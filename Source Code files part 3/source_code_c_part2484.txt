break;
			case 1:
				p1  = vpt->SnapPoint(m,m,NULL,snapdim);
				float x=Length(p1-p0);
				ob->pblock->SetValue(PB_ICONSIZE,0,x);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT)
				{	if (Length(m-sp0)<3) return CREATE_ABORT;
					else return CREATE_STOP;
				}
				break;
		}
	}
	else
	{	if (msg == MOUSE_ABORT)
		return CREATE_ABORT;
	}
	return TRUE;
}

static ForceObjCreateCallback ForceCreateCB;

CreateMouseCallBack* ForceObject::GetCreateMouseCallBack()
{	ForceCreateCB.ob = this;
	return &ForceCreateCB;
}

void ForceObject::InvalidateUI() 
{	if (pmapParam) pmapParam->Invalidate();}

Modifier *ForceObject::CreateWSMMod(INode *node)
{	return new ForceMod(node,this);}

RefTargetHandle ForceObject::Clone(RemapDir& remap) 
{	ForceObject* newob = new ForceObject();
	newob->ReplaceReference(0,pblock->Clone(remap));
	return newob;
}

ParamDimension *ForceObject::GetParameterDim(int pbIndex) 
{	switch (pbIndex)
	{	case PB_ONTIME:		return stdTimeDim;
		case PB_OFFTIME:	return stdTimeDim;
		case PB_TIMEPER1:	return stdTimeDim;
		case PB_TIMEPER2:	return stdTimeDim;
		case PB_PHASPER1:	return stdAngleDim;
		case PB_PHASPER2:	return stdAngleDim;
		default: return defaultDim;
	}
}

TSTR ForceObject::GetParameterName(int pbIndex) 
{	switch (pbIndex)
	{	case PB_ONTIME:		return GetString(IDS_AP_ONTIME);
		case PB_OFFTIME:	return GetString(IDS_AP_OFFTIME);
		case PB_STRENGTH:	return GetString(IDS_AP_STRENGTH);
		case PB_UNITS:		return GetString(IDS_AP_UNITS);
		case PB_FEEDBACKON:	return GetString(IDS_AP_FEEDBACKON);
		case PB_REVERSIBLE:	return GetString(IDS_AP_REVERSIBLE);
		case PB_TARGETVEL:	return GetString(IDS_AP_TARGETVEL);
		case PB_CONTROLGAIN:return GetString(IDS_AP_CONTROLGAIN);
		case PB_ENABLESINES:return GetString(IDS_AP_ENABLESINES);
		case PB_TIMEPER1:	return GetString(IDS_AP_TIMEPER1);
		case PB_AMP1:		return GetString(IDS_AP_AMP1);
		case PB_PHASPER1:	return GetString(IDS_AP_PHASPER1);
		case PB_TIMEPER2:	return GetString(IDS_AP_TIMEPER2);
		case PB_AMP2:		return GetString(IDS_AP_AMP2);
		case PB_PHASPER2:	return GetString(IDS_AP_PHASPER2);
		case PB_RANGEON:	return GetString(IDS_AP_RANGEON);
		case PB_RANGEVAL:	return GetString(IDS_AP_RANGEVAL);
		case PB_ICONSIZE:	return GetString(IDS_AP_ICONSIZE);
		default: 			return TSTR(_T(""));
	}
}

ParamUIDesc *ForceObject::UIDesc()
{	return descParamForce;}

int ForceObject::UIDescLength()
{	return FORCEPARAMDESC_LENGTH;}

TSTR ForceObject::UIStrName()
{   return GetString(IDS_AP_FORCEPARAM);}


ForceMod::ForceMod(INode *node,ForceObject *obj)
{	//MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);
	pblock = NULL;
	obRef = NULL;
	}

Interval ForceMod::GetValidity(TimeValue t) 
{	if (nodeRef)
	{	Interval valid=FOREVER;
		Matrix3 tm;
		float f;
		TimeValue tt;
		((ForceObject*)GetWSMObject(t))->pblock->GetValue(PB_STRENGTH,t,f,valid);
		((ForceObject*)GetWSMObject(t))->pblock->GetValue(PB_TARGETVEL,t,f,valid);
		((ForceObject*)GetWSMObject(t))->pblock->GetValue(PB_CONTROLGAIN,t,f,valid);
		((ForceObject*)GetWSMObject(t))->pblock->GetValue(PB_TIMEPER1,t,tt,valid);
		((ForceObject*)GetWSMObject(t))->pblock->GetValue(PB_TIMEPER2,t,tt,valid);
		((ForceObject*)GetWSMObject(t))->pblock->GetValue(PB_PHASPER1,t,f,valid);
		((ForceObject*)GetWSMObject(t))->pblock->GetValue(PB_PHASPER2,t,f,valid);
		((ForceObject*)GetWSMObject(t))->pblock->GetValue(PB_AMP1,t,f,valid);
		((ForceObject*)GetWSMObject(t))->pblock->GetValue(PB_AMP2,t,f,valid);
		((ForceObject*)GetWSMObject(t))->pblock->GetValue(PB_RANGEVAL,t,f,valid);
		tm=nodeRef->GetObjectTM(t,&valid);
		return valid;
	}
	else
	{	return FOREVER;
	}
}

class ForceDeformer : public Deformer
{	public:		
	Point3 Map(int i, Point3 p) {return p;}
};
static ForceDeformer gdeformer;

Deformer& ForceMod::GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
{	return gdeformer;}

RefTargetHandle ForceMod::Clone(RemapDir& remap) 
{	ForceMod *newob = new ForceMod(nodeRef,(ForceObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
}

void ForceMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
{	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj)
	{	force.obj=(ForceObject*)GetWSMObject(t);
		force.node=nodeRef;
		force.tmValid.SetEmpty();
		force.fValid.SetEmpty();
		force.dt=GetTicksPerFrame();
		force.dtsq=force.dt*force.dt;
		obj->ApplyForceField(&force);
	}
}

Point3 PtForceField::Force(TimeValue t,const Point3 &pos, const Point3 &vel,int index)
{	Point3 ApplyAt,OutForce,zdir;
	fValid= FOREVER;		
	if (!tmValid.InInterval(t)) 
	{	tmValid=FOREVER;
		tm=node->GetObjectTM(t,&tmValid);
		invtm=Inverse(tm);
	}
	ApplyAt=tm.GetTrans();
	fValid&=tmValid;
	TimeValue t1,t2;
	obj->pblock->GetValue(PB_ONTIME,t,t1,fValid);
	obj->pblock->GetValue(PB_OFFTIME,t,t2,fValid);
	if ((t>=t1)&&(t<=t2))
	{	float BaseF;
		zdir=tm.GetRow(2);
		obj->pblock->GetValue(PB_STRENGTH,t,BaseF,fValid); //assume N
		int tpf=GetTicksPerFrame();
		//int tpf2=tpf*tpf;
		int tps=TIME_TICKSPERSEC;
		int tps2=tps*tps;
		//int FToTick=(int)((float)tps/(float)GetFrameRate());
		BaseF/=(float)tps2;//convert to kg-m/t2
		BaseF*=100.0f; //convert to kg-cm/t2
		int UnitsVal;
		obj->pblock->GetValue(PB_UNITS,t,UnitsVal,fValid);
		if (UnitsVal!=0) BaseF*=4.4591f; //lbf is this much larger than N=kg-m/s2
		TimeValue tage=t-t1;
		TimeValue Per1,Per2;
		obj->pblock->GetValue(PB_TIMEPER1,t,Per1,fValid);
		obj->pblock->GetValue(PB_TIMEPER2,t,Per2,fValid);
		float scalefactor=1.0f;
		int sintoggle;
		obj->pblock->GetValue(PB_ENABLESINES,t,sintoggle,fValid);
		if (sintoggle)
		{	if (Per1>0)
			{	float phase1,amp1;
				float relage1=(float)tage/(float)Per1;
				obj->pblock->GetValue(PB_PHASPER1,t,phase1,fValid);
				obj->pblock->GetValue(PB_AMP1,t,amp1,fValid);
				scalefactor+=0.01f*amp1*(float)sin(TWOPI*relage1+phase1);
			}
			if (Per2>0)
			{	float phase2,amp2;
				float relage2=(float)tage/(float)Per2;
				obj->pblock->GetValue(PB_PHASPER2,t,phase2,fValid);
				obj->pblock->GetValue(PB_AMP2,t,amp2,fValid);
				scalefactor+=0.01f*amp2*(float)sin(TWOPI*relage2+phase2);
			}
		}
		int feedback;
		obj->pblock->GetValue(PB_FEEDBACKON,t,feedback,fValid);
		float scalefactorg=1.0f;
		if (feedback)
		{	float targetspeed,loopgain;
			obj->pblock->GetValue(PB_TARGETVEL,t,targetspeed,fValid);
			targetspeed/=(float)tpf;
			obj->pblock->GetValue(PB_CONTROLGAIN,t,loopgain,fValid);
			float diffspeed=targetspeed-DotProd(vel,zdir);
			//scalefactorg*=diffspeed*loopgain/(float)tpf;
			scalefactorg*=diffspeed*loopgain/100.0f;
			int revon;
			obj->pblock->GetValue(PB_REVERSIBLE,t,revon,fValid);
			if ((!revon)&&(scalefactorg<0.0f)) scalefactorg=0.0f;
		}
		OutForce=zdir*BaseF*scalefactor*scalefactorg;
		int rangeon;
		obj->pblock->GetValue(PB_RANGEON,t,rangeon,fValid);
		if (rangeon)
		{	float maxrange;
			obj->pblock->GetValue(PB_RANGEVAL,t,maxrange,fValid);
			if (maxrange>FLOAT_EPSILON)
			{	float distance=Length(ApplyAt-pos);
				if (distance<maxrange) OutForce*=(1.0f-distance/maxrange);
				else OutForce=Zero;
			}
		}
	}
	else OutForce=Zero;
	return OutForce*6.25e-03f;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\dynwarps\dynw.h ===
#ifndef __DYNWARPS__H
#define __DYNWARPS__H

#include "Max.h"
#include "dynwarps.h"
#include "Simpobj.h"

TCHAR *GetString(int id);

extern ClassDesc* GetForceObjDesc();
extern ClassDesc* GetForceModDesc();
extern ClassDesc* GetMotorObjDesc();
extern ClassDesc* GetMotorModDesc();
extern ClassDesc* GetPinObjDesc();
extern ClassDesc* GetPinModDesc();

extern HINSTANCE hInstance;
extern int RNDSign();
extern float RND01();
extern float RND11();
extern int RND0x(int maxnum);

const float FLOAT_EPSILON=0.005f;
const float HalfPI=1.570796327f;
const float PIOver5=0.62831853f;
const float FTOIEPS=0.000001f;
const float PRECISION_LIMIT=1.0e-15f;
const float SQR2=1.1414f;
const float SMALL_EPSILON=0.005f;
const int row3size=3*sizeof(float);
const Point3 v111=Point3(0.450f,0.218f,0.732f);
extern Point3 Zero;
const Point3 deftex=Point3(0.5f,0.5f,0.0f);
const int NoAni=-9999;

typedef float Matrix4By4[4][4];
typedef float Matrix3By4[3][4];

static Matrix3 ident(1);

extern void Mult4X4(Matrix4By4 A,Matrix4By4 B,Matrix4By4 C);
extern void RotatePoint(Matrix3By4 Pin,float *Q, float *W,float Theta);
extern void RotateOnePoint(float *Pin,float *Q, float *W,float Theta);
extern int FloatEQ0(float number);
extern int SmallerEQ0(float number);
extern int FGT0(Point3 p1);
extern void Mult4X1(float *A,Matrix4By4 B,float *C);
extern int MatrixInvert(Matrix4By4 in,Matrix4By4 out);
extern BOOL CALLBACK DefaultSOTProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
extern void TurnButton(HWND hWnd,int SpinNum,BOOL ison);
extern void SpinnerOn(HWND hWnd,int SpinNum,int Winnum);
extern void SpinnerOff(HWND hWnd,int SpinNum,int Winnum);
extern Point3 CalcSpread(float divangle,Point3 oldnorm);
extern TriObject *TriIsUseable(Object *pobj,TimeValue t);
extern void VectorVar(Point3 *vel,float R,float MaxAngle);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\dynwarps\motor.cpp ===
/*****************************************************************************
 *<
	FILE: motor.cpp

	DESCRIPTION: motor icon for Dynamics / Force field for Particles

	CREATED BY: Eric Peterson (from Audrey's PBOMB.CPP)

	HISTORY: 6/97

 *>	Copyright (c) 1997, All Rights Reserved, assigned to, and for Yost Group Inc.
 *****************************************************************************/
#include "dynwarps.h"
#include "dynw.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"

static Class_ID MOTOR_CLASS_ID(0x63081cea, 0x1fc549db);
static Class_ID MOTORMOD_CLASS_ID(0x26712b4d, 0x2213417);

class MotorObject : public SimpleWSMObject
{	public:									
		MotorObject();		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
		ForceField *GetForceField(INode *node);
		BOOL SupportsDynamics() {return TRUE;}

		// From Animatable		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		void MapKeys(TimeMap *map,DWORD flags);

		// From BaseObject
		IParamArray *GetParamBlock() {return pblock;}
		int GetParamBlockIndex(int id) {return id;}
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack();		
		
		// From SimpleWSMObject		
		void InvalidateUI();		

		// From Animatable		
		void DeleteThis() {delete this;}		
		Class_ID ClassID() {return MOTOR_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_AP_MOTOR);}
						
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);
		
		// From SimpleWSMObject				
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void BuildMesh(TimeValue t);

		int DialogID() {return IDD_SW_DYNMOTOR;}
		ParamUIDesc *UIDesc();
		int UIDescLength();
		TSTR UIStrName();
	};

IObjParam *MotorObject::ip        = NULL;
IParamMap *MotorObject::pmapParam = NULL;
HWND       MotorObject::hSot      = NULL;

class MotorClassDesc:public ClassDesc
{	public:
		int 			IsPublic() {return 1;}
		void *			Create(BOOL loading = FALSE) { return new MotorObject;}
		const TCHAR *	ClassName() {return GetString(IDS_AP_MOTOR_CLASS);}
		SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
		Class_ID		ClassID() {return MOTOR_CLASS_ID;}
		const TCHAR* 	Category() {return GetSpaceWarpCatString(SPACEWARP_CAT_PARTICLE);}
};

static MotorClassDesc MotorDesc;
ClassDesc* GetMotorObjDesc() {return &MotorDesc;}

class MotorMod;

class MotorField : public ForceField
{	public:
		MotorObject *obj;
		TimeValue dtsq,dt;
		INode *node;
		int count;
		Matrix3 tm,invtm;
		Interval tmValid;
		Point3 force;
		Interval fValid;
		Point3 Force(TimeValue t,const Point3 &pos, const Point3 &vel, int index);
};

class MotorMod : public SimpleWSMMod
{	public:				
		MotorField force;
		MotorMod() {}
		MotorMod(INode *node,MotorObject *obj);		
		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_AP_MOTORMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return MOTORMOD_CLASS_ID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_AP_MOTORBINDING);}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
};

class MotorModClassDesc:public ClassDesc
{	public:
		int 			IsPublic() { return 0; }
		void *			Create(BOOL loading = FALSE) {return new MotorMod;}
		const TCHAR *	ClassName() { return GetString(IDS_AP_MOTORMOD);}
		SClass_ID		SuperClassID() {return WSM_CLASS_ID;}
		Class_ID		ClassID() {return MOTORMOD_CLASS_ID;}
		const TCHAR* 	Category() {return _T("");}
};

static MotorModClassDesc MotorModDesc;

ClassDesc* GetMotorModDesc() {return &MotorModDesc;}

class MotorModData : public LocalModData
{	public:
		LocalModData *Clone ();
};

LocalModData *MotorModData::Clone ()
{	MotorModData *clone;
	clone = new MotorModData ();
	return(clone);
}

//--- MotorObject Parameter map/block descriptors ------------------
#define PB_ONTIME			0
#define PB_OFFTIME			1
#define PB_STRENGTH			2
#define PB_UNITS			3
#define PB_FEEDBACKON		4 
#define PB_REVERSIBLE		5
#define PB_TARGETVEL		6
#define PB_REVSUNITS		7
#define PB_CONTROLGAIN		8
#define PB_ENABLESINES		9
#define PB_TIMEPER1			10
#define PB_AMP1				11
#define PB_PHASPER1			12
#define PB_TIMEPER2			13
#define PB_AMP2				14
#define PB_PHASPER2			15
#define PB_RANGEON			16
#define PB_RANGEVAL			17
#define PB_ICONSIZE			18

static int UnitsIDs[] = {IDC_AP_TINNM,IDC_AP_TINLBFT,IDC_AP_TINLBIN};
static int RevUnitsIDs[] = {IDC_AP_REVSRPH,IDC_AP_REVSRPM,IDC_AP_REVSRPS};

static ParamUIDesc descParamMotor[] = {

	// Motor Time On
	ParamUIDesc(
		PB_ONTIME,
		EDITTYPE_TIME,
		IDC_AP_MOTORONT,IDC_AP_MOTORONTSPIN,
		-999999999.0f,999999999.0f,
		10.0f),
	
	// Motor Time Off
	ParamUIDesc(
		PB_OFFTIME,
		EDITTYPE_TIME,
		IDC_AP_MOTOROFFT,IDC_AP_MOTOROFFTSPIN,
		-999999999.0f,999999999.0f,
		10.0f),
	
	// Strength
	ParamUIDesc(
		PB_STRENGTH,
		EDITTYPE_FLOAT,
		IDC_AP_TVALUE,IDC_AP_TVALUESPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Torque Units
	ParamUIDesc(PB_UNITS,TYPE_RADIO,UnitsIDs,3),

	// Feedback
	ParamUIDesc(PB_FEEDBACKON,TYPE_SINGLECHEKBOX,IDC_AP_FEEDBACKON),

	// Reversible
	ParamUIDesc(PB_REVERSIBLE,TYPE_SINGLECHEKBOX,IDC_AP_REVERSIBLET),
	
	// Target Revs
	ParamUIDesc(
		PB_TARGETVEL,
		EDITTYPE_FLOAT,
		IDC_AP_CONTROLPT,IDC_AP_CONTROLPTSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Revs Units
	ParamUIDesc(PB_REVSUNITS,TYPE_RADIO,RevUnitsIDs,3),

	// Gain
	ParamUIDesc(
		PB_CONTROLGAIN,
		EDITTYPE_FLOAT,
		IDC_AP_GAIN,IDC_AP_GAINSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Reversible
	ParamUIDesc(PB_ENABLESINES,TYPE_SINGLECHEKBOX,IDC_AP_VARIATIONON),
	
	// Period 1
	ParamUIDesc(
		PB_TIMEPER1,
		EDITTYPE_TIME,
		IDC_AP_AMPVART1,IDC_AP_AMPVART1SPIN,
		0.0f,999999999.0f,
		10.0f),

	// Amp 1
	ParamUIDesc(
		PB_AMP1,
		EDITTYPE_FLOAT,
		IDC_AP_AMPAMP1M,IDC_AP_AMPAMP1MSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Phase 1
	ParamUIDesc(
		PB_PHASPER1,
		EDITTYPE_FLOAT,
		IDC_AP_AMPPHAS1T,IDC_AP_AMPPHAS1TSPIN,
		0.0f,360.0f,
		SPIN_AUTOSCALE),

	// Period 2
	ParamUIDesc(
		PB_TIMEPER2,
		EDITTYPE_TIME,
		IDC_AP_AMPVART2T,IDC_AP_AMPVART2TSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Amp 2
	ParamUIDesc(
		PB_AMP2,
		EDITTYPE_FLOAT,
		IDC_AP_AMPAMP2M,IDC_AP_AMPAMP2MSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Phase 2
	ParamUIDesc(
		PB_PHASPER2,
		EDITTYPE_FLOAT,
		IDC_AP_AMPPHAS2T,IDC_AP_AMPPHAS2TSPIN,
		0.0f,360.0f,
		SPIN_AUTOSCALE),

	// Range on
	ParamUIDesc(PB_RANGEON,TYPE_SINGLECHEKBOX,IDC_AP_RANGEM),

	// Range Value
	ParamUIDesc(
		PB_RANGEVAL,
		EDITTYPE_UNIVERSE,
		IDC_AP_RANGEVALM,IDC_AP_RANGEVALMSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Icon Size
	ParamUIDesc(
		PB_ICONSIZE,
		EDITTYPE_UNIVERSE,
		IDC_AP_DTORK_ICONSIZE,IDC_AP_DTORK_ICONSIZESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	};

#define MOTORPARAMDESC_LENGTH	19

ParamBlockDescID descMotorVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	// PB_ONTIME
	{ TYPE_INT, NULL, FALSE, 1 },	// PB_OFFTIME
	{ TYPE_FLOAT, NULL, TRUE, 2 },	// PB_STRENGTH
	{ TYPE_INT, NULL, FALSE, 3 },	// PB_UNITS
	{ TYPE_INT, NULL, FALSE, 4 },	// PB_FEEDBACKON
	{ TYPE_INT, NULL, FALSE, 5 },	// PB_REVERSIBLE
	{ TYPE_FLOAT, NULL, TRUE, 6 },	// PB_TARGETVEL
	{ TYPE_INT, NULL, FALSE, 7 },	// PB_REVSUNITS
	{ TYPE_FLOAT, NULL, TRUE, 8 },  // PB_CONTROLGAIN
	{ TYPE_INT, NULL, FALSE, 9 },   // PB_ENABLESINES
	{ TYPE_INT, NULL, TRUE, 10 },   // PB_TIMEPER1
	{ TYPE_FLOAT, NULL, TRUE, 11 }, // PB_AMP1
	{ TYPE_FLOAT, NULL, TRUE, 12 }, // PB_PHASPER1
	{ TYPE_INT, NULL, TRUE, 13 },   // PB_TIMEPER2
	{ TYPE_FLOAT, NULL, TRUE, 14 }, // PB_AMP2
	{ TYPE_FLOAT, NULL, TRUE, 15 }, // PB_PHASPER2
	{ TYPE_INT, NULL, FALSE, 16 },  // PB_RANGEON
	{ TYPE_FLOAT, NULL, TRUE, 17 }, // PB_RANGE
	{ TYPE_FLOAT, NULL, FALSE, 18 } // PB_ICONSIZE
	};

#define PBLOCK_LENGTH	19

#define CURRENT_VERSION	0


//--- Deflect object methods -----------------------------------------

MotorObject::MotorObject()
{	int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
	MakeRefByID(FOREVER, 0,CreateParameterBlock(descMotorVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);	
	pblock->SetValue(PB_ONTIME,0,0);
	pblock->SetValue(PB_OFFTIME,0,FToTick*30);
	pblock->SetValue(PB_STRENGTH,0,1.0f);
	pblock->SetValue(PB_UNITS,0,0);
	pblock->SetValue(PB_FEEDBACKON,0,0);
	pblock->SetValue(PB_REVERSIBLE,0,0);
	pblock->SetValue(PB_REVSUNITS,0,1);
	pblock->SetValue(PB_CONTROLGAIN,0,50.0f);
	pblock->SetValue(PB_TARGETVEL,0,100.0f);
	pblock->SetValue(PB_ENABLESINES,0,0);
	pblock->SetValue(PB_TIMEPER1,0,100);
	pblock->SetValue(PB_AMP1,0,100.0f);
	pblock->SetValue(PB_PHASPER1,0,0.0f);
	pblock->SetValue(PB_TIMEPER2,0,100);
	pblock->SetValue(PB_AMP2,0,100.0f);
	pblock->SetValue(PB_PHASPER2,0,0.0f);
	pblock->SetValue(PB_RANGEON,0,0);
	pblock->SetValue(PB_RANGEVAL,0,1000.0f);
}

class MotorDlgProc : public ParamMapUserDlgProc
{	public:
		MotorObject *po;
		HWND hwnd;
		MotorDlgProc(MotorObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DoFeedback();
		void DoEnableVar();
		void DoRange();
		void DeleteThis() {delete this;}
};
void MotorDlgProc::DoFeedback()
{ int feedbackon;
  po->pblock->GetValue(PB_FEEDBACKON,0,feedbackon,FOREVER);
  if (feedbackon)
  {	SpinnerOn(hwnd,IDC_AP_CONTROLPTSPIN,IDC_AP_CONTROLPT);
 	SpinnerOn(hwnd,IDC_AP_GAINSPIN,IDC_AP_GAIN);
  }
  else
  {	SpinnerOff(hwnd,IDC_AP_CONTROLPTSPIN,IDC_AP_CONTROLPT);
	SpinnerOff(hwnd,IDC_AP_GAINSPIN,IDC_AP_GAIN);
  }
  EnableWindow(GetDlgItem(hwnd,IDC_AP_REVERSIBLET),feedbackon);
  EnableWindow(GetDlgItem(hwnd,IDC_AP_REVSRPH),feedbackon);
  EnableWindow(GetDlgItem(hwnd,IDC_AP_REVSRPM),feedbackon);
  EnableWindow(GetDlgItem(hwnd,IDC_AP_REVSRPS),feedbackon);
}
void MotorDlgProc::DoEnableVar()
{ int enablevar;
  po->pblock->GetValue(PB_ENABLESINES,0,enablevar,FOREVER);
  if (enablevar)
  {	SpinnerOn(hwnd,IDC_AP_AMPVART1SPIN,IDC_AP_AMPVART1);
	SpinnerOn(hwnd,IDC_AP_AMPAMP1MSPIN,IDC_AP_AMPAMP1M);
	SpinnerOn(hwnd,IDC_AP_AMPPHAS1TSPIN,IDC_AP_AMPPHAS1T);
	SpinnerOn(hwnd,IDC_AP_AMPVART2TSPIN,IDC_AP_AMPVART2T);
	SpinnerOn(hwnd,IDC_AP_AMPAMP2MSPIN,IDC_AP_AMPAMP2M);
	SpinnerOn(hwnd,IDC_AP_AMPPHAS2TSPIN,IDC_AP_AMPPHAS2T);
  }
  else
  {	SpinnerOff(hwnd,IDC_AP_AMPVART1SPIN,IDC_AP_AMPVART1);
	SpinnerOff(hwnd,IDC_AP_AMPAMP1MSPIN,IDC_AP_AMPAMP1M);
	SpinnerOff(hwnd,IDC_AP_AMPPHAS1TSPIN,IDC_AP_AMPPHAS1T);
	SpinnerOff(hwnd,IDC_AP_AMPVART2TSPIN,IDC_AP_AMPVART2T);
	SpinnerOff(hwnd,IDC_AP_AMPAMP2MSPIN,IDC_AP_AMPAMP2M);
	SpinnerOff(hwnd,IDC_AP_AMPPHAS2TSPIN,IDC_AP_AMPPHAS2T);
  }
}
void MotorDlgProc::DoRange()
{ int enablerng;
  po->pblock->GetValue(PB_RANGEON,0,enablerng,FOREVER);
  if (enablerng) 
	SpinnerOn(hwnd,IDC_AP_RANGEVALMSPIN,IDC_AP_RANGEVALM);
  else
	SpinnerOff(hwnd,IDC_AP_RANGEVALMSPIN,IDC_AP_RANGEVALM);
}

void MotorDlgProc::Update(TimeValue t)
{ DoFeedback();
  DoEnableVar();
  DoRange();
}

BOOL MotorDlgProc::DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) 
	{	case WM_INITDIALOG: 
		{	hwnd=hWnd;
			Update(t);
			break;
		}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{	case IDC_AP_FEEDBACKON:
					DoFeedback();
					return TRUE;
				case IDC_AP_VARIATIONON:
					DoEnableVar();
					return TRUE;
				case IDC_AP_RANGEM:
					DoRange();
					return TRUE;
				default: return TRUE;
			}
	}
	return FALSE;
}

/*
BOOL MotorDlgProc::DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) 
	{	case WM_INITDIALOG: 
		{	break;
		}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{	default: return TRUE;
			}
	}
	return FALSE;
}
*/

void MotorObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
{	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;
	if (pmapParam)
	{	// Left over
		pmapParam->SetParamBlock(pblock);
	}
	else
	{	hSot = ip->AddRollupPage(hInstance,MAKEINTRESOURCE(IDD_SW_DESC),DefaultSOTProc,GetString(IDS_AP_TOP),(LPARAM)ip,APPENDROLL_CLOSED);
		// Gotta make a new one.
		pmapParam = CreateCPParamMap(descParamMotor,MOTORPARAMDESC_LENGTH,pblock,ip,hInstance,MAKEINTRESOURCE(IDD_SW_DYNMOTOR),GetString(IDS_AP_PARAMETERS),0);
	}
	if (pmapParam) pmapParam->SetUserDlgProc(new MotorDlgProc(this));
}

void MotorObject::EndEditParams(IObjParam *ip,ULONG flags,Animatable *next)
{	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;
	if (flags&END_EDIT_REMOVEUI )
	{	DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
	}	
}

void MotorObject::MapKeys(TimeMap *map,DWORD flags)
{	TimeValue TempTime;
// mapped values
	pblock->GetValue(PB_ONTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_ONTIME,0,TempTime);
	pblock->GetValue(PB_OFFTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_OFFTIME,0,TempTime);
// scaled values
	pblock->GetValue(PB_TIMEPER1,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEPER1,0,TempTime);
	pblock->GetValue(PB_TIMEPER2,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEPER2,0,TempTime);
}

#define NUM_SEGS 12
#define NUM_SEGS2 24

void MotorObject::BuildMesh(TimeValue t)
{	ivalid = FOREVER;
	float l1,l2,l3,r1,r2,length;
	pblock->GetValue(PB_ICONSIZE,t,length,ivalid);
	int dorange,dofrange=0,norvs,norfs;
	pblock->GetValue(PB_RANGEON,t,dorange,ivalid);
	if (dorange){ dorange=73;dofrange=72;}
	l1=0.0f;
	l2=0.25f*length;
	l3=length;
	r1=length/1.5f;
	r2=r1/2.0f;
	float u,cosu,sinu,r1cosu,r2cosu,r1sinu,r2sinu;
	mesh.setNumVerts((norvs=75)+dorange);
	mesh.setNumFaces((norfs=76)+dofrange);
	int i,i2,i3,i4,i5;
	i2=NUM_SEGS;
	i3=2*NUM_SEGS;
	i4=3*NUM_SEGS;
	i5=4*NUM_SEGS;
    for (i=0;i<NUM_SEGS;i++)
    {	u=float(i)/float(NUM_SEGS)*TWOPI;
		cosu=(float)cos(u);sinu=(float)sin(u);
		r1cosu=r1*cosu;r1sinu=r1*sinu;
		r2cosu=r2*cosu;r2sinu=r2*sinu;
		mesh.setVert(i,   Point3(r1cosu,r1sinu,-l3));
		mesh.setVert(i+i2,Point3(r1cosu,r1sinu,-l2));
		mesh.setVert(i+i3,Point3(r2cosu,r2sinu,-l2));
		mesh.setVert(i+i4,Point3(r2cosu,r2sinu,-l1));
	}
    mesh.setVert(i5  ,Point3(0.0f,0.0f,-l3));
    mesh.setVert(i5+1,Point3(0.0f,0.0f,-l2));
    mesh.setVert(i5+2,Point3(0.0f,0.0f,-l1));
    for (i=0;i<NUM_SEGS;i++) 
    {	int v,v2,v3,v4;
		if (i>(NUM_SEGS-2))
		{	v=0;
			v2=i2;
			v3=i3;
			v4=i4;
		}
		else
		{	v=i+1;
			v2=v+i2;
			v3=v+i3;
			v4=v+i4;
		}
		mesh.faces[i].setEdgeVisFlags(1,0,0);
	    mesh.faces[i].setSmGroup(0);
	    mesh.faces[i].setVerts(i,v,i5);
		int ii2=i+i2;
		mesh.faces[ii2].setEdgeVisFlags(1,0,0);
	    mesh.faces[ii2].setSmGroup(0);
	    mesh.faces[ii2].setVerts(ii2,v2,i5+1);
		int ii3=i+i3;
		mesh.faces[ii3].setEdgeVisFlags(1,0,0);
	    mesh.faces[ii3].setSmGroup(0);
	    mesh.faces[ii3].setVerts(ii3,v3,i5+1);
		int ii4=i+i4;
		mesh.faces[ii4].setEdgeVisFlags(1,0,0);
	    mesh.faces[ii4].setSmGroup(0);
	    mesh.faces[ii4].setVerts(ii4,v4,i5+2);
    }
	float r3,w,r4,r5,r3cosu,r3sinu,r4cosu,r4sinu;;
	w=r2/3.0f;
	r3=r1-w/2.0f;;
	r4=r3+w;
	r5=(r3+r4)/2.0f;
	for (i=0;i<10;i++)
    {	int ii=i+i;
		u=float(i)/float(NUM_SEGS)*TWOPI;
		cosu=(float)cos(u);sinu=(float)sin(u);
		r3cosu=r3*cosu;r3sinu=r3*sinu;
		r4cosu=r4*cosu;r4sinu=r4*sinu;
		mesh.setVert(ii+51,Point3(r4cosu,r4sinu,-l1));
		mesh.setVert(ii+52,Point3(r3cosu,r3sinu,-l1));
	}
	mesh.setVert(71,Point3(r4,-w,-l1));
	mesh.setVert(72,Point3(0.0f,-r3+w,-l1));
	mesh.setVert(73,Point3(0.0f,-r4-w,-l1));
	mesh.setVert(74,Point3(3.0f*w,-r5,-l1));
	for (i=0;i<17;i+=2)
	{	mesh.faces[i+56].setEdgeVisFlags(1,0,0);
		mesh.faces[i+56].setSmGroup(2);
	    mesh.faces[i+56].setVerts(i+51,i+53,i+52);
		mesh.faces[i+57].setEdgeVisFlags(0,0,1);
		mesh.faces[i+57].setSmGroup(2);
	    mesh.faces[i+57].setVerts(i+52,i+53,i+54);
	}
	mesh.faces[48].setEdgeVisFlags(1,0,0);
    mesh.faces[48].setSmGroup(2);
    mesh.faces[48].setVerts(0,12,6);
	mesh.faces[49].setEdgeVisFlags(0,0,1);
    mesh.faces[49].setSmGroup(2);
    mesh.faces[49].setVerts(6,12,18);
	mesh.faces[50].setEdgeVisFlags(1,0,0);
    mesh.faces[50].setSmGroup(2);
    mesh.faces[50].setVerts(3,15,9);
	mesh.faces[51].setEdgeVisFlags(0,0,1);
    mesh.faces[51].setSmGroup(2);
    mesh.faces[51].setVerts(9,15,21);
	mesh.faces[52].setEdgeVisFlags(1,0,0);
    mesh.faces[52].setSmGroup(2);
    mesh.faces[52].setVerts(24,36,30);
	mesh.faces[53].setEdgeVisFlags(0,0,1);
    mesh.faces[53].setSmGroup(2);
    mesh.faces[53].setVerts(30,36,42);
	mesh.faces[54].setEdgeVisFlags(1,0,0);
    mesh.faces[54].setSmGroup(2);
    mesh.faces[54].setVerts(27,39,33);
	mesh.faces[55].setEdgeVisFlags(0,0,1);
    mesh.faces[55].setSmGroup(2);
    mesh.faces[55].setVerts(33,39,45);
	mesh.faces[74].setEdgeVisFlags(1,0,1);
	mesh.faces[74].setSmGroup(2);
    mesh.faces[74].setVerts(71,51,52);
	mesh.faces[75].setEdgeVisFlags(1,1,1);
	mesh.faces[75].setSmGroup(2);
    mesh.faces[75].setVerts(72,73,74);
	if (dorange)
	{   int newv;
		pblock->GetValue(PB_RANGEVAL,t,length,ivalid);
		for (int i=0; i<NUM_SEGS2; i++)
	    { u = float(i)/float(NUM_SEGS2) * TWOPI;
		  mesh.setVert(i+norvs, Point3((float)cos(u) * length, (float)sin(u) * length, 0.0f));
	    }
		newv=NUM_SEGS2+norvs;
	    for (i=0; i<NUM_SEGS2; i++) 
	    { u = float(i)/float(NUM_SEGS2) * TWOPI;
		  mesh.setVert(i+newv, Point3(0.0f, (float)cos(u) * length, (float)sin(u) * length));
	    } newv+=NUM_SEGS2;
	    for (i=0; i<NUM_SEGS2; i++)
	    { u = float(i)/float(NUM_SEGS2) * TWOPI;
		  mesh.setVert(i+newv, Point3((float)cos(u) * length, 0.0f, (float)sin(u) * length));
	    }	
		newv+=NUM_SEGS2;
	    mesh.setVert(newv, Point3(0.0f, 0.0f, 0.0f));
		int vi=norvs;
	    for (i=norfs; i<norfs+dofrange; i++) 
	    { int i1 = vi+1;
	      if ((i1-norvs)%NUM_SEGS2==0) i1 -= NUM_SEGS2;
	      mesh.faces[i].setEdgeVisFlags(1,0,0);
	      mesh.faces[i].setSmGroup(0);
	      mesh.faces[i].setVerts(vi,i1,newv);
		  vi++;
		}
	}
	mesh.InvalidateGeomCache();
}

class MotorObjCreateCallback : public CreateMouseCallBack
{	public:
		MotorObject *ob;	
		Point3 p0,p1;
		IPoint2 sp0;
		int proc(ViewExp *vpt,int msg,int point,int flags,IPoint2 m,Matrix3& mat);
};

int MotorObjCreateCallback::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
{
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE)
	 {	switch(point)
		{	case 0:								
				// if hidden by category, re-display particles and objects
				GetCOREInterface()->SetHideByCategoryFlags(GetCOREInterface()->GetHideByCategoryFlags() & ~(HIDE_OBJECTS|HIDE_PARTICLES));
				sp0 = m;
				p0  = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				break;
			case 1:
				p1  = vpt->SnapPoint(m,m,NULL,snapdim);
				float x=Length(p1-p0);
				ob->pblock->SetValue(PB_ICONSIZE,0,x);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT)
				{	if (Length(m-sp0)<3) return CREATE_ABORT;
					else return CREATE_STOP;
				}
				break;
		}
	}
	else
	{	if (msg == MOUSE_ABORT)
		return CREATE_ABORT;
	}
	return TRUE;
}

static MotorObjCreateCallback MotorCreateCB;

CreateMouseCallBack* MotorObject::GetCreateMouseCallBack()
{	MotorCreateCB.ob = this;
	return &MotorCreateCB;
}

void MotorObject::InvalidateUI() 
{	if (pmapParam) pmapParam->Invalidate();}

Modifier *MotorObject::CreateWSMMod(INode *node)
{	return new MotorMod(node,this);}

RefTargetHandle MotorObject::Clone(RemapDir& remap) 
{	MotorObject* newob = new MotorObject();
	newob->ReplaceReference(0,pblock->Clone(remap));
	return newob;
}

ParamDimension *MotorObject::GetParameterDim(int pbIndex) 
{	switch (pbIndex)
	{	case PB_ONTIME:		return stdTimeDim;
		case PB_OFFTIME:	return stdTimeDim;
		case PB_TIMEPER1:	return stdTimeDim;
		case PB_TIMEPER2:	return stdTimeDim;
		case PB_PHASPER1:	return stdAngleDim;
		case PB_PHASPER2:	return stdAngleDim;
		default: return defaultDim;
	}
}

TSTR MotorObject::GetParameterName(int pbIndex) 
{	switch (pbIndex)
	{	case PB_ONTIME:		return GetString(IDS_AP_ONTIME);
		case PB_OFFTIME:	return GetString(IDS_AP_OFFTIME);
		case PB_STRENGTH:	return GetString(IDS_AP_STRENGTHT);
		case PB_UNITS:		return GetString(IDS_AP_UNITS);
		case PB_FEEDBACKON:	return GetString(IDS_AP_FEEDBACKON);
		case PB_REVERSIBLE:	return GetString(IDS_AP_REVERSIBLE);
		case PB_TARGETVEL:	return GetString(IDS_AP_TARGETREVS);
		case PB_REVSUNITS:	return GetString(IDS_AP_REVSUNITS);
		case PB_CONTROLGAIN:return GetString(IDS_AP_CONTROLGAIN);
		case PB_ENABLESINES:return GetString(IDS_AP_ENABLESINES);
		case PB_TIMEPER1:	return GetString(IDS_AP_TIMEPER1);
		case PB_AMP1:		return GetString(IDS_AP_AMP1);
		case PB_PHASPER1:	return GetString(IDS_AP_PHASPER1);
		case PB_TIMEPER2:	return GetString(IDS_AP_TIMEPER2);
		case PB_AMP2:		return GetString(IDS_AP_AMP2);
		case PB_PHASPER2:	return GetString(IDS_AP_PHASPER2);
		case PB_RANGEON:	return GetString(IDS_AP_RANGEON);
		case PB_RANGEVAL:	return GetString(IDS_AP_RANGEVAL);
		case PB_ICONSIZE:	return GetString(IDS_AP_ICONSIZE);
		default: 			return TSTR(_T(""));
	}
}

ParamUIDesc *MotorObject::UIDesc()
{	return descParamMotor;}

int MotorObject::UIDescLength()
{	return MOTORPARAMDESC_LENGTH;}

TSTR MotorObject::UIStrName()
{   return GetString(IDS_AP_MOTORPARAM);}


MotorMod::MotorMod(INode *node,MotorObject *obj)
{	//MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);
	pblock = NULL;
	obRef = NULL;
	}

Interval MotorMod::GetValidity(TimeValue t) 
{	if (nodeRef)
	{	Interval valid=FOREVER;
		Matrix3 tm;
		float f;
		TimeValue tt;
		((MotorObject*)GetWSMObject(t))->pblock->GetValue(PB_STRENGTH,t,f,valid);
		((MotorObject*)GetWSMObject(t))->pblock->GetValue(PB_TARGETVEL,t,f,valid);
		((MotorObject*)GetWSMObject(t))->pblock->GetValue(PB_CONTROLGAIN,t,f,valid);
		((MotorObject*)GetWSMObject(t))->pblock->GetValue(PB_TIMEPER1,t,tt,valid);
		((MotorObject*)GetWSMObject(t))->pblock->GetValue(PB_AMP1,t,f,valid);
		((MotorObject*)GetWSMObject(t))->pblock->GetValue(PB_PHASPER1,t,f,valid);
		((MotorObject*)GetWSMObject(t))->pblock->GetValue(PB_TIMEPER2,t,tt,valid);
		((MotorObject*)GetWSMObject(t))->pblock->GetValue(PB_AMP2,t,f,valid);
		((MotorObject*)GetWSMObject(t))->pblock->GetValue(PB_PHASPER2,t,f,valid);
		((MotorObject*)GetWSMObject(t))->pblock->GetValue(PB_RANGEVAL,t,f,valid);
		tm=nodeRef->GetObjectTM(t,&valid);
		return valid;
	}
	else
	{	return FOREVER;
	}
}

class MotorDeformer : public Deformer
{	public:		
	Point3 Map(int i, Point3 p) {return p;}
};
static MotorDeformer gdeformer;

Deformer& MotorMod::GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
{	return gdeformer;}

RefTargetHandle MotorMod::Clone(RemapDir& remap) 
{	MotorMod *newob = new MotorMod(nodeRef,(MotorObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
}

void MotorMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
{	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj)
	{	force.obj=(MotorObject*)GetWSMObject(t);
		force.node=nodeRef;
		force.tmValid.SetEmpty();
		force.fValid.SetEmpty();
		force.dt=GetTicksPerFrame();
		force.dtsq=force.dt*force.dt;
		obj->ApplyForceField(&force);
	}
}

ForceField *MotorObject::GetForceField(INode *node)
{	MotorField *pb = new MotorField;	
	pb->obj  = this;
	pb->node = node;
	pb->tmValid.SetEmpty();
	pb->fValid.SetEmpty();
	pb->dt=GetTicksPerFrame();
	pb->dtsq=pb->dt*pb->dt;
	return pb;
}

#define K 2.54f

Point3 MotorField::Force(TimeValue t,const Point3 &pos, const Point3 &vel,int index)
{	Point3 ApplyAt,OutForce,zdir;
	fValid= FOREVER;		
	if (!tmValid.InInterval(t)) 
	{	tmValid=FOREVER;
		tm=node->GetObjectTM(t,&tmValid);
		invtm=Inverse(tm);
	}
	ApplyAt=tm.GetTrans();
	fValid&=tmValid;
	TimeValue t1,t2;
	obj->pblock->GetValue(PB_ONTIME,t,t1,fValid);
	obj->pblock->GetValue(PB_OFFTIME,t,t2,fValid);
	if ((t>=t1)&&(t<=t2))
	{	float BaseT;
		zdir=tm.GetRow(2);
		obj->pblock->GetValue(PB_STRENGTH,t,BaseT,fValid); //assume N-m
		//int tpf=GetTicksPerFrame();
		//int tpf2=tpf*tpf;
		int tps=TIME_TICKSPERSEC;
		int tps2=tps*tps;
		//int FToTick=(int)((float)tps/(float)GetFrameRate());
		BaseT/=(float)tps2;//convert to kg-m2/t2
		BaseT*=10000.0f; //convert to kg-cm2/t2
		int UnitsVal;
		obj->pblock->GetValue(PB_UNITS,t,UnitsVal,fValid);
		switch (UnitsVal)
		{	case 0: break;
			case 1:	BaseT*=1.3591f; break;// 4.4591 N/Lbf*.305M/ft
			case 2: BaseT*=16.310f; break;//also 12in/ft
		}
		TimeValue tage=t-t1;
		TimeValue Per1,Per2;
		obj->pblock->GetValue(PB_TIMEPER1,t,Per1,fValid);
		obj->pblock->GetValue(PB_TIMEPER2,t,Per2,fValid);
		float scalefactor=1.0f;
		int sintoggle;
		obj->pblock->GetValue(PB_ENABLESINES,t,sintoggle,fValid);
		if (sintoggle)
		{	if (Per1>0)
			{	float phase1,amp1;
				float relage1=(float)tage/(float)Per1;
				obj->pblock->GetValue(PB_PHASPER1,t,phase1,fValid);
				obj->pblock->GetValue(PB_AMP1,t,amp1,fValid);
				scalefactor+=0.01f*amp1*(float)sin(TWOPI*relage1+phase1);
			}
			if (Per2>0)
			{	float phase2,amp2;
				float relage2=(float)tage/(float)Per2;
				obj->pblock->GetValue(PB_PHASPER2,t,phase2,fValid);
				obj->pblock->GetValue(PB_AMP2,t,amp2,fValid);
				scalefactor+=0.01f*amp2*(float)sin(TWOPI*relage2+phase2);
			}
		}
		float LenOffV;
		Point3 OffV=pos-ApplyAt;
		float theta=(float)acos(DotProd(OffV,zdir)/(LenOffV=Length(OffV)));
		float offaxis=K*LenOffV*(float)sin(theta);
		Point3 fdir;
		if (theta>FLOAT_EPSILON) fdir=Normalize(zdir^OffV);
		else fdir=Normalize(Point3(RND11(),RND11(),RND11()));
		int feedback;
		obj->pblock->GetValue(PB_FEEDBACKON,t,feedback,fValid);
		float scalefactorg=1.0f;
		if (feedback)
		{	float targetrevs,loopgain;
			obj->pblock->GetValue(PB_TARGETVEL,t,targetrevs,fValid);
			obj->pblock->GetValue(PB_CONTROLGAIN,t,loopgain,fValid);
			int revunitstype;
			obj->pblock->GetValue(PB_REVSUNITS,t,revunitstype,fValid);
			float targetomega;
			switch(revunitstype)
			{	case 0:	targetomega=(targetrevs/(3600.0f*(float)tps))*TWOPI; break;
				case 1: targetomega=(targetrevs/(60.0f*(float)tps))*TWOPI; break;
				case 2: targetomega=(targetrevs/(float)tps)*TWOPI; break;
			}
			float targetspeed=targetomega*offaxis;
			float diffspeed=targetspeed-DotProd(vel,fdir);
			//scalefactorg*=diffspeed*loopgain/(float)tpf;
			scalefactorg*=diffspeed*loopgain/100.0f;
			int revon;
			obj->pblock->GetValue(PB_REVERSIBLE,t,revon,fValid);
			if ((!revon)&&(scalefactorg<0.0f)) scalefactorg=0.0f;
		}
		if (offaxis>FLOAT_EPSILON)
			OutForce=fdir*BaseT*scalefactor*scalefactorg/offaxis;
		int rangeon;
		obj->pblock->GetValue(PB_RANGEON,t,rangeon,fValid);
		if (rangeon)
		{	float maxrange;
			obj->pblock->GetValue(PB_RANGEVAL,t,maxrange,fValid);
			if (maxrange>FLOAT_EPSILON)
			{	if (offaxis<maxrange) OutForce*=(1.0f-offaxis/maxrange);
				else OutForce=Zero;
			}
		}
	}
	else OutForce=Zero;
	return OutForce*6.25e-03f;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Add\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by add.rc
//
#define IDS_DB_ADD                      1
#define IDS_DB_IMAGE_FILTER             2
#define IDS_ADDITIVE_COMP               3
#define IDS_LIBDESCRIPTION              4
#define IDD_ADD_ABOUT                   101
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ffd\ffdui.cpp ===
/**********************************************************************
 *<
	FILE: ffdmod.cpp

	DESCRIPTION: DllMain is in here

	CREATED BY: Ravi Karra

	HISTORY: created 1/11/99

 *>	Copyright (c) 1996 Rolf Berteig, All Rights Reserved.
 **********************************************************************/


#include "ffdmod.h"
#include "ffdui.h"
#include "istdplug.h"
#include "Maxscrpt.h"
#include "3DMath.h"
#include "definsfn.h"

// Maxscript stuff
def_visible_primitive (conform,			"conformToShape" );
def_visible_primitive (getDimensions,	"getDimensions" );
def_visible_primitive (setDimensions,	"setDimensions" );
def_visible_primitive (animateAll,		"animateAll" );
def_visible_primitive (resetLattice,	"resetLattice" );

#define get_ffd_mod()																\
	Modifier *mod = arg_list[0]->to_modifier();										\
	Class_ID id = mod->ClassID();													\
	if ( id != FFDNMOSSQUARE_CLASS_ID && id != FFDNMOSCYL_CLASS_ID &&				\
			id != FFD44_CLASS_ID && id != FFD33_CLASS_ID && id !=FFD22_CLASS_ID )	\
		throw RuntimeError(GetString(IDS_RK_NOT_FFD_ERROR), arg_list[0]);			\
	IFFDMod<Modifier>* ffd = (IFFDMod<Modifier>*)mod;			


Value*
conform_cf(Value** arg_list, int count)
{
	check_arg_count(conform, 1, count);
	get_ffd_mod();
	ffd->Conform();
	MAXScript_interface->RedrawViews(MAXScript_interface->GetTime());
	return &ok;
}

Value*
getDimensions_cf(Value** arg_list, int count)
{
	check_arg_count(setDimensions, 1, count);
	get_ffd_mod();
	IPoint3 p = ffd->GetGridDim();
	return new Point3Value(Point3(p.x, p.y, p.z));	
}


Value*
setDimensions_cf(Value** arg_list, int count)
{
	check_arg_count(setDimensions, 2, count);
	get_ffd_mod();
	Point3 p = arg_list[1]->to_point3();
	ffd->SetGridDim(IPoint3((int)p.x, (int)p.y, (int)p.z));
	MAXScript_interface->RedrawViews(MAXScript_interface->GetTime());
	return &ok;
}

Value*
animateAll_cf(Value** arg_list, int count)
{
	check_arg_count(animateAll, 1, count);
	get_ffd_mod();
	ffd->AnimateAll();	
	MAXScript_interface->RedrawViews(MAXScript_interface->GetTime());
	return &ok;
}

Value*
resetLattice_cf(Value** arg_list, int count)
{
	check_arg_count(resetLattice, 1, count);
	get_ffd_mod();
	ffd->SetGridDim(ffd->GetGridDim());	
	mod->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	MAXScript_interface->RedrawViews(MAXScript_interface->GetTime());
	return &ok;
}

static ShortcutDescription spShortcuts[] = {
	ID_SUBOBJ_TOP,			   IDS_SWITCH_TOP,
	ID_SUBOBJ_CP,              IDS_SWITCH_CP,
    ID_SUBOBJ_LATTICE,         IDS_SWITCH_LATTICE,
    ID_SUBOBJ_SETVOLUME,       IDS_SWITCH_SETVOLUME,			
	};

ShortcutTable* GetShortcuts()
{
    TSTR name = GetString(IDS_RB_FFDGEN);
    HACCEL hAccel = LoadAccelerators(hInstance,
                                     MAKEINTRESOURCE(IDR_FFD_SHORTCUTS));
    int numOps = NumElements(spShortcuts);
    ShortcutTable* pTab;
    pTab = new ShortcutTable(kFFDShortcuts, name, hAccel, numOps,
                             spShortcuts, hInstance);        
	return pTab;
}


int sMyEnumProc::proc(ReferenceMaker *rmaker) 
	{ 
	if (rmaker->SuperClassID()==BASENODE_CLASS_ID)    
			{
            Nodes.Append(1, (INode **)&rmaker);                 
			}
     return 0;              
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Add\add.h ===
//-----------------------------------------------------------------------------
// ----------------
// File ....: Add.h
// ----------------
// Author...: Gus J Grubba
// Date ....: September 1995
// Descr....: Additive Compositor
//
// History .: Sep, 27 1995 - Started
//            
//-----------------------------------------------------------------------------
        
#ifndef _ADDCLASS_
#define _ADDCLASS_

#define DLLEXPORT __declspec(dllexport)

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class ImageFilter_Add : public ImageFilter {

     public:
     
        //-- Constructors/Destructors
        
                       ImageFilter_Add( ) {};
                      ~ImageFilter_Add( ) {};
               
        //-- Filter Info  ---------------------------------

        const TCHAR   *Description         ( ) ;
        const TCHAR   *AuthorName          ( ) { return _T("Gus J Grubba");}
        const TCHAR   *CopyrightMessage    ( ) { return _T("Copyright 1995, Yost Group");}
        UINT           Version             ( ) { return (100);}

        //-- Filter Capabilities --------------------------
        
        DWORD          Capability          ( ) { return(IMGFLT_COMPOSITOR | IMGFLT_MASK); }

        //-- Show DLL's About box -------------------------
        
        void           ShowAbout           ( HWND hWnd );  
        BOOL           ShowControl         ( HWND hWnd ) { return (FALSE); }  

        //-- Show Time ------------------------------------
        
        BOOL           Render              ( HWND hWnd );

};

#endif

//-- EOF: Add.h ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Alpha\pmalpha.cpp ===
//-----------------------------------------------------------------------------
// ----------------------
// File ....: PMAlpha.cpp
// ----------------------
// Author...: Gus J Grubba
// Date ....: September 1995
// Descr....: Pre-Multiplied Alpha Compositor
//
// History .: Sep 27 1995 - Started
//            Apr 09 1997 - Added G Channel Support (GG)
//            Aug 19 1997 - Added Blur's Code
//
// Note ....: (c) 1996 Steven C. Blackmon / Blur Studio Inc.
//            
//-----------------------------------------------------------------------------
        
//-- Include files

#include <Max.h>
#include <bmmlib.h>
#include <fltlib.h>
#include "PMAlpha.h"
#include "resource.h"

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
     switch (fdwReason) {
         case DLL_PROCESS_ATTACH:
              if (hInst)
                 return(FALSE);
              hInst = hDLLInst;
              break;
         case DLL_PROCESS_DETACH:
              hInst  = NULL;
              break;
         case DLL_THREAD_ATTACH:
              break;
         case DLL_THREAD_DETACH:
              break;
     }
     return TRUE;
}

//-----------------------------------------------------------------------------
// Helper

TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// PMAlpha Class Description

class PMALPHAClassDesc:public ClassDesc {
     
     public:

        int             IsPublic     ( )                   { return 1;                }
        void           *Create       ( BOOL loading=FALSE) { return new ImageFilter_PMAlpha; }
        const TCHAR    *ClassName    ( )                   { return GetString(IDS_DB_PMALPHA);     }
        SClass_ID       SuperClassID ( )                   { return FLT_CLASS_ID;  }
        Class_ID        ClassID      ( )                   { return Class_ID(ALPHACLASSID,0);    }
        const TCHAR    *Category     ( )                   { return GetString(IDS_DB_IMAGE_FILTER); }

};

static PMALPHAClassDesc PMALPHADesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
     return GetString(IDS_LIBDESCRIPTION); 
}

DLLEXPORT int LibNumberClasses ( ) { 
     return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
     switch(i) {
        case  0: return &PMALPHADesc; break;
        default: return 0;        break;
     }
}

DLLEXPORT ULONG LibVersion ( )  { 
     return ( VERSION_3DSMAX ); 
}

const TCHAR *ImageFilter_PMAlpha::Description( ) {
	return GetString(IDS_DB_PMALPHA_COMP);
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

     switch (message) {
        
        case WM_INITDIALOG: {
             CenterWindow(hWnd,GetParent(hWnd));
             SetCursor(LoadCursor(NULL,IDC_ARROW));
             return 1;
        }

        case WM_COMMAND:

             switch (LOWORD(wParam)) {
                
                case IDOK:              
                     EndDialog(hWnd,1);
                     break;

                case IDCANCEL:
                     EndDialog(hWnd,0);
                     break;
        
             }
             return 1;

     }
     
     return 0;

}

//-----------------------------------------------------------------------------
// #> ImageFilter_PMAlpha::ShowAbout()

void ImageFilter_PMAlpha::ShowAbout(HWND hWnd) {
     DialogBoxParam(
        hInst,
        MAKEINTRESOURCE(IDD_PMALPHA_ABOUT),
        hWnd,
        (DLGPROC)AboutCtrlDlgProc,
        (LPARAM)this);
}

//-----------------------------------------------------------------------------
// *> fLerp()
//

static _inline float fLerp(float a, float b, int i) {
   float f = i / 65535.0f;
   if (f > 1.0f) f = 1.0f;
   return((1.0f-f)*a + f*b);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_PMAlpha::Render()
//
//    Private member Bitmap *srcmap has source bitmap
//    Private member Bitmap *frgmap has foreground bitmap
//    Private member Bitmap *mskmap has mask (if any)
//

BOOL ImageFilter_PMAlpha::Render(HWND hWnd) {

	BMM_Color_64 *s64,*src64	= NULL;
	BMM_Color_64 *f64,*fgd64	= NULL;
	WORD         *m16,*mask16	= NULL;

	float bak_r, for_r, res_r;
	float bak_g, for_g, res_g;
	float bak_b, for_b, res_b;
	float bak_a, for_a, res_a;
	float i_for_a;

	int mwidth;
     
	if (!srcmap)
		return (FALSE);

	if (!frgmap)
		return (FALSE);

	int width	= srcmap->Width();
	int height	= srcmap->Height();

	//-- Allocate Background Line
     
	if ((src64=(BMM_Color_64 *)calloc(width,sizeof(BMM_Color_64)))==NULL)
		return (FALSE);

	//-- Allocate Foreground Line
     
	if ((fgd64=(BMM_Color_64 *)calloc(width,sizeof(BMM_Color_64)))==NULL)
		return (FALSE);

	//-- Allocate Mask Line
     
	if (mskmap) {
		mask16 = (WORD *)calloc(width,sizeof(WORD));
		mwidth = min(width,mskmap->Width());
	}  

	BOOL result = TRUE;
	BOOL abort  = FALSE;
     
	//----------------------------------------------------------------
	//-- Handle G Channels (if any)

	DWORD src_channels = srcmap->ChannelsPresent();
	DWORD frg_channels = frgmap->ChannelsPresent();

	if (frg_channels || src_channels) {

		//------------------------------------------------------------
		//-- Z Channel
				
		if (frg_channels & BMM_CHAN_Z && !abort && result) {
		
			if (!(src_channels & BMM_CHAN_Z))
				srcmap->CreateChannels(BMM_CHAN_Z);
		
			DWORD type;
			float *sbuffer = (float *)srcmap->GetChannel(BMM_CHAN_Z,type);
			float *fbuffer = (float *)frgmap->GetChannel(BMM_CHAN_Z,type);

			//-- Display what's going on

			SendMessage(hWnd,FLT_TEXTMSG,0,(LPARAM)GetString(IDS_PROCESS_Z));

			for (int iy = 0; iy < height; iy++) {
				
				//-- Progress Report
        
				SendMessage(hWnd,FLT_PROGRESS,iy,height-1);

				//-- Check for Abort
        
				SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

				if (abort) {
					result = FALSE;
					break;
				}   
        
				f64 = fgd64;

				//-- Get Foreground line (RGBA Image)
        
				if (frgmap->GetLinearPixels(0,iy,width,fgd64)!=1) {
					result = FALSE;
					break;
				}

				//-- Handle Mask -------------------------------------
		        
				if (mask16) {
					
					if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
						result = FALSE;
						break;
					}
		           
					m16 = mask16;
					for (int ix = 0; ix < width; ix++,f64++,m16++,sbuffer++,fbuffer++) {
						if (*m16 > 0x7FFF) {
							if (f64->a > 0x7FFF)
								*sbuffer = *fbuffer;
						}
					}

				//-- Unmasked ----------------------------------------
		
				} else {
					for (int ix = 0; ix < width; ix++,f64++,sbuffer++,fbuffer++) {
						if (f64->a > 0x7FFF)
							*sbuffer = *fbuffer;
					}
				}

			}

		}

		//------------------------------------------------------------
		//-- Material Effects Channel

		if (frg_channels & BMM_CHAN_MTL_ID && !abort && result) {
		
			if (!(src_channels & BMM_CHAN_MTL_ID))
				srcmap->CreateChannels(BMM_CHAN_MTL_ID);
		
			DWORD type;
			BYTE *sbuffer = (BYTE *)srcmap->GetChannel(BMM_CHAN_MTL_ID,type);
			BYTE *fbuffer = (BYTE *)frgmap->GetChannel(BMM_CHAN_MTL_ID,type);

			//-- Display what's going on

			SendMessage(hWnd,FLT_TEXTMSG,0,(LPARAM)GetString(IDS_PROCESS_MTLID));

			for (int iy = 0; iy < height; iy++) {
				
				//-- Progress Report
        
				SendMessage(hWnd,FLT_PROGRESS,iy,height-1);

				//-- Check for Abort
        
				SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

				if (abort) {
					result = FALSE;
					break;
				}   
        
				f64 = fgd64;

				//-- Get Foreground line (RGBA Image)
        
				if (frgmap->GetLinearPixels(0,iy,width,fgd64)!=1) {
					result = FALSE;
					break;
				}

				//-- Handle Mask -------------------------------------
		        
				if (mask16) {
					
					if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
						result = FALSE;
						break;
					}
		           
					m16 = mask16;
					for (int ix = 0; ix < width; ix++,f64++,m16++,sbuffer++,fbuffer++) {
						if (*m16 > 0x7FFF) {
							if (f64->a > 0x7FFF)
								*sbuffer = *fbuffer;
						}
					}

				//-- Unmasked ----------------------------------------
		
				} else {
					for (int ix = 0; ix < width; ix++,f64++,sbuffer++,fbuffer++) {
						if (f64->a > 0x7FFF)
							*sbuffer = *fbuffer;
					}
				}

			}

		}

		//------------------------------------------------------------
		//-- Node ID Channel

		if (frg_channels & BMM_CHAN_NODE_ID && !abort && result) {
		
			if (!(src_channels & BMM_CHAN_NODE_ID))
				srcmap->CreateChannels(BMM_CHAN_NODE_ID);
		
			DWORD type;
			WORD *sbuffer = (WORD *)srcmap->GetChannel(BMM_CHAN_NODE_ID,type);
			WORD *fbuffer = (WORD *)frgmap->GetChannel(BMM_CHAN_NODE_ID,type);

			//-- Display what's going on

			SendMessage(hWnd,FLT_TEXTMSG,0,(LPARAM)GetString(IDS_PROCESS_NODEID));

			for (int iy = 0; iy < height; iy++) {
				
				//-- Progress Report
        
				SendMessage(hWnd,FLT_PROGRESS,iy,height-1);

				//-- Check for Abort
        
				SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

				if (abort) {
					result = FALSE;
					break;
				}   
        
				f64 = fgd64;

				//-- Get Foreground line (RGBA Image)
        
				if (frgmap->GetLinearPixels(0,iy,width,fgd64)!=1) {
					result = FALSE;
					break;
				}

				//-- Handle Mask -------------------------------------
		        
				if (mask16) {
					
					if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
						result = FALSE;
						break;
					}
		           
					m16 = mask16;
					for (int ix = 0; ix < width; ix++,f64++,m16++,sbuffer++,fbuffer++) {
						if (*m16 > 0x7FFF) {
							if (f64->a > 0x7FFF)
								*sbuffer = *fbuffer;
						}
					}

				//-- Unmasked ----------------------------------------
		
				} else {
					for (int ix = 0; ix < width; ix++,f64++,sbuffer++,fbuffer++) {
						if (f64->a > 0x7FFF)
							*sbuffer = *fbuffer;
					}
				}

			}

		}

		//------------------------------------------------------------
		//-- UV Coordinates Channel


		if (frg_channels & BMM_CHAN_UV && !abort && result) {
		
			if (!(src_channels & BMM_CHAN_UV))
				srcmap->CreateChannels(BMM_CHAN_UV);
		
			DWORD type;
			Point2 *sbuffer = (Point2 *)srcmap->GetChannel(BMM_CHAN_UV,type);
			Point2 *fbuffer = (Point2 *)frgmap->GetChannel(BMM_CHAN_UV,type);

			//-- Display what's going on

			SendMessage(hWnd,FLT_TEXTMSG,0,(LPARAM)GetString(IDS_PROCESS_UV));

			for (int iy = 0; iy < height; iy++) {
				
				//-- Progress Report
        
				SendMessage(hWnd,FLT_PROGRESS,iy,height-1);

				//-- Check for Abort
        
				SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

				if (abort) {
					result = FALSE;
					break;
				}   
        
				f64 = fgd64;

				//-- Get Foreground line (RGBA Image)
        
				if (frgmap->GetLinearPixels(0,iy,width,fgd64)!=1) {
					result = FALSE;
					break;
				}

				//-- Handle Mask -------------------------------------
		        
				if (mask16) {
					
					if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
						result = FALSE;
						break;
					}
		           
					m16 = mask16;
					for (int ix = 0; ix < width; ix++,f64++,m16++,sbuffer++,fbuffer++) {
						if (*m16 > 0x7FFF) {
							if (f64->a > 0x7FFF)
								*sbuffer = *fbuffer;
						}
					}

				//-- Unmasked ----------------------------------------
		
				} else {
					for (int ix = 0; ix < width; ix++,f64++,sbuffer++,fbuffer++) {
						if (f64->a > 0x7FFF)
							*sbuffer = *fbuffer;
					}
				}

			}

		}

		//------------------------------------------------------------
		//-- Normals Channel

		if (frg_channels & BMM_CHAN_NORMAL && !abort && result) {
		
			if (!(src_channels & BMM_CHAN_NORMAL))
				srcmap->CreateChannels(BMM_CHAN_NORMAL);
		
			DWORD type;
			DWORD *sbuffer = (DWORD *)srcmap->GetChannel(BMM_CHAN_NORMAL,type);
			DWORD *fbuffer = (DWORD *)frgmap->GetChannel(BMM_CHAN_NORMAL,type);

			//-- Display what's going on

			SendMessage(hWnd,FLT_TEXTMSG,0,(LPARAM)GetString(IDS_PROCESS_NORMAL));

			for (int iy = 0; iy < height; iy++) {
				
				//-- Progress Report
        
				SendMessage(hWnd,FLT_PROGRESS,iy,height-1);

				//-- Check for Abort
        
				SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

				if (abort) {
					result = FALSE;
					break;
				}   
        
				f64 = fgd64;

				//-- Get Foreground line (RGBA Image)
        
				if (frgmap->GetLinearPixels(0,iy,width,fgd64)!=1) {
					result = FALSE;
					break;
				}

				//-- Handle Mask -------------------------------------
		        
				if (mask16) {
					
					if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
						result = FALSE;
						break;
					}
		           
					m16 = mask16;
					for (int ix = 0; ix < width; ix++,f64++,m16++,sbuffer++,fbuffer++) {
						if (*m16 > 0x7FFF) {
							if (f64->a > 0x7FFF)
								*sbuffer = *fbuffer;
						}
					}

				//-- Unmasked ----------------------------------------
		
				} else {
					for (int ix = 0; ix < width; ix++,f64++,sbuffer++,fbuffer++) {
						if (f64->a > 0x7FFF)
							*sbuffer = *fbuffer;
					}
				}

			}

		}

		//------------------------------------------------------------
		//-- Real Colors Channel

		if (frg_channels & BMM_CHAN_REALPIX && !abort && result) {
		
			if (!(src_channels & BMM_CHAN_REALPIX))
				srcmap->CreateChannels(BMM_CHAN_REALPIX);
		
			DWORD type;
			RealPixel *sbuffer = (RealPixel *)srcmap->GetChannel(BMM_CHAN_REALPIX,type);
			RealPixel *fbuffer = (RealPixel *)frgmap->GetChannel(BMM_CHAN_REALPIX,type);

			//-- Display what's going on

			SendMessage(hWnd,FLT_TEXTMSG,0,(LPARAM)GetString(IDS_PROCESS_REALPIX));

			for (int iy = 0; iy < height; iy++) {
				
				//-- Progress Report
        
				SendMessage(hWnd,FLT_PROGRESS,iy,height-1);

				//-- Check for Abort
        
				SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

				if (abort) {
					result = FALSE;
					break;
				}   
        
				f64 = fgd64;

				//-- Get Foreground line (RGBA Image)
        
				if (frgmap->GetLinearPixels(0,iy,width,fgd64)!=1) {
					result = FALSE;
					break;
				}

				//-- Handle Mask -------------------------------------
		        
				if (mask16) {
					
					if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
						result = FALSE;
						break;
					}
		           
					m16 = mask16;
					for (int ix = 0; ix < width; ix++,f64++,m16++,sbuffer++,fbuffer++) {
						float sr,sg,sb;
						float fr,fg,fb;
						float tr,tg,tb;
						ExpandRealPixel(*sbuffer,sr,sg,sb);
						ExpandRealPixel(*fbuffer,fr,fg,fb);
						for_a = ((float)f64->a / 65530.0f);
						i_for_a = 1.0f - for_a;
						tr = (sr * i_for_a) + fr;
						tg = (sg * i_for_a) + fg;
						tb = (sb * i_for_a) + fb;
						if (*m16 < 65530) {
							if (*m16) {
								sr = fLerp(tr,sr,*m16);
								sg = fLerp(tg,sg,*m16);
								sb = fLerp(tb,sb,*m16);
							} else {
								sr = tr;
								sg = tg;
								sb = tb;
							}
						}
						*sbuffer = MakeRealPixel(sr,sg,sb);
					}

				//-- Unmasked ----------------------------------------
		
				} else {
					for (int ix = 0; ix < width; ix++,f64++,sbuffer++,fbuffer++) {
						float sr,sg,sb;
						float fr,fg,fb;
						ExpandRealPixel(*sbuffer,sr,sg,sb);
						ExpandRealPixel(*fbuffer,fr,fg,fb);
						for_a = ((float)f64->a / 65530.0f);
						i_for_a = 1.0f - for_a;
						sr = (sr * i_for_a) + fr;
						sg = (sg * i_for_a) + fg;
						sb = (sb * i_for_a) + fb;
						*sbuffer = MakeRealPixel(sr,sg,sb);
					}
				}

			}

		}

	}

	//----------------------------------------------------------------
	//-- Handle RGBA Image

	if (!abort && result) {

		//-- Display what's going on

		SendMessage(hWnd,FLT_TEXTMSG,0,(LPARAM)GetString(IDS_PROCESS_RGBA));

		for (int iy = 0; iy < height; iy++) {

			//-- Progress Report
	        
			SendMessage(hWnd,FLT_PROGRESS,iy,height-1);

			//-- Check for Abort
	        
			SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

			if (abort) {
				result = FALSE;
				break;
			}   
	        
			s64 = src64;
			f64 = fgd64;

			//-- Get Source line
	        
			if (srcmap->GetLinearPixels(0,iy,width,src64)!=1) {
				result = FALSE;
				break;
			}

			//-- Get Foreground line
	        
			if (frgmap->GetLinearPixels(0,iy,width,fgd64)!=1) {
				result = FALSE;
				break;
			}

			//-- Handle Mask ----------------------------------
	        
			if (mask16) {
				
				WORD r,g,b,a;
	           
				if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
					result = FALSE;
					break;
				}
	           
				m16 = mask16;
				for (int ix = 0; ix < width; ix++,s64++,f64++,m16++) {

					bak_r = ((float)s64->r / 65530.0f);
					bak_g = ((float)s64->g / 65530.0f);
					bak_b = ((float)s64->b / 65530.0f);
					bak_a = ((float)s64->a / 65530.0f);

					for_r = ((float)f64->r / 65530.0f);
					for_g = ((float)f64->g / 65530.0f);
					for_b = ((float)f64->b / 65530.0f);
					for_a = ((float)f64->a / 65530.0f);

					i_for_a = 1.0f - for_a;

					res_r = (bak_r * i_for_a) + for_r;
					res_g = (bak_g * i_for_a) + for_g;
					res_b = (bak_b * i_for_a) + for_b;
					res_a = bak_a + for_a;

					res_r = min(max(res_r,0.0f),1.0f);
					res_g = min(max(res_g,0.0f),1.0f);
					res_b = min(max(res_b,0.0f),1.0f);
					res_a = min(max(res_a,0.0f),1.0f);
					
					r = (WORD)(res_r * 65530.0f);
					g = (WORD)(res_g * 65530.0f);
					b = (WORD)(res_b * 65530.0f);
					a = (WORD)(res_a * 65530.0f);

					if (*m16 < 65530) {
						if (*m16) {
							s64->r = Lerp(r,(int)s64->r,(int)*m16);
							s64->g = Lerp(g,(int)s64->g,(int)*m16);
							s64->b = Lerp(b,(int)s64->b,(int)*m16);
							s64->a = Lerp(a,(int)s64->a,(int)*m16);
						} else {
							s64->r = r;
							s64->g = g;
							s64->b = b;
							s64->a = a;
						}
					}
	           
				}
	           
			//-- Unmasked -------------------------------------
	        
			} else {
	        
				for (int ix = 0; ix < width; ix++,f64++,s64++) {


					bak_r = ((float)s64->r / 65530.0f);
					bak_g = ((float)s64->g / 65530.0f);
					bak_b = ((float)s64->b / 65530.0f);
					bak_a = ((float)s64->a / 65530.0f);

					for_r = ((float)f64->r / 65530.0f);
					for_g = ((float)f64->g / 65530.0f);
					for_b = ((float)f64->b / 65530.0f);
					for_a = ((float)f64->a / 65530.0f);

					i_for_a = 1.0f - for_a;

					res_r = (bak_r * i_for_a) + for_r;
					res_g = (bak_g * i_for_a) + for_g;
					res_b = (bak_b * i_for_a) + for_b;
					res_a = bak_a + for_a;

					res_r = min(max(res_r,0.0f),1.0f);
					res_g = min(max(res_g,0.0f),1.0f);
					res_b = min(max(res_b,0.0f),1.0f);
					res_a = min(max(res_a,0.0f),1.0f);
				
					s64->r = (WORD)(res_r * 65530.0f);
					s64->g = (WORD)(res_g * 65530.0f);
					s64->b = (WORD)(res_b * 65530.0f);
					s64->a = (WORD)(res_a * 65530.0f);

				}

	        }

	        //-- Output Line
	        
	        if (srcmap->PutPixels(0,iy,width,src64)!=1) {
	           result = FALSE;
	           break;
	        }

		}

	}
     
	if (mask16)
		free(mask16);
        
	if (src64)
		free(src64);
        
	if (fgd64)
		free(fgd64);
        
	return(result);

}

//-- EOF: PMAlpha.cpp --------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ffd\ffdnm.cpp ===
/**********************************************************************
 *<
	FILE: ffdnm.cpp

	DESCRIPTION: A NxM FFD Modifier

	CREATED BY: Rolf Berteig, 3.0 additions by Ravi Karra 

	HISTORY: 01/16/97

 *>	Copyright (c) 1996 Rolf Berteig, All Rights Reserved.
 **********************************************************************/

////////////////////////////////////////////////////////////////////
//
// Free Form Deformation Patent #4,821,214 licensed 
// from Viewpoint DataLabs Int'l, Inc., Orem, UT
// www.viewpoint.com
// 
////////////////////////////////////////////////////////////////////

#include "ffdmod.h"
#include "istdplug.h"
#include "simpmod.h"
#include "iparamb2.h"
#include "iparamm2.h"
#include "macrorec.h"

#define INC_CONSTRAINTS
#include "ffdui.h"
#undef INC_CONSTRAINTS

#define FFD_SELECT_CLASS_ID			Class_ID(0x305f8a34,0x449eec81)
#define GENFFDOBJECT_CLASS_ID		Class_ID(0x763f2e8a,0xaa7b25e3)

static Point3 InterpSpline(float u,Point3 knot[4],float m1, float m2);
static void ComputeTCBMults(float tens, float cont, float &m1, float &m2);
BOOL CALLBACK DefaultSOTProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);

// in ffd.cpp
extern Point3 LatticeSize(Box3 box);
extern void MakeBoxThick(Box3 &box);

template <class T>
class FFDNM : public IFFDMod<T> {
	public:
		MasterPointControl	*masterCont;		// Master track controller
		IParamBlock2		*pblock;
		Control				*tmControl;
		BitArray			sel;
		Tab<Control*>		ptCont;
		Tab<Point3>			pt;
		Box3				lbox;
		int					dim[3];		
		int					selLevel;
		int					loadRefVersion;
		Tab<Point3>			offsets;				// Lattice offsets points
		FFDRightMenu<FFDNM<T> >		*ffdMenu;		// Right-click menu handler		
		FFDShortcutCB<FFDNM<T> >	*ffdShortcutCB;	// Shortcuts handler 			
		BOOL beenDeformed;

		FFDNM();
		static FFDNM				*editFFD;
		static IObjParam			*ip;
		static MoveModBoxCMode		*moveMode;
		static RotateModBoxCMode	*rotMode;
		static UScaleModBoxCMode	*uscaleMode;
		static NUScaleModBoxCMode	*nuscaleMode;
		static SquashModBoxCMode	*squashMode;
		static SelectModBoxCMode	*selectMode;
		static BOOL allX, allY, allZ;
		static HWND	hSot;

		// From Animatable
		void	DeleteThis() { delete this; }		
		void	BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void	EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);
		CreateMouseCallBack* GetCreateMouseCallBack() { return NULL; } 
		BOOL	AssignController(Animatable *control,int subAnim);		
		int		SubNumToRefNum(int subNum);
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock


		// From ReferenceTarget/Maker
		int		NumRefs() { return ptCont.Count()+3; }
		RefTargetHandle GetReference(int i);
		void	SetReference(int i, RefTargetHandle rtarg);
		int		NumSubs() { return 3;}
		Animatable* SubAnim(int i) { return GetReference(i); }
		TSTR	SubAnimName(int i);
		BOOL	SelectSubAnim(int subNum);
		int		RemapRefOnLoad(int iref);
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);						
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
			PartID& partID, RefMessage message) { return REF_SUCCEED; }

		// From BaseObject/Object
		int		Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext *mc);
		void	GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);
		int		HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		void	SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE);
		void	ClearSelection(int selLevel);
		void	SelectAll(int selLevel);
		void	InvertSelection(int selLevel);
		void	ActivateSubobjSel(int level, XFormModes& modes);
		void	Move(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin);
		void	Rotate(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin);
		void	Scale(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin);
		void	GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void	GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void	TransformStart(TimeValue t) {  if (ip) ip->LockAxisTripods(TRUE);  }
		void	TransformFinish(TimeValue t) { if (ip) ip->LockAxisTripods(FALSE); }
		void	TransformCancel(TimeValue t) { if (ip) ip->LockAxisTripods(FALSE); }		
		TCHAR	*GetObjectName();
		DWORD	GetSubselState() { return selLevel; } 
		void	SetSubSelState(DWORD s) { selLevel=(int)s; }

		int		DrawControlPoints(TimeValue t,ViewExp *vpt,GraphicsWindow *gw,Box3 box,BOOL ht=FALSE,INode *inode=NULL,ModContext *mc=NULL,int flags=0);
		void	PlugControllers(TimeValue t, BOOL all=FALSE);
		Matrix3 CompTM(TimeValue t,INode *inode,ModContext *mc);

		// RK: Methods from IFFDMod
		int		NumPts() { return pt.Count(); }
		int		NumPtConts() { return ptCont.Count(); }
		Control* GetPtCont(int i) { return ptCont[i]; }
		void	SetPtCont(int i,Control *c);
		Point3	GetPt(int i);
		void	SetPt(int i, Point3 p) { pt[i] = p; }
//		void	SetGridDim(int x, int y, int z) { int dm[] = {x,y,z}; SetGridDim(dm); }
		void	SetGridDim(IPoint3 d) { int dm[] = {d.x,d.y,d.z}; SetGridDim(dm); }
		IPoint3	GetGridDim() { return IPoint3(dim[0],dim[1],dim[2]); }
		Point3	GetControlPoint(TimeValue t, int i, int src=FALSE, BOOL initVol=FALSE);
		void	AnimateAll();		
		void	SelectPt(int i, BOOL sel, BOOL clearAll=FALSE);
		void	Conform();
		
		Point3	GetPtOR(int i, int j, int k);
		int		GridDim(int which);
		void	SetGridDim(int dm[3]);		
		int		GridIndex(int i, int j, int k);
		void	ExpandSelection(int ix, BOOL on);
		void	BaseClone(FFDNM<T> *src,RemapDir &remap,BOOL noRef=FALSE);

		virtual Point3 InverseLattice(Point3 p)=0;
		virtual Point3 GetSourcePoint(int i)=0;		
		virtual int GetNameID()=0;
		virtual int GetDlgID()=0;
		virtual	ClassDesc2* GetClassDesc()=0;		
		virtual BOOL WrapX() { return FALSE; }
		virtual int MinXDim() { return 2; }
		virtual int GetLengthNameID() { return IDS_RB_LENGTH; }
		virtual int GetWidthNameID() { return IDS_RB_WIDTH; }
		virtual void UpdateBox(TimeValue t) { }
		virtual int GetSetDimDlgID() { return IDD_FFD_SETDIM; }
	};

template <class T>
class FFDNMDeformer : public Deformer {
	public:		
		Matrix3		tm, itm;
		int			inVol, dim[3];
		float		falloff, m1, m2;
		FFDNM<T>	*ffd;
		Point3		***pts;
		BOOL		wrapX;

		FFDNMDeformer() { ffd=NULL;pts=NULL;dim[0]=dim[1]=dim[2]=0;wrapX=FALSE; }
		FFDNMDeformer(FFDNM<T> *ffd,TimeValue t,Matrix3 *mtm, Box3 &box, BOOL ws=FALSE);		
		Point3	Map(int ii, Point3 p);
		void	FreePointCache() {
			if (pts) { 				
				for (int i=0; i<dim[0]+(wrapX?0:2); i++) {
					for (int j=0; j<dim[1]+2; j++) {
						delete[] pts[i][j];						
						}
					delete[] pts[i];
					}
				delete[] pts;			
				pts = NULL;
				}
			}
	};


template <class T>
class FFDNMSquare : public FFDNM<T> { 	
	public:		
		Point3		InverseLattice(Point3 p) { return p; }
		Point3		GetSourcePoint(int i);
		int			GetNameID() { return IDS_RB_FFDRECT; }
	};

template <class T>
class FFDNMCyl : public FFDNM<T> { 	
	public:
		Point3		InverseLattice(Point3 p);
		Point3		GetSourcePoint(int i);
		int			GetNameID() { return IDS_RB_FFDCYL; }
		int			GetSetDimDlgID() { return IDD_FFD_SETDIMCYL; }
		BOOL		WrapX() { return TRUE; }
		int			MinXDim() { return 6; }
	};

template <class T>
class FFDNMOSMod : public T {
	public:
		FFDNMOSMod();		
		
		ChannelMask ChannelsUsed()  { return PART_GEOM|PART_TOPO|PART_SELECT|PART_SUBSEL_TYPE; }
		ChannelMask ChannelsChanged() { return PART_GEOM; }
		Class_ID	InputType() { return defObjectClassID; }

		void		GetClassName(TSTR& s) { s = GetObjectName(); }
		int			GetDlgID() { return IDD_FFDNMOSPARAMS; }		
		ClassDesc2*	GetClassDesc()	{ return NULL; }		
	};

class FFDNMSquareOSMod : public FFDNMOSMod<FFDNMSquare<Modifier> > { 	
	public:		
					FFDNMSquareOSMod();
		Class_ID	ClassID() { return FFDNMOSSQUARE_CLASS_ID; }	
		Interval	LocalValidity(TimeValue t);
		void		ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);		
		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		IOResult	Load(ILoad *iload);
		ClassDesc2*	GetClassDesc();
	};

class FFDNMCylOSMod : public FFDNMOSMod<FFDNMCyl<Modifier> >  {
	public:
					FFDNMCylOSMod();
		Class_ID	ClassID() { return FFDNMOSCYL_CLASS_ID; }
		Interval	LocalValidity(TimeValue t);
		void		ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		IOResult	Load(ILoad *iload);
		ClassDesc2*	GetClassDesc();
	};

template <class T>
class FFDNMWSObj : public T {
	public:
		void		InitNodeName(TSTR& s) { s = GetString(IDS_RB_FFDGEN); }
		//void		GetClassName(TSTR& s) { s = GetObjectName(); }
		int			IsRenderable() { return FALSE; }		
	};

class FFDNMSquareWSObj : public FFDNMWSObj<FFDNMSquare<WSMObject> > {
	public:
		Interval	geomValid, selValid;
		BOOL		selLevelValid;

					FFDNMSquareWSObj(BOOL noRef=FALSE);
		Class_ID	ClassID() { return FFDNMWSSQUARE_CLASS_ID; }
		void		GetClassName(TSTR& s) { s = GetString(IDS_RB_FFDRECT_C); }
		Modifier	*CreateWSMMod(INode *node);
		CreateMouseCallBack* GetCreateMouseCallBack();
		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		IOResult	Load(ILoad *iload);
		BOOL		IsSubClassOf(Class_ID classID);

		Interval ObjectValidity(TimeValue t);
		void		GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box);
		void		GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box);
		void		GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel);
		int			Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		int			HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);

		Interval	ChannelValidity(TimeValue t, int nchan);
		void		SetChannelValidity(int i, Interval v);
		void		InvalidateChannels(ChannelMask channels);
		int			CanConvertToType(Class_ID obtype);
		Object		*ConvertToType(TimeValue t, Class_ID obtype);		
		Object		*MakeShallowCopy(ChannelMask channels);
		void		ShallowCopy(Object* fromOb, ChannelMask channels);		
		void		Deform(Deformer *defProc, int useSel);
		int			IsDeformable() { return 1; }  
		int			NumPoints() { return pt.Count(); }
		Point3		GetPoint(int i) { 
									Point3 s = LatticeSize(lbox);
									Point3 p = pt[i]*s + lbox.Min(); 
									return p; 
									}
		void		SetPoint(int i, const Point3& p) { 
									Point3 s = LatticeSize(lbox);
									pt[i] = (p-lbox.Min())/s;
//									pt[i]=p; 
									}
		ObjectState Eval(TimeValue t);

		void		UpdateBox(TimeValue t);
		int			GetDlgID() { return IDD_FFDNMWSPARAMS; }		
		ClassDesc2*	GetClassDesc();		

	};

class FFDNMCylWSObj : public FFDNMWSObj<FFDNMCyl<WSMObject> > {
	public:		
		Interval	geomValid, selValid;
		BOOL		selLevelValid;

					FFDNMCylWSObj(BOOL noRef=FALSE);
		Class_ID	ClassID() { return FFDNMWSCYL_CLASS_ID; }
		void		GetClassName(TSTR& s) { s = GetString(IDS_RB_FFDCYL_C); }
		Modifier	*CreateWSMMod(INode *node);
		CreateMouseCallBack* GetCreateMouseCallBack();

		Interval	ObjectValidity(TimeValue t);
		void		GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box);
		void		GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box);
		void		GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel);
		int			Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		int			HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		RefTargetHandle Clone(RemapDir &remap = NoRemap());		
		IOResult	Load(ILoad *iload);
		BOOL		IsSubClassOf(Class_ID classID);

		Interval	ChannelValidity(TimeValue t, int nchan);
		void		SetChannelValidity(int i, Interval v);
		void		InvalidateChannels(ChannelMask channels);
		int			CanConvertToType(Class_ID obtype);
		Object		*ConvertToType(TimeValue t, Class_ID obtype);		
		Object		*MakeShallowCopy(ChannelMask channels);
		void		ShallowCopy(Object* fromOb, ChannelMask channels);		
		void		Deform(Deformer *defProc, int useSel);
		int			IsDeformable() { return 1; }  
		int			NumPoints() { return pt.Count(); }
		Point3		GetPoint(int i) { 
									Point3 s = LatticeSize(lbox);
									Point3 p = pt[i]*s + lbox.Min(); 
									return p; 
									}
		void		SetPoint(int i, const Point3& p) { 
//									pt[i]=p; 
									Point3 s = LatticeSize(lbox);
									pt[i] = (p-lbox.Min())/s;
									}
		ObjectState Eval(TimeValue t);

		void		UpdateBox(TimeValue t);		
		int			GetDlgID() { return IDD_FFDNMWSCYLPARAMS; }
		ClassDesc2*	GetClassDesc();
		int			GetLengthNameID() { return IDS_RB_HEIGHT; }
		int			GetWidthNameID() { return IDS_RB_RADIUS; }
	};


class FFDNMWSMod : public SimpleWSMMod {
	public:
					FFDNMWSMod();
					FFDNMWSMod(INode *node);

		// From Animatable
		void		GetClassName(TSTR& s) { s= GetString(IDS_RB_FFDNMWSMOD); }
		SClass_ID	SuperClassID() { return WSM_CLASS_ID; }		
		Class_ID	ClassID() { return FFDNMWSSQUARE_MOD_CLASS_ID; }
		void		DeleteThis() { delete this; }		
		RefTargetHandle Clone(RemapDir &remap = NoRemap());

		//RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR		*GetObjectName() { return GetString(IDS_RB_FFDNMWSMOD); }
		
		// From SimpleWSMMod		
		Deformer&	GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
		Interval	GetValidity(TimeValue t);

		RefResult	NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
		ClassDesc2*	GetClassDesc();
	};


//--- Class Descriptor and Class Vars. ------------------------------------------

template <class T> FFDNM<T>             *FFDNM<T>::editFFD = NULL;
template <class T> IObjParam			*FFDNM<T>::ip = NULL;
template <class T> MoveModBoxCMode		*FFDNM<T>::moveMode = NULL;
template <class T> RotateModBoxCMode	*FFDNM<T>::rotMode = NULL;
template <class T> UScaleModBoxCMode	*FFDNM<T>::uscaleMode = NULL;
template <class T> NUScaleModBoxCMode	*FFDNM<T>::nuscaleMode = NULL;
template <class T> SquashModBoxCMode	*FFDNM<T>::squashMode = NULL;
template <class T> SelectModBoxCMode	*FFDNM<T>::selectMode = NULL;
template <class T> BOOL                  FFDNM<T>::allX = 0;
template <class T> BOOL                  FFDNM<T>::allY = 0;
template <class T> BOOL                  FFDNM<T>::allZ = 0;
template <class T> HWND                  FFDNM<T>::hSot = NULL;

template <class T> void resetClassParams()
{
	FFDNM<T>::allX = 0;
	FFDNM<T>::allY = 0;
	FFDNM<T>::allZ = 0;
}

class FFDNMSquareOSModClassDesc: public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new FFDNMSquareOSMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_FFDRECT); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return FFDNMOSSQUARE_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS); }
	const TCHAR*	InternalName() { return _T("FFDBox"); }
	HINSTANCE		HInstance()	{ return hInstance; }
	int             NumShortcutTables() { return 1; }
	ShortcutTable*  GetShortcutTable(int i) { return GetShortcuts(); }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetClassParams<Modifier>(); } // mjm - 2.3.99
	};
static FFDNMSquareOSModClassDesc ffdNMSquareOSDesc;
ClassDesc* GetFFDNMSquareOSDesc() { return &ffdNMSquareOSDesc; }
ClassDesc2*	FFDNMSquareOSMod::GetClassDesc() { return &ffdNMSquareOSDesc; }

class FFDNMSquareWSObjClassDesc: public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new FFDNMSquareWSObj; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_FFDRECT_C); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return FFDNMWSSQUARE_CLASS_ID; }
	const TCHAR* 	Category() { return GetSpaceWarpCatString(SPACEWARP_CAT_GEOMDEF); }
	const TCHAR*	InternalName() { return _T("SpaceFFDBox"); }
	HINSTANCE		HInstance()	{ return hInstance; }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetClassParams<WSMObject>(); } // mjm - 2.3.99
	};
static FFDNMSquareWSObjClassDesc ffdNMSquareWSDesc;
ClassDesc* GetFFDNMSquareWSDesc() { return &ffdNMSquareWSDesc; }
ClassDesc2*	FFDNMSquareWSObj::GetClassDesc() { return &ffdNMSquareWSDesc; }

class FFDNMSquareWSModClassDesc: public ClassDesc2 {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) { return new FFDNMWSMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_FFDNMWSMOD); }
	SClass_ID		SuperClassID() { return WSM_CLASS_ID; }
	Class_ID		ClassID() { return FFDNMWSSQUARE_MOD_CLASS_ID; }
	const TCHAR* 	Category() { return _T(""); }	
	HINSTANCE		HInstance()	{ return hInstance; }
	};
static FFDNMSquareWSModClassDesc ffdNMSquareWSModDesc;
ClassDesc* GetFFDNMSquareWSModDesc() { return &ffdNMSquareWSModDesc; }
ClassDesc2*	FFDNMWSMod::GetClassDesc() { return &ffdNMSquareWSModDesc; }

class FFDNMCylOSModClassDesc: public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new FFDNMCylOSMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_FFDCYL); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return FFDNMOSCYL_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS); }
	const TCHAR*	InternalName() { return _T("FFDCyl"); }
	HINSTANCE		HInstance()	{ return hInstance; }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetClassParams<Modifier>(); } // mjm - 2.3.99
	};
static FFDNMCylOSModClassDesc ffdNMCylOSDesc;
ClassDesc* GetFFDNMCylOSDesc() { return &ffdNMCylOSDesc; }
ClassDesc2*	FFDNMCylOSMod::GetClassDesc() { return &ffdNMCylOSDesc; }

class FFDNMCylWSObjClassDesc: public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new FFDNMCylWSObj; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_FFDCYL_C); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return FFDNMWSCYL_CLASS_ID; }
	const TCHAR* 	Category() { return GetSpaceWarpCatString(SPACEWARP_CAT_GEOMDEF); }
	const TCHAR*	InternalName() { return _T("SpaceFFDCyl"); }
	HINSTANCE		HInstance()	{ return hInstance; }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetClassParams<WSMObject>(); } // mjm - 2.3.99
	};
static FFDNMCylWSObjClassDesc ffdNMCylWSDesc;
ClassDesc* GetFFDNMCylWSDesc() { return &ffdNMCylWSDesc; }
ClassDesc2*	FFDNMCylWSObj::GetClassDesc() { return &ffdNMCylWSDesc; }


//--- RestoreObjects for undo/redo --------------------------------

#define WM_RESETDIMTEXT	(WM_USER+0x0382)


// A restore object to restore changes to the dimension
template <class T>
class DimRestore : public RestoreObj {
	public:
		int			undoDim[3], redoDim[3];
		BitArray	undoSel, redoSel;
		Tab<Control*> undoCont, redoCont;
		Tab<Point3> undoPt, redoPt, undoOffs, redoOffs;
		FFDNM<T>	*ffd;
		DimRestore(FFDNM<T> *f) {
			ffd = f;
			for (int i=0; i<3; i++) undoDim[i] = ffd->dim[i];
			undoCont = ffd->ptCont;
			undoPt = ffd->pt;
			undoOffs = ffd->offsets;
			undoSel = ffd->sel;
			}
		void Restore(int isUndo) {
			for (int i=0; i<3; i++) redoDim[i] = ffd->dim[i];
			redoCont = ffd->ptCont;
			redoPt = ffd->pt;			
			redoSel = ffd->sel;
			redoOffs = ffd->offsets;
			for (i=0; i<3; i++) ffd->dim[i] = undoDim[i];			
			ffd->ptCont = undoCont;					
			ffd->masterCont->SetNumSubControllers(undoCont.Count());
			ffd->pt = undoPt;
			ffd->offsets = undoOffs;
			ffd->sel = undoSel;
			ffd->NotifyDependents(FOREVER,PART_SELECT,REFMSG_CHANGE);
			ffd->NotifyDependents(FOREVER,PART_ALL,REFMSG_NODE_NAMECHANGE);
			ffd->NotifyDependents(FOREVER,PART_ALL,REFMSG_BRANCHED_HISTORY_CHANGED);
			if (ffd->pblock->GetMap()) PostMessage(ffd->pblock->GetMap()->GetHWnd(),WM_RESETDIMTEXT,0,0);
			}
		void Redo() {
			for (int i=0; i<3; i++) ffd->dim[i] = redoDim[i];
			ffd->ptCont = redoCont;
			ffd->pt = redoPt;
			ffd->offsets = redoOffs;
			ffd->sel = redoSel;			
			ffd->NotifyDependents(FOREVER,PART_SELECT,REFMSG_CHANGE);
			ffd->NotifyDependents(FOREVER,PART_ALL,REFMSG_NODE_NAMECHANGE);
			ffd->NotifyDependents(FOREVER,PART_ALL,REFMSG_BRANCHED_HISTORY_CHANGED);
			if (ffd->pblock->GetMap()) PostMessage(ffd->pblock->GetMap()->GetHWnd(),WM_RESETDIMTEXT,0,0);
			}

	};

// A restore object to save the selection state.
template <class T>
class SelRestore : public RestoreObj {
	public:		
		FFDNM<T>	*mod;
		BitArray	undo,redo;
		SelRestore(FFDNM<T> *m) { mod=m;undo=mod->sel; }
		void Restore(int isUndo) {
			// if we're undoing, save a redo state
			if (isUndo) redo = mod->sel;
			mod->sel = undo;
			mod->NotifyDependents(FOREVER,PART_SELECT,REFMSG_CHANGE);
			}
		void Redo() {
			mod->sel = redo;
			mod->NotifyDependents(FOREVER,PART_SELECT,REFMSG_CHANGE);
			}
	};

// A restore object to save the position of control points.
template <class T>
class MoveRestore : public RestoreObj {
	public:		
		FFDNM<T> *mod;
		Tab<Point3> undo, redo, undoOffs, redoOffs;
		MoveRestore(FFDNM<T> *m) {
			mod = m;
			undo.SetCount(mod->NumPts());
			undoOffs.SetCount(mod->NumPts());
			for (int i=0; i<mod->NumPts(); i++) {
				undo[i] = mod->GetPt(i);
				undoOffs[i] = mod->offsets[i];
				}
			}
		void Restore(int isUndo) {
			// if we're undoing, save a redo state
			if (isUndo) {
				redo.SetCount(mod->NumPts());
				redoOffs.SetCount(mod->NumPts());
				for (int i=0; i<mod->NumPts(); i++) {
					redo[i] = mod->GetPt(i);
					redoOffs[i] = mod->offsets[i];
					}
				}
			for (int i=0; i<mod->NumPts(); i++) {
				mod->pt[i] = undo[i];
				mod->offsets[i] = undoOffs[i];
				}
			mod->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
			}
		void Redo() {
			for (int i=0; i<mod->NumPts(); i++) {
				mod->pt[i] = redo[i];
				mod->offsets[i] = redoOffs[i];
				}
			mod->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
			}
		void EndHold() {
			mod->ClearAFlag(A_HELD);
			}
	};


//--- Parameter map/block descriptors -------------------------------

enum { ffd_params };
enum { ffd_disp_lattice, ffd_disp_source, ffd_deform, ffd_falloff, 
		ffd_tens, ffd_cont, ffd_length, ffd_width, ffd_height, 
		ffd_inpoints, ffd_outpoints, ffd_offset};


static ParamBlockDesc2 ffdos_box_param_blk ( ffd_params, _T("ffdparameters"),  0, &ffdNMSquareOSDesc, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF, 
	//rollout
	IDD_FFDNMOSPARAMS, IDS_RB_PARAMETERS, 0, 0, NULL,
	// params
	ffd_disp_lattice, 	_T("dispLattice"),		TYPE_BOOL, 		0,				IDS_RK_SHOWLATTICE,
		p_default, 		TRUE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_FFD_SHOWLATTICE, 
		end, 
	ffd_disp_source, 	_T("dispSource"),		TYPE_BOOL, 		0,				IDS_RK_SHOWSOURCE,
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_FFD_SHOWSOURCE, 
		end, 
	ffd_deform, 		_T("deformType"),		TYPE_INT, 		0,				0,
		p_default, 		0, 
		p_range, 		0, 1, 
		p_ui, 			TYPE_RADIO, 	2,		IDC_FFD_INVOLUME, IDC_FFD_DEFORMALL,  
		end, 
	ffd_falloff, 		_T("falloff"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RK_FALLOFF, 
		p_default, 		0.0, 
		p_range, 		0.0f, float(1.0E30), 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_UNIVERSE, IDC_FFD_FALLOFF,IDC_FFD_FALLOFFSPIN, SPIN_AUTOSCALE, 
		end, 
	ffd_tens, 			_T("tension"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RK_TENSION, 
		p_default, 		25.0f, 
		p_range, 		0.0f, 50.0f, 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_FLOAT, IDC_FFD_TENS,	IDC_FFD_TENSSPIN, 0.1f, 
		end, 
	ffd_cont, 			_T("continuity"), 		TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RK_CONT, 
		p_default, 		25.0, 
		p_range, 		0.0f, 50.0f, 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_FLOAT, IDC_FFD_CONT,	IDC_FFD_CONTSPIN, 0.1f, 
		end, 
	ffd_inpoints, 		_T("inPoints"),			TYPE_BOOL, 		0,				IDS_RK_INPOINTS,
		p_default, 		TRUE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_FFD_INPOINTS, 
		end,
	ffd_outpoints, 		_T("outPoints"),		TYPE_BOOL, 		0,				IDS_RK_OUTPOINTS,
		p_default, 		TRUE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_FFD_OUTPOINTS, 
		end,		
	ffd_offset, 		_T("offset"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RK_OFFSET, 
		p_default, 		0.05f, 
		p_range, 		-0.2f, 0.2f, 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_FLOAT, IDC_FFD_OFFSET,	IDC_FFD_OFFSETSPIN, 0.01f, 
		end,
	end
	);

static ParamBlockDesc2 ffdos_cyl_param_blk ( ffd_params, _T("ffdparameters"),  0, &ffdNMCylOSDesc, P_AUTO_CONSTRUCT + P_USE_PARAMS, PBLOCK_REF,
	// use params from existing descriptor
  	&ffdos_box_param_blk
	);
 
static ParamBlockDesc2 ffdws_box_param_blk ( ffd_params, _T("ffdparameters"),  0, &ffdNMSquareWSDesc, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF, 
	//rollout
	IDD_FFDNMWSPARAMS, IDS_RB_PARAMETERS, 0, 0, NULL,
	// params
	ffd_disp_lattice, 	_T("dispLattice"),		TYPE_BOOL, 		0,				IDS_RK_SHOWLATTICE,
		p_default, 		TRUE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_FFD_SHOWLATTICE, 
		end, 
	ffd_disp_source, 	_T("dispSource"),		TYPE_BOOL, 		0,				IDS_RK_SHOWSOURCE,
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_FFD_SHOWSOURCE, 
		end, 
	ffd_deform, 		_T("deformType"),		TYPE_INT, 		0,				0,
		p_default, 		0, 
		p_range, 		0, 1, 
		p_ui, 			TYPE_RADIO, 	2,		IDC_FFD_INVOLUME,IDC_FFD_DEFORMALL,  
		end, 
	ffd_falloff, 		_T("falloff"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RK_FALLOFF, 
		p_default, 		0.0, 
		p_range, 		0.0f, float(1.0E30), 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_UNIVERSE, IDC_FFD_FALLOFF,IDC_FFD_FALLOFFSPIN, SPIN_AUTOSCALE, 
		end, 
	ffd_tens, 			_T("tension"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RK_TENSION, 
		p_default, 		25.0f, 
		p_range, 		0.0f, 50.0f, 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_FLOAT, IDC_FFD_TENS,	IDC_FFD_TENSSPIN, 0.1f, 
		end, 
	ffd_cont, 			_T("continuity"), 		TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RK_CONT, 
		p_default, 		25.0, 
		p_range, 		0.0f, 50.0f, 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_FLOAT, IDC_FFD_CONT,	IDC_FFD_CONTSPIN, 0.1f, 
		end, 
	ffd_length, 		_T("length"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RK_LENGTH, 
		p_default, 		0.0, 
		p_range, 		0.0f, float(1.0E30), 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_UNIVERSE, IDC_FFD_LENGTH,IDC_FFD_LENGTHSPIN, SPIN_AUTOSCALE, 
		end,	
	ffd_width, 			_T("width"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RK_WIDTH, 
		p_default, 		0.0, 
		p_range, 		0.0f, float(1.0E30), 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_UNIVERSE, IDC_FFD_WIDTH,IDC_FFD_WIDTHSPIN, SPIN_AUTOSCALE, 
		end,			
	ffd_height, 		_T("height"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RK_HEIGHT, 
		p_default, 		0.0, 
		p_range, 		0.0f, float(1.0E30), 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_UNIVERSE, IDC_FFD_HEIGHT, IDC_FFD_HEIGHTSPIN, SPIN_AUTOSCALE, 
		end,
	end
	);

static ParamBlockDesc2 ffdws_cyl_param_blk ( ffd_params, _T("ffdparameters"),  0, &ffdNMCylWSDesc, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF,
	//rollout
	IDD_FFDNMWSCYLPARAMS, IDS_RB_PARAMETERS, 0, 0, NULL,
	// params
	ffd_disp_lattice, 	_T("dispLattice"),		TYPE_BOOL, 		0,				IDS_RK_SHOWLATTICE,
		p_default, 		TRUE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_FFD_SHOWLATTICE, 
		end, 
	ffd_disp_source, 	_T("dispSource"),		TYPE_BOOL, 		0,				IDS_RK_SHOWSOURCE,
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_FFD_SHOWSOURCE, 
		end, 
	ffd_deform, 		_T("deformType"),		TYPE_INT, 		0,				0,
		p_default, 		0, 
		p_range, 		0, 1, 
		p_ui, 			TYPE_RADIO, 	2,		IDC_FFD_INVOLUME,IDC_FFD_DEFORMALL,  
		end, 
	ffd_falloff, 		_T("falloff"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RK_FALLOFF, 
		p_default, 		0.0, 
		p_range, 		0.0f, float(1.0E30), 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_UNIVERSE, IDC_FFD_FALLOFF,IDC_FFD_FALLOFFSPIN, SPIN_AUTOSCALE, 
		end, 
	ffd_tens, 			_T("tension"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RK_TENSION, 
		p_default, 		25.0f, 
		p_range, 		0.0f, 50.0f, 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_FLOAT, IDC_FFD_TENS,	IDC_FFD_TENSSPIN, 0.1f, 
		end, 
	ffd_cont, 			_T("continuity"), 		TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RK_CONT, 
		p_default, 		25.0, 
		p_range, 		0.0f, 50.0f, 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_FLOAT, IDC_FFD_CONT,	IDC_FFD_CONTSPIN, 0.1f, 
		end, 
	//radius
	ffd_length, 		_T("radius"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RB_RADIUS, 
		p_default, 		0.0, 
		p_range, 		0.0f, float(1.0E30), 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_UNIVERSE, IDC_FFD_LENGTH,IDC_FFD_LENGTHSPIN, SPIN_AUTOSCALE, 
		end,	
	// height
	ffd_width, 			_T("height"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RB_HEIGHT, 
		p_default, 		0.0, 
		p_range, 		0.0f, float(1.0E30), 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_UNIVERSE, IDC_FFD_WIDTH,IDC_FFD_WIDTHSPIN, SPIN_AUTOSCALE, 
		end,			
	end
	);

//
//
// Parameters

#define PARAMDESC_LENGH_MOD		6
#define PARAMDESC_LENGH_OBJ		9
#define PARAMDESC_LENGH_OBJCYL	8

// The parameter block. Note that none of these parameters are animatable.
static ParamBlockDescID descVerModV0[] = {
	{ TYPE_INT,   NULL, FALSE, ffd_disp_lattice },
	{ TYPE_INT,   NULL, FALSE, ffd_disp_source },
	{ TYPE_INT,   NULL, FALSE, ffd_deform },
	{ TYPE_FLOAT, NULL, TRUE,  ffd_falloff }};

static ParamBlockDescID descVerModV1[] = {
	{ TYPE_INT,   NULL, FALSE, ffd_disp_lattice },
	{ TYPE_INT,   NULL, FALSE, ffd_disp_source },
	{ TYPE_INT,   NULL, FALSE, ffd_deform },
	{ TYPE_FLOAT, NULL, TRUE,  ffd_falloff },
	{ TYPE_FLOAT, NULL, TRUE,  ffd_tens },
	{ TYPE_FLOAT, NULL, TRUE,  ffd_cont }};
#define PBLOCK_LENGTH_MOD	6

static ParamBlockDescID descVerObjV0[] = {
	{ TYPE_INT,   NULL, FALSE, ffd_disp_lattice },
	{ TYPE_INT,   NULL, FALSE, ffd_disp_source },
	{ TYPE_INT,   NULL, FALSE, ffd_deform },
	{ TYPE_FLOAT, NULL, TRUE,  ffd_falloff },	
	{ TYPE_FLOAT, NULL, TRUE,  ffd_length },
	{ TYPE_FLOAT, NULL, TRUE,  ffd_width },
	{ TYPE_FLOAT, NULL, TRUE,  ffd_height }};

static ParamBlockDescID descVerObjV1[] = {
	{ TYPE_INT,   NULL, FALSE, ffd_disp_lattice },
	{ TYPE_INT,   NULL, FALSE, ffd_disp_source },
	{ TYPE_INT,   NULL, FALSE, ffd_deform },
	{ TYPE_FLOAT, NULL, TRUE,  ffd_falloff },
	{ TYPE_FLOAT, NULL, TRUE,  ffd_tens },
	{ TYPE_FLOAT, NULL, TRUE,  ffd_cont },
	{ TYPE_FLOAT, NULL, TRUE,  ffd_length },
	{ TYPE_FLOAT, NULL, TRUE,  ffd_width },
	{ TYPE_FLOAT, NULL, TRUE,  ffd_height }};


// Arrays of old versions
static ParamVersionDesc versionsMod[] = {
	ParamVersionDesc(descVerModV0,4,0),
	ParamVersionDesc(descVerModV1,6,1),
	};

static ParamVersionDesc versionsObjSquare[] = {
	ParamVersionDesc(descVerObjV0,7,0),
	ParamVersionDesc(descVerObjV1,9,1)
	};

static ParamVersionDesc versionsObjCyl[] = {
	ParamVersionDesc(descVerObjV0,6,0),
	ParamVersionDesc(descVerObjV1,8,1)
	};

#define NUM_OLDVERSIONS	2



//--- FFDDlgProc ---------------------------------------------
//
// A dialog proc for the about box
//


// NOTE:
// The following statement (which appears in the about box of this
// modifier) ABSOLUTELY MUST APPEAR in any modifier based on this
// code or that uses the FFD technology.
//
////////////////////////////////////////////////////////////////////
//
// Free Form Deformation Patent #4,821,214 licensed 
// from Viewpoint DataLabs Int'l, Inc., Orem, UT
// www.viewpoint.com
// 
////////////////////////////////////////////////////////////////////

static BOOL CALLBACK AboutDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			CenterWindow(hWnd, GetParent(hWnd));
			break;
		case WM_CLOSE:
			EndDialog(hWnd,1);

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					EndDialog(hWnd,1);
					break;
				}
			break;
		
		default:
			return FALSE;
		}
	return TRUE;
	}

static BOOL CALLBACK SetDimDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	static int *dim;

	switch (msg) {
		case WM_INITDIALOG: {
			dim = (int*)lParam;
			ISpinnerControl *spin;
			spin = GetISpinner(GetDlgItem(hWnd,IDC_FFD_DIM0SPIN));
			spin->SetLimits(dim[3],1000, FALSE);
			spin->SetScale(0.1f);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_FFD_DIM0), EDITTYPE_INT);
			spin->SetValue(dim[0],FALSE);
			ReleaseISpinner(spin);

			spin = GetISpinner(GetDlgItem(hWnd,IDC_FFD_DIM1SPIN));
			spin->SetLimits(2,1000, FALSE);
			spin->SetScale(0.1f);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_FFD_DIM1), EDITTYPE_INT);
			spin->SetValue(dim[1],FALSE);
			ReleaseISpinner(spin);

			spin = GetISpinner(GetDlgItem(hWnd,IDC_FFD_DIM2SPIN));
			spin->SetLimits(2,1000, FALSE);
			spin->SetScale(0.1f);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_FFD_DIM2), EDITTYPE_INT);
			spin->SetValue(dim[2],FALSE);
			ReleaseISpinner(spin);
			
			CenterWindow(hWnd, GetParent(hWnd));
			break;
			}		

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK: {
					ISpinnerControl *spin;
					spin = GetISpinner(GetDlgItem(hWnd,IDC_FFD_DIM0SPIN));
					dim[0] = spin->GetIVal();
					ReleaseISpinner(spin);

					spin = GetISpinner(GetDlgItem(hWnd,IDC_FFD_DIM1SPIN));
					dim[1] = spin->GetIVal();
					ReleaseISpinner(spin);

					spin = GetISpinner(GetDlgItem(hWnd,IDC_FFD_DIM2SPIN));
					dim[2] = spin->GetIVal();
					ReleaseISpinner(spin);

					EndDialog(hWnd,1);
					break;
					}
				case IDCANCEL:
					EndDialog(hWnd,0);
					break;
				}
			break;
		
		default:
			return FALSE;
		}
	return TRUE;
	}

template <class T>
class FFDDlgProc : public ParamMap2UserDlgProc {
	public:		
		FFDNM<T>	*ffd;
		HWND		hWnd;
		FFDDlgProc(FFDNM<T> *f) { ffd=f; }
		BOOL		DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void		DeleteThis() { delete this; }		
		void		InitDlg(HWND hWnd);
		void		SetDimText();
		void		SetFalloffState();
		void		SetButtonStates();
		void		Update(TimeValue t) { SetFalloffState(); }
	};

template <class T>
void FFDDlgProc<T>::InitDlg(HWND hWnd)
	{
	this->hWnd = hWnd;
	SetDimText();
	SetFalloffState();
	SetButtonStates();	
	}

template <class T>
void FFDDlgProc<T>::SetDimText()
	{
	TSTR buf;
	buf.printf(_T("%dx%dx%d"), ffd->dim[1], ffd->dim[0], ffd->dim[2]);
	SetDlgItemText(hWnd,IDC_FFD_DIMTEXT,buf);
	}

template <class T>
void FFDDlgProc<T>::SetFalloffState()
	{
	int def;
	ffd->pblock->GetValue(ffd_deform,0,def,FOREVER);
	ISpinnerControl *spin = GetISpinner(GetDlgItem(hWnd,IDC_FFD_FALLOFFSPIN));
	if (!def) {
		spin->Disable();
		EnableWindow(GetDlgItem(hWnd,IDC_FFD_FALLOFFLABEL),FALSE);
	} else {
		spin->Enable();
		EnableWindow(GetDlgItem(hWnd,IDC_FFD_FALLOFFLABEL),TRUE);
		}
	ReleaseISpinner(spin);
	}

template <class T>
void FFDDlgProc<T>::SetButtonStates()
	{
	ICustButton *but;
	but = GetICustButton(GetDlgItem(hWnd,IDC_FFD_ALLX));
	but->SetType(CBT_CHECK);
	but->SetCheck(ffd->allX);
	ReleaseICustButton(but);

	but = GetICustButton(GetDlgItem(hWnd,IDC_FFD_ALLY));
	but->SetType(CBT_CHECK);
	but->SetCheck(ffd->allY);
	ReleaseICustButton(but);

	but = GetICustButton(GetDlgItem(hWnd,IDC_FFD_ALLZ));
	but->SetType(CBT_CHECK);
	but->SetCheck(ffd->allZ);
	ReleaseICustButton(but);
	}

template <class T>
BOOL FFDDlgProc<T>::DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			InitDlg(hWnd);
			break;

		case WM_RESETDIMTEXT:
			SetDimText();
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_FFD_ALLX: {
					ICustButton *but = GetICustButton(GetDlgItem(hWnd,IDC_FFD_ALLX));
					ffd->allX = but->IsChecked();
					ReleaseICustButton(but);
					break;
					}
				case IDC_FFD_ALLY: {
					ICustButton *but = GetICustButton(GetDlgItem(hWnd,IDC_FFD_ALLY));
					ffd->allY = but->IsChecked();
					ReleaseICustButton(but);
					break;
					}
				case IDC_FFD_ALLZ: {
					ICustButton *but = GetICustButton(GetDlgItem(hWnd,IDC_FFD_ALLZ));
					ffd->allZ = but->IsChecked();
					ReleaseICustButton(but);
					break;
					}

				case IDC_FFD_SETDIM: {
					int dim[4] = { ffd->dim[0],ffd->dim[1],ffd->dim[2],ffd->MinXDim()};
					if (DialogBoxParam(
						hInstance,
						MAKEINTRESOURCE(ffd->GetSetDimDlgID()),
						hWnd,
						SetDimDlgProc,
						(LPARAM)dim)) {
						Point3 d = Point3(dim[0],dim[1],dim[2]);
						macroRecorder->FunctionCall(_T("setDimensions"), 2, 0, mr_reftarg, ffd, mr_point3, &d);
						theHold.Begin();						
						ffd->SetGridDim(dim);
						theHold.Accept(GetString(IDS_RB_SETFFDDIM));
						SetDimText();
						}
					break;
					}

				case IDC_FFD_DEFORMALL:
				case IDC_FFD_INVOLUME:
					SetFalloffState();
					break;

				case IDC_FFD_RESET:
					macroRecorder->FunctionCall(_T("resetLattice"), 1, 0, mr_reftarg, ffd, mr_funcall);
					theHold.Begin();
					ffd->SetGridDim(ffd->dim);
					//ffd->sel=0;
					theHold.Accept(GetString(IDS_RK_RESETLATTICE));						
					break;

				case IDC_FFD_ANIMATEALL:
					macroRecorder->FunctionCall(_T("animateAll"), 1, 0, mr_reftarg, ffd, mr_funcall);
					theHold.Begin();
					ffd->AnimateAll();
					theHold.Accept(GetString(IDS_RK_ANIMATEALL));					
					break;
				
				case IDC_FFD_CONFORM: {
					HCURSOR hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
					macroRecorder->FunctionCall(_T("conformToShape"), 1, 0, mr_reftarg, ffd, mr_funcall);
					theHold.Begin();
					ffd->Conform();
					theHold.Accept(GetString(IDS_RK_CONFORM));
					SetCursor(hCur);
					}
					break;

				case IDC_FFD_ABOUT:
					// Put up the about box
					DialogBox(
						hInstance,
						MAKEINTRESOURCE(IDD_FFD_ABOUTNM),
						hWnd,
						AboutDlgProc);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}


//--- FFDNM  Methods ----------------------------------------------


template <class T>
FFDNM<T>::FFDNM()
	{
	selLevel = 0;
	dim[0] = dim[1] = dim[2] = 0;
	tmControl = NULL;
	pblock = NULL;
	masterCont = NULL;		
	beenDeformed = FALSE;
	}

template <class T>
void FFDNM<T>::BaseClone(FFDNM<T> *src,RemapDir &remap,BOOL noRef)
	{
	if (noRef) {
		src->tmControl = tmControl;
		src->pblock    = pblock;
		src->masterCont = masterCont;
	} else {
		if (tmControl) src->ReplaceReference(0,remap.CloneRef(tmControl));
		src->ReplaceReference(1,remap.CloneRef(pblock));
		src->ReplaceReference(2,remap.CloneRef(masterCont));
		}
	src->ptCont.SetCount(NumPts());	
	src->masterCont->SetNumSubControllers(NumPts());
	src->pt       = pt;
	src->offsets  = offsets;
	src->sel      = sel;
	src->selLevel = selLevel;
	src->dim[0]   = dim[0];
	src->dim[1]   = dim[1];
	src->dim[2]   = dim[2];
	src->lbox     = lbox;	
	src->beenDeformed = beenDeformed;
	for (int i=0; i<NumPts(); i++) {
		src->ptCont[i] = NULL;
		if (ptCont[i] && !noRef) {
			src->ReplaceReference(i+3,remap.CloneRef(ptCont[i]));
			}
		}
	}

template <class T>
void FFDNM<T>::PlugControllers(TimeValue t, BOOL all)
	{
	BOOL notify=FALSE;
	// Plug-in controllers for selected points without controllers
	// if we're animating
	if (all || (Animating() && t!=0)) { 	// RK: Adding option to animate all
		SuspendAnimate();
		AnimateOff();
		for (int i=0; i<NumPts(); i++) { 		
			if ((all || sel[i]) && !GetPtCont(i)) {
				ReplaceReference(3+i,NewDefaultPoint3Controller());				
				theHold.Suspend();				
				GetPtCont(i)->SetValue(0,&pt[i],TRUE,CTRL_ABSOLUTE);								
				theHold.Resume();
				masterCont->SetSubController(i,GetPtCont(i));
				notify = TRUE;
				}			
			}
		ResumeAnimate();
	}
	if (notify) NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	}

static Point3 Reflect(Point3 axis, Point3 vect)
	{
   	axis = Normalize(axis);
	Point3 perp = Normalize(axis^vect) ^ axis;
	return (DotProd(vect,axis)*axis) - (DotProd(vect,perp)*perp);
	}
 
template <class T>
Point3 FFDNM<T>::GetPtOR(int i, int j, int k)
	{
	int ii=i, jj=j, kk=k;
	if (i<0) i = 0; if (i>dim[0]-1) i = dim[0]-1;
	if (j<0) j = 0; if (j>dim[1]-1) j = dim[1]-1;
	if (k<0) k = 0; if (k>dim[2]-1) k = dim[2]-1;
	int gi = GridIndex(i,j,k);
	Point3 p = GetPt(gi)-offsets[gi];
	if (ii!=i || jj!=j || kk!=k) {
		if (TRUE) {
			Point3 pp=p, pp1, pp2;
			if (ii<0) {
				if (WrapX()) {
					p = GetPtOR(dim[0]+ii,jj,kk);
				} else {
					pp  = GetPtOR(i  ,jj,kk);
					pp1 = GetPtOR(i+1,jj,kk);
					if (dim[0]>2) {
						pp2 = GetPtOR(i+2,jj,kk);
						p += Reflect(pp-pp1,pp1-pp2);
					} else {
						p += pp-pp1;
						}
					}
				}
			if (ii>dim[0]-1) {
				if (WrapX()) {
					p = GetPtOR(ii-dim[0],jj,kk);
				} else {
					pp  = GetPtOR(i  ,jj,kk);
					pp1 = GetPtOR(i-1,jj,kk);
					if (dim[0]>2) {
						pp2 = GetPtOR(i-2,jj,kk);
						p += Reflect(pp-pp1,pp1-pp2);
					} else {
						p += pp-pp1;
						}
					}
				}

			if (jj<0) {
				pp  = GetPtOR(ii,j  ,kk);
				pp1 = GetPtOR(ii,j+1,kk);
				if (dim[1]>2) {
					pp2 = GetPtOR(ii,j+2,kk);
					p += Reflect(pp-pp1,pp1-pp2);
				} else {
					p += pp-pp1;
					}
				}
			if (jj>dim[1]-1) {
				pp  = GetPtOR(ii,j  ,kk);
				pp1 = GetPtOR(ii,j-1,kk);
				if (dim[1]>2) {
					pp2 = GetPtOR(ii,j-2,kk);
					p += Reflect(pp-pp1,pp1-pp2);
				} else {
					p += pp-pp1;
					}
				}

			if (kk<0) {
				pp  = GetPtOR(ii,jj,k  );
				pp1 = GetPtOR(ii,jj,k+1);
				if (dim[2]>2) {
					pp2 = GetPtOR(ii,jj,k+2);
					p += Reflect(pp-pp1,pp1-pp2);
				} else {
					p += pp-pp1;
					}
				}
			if (kk>dim[2]-1) {
				pp  = GetPtOR(ii,jj,k  );
				pp1 = GetPtOR(ii,jj,k-1);
				if (dim[2]>2) {
					pp2 = GetPtOR(ii,jj,k-2);
					p += Reflect(pp-pp1,pp1-pp2);
				} else {
					p += pp-pp1;
					}
				}
		} else { 			
			float x = 1.0f/float(dim[0]-1);
			float y = 1.0f/float(dim[1]-1);
			float z = 1.0f/float(dim[2]-1);
			if (ii<0) {
				if (WrapX()) p = GetPtOR(dim[0]+ii,jj,kk);
				else p.x -= x; 
				}
			if (ii>dim[0]-1) {
				if (WrapX()) p = GetPtOR(ii-dim[0],jj,kk);
				else p.x += x;
				}
			if (jj<0) p.y -= y; if (jj>dim[1]-1) p.y += y;
			if (kk<0) p.z -= z; if (kk>dim[2]-1) p.z += z;
			}
		}
	return p;
	}

template <class T>
void FFDNM<T>::SetPtCont(int i,Control *c)
	{
	ptCont[i]=c;
	if (masterCont) 
		masterCont->SetSubController(i,c);
	}

template <class T>
Point3 FFDNM<T>::GetPt(int i)
	{
	return pt[i];
	}

template <class T>
Point3 FFDNM<T>::GetControlPoint(TimeValue t, int i, int src, BOOL initVol)
	{	
	if (initVol) return pt[i];
	if (src) {
		return GetSourcePoint(i);
	} else {
		if (ptCont[i]) {
			// The point is animated, get it from the controller
			Point3 p;
			ptCont[i]->GetValue(t,&p,FOREVER,CTRL_ABSOLUTE);
			return p;
		} else {
			// the point is not animated.
			return pt[i];
			}
		}
	}

template <class T>
void FFDNM<T>::AnimateAll()
{
	PlugControllers(0, TRUE);	
}

template <class T>
void FFDNM<T>::Conform()
{
	int inPts, outPts, out=FALSE;
	Ray ry;
	Point3 norm, ipt, center, s;
	float at, off;	
	sMyEnumProc dep;              
	EnumDependents(&dep);
	TimeValue t = GetCOREInterface()->GetTime();
	
	if (SuperClassID()==WSM_OBJECT_CLASS_ID || (dep.Nodes.Count() != 1) ||
			!dep.Nodes[0]->EvalWorldState(t).obj->IsSubClassOf(triObjectClassID))
		return;
	
	inPts = pblock->GetInt(ffd_inpoints);
	outPts = pblock->GetInt(ffd_outpoints);
	off = pblock->GetFloat(ffd_offset);

	if (theHold.Holding()) theHold.Put(new MoveRestore<T>(this));	
	if (!inPts && !outPts) return;

	Box3 box;		
	ObjectState os = dep.Nodes[0]->EvalWorldState(t);
	os.obj->GetDeformBBox(t, box,NULL);
	Mesh *ffdmesh = &((TriObject*)os.obj)->GetMesh();
	if (!ffdmesh) return;		
	
	// Calculate the center of the mesh
	Point3 sum = Point3(0,0,0);	
	for (int v=0; v < ffdmesh->numVerts; v++)
		sum += ffdmesh->getVert(v);
	center = sum/(float)ffdmesh->numVerts;		
	s = LatticeSize(box);
	
	// Shrink wrap the lattice to fit the shape of the object
	for (int i=0; i<NumPts(); i++) {				
		
		BOOL hit = FALSE; 	
		Point3 lp = GetPt(i);				
		
		// Try three times by varying ry.p, to avoid de-generated faces
		for (int j=0; j < 3 && !hit; j++, ry.p.y += 0.01f) {
			// Shoot ray from lattice point to center
			ry.p = box.Min() + lp*s;		
			ry.dir =  center - ry.p;			
			if (ffdmesh->IntersectRay(ry, at, norm))
				out = hit = TRUE;
			}
		
		if (!hit || at>1.0f) {			
			// Shoot ray from center to lattice point
			ry.p = center;
			ry.dir =  box.Min() + lp*s - ry.p;
			if (ffdmesh->IntersectRay(ry, at, norm))
				out = !(hit = TRUE);
			}
		if (!hit || (out ? !outPts : !inPts))
			continue;
		
		// Compute the point of intersection 
		ipt = (ry.p + ry.dir * (at-off) - box.Min())/s; 		
		
		// Move the lattice point to the point of intersection
		pt[i] = ipt;
		offsets[i] = ipt-GetSourcePoint(i);
		}
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);	
}

template <class T>
int FFDNM<T>::GridDim(int which)
	{
	return dim[which];
	}

template <class T>
int FFDNM<T>::GridIndex(int i, int j, int k)
	{
	int ix = k*dim[0]*dim[1] + j*dim[0] + i;
	assert(ix>=0 && ix<NumPts());
	return ix;
	}

template <class T>
void FFDNM<T>::SetGridDim(int dm[3])
	{
	if (dm[0]<MinXDim()) dm[0] = MinXDim();
	DimRestore<T> *rest = NULL;
	if (theHold.Holding()) rest = new DimRestore<T>(this);
	for (int i=0; i<3; i++) dim[i] = dm[i];
	for (i=0; i<ptCont.Count(); i++) DeleteReference(i+3);	
	int total = dim[0]*dim[1]*dim[2];
	ptCont.SetCount(total);
	masterCont->SetNumSubControllers(total);
	pt.SetCount(total);	
	offsets.SetCount(total);
	sel.SetSize(total);
	for (i=0; i<total; i++) {
		ptCont[i] = NULL;
		pt[i] = GetSourcePoint(i);
		offsets[i] = Point3(0,0,0);
		}	
	if (rest) theHold.Put(rest);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_NODE_NAMECHANGE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_BRANCHED_HISTORY_CHANGED);
	}

template <class T>
int FFDNM<T>::DrawControlPoints(
		TimeValue t,ViewExp *vpt,GraphicsWindow *gw,
		Box3 box,BOOL ht,INode *inode,
		ModContext *mc,int flags)
	{
	MakeBoxThick(box);
	Point3 s = LatticeSize(box);
	Point3 p, pp[3];
	int res=0, dispLat, dispSrc;
	int level = ip ?  ip->GetSubObjectLevel() : SEL_LATTICE;		
	if (!ht) level = selLevel;
	// RK: 04/23/99 commented as it is showing sel vertices in green when sub-object 
	//     level is set to 0 through MaxScript 
	//if (!ht && !(flags&DISP_SHOWSUBOBJECT)) level = 0;

	pblock->GetValue(ffd_disp_lattice,0,dispLat,FOREVER);
	pblock->GetValue(ffd_disp_source,0,dispSrc,FOREVER);

	// Draw the control points
	for (int i=0; i<NumPts(); i++) {
		// Maybe skip sel or unsel points
		if (ht && flags&HIT_SELONLY   && !sel[i]) continue;
		if (ht && flags&HIT_UNSELONLY &&  sel[i]) continue;

		// Set the line color based on selection
		if (!ht)
		{
			if (level==SEL_POINTS) {
				if ( sel[i]) //gw->setColor(LINE_COLOR, (float)1, (float)1, (float)0.0);
					gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));
				if (!sel[i]) //gw->setColor(LINE_COLOR, (float).85, (float).5, (float)0.0);
					gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
				}			
			else if (level==SEL_SETVOLUME) {
				if ( sel[i]) gw->setColor(LINE_COLOR, (float)1, (float)0, (float)0.0);				
				if (!sel[i]) gw->setColor(LINE_COLOR, (float)0, (float)1, (float)0.0);				
				}
		}
		// Draw the point
		p = GetControlPoint(t,i,dispSrc,level==SEL_SETVOLUME)*s + box.Min();
		gw->marker(&p,HOLLOW_BOX_MRKR);		
		
		// If we're hit testing then check for a hit and log it
		if (ht && gw->checkHitCode()) {
			gw->clearHitCode();
			if (ip && level) vpt->LogHit(inode, mc, gw->getHitDistance(), i, NULL);
			res = 1;
			if (flags&HIT_ABORTONHIT) return res;
			if (level==SEL_LATTICE) return 1;
			}
		}

	if (0 && !ht) {
		gw->setColor(LINE_COLOR, (float)0, (float)0, (float)1);
		for (int i=-1; i<dim[0]+1; i++) {
			for (int j=-1; j<dim[1]+1; j++) {
				for (int k=-1; k<dim[2]+1; k++) {
					if (i<0||i>=dim[0]||j<0||j>=dim[1]||k<0||k>=dim[2]) {
						p = GetPtOR(i,j,k)*s + box.Min();
						gw->marker(&p,HOLLOW_BOX_MRKR);		
						}
					}
				}
			}
		//gw->setColor(LINE_COLOR, (float).85, (float).5, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
		}		

	// Don't hit test the lattice
	if (ht && level!=SEL_LATTICE && level) return res;
	if (!dispLat) return res;

	// Set the GW line color
	if (level!=SEL_LATTICE ) {
		//gw->setColor( LINE_COLOR, (float).85, (float).5, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
		}

	// Draw the lattice
	if (inode->IsFrozen()) {
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_FREEZE));
		}
	for (i=0; i<GridDim(0); i++) {
		for (int j=0; j<GridDim(1); j++) {
			for (int k=0; k<GridDim(2); k++) {
				pp[0] = GetControlPoint(t,GridIndex(i,j,k),dispSrc,level==SEL_SETVOLUME)*s + box.Min();
				if (i<GridDim(0)-1 || WrapX()) {
					int ii = i+1;
					if (ii>GridDim(0)-1) ii = 0;					
					pp[1] = GetControlPoint(t,GridIndex(ii,j,k),dispSrc,level==SEL_SETVOLUME)*s + box.Min();
					gw->polyline(2,pp,NULL,NULL,FALSE,NULL);
					}
				if (j<GridDim(1)-1) {
					pp[1] = GetControlPoint(t,GridIndex(i,j+1,k),dispSrc,level==SEL_SETVOLUME)*s + box.Min();
					gw->polyline(2,pp,NULL,NULL,FALSE,NULL);
					}
				if (k<GridDim(2)-1) {
					pp[1] = GetControlPoint(t,GridIndex(i,j,k+1),dispSrc,level==SEL_SETVOLUME)*s + box.Min();
					gw->polyline(2,pp,NULL,NULL,FALSE,NULL);
					}
				}
			}
		}
	
	if (ht && gw->checkHitCode()) {
		gw->clearHitCode();
		if (ip && level) vpt->LogHit(inode, mc, gw->getHitDistance(), i, NULL);
		return 1;
		}
	return 0;
	}

template <class T>
int FFDNM<T>::SubNumToRefNum(int subNum)
	{
	if (subNum==1) return -1;
	else return subNum;
	}

template <class T>
BOOL FFDNM<T>::AssignController(Animatable *control,int subAnim)
	{
	ReplaceReference(subAnim,(RefTargetHandle)control);	
	if (subAnim==MASTER_REF) {
		int n = NumPtConts();
		masterCont->SetNumSubControllers(n);
		for (int i=0; i<n; i++)
			if (GetPtCont(i)) masterCont->SetSubController(i,GetPtCont(i));
		}
	NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE,TREE_VIEW_CLASS_ID,FALSE);	
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	return TRUE;
	}

template <class T>
RefTargetHandle FFDNM<T>::GetReference(int i)
	{
	if (i==0) 
		return tmControl;
	else if (i==1) {
		return pblock;
	} else if (i==2) {
		return masterCont;
	} else if (i<NumPts()+3) { 		
		return GetPtCont(i-3);
	} else 
		return NULL;
	}

template <class T>
void  FFDNM<T>::SetReference(int i, RefTargetHandle rtarg)
	{
	if (i==0) 
		tmControl = (Control*)rtarg;
	else if (i==1) {
		pblock = (IParamBlock2*)rtarg;
	} else if (i==2) {
		masterCont = (MasterPointControl*)rtarg;
		if (masterCont)
			masterCont->SetNumSubControllers(NumPtConts());
	} else if (i<NumPts()+3) {
		SetPtCont(i-3,(Control*)rtarg);
	} else 
		assert(0);
	}

template <class T>
TSTR  FFDNM<T>::SubAnimName(int i)
	{
	if (i==0) {
		return GetString(IDS_RB_LATTICETM);
	} else if (i==1) {
		return GetString(IDS_RB_PARAMETERS);
	} else if (i==2) {
		return GetString(IDS_RK_MASTER);
	} else if (i<NumPts()+3) { 		
		TSTR str;
		str.printf(GetString(IDS_RB_CONTROLPOINTN),i-2);
		return str;
	} else 
		return TSTR();
	}

template <class T>
int  FFDNM<T>::RemapRefOnLoad(int iref) {
	if(loadRefVersion == ES_REF_VER_0 && iref > PBLOCK_REF)
		return iref+1;
	return iref;
}

#define FFD_SEL_CHUNKID			0x0100
#define FFD_PT_CHUNKID			0x0200
#define FFD_DIM_CHUNKID			0x0300
#define FFD_SELLEVEL_CHUNKID	0x0400
#define FFD_OFFSETS_CHUNKID		0x0500
// The following chunk tells which reference version we're dealing with
#define REF_VERSION_CHUNK		0x2000

//deform involume setting has changed from 2.5 to 3.0, this will fix that
template <class T>
class InVolFixPLCB : public PostLoadCallback 
{
public:
	FFDNM<T> *ffd;

	InVolFixPLCB(FFDNM<T>* f) { ffd = f; }
	void proc(ILoad *iload)
	{
		if (ffd->loadRefVersion == ES_REF_VER_0)
			ffd->pblock->SetValue(ffd_deform, 0, !ffd->pblock->GetInt(ffd_deform,0));
		delete this;
	}
};

template <class T>
IOResult  FFDNM<T>::Load(ILoad *iload)
	{
	T::Load(iload);	
	iload->RegisterPostLoadCallback(new InVolFixPLCB<T>(this));
	ULONG nb;
	IOResult res;
	loadRefVersion = ES_REF_VER_0;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case REF_VERSION_CHUNK:
				res = iload->Read(&loadRefVersion,sizeof(int), &nb);
				break;
			case FFD_DIM_CHUNKID: {
				int dm[3];
				iload->Read(dm,sizeof(int)*3, &nb);
				SetGridDim(dm);
				break;
				}
			case FFD_SEL_CHUNKID:
				sel.Load(iload);
				break;
			case FFD_PT_CHUNKID:
				res = iload->Read(&pt[0],NumPts()*sizeof(Point3), &nb);
				break;
			case FFD_OFFSETS_CHUNKID:
				res = iload->Read(&offsets[0],NumPts()*sizeof(Point3), &nb);
				break;
			case FFD_SELLEVEL_CHUNKID:
				iload->Read(&selLevel,sizeof(selLevel), &nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

template <class T>
IOResult  FFDNM<T>::Save(ISave *isave)
	{
	T::Save(isave);
	ULONG nb;

	int refVer = ES_REF_VER_1;
	
	isave->BeginChunk(REF_VERSION_CHUNK);
	isave->Write(&refVer,sizeof(int), &nb);
	isave->EndChunk();
	
	isave->BeginChunk(FFD_DIM_CHUNKID);
	isave->Write(&dim[0],sizeof(int)*3,&nb);
	isave->EndChunk();
	
	isave->BeginChunk(FFD_SEL_CHUNKID);
	sel.Save(isave);
	isave->EndChunk();
	
	isave->BeginChunk(FFD_PT_CHUNKID);
	isave->Write(&pt[0],NumPts()*sizeof(Point3), &nb);
	isave->EndChunk();

	isave->BeginChunk(FFD_OFFSETS_CHUNKID);
	isave->Write(&offsets[0],NumPts()*sizeof(Point3), &nb);
	isave->EndChunk();

	isave->BeginChunk(FFD_SELLEVEL_CHUNKID);
	isave->Write(&selLevel,sizeof(selLevel),&nb);
	isave->EndChunk();

	return IO_OK;
	}

template <class T>
int  FFDNM<T>::Display(
		TimeValue t, INode* inode, ViewExp *vpt, 
		int flags, ModContext *mc)
	{
	if (mc && mc->box) lbox = *mc->box;
	MakeBoxThick(lbox);
	GraphicsWindow *gw = vpt->getGW();
	
	// Compute a the transformation out of lattice space into world space
	// Then plug this matrix into the GW.	
	Matrix3 tm = CompTM(t,inode,mc);
	gw->setTransform(tm);
	
	// Draw...
	if (inode->Selected() && SuperClassID()!=OSM_CLASS_ID &&
		(!(flags&DISP_SHOWSUBOBJECT) || selLevel==0)) {
		gw->setColor( LINE_COLOR, GetSelColor());
	} else {
		if (ip && ip->GetSubObjectLevel()==SEL_LATTICE) {
			//gw->setColor(LINE_COLOR, (float)1, (float)1, (float)0.0);
			gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));
		} else {
			if (inode->IsFrozen()) {
				gw->setColor(LINE_COLOR,GetUIColor(COLOR_FREEZE));
			} else {
				//gw->setColor(LINE_COLOR, (float).85, (float).5, (float)0.0);
				gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
				}
			}
		}	
	DrawControlPoints(t,vpt,gw,lbox,FALSE,inode,mc,flags);

	return 0;
	}

template <class T>
void  FFDNM<T>::GetWorldBoundBox(
		TimeValue t,INode* inode, ViewExp *vpt, 
		Box3& box, ModContext *mc)
	{
	if (mc && mc->box) lbox = *mc->box;	
	MakeBoxThick(lbox);
	Point3 s = LatticeSize(lbox);
	Point3 p;
	GraphicsWindow *gw = vpt->getGW();	
	if (lbox.IsEmpty()) return;
	
	// Compute a the transformation out of lattice space into world space	
	Matrix3 tm = CompTM(t,inode,mc);
	
	// Expand the box to include all control points
	for (int i=0; i<NumPts(); i++) {
		p    = GetControlPoint(t,i)*s + lbox.Min();
		box += p * tm;
		}
	}

template <class T>
int  FFDNM<T>::HitTest(
		TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc)
	{
	if (mc && mc->box) lbox = *mc->box;
	MakeBoxThick(lbox);
	GraphicsWindow *gw = vpt->getGW();
	
	// Set the GW into pick mode.
	int savedLimits;
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->clearHitCode();
	HitRegion hr;
	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);

	// Compute a the transformation out of lattice space into world space
	// Then plug this matrix into the GW.
	Matrix3 tm = CompTM(t,inode,mc);	
	gw->setTransform(tm);

	int res = DrawControlPoints(t,vpt,gw,lbox,TRUE,inode,mc,flags);

	// Restore the GW's render limits
	gw->setRndLimits(savedLimits);

	return res;
	}

template <class T>
void FFDNM<T>::SelectPt(int i, BOOL s, BOOL clearAll)
	{
	if (theHold.Holding()) theHold.Put(new SelRestore<T>(this));	
	if (clearAll) sel.ClearAll();
	else if (!s) sel.Clear(i);
	else sel.Set(i);
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

template <class T>
BOOL FFDNM<T>::SelectSubAnim(int subNum)
	{
	if (theHold.Holding()) theHold.Put(new SelRestore<T>(this));
	
	BOOL add = GetKeyState(VK_CONTROL)<0;
	BOOL sub = GetKeyState(VK_MENU)<0;

	if (!add && !sub) sel.ClearAll();
	if (sub)
		 sel.Clear(subNum-3);
	else sel.Set(subNum-3);

	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	return TRUE;
	}


template <class T>
void  FFDNM<T>::SelectSubComponent(
		HitRecord *hitRec, BOOL selected, 
		BOOL all, BOOL invert)
	{
	int level = ip->GetSubObjectLevel();
	if (level==SEL_LATTICE) return;

	if (theHold.Holding()) theHold.Put(new SelRestore<T>(this));
	while (hitRec) {
		BOOL state = selected;
		if (invert) state = !sel[hitRec->hitInfo];
		if (allX || allY || allZ) {
			ExpandSelection(hitRec->hitInfo,state);
		} else {
			if (state) sel.Set(hitRec->hitInfo);
			else       sel.Clear(hitRec->hitInfo);
			}
		if (!all) break;
		hitRec = hitRec->Next();
		}	
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

template <class T>
void  FFDNM<T>::ClearSelection(int selLevel)
	{
	int level = ip->GetSubObjectLevel();
	if (level==SEL_LATTICE) return;

	if (theHold.Holding()) theHold.Put(new SelRestore<T>(this));
	sel.ClearAll();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

template <class T>
void  FFDNM<T>::SelectAll(int selLevel)
	{
	if (theHold.Holding()) theHold.Put(new SelRestore<T>(this));
	sel.SetAll();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

template <class T>
void  FFDNM<T>::InvertSelection(int selLevel)
	{
	if (theHold.Holding()) theHold.Put(new SelRestore<T>(this));
	sel = ~sel;
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

template <class T>
void FFDNM<T>::ExpandSelection(int ix, BOOL on)
	{
	int j, k, i;	
	if (dim[0]==0 || dim[1]==0) return;	

	k   = ix/(dim[0]*dim[1]);
	ix -= k*(dim[0]*dim[1]);
	j   = ix/dim[0];
	ix -= j*dim[0];
	i   = ix;

	if (allX) {
		for (int ix=0; ix<dim[0]; ix++) {
			if (allY) {
				for (int jx=0; jx<dim[1]; jx++) {
					int index = GridIndex(ix,jx,k);			
					sel.Set(index,on);
					}
				}
			if (allZ) {
				for (int kx=0; kx<dim[2]; kx++) {
					int index = GridIndex(ix,j,kx);			
					sel.Set(index,on);
					}
				}
			int index = GridIndex(ix,j,k);			
			sel.Set(index,on);
			}
		}
	if (allY) {
		for (int jx=0; jx<dim[1]; jx++) {
			if (allX) {
				for (int ix=0; ix<dim[0]; ix++) {
					int index = GridIndex(ix,jx,k);			
					sel.Set(index,on);
					}
				}
			if (allZ) {
				for (int kx=0; kx<dim[2]; kx++) {
					int index = GridIndex(ix,j,kx);			
					sel.Set(index,on);
					}
				}
			int index = GridIndex(i,jx,k);
			sel.Set(index,on);
			}
		}
	if (allZ) {
		for (int kx=0; kx<dim[2]; kx++) {
			if (allX) {
				for (int ix=0; ix<dim[0]; ix++) {
					int index = GridIndex(ix,j,kx);			
					sel.Set(index,on);
					}
				}
			if (allY) {
				for (int jx=0; jx<dim[1]; jx++) {
					int index = GridIndex(i,jx,kx);			
					sel.Set(index,on);
					}
				}
			int index = GridIndex(i,j,kx);
			sel.Set(index,on);
			}
		}
	}

template <class T>
void  FFDNM<T>::ActivateSubobjSel(int level, XFormModes& modes)
	{
	selLevel = level;
	if (level==SEL_OBJECT) {
		// Make sure these modes aren't still on the command stack.
		ip->DeleteMode(moveMode);
		ip->DeleteMode(rotMode);
		ip->DeleteMode(uscaleMode);
		ip->DeleteMode(nuscaleMode);
		ip->DeleteMode(squashMode);
		ip->DeleteMode(selectMode);		
	} else {
		modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,selectMode);
		}		
	NotifyDependents(FOREVER, SELECT_CHANNEL|PART_SUBSEL_TYPE|PART_DISPLAY, REFMSG_CHANGE);
	ip->PipeSelLevelChanged();
	NotifyDependents(FOREVER, SELECT_CHANNEL|DISP_ATTRIB_CHANNEL|SUBSEL_TYPE_CHANNEL, REFMSG_CHANGE);
	}

template <class T>
void  FFDNM<T>::Move(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin)
	{
	int level = ip->GetSubObjectLevel();
	if (level==SEL_LATTICE) {
		SetXFormPacket pckt(val,partm,tmAxis);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
	} else { 		
		PlugControllers(t);

		// Compute a matrix to move points
		Matrix3 ctm(1);
		if (tmControl) tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);
		Matrix3 tm  = ctm * partm * Inverse(tmAxis);
		Matrix3 itm = Inverse(tm);
		tm *= TransMatrix(val);
		
		// Compute scale (and inverse scale) to and from lattice space
		// and apply it to the matrices	
		Matrix3 stm = ScaleMatrix(LatticeSize(lbox));
		stm.SetTrans(lbox.Min());
		tm  = stm * tm;
		itm = itm * Inverse(stm);

		// Hold for undo
		if (theHold.Holding() && !TestAFlag(A_HELD)) {
			theHold.Put(new MoveRestore<T>(this));
			SetAFlag(A_HELD);
			}
		
		// Move the control points
		for (int i=0; i<NumPts(); i++) {
			if (sel[i]) {
				if (GetPtCont(i)) {
					GetPtCont(i)->GetValue(t,&pt[i],FOREVER,CTRL_ABSOLUTE);
					pt[i] = (tm*GetPt(i))*itm;
					GetPtCont(i)->SetValue(t,&pt[i],TRUE,CTRL_ABSOLUTE);
				} else {					
					Point3 p = GetPt(i);
					pt[i] = (tm*p)*itm;					
					// Calculate offsets if setting the initial state of the lattice
					if(selLevel==SEL_SETVOLUME) offsets[i] += GetPt(i)-p;//GetPt(i) - GetSourcePoint(i);
					}
				}
			}
		}
	NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
	}

template <class T>
void  FFDNM<T>::Rotate(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Quat& val, BOOL localOrigin)
	{
	int level = ip->GetSubObjectLevel();
	if (level==SEL_LATTICE) {
		SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	} else {
		PlugControllers(t);

		Matrix3 ctm(1);
		if (tmControl) tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);
		Matrix3 tm  = ctm * partm * Inverse(tmAxis);
		Matrix3 itm = Inverse(tm);
		Matrix3 mat;
		val.MakeMatrix(mat);
		tm *= mat;

		// Compute scale (and inverse scale) to and from lattice space
		// and apply it to the matrices	
		Matrix3 stm = ScaleMatrix(LatticeSize(lbox));
		stm.SetTrans(lbox.Min());
		tm  = stm * tm;
		itm = itm * Inverse(stm);

		// Hold for undo
		if (theHold.Holding() && !TestAFlag(A_HELD)) {
			theHold.Put(new MoveRestore<T>(this));
			SetAFlag(A_HELD);
			}
		
		// Move the control points
		for (int i=0; i<NumPts(); i++) {
			if (sel[i]) {
				if (GetPtCont(i)) {
					GetPtCont(i)->GetValue(t,&pt[i],FOREVER,CTRL_ABSOLUTE);
					pt[i] = (tm*GetPt(i))*itm;
					GetPtCont(i)->SetValue(t,&pt[i],TRUE,CTRL_ABSOLUTE);
				} else {
					Point3 p =  GetPt(i);
					pt[i] = (tm*p)*itm;
					// Calculate offsets if setting the initial state of the lattice
					if(selLevel==SEL_SETVOLUME) offsets[i] += GetPt(i)-p;
					}
				}
			}
		}
	NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
	}

template <class T>
void  FFDNM<T>::Scale(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin)
	{
	int level = ip->GetSubObjectLevel();
	if (level==SEL_LATTICE) {
		SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	} else {
		PlugControllers(t);

		Matrix3 ctm(1);
		if (tmControl) tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);
		Matrix3 tm  = ctm * partm * Inverse(tmAxis);
		Matrix3 itm = Inverse(tm);
		tm *= ScaleMatrix(val);;
		
		// Compute scale (and inverse scale) to and from lattice space
		// and apply it to the matrices	
		Matrix3 stm = ScaleMatrix(LatticeSize(lbox));
		stm.SetTrans(lbox.Min());
		tm  = stm * tm;
		itm = itm * Inverse(stm);

		// Hold for undo
		if (theHold.Holding() && !TestAFlag(A_HELD)) {
			theHold.Put(new MoveRestore<T>(this));
			SetAFlag(A_HELD);
			}
		
		// Move the control points
		for (int i=0; i<NumPts(); i++) {
			if (sel[i]) {
				if (GetPtCont(i)) {
					GetPtCont(i)->GetValue(t,&pt[i],FOREVER,CTRL_ABSOLUTE);
					pt[i] = (tm*GetPt(i))*itm;
					GetPtCont(i)->SetValue(t,&pt[i],TRUE,CTRL_ABSOLUTE);
				} else {
					Point3 p = GetPt(i);
					pt[i] = (tm*p)*itm;
					// Calculate offsets if setting the initial state of the lattice
					if(selLevel==SEL_SETVOLUME) offsets[i] += GetPt(i)-p;
					}
				}
			}
		}
	NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
	}

template <class T>
void  FFDNM<T>::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	// Compute a the transformation out of lattice space into world space	
	if (mc && mc->box) lbox = *mc->box;
	MakeBoxThick(lbox);
	Point3 s = LatticeSize(lbox);
	Matrix3 tm = CompTM(t,node,mc);	

	int level = ip->GetSubObjectLevel();
	if (level==SEL_LATTICE) {
		cb->Center(tm.GetTrans(),0);
	} else {
		Point3 cent(0,0,0);
		int ct=0;
		for (int i=0; i<NumPts(); i++) {
			if (sel[i]) {
				cent += (GetControlPoint(t,i)*s + lbox.Min()) * tm;
				ct++;
				}
			}
		if (ct) { 
			cent /= float(ct);
			cb->Center(cent,0);
			}
		}
	}

template <class T>
void  FFDNM<T>::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	// Compute a the transformation out of lattice space into world space
	Matrix3 tm = CompTM(t,node,mc);
	cb->TM(tm,0);
	}

template <class T>
TCHAR *FFDNM<T>::GetObjectName()
	{
	static TSTR buf;
	buf.printf("%s %dx%dx%d",GetString(GetNameID()),
		GridDim(1), GridDim(0), GridDim(2));
	return buf;
	}

template <class T>
Matrix3 FFDNM<T>::CompTM(TimeValue t,INode *inode,ModContext *mc)
	{
	// Compute a the transformation out of lattice space into world space	
	//Matrix3 ntm = inode->GetObjTMBeforeWSM(t);
	// RB 2/22/99: When a WS mod is applied to an FFD WS obj, the points are 
	// already transformed into world space so we want to make sure we don't
	// transform twice. GetObjectTM() correctly returns the identity when the
	// object has already been transformed.
	Matrix3 ntm = inode->GetObjectTM(t); 
	Matrix3 ctm(1);
	if (mc && mc->tm) {
		ntm = Inverse(*(mc->tm)) * ntm;
		}
	if (tmControl) tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);
	return ctm * ntm;
	}

template <class T>
void FFDNM<T>::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{
	this->ip = ip;
	editFFD = this;		
	
	// Activate the right-click menu callback
	ffdMenu = new FFDRightMenu<FFDNM<T> >(this);
	ip->GetRightClickMenuManager()->Register(ffdMenu);
	
	// Set up keyboard shortcuts    
	ffdShortcutCB = new FFDShortcutCB<FFDNM<T> >(this);
    ip->ActivateShortcutTable(ffdShortcutCB, kFFDShortcuts);

	// Creates some modes
	moveMode       = new MoveModBoxCMode(this,ip);
	rotMode        = new RotateModBoxCMode(this,ip);
	uscaleMode     = new UScaleModBoxCMode(this,ip);
	nuscaleMode    = new NUScaleModBoxCMode(this,ip);
	squashMode     = new SquashModBoxCMode(this,ip);
	selectMode     = new SelectModBoxCMode(this,ip);

	// Add our sub object type
	if (SuperClassID()==OSM_CLASS_ID) {
		TSTR type1(GetString(IDS_RB_CONTPOINTS));	
		TSTR type2(GetString(IDS_RB_LATTICE));	
		TSTR type3(GetString(IDS_RK_SETVOLUME));
		const TCHAR *ptype[] = { type1,type2, type3};
		ip->RegisterSubObjectTypes(ptype, 3);

		// Notify the system that we have an apparatus to display
		TimeValue t = ip->GetTime();
		NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
		NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
		SetAFlag(A_MOD_BEING_EDITED);
	} else {
		TSTR type1(GetString(IDS_RB_CONTPOINTS));
		const TCHAR *ptype[] = { type1};
		ip->RegisterSubObjectTypes(ptype, 1);
		}

	if (SuperClassID()==WSM_OBJECT_CLASS_ID) {
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_FFD_SOT),
			DefaultSOTProc,
			GetString(IDS_RB_SOT), 
			(LPARAM)ip,APPENDROLL_CLOSED);
		}

	ParamBlockDesc2 *pbd = GetClassDesc()->GetParamBlockDesc(0);
	pbd->flags |= P_AUTO_UI;
	GetClassDesc()->BeginEditParams(ip, this, flags, prev);
	pbd->SetUserDlgProc(new FFDDlgProc<T>(this));	
	
	if ((SuperClassID() != WSM_OBJECT_CLASS_ID)) {
		// Disable "conform" controls if multiple objects or non-triobjects are selected
		sMyEnumProc dep;              
		EnumDependents(&dep);
		
		if ((dep.Nodes.Count() != 1) ||
			!dep.Nodes[0]->EvalWorldState(ip->GetTime()).obj->IsSubClassOf(triObjectClassID)) {
				EnableWindow(GetDlgItem(pblock->GetMap()->GetHWnd(),IDC_FFD_CONFORM), FALSE);
				EnableWindow(GetDlgItem(pblock->GetMap()->GetHWnd(),IDC_FFD_INPOINTS), FALSE);
				EnableWindow(GetDlgItem(pblock->GetMap()->GetHWnd(),IDC_FFD_OUTPOINTS), FALSE);
				EnableWindow(GetDlgItem(pblock->GetMap()->GetHWnd(),IDC_FFD_OFFSETLABEL),FALSE);
				ISpinnerControl *spin = GetISpinner(GetDlgItem(pblock->GetMap()->GetHWnd(),IDC_FFD_OFFSETSPIN));				
				spin->Disable();			
				ReleaseISpinner(spin);
			}
	}
	// Restore the selection level
	ip->SetSubObjectLevel(selLevel);

	// Disable show end result.
	ip->EnableShowEndResult(FALSE);
	}

template <class T>
void FFDNM<T>::EndEditParams(
		IObjParam *ip,ULONG flags,Animatable *next)
	{
	ip->GetRightClickMenuManager()->Unregister(ffdMenu);
	delete ffdMenu;
	ip->DeactivateShortcutTable(ffdShortcutCB, kFFDShortcuts);
	delete ffdShortcutCB;

	if (hSot) ip->DeleteRollupPage(hSot);
	hSot = NULL;

	// Turn off aparatus display
	if (SuperClassID()==OSM_CLASS_ID) {
		TimeValue t = ip->GetTime();
		ClearAFlag(A_MOD_BEING_EDITED);
		NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
		NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);
		}
	
	ip->DeleteMode(moveMode);
	ip->DeleteMode(rotMode);
	ip->DeleteMode(uscaleMode);
	ip->DeleteMode(nuscaleMode);
	ip->DeleteMode(squashMode);
	ip->DeleteMode(selectMode);
	if (moveMode) delete moveMode;
	moveMode = NULL;
	if (rotMode) delete rotMode;
	rotMode = NULL;
	if (uscaleMode) delete uscaleMode;
	uscaleMode = NULL;
	if (nuscaleMode) delete nuscaleMode;
	nuscaleMode = NULL;
	if (squashMode) delete squashMode;
	squashMode = NULL;
	if (selectMode) delete selectMode;
	selectMode = NULL;
	
	this->ip = NULL;
	editFFD  = NULL;

	GetClassDesc()->EndEditParams(ip, this, flags, next);	

	// Enable show end result
	ip->EnableShowEndResult(TRUE);
	}

//--- FFDNMDeformer -------------------------------------------------


template <class T>
FFDNMDeformer<T>::FFDNMDeformer(
		FFDNM<T> *ffd,TimeValue t,Matrix3 *mtm, Box3 &box, BOOL ws)
	{
	pts = NULL;
	this->ffd = ffd;
	if (!ffd) return;

	inVol = !ffd->pblock->GetInt(ffd_deform,t);
	ffd->pblock->GetValue(ffd_falloff,t,falloff,FOREVER);	
	dim[0] = ffd->dim[0]; dim[1]=ffd->dim[1]; dim[2]=ffd->dim[2];
	wrapX = ffd->WrapX();
	
	// Evaluate any controllers
	for (int i=0; i<ffd->NumPts(); i++) {
		if (ffd->ptCont[i]) {
			ffd->ptCont[i]->GetValue(t,&ffd->pt[i],FOREVER,CTRL_ABSOLUTE);
			}
		}
	
	// Build a cache of all points
	pts = new Point3**[ffd->dim[0]+(ffd->WrapX()?0:2)];
	for (i=0; i<ffd->dim[0]+(ffd->WrapX()?0:2); i++) {
		pts[i] = new Point3*[ffd->dim[1]+2];
		for (int j=0; j<ffd->dim[1]+2; j++) {
			pts[i][j] = new Point3[ffd->dim[2]+2];
			for (int k=0; k<ffd->dim[2]+2; k++) {				
				pts[i][j][k] = ffd->GetPtOR(i-(ffd->WrapX()?0:1),j-1,k-1);
				}
			}
		}

	// Evaluate the TM controller
	Matrix3 ctm(1);
	if (ffd->tmControl)
		ffd->tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);
	
	// Start with the ModContext TM or node TM (if there is one)
	tm  = mtm ? *mtm : Matrix3(1);
	
	// Apply our TM to the MC TM
	tm *= Inverse(ctm);
	
	// The origin of the TM is the lower left corner of the
	// box, not the center.
	tm.SetTrans(tm.GetTrans()-box.Min());
	
	// Compute scale factors to normalize lattice space
	// to the extents of the box.
	Point3 s = LatticeSize(box);
	for (i=0; i<3; i++) {
		if (s[i]==0.0f) s[i] = 1.0f;
		else s[i] = 1.0f/s[i];
		}
	tm.Scale(s,TRUE);

	// Compute the inverse.
	itm = Inverse(tm);

	// If the lattice has been transformed into WS we need to untransform the result.
	if (ffd->beenDeformed && mtm && ws) {
		itm = itm * (*mtm);
		}

	// Compute the TCB multipliers	
	float tens = 0.0f;
	float cont = 0.0f;
	ffd->pblock->GetValue(ffd_tens,t,tens,FOREVER);
	ffd->pblock->GetValue(ffd_cont,t,cont,FOREVER);
	tens = (tens-25.0f)/25.0f;
	cont = (cont-25.0f)/25.0f;
	ComputeTCBMults(tens,cont,m1,m2);
	}

inline float BPoly4(int i, float u)
	{
	float s = 1.0f-u;
	switch (i) {
		case 0: return s*s*s;
		case 1: return 3.0f*u*s*s;
		case 2: return 3.0f*u*u*s;
		case 3: return u*u*u;
		default: return 0.0f;
		}
	}

template <class T>
Point3 FFDNMDeformer<T>::Map(int ii, Point3 p)
	{
	if (!ffd) return p;

	Point3 q(0,0,0), pp;
	
	// Transform into lattice space
	pp = p*tm;

	// Allow derived classes to do additional inverse transforms
	pp = ffd->InverseLattice(pp);	

	// Compute distance for falloff
	float dist = 0.0f;
	if (inVol) { 		
		if (ffd->WrapX()) {
			if (pp.y<-0.001f || pp.y>1.001f ||
				pp.z<-0.001f || pp.z>1.001f) {
				return p;
				}
		} else {
			if (pp.x<-0.001f || pp.x>1.001f ||
				pp.y<-0.001f || pp.y>1.001f ||
				pp.z<-0.001f || pp.z>1.001f) {
				return p;
				}
			}
	} else
	if (falloff>0.0f) {
		float closest = 0.0f;
		BOOL found = FALSE;
		if (!ffd->WrapX()) {
			if (pp.x<0.0f && -pp.x>closest) { closest=-pp.x; found=TRUE; }
			if (pp.x>1.0f && (pp.x-1.0f)>closest) { closest=pp.x-1.0f; found=TRUE; }
			}
		if (pp.y<0.0f && -pp.y>closest) { closest=-pp.y; found=TRUE; }
		if (pp.y>1.0f && (pp.y-1.0f)>closest) { closest=pp.y-1.0f; found=TRUE; }
		if (pp.z<0.0f && -pp.z>closest) { closest=-pp.z; found=TRUE; }		
		if (pp.z>1.0f && (pp.z-1.0f)>closest) { closest=pp.z-1.0f; found=TRUE; }
		if (found) {
			dist = closest;
			if (dist>falloff) return p;
			}
		}

	// Find the cell we're in	
	pp.x = pp.x*float(ffd->dim[0]-(ffd->WrapX()?0:1));
	pp.y = pp.y*float(ffd->dim[1]-1);
	pp.z = pp.z*float(ffd->dim[2]-1);
	int i = int(pp.x);
	int j = int(pp.y);
	int k = int(pp.z);
	int io=i, jo=j, ko=k;
	if (!ffd->WrapX()) {
		if (i<0) i = 0; if (i>ffd->dim[0]-2) i = ffd->dim[0]-2;
		}
	if (j<0) j = 0; if (j>ffd->dim[1]-2) j = ffd->dim[1]-2;
	if (k<0) k = 0; if (k>ffd->dim[2]-2) k = ffd->dim[2]-2;	

	// Make pp relative to our cell
	pp.x -= float(i);
	pp.y -= float(j);
	pp.z -= float(k);

	// We are going to consider all surrounding cells. Make i,j,k
	// refer to the corner of a 3x3x3 cell array with the current cell at the center.
	i -= 1; j -= 1; k -= 1;

#if 0	
	for (int ix=0; ix<4; ix++) {
		for (int jx=0; jx<4; jx++) {
			Point3 knots[4];
			for (int kx=0; kx<4; kx++) { 				
				int ii;
				if (ffd->WrapX()) {
					ii = i+ix;
					if (ii<0) ii = dim[0]+ii;
					if (ii>dim[0]-1) ii = ii-dim[0];
				} else {
					ii = i+ix+1;
					}
				q += (pts[ii][j+jx+1][k+kx+1]+Point3(0.5,0.5,0.5))*
					BPoly4(ii,pp.x)*
					BPoly4(j+jx+1,pp.y)*
					BPoly4(k+kx+1,pp.z);
				}			
			}
		}
	return q*itm;
#else 	
	
	// Interpolate the 64 control points using Z to get 16 points
	Point3 pt[4][4];
	for (int ix=0; ix<4; ix++) {
		for (int jx=0; jx<4; jx++) {
			Point3 knots[4];
			for (int kx=0; kx<4; kx++) { 				
				int ii;
				if (ffd->WrapX()) {
					ii = i+ix;
					if (ii<0) ii = dim[0]+ii;
					if (ii>dim[0]-1) ii = ii-dim[0];
				} else {
					ii = i+ix+1;
					}
				knots[kx] = pts[ii][j+jx+1][k+kx+1];					
				}
			pt[ix][jx] = InterpSpline(pp.z,knots,m1,m2);
			}
		}

	// Now interpolate 16 points to get a single 4 point spline
	Point3 knots[4];
	for (ix=0; ix<4; ix++) {
		knots[ix] = InterpSpline(pp.y,pt[ix],m1,m2);
		}

	// Finally we get the point
	q = InterpSpline(pp.x,knots,m1,m2) * itm;

	if (falloff>0.0f && dist>0.0f) {
		float u=dist/falloff;
		u = (u*u*(3-2*u));
		q = u*p + (1.0f-u)*q;
		}	 
	return q;
#endif
	}

//--- FFDNMSquare ----------------------------------------------------

template <class T>
Point3 FFDNMSquare<T>::GetSourcePoint(int i)
	{
	int j, k;
	
	if (dim[0]==0 || dim[1]==0) return Point3(0,0,0);

	k = i/(dim[0]*dim[1]);
	i -= k*(dim[0]*dim[1]);
	j = i/dim[0];
	i -= j*dim[0];

	return Point3(
		float(i)/float(dim[0]-1),
		float(j)/float(dim[1]-1),
		float(k)/float(dim[2]-1));
	}


//--- FFDNMCyl ----------------------------------------------------

// Radius of sqrt(.5) for a cylinder that bounds a 1x1 box
#define CYL_RAD	0.7071067812f

template <class T>
Point3 FFDNMCyl<T>::GetSourcePoint(int i)
	{
	int j, k;
	
	if (dim[0]==0 || dim[1]==0) return Point3(0,0,0);

	k = i/(dim[0]*dim[1]);
	i -= k*(dim[0]*dim[1]);
	j = i/dim[0];
	i -= j*dim[0];

	float u = float(i)/float(dim[0]);
	float v = float(j)/float(dim[1]-1);
	
	return Point3(
		float(cos(u*TWOPI)*CYL_RAD*v+0.5),
		float(sin(u*TWOPI)*CYL_RAD*v+0.5),
		float(k)/float(dim[2]-1));
	}

template <class T>
Point3 FFDNMCyl<T>::InverseLattice(Point3 p)
	{
	float x = p.x-0.5f;
	float y = p.y-0.5f;
	float l = (float)sqrt(x*x + y*y);
	if (l==0.0f) {
		p.x = 0.0f;
	} else {
		p.x = float(atan2(y,x));
		if (p.x<0.0f) p.x += TWOPI;
		p.x /= TWOPI;		
		}
	p.y = l/CYL_RAD;	
	return p;
	}


//--- FFDNMSquareOSMod ----------------------------------------------------


template <class T>
FFDNMOSMod<T>::FFDNMOSMod()
	{	
	tmControl = NULL;
	MakeRefByID(FOREVER,TM_REF,NewDefaultMatrix3Controller()); 	
	pblock = NULL;	

	// Create the ffd master control
	masterCont = NULL;		
	MakeRefByID(FOREVER, MASTER_REF, NewDefaultMasterPointController());	
	int dm[3] = { 4,4,4};
	SetGridDim(dm);
	}

FFDNMSquareOSMod::FFDNMSquareOSMod()
	{ 	
	ffdos_box_param_blk.dlg_template = IDD_FFDNMOSPARAMS;
	ffdos_box_param_blk.title = IDS_RB_PARAMETERS;

	GetClassDesc()->MakeAutoParamBlocks(this);
	}

FFDNMCylOSMod::FFDNMCylOSMod() 
	{ 
	ffdos_cyl_param_blk.dlg_template = IDD_FFDNMOSPARAMS;
	ffdos_cyl_param_blk.title = IDS_RB_PARAMETERS;
	GetClassDesc()->MakeAutoParamBlocks(this);
	}

Interval FFDNMSquareOSMod::LocalValidity(TimeValue t)
	{ 	
	// If we're being edited, then returning NEVER for our
	// validity will ensure that the output of the previous
	// modifier is cached.
	if (TestAFlag(A_MOD_BEING_EDITED))
		 return NEVER;  
	else {
		// Our validity depends on whether any of our controllers
		// are animated.
		Interval valid = FOREVER;
		Matrix3 ctm(1);
		Point3 p;
		tmControl->GetValue(t,&ctm,valid,CTRL_RELATIVE);
		float f;
		pblock->GetValue(ffd_falloff,t,f,valid);
		pblock->GetValue(ffd_tens,t,f,valid);
		pblock->GetValue(ffd_cont,t,f,valid);
		for (int i=0; i<NumPts(); i++) { 			
			if (GetPtCont(i)) GetPtCont(i)->GetValue(t,&p,valid,CTRL_ABSOLUTE);
			}
		return valid;
		}
	}
Interval FFDNMCylOSMod::LocalValidity(TimeValue t)
	{ 	
	// If we're being edited, then returning NEVER for our
	// validity will ensure that the output of the previous
	// modifier is cached.
	if (TestAFlag(A_MOD_BEING_EDITED))
		 return NEVER;  
	else {
		// Our validity depends on whether any of our controllers
		// are animated.
		Interval valid = FOREVER;
		Matrix3 ctm(1);
		Point3 p;
		tmControl->GetValue(t,&ctm,valid,CTRL_RELATIVE);
		float f;		
		pblock->GetValue(ffd_falloff,t,f,valid);
		pblock->GetValue(ffd_tens,t,f,valid);
		pblock->GetValue(ffd_cont,t,f,valid);
		for (int i=0; i<NumPts(); i++) { 			
			if (GetPtCont(i)) GetPtCont(i)->GetValue(t,&p,valid,CTRL_ABSOLUTE);
			}
		return valid;
		}
	}


void FFDNMSquareOSMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{	
	// Compute our validity interval
	Interval valid = LocalValidity(t);
	if (valid.Empty()) valid.SetInstant(t);

	// Cache the input box
	lbox = *mc.box;
	MakeBoxThick(lbox);
	
	// Apply the deformer	
	FFDNMDeformer<Modifier> deformer(this,t,mc.tm,lbox);
	os->obj->Deform(&deformer, TRUE);	
	deformer.FreePointCache();

	// This will intersect our validity with the object's
	// validity.
	os->obj->UpdateValidity(GEOM_CHAN_NUM,valid);	
	}
void FFDNMCylOSMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	// Compute our validity interval
	Interval valid = LocalValidity(t);
	if (valid.Empty()) valid.SetInstant(t);

	// Cache the input box
	lbox = *mc.box;
	MakeBoxThick(lbox);

	// Apply the deformer
	FFDNMDeformer<Modifier> deformer(this,t,mc.tm,lbox);	
	os->obj->Deform(&deformer, TRUE);		
	deformer.FreePointCache();	

	// This will intersect our validity with the object's
	// validity.
	os->obj->UpdateValidity(GEOM_CHAN_NUM,valid);
	}

RefTargetHandle FFDNMSquareOSMod::Clone(RemapDir &remap)
	{
	FFDNMSquareOSMod *mod = new FFDNMSquareOSMod;
	BaseClone(mod,remap);
	return mod;
	}
RefTargetHandle FFDNMCylOSMod::Clone(RemapDir &remap)
	{
	FFDNMCylOSMod *mod = new FFDNMCylOSMod;
	BaseClone(mod,remap);
	return mod;
	}

IOResult FFDNMSquareOSMod::Load(ILoad *iload)
	{
	FFDNM<Modifier>::Load(iload);	
	iload->RegisterPostLoadCallback(
		new ParamBlock2PLCB(versionsMod, NUM_OLDVERSIONS, &ffdos_box_param_blk, this, PBLOCK_REF));
	return IO_OK;
	}
IOResult FFDNMCylOSMod::Load(ILoad *iload)
	{
	FFDNM<Modifier>::Load(iload);
	iload->RegisterPostLoadCallback(
		new ParamBlock2PLCB(versionsMod, NUM_OLDVERSIONS, &ffdos_cyl_param_blk, this, PBLOCK_REF));
	return IO_OK;
	}


//--- FFDNMSquareWSObj --------------------------------------------------

FFDNMSquareWSObj::FFDNMSquareWSObj(BOOL noRef)
	{ 	
	geomValid = selValid = FOREVER;
	selLevelValid = TRUE;
	if (!noRef) {		
		pblock = NULL;				
		GetClassDesc()->MakeAutoParamBlocks(this);		
		masterCont = NULL;		
		MakeRefByID(FOREVER, MASTER_REF, NewDefaultMasterPointController());	
		int dm[3] = { 4,4,4};
		SetGridDim(dm);
	} else {
		pblock = NULL;		
		}
	}
FFDNMCylWSObj::FFDNMCylWSObj(BOOL noRef)
	{
	geomValid = selValid = FOREVER;
	selLevelValid = TRUE;
	if (!noRef) {		
		pblock = NULL;				
		GetClassDesc()->MakeAutoParamBlocks(this);
		masterCont = NULL;		
		MakeRefByID(FOREVER, MASTER_REF, NewDefaultMasterPointController());	
		int dm[3] = { 8,4,4};
		SetGridDim(dm);
	} else {
		pblock = NULL;
		}
	}


BOOL FFDNMSquareWSObj::IsSubClassOf(Class_ID classID)
	{
	return ((classID==ClassID()) || (classID==GENFFDOBJECT_CLASS_ID));
	}
BOOL FFDNMCylWSObj::IsSubClassOf(Class_ID classID)
	{
	return ((classID==ClassID()) || (classID==GENFFDOBJECT_CLASS_ID));
	}

int FFDNMSquareWSObj::CanConvertToType(Class_ID obtype) 
	{
	return IsSubClassOf(obtype) || obtype==defObjectClassID;
	}
int FFDNMCylWSObj::CanConvertToType(Class_ID obtype) 
	{
	return IsSubClassOf(obtype) || obtype==defObjectClassID;
	}

RefTargetHandle FFDNMSquareWSObj::Clone(RemapDir &remap)
	{
	FFDNMSquareWSObj *obj = new FFDNMSquareWSObj;
	BaseClone(obj,remap);
	return obj;
	}
RefTargetHandle FFDNMCylWSObj::Clone(RemapDir &remap)
	{
	FFDNMCylWSObj *obj = new FFDNMCylWSObj;
	BaseClone(obj,remap);
	return obj;
	}


IOResult FFDNMSquareWSObj::Load(ILoad *iload)
	{
	FFDNM<WSMObject>::Load(iload);
	iload->RegisterPostLoadCallback(		
		new ParamBlock2PLCB(versionsObjSquare, NUM_OLDVERSIONS, &ffdws_box_param_blk, this, PBLOCK_REF));
	return IO_OK;
	}
IOResult FFDNMCylWSObj::Load(ILoad *iload)
	{
	FFDNM<WSMObject>::Load(iload);
	iload->RegisterPostLoadCallback(		
		new ParamBlock2PLCB(versionsObjCyl, NUM_OLDVERSIONS, &ffdws_cyl_param_blk, this, PBLOCK_REF));
	return IO_OK;
	}

void FFDNMSquareWSObj::GetWorldBoundBox(
		TimeValue t, INode* inode, ViewExp* vpt, Box3& box)
	{
	UpdateBox(t);
	FFDNM<WSMObject>::GetWorldBoundBox(t,inode,vpt,box,NULL);
	}
void FFDNMCylWSObj::GetWorldBoundBox(
		TimeValue t, INode* inode, ViewExp* vpt, Box3& box)
	{
	UpdateBox(t);
	FFDNM<WSMObject>::GetWorldBoundBox(t,inode,vpt,box,NULL);
	}


void FFDNMSquareWSObj::GetLocalBoundBox(
		TimeValue t, INode* inode, ViewExp* vpt, Box3& box)
	{
	UpdateBox(t);
	box = lbox;
	
	if (beenDeformed) {
		Box3 abox; abox.Init();
		Point3 s = LatticeSize(lbox);
		for (int i=0; i<pt.Count(); i++) {			
			abox += pt[i]*s + lbox.Min();
			}
		box = abox;
		}
	}
void FFDNMCylWSObj::GetLocalBoundBox(
		TimeValue t, INode* inode, ViewExp* vpt, Box3& box)
	{
	UpdateBox(t);	
	box = lbox;	

	if (beenDeformed) {
		Box3 abox; abox.Init();
		Point3 s = LatticeSize(lbox);
		for (int i=0; i<pt.Count(); i++) {			
			abox += pt[i]*s + lbox.Min();
			}
		box = abox;
		}
	}

void FFDNMSquareWSObj::GetDeformBBox(
		TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel)
	{
	Matrix3 ttm(1);
	if (!tm) tm = &ttm;
	UpdateBox(t);
	if (selLevel!=SEL_POINTS && selLevel!=SEL_SETVOLUME) useSel = FALSE;
	if (useSel || tm) {
		Point3 s = LatticeSize(lbox);
		box.Init();
		for (int i=0; i<pt.Count(); i++) {
			if (sel[i] || !useSel) {
				box += (pt[i]*s + lbox.Min())* *tm;
				}
			}
	} else {
		box = lbox;
		}
	}
void FFDNMCylWSObj::GetDeformBBox(
		TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel)
	{
	Matrix3 ttm(1);
	if (!tm) tm = &ttm;
	UpdateBox(t);
	if (selLevel!=SEL_POINTS && selLevel!=SEL_SETVOLUME) useSel = FALSE;
	if (useSel || tm) {
		Point3 s = LatticeSize(lbox);
		box.Init();
		for (int i=0; i<pt.Count(); i++) {
			if (sel[i] || !useSel) {
				box += (pt[i]*s + lbox.Min())* *tm;
				}
			}
	} else {
		box = lbox;
		}
	}

int FFDNMSquareWSObj::Display(
		TimeValue t, INode* inode, ViewExp *vpt, int flags)
	{
	UpdateBox(t);
	return FFDNM<WSMObject>::Display(t,inode,vpt,flags,NULL);		
	}
int FFDNMCylWSObj::Display(
		TimeValue t, INode* inode, ViewExp *vpt, int flags)
	{
	UpdateBox(t);
	return FFDNM<WSMObject>::Display(t,inode,vpt,flags,NULL);		
	}

int FFDNMSquareWSObj::HitTest(
		TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt)
	{
	return FFDNM<WSMObject>::HitTest(t,inode,type,crossing,flags,p,vpt,NULL);
	}
int FFDNMCylWSObj::HitTest(
		TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt)
	{
	return FFDNM<WSMObject>::HitTest(t,inode,type,crossing,flags,p,vpt,NULL);
	}

Interval FFDNMSquareWSObj::ObjectValidity(TimeValue t)
	{
	Interval valid = FOREVER;	
	float f;
	Point3 p;	
	valid &= geomValid;
	valid &= selValid;
	for (int i=0; i<NumPts(); i++) { 			
		if (GetPtCont(i)) GetPtCont(i)->GetValue(t,&p,valid,CTRL_ABSOLUTE);
		}
	pblock->GetValue(ffd_width,t,f,valid);
	pblock->GetValue(ffd_length,t,f,valid);
	pblock->GetValue(ffd_height,t,f,valid);
	return valid;
	}
Interval FFDNMCylWSObj::ObjectValidity(TimeValue t)
	{
	Interval valid = FOREVER;	
	float f;
	Point3 p;	
	valid &= geomValid;
	valid &= selValid;
	for (int i=0; i<NumPts(); i++) { 			
		if (GetPtCont(i)) GetPtCont(i)->GetValue(t,&p,valid,CTRL_ABSOLUTE);
		}
	pblock->GetValue(ffd_width,t,f,valid);
	pblock->GetValue(ffd_length,t,f,valid);	
	return valid;
	}


static void RectifyBox(Box3 &box)
	{
	for (int i=0; i<3; i++) {
		if (box.pmin[i]>box.pmax[i]) {
			float tmp   = box.pmin[i];
			box.pmin[i] = box.pmax[i];
			box.pmax[i] = tmp;
			}
		}
	}

void FFDNMSquareWSObj::UpdateBox(TimeValue t)
	{	
	float l, w, h;	
	pblock->GetValue(ffd_width,t,w,FOREVER);
	pblock->GetValue(ffd_length,t,l,FOREVER);
	pblock->GetValue(ffd_height,t,h,FOREVER);

	lbox.pmin = Point3(-w/2.0f,-l/2.0f,-h/2.0f);
	lbox.pmax = Point3( w/2.0f, l/2.0f, h/2.0f);	

	RectifyBox(lbox);
	}
void FFDNMCylWSObj::UpdateBox(TimeValue t)
	{
	float r,h;		
	pblock->GetValue(ffd_width,t,r,FOREVER);
	pblock->GetValue(ffd_length,t,h,FOREVER);	

	lbox.pmin = Point3(-r,-r,-h/2.0f);
	lbox.pmax = Point3( r, r, h/2.0f);

	RectifyBox(lbox);
	}

Modifier *FFDNMSquareWSObj::CreateWSMMod(INode *node)
	{
	return new FFDNMWSMod(node);
	}
Modifier *FFDNMCylWSObj::CreateWSMMod(INode *node)
	{
	return new FFDNMWSMod(node);
	}

ObjectState FFDNMSquareWSObj::Eval(TimeValue t) 
	{
	UpdateBox(t);
	selValid = geomValid = FOREVER;
	selLevelValid = TRUE;
	for (int i=0; i<ptCont.Count(); i++) {
		if (ptCont[i]) ptCont[i]->GetValue(t,&pt[i],geomValid,CTRL_ABSOLUTE);
		}
	return ObjectState(this);
	}
ObjectState FFDNMCylWSObj::Eval(TimeValue t) 
	{
	UpdateBox(t);
	selValid = geomValid = FOREVER;
	selLevelValid = TRUE;
	for (int i=0; i<ptCont.Count(); i++) {
		if (ptCont[i]) ptCont[i]->GetValue(t,&pt[i],geomValid,CTRL_ABSOLUTE);
		}
	return ObjectState(this);
	}

Interval FFDNMSquareWSObj::ChannelValidity(TimeValue t, int nchan)
	{
	switch(nchan) {
		case GEOM_CHAN_NUM: return geomValid;		
		case SELECT_CHAN_NUM: return selValid;
		case SUBSEL_TYPE_CHAN_NUM: return selLevelValid?FOREVER:NEVER;
		default: return FOREVER;
		}
	}
Interval FFDNMCylWSObj::ChannelValidity(TimeValue t, int nchan)
	{
	switch(nchan) {
		case GEOM_CHAN_NUM: return geomValid;		
		case SELECT_CHAN_NUM: return selValid;
		case SUBSEL_TYPE_CHAN_NUM: return selLevelValid?FOREVER:NEVER;
		default: return FOREVER;
		}
	}

void FFDNMSquareWSObj::SetChannelValidity(int i, Interval v)
	{
	switch(i) {
		case GEOM_CHAN_NUM:  geomValid = v; break;		
		case SELECT_CHAN_NUM: selValid = v; break;
		case SUBSEL_TYPE_CHAN_NUM:
			if (v.InInterval(0)) selLevelValid = TRUE;
			else selLevelValid = FALSE;
			break;
		}
	}
void FFDNMCylWSObj::SetChannelValidity(int i, Interval v)
	{
	switch(i) {
		case GEOM_CHAN_NUM:  geomValid = v; break;		
		case SELECT_CHAN_NUM: selValid = v; break;
		case SUBSEL_TYPE_CHAN_NUM:
			if (v.InInterval(0)) selLevelValid = TRUE;
			else selLevelValid = FALSE;
			break;
		}
	}

void FFDNMSquareWSObj::InvalidateChannels(ChannelMask channels)
	{
	if (channels&GEOM_CHANNEL) geomValid.SetEmpty();
	if (channels&SELECT_CHANNEL) selValid.SetEmpty();
	if (channels&SUBSEL_TYPE_CHANNEL) selLevelValid = FALSE;
	}
void FFDNMCylWSObj::InvalidateChannels(ChannelMask channels)
	{
	if (channels&GEOM_CHANNEL) geomValid.SetEmpty();
	if (channels&SELECT_CHANNEL) selValid.SetEmpty();
	if (channels&SUBSEL_TYPE_CHANNEL) selLevelValid = FALSE;
	}

Object* FFDNMSquareWSObj::ConvertToType(TimeValue t, Class_ID obtype)
	{
	if (IsSubClassOf(obtype) || obtype==defObjectClassID) return this;
	return NULL;
	}
Object* FFDNMCylWSObj::ConvertToType(TimeValue t, Class_ID obtype)
	{
	if (IsSubClassOf(obtype) || obtype==defObjectClassID) return this;
	return NULL;
	}

Object *FFDNMSquareWSObj::MakeShallowCopy(ChannelMask channels)
	{
	FFDNMSquareWSObj *obj = new FFDNMSquareWSObj(TRUE);
	BaseClone(obj,NoRemap(),TRUE);
	obj->selValid  = selValid;
	obj->geomValid = geomValid;
	obj->selLevelValid = selLevelValid;
	return obj;
	}
Object *FFDNMCylWSObj::MakeShallowCopy(ChannelMask channels)
	{
	FFDNMCylWSObj *obj = new FFDNMCylWSObj(TRUE);
	BaseClone(obj,NoRemap(),TRUE);
	obj->selValid  = selValid;
	obj->geomValid = geomValid;
	obj->selLevelValid = selLevelValid;
	return obj;
	}

void FFDNMSquareWSObj::ShallowCopy(Object* fromOb, ChannelMask channels)
	{
	assert(fromOb->ClassID()==ClassID());
	FFDNMSquareWSObj *ob = (FFDNMSquareWSObj*)fromOb;
	if (channels&GEOM_CHANNEL)   {
		pt = ob->pt;
		offsets = ob->offsets;
		geomValid = ob->geomValid;
		}
	if (channels&SELECT_CHANNEL) {
		sel = ob->sel;
		selValid = ob->selValid;
		}
	if (channels&SUBSEL_TYPE_CHANNEL) { 	
		selLevel = ob->selLevel;
		selLevelValid = ob->selLevelValid;
		}
	}
void FFDNMCylWSObj::ShallowCopy(Object* fromOb, ChannelMask channels)
	{
	assert(fromOb->ClassID()==ClassID());
	FFDNMCylWSObj *ob = (FFDNMCylWSObj*)fromOb;
	if (channels&GEOM_CHANNEL) {
		pt = ob->pt;
		offsets = ob->offsets;
		geomValid = ob->geomValid;
		}
	if (channels&SELECT_CHANNEL) {
		sel = ob->sel;
		selValid = ob->selValid;
		}
	if (channels&SUBSEL_TYPE_CHANNEL) { 	
		selLevel = ob->selLevel;
		selLevelValid = ob->selLevelValid;
		}
	}

void FFDNMSquareWSObj::Deform(Deformer *defProc, int useSel)
	{
	if (selLevel!=SEL_POINTS) useSel = FALSE;
	Point3 s = LatticeSize(lbox);
	for (int i=0; i<pt.Count(); i++) {
		if (sel[i] || !useSel) {
			Point3 p = pt[i]*s + lbox.Min(); 
			p = defProc->Map(i,p);
			pt[i] = (p-lbox.Min())/s;
			}
		}
	beenDeformed = TRUE;
	}
void FFDNMCylWSObj::Deform(Deformer *defProc, int useSel)
	{
	if (selLevel!=SEL_POINTS) useSel = FALSE;
	Point3 s = LatticeSize(lbox);
	for (int i=0; i<pt.Count(); i++) {
		if (sel[i] || !useSel) {
			Point3 p = pt[i]*s + lbox.Min();
			p = defProc->Map(i,p);
			pt[i] = (p-lbox.Min())/s;
			}
		}
	beenDeformed = TRUE;
	}


class FFDObjSquareCreateCallBack: public CreateMouseCallBack { 	
	FFDNMSquareWSObj *ob;
	Point3 p0,p1;
	IPoint2 sp0, sp1;	
	public:
		int proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);		
		void SetObj(FFDNMSquareWSObj *obj) { ob = obj; }
	};
class FFDObjCylCreateCallBack: public CreateMouseCallBack { 	
	FFDNMCylWSObj *ob;
	Point3 p0,p1;
	IPoint2 sp0, sp1;	
	public:
		int proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);		
		void SetObj(FFDNMCylWSObj *obj) { ob = obj; }
	};

int FFDObjSquareCreateCallBack::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat) 
	{
	Point3 d, xyz;
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				ob->pblock->SetValue(ffd_width,0,0.0f);
				ob->pblock->SetValue(ffd_length,0,0.0f);
				ob->pblock->SetValue(ffd_height,0,0.0f);
				p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				p1 = p0 + Point3(.01,.01,.01);				
				xyz = float(.5)*(p0+p1);
				mat.SetTrans(xyz);
				break;
			case 1:
				sp1 = m;
				p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				p1.z = p0.z +(float).01; 
				xyz = float(.5)*(p0+p1);
				mat.SetTrans(xyz);
				d = p1-p0;								
				ob->pblock->SetValue(ffd_width,0,float(fabs(d.x)));
				ob->pblock->SetValue(ffd_length,0,float(fabs(d.y)));
				ob->pblock->SetValue(ffd_height,0,float(fabs(d.z)));
				ob->pblock->GetMap()->Invalidate();										

				if (msg==MOUSE_POINT && 
						(Length(sp1-sp0)<3 || Length(d)<0.1f)) {
					return CREATE_ABORT;
					}
				break;
			case 2:
				p1.z = p0.z + vpt->SnapLength(vpt->GetCPDisp(p1,Point3(0,0,1),sp1,m));
				xyz = float(.5)*(p0+p1);
				mat.SetTrans(xyz);
				d = p1-p0;				
				ob->pblock->SetValue(ffd_width,0,float(fabs(d.x)));
				ob->pblock->SetValue(ffd_length,0,float(fabs(d.y)));
				ob->pblock->SetValue(ffd_height,0,float(fabs(d.z)));
				ob->pblock->GetMap()->Invalidate();				
					
				if (msg==MOUSE_POINT) {
					return CREATE_STOP;
					}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) { 		
		return CREATE_ABORT;
		}
	else
	if (msg == MOUSE_FREEMOVE) {
		vpt->SnapPreview(m,m);
		}

	return TRUE;
	}

int FFDObjCylCreateCallBack::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat) 
	{
	Point3 d, xyz;
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				ob->pblock->SetValue(ffd_width,0,0.0f);
				ob->pblock->SetValue(ffd_length,0,0.0f);				
				p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);				
				mat.SetTrans(p0);
				break;
			case 1:
				sp1 = m;
				p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				p1.z = p0.z +(float).01; 				
				mat.SetTrans(p0);
				d = p1-p0;								
				ob->pblock->SetValue(ffd_width,0,Length(d));
				ob->pblock->SetValue(ffd_length,0,float(fabs(d.z)));				
				ob->pblock->GetMap()->Invalidate();										

				if (msg==MOUSE_POINT && 
						(Length(sp1-sp0)<3 || Length(d)<0.1f)) {
					return CREATE_ABORT;
					}
				break;
			case 2:
				p1.z = p0.z + vpt->SnapLength(vpt->GetCPDisp(p1,Point3(0,0,1),sp1,m));				
				xyz  = p0;
				xyz.z = 0.5f*(p0.z+p1.z);
				mat.SetTrans(xyz);
				d = p1-p0;				
				ob->pblock->SetValue(ffd_length,0,float(fabs(d.z)));				
				ob->pblock->GetMap()->Invalidate();				
					
				if (msg==MOUSE_POINT) {
					return CREATE_STOP;
					}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) { 		
		return CREATE_ABORT;
		}
	else
	if (msg == MOUSE_FREEMOVE) {
		vpt->SnapPreview(m,m);
		}

	return TRUE;
	}

CreateMouseCallBack* FFDNMSquareWSObj::GetCreateMouseCallBack()
	{
	static FFDObjSquareCreateCallBack createCB;
	createCB.SetObj(this);
	return &createCB;
	}
CreateMouseCallBack* FFDNMCylWSObj::GetCreateMouseCallBack()
	{
	static FFDObjCylCreateCallBack createCB;
	createCB.SetObj(this);
	return &createCB;
	}


//--- FFDNMSquareWSMod ------------------------------------------------

FFDNMWSMod::FFDNMWSMod()
	{
	nodeRef = NULL;
	pblock = NULL;	
	obRef = NULL;
	}

FFDNMWSMod::FFDNMWSMod(INode *node)
	{
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
	pblock = NULL;	
	obRef = NULL;
	}

RefResult FFDNMWSMod::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message)
	{
	if (message==REFMSG_OBJECT_CACHE_DUMPED) return REF_STOP;
	else return SimpleWSMMod::NotifyRefChanged(changeInt,hTarget,partID,message);
	}

RefTargetHandle FFDNMWSMod::Clone(RemapDir &remap)
	{
	FFDNMWSMod *mod = new FFDNMWSMod;
	mod->ReplaceReference(SIMPWSMMOD_NODEREF,nodeRef);
	return mod;
	}

static FFDNMDeformer<WSMObject> deformer;

Deformer& FFDNMWSMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{ 	
	FFDNM<WSMObject> *obj = (FFDNM<WSMObject>*)GetWSMObject(t);
	if (obj) obj->UpdateBox(t);
	
	// We want the TM even if a WS mod is applied to the FFD object.
	// We also want to compare the before and after TMs so we can determine if the lattice points
	// have already been transformed into WS. If they have then we need to include an untransform
	// so the verts deformed by the FFD don't get an extra transform.
	//Matrix3 tm = Inverse(nodeRef->GetObjectTM(t));	
	Matrix3 tm  = Inverse(nodeRef->GetObjTMBeforeWSM(t)); 
	Matrix3 tm2 = Inverse(nodeRef->GetObjTMAfterWSM(t)); 

	deformer.FreePointCache();
	deformer = FFDNMDeformer<WSMObject>(obj,t,&tm,obj->lbox, !(tm==tm2));	
	return deformer;
	}

Interval FFDNMWSMod::GetValidity(TimeValue t)
	{
	Interval valid = FOREVER;
	if (nodeRef) { 		
		FFDNM<WSMObject> *obj = (FFDNM<WSMObject>*)GetWSMObject(t);
		nodeRef->GetObjectTM(t,&valid);
		if (obj) {
			float f;
			valid &= obj->ChannelValidity(t,GEOM_CHAN_NUM);
			valid &= obj->ChannelValidity(t,SELECT_CHAN_NUM);
			obj->pblock->GetValue(ffd_falloff,t,f,valid);
			obj->pblock->GetValue(ffd_tens,t,f,valid);
			obj->pblock->GetValue(ffd_cont,t,f,valid);
			obj->pblock->GetValue(ffd_length,t,f,valid);
			obj->pblock->GetValue(ffd_width,t,f,valid);
			if (obj->ClassID()==FFDNMWSSQUARE_CLASS_ID) {
				obj->pblock->GetValue(ffd_height,t,f,valid);
				}
			Point3 p;
			for (int i=0; i<obj->NumPts(); i++) { 			
				if (obj->GetPtCont(i)) obj->GetPtCont(i)->GetValue(t,&p,valid,CTRL_ABSOLUTE);
				}
			}
		}
	return valid;
	}


//--------------------------------------------------------------------
// Catmull-Rom spline from Texture and Modeling A Procedural Approach

#define CR00	-0.5f
#define CR01	 1.5f
#define CR02	-1.5f
#define CR03	 0.5f
#define CR10	 1.0f
#define CR11	-2.5f
#define CR12	 2.0f
#define CR13	-0.5f
#define CR20	-0.5f
#define CR21	 0.0f
#define CR22	 0.5f
#define CR23     0.0f
#define CR30     0.0f
#define CR31	 1.0f
#define CR32     0.0f
#define CR33     0.0f

static Point3 InterpSplineCatmullRom(float u,Point3 knot[4])
	{
	Point3 c0, c1, c2, c3;
	c3 = (CR00 * knot[0]) + (CR01 * knot[1])
	   + (CR02 * knot[2]) + (CR03 * knot[3]);
	c2 = (CR10 * knot[0]) + (CR11 * knot[1])
	   + (CR12 * knot[2]) + (CR13 * knot[3]);
	c1 = (CR20 * knot[0]) + (CR21 * knot[1])
	   + (CR22 * knot[2]) + (CR23 * knot[3]);
	c0 = (CR30 * knot[0]) + (CR31 * knot[1])
	   + (CR32 * knot[2]) + (CR33 * knot[3]);

	return ((c3*u + c2)*u + c1)*u + c0;
	}


//------------------------------------------------------------------- 
// TCB ... except we're not going to use bias

static void ComputeHermiteBasis(float u, float *v) 
	{
#if 1
	float u2,u3,a;
	
	u2 = u*u;
	u3 = u2*u;
	a  = 2.0f*u3 - 3.0f*u2;
	v[0] = 1.0f + a;
	v[1] = -a;
	v[2] = u - 2.0f*u2 + u3;
	v[3] = -u2 + u3;
#else
	float s = 1.0f-u;
	v[0] = s*s*s;
	v[1] = 3.0f*u*s*s;
	v[2] = 3.0f*u*u*s;
	v[3] = u*u*u;
#endif
	}

static void ComputeTCBMults(float tens, float cont, float &m1, float &m2)
	{ 	
	float tm,cm,cp;	
	tm = 0.5f*(1.0f - tens);
	cm = 1.0f - cont;       
	cp = 2.0f - cm;
	m1 = tm*cm;
	m2 = tm*cp;
	}

static Point3 InterpSpline(float u,Point3 knot[4],float m1, float m2)
	{
	float v[4];
	Point3 p;
	ComputeHermiteBasis(u,v);
#if 1
	float c[4];
	c[0] = -v[2]*m2;
	c[1] = v[0] + v[2]*(m2-m1) - v[3]*m1;
	c[2] = v[1] + v[2]*m1 + v[3]*(m1-m2);
	c[3] = v[3]*m2;
	p =  knot[0]*c[0] + knot[1]*c[1] + knot[2]*c[2] + knot[3]*c[3];
#else	
	Point3 R1, R4;
	R1 = 3.0f*(knot[1] - knot[0]);
	R4 = 3.0f*(knot[3] - knot[2]); 
	p = knot[0]*v[0] + knot[3]*v[1] + R1*v[2] + R4*v[3];
#endif

#if 0
	DebugPrint ("u:%.2f [%.2f, %.2f, %.2f] #([%.2f, %.2f, %.2f], [%.2f, %.2f, %.2f], [%.2f, %.2f, %.2f], [%.2f, %.2f, %.1f])\n",
			 u, p.x, p.y, p.x, knot[0].x, knot[0].y, knot[0].z, knot[1].x, knot[1].y, knot[1].z, 
				knot[2].x, knot[2].y, knot[2].z, knot[3].x, knot[3].y, knot[3].z);
#endif	
	return p;
	}


//-----------------------------------------------------------------------
//
// FFD select modifier
//
//

class FFDSelData;

class FFDSelMod : public Modifier { 	
	public:				
		DWORD selLevel;
		
		static IObjParam *ip;		
		static FFDSelMod *editMod;		
		static HWND hParams;
		static SelectModBoxCMode *selectMode;
		static BOOL allX, allY, allZ;

		FFDSelMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s = GetString(IDS_RB_FFDSELMOD); }  
		virtual Class_ID ClassID() { return FFD_SELECT_CLASS_ID; }		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_RB_FFDSELMOD); }

		// From modifier
		ChannelMask ChannelsUsed()  { return PART_GEOM|PART_SELECT|PART_SUBSEL_TYPE; }
		ChannelMask ChannelsChanged() { return PART_SELECT|PART_SUBSEL_TYPE; }
		Class_ID InputType() { return GENFFDOBJECT_CLASS_ID; }
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t) { return FOREVER; }

		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack() { return NULL; } 
		void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);		
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		void ActivateSubobjSel(int level, XFormModes& modes);
		void SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE);
		void ClearSelection(int selLevel);
		void SelectAll(int selLevel);
		void InvertSelection(int selLevel);
		void NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc);

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);		
		IOResult SaveLocalData(ISave *isave, LocalModData *ld);
		IOResult LoadLocalData(ILoad *iload, LocalModData **pld);

		int NumRefs() { return 0; }
		RefTargetHandle GetReference(int i) { return NULL; }
		void SetReference(int i, RefTargetHandle rtarg) { }

		int NumSubs() { return 0; }
		Animatable* SubAnim(int i) { return NULL; }
		TSTR SubAnimName(int i) { return _T(""); }

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message) { return REF_SUCCEED; }

		void SetButtonStates();
		void ExpandSelection(int ix, BOOL on,FFDSelData *d);

	};

class FFDSelData : public LocalModData {
	public:		
		BitArray sel;
		Box3 lbox;

		BOOL held;
		Tab<Point3> pt;
		int dim[3];

		FFDSelData(FFDNM<WSMObject> *ffd);
		FFDSelData() { held=0;lbox.Init(); }
		LocalModData *Clone();		
		void SetCache(FFDNM<WSMObject> *ffd);
		void FreeCache();
		int GridIndex(int i, int j, int k);
	};

class FFDSelRestore : public RestoreObj {
	public:
		BitArray usel, rsel;		
		FFDSelMod *mod;
		FFDSelData *d;
		int level;

		FFDSelRestore(FFDSelMod *m, FFDSelData *d);
		void Restore(int isUndo);
		void Redo();
		int Size() { return 1; }
		void EndHold() { d->held=FALSE; }
		TSTR Description() { return TSTR(_T("SelectRestore")); }
	};

//--- ClassDescriptor and class vars ---------------------------------

IObjParam			*FFDSelMod::ip         = NULL;
FFDSelMod			*FFDSelMod::editMod    = NULL;
HWND				 FFDSelMod::hParams    = NULL;
SelectModBoxCMode	*FFDSelMod::selectMode = SEL_OBJECT;
BOOL                 FFDSelMod::allX       = FALSE;
BOOL                 FFDSelMod::allY       = FALSE;
BOOL                 FFDSelMod::allZ       = FALSE;

class FFDSelClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new FFDSelMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_FFDSELMOD); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return FFD_SELECT_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS); }
	};

static FFDSelClassDesc ffdSelDesc;
ClassDesc* GetFFDSelModDesc() { return &ffdSelDesc; }

static BOOL CALLBACK FFDSelProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

//--- FFDSelMod methods -----------------------------------------------------

FFDSelMod::FFDSelMod()
	{
	selLevel = SEL_POINTS;
	}

RefTargetHandle FFDSelMod::Clone(RemapDir& remap)
	{
	FFDSelMod *newMod = new FFDSelMod();
	newMod->selLevel = selLevel;
	return newMod;
	}

void FFDSelMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	if (os->obj->IsSubClassOf(GENFFDOBJECT_CLASS_ID)) {
		FFDNM<WSMObject> *ffd = (FFDNM<WSMObject>*)os->obj;
		FFDSelData *d  = (FFDSelData*)mc.localData;
		if (!d) {
			mc.localData = d = new FFDSelData(ffd);
			}
		if (editMod==this) {
			if (d->pt.Count()!=ffd->pt.Count()) d->SetCache(ffd);
			}
		d->sel.SetSize(ffd->sel.GetSize(),TRUE);
		ffd->sel = d->sel;
		ffd->selLevel = selLevel;
		}
	}

void FFDSelMod::NotifyInputChanged(
		Interval changeInt, PartID partID, RefMessage message, ModContext *mc)
	{
	if (mc->localData && ip) {
		((FFDSelData*)mc->localData)->FreeCache();
		TimeValue t = ip->GetTime();
		NotifyDependents(Interval(t,t), 
			PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE,
		    REFMSG_MOD_EVAL);
		}
	}

void FFDSelMod::BeginEditParams(
		IObjParam  *ip, ULONG flags,Animatable *prev)
	{
	this->ip = ip;	
	editMod  = this;
	selectMode = new SelectModBoxCMode(this,ip);

	// Add our sub object type
	TSTR type1(GetString(IDS_RB_CONTPOINTS));
	const TCHAR *ptype[] = { type1};
	ip->RegisterSubObjectTypes(ptype, 1);	

	// Restore the selection level.
	ip->SetSubObjectLevel(selLevel);

	// Disable show end result.
	ip->EnableShowEndResult(FALSE);	

	hParams = ip->AddRollupPage( 
		hInstance, 
		MAKEINTRESOURCE(IDD_FFDSELMODPARAMS),
		FFDSelProc,
		GetString(IDS_RB_FFDSELMOD),
		(LPARAM)this);	
	}

void FFDSelMod::EndEditParams(
		IObjParam *ip,ULONG flags,Animatable *next)
	{
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	for (int i=0; i<list.Count(); i++) {
		((FFDSelData*)list[i]->localData)->FreeCache();
		}
	nodes.DisposeTemporary();

	if (hParams) ip->DeleteRollupPage(hParams);
	hParams = NULL;	

	ip->DeleteMode(selectMode);
	if (selectMode) delete selectMode;
	selectMode = NULL;

	// Enable show end result
	ip->EnableShowEndResult(TRUE);

	this->ip = NULL;
	editMod  = NULL;
	hParams  = NULL;
	}

int FFDSelMod::HitTest(
		TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc)
	{ 		
	FFDSelData *d = (FFDSelData *)mc->localData;
	if (!d) return 0;

	int savedLimits, res = 0;
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	
	// Setup GW
	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);
	Matrix3 mat = inode->GetObjectTM(t);
	gw->setTransform(mat);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);	
	gw->setRndLimits(gw->getRndLimits() & ~GW_BACKCULL);
	gw->clearHitCode();	

	Point3 s = LatticeSize(d->lbox);
	for (int i=0; i<d->pt.Count(); i++) {
		// Maybe skip sel or unsel points
		if (flags&HIT_SELONLY   && !d->sel[i]) continue;
		if (flags&HIT_UNSELONLY &&  d->sel[i]) continue;
		
		// Draw the point
		Point3 p = d->pt[i]*s + d->lbox.Min();
		gw->marker(&p,HOLLOW_BOX_MRKR);		
		
		// Check for a hit and log it
		if (gw->checkHitCode()) { 			
			gw->clearHitCode();
			vpt->LogHit(inode, mc, gw->getHitDistance(), i, NULL);
			res = 1;
			if (flags&HIT_ABORTONHIT) return res;			
			}
		}

	gw->setRndLimits(savedLimits);	
	return res;
	}

void FFDSelMod::ActivateSubobjSel(int level, XFormModes& modes)
	{
	selLevel = level;
	if (level!=SEL_OBJECT) {
		modes = XFormModes(NULL,NULL,NULL,NULL,NULL,selectMode);
		}
	
	NotifyDependents(FOREVER, SELECT_CHANNEL|PART_SUBSEL_TYPE|PART_DISPLAY, REFMSG_CHANGE);
	ip->PipeSelLevelChanged();
	NotifyDependents(FOREVER, SELECT_CHANNEL|DISP_ATTRIB_CHANNEL|SUBSEL_TYPE_CHANNEL, REFMSG_CHANGE);	
	}

void FFDSelMod::ExpandSelection(int ix, BOOL on,FFDSelData *d)
	{
	int j, k, i;	
	if (d->dim[0]==0 || d->dim[1]==0) return;	

	k   = ix/(d->dim[0]*d->dim[1]);
	ix -= k*(d->dim[0]*d->dim[1]);
	j   = ix/d->dim[0];
	ix -= j*d->dim[0];
	i   = ix;

	if (allX) {
		for (int ix=0; ix<d->dim[0]; ix++) {
			if (allY) {
				for (int jx=0; jx<d->dim[1]; jx++) {
					int index = d->GridIndex(ix,jx,k);			
					d->sel.Set(index,on);
					}
				}
			if (allZ) {
				for (int kx=0; kx<d->dim[2]; kx++) {
					int index = d->GridIndex(ix,j,kx);			
					d->sel.Set(index,on);
					}
				}
			int index = d->GridIndex(ix,j,k);			
			d->sel.Set(index,on);
			}
		}
	if (allY) {
		for (int jx=0; jx<d->dim[1]; jx++) {
			if (allX) {
				for (int ix=0; ix<d->dim[0]; ix++) {
					int index = d->GridIndex(ix,jx,k);			
					d->sel.Set(index,on);
					}
				}
			if (allZ) {
				for (int kx=0; kx<d->dim[2]; kx++) {
					int index = d->GridIndex(ix,j,kx);			
					d->sel.Set(index,on);
					}
				}
			int index = d->GridIndex(i,jx,k);
			d->sel.Set(index,on);
			}
		}
	if (allZ) {
		for (int kx=0; kx<d->dim[2]; kx++) {
			if (allX) {
				for (int ix=0; ix<d->dim[0]; ix++) {
					int index = d->GridIndex(ix,j,kx);			
					d->sel.Set(index,on);
					}
				}
			if (allY) {
				for (int jx=0; jx<d->dim[1]; jx++) {
					int index = d->GridIndex(i,jx,kx);			
					d->sel.Set(index,on);
					}
				}
			int index = d->GridIndex(i,j,kx);
			d->sel.Set(index,on);
			}
		}
	}

void FFDSelMod::SelectSubComponent(
		HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert)
	{
	FFDSelData *d;
	while (hitRec) {
		d = (FFDSelData*)hitRec->modContext->localData;
		if (theHold.Holding() && !d->held) theHold.Put(new FFDSelRestore(this,d));
		BOOL state = selected;
		if (invert) state = !d->sel[hitRec->hitInfo];
		if (allX || allY || allZ) {
			ExpandSelection(hitRec->hitInfo,state,d);
		} else {
			if (state) d->sel.Set(hitRec->hitInfo);
			else       d->sel.Clear(hitRec->hitInfo);
			}
		if (!all) break;
		hitRec = hitRec->Next();
		}
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void FFDSelMod::ClearSelection(int selLevel)
	{
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	FFDSelData *d;
	for (int i=0; i<list.Count(); i++) {
		d = (FFDSelData*)list[i]->localData;
		if (theHold.Holding() && !d->held) theHold.Put(new FFDSelRestore(this,d));
		d->sel.ClearAll();		
		}	
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void FFDSelMod::SelectAll(int selLevel)
	{
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	FFDSelData *d;
	for (int i=0; i<list.Count(); i++) {
		d = (FFDSelData*)list[i]->localData;
		if (theHold.Holding() && !d->held) theHold.Put(new FFDSelRestore(this,d));
		d->sel.SetAll();		
		}	
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void FFDSelMod::InvertSelection(int selLevel)
	{
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	FFDSelData *d;
	for (int i=0; i<list.Count(); i++) {
		d = (FFDSelData*)list[i]->localData;
		if (theHold.Holding() && !d->held) theHold.Put(new FFDSelRestore(this,d));
		d->sel = ~d->sel;
		}	
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

#define SELLEVEL_CHUNKID		0x0100
#define SEL_CHUNKID				0x0200

IOResult FFDSelMod::Save(ISave *isave)
	{
	IOResult res;
	ULONG nb;
	Modifier::Save(isave);
	isave->BeginChunk(SELLEVEL_CHUNKID);
	res = isave->Write(&selLevel, sizeof(selLevel), &nb);
	isave->EndChunk();
	return res;
	}

IOResult FFDSelMod::Load(ILoad *iload)
	{
	IOResult res;
	ULONG nb;
	Modifier::Load(iload);
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SELLEVEL_CHUNKID:
				iload->Read(&selLevel, sizeof(selLevel), &nb);
				break;			
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

IOResult FFDSelMod::SaveLocalData(ISave *isave, LocalModData *ld)
	{
	FFDSelData *d = (FFDSelData*)ld;

	isave->BeginChunk(SEL_CHUNKID);
	d->sel.Save(isave);
	isave->EndChunk();

	return IO_OK;
	}

IOResult FFDSelMod::LoadLocalData(ILoad *iload, LocalModData **pld)
	{
	FFDSelData *d = new FFDSelData;
	*pld = d;
	IOResult res;	
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SEL_CHUNKID:
				d->sel.Load(iload);
				break;			
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}


void FFDSelMod::SetButtonStates()
	{
	ICustButton *but;
	but = GetICustButton(GetDlgItem(hParams,IDC_FFD_ALLX));
	but->SetType(CBT_CHECK);
	but->SetCheck(allX);
	ReleaseICustButton(but);

	but = GetICustButton(GetDlgItem(hParams,IDC_FFD_ALLY));
	but->SetType(CBT_CHECK);
	but->SetCheck(allY);
	ReleaseICustButton(but);

	but = GetICustButton(GetDlgItem(hParams,IDC_FFD_ALLZ));
	but->SetType(CBT_CHECK);
	but->SetCheck(allZ);
	ReleaseICustButton(but);
	}

static BOOL CALLBACK FFDSelProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	FFDSelMod *mod = (FFDSelMod*)GetWindowLong(hWnd,GWL_USERDATA);
	switch (msg) {
		case WM_INITDIALOG: {
			mod = (FFDSelMod*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mod->hParams = hWnd;
			mod->SetButtonStates();
			break;
			}
		
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_FFD_ALLX: {
					ICustButton *but = GetICustButton(GetDlgItem(hWnd,IDC_FFD_ALLX));
					mod->allX = but->IsChecked();
					ReleaseICustButton(but);
					break;
					}
				case IDC_FFD_ALLY: {
					ICustButton *but = GetICustButton(GetDlgItem(hWnd,IDC_FFD_ALLY));
					mod->allY = but->IsChecked();
					ReleaseICustButton(but);
					break;
					}
				case IDC_FFD_ALLZ: {
					ICustButton *but = GetICustButton(GetDlgItem(hWnd,IDC_FFD_ALLZ));
					mod->allZ = but->IsChecked();
					ReleaseICustButton(but);
					break;
					}				
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:   			
   			mod->ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			break;
		default: return FALSE;
		}
	return TRUE;
	}


//--- FFDSelData ------------------------------------------------------

FFDSelData::FFDSelData(FFDNM<WSMObject> *ffd)
	{
	held = 0;
	lbox = ffd->lbox;
	sel  = ffd->sel;
	}

LocalModData *FFDSelData::Clone()
	{
	FFDSelData *d = new FFDSelData();
	d->sel = sel;
	return d;
	}

void FFDSelData::SetCache(FFDNM<WSMObject> *ffd)
	{ 	
	pt   = ffd->pt;	
	lbox = ffd->lbox;
	for (int i=0; i<3; i++) dim[i] = ffd->dim[i];
	}

void FFDSelData::FreeCache()
	{ 	
	pt.Resize(0);
	}

int FFDSelData::GridIndex(int i, int j, int k)
	{
	int ix = k*dim[0]*dim[1] + j*dim[0] + i;
	assert(ix>=0 && pt.Count());
	return ix;
	}

//--- FFDSelRestore -----------------------------------------------------

FFDSelRestore::FFDSelRestore(FFDSelMod *m, FFDSelData *d)
	{
	mod     = m;
	level   = mod->selLevel;
	this->d = d;
	d->held = TRUE;
	usel    = d->sel;
	}

void FFDSelRestore::Restore(int isUndo)
	{
	if (isUndo) {
		rsel = d->sel;
		}
	d->sel = usel;
	mod->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void FFDSelRestore::Redo()
	{
	d->sel = rsel;
	mod->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ffd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ffdmod.rc
//
#define IDS_RB_FFD44                    1
#define IDS_RB_DEFDEFORMATIONS          2
#define IDS_RB_CONTPOINTS               3
#define IDS_RB_LATTICE                  4
#define IDS_RB_LATTICETM                5
#define IDS_RB_CONTROLPOINTN            6
#define IDS_RB_PARAMETERS               7
#define IDS_RB_FFD33                    8
#define IDS_RB_FFD22                    9
#define IDS_RB_FFDNMOS                  10
#define IDS_RB_FFDRECT                  11
#define IDS_RB_FFDCYL                   12
#define IDS_RB_FFDNMWS                  13
#define IDS_RB_FFDNMWSMOD               14
#define IDS_RB_LENGTH                   15
#define IDS_RB_WIDTH                    16
#define IDS_RB_HEIGHT                   17
#define IDS_RB_FALLOFF                  18
#define IDS_RB_FFDGEN                   19
#define IDS_RB_SETFFDDIM                20
#define IDS_RB_RADIUS                   21
#define IDS_RB_TENS                     22
#define IDS_RB_CONT                     23
#define IDS_RB_FFDSELMOD                24
#define IDS_RB_SOT                      25
#define IDS_RB_FFDMOD                   26
#define IDS_RB_FFDRECT_C                27
#define IDS_RB_FFDCYL_C                 28
#define IDS_RK_FFDCONT                  29
#define IDS_RK_MASTER                   30
#define IDS_RK_RESETLATTICE             31
#define IDS_RK_ANIMATEALL               32
#define IDS_RK_SETVOLUME                35
#define IDS_RK_ALLX                     36
#define IDS_RK_ALLY                     37
#define IDS_RK_ALLZ                     38
#define IDS_RK_CONFORM                  39
#define IDS_RK_SHOWLATTICE              40
#define IDS_RK_SHOWSOURCE               41
#define IDS_RK_FALLOFF                  42
#define IDS_RK_TENSION                  43
#define IDS_RK_CONT                     44
#define IDS_RK_LENGTH                   45
#define IDS_RK_WIDTH                    46
#define IDS_RK_HEIGHT                   47
#define IDS_RK_INPOINTS                 48
#define IDS_RK_OUTPOINTS                49
#define IDS_RK_OFFSET                   50
#define IDD_DIALOG1                     101
#define IDD_FFD_ABOUT                   102
#define IDD_FFD_ABOUT44                 102
#define IDD_FFD_SETDIM                  103
#define IDR_FFD_SHORTCUTS               105
#define IDD_FFDPARAMS                   123
#define IDD_FFD_ABOUT33                 124
#define IDB_TANGRAPHSLEFT               124
#define IDD_FFD_ABOUT22                 125
#define IDD_FFDNMOSPARAMS               126
#define IDD_FFD_ABOUTNM                 127
#define IDD_FFDNMWSPARAMS               128
#define IDD_FFDNMWSCYLPARAMS            129
#define IDD_FFD_SETDIMCYL               130
#define IDD_FFDSELMODPARAMS             131
#define IDD_FFD_SOT                     146
#define IDS_SWITCH_TOP                  460
#define IDS_SWITCH_CP                   461
#define IDS_SWITCH_LATTICE              462
#define IDS_SWITCH_SETVOLUME            463
#define IDS_RK_TOP                      464
#define IDS_RK_NOT_FFD_CONFORM_ERROR    465
#define IDS_RK_NOT_FFD_ERROR            465
#define IDS_RK_NOT_FFD_SETDIM_ERROR     466
#define IDC_FFD_DEFORMALL               1000
#define IDC_FFD_INVOLUME                1001
#define IDC_FFD_ABOUT                   1002
#define IDC_FFD_SETDIM                  1006
#define IDC_FFD_FALLOFFLABEL            1007
#define IDC_FFD_DIM0                    1008
#define IDC_FFD_DIM0SPIN                1009
#define IDC_FFD_DIM1                    1010
#define IDC_FFD_DIMTEXT                 1010
#define IDC_FFD_DIM1SPIN                1011
#define IDC_FFD_ALLX                    1011
#define IDC_FFD_DIM2                    1012
#define IDC_FFD_ALLY                    1012
#define IDC_FFD_DIM2SPIN                1013
#define IDC_FFD_ALLZ                    1013
#define IDC_FFD_SETVOLUME               1014
#define IDC_FFD_FALLOFF                 1024
#define IDC_FFD_FALLOFFSPIN             1025
#define IDC_FFD_LENGTH                  1026
#define IDC_FFD_LENGTHSPIN              1027
#define IDC_FFD_WIDTH                   1028
#define IDC_FFD_WIDTHSPIN               1029
#define IDC_FFD_HEIGHT                  1030
#define IDC_FFD_HEIGHTSPIN              1031
#define IDC_FFD_TENS                    1032
#define IDC_FFD_TENSSPIN                1033
#define IDC_FFD_CONT                    1034
#define IDC_FFD_CONTSPIN                1035
#define IDC_FFD_SHOWLATTICE             1036
#define IDC_FFD_SHOWSOURCE              1037
#define IDC_FFD_RESET                   1038
#define IDC_FFD_ANIMATEALL              1039
#define IDC_FFD_CONFORM                 1040
#define IDC_FFD_INPOINTS                1041
#define IDC_FFD_OUTPOINTS               1042
#define IDC_FFD_OFFSET                  1043
#define IDC_FFD_OFFSETSPIN              1044
#define IDC_FFD_OFFSETLABEL             1045
#define ID_SUBOBJ_LATTICE               30003
#define ID_SUBOBJ_SETVOLUME             30022
#define ID_SUBOBJ_CP                    30025
#define ID_SUBOBJ_TOP                   40001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1046
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ffd\ffdui.h ===
/**********************************************************************
 *<
	FILE: ffdui.h

	DESCRIPTION:

	CREATED BY: Ravi Karra

	HISTORY: created 1/11/99

 *>	Copyright (c) 1996 Rolf Berteig, All Rights Reserved.
 **********************************************************************/

#ifndef __FFDUI__H
#define __FFDUI__H

#include "ffdmod.h"
#include "KbdShortcut.h"

// The reference versions
#define ES_REF_VER_0	0	// Pre-r3 (vertex controllers are only refs)
#define ES_REF_VER_1	1	// MAXr3 (ref 0 is master vertex controller)

// Reference indices
#define TM_REF		0
#define PBLOCK_REF	1
#define MASTER_REF	2

// Selection levels
#define SEL_OBJECT		0
#define SEL_POINTS		1
#define SEL_LATTICE		2
#define SEL_SETVOLUME	3

// Right Click ID's
enum { RC_ANIMATE_ALL = SEL_SETVOLUME+1, RC_ALLX, RC_ALLY, RC_ALLZ };

// Keyboard Shortcuts stuff
const ShortcutTableId kFFDShortcuts = 0x7ed73ca2;

#define NumElements(array) (sizeof(array) / sizeof(array[0]))

ShortcutTable* GetShortcuts();

template <class T>
class FFDShortcutCB : public ShortcutCallback
{
	public:
		T*		ffd;
				FFDShortcutCB(T *ffd) { this->ffd = ffd; }
		BOOL	KeyboardShortcut(int id); 
};

// Right-click menu stuff
template <class T>
class FFDRightMenu : public RightClickMenu {
	public:
		T		*ffd;
				FFDRightMenu(T *ffd) { this->ffd = ffd; }
		void	Init(RightClickMenuManager* manager, HWND hWnd, IPoint2 m);
		void	Selected(UINT id);
		void	AddMenu(RightClickMenuManager* pManager, int commandId, 
					int stringId, DWORD flags = MF_STRING, TCHAR* pName = NULL);
};

class sMyEnumProc : public DependentEnumProc 
	{
      public :
		INodeTab Nodes;              
		virtual int proc(ReferenceMaker *rmaker); 
	};


template <class T>
BOOL FFDShortcutCB<T>::KeyboardShortcut(int id) {
	switch (id) {
		case ID_SUBOBJ_TOP:
			ffd->ip->SetSubObjectLevel(SEL_OBJECT);
			ffd->ip->RedrawViews(ffd->ip->GetTime());
			return TRUE;
		case ID_SUBOBJ_CP:
			ffd->ip->SetSubObjectLevel(SEL_POINTS);
			return TRUE;
		case ID_SUBOBJ_LATTICE:
			ffd->ip->SetSubObjectLevel(SEL_LATTICE);
			return TRUE;
		case ID_SUBOBJ_SETVOLUME:
			ffd->ip->SetSubObjectLevel(SEL_SETVOLUME);
			return TRUE;
	}
	return FALSE;
	
}

template <class T>
void FFDRightMenu<T>::AddMenu(RightClickMenuManager* manager,
                   int commandId, int stringId, DWORD flags,
                   TCHAR* pName)
{
    TCHAR buf[64];
    TCHAR buf2[512];
    TCHAR *pOpName; 
    if (stringId)
        pOpName = GetString(stringId);
    else
        pOpName = pName;
            
    if (ffd->ip->GetShortcutString(kFFDShortcuts, commandId, buf)) {
        sprintf(buf2, _T("%s\t%s"), pOpName, buf);
    } else
        _tcscpy(buf2, pOpName);
    
    manager->AddMenu(this, flags, commandId, buf2);
}

template <class T>
void FFDRightMenu<T>::Init(RightClickMenuManager* manager, HWND hWnd, IPoint2 m) {
	manager->AddMenu(this, MF_SEPARATOR, 0, NULL);
	AddMenu(manager, ID_SUBOBJ_TOP,			IDS_RK_TOP,			(ffd->selLevel==SEL_OBJECT) ? MF_CHECKED : MF_UNCHECKED);
	AddMenu(manager, ID_SUBOBJ_CP,			IDS_RB_CONTPOINTS,	(ffd->selLevel==SEL_POINTS) ? MF_CHECKED : MF_UNCHECKED);
	if(ffd->SuperClassID()==OSM_CLASS_ID)
	{
		AddMenu(manager, ID_SUBOBJ_LATTICE,		IDS_RB_LATTICE,		(ffd->selLevel==SEL_LATTICE) ? MF_CHECKED : MF_UNCHECKED);
		AddMenu(manager, ID_SUBOBJ_SETVOLUME,	IDS_RK_SETVOLUME,	(ffd->selLevel==SEL_SETVOLUME) ? MF_CHECKED : MF_UNCHECKED);
	}
	manager->AddMenu(this, MF_SEPARATOR, 0, NULL);
	AddMenu(manager, RC_ANIMATE_ALL,		IDS_RK_ANIMATEALL,	MF_STRING);	
#ifdef INC_CONSTRAINTS
	AddMenu(manager, RC_ALLX,				IDS_RK_ALLX,		(ffd->allX)?MF_CHECKED:MF_UNCHECKED);
	AddMenu(manager, RC_ALLY,				IDS_RK_ALLY,		(ffd->allY)?MF_CHECKED:MF_UNCHECKED);
	AddMenu(manager, RC_ALLZ,				IDS_RK_ALLZ,		(ffd->allZ)?MF_CHECKED:MF_UNCHECKED);
#endif
}

template <class T>
void FFDRightMenu<T>::Selected(UINT id) {	
	if (ffd->ffdShortcutCB->KeyboardShortcut(id))		
		return;		
	switch(id) {				
		case RC_ANIMATE_ALL:
			ffd->AnimateAll();
			break;
#ifdef INC_CONSTRAINTS
		case RC_ALLX: {
			ffd->allX = !ffd->allX;
			ICustButton *but = GetICustButton(GetDlgItem(ffd->pblock->GetMap()->GetHWnd(),IDC_FFD_ALLX));
			but->SetCheck(ffd->allX);
			ReleaseICustButton(but);			
			break;
			}
		case RC_ALLY: {
			ffd->allY = !ffd->allY;
			ICustButton *but = GetICustButton(GetDlgItem(ffd->pblock->GetMap()->GetHWnd(),IDC_FFD_ALLY));
			but->SetCheck(ffd->allY);
			ReleaseICustButton(but);						
			break;
			}
		case RC_ALLZ: {
			ffd->allZ = !ffd->allZ;
			ICustButton *but = GetICustButton(GetDlgItem(ffd->pblock->GetMap()->GetHWnd(),IDC_FFD_ALLZ));
			but->SetCheck(ffd->allZ);
			ReleaseICustButton(but);			
			break;
			}
#endif
		}
	}

#endif //__FFDUI__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Add\add.cpp ===
//-----------------------------------------------------------------------------
// ------------------
// File ....: Add.cpp
// ------------------
// Author...: Gus J Grubba
// Date ....: September 1995
// Descr....: Additive Compositor
//
// History .: Sep, 27 1995 - Started
//            
//-----------------------------------------------------------------------------
        
//-- Include files

#include <Max.h>
#include <bmmlib.h>
#include <fltlib.h>
#include "Add.h"
#include "resource.h"

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

//-- Parameter Block ----------------------------------------------------------

#define NPARAMS 3

static ParamBlockDescID parameters[] = {
     { TYPE_FLOAT,  NULL, TRUE,1 },  // blur
     { TYPE_POINT3, NULL, TRUE,2 },  // col1
     { TYPE_POINT3, NULL, TRUE,3 }   // col2
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
     switch (fdwReason) {
         case DLL_PROCESS_ATTACH:
              if (hInst)
                 return(FALSE);
              hInst = hDLLInst;
              break;
         case DLL_PROCESS_DETACH:
              hInst  = NULL;
              break;
         case DLL_THREAD_ATTACH:
              break;
         case DLL_THREAD_DETACH:
              break;
     }
     return TRUE;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Add Class Description

class ADDClassDesc:public ClassDesc {
     
     public:

        int             IsPublic     ( )                   { return 1;                }
        void           *Create       ( BOOL loading=FALSE) { return new ImageFilter_Add; }
        const TCHAR    *ClassName    ( )                   { return GetString(IDS_DB_ADD);     }
        SClass_ID       SuperClassID ( )                   { return FLT_CLASS_ID;  }
        Class_ID        ClassID      ( )                   { return Class_ID(ADDCLASSID,0);    }
        const TCHAR    *Category     ( )                   { return GetString(IDS_DB_IMAGE_FILTER); }

};

static ADDClassDesc ADDDesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
     return GetString(IDS_LIBDESCRIPTION); 
}

DLLEXPORT int LibNumberClasses ( ) { 
     return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
     switch(i) {
        case  0: return &ADDDesc; break;
        default: return 0;        break;
     }
}

DLLEXPORT ULONG LibVersion ( )  { 
     return ( VERSION_3DSMAX ); 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

const TCHAR *ImageFilter_Add::Description( )
{
	return GetString(IDS_ADDITIVE_COMP);
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

     switch (message) {
        
        case WM_INITDIALOG: {
             CenterWindow(hWnd,GetParent(hWnd));
             SetCursor(LoadCursor(NULL,IDC_ARROW));
             return 1;
        }

        case WM_COMMAND:

             switch (LOWORD(wParam)) {
                
                case IDOK:              
                     EndDialog(hWnd,1);
                     break;

                case IDCANCEL:
                     EndDialog(hWnd,0);
                     break;
        
             }
             return 1;

     }
     
     return 0;

}

//-----------------------------------------------------------------------------
// #> ImageFilter_Add::ShowAbout()

void ImageFilter_Add::ShowAbout(HWND hWnd) {
     DialogBoxParam(
        hInst,
        MAKEINTRESOURCE(IDD_ADD_ABOUT),
        hWnd,
        (DLGPROC)AboutCtrlDlgProc,
        (LPARAM)this);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Add::Render()
//
//    Private member Bitmap *srcmap has source bitmap
//    Private member Bitmap *frgmap has foreground bitmap
//    Private member Bitmap *mskmap has mask (if any)
//

BOOL ImageFilter_Add::Render(HWND hWnd) {

     BMM_Color_64 *l64,*line64 = NULL;
     BMM_Color_64 *f64,*fgnd64 = NULL;
     WORD         *m16,*mask16 = NULL;

     int width,mwidth;
     
     if (!srcmap)
        return (FALSE);

     if (!frgmap)
        return (FALSE);

     //-- Allocate Background Line
     
     if ((line64=(BMM_Color_64 *)calloc(srcmap->Width(),sizeof(BMM_Color_64)))==NULL)
        return (FALSE);

     //-- Allocate Foreground Line
     
     if ((fgnd64=(BMM_Color_64 *)calloc(srcmap->Width(),sizeof(BMM_Color_64)))==NULL)
        return (FALSE);

     //-- Allocate Mask Line
     
     if (mskmap) {
        mask16 = (WORD *)calloc(srcmap->Width(),sizeof(WORD));
        mwidth = min(srcmap->Width(),mskmap->Width());
     }  

     BOOL result = TRUE;
     BOOL abort  = FALSE;
     
     //-- Adjust differences in bitmap widths
     
     width  = min(srcmap->Width(),frgmap->Width());
     
     for (int iy = 0; iy < srcmap->Height(); iy++) {

        //-- Progress Report
        
        SendMessage(hWnd,FLT_PROGRESS,iy,srcmap->Height()-1);

        //-- Check for Abort
        
        SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

        if (abort) {
           result = FALSE;
           break;
        }   
        
        l64 = line64;
        f64 = fgnd64;

        //-- Get Source line
        
        if (srcmap->GetLinearPixels(0,iy,srcmap->Width(),line64)!=1) {
           result = FALSE;
           break;
        }

        //-- Get Foreground line
        
        if (iy >= frgmap->Height()) {
           memset(fgnd64,0,sizeof(BMM_Color_64));
        } else {
           if (frgmap->GetLinearPixels(0,iy,width,fgnd64)!=1) {
              result = FALSE;
              break;
           }
        }

        //-- Handle Mask ----------------------------------
        
        if (mask16) {
           int r,g,b,a;
           
           if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
              result = FALSE;
              break;
           }
           
           m16 = mask16;
           for (int ix = 0; ix < srcmap->Width(); ix++,m16++,l64++,f64++) {
              
              r = max(l64->r,f64->r);
              g = max(l64->g,f64->g);
              b = max(l64->b,f64->b);
              a = max(l64->a,f64->a);
              
              if (*m16 < 65530) {
                 if (*m16) {
                    l64->r = Lerp(r,(int)l64->r,(int)*m16);
                    l64->g = Lerp(g,(int)l64->g,(int)*m16);
                    l64->b = Lerp(b,(int)l64->b,(int)*m16);
                    l64->a = Lerp(a,(int)l64->a,(int)*m16);
                 } else {
                    l64->r = r;
                    l64->g = g;
                    l64->b = b;
                    l64->a = a;
                 }
              }
           
           }
           
        //-- Unmasked -------------------------------------
        
        } else {
        
           for (int ix = 0; ix < srcmap->Width(); ix++,l64++,f64++) {

              l64->r = max(l64->r,f64->r);
              l64->g = max(l64->g,f64->g);
              l64->b = max(l64->b,f64->b);
              l64->a = max(l64->a,f64->a);

           }
           
        }

        //-- Output Line ----------------------------------
        
        if (srcmap->PutPixels(0,iy,srcmap->Width(),line64)!=1) {
           result = FALSE;
           break;
        }

     }
     
     if (mask16)
        free(mask16);
        
     if (line64)
        free(line64);
        
     if (fgnd64)
        free(fgnd64);
        
     return(result);

}
//-- EOF: Add.cpp -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Alpha\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pmalpha.rc
//
#define IDS_DB_PMALPHA                    1
#define IDS_DB_IMAGE_FILTER             2
#define IDS_DB_PMALPHA_COMP               3
#define IDS_PROCESS_Z                   4
#define IDS_PROCESS_RGBA                5
#define IDS_PROCESS_MTLID               6
#define IDS_PROCESS_NODEID              7
#define IDS_PROCESS_UV                  8
#define IDS_PROCESS_NORMAL              9
#define IDS_PROCESS_REALPIX             10
#define IDS_LIBDESCRIPTION              11
#define IDD_PMALPHA_ABOUT                 101
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\contrast\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by contrast.rc
//
#define IDS_DB_CONTRAST                 1
#define IDS_DB_IMAGE_FILTER             2
#define IDS_BLEND                       3
#define IDS_LIBDESCRIPTION              3
#define IDD_CON_ABOUT                   101
#define IDD_CONTROL                     102
#define IDC_ABSOLUTE                    1002
#define IDC_DERIVED                     1003
#define IDC_CONTRAST_ED                 1023
#define IDC_BRIGHT_ED                   1024
#define IDC_CONTRAST_SP                 1049
#define IDC_BRIGHT_SP                   1050
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Alpha\pmalpha.h ===
//-----------------------------------------------------------------------------
// ------------------
// File ....: PMAlpha.h
// ------------------
// Author...: Gus J Grubba
// Date ....: September 1995
// Descr....: PMAlpha Compositor
//
// History .: Sep, 27 1995 - Started
//            Apr, 09 1997 - Added G Channel Support (GG)
//            
//-----------------------------------------------------------------------------
        
#ifndef _PMALPHACLASS_
#define _PMALPHACLASS_

#define DLLEXPORT __declspec(dllexport)

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class ImageFilter_PMAlpha : public ImageFilter {
    
	public:
     
		//-- Constructors/Destructors
        
                       ImageFilter_PMAlpha( ) {}
                      ~ImageFilter_PMAlpha( ) {}
               
       //-- Filter Info  ---------------------------------

       const TCHAR   *Description         ( ) ;
       const TCHAR   *AuthorName          ( ) { return _T("Gus J Grubba");}
       const TCHAR   *CopyrightMessage    ( ) { return _T("Copyright 1995, Yost Group");}
       UINT           Version             ( ) { return (200);}

       //-- Filter Capabilities --------------------------
        
       DWORD          Capability          ( ) { return(IMGFLT_COMPOSITOR | IMGFLT_MASK); }

       //-- Show DLL's About box -------------------------
        
       void           ShowAbout           ( HWND hWnd );  
       BOOL           ShowControl         ( HWND hWnd ) { return (FALSE); }  

       //-- Show Time ------------------------------------
        
       BOOL           Render              ( HWND hWnd );


};

#endif

//-- EOF: PMAlpha.h ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\contrast\contrast.cpp ===
//-----------------------------------------------------------------------------
// -----------------------
// File ....: Contrast.cpp
// -----------------------
// Author...: Gus J Grubba
// Date ....: September 1995
// Descr....: Contrast Image Filter
//
// History .: Sep, 07 1995 - Started
//            
//-----------------------------------------------------------------------------
		 
//-- Include files

#include <Max.h>
#include <tvnode.h>
#include <bmmlib.h>
#include <fltlib.h>
#include "Contrast.h"
#include "resource.h"

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;
static BOOL controlsInit = FALSE;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
			if (hInst)
				return(FALSE);
			hInst = hDLLInst;
			if ( !controlsInit ) {
				controlsInit = TRUE;
				InitCustomControls(hInst);
			}
			break;
		case DLL_PROCESS_DETACH:
			hInst  = NULL;
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
	}
	return TRUE;
}

//-----------------------------------------------------------------------------
//-- Helper

TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Contrast Class Description

class CONClassDesc:public ClassDesc {
	  
	  public:

		 int             IsPublic     ( )                   { return 1;                }
		 void           *Create       ( BOOL loading=FALSE) { return new ImageFilter_Contrast; }
		 const TCHAR    *ClassName    ( )                   { return GetString(IDS_DB_CONTRAST);     }
		 SClass_ID       SuperClassID ( )                   { return FLT_CLASS_ID;  }
		 Class_ID        ClassID      ( )                   { return Class_ID(CONTRASTCLASSID,0);    }
		 const TCHAR    *Category     ( )                   { return GetString(IDS_DB_IMAGE_FILTER); }

};

static CONClassDesc CONDesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
	  return GetString(IDS_LIBDESCRIPTION); 
}

DLLEXPORT int LibNumberClasses ( ) { 
	  return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
	  switch(i) {
		 case  0: return &CONDesc; break;
		 default: return 0;        break;
	  }
}

DLLEXPORT ULONG LibVersion ( )  { 
	  return ( VERSION_3DSMAX ); 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

const TCHAR *ImageFilter_Contrast::Description( ) 
{
	return GetString(IDS_DB_CONTRAST);
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

	  switch (message) {
		 
		 case WM_INITDIALOG: {
			  CenterWindow(hWnd,GetParent(hWnd));
			  SetCursor(LoadCursor(NULL,IDC_ARROW));
			  return 1;
		 }

		 case WM_COMMAND:

			  switch (LOWORD(wParam)) {
				 
				 case IDOK:              
					  EndDialog(hWnd,1);
					  break;

				 case IDCANCEL:
					  EndDialog(hWnd,0);
					  break;
		 
			  }
			  return 1;

	  }
	  
	  return 0;

}

//-----------------------------------------------------------------------------
// *> ControlCtrlDlgProc()
//

BOOL CALLBACK ControlCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {
	static ImageFilter_Contrast *f = NULL;
	if (message == WM_INITDIALOG) 
		f = (ImageFilter_Contrast *)lParam;
	if (f) 
		return (f->Control(hWnd,message,wParam,lParam));
	else
		return(FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Contrast::ImageFilter_Contrast()

ImageFilter_Contrast::ImageFilter_Contrast() {

	lut				= NULL;
	data.absolute	= FALSE;
	data.contrast	= 0.0f;
	data.brightness	= 0.0f;

}

//-----------------------------------------------------------------------------
// #> ImageFilter_Contrast::ShowAbout()

void ImageFilter_Contrast::ShowAbout(HWND hWnd) {
	  DialogBoxParam(
		 hInst,
		 MAKEINTRESOURCE(IDD_CON_ABOUT),
		 hWnd,
		 (DLGPROC)AboutCtrlDlgProc,
		 (LPARAM)this);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Contrast::ShowControl()

BOOL ImageFilter_Contrast::ShowControl(HWND hWnd) {
	return (DialogBoxParam(
		hInst,
		MAKEINTRESOURCE(IDD_CONTROL),
		hWnd,
		(DLGPROC)ControlCtrlDlgProc,
		(LPARAM)this));
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Contrast::Control()

BOOL ImageFilter_Contrast::Control(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

	switch (message) {
		
		//------------------------------------------------------------
		//-- Init ----------------------------------------------------

		case WM_INITDIALOG:

			CenterWindow(hWnd,GetParent(hWnd));
			CheckRadioButton(hWnd,IDC_ABSOLUTE,IDC_DERIVED,data.absolute?IDC_ABSOLUTE:IDC_DERIVED);

			//-- Contrast Spinner

			conspin = GetISpinner(GetDlgItem(hWnd, IDC_CONTRAST_SP));
			conspin->LinkToEdit(  GetDlgItem(hWnd, IDC_CONTRAST_ED), EDITTYPE_FLOAT );
			conspin->SetLimits( -1.0f,1.0f, FALSE);
			conspin->SetValue(data.contrast,FALSE);
			conspin->SetScale((float)0.01);

			//-- Brightness Spinner

			brispin = GetISpinner(GetDlgItem(hWnd, IDC_BRIGHT_SP));
			brispin->LinkToEdit(  GetDlgItem(hWnd, IDC_BRIGHT_ED), EDITTYPE_FLOAT );
			brispin->SetLimits( -1.0f,1.0f, FALSE);
			brispin->SetValue(data.brightness,FALSE);
			brispin->SetScale((float)0.01);

			return 1;

		//------------------------------------------------------------
		//-- Buttons -------------------------------------------------
				  
		case WM_COMMAND:

			switch (LOWORD(wParam)) {
				  
				case IDOK:              
					data.absolute	= IsDlgButtonChecked(hWnd,IDC_ABSOLUTE);
					data.contrast	= conspin->GetFVal();
					data.brightness	= brispin->GetFVal();
					EndDialog(hWnd,1);
					break;

				case IDCANCEL:
				   	EndDialog(hWnd,0);
				   	break;
		
			}
			return 1;

		//------------------------------------------------------------
		//-- Kaput ---------------------------------------------------
				  
		case WM_DESTROY:
			ReleaseISpinner(conspin);
			ReleaseISpinner(brispin);
			break;

	}
	
	return 0;

}

//-----------------------------------------------------------------------------
// #> ImageFilter_Contrast::Render()
//

BOOL ImageFilter_Contrast::Render(HWND hWnd) {

	BMM_Color_64 *l64,*line64 = NULL;
	
	if (!srcmap)
		return (FALSE);

	if (!BuildTable())
		return (FALSE);

	if (data.contrast == 0.0f && data.brightness == 0.0f)
		return(TRUE);

	if ((line64=(BMM_Color_64 *)calloc(srcmap->Width(),sizeof(BMM_Color_64)))==NULL)
		return (FALSE);

	BOOL result = TRUE;
	BOOL abort  = FALSE;

	int	bright = (int)(data.brightness * 65535.0f);
	  
	//-- Mess up the image

	for (int iy = 0; iy < srcmap->Height(); iy++) {

		//-- Progress Report
		 
		SendMessage(hWnd,FLT_PROGRESS,iy,srcmap->Height()-1);

		//-- Check for Abort
		 
		SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

		if (abort) {
			result = FALSE;
			break;
		}   
		 
		//-- Get line
		 
		l64 = line64;

		if (srcmap->GetLinearPixels(0,iy,srcmap->Width(),line64)!=1) {
			result = FALSE;
			break;
		}

		for (int ix = 0; ix < srcmap->Width(); ix++,l64++) {

			int gray;

			int r = l64->r;
			int g = l64->g;
			int b = l64->b;

			if (data.absolute) {
			    gray = max(r,g);
			    gray = max(b,gray);
			} else 
				gray = (r+g+b) / 3;

			int k = lut[gray]-gray;

			l64->r = max( min( r + k + bright, 65535),0);
			l64->g = max( min( g + k + bright, 65535),0);
			l64->b = max( min( b + k + bright, 65535),0);

		}

		//-- Output Line
		 
		if (srcmap->PutPixels(0,iy,srcmap->Width(),line64)!=1) {
			result = FALSE;
			break;
		}

	}
	  
	if (line64)
		free(line64);
		 
	return(result);

}

//-----------------------------------------------------------------------------
// #> ImageFilter_Contrast::BuildTable()
//

BOOL ImageFilter_Contrast::BuildTable ( void ) {
	
	lut = (WORD *)LocalAlloc(LPTR,sizeof(WORD)*65536);

	if (!lut)
		return (FALSE);
	
	int i;

	for (i=0; i < 65536; i++) lut[i]=i;

	if ( data.contrast > 0.0f ) {

		int MinBin	= (int)(data.contrast * 65535.0f);
		int MaxBin	= 65535 - MinBin;
		float step	= (float)sqrt((double)data.contrast)/data.contrast;
		float stepv	= 0.0f;

		for (i=0; i<MinBin; i++) {
			lut[i] = (WORD)stepv;
			stepv += step;
		}

		step = 65536.0f / (float)(MaxBin-MinBin);

		for (i=MinBin; i<=MaxBin; i++) {
			if (stepv > 65535.0f) {
				stepv = 65535.0f;
				step = 0.0f;
			}
			lut[i] = (WORD)stepv;
			stepv += step;
		}

		for (i=MaxBin+1; i < 65536; i++) lut[i] = 65535;

	} else  {

		if (data.contrast < 0.0f ) {
			float step	= (65536.0f + data.contrast * 2.0f * 65535.0f ) / 65536.0f;
			float stepv	= data.contrast * -1.0f * 65535.0f;
			for (i = 0; i < 65536; i++) {
				lut[i] = (WORD)stepv;
				stepv += step;
			}
		}
	}

	return (TRUE);

}

//-----------------------------------------------------------------------------
// #> ImageFilter_Contrast::LoadConfigure()

BOOL ImageFilter_Contrast::LoadConfigure ( void *ptr ) {
	CONTRASTDATA *buf = (CONTRASTDATA *)ptr;
	if (buf->version == CONTRASTVERSION) {
		memcpy((void *)&data,ptr,sizeof(CONTRASTDATA));
		return (TRUE);
	} else
		return (FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Contrast::SaveConfigure()

BOOL ImageFilter_Contrast::SaveConfigure ( void *ptr ) {
	if (ptr) {
		data.version = CONTRASTVERSION;
		memcpy(ptr,(void *)&data,sizeof(CONTRASTDATA));
		return (TRUE);
	} else
		return (FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Contrast::EvaluateConfigure()

DWORD ImageFilter_Contrast::EvaluateConfigure ( ) {
      return (sizeof(CONTRASTDATA));
}

//-- EOF: contrast.cpp --------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Cookie\cookie.h ===
//-----------------------------------------------------------------------------
// -------------------
// File ....: Cookie.h
// -------------------
// Author...: Gus J Grubba
// Date ....: February 1996
// Descr....: Cookie Cutter Image Filter
//
// History .: Feb, 18 1996 - Started
//            
//-----------------------------------------------------------------------------
        
#ifndef _COOKIECLASS_
#define _COOKIECLASS_

#define DLLEXPORT __declspec(dllexport)

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class ImageFilter_Cookie : public ImageFilter {
    
     public:
     
        //-- Constructors/Destructors
        
                       ImageFilter_Cookie( ) {}
                      ~ImageFilter_Cookie( ) {}
               
        //-- Filter Info  ---------------------------------

        const TCHAR   *Description         ( ) ;
        const TCHAR   *AuthorName          ( ) { return _T("Gus J Grubba");}
        const TCHAR   *CopyrightMessage    ( ) { return _T("Copyright 1996, Yost Group");}
        UINT           Version             ( ) { return (100);}

        //-- Filter Capabilities --------------------------
        
        DWORD          Capability          ( ) { return(IMGFLT_FILTER | IMGFLT_MASK); }

        //-- Show DLL's About box -------------------------
        
        void           ShowAbout           ( HWND hWnd );

        //-- Showtime -------------------------------------
        
        BOOL           Render              ( HWND hWnd );

};

#endif

//-- EOF: Cookie.h ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Cookie\cookie.cpp ===
//-----------------------------------------------------------------------------
// ---------------------
// File	....:	Cookie.cpp
// ---------------------
// Author...:	Gus J	Grubba
// Date	....:	February 1996
// Descr....:	Cookie Cutter Image Filter
//
// History	.:	Feb, 18 1996 -	Started
//				
//-----------------------------------------------------------------------------
		
//--	Include files

#include <Max.h>
#include <bmmlib.h>
#include <fltlib.h>
#include "Cookie.h"
#include "resource.h"

//--	Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//--	DLL Declaration

BOOL	WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)	{
	switch (fdwReason) {
		 case	DLL_PROCESS_ATTACH:
				if	(hInst)
					return(FALSE);
				hInst	= hDLLInst;
				break;
		 case	DLL_PROCESS_DETACH:
				hInst	 =	NULL;
				break;
		 case	DLL_THREAD_ATTACH:
				break;
		 case	DLL_THREAD_DETACH:
				break;
	}
	return TRUE;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Cookie	Class	Description

class COOKIEClassDesc:public ClassDesc {
	
	public:

		int				 IsPublic	  ( )							{ return	1;						}
		void				*Create		  ( BOOL	loading=FALSE)	{ return	new ImageFilter_Cookie; }
		const	TCHAR		*ClassName	  ( )							{ return	GetString(IDS_DB_COOKIE);		 }
		SClass_ID		 SuperClassID ( )							{ return	FLT_CLASS_ID;	}
		Class_ID			 ClassID		  ( )							{ return	Class_ID(COOKIECLASSID,0);	 }
		const	TCHAR		*Category	  ( )							{ return	GetString(IDS_DB_IMAGE_FILTER); }

};

static COOKIEClassDesc COOKIEDesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription (	)	{ 
 	return GetString(IDS_LIBDESCRIPTION); 
}

DLLEXPORT int	LibNumberClasses ( )	{ 
	return 1; 
}

DLLEXPORT ClassDesc	*LibClassDesc(int	i)	{
	switch(i) {
		case	0:	return &COOKIEDesc;	break;
		default:	return 0;		  break;
	}
}

DLLEXPORT ULONG LibVersion (	)	{ 
	return (	VERSION_3DSMAX	);	
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

const TCHAR *ImageFilter_Cookie::Description( ) 
{
	return GetString(IDS_DB_IMAGE_ALPHA);
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL	CALLBACK	AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)	{
	switch (message) {
		case WM_INITDIALOG:
			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			return 1;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:				  
				case IDCANCEL:
					EndDialog(hWnd,1);
					break;
			}
			return 1;
	}
	return 0;
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Cookie::ShowAbout()

void	ImageFilter_Cookie::ShowAbout(HWND hWnd) {
	DialogBoxParam(
		hInst,
		MAKEINTRESOURCE(IDD_COOKIE_ABOUT),
		hWnd,
		(DLGPROC)AboutCtrlDlgProc,
		(LPARAM)this);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Cookie::Render()
//

BOOL	ImageFilter_Cookie::Render(HWND	hWnd)	{

	BMM_Color_64 *l64,*line64 = NULL;
	WORD			 *m16,*mask16 = NULL;
	BOOL result	= FALSE;
	BOOL abort	= FALSE;
	int iy,ix;

	if	(!srcmap)
		return (FALSE);

	if	(!mskmap)
		return (FALSE);

	//-- Buffers -----------------------------------------

	line64 = (BMM_Color_64 *)calloc(srcmap->Width(),sizeof(BMM_Color_64));

	if	(!line64)
		goto done;

	mask16 =	(WORD	*)calloc(srcmap->Width(),sizeof(WORD));

	if	(!mask16)
		goto done;

	//-- Render Loop -------------------------------------

	for ( iy	= 0; iy < srcmap->Height(); iy++) {

		//-- Progress Report
		
		SendMessage(hWnd,FLT_PROGRESS,iy,srcmap->Height()-1);

		//-- Check for	Abort
		
		SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL	*)&abort);

		if	(abort)
			goto done;
		
		//-- Get	lines
		
		if	(srcmap->GetLinearPixels(0,iy,srcmap->Width(),line64)!=1)
			goto done;

		if	(mskmap->Get16Gray(0,iy,srcmap->Width(),mask16)!=1)
			goto done;
			
		//-- Apply Mask -----------------------------------
		
		l64 =	line64;
	  	m16 =	mask16;

		for ( ix	= 0; ix < srcmap->Width();	ix++,l64++,m16++)	{
			l64->a =	*m16;
		}

		//-- Output	Line
		
		if	(srcmap->PutPixels(0,iy,srcmap->Width(),line64)!=1)
			goto done;

	}

	result = TRUE;
	
	//-- Kaput -------------------------------------------

	done:

	if	(mask16)
		free(mask16);
		
	if	(line64)
		free(line64);
		
	return(result);

}

//--	EOF: Cookie.cpp --------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Cookie\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cookie.rc
//
#define IDS_DB_COOKIE                   1
#define IDS_DB_IMAGE_FILTER             2
#define IDS_DB_IMAGE_ALPHA              3
#define IDS_LIBDESCRIPTION              4
#define IDD_COOKIE_ABOUT                101
#define IDD_COOKIE_CONTROL              102
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\contrast\contrast.h ===
//-----------------------------------------------------------------------------
// ---------------------
// File ....: Contrast.h
// ---------------------
// Author...: Gus J Grubba
// Date ....: September 1995
// Descr....: Contrast Image Filter
//
// History .: Sep, 07 1995 - Started
//            
//
//
//-----------------------------------------------------------------------------
		 
#ifndef _CONCLASS_
#define _CONCLASS_

#define DLLEXPORT __declspec(dllexport)
#define CONTRASTCLASSID NEGATIVECLASSID + 0x128

//-----------------------------------------------------------------------------
//-- Configuration Block ------------------------------------------------------
//

#define CONTRASTVERSION 100

typedef struct tagCONTRASTDATA {
     DWORD	version;
	  BOOL	absolute;
     float	contrast;
	  float	brightness;
} CONTRASTDATA;

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class ImageFilter_Contrast : public ImageFilter {

		WORD			*lut;
		CONTRASTDATA	data;

		ISpinnerControl	*conspin;
		ISpinnerControl	*brispin;
	
		BOOL			BuildTable			( void );

	  public:
	  
		//-- Constructors/Destructors
		
						ImageFilter_Contrast ( );
						~ImageFilter_Contrast( ) { if (lut) LocalFree(lut); }
			   
		//-- Filter Info  ----------------------------------

		const TCHAR   	*Description        ( ) ;
		const TCHAR   	*AuthorName         ( ) { return _T("Gus J Grubba");}
		const TCHAR   	*CopyrightMessage   ( ) { return _T("Copyright 1993, 1996 Gus J Grubba");}
		UINT           	Version             ( ) { return (100);}

		//-- Filter Capabilities --------------------------
		
		DWORD          	Capability          ( ) { return( IMGFLT_FILTER | IMGFLT_CONTROL); }

		//-- Show DLL's Dialogue boxes --------------------
		
		void           	ShowAbout           ( HWND hWnd );  
		BOOL           	ShowControl         ( HWND hWnd );  

		//-- Show Time ------------------------------------
		
		BOOL           	Render              ( HWND hWnd );

        //-- Filter Configuration -------------------------
        
		BOOL           	LoadConfigure		( void *ptr );
		BOOL           	SaveConfigure		( void *ptr );
		DWORD          	EvaluateConfigure	( );
        
		//-- Local Methods --------------------------------
        
		BOOL  			Control	  			(HWND ,UINT ,WPARAM ,LPARAM );

};

#endif

//-- EOF: Contrast.h ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\CrosFade\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by crosfade.rc
//
#define IDS_DB_CROSSFADE                1
#define IDS_DB_IMAGE_FILTER             2
#define IDS_DB_CROSS_FADE               3
#define IDS_LIBDESCRIPTION              4
#define IDD_CROSFADE_ABOUT              101
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\CrosFade\crosfade.h ===
//-----------------------------------------------------------------------------
// ------------------
// File ....: CrosFade.h
// ------------------
// Author...: Gus J Grubba
// Date ....: February 1996
// Descr....: CrosFade Transition
//
// History .: Feb, 08 1996 - Started
//            
//-----------------------------------------------------------------------------
        
#ifndef _CROSFADECLASS_
#define _CROSFADECLASS_

#define DLLEXPORT __declspec(dllexport)

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class ImageFilter_CrosFade : public ImageFilter {
    
     public:
     
        //-- Constructors/Destructors
        
                       ImageFilter_CrosFade( ) {}
                      ~ImageFilter_CrosFade( ) {}
               
        //-- Filter Info  ---------------------------------

        const TCHAR   *Description         ( ) ;
        const TCHAR   *AuthorName          ( ) { return _T("Gus J Grubba");}
        const TCHAR   *CopyrightMessage    ( ) { return _T("Copyright 1995, Yost Group");}
        UINT           Version             ( ) { return (100);}

        //-- Filter Capabilities --------------------------
        
        DWORD          Capability          ( ) { return(IMGFLT_COMPOSITOR | IMGFLT_MASK); }

        //-- Show DLL's About box -------------------------
        
        void           ShowAbout           ( HWND hWnd );  
        BOOL           ShowControl         ( HWND hWnd ) { return (FALSE); }  

        //-- Show Time ------------------------------------
        
        BOOL           Render              ( HWND hWnd );

};

#endif

//-- EOF: CrosFade.h ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\CrosFade\crosfade.cpp ===
//-----------------------------------------------------------------------------
// -----------------------
// File ....: CrosFade.cpp
// -----------------------
// Author...: Gus J Grubba
// Date ....: February 1996
// Descr....: CrosFade Transition
//
// History .: Feb, 08 1996 - Started
//            
//-----------------------------------------------------------------------------
		
//-- Include files

#include <Max.h>
#include <bmmlib.h>
#include <fltlib.h>
#include "CrosFade.h"
#include "resource.h"

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
	switch (fdwReason) {
		 case DLL_PROCESS_ATTACH:
				if (hInst)
					return(FALSE);
				hInst = hDLLInst;
				break;
		 case DLL_PROCESS_DETACH:
				hInst  = NULL;
				break;
		 case DLL_THREAD_ATTACH:
				break;
		 case DLL_THREAD_DETACH:
				break;
	}
	return TRUE;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// CrosFade Class Description

class CROSFADEClassDesc:public ClassDesc {
	
	public:

		int             IsPublic     ( )                   { return 1;                }
		void           *Create       ( BOOL loading=FALSE) { return new ImageFilter_CrosFade; }
		const TCHAR    *ClassName    ( )                   { return GetString(IDS_DB_CROSSFADE);     }
		SClass_ID       SuperClassID ( )                   { return FLT_CLASS_ID;  }
		Class_ID        ClassID      ( )                   { return Class_ID(CROSFADECLASSID,0);    }
		const TCHAR    *Category     ( )                   { return GetString(IDS_DB_IMAGE_FILTER); }

};

static CROSFADEClassDesc CROSFADEDesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
	return GetString(IDS_LIBDESCRIPTION); 
}

DLLEXPORT int LibNumberClasses ( ) { 
	return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
	switch(i) {
		case  0: return &CROSFADEDesc; break;
		default: return 0;        break;
	}
}

DLLEXPORT ULONG LibVersion ( )  { 
	return ( VERSION_3DSMAX ); 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

const TCHAR *ImageFilter_CrosFade::Description( ) 
{
	return GetString(IDS_DB_CROSS_FADE);
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

	switch (message) {
		
		case WM_INITDIALOG: {
			  CenterWindow(hWnd,GetParent(hWnd));
			  SetCursor(LoadCursor(NULL,IDC_ARROW));
			  return 1;
		}

		case WM_COMMAND:

			  switch (LOWORD(wParam)) {
				  
				  case IDOK:              
						 EndDialog(hWnd,1);
						 break;

				  case IDCANCEL:
						 EndDialog(hWnd,0);
						 break;
		
			  }
			  return 1;

	}
	
	return 0;

}

//-----------------------------------------------------------------------------
// #> ImageFilter_CrosFade::ShowAbout()

void ImageFilter_CrosFade::ShowAbout(HWND hWnd) {
	DialogBoxParam(
		hInst,
		MAKEINTRESOURCE(IDD_CROSFADE_ABOUT),
		hWnd,
		(DLGPROC)AboutCtrlDlgProc,
		(LPARAM)this);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_CrosFade::Render()
//
//    Private member Bitmap *srcmap has source bitmap
//    Private member Bitmap *frgmap has foreground bitmap
//    Private member Bitmap *mskmap has mask (if any)
//

BOOL ImageFilter_CrosFade::Render(HWND hWnd) {

	BMM_Color_64 *l64,*line64 = NULL;
	BMM_Color_64 *f64,*fgnd64 = NULL;
	WORD         *m16,*mask16 = NULL;

	if (!srcmap)
		return (FALSE);

	if (!frgmap)
		return (FALSE);

	//-- Allocate Background Line
	
	if ((line64=(BMM_Color_64 *)calloc(srcmap->Width(),sizeof(BMM_Color_64)))==NULL)
		return (FALSE);

	//-- Allocate Foreground Line
	
	if ((fgnd64=(BMM_Color_64 *)calloc(srcmap->Width(),sizeof(BMM_Color_64)))==NULL)
		return (FALSE);

	//-- Allocate Mask Line
	
	if (mskmap) {
		mask16 = (WORD *)calloc(srcmap->Width(),sizeof(WORD));
	}  

	BOOL result = TRUE;
	BOOL abort  = FALSE;
	
	//-- Calculate Lerp value

	float count = (float)ifi->FilterRange.Count();
	float lerp 	= (float)((ifi->QueueRange.Current() - ifi->FilterRange.First())) / count;
	
	//-- Process Image

	for (int iy = 0; iy < srcmap->Height(); iy++) {

		//-- Progress Report
		
		SendMessage(hWnd,FLT_PROGRESS,iy,srcmap->Height()-1);

		//-- Check for Abort
		
		SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

		if (abort) {
			result = FALSE;
			break;
		}   
		
		l64 = line64;
		f64 = fgnd64;

		//-- Get Source line
		
		if (srcmap->GetLinearPixels(0,iy,srcmap->Width(),line64)!=1) {
			result = FALSE;
			break;
		}

		//-- Get Foreground line
		
		if (frgmap->GetLinearPixels(0,iy,srcmap->Width(),fgnd64)!=1) {
			result = FALSE;
			break;
		}

		//-- Handle Mask ----------------------------------
		
		if (mask16) {
			int r,g,b,a;
			
			if (mskmap->Get16Gray(0,iy,srcmap->Width(),mask16)!=1) {
				result = FALSE;
				break;
			}
			
			m16 = mask16;
			for (int ix = 0; ix < srcmap->Width(); ix++,m16++,l64++,f64++) {
				
				r = Lerp(l64->r, f64->r, lerp);
				g = Lerp(l64->g, f64->g, lerp);
				b = Lerp(l64->b, f64->b, lerp);
				a = Lerp(l64->a, f64->a, lerp);
				
				if (*m16 < 65530) {
					if (*m16) {
						l64->r = Lerp(r,(int)l64->r,(int)*m16);
						l64->g = Lerp(g,(int)l64->g,(int)*m16);
						l64->b = Lerp(b,(int)l64->b,(int)*m16);
						l64->a = Lerp(a,(int)l64->a,(int)*m16);
					} else {
						l64->r = r;
						l64->g = g;
						l64->b = b;
						l64->a = a;
					}
				}
			
			}
			
		//-- Unmasked -------------------------------------
		
		} else {
		
			for (int ix = 0; ix < srcmap->Width(); ix++,l64++,f64++) {

				l64->r = Lerp(l64->r, f64->r, lerp);
				l64->g = Lerp(l64->g, f64->g, lerp);
				l64->b = Lerp(l64->b, f64->b, lerp);
				l64->a = Lerp(l64->a, f64->a, lerp);

			}
			
		}

		//-- Output Line ----------------------------------
		
		if (srcmap->PutPixels(0,iy,srcmap->Width(),line64)!=1) {
			result = FALSE;
			break;
		}

	}
	
	if (mask16)
		free(mask16);
		
	if (line64)
		free(line64);
		
	if (fgnd64)
		free(fgnd64);
		
	return(result);

}

//-- EOF: CrosFade.cpp --------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Fade\fade.cpp ===
//-----------------------------------------------------------------------------
// -------------------
// File ....: Fade.cpp
// -------------------
// Author...: Gus J Grubba
// Date ....: February 1996
// Descr....: Fade Image Filter
//
// History .: Feb, 21 1995 - Started
//            
//-----------------------------------------------------------------------------
        
//-- Include files

#include <Max.h>
#include <bmmlib.h>
#include <fltlib.h>
#include "Fade.h"
#include "resource.h"

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
     switch (fdwReason) {
         case DLL_PROCESS_ATTACH:
              if (hInst)
                 return(FALSE);
              hInst = hDLLInst;
              break;
         case DLL_PROCESS_DETACH:
              hInst  = NULL;
              break;
         case DLL_THREAD_ATTACH:
              break;
         case DLL_THREAD_DETACH:
              break;
     }
     return TRUE;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Fade Class Description

class FADEClassDesc:public ClassDesc {
     
     public:

        int             IsPublic     ( )                   { return 1;                }
        void           *Create       ( BOOL loading=FALSE) { return new ImageFilter_Fade; }
        const TCHAR    *ClassName    ( )                   { return GetString(IDS_DB_FADE);     }
        SClass_ID       SuperClassID ( )                   { return FLT_CLASS_ID;  }
        Class_ID        ClassID      ( )                   { return Class_ID(FADECLASSID,0);    }
        const TCHAR    *Category     ( )                   { return GetString(IDS_DB_IMAGE_FILTER); }

};

static FADEClassDesc FADEDesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
     return GetString(IDS_LIBDESCRIPTION); 
}

DLLEXPORT int LibNumberClasses ( ) { 
     return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
     switch(i) {
        case  0: return &FADEDesc; break;
        default: return 0;        break;
     }
}

DLLEXPORT ULONG LibVersion ( )  { 
     return ( VERSION_3DSMAX ); 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

const TCHAR *ImageFilter_Fade::Description( ) 
{
	return GetString(IDS_DB_FADE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Fade::ImageFilter_Fade()
//

ImageFilter_Fade::ImageFilter_Fade()	{
	data.version= FADEVERSION; 
	data.type	= IDC_OUT;
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Fade::Control()
//

BOOL	ImageFilter_Fade::Control(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)	{

	switch (message) {

		case WM_INITDIALOG:

			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));

			CheckRadioButton(
				hWnd,
				IDC_IN,
				IDC_OUT,
				data.type
			);

			return 1;

		case WM_COMMAND:

			switch (LOWORD(wParam)) {

				case IDOK:
					data.type = (IsDlgButtonChecked(hWnd,IDC_IN) ? IDC_IN : IDC_OUT);
					EndDialog(hWnd,1);
					break;

				case IDCANCEL:
					EndDialog(hWnd,0);
					break;

			}

			return 1;

	}

	return 0;

}

//-----------------------------------------------------------------------------
// *> ControlDlgProc()
//

BOOL	CALLBACK	ControlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)	{
     static ImageFilter_Fade *flt = NULL;
     if (message == WM_INITDIALOG) 
        flt = (ImageFilter_Fade *)lParam;
     if (flt) 
        return (flt->Control(hWnd,message,wParam,lParam));
     else
        return(FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Fade::ShowControl()

BOOL ImageFilter_Fade::ShowControl(HWND hWnd) {
     return (DialogBoxParam(
        hInst,
        MAKEINTRESOURCE(IDD_FADE_CONTROL),
        hWnd,
        (DLGPROC)ControlDlgProc,
        (LPARAM)this));
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

     switch (message) {
        
        case WM_INITDIALOG: {
             CenterWindow(hWnd,GetParent(hWnd));
             SetCursor(LoadCursor(NULL,IDC_ARROW));
             return 1;
        }

        case WM_COMMAND:

             switch (LOWORD(wParam)) {
                
                case IDOK:              
                     EndDialog(hWnd,1);
                     break;

                case IDCANCEL:
                     EndDialog(hWnd,0);
                     break;
        
             }
             return 1;

     }
     
     return 0;

}

//-----------------------------------------------------------------------------
// #> ImageFilter_Fade::ShowAbout()

void ImageFilter_Fade::ShowAbout(HWND hWnd) {
     DialogBoxParam(
        hInst,
        MAKEINTRESOURCE(IDD_FADE_ABOUT),
        hWnd,
        (DLGPROC)AboutCtrlDlgProc,
        (LPARAM)this);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Fade::Render()
//

BOOL ImageFilter_Fade::Render(HWND hWnd) {

     BMM_Color_64 *l64,*line64 = NULL;
     WORD         *m16,*mask16 = NULL;

     BOOL result = TRUE;
     BOOL abort  = FALSE;
     
     if (!srcmap)
        return (FALSE);

     if ((line64=(BMM_Color_64 *)calloc(srcmap->Width(),sizeof(BMM_Color_64)))==NULL)
        return (FALSE);

     if (mskmap)
        mask16 = (WORD *)calloc(srcmap->Width(),sizeof(WORD));

	//-- Calculate Lerp value

	float count = (float)(max(ifi->FilterRange.Count()-1,1));
	float lerp 	= (float)((ifi->QueueRange.Current() - ifi->FilterRange.First())) / count;

	if (data.type == IDC_OUT)
		lerp = 1.0f - lerp;
     
     for (int iy = 0; iy < srcmap->Height(); iy++) {

        //-- Progress Report
        
        SendMessage(hWnd,FLT_PROGRESS,iy,srcmap->Height()-1);

        //-- Check for Abort
        
        SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

        if (abort)
			goto done;
        
        //-- Get line
        
        l64 = line64;

        if (srcmap->GetLinearPixels(0,iy,srcmap->Width(),line64)!=1)
			goto done;

        //-- Handle Mask
        
        if (mask16) {
           int r,g,b,a;
           
           if (mskmap->Get16Gray(0,iy,srcmap->Width(),mask16)!=1)
				goto done;
           
           m16 = mask16;
           for (int ix = 0; ix < srcmap->Width(); ix++,l64++,m16++) {
              r = (int)((float)l64->r * lerp);
              g = (int)((float)l64->g * lerp);
              b = (int)((float)l64->b * lerp);
              a = (int)((float)l64->a * lerp);
              if (*m16 < 65530) {
                 if (*m16) {
                    l64->r = Lerp(r,(int)l64->r,(int)*m16);
                    l64->g = Lerp(g,(int)l64->g,(int)*m16);
                    l64->b = Lerp(b,(int)l64->b,(int)*m16);
                    l64->a = Lerp(a,(int)l64->a,(int)*m16);
                 } else {
                    l64->r = r;
                    l64->g = g;
                    l64->b = b;
                    l64->a = a;
                 }
              }
           }
           
        //-- Unmasked
        
        } else {
        
           for (int ix = 0; ix < srcmap->Width(); ix++,l64++) {
              l64->r = (int)((float)l64->r * lerp);
              l64->g = (int)((float)l64->g * lerp);
              l64->b = (int)((float)l64->b * lerp);
              l64->a = (int)((float)l64->a * lerp);
           }
           
        }

        //-- Output Line
        
        if (srcmap->PutPixels(0,iy,srcmap->Width(),line64)!=1)
			goto done;

     }

	result = TRUE;
     
	done:

     if (mask16)
        free(mask16);
        
     if (line64)
        free(line64);
        
     return(result);

}

//-----------------------------------------------------------------------------
// #> ImageFilter_Fade::LoadConfigure()

BOOL ImageFilter_Fade::LoadConfigure ( void *ptr ) {
     FADEDATA *buf = (FADEDATA *)ptr;
     if (buf->version == FADEVERSION) {
        memcpy((void *)&data,ptr,sizeof(FADEDATA));
        return (TRUE);
     } else
        return (FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Fade::SaveConfigure()

BOOL ImageFilter_Fade::SaveConfigure ( void *ptr ) {
     if (ptr) {
        memcpy(ptr,(void *)&data,sizeof(FADEDATA));
        return (TRUE);
     } else
        return (FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Fade::EvaluateConfigure()

DWORD ImageFilter_Fade::EvaluateConfigure ( ) {
      return (sizeof(FADEDATA));
}

//-- EOF: Fade.cpp ------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Glow\glow.h ===
//-----------------------------------------------------------------------------
// ---------------------
// File ....: Glow.h
// ---------------------
// Author...: Gus J Grubba
// Date ....: September 1995
// Descr....: Glow Image Filter
//
// History .: Feb, 17 1996 - Started
//            
//-----------------------------------------------------------------------------
        
#ifndef _GLOWCLASS_
#define _GLOWCLASS_

#define DLLEXPORT __declspec(dllexport)

//-----------------------------------------------------------------------------
//-- Configuration Block ------------------------------------------------------
//

#define GLOWVERSION 101

typedef struct tagGLOWDATA {
	DWORD version;
	int	type;
	int	node;
	int	mtl;
	int	size;	
	BMM_Color_64 color;	
	int	colorsrc;	
} GLOWDATA;

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class ImageFilter_Glow : public ImageFilter {
    
		GLOWDATA       data;

	public:
     
        //-- Constructors/Destructors
        
                       ImageFilter_Glow( );
                      ~ImageFilter_Glow( ) {}
               
        //-- Filter Info  ---------------------------------

        const TCHAR   *Description         ( );
        const TCHAR   *AuthorName          ( ) { return _T("Gus J Grubba, David C Thompson");}
        const TCHAR   *CopyrightMessage    ( ) { return _T("Copyright 1996, Yost Group");}
        UINT           Version             ( ) { return (GLOWVERSION);}

        //-- Filter Capabilities --------------------------
        
        DWORD          Capability          ( ) { return(IMGFLT_FILTER | IMGFLT_CONTROL); }

        //-- Show DLL's About & Control box ---------------
        
        void           ShowAbout           ( HWND hWnd );  
        BOOL           ShowControl         ( HWND hWnd );  

        //-- Showtime -------------------------------------
        
        BOOL           Render              ( HWND hWnd );

        //-- Filter Configuration -------------------------
        
        BOOL           LoadConfigure			( void *ptr );
        BOOL           SaveConfigure			( void *ptr );
        DWORD          EvaluateConfigure		( );
        DWORD          ChannelsRequired		( );

        //-- Local Methods --------------------------------
        
		BOOL				Control					(HWND ,UINT ,WPARAM ,LPARAM );
		void				HandleInputs			( HWND hWnd );
		void				GlowPixels				(int sx, int sy, BMM_Color_64 *curPix);

};

#endif

//-- EOF: Glow.h ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Glow\glow.cpp ===
//-----------------------------------------------------------------------------
// -------------------
// File	....:	Glow.cpp
// -------------------
// Author...:	Gus J	Grubba
// Date	....:	September 1995
// Descr....:	Glow Image Filter
//
// History	.:	Feb, 17 1996 -	Started
//				
//-----------------------------------------------------------------------------
		
//--	Include files

#include <Max.h>
#include <bmmlib.h>
#include <fltlib.h>
#include "Glow.h"
#include "resource.h"

//--	Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

static ISpinnerControl	*mtlspin = NULL;
static ISpinnerControl	*nodspin = NULL;
static ISpinnerControl	*sizespin = NULL;
static IColorSwatch		*colorSwatch = NULL;
COLORREF colorref;

static BOOL controlsInit = FALSE;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//--	DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)	{
	switch (fdwReason) {
		 case	DLL_PROCESS_ATTACH:
				if (hInst)
					return(FALSE);
				hInst = hDLLInst;
				if ( !controlsInit ) {
					controlsInit = TRUE;
					InitCustomControls(hInst);
					//InitCommonControls();
				}
				break;
		 case	DLL_PROCESS_DETACH:
				hInst =	NULL;
				break;
		 case	DLL_THREAD_ATTACH:
				break;
		 case	DLL_THREAD_DETACH:
				break;
	}
	return TRUE;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Helpers

TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Glow	Class	Description

class GLOWClassDesc:public ClassDesc {
	
	public:

		int				IsPublic ( )					{ return	1; }
		void			*Create (BOOL loading=FALSE)	{ return	new ImageFilter_Glow; }
		const	TCHAR	*ClassName ( )					{ return	GetString(IDS_DB_GLOW);	}
		SClass_ID		SuperClassID ( )				{ return	FLT_CLASS_ID; }
		Class_ID		ClassID	( )						{ return	Class_ID(GLOWCLASSID,0); }
		const	TCHAR	*Category ( )					{ return	GetString(IDS_DB_IMAGE_FILTER); }

};

static GLOWClassDesc GLOWDesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription (	) { 
 	return GetString(IDS_DB_GLOW_FILTER); 
}

DLLEXPORT int	LibNumberClasses ( ) { 
	return 1; 
}

DLLEXPORT ClassDesc	*LibClassDesc(int	i) {
	switch(i) {
		case 0:		return &GLOWDesc;	break;
		default:	return 0;			break;
	}
}

DLLEXPORT ULONG LibVersion (	)	{ 
	return (VERSION_3DSMAX);	
}


//-----------------------------------------------------------------------------
// #> ImageFilter_Glow::ImageFilter_Glow()
//

ImageFilter_Glow::ImageFilter_Glow() {
	data.version = GLOWVERSION;
	data.type = IDC_MTLID_BUTT;
	data.mtl  = 0;
	data.node = 0;
	data.size = 20;	
	data.color.r = 0xFFFF;
	data.color.g = 0xFFFF;
	data.color.b = 0xFFFF;
	data.color.a = 0xFFFF;	
	data.colorsrc = IDC_MTLCOLOR_BUTT;	
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Glow::Description()
//

const TCHAR *ImageFilter_Glow::Description( void ) {
	return GetString(IDS_GG_DESCRIPTION);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Glow::HandleInputs()
//

void ImageFilter_Glow::HandleInputs( HWND hWnd ) {
	HWND hDlg;

	BOOL flag = IsDlgButtonChecked(hWnd,IDC_MTLID_BUTT);

	hDlg = GetDlgItem(hWnd,IDC_MTLID_EDIT);
	EnableWindow(hDlg,flag);
	hDlg = GetDlgItem(hWnd,IDC_MTLID_SPIN);
	EnableWindow(hDlg,flag);

	flag = !flag;

	hDlg = GetDlgItem(hWnd,IDC_NODEID_EDIT);
	EnableWindow(hDlg,flag);
	hDlg = GetDlgItem(hWnd,IDC_NODEID_SPIN);
	EnableWindow(hDlg,flag);
	
	flag = IsDlgButtonChecked(hWnd,IDC_USERCOLOR_BUTT);
	hDlg = GetDlgItem(hWnd,IDC_COLOR_SWATCH);
	EnableWindow(hDlg,flag); 	
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Glow::Control()
//

BOOL ImageFilter_Glow::Control(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)	{

	switch (message) {

		case WM_INITDIALOG:
			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));

			CheckRadioButton(
				hWnd,
				IDC_MTLID_BUTT,
				IDC_NODEID_BUTT,
				data.type
			);
			
			CheckRadioButton(
				hWnd,
				IDC_MTLCOLOR_BUTT,
				IDC_USERCOLOR_BUTT,
				data.colorsrc
			);
						
			colorSwatch = GetIColorSwatch(
				GetDlgItem(hWnd, IDC_COLOR_SWATCH),
				RGB(data.color.r>>8,data.color.g>>8,data.color.b>>8),
				GetString(IDS_DB_GLOW_COLOR));						

			mtlspin	= GetISpinner(GetDlgItem(hWnd, IDC_MTLID_SPIN));
			mtlspin->LinkToEdit( GetDlgItem(hWnd,IDC_MTLID_EDIT), EDITTYPE_INT );
			mtlspin->SetLimits(	0,15, FALSE );
			mtlspin->SetValue(data.mtl,FALSE);

			nodspin	= GetISpinner(GetDlgItem(hWnd, IDC_NODEID_SPIN));
			nodspin->LinkToEdit( GetDlgItem(hWnd,IDC_NODEID_EDIT), EDITTYPE_INT );
			nodspin->SetLimits(	1,65535, FALSE );
			nodspin->SetValue(data.node,FALSE);
			
			sizespin = GetISpinner(GetDlgItem(hWnd, IDC_SIZE_SPIN));
			sizespin->LinkToEdit( GetDlgItem(hWnd,IDC_SIZE_EDIT), EDITTYPE_INT );
			sizespin->SetLimits( 1,100, FALSE );
			sizespin->SetValue(data.size,FALSE);			

			HandleInputs(hWnd);

			return 1;

		case WM_COMMAND:

			switch (LOWORD(wParam)) {

				case IDC_MTLID_BUTT:
				case IDC_NODEID_BUTT:				
				case IDC_MTLCOLOR_BUTT:
				case IDC_USERCOLOR_BUTT:				
					HandleInputs(hWnd);
					break;

				case IDOK:
					data.type= (IsDlgButtonChecked(hWnd,IDC_MTLID_BUTT) ? IDC_MTLID_BUTT : IDC_NODEID_BUTT);
					data.mtl= mtlspin->GetIVal();
					data.node= nodspin->GetIVal();					
					data.size= sizespin->GetIVal();
					data.colorsrc= (IsDlgButtonChecked(hWnd, IDC_MTLCOLOR_BUTT) ? IDC_MTLCOLOR_BUTT : IDC_USERCOLOR_BUTT);					 
					colorref = colorSwatch->GetColor();
					data.color.r = GetRValue(colorref)<<8|0xFF;
					data.color.g = GetGValue(colorref)<<8|0xFF;
					data.color.b = GetBValue(colorref)<<8|0xFF;					
					EndDialog(hWnd,1);
					break;

				case IDCANCEL:
					EndDialog(hWnd,0);
					break;

			}

			return 1;

		case WM_DESTROY:
			  if (mtlspin) {
				  ReleaseISpinner(mtlspin);
				  mtlspin = NULL;
			  }
			  if (nodspin) {
				  ReleaseISpinner(nodspin);
				  nodspin = NULL;
			  }			  
			  if (sizespin) {
				  ReleaseISpinner(sizespin);
				  sizespin = NULL;
			  }

			  if (colorSwatch) {
					ReleaseIColorSwatch(colorSwatch);
					colorSwatch = NULL;
			  }			  
			  break;

	}

	return 0;

}

//-----------------------------------------------------------------------------
// *> ControlDlgProc()
//

BOOL CALLBACK ControlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)	{
     static ImageFilter_Glow *flt = NULL;
     if (message == WM_INITDIALOG) 
        flt = (ImageFilter_Glow *)lParam;
     if (flt) 
        return (flt->Control(hWnd,message,wParam,lParam));
     else
        return(FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Glow::ShowControl()

BOOL ImageFilter_Glow::ShowControl(HWND hWnd) {
	return (DialogBoxParam(
		hInst,
		MAKEINTRESOURCE(IDD_GLOW_CONTROL),
		hWnd,
		(DLGPROC)ControlDlgProc,
		(LPARAM)this));
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)	{
	switch (message) {
		case WM_INITDIALOG:
			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			return 1;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:				  
				case IDCANCEL:
					EndDialog(hWnd,1);
					break;
			}
			return 1;
	}
	return 0;
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Glow::ShowAbout()

void ImageFilter_Glow::ShowAbout(HWND hWnd)	{
	DialogBoxParam(
		hInst,
		MAKEINTRESOURCE(IDD_GLOW_ABOUT),
		hWnd,
		(DLGPROC)AboutCtrlDlgProc,
		(LPARAM)this);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Glow::Render()
//

BOOL ImageFilter_Glow::Render(HWND hWnd) {

	BMM_Color_64	*l64,*line64	= NULL;	
	BOOL			result			= TRUE;
	BOOL			abort			= FALSE;

	BYTE			*mtlbuf			= NULL;
	WORD			*nodbuf			= NULL;
	DWORD			type;
	int				gpix,iy,ix;


	if	(!srcmap)
		return (FALSE);

	//-- Prepare Line Buffers ------------------------------------------------

	if	((line64 = (BMM_Color_64 *)calloc(srcmap->Width(),sizeof(BMM_Color_64)))==NULL)
		goto done;

	if (data.type == IDC_MTLID_BUTT) {
		mtlbuf = (BYTE *)srcmap->GetChannel(BMM_CHAN_MTL_ID,type);
		if (!mtlbuf)
			goto done;
	} else {
		nodbuf = (WORD *)srcmap->GetChannel(BMM_CHAN_NODE_ID,type);
		if (!nodbuf)
			goto done;
	}	

	
	//------------------------------------------------------------------------
	//-- Process -------------------------------------------------------------

	for (iy = 0; iy < srcmap->Height(); iy++) {

		gpix = iy * srcmap->Width();

		//-- Progress Report
		
		SendMessage(hWnd,FLT_PROGRESS,iy,srcmap->Height()-1);

		//-- Check for	Abort
		
		SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL	*)&abort);

		if (abort)
			goto done;
		
		//-- Get	line
		
		l64 = line64;

		if (srcmap->GetLinearPixels(0,iy,srcmap->Width(),line64)!=1)
			goto done;
		
		
		//-- Material ID -------------------------------
		
		if (data.type == IDC_MTLID_BUTT) {
			for ( ix = 0; ix < srcmap->Width();	ix++,l64++)	{
				if (mtlbuf[gpix+ix] == data.mtl) {              		
					GlowPixels(ix, iy, l64);
				}
			}

		//-- Node ID -----------------------------------

		} else {
			for ( ix = 0; ix < srcmap->Width();	ix++,l64++)	{					
				if (nodbuf[gpix+ix] == data.node) {
					GlowPixels(ix, iy, l64);
				}
			}
		}
	}

	result = TRUE;

	done:	
			
	if (line64)
		free(line64);
		
	return(result);

}

//-----------------------------------------------------------------------------
// #> ImageFilter_Glow::GlowPixels()

void ImageFilter_Glow::GlowPixels(int sx, int sy, BMM_Color_64 *curPix) {
	BMM_Color_64 glowColor, g64;
	float glowBrite, fTmp;	
	int glowRad, sy2, sx2, gx, gy;
	int glowRadSqr, curRadSqr;	

	glowRad = data.size;
	glowRadSqr = glowRad * glowRad;					
	if(data.colorsrc == IDC_MTLCOLOR_BUTT)						
		glowColor = *curPix;
	else {
		glowColor = data.color;	
		glowColor.a = curPix->a;
	}
	for(sy2 = -glowRad; sy2 <= glowRad; sy2++) {
		for(sx2 = -glowRad; sx2 <= glowRad; sx2++) {
			curRadSqr = (sy2*sy2) + (sx2*sx2);
			if(curRadSqr > 0 && curRadSqr <= glowRadSqr) {								
				if((gy=sy+sy2) > -1 && gy < srcmap->Height()) {
					if((gx=sx+sx2) > -1 && gx < srcmap->Width()) {
						glowBrite = (float)(glowRadSqr-curRadSqr)/glowRadSqr;											
						fTmp = glowBrite*glowBrite*(3.0f-2.0f*glowBrite);											
						glowBrite = fTmp*fTmp*0.01f;										
						srcmap->GetLinearPixels(gx,gy,1,&g64);
						g64.r = min(g64.r + WORD(glowColor.r*glowBrite),0xFFFF);
						g64.g = min(g64.g + WORD(glowColor.g*glowBrite),0xFFFF);
						g64.b = min(g64.b + WORD(glowColor.b*glowBrite),0xFFFF);												
						g64.a = min(g64.a + WORD(glowColor.a*glowBrite),0xFFFF);										
						srcmap->PutPixels(gx,gy,1,&g64);
					}
				}
			}
		}
	}
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Glow::LoadConfigure()

BOOL ImageFilter_Glow::LoadConfigure ( void *ptr ) {
     GLOWDATA *buf = (GLOWDATA *)ptr;
     if (buf->version == GLOWVERSION) {
        memcpy((void *)&data,ptr,sizeof(GLOWDATA));
        return (TRUE);
     } else
        return (FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Glow::SaveConfigure()

BOOL ImageFilter_Glow::SaveConfigure ( void *ptr ) {
     if (ptr) {
        memcpy(ptr,(void *)&data,sizeof(GLOWDATA));
		return (TRUE);
	} else
        return (FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Glow::EvaluateConfigure()

DWORD ImageFilter_Glow::EvaluateConfigure ( ) {
	return (sizeof(GLOWDATA));
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Glow::ChannelsRequired()

DWORD ImageFilter_Glow::ChannelsRequired ( ) {

	if (data.type == IDC_MTLID_BUTT)
		return(BMM_CHAN_MTL_ID);
	else
		return(BMM_CHAN_NODE_ID);

}

//--	EOF: Glow.cpp --------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Fade\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by fade.rc
//
#define IDS_DB_FADE                     1
#define IDS_DB_IMAGE_FILTER             2
#define IDS_LIBDESCRIPTION              3
#define IDD_FADE_ABOUT                  101
#define IDD_FADE_CONTROL                102
#define IDC_IN                          1001
#define IDC_OUT                         1002
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Glow\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by glow.rc
//
#define IDS_DB_GLOW                     1
#define IDS_DB_IMAGE_FILTER             2
#define IDS_DB_GLOW_FILTER              3
#define IDS_DB_GLOW_COLOR               4
#define IDS_GG_DESCRIPTION              5
#define IDD_GLOW_ABOUT                  101
#define IDD_GLOW_CONTROL                102
#define IDC_MTLID_BUTT                  1001
#define IDC_NODEID_BUTT                 1002
#define IDC_MTLCOLOR_BUTT               1003
#define IDC_USERCOLOR_BUTT              1004
#define IDC_MTLID_EDIT                  1026
#define IDC_NODEID_EDIT                 1027
#define IDC_SIZE_EDIT                   1028
#define IDC_COLOR_SWATCH                1029
#define IDC_MTLID_SPIN                  1046
#define IDC_NODEID_SPIN                 1047
#define IDC_SIZE_SPIN                   1048
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Fade\fade.h ===
//-----------------------------------------------------------------------------
// ---------------------
// File ....: Fade.h
// ---------------------
// Author...: Gus J Grubba
// Date ....: February 1996
// Descr....: Fade Image Filter
//
// History .: Feb, 21 1995 - Started
//            
//-----------------------------------------------------------------------------
        
#ifndef _FADECLASS_
#define _FADECLASS_

#define DLLEXPORT __declspec(dllexport)

//-----------------------------------------------------------------------------
//-- Configuration Block ------------------------------------------------------
//

#define FADEVERSION 100

typedef struct tagFADEDATA {
     DWORD	version;
     int 	type;
} FADEDATA;

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class ImageFilter_Fade : public ImageFilter {
    
		FADEDATA			data;

     public:
     
        //-- Constructors/Destructors
        
                       ImageFilter_Fade( );
                      ~ImageFilter_Fade( ) {}
               
        //-- Filter Info  ---------------------------------

        const TCHAR   *Description         ( ) ;
        const TCHAR   *AuthorName          ( ) { return _T("Gus J Grubba");}
        const TCHAR   *CopyrightMessage    ( ) { return _T("Copyright 1996, Yost Group");}
        UINT           Version             ( ) { return (FADEVERSION);}

        //-- Filter Capabilities --------------------------
        
        DWORD          Capability          ( ) { return(IMGFLT_FILTER	| 
        																IMGFLT_MASK 	| 
        																IMGFLT_CONTROL); }

        //-- Show DLL's About box -------------------------
        
        void           ShowAbout           ( HWND hWnd );  
        BOOL           ShowControl         ( HWND hWnd );  

        //-- Show Time ------------------------------------
        
        BOOL           Render              ( HWND hWnd );

        //-- Filter Configuration -------------------------
        
        BOOL           LoadConfigure			( void *ptr );
        BOOL           SaveConfigure			( void *ptr );
        DWORD          EvaluateConfigure		( );
        
        //-- Local Methods --------------------------------
        
		BOOL				Control					(HWND ,UINT ,WPARAM ,LPARAM );

};

#endif

//-- EOF: Fade.h ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Negative\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by negative.rc
//
#define IDS_DB_NEGATIVE                 1
#define IDS_DB_IMAGE_FILTER             2
#define IDS_BLEND                       3
#define IDS_BLEND_VALUE                 4
#define IDS_LIBDESCRIPTION              5
#define IDD_NEG_ABOUT                   101
#define IDD_NEG_CONTROL                 102
#define IDC_NEG_BLEND_ED                1028
#define IDC_NEG_BLEND_SP                1047
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Negative\negative.h ===
//-----------------------------------------------------------------------------
// ---------------------
// File ....: Negative.h
// ---------------------
// Author...: Gus J Grubba
// Date ....: September 1995
// Descr....: Negative Image Filter
//
// History .: Sep, 07 1995 - Started
//            
//
//
//-----------------------------------------------------------------------------
		 
#ifndef _NEGCLASS_
#define _NEGCLASS_

#define DLLEXPORT __declspec(dllexport)

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class ImageFilter_Negative : public ImageFilter {

#define BLEND_CLASS_ID			Class_ID(0x123,0x456)
#define DEFAULT_BLEND_VALUE 	0.0f;

		Control *blendcontrol;

	  public:
	  
		//-- Constructors/Destructors
		
					   ImageFilter_Negative( ) {}
					  ~ImageFilter_Negative( ) {}
			   
		//-- Filter Info  ----------------------------------

		const TCHAR   	*Description        ( ) ;
		const TCHAR   	*AuthorName         ( ) { return _T("Gus J Grubba");}
		const TCHAR   	*CopyrightMessage   ( ) { return _T("Copyright 1996, Yost Group");}
		UINT           	Version             ( ) { return (200);}

		//-- Filter Capabilities ---------------------------
		
		DWORD          	Capability          ( ) { return( IMGFLT_FILTER | IMGFLT_MASK | IMGFLT_CONTROL ); }

		//-- Show DLL's About box --------------------------
		
		void           	ShowAbout           ( HWND hWnd );  
		BOOL           	ShowControl         ( HWND hWnd );  

		//-- Show Time -------------------------------------
		
		BOOL           	Render              ( HWND hWnd );

		//-- Node Tracking ---------------------------------

		void			FilterUpdate		( );
		
		//-- Local Methods --------------------------------
        
		BOOL  			Control	  			(HWND ,UINT ,WPARAM ,LPARAM );

};

#endif

//-- EOF: Negative.h ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Negative\negative.cpp ===
//-----------------------------------------------------------------------------
// -----------------------
// File ....: Negative.cpp
// -----------------------
// Author...: Gus J Grubba
// Date ....: September 1995
// Descr....: Negative Image Filter
//
// History .: Sep, 07 1995 - Started
//            
//-----------------------------------------------------------------------------
		 
//-- Include files

#include <Max.h>
#include <tvnode.h>
#include <bmmlib.h>
#include <fltlib.h>
#include "Negative.h"
#include "resource.h"

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;
static BOOL controlsInit = FALSE;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
			if (hInst)
				return(FALSE);
			hInst = hDLLInst;
			if ( !controlsInit ) {
				controlsInit = TRUE;
				InitCustomControls(hInst);
			}
			break;
		case DLL_PROCESS_DETACH:
			hInst  = NULL;
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
	}
	return TRUE;
}

//-----------------------------------------------------------------------------
//-- Helper

TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Negative Class Description

class NEGClassDesc:public ClassDesc {
	  
	  public:

		 int             IsPublic     ( )                   { return 1;                }
		 void           *Create       ( BOOL loading=FALSE) { return new ImageFilter_Negative; }
		 const TCHAR    *ClassName    ( )                   { return GetString(IDS_DB_NEGATIVE);     }
		 SClass_ID       SuperClassID ( )                   { return FLT_CLASS_ID;  }
		 Class_ID        ClassID      ( )                   { return Class_ID(NEGATIVECLASSID,0);    }
		 const TCHAR    *Category     ( )                   { return GetString(IDS_DB_IMAGE_FILTER); }

};

static NEGClassDesc NEGDesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
	  return GetString(IDS_LIBDESCRIPTION); 
}

DLLEXPORT int LibNumberClasses ( ) { 
	  return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
	  switch(i) {
		 case  0: return &NEGDesc; break;
		 default: return 0;        break;
	  }
}

DLLEXPORT ULONG LibVersion ( )  { 
	  return ( VERSION_3DSMAX ); 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

const TCHAR *ImageFilter_Negative::Description( ) 
{
	return GetString(IDS_DB_NEGATIVE);
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

	  switch (message) {
		 
		 case WM_INITDIALOG: {
			  CenterWindow(hWnd,GetParent(hWnd));
			  SetCursor(LoadCursor(NULL,IDC_ARROW));
			  return 1;
		 }

		 case WM_COMMAND:

			  switch (LOWORD(wParam)) {
				 
				 case IDOK:              
					  EndDialog(hWnd,1);
					  break;

				 case IDCANCEL:
					  EndDialog(hWnd,0);
					  break;
		 
			  }
			  return 1;

	  }
	  
	  return 0;

}

//-----------------------------------------------------------------------------
// *> ControlCtrlDlgProc()
//

BOOL CALLBACK ControlCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {
	static ImageFilter_Negative *f = NULL;
	if (message == WM_INITDIALOG) 
		f = (ImageFilter_Negative *)lParam;
	if (f) 
		return (f->Control(hWnd,message,wParam,lParam));
	else
		return(FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Negative::ShowControl()

BOOL ImageFilter_Negative::ShowControl(HWND hWnd) {
	return (DialogBoxParam(
		hInst,
		MAKEINTRESOURCE(IDD_NEG_CONTROL),
		hWnd,
		(DLGPROC)ControlCtrlDlgProc,
		(LPARAM)this));
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Negative::Control()

BOOL ImageFilter_Negative::Control(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

	//-- Undo State Flag
	
	static bool hold;
	static bool undo;

	switch (message) {
		
		//------------------------------------------------------------
		//-- Init ----------------------------------------------------

		case WM_INITDIALOG: {
				
				hold = false;	
				undo = false;

				//-- Make Dialogue Interactive
				
				MakeDlgInteractive(hWnd);
				
				//-- Center it

				HWND hWndParent = TheManager->AppWnd();
				CenterWindow(hWnd,hWndParent);
				
				//-- Setup User Interface

				FilterUpdate();
				float blend = DEFAULT_BLEND_VALUE;
				if (Node()) {
					undonotify = new UndoNotify(hWnd);
					if (undonotify)
						Node()->RegisterTVNodeNotify((TVNodeNotify *)undonotify);
					blendcontrol = Node()->GetController(BLEND_CLASS_ID);
					if (blendcontrol) {
						Interval valid = Max()->GetAnimRange();
						blendcontrol->GetValue(Max()->GetTime(),&blend,valid);
					}
				}

				ISpinnerControl	*blendspin = GetISpinner(GetDlgItem(hWnd,IDC_NEG_BLEND_SP));
				if (blendspin) {
					blendspin->LinkToEdit(GetDlgItem(hWnd,IDC_NEG_BLEND_ED),EDITTYPE_FLOAT);
					blendspin->SetLimits(0.0f,100.0f,FALSE);
					blendspin->SetValue(blend,FALSE);
				}

			}
			return 1;

		//------------------------------------------------------------
		//-- Undo ----------------------------------------------------
		//
		//   The filter manager sends this message (if you register
		//   for the notification as in above with RegisterTVNodeNotify())
		//   and an undo operation was performed. Instead of updating the 
		//	 controls here, we just set a flag and wait for a paint message.
				  
		case FLT_UNDO:
			undo = true;
			break;

		//------------------------------------------------------------
		//-- Paint ---------------------------------------------------
				  
		case WM_PAINT:
			if (undo) {
				float blend = DEFAULT_BLEND_VALUE;
				if (Node()) {
					blendcontrol = Node()->GetController(BLEND_CLASS_ID);
					if (blendcontrol) {
						Interval valid = Max()->GetAnimRange();
						blendcontrol->GetValue(Max()->GetTime(),&blend,valid);
					}
				}

				ISpinnerControl	*blendspin = GetISpinner(GetDlgItem(hWnd,IDC_NEG_BLEND_SP));
				if (blendspin) {
					blendspin->SetValue(blend,FALSE);
				}
				undo = false;
			}
			break;

		//------------------------------------------------------------
		//-- Spinners ------------------------------------------------
				  
		case CC_SPINNER_CHANGE:
			if ( LOWORD(wParam) == IDC_NEG_BLEND_SP ) {
				if (!hold) {
					theHold.Begin();
					hold = true;
				}
				ISpinnerControl	*blendspin = GetISpinner(GetDlgItem(hWnd,IDC_NEG_BLEND_SP));
				if (blendspin) {
					float blend = blendspin->GetFVal();
					if (Node()) {
						blendcontrol = Node()->GetController(BLEND_CLASS_ID);
						if (blendcontrol) {
							Interval valid = Max()->GetAnimRange();
							blendcontrol->SetValue(Max()->GetTime(),&blend);
						}
					}
				}
			}
			break;

		case CC_SPINNER_BUTTONDOWN:
			if ( LOWORD(wParam) == IDC_NEG_BLEND_SP ) {
				theHold.Begin();
				hold = true;
			}
			break;

		case CC_SPINNER_BUTTONUP:
			if ( LOWORD(wParam) == IDC_NEG_BLEND_SP ) {
				if (hold) {
					if (!HIWORD(wParam))
						theHold.Cancel();
					else
						theHold.Accept(GetString(IDS_BLEND_VALUE));
					hold = false;
				}
			}
			break;
			
		case WM_CUSTEDIT_ENTER:
			if ((LOWORD(wParam) == IDC_NEG_BLEND_ED) && hold) {
				theHold.Accept(GetString(IDS_BLEND_VALUE));
				hold = false;
			}
			break;

		//------------------------------------------------------------
		//-- Time Change Notification --------------------------------
				  
		case FLT_TIMECHANGED: {
				ISpinnerControl	*blendspin = GetISpinner(GetDlgItem(hWnd,IDC_NEG_BLEND_SP));
				if (blendspin) {
					float blend = DEFAULT_BLEND_VALUE;
					if (Node()) {
						blendcontrol = Node()->GetController(BLEND_CLASS_ID);
						if (blendcontrol) {
							Interval valid = Max()->GetAnimRange();
							blendcontrol->GetValue((TimeValue)lParam,&blend,valid);
							ISpinnerControl	*blendspin = GetISpinner(GetDlgItem(hWnd,IDC_NEG_BLEND_SP));
							if (blendspin) {
								blendspin->SetValue(blend,FALSE);
								blendspin->SetKeyBrackets(blendcontrol->IsKeyAtTime(Max()->GetTime(),0));
							}
						}
					}
				}
			}
			break;

		//------------------------------------------------------------
		//-- Buttons -------------------------------------------------
				  
		case WM_COMMAND:

			switch (LOWORD(wParam)) {
				  
				case IDOK:              
					EndDialog(hWnd,1);
					break;

				case IDCANCEL:
				   	EndDialog(hWnd,0);
				   	break;
		
			}
			return 1;

		//------------------------------------------------------------
		//-- Kaput ---------------------------------------------------
				  
		case WM_DESTROY: {
				ISpinnerControl	*blendspin = GetISpinner(GetDlgItem(hWnd,IDC_NEG_BLEND_SP));
				if (blendspin)
					ReleaseISpinner(blendspin);
				if (Node() && undonotify) {
					Node()->UnRegisterTVNodeNotify((TVNodeNotify *)undonotify);
					delete undonotify;
					undonotify = NULL;
				}
			}
			break;

	}
	
	return 0;

}

//-----------------------------------------------------------------------------
// #> ImageFilter_Negative::FilterUpdate()

void ImageFilter_Negative::FilterUpdate() {
	if (!CreateNode())
		return;
	if (Node()->FindItem(BLEND_CLASS_ID) == -1) {
		float value = DEFAULT_BLEND_VALUE;
		blendcontrol = NewDefaultFloatController();
		if (blendcontrol) {
			blendcontrol->SetValue(0,&value,1);
			Node()->AddController(blendcontrol,GetString(IDS_BLEND),BLEND_CLASS_ID);
		}
	}
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Negative::ShowAbout()

void ImageFilter_Negative::ShowAbout(HWND hWnd) {
	  DialogBoxParam(
		 hInst,
		 MAKEINTRESOURCE(IDD_NEG_ABOUT),
		 hWnd,
		 (DLGPROC)AboutCtrlDlgProc,
		 (LPARAM)this);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Negative::Render()
//
//    Private member Bitmap *srcmap has source bitmap
//    Private member Bitmap *mskmap has mask (if any)

BOOL ImageFilter_Negative::Render(HWND hWnd) {

	BMM_Color_64 *l64,*line64 = NULL;
	WORD         *m16,*mask16 = NULL;
	
	int mwidth,r,g,b,a;

	if (!srcmap)
		return (FALSE);

	if ((line64=(BMM_Color_64 *)calloc(srcmap->Width(),sizeof(BMM_Color_64)))==NULL)
		return (FALSE);

	if (mskmap) {
		mask16 = (WORD *)calloc(srcmap->Width(),sizeof(WORD));
		mwidth = min(srcmap->Width(),mskmap->Width());
	}  

	BOOL result = TRUE;
	BOOL abort  = FALSE;
	  
	//-- Get controler value

	float blend = DEFAULT_BLEND_VALUE;

	if (Node()) {

		Interval valid;
		int tpf = GetTicksPerFrame();
		valid.Set(ifi->FilterRange.First() * tpf, ifi->FilterRange.Last() * tpf);
		TimeValue now = (TimeValue)(ifi->FilterRange.Current() * tpf);
		blendcontrol = Node()->GetController(BLEND_CLASS_ID);
		if (blendcontrol)
			blendcontrol->GetValue(now,&blend,valid);

	}

	blend = 1.0f - (blend / 100.0f);

	//-- Mess up the image

	for (int iy = 0; iy < srcmap->Height(); iy++) {

		//-- Progress Report
		 
		SendMessage(hWnd,FLT_PROGRESS,iy,srcmap->Height()-1);

		//-- Check for Abort
		 
		SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

		if (abort) {
			result = FALSE;
			break;
		}   
		 
		if (blend == 0.0f)
			continue;

		//-- Get line
		 
		l64 = line64;

		if (srcmap->GetLinearPixels(0,iy,srcmap->Width(),line64)!=1) {
			result = FALSE;
			break;
		}

		//-- Handle Mask
		 
		if (mask16) {

			if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
				result = FALSE;
				break;
			}
			
			m16 = mask16;

			for (int ix = 0; ix < srcmap->Width(); ix++,l64++,m16++) {

				r = 65535 - l64->r;
				g = 65535 - l64->g;
				b = 65535 - l64->b;
				a = 65535 - l64->a;

				if (*m16 < 65530) {
					
					if (*m16) {
						r = Lerp(r,(int)l64->r,(int)*m16);
						g = Lerp(g,(int)l64->g,(int)*m16);
						b = Lerp(b,(int)l64->b,(int)*m16);
						a = Lerp(a,(int)l64->a,(int)*m16);
					}
					
					if (blend < 1.0f) {
						/*l64->r = r;
						l64->g = g;
						l64->b = b;
						l64->a = a;
					} else {*/
						l64->r = Lerp(l64->r,r,blend);
						l64->g = Lerp(l64->g,g,blend);
						l64->b = Lerp(l64->b,b,blend);
						l64->a = Lerp(l64->a,a,blend);
					}
					
				}
			}
			
		//-- Unmasked
		 
		} else {
		 
			if (blend < 1.0f) {

				for (int ix = 0; ix < srcmap->Width(); ix++,l64++) {
					r = 65535 - l64->r;
					g = 65535 - l64->g;
					b = 65535 - l64->b;
					a = 65535 - l64->a;
					l64->r = Lerp(l64->r,r,blend);
					l64->g = Lerp(l64->g,g,blend);
					l64->b = Lerp(l64->b,b,blend);
					l64->a = Lerp(l64->a,a,blend);
				}

			} else {

				for (int ix = 0; ix < srcmap->Width(); ix++,l64++) {
					l64->r = 65535 - l64->r;
	            	l64->g = 65535 - l64->g;
	            	l64->b = 65535 - l64->b;
	            	l64->a = 65535 - l64->a;
				}

			}
			
		}

		//-- Output Line
		 
		if (srcmap->PutPixels(0,iy,srcmap->Width(),line64)!=1) {
			result = FALSE;
			break;
		}

	}
	  
	if (mask16)
		free(mask16);
		 
	if (line64)
		free(line64);
		 
	return(result);

}

//-- EOF: negative.cpp --------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\NodeTrak\nodetrak.cpp ===
//-----------------------------------------------------------------------------
// -----------------------
// File ....: NodeTrak.cpp
// -----------------------
// Author...: Gus J Grubba
// Date ....: March 1996
// Descr....: NodeTrak Image Filter
//
// History .: Mar, 5 1995 - Started
//            
//-----------------------------------------------------------------------------
		
//-- Include files

#include <Max.h>
#include <bmmlib.h>
#include <fltlib.h>
#include "NodeTrak.h"
#include "resource.h"

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
	switch (fdwReason) {
		 case DLL_PROCESS_ATTACH:
				if (hInst)
					return(FALSE);
				hInst = hDLLInst;
				break;
		 case DLL_PROCESS_DETACH:
				hInst  = NULL;
				break;
		 case DLL_THREAD_ATTACH:
				break;
		 case DLL_THREAD_DETACH:
				break;
	}
	return TRUE;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// NodeTrak Class Description

class NODETRAKClassDesc:public ClassDesc {
	
	public:

		int             IsPublic     ( )                   { return 1;                }
		void           *Create       ( BOOL loading=FALSE) { return new ImageFilter_NodeTrak; }
		const TCHAR    *ClassName    ( )                   { return GetString(IDS_DB_NODETRAK);     }
		SClass_ID       SuperClassID ( )                   { return FLT_CLASS_ID;  }
		Class_ID        ClassID      ( )                   { return Class_ID(1,0);    }
		const TCHAR    *Category     ( )                   { return GetString(IDS_DB_IMAGE_FILTER); }

};

static NODETRAKClassDesc NODETRAKDesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
	return GetString(IDS_LIBDESCRIPTION); 
}

DLLEXPORT int LibNumberClasses ( ) { 
	return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
	switch(i) {
		case  0: return &NODETRAKDesc; break;
		default: return 0;        break;
	}
}

DLLEXPORT ULONG LibVersion ( )  { 
	return ( VERSION_3DSMAX ); 
}

const TCHAR *ImageFilter_NodeTrak::Description( ) 
{
	return GetString(IDS_DB_NODE_TRACKER);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_NodeTrak::ImageFilter_NodeTrak()
//

ImageFilter_NodeTrak::ImageFilter_NodeTrak()   {
	data.version= NODETRAKVERSION; 
	data.nodename[0] = 0;
}

//-----------------------------------------------------------------------------
// #> NodeDlg::proc()
//

void NodeDlg::proc(INodeTab &nodeTab) {
	if (flt) {
		if (nodeTab.Count())
			flt->SetNodeName(nodeTab[0]->GetName());
	}
}

//-----------------------------------------------------------------------------
// #> ImageFilter_NodeTrak::Control()
//

BOOL ImageFilter_NodeTrak::Control(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)   {

	static NODETRAKDATA tempdata;

	switch (message) {

		case WM_INITDIALOG:

			tempdata = data;
			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));

			if (data.nodename[0])
				SetDlgItemText(hWnd,IDC_NODENAME,data.nodename);
			else
				SetDlgItemText(hWnd,IDC_NODENAME,"Undefined");

			return 1;

		case WM_COMMAND:

			switch (LOWORD(wParam)) {

				case IDC_PICKNODE:
					nodeDlg = new NodeDlg(this);
					if (Max()->DoHitByNameDialog(nodeDlg)) {
						if (data.nodename[0])
							SetDlgItemText(hWnd,IDC_NODENAME,data.nodename);
					}
					break;

				case IDOK:
					EndDialog(hWnd,1);
					break;

				case IDCANCEL:
					data = tempdata;
					EndDialog(hWnd,0);
					break;

			}

			return 1;

		case WM_DESTROY:
			if (nodeDlg) {
				delete nodeDlg;
				nodeDlg = NULL;
			}
			return 1;

	}

	return 0;

}

//-----------------------------------------------------------------------------
// *> ControlDlgProc()
//

BOOL CALLBACK ControlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)   {
	static ImageFilter_NodeTrak *flt = NULL;
	if (message == WM_INITDIALOG) 
		flt = (ImageFilter_NodeTrak *)lParam;
	if (flt) 
		return (flt->Control(hWnd,message,wParam,lParam));
	else
		return(FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_NodeTrak::ShowControl()

BOOL ImageFilter_NodeTrak::ShowControl(HWND hWnd) {
	return (DialogBoxParam(
		hInst,
		MAKEINTRESOURCE(IDD_NODETRAK_CONTROL),
		hWnd,
		(DLGPROC)ControlDlgProc,
		(LPARAM)this));
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

	switch (message) {
		
		case WM_INITDIALOG: {
			  CenterWindow(hWnd,GetParent(hWnd));
			  SetCursor(LoadCursor(NULL,IDC_ARROW));
			  return 1;
		}

		case WM_COMMAND:

			  switch (LOWORD(wParam)) {
				  
				  case IDOK:              
						 EndDialog(hWnd,1);
						 break;

				  case IDCANCEL:
						 EndDialog(hWnd,0);
						 break;
		
			  }
			  return 1;

	}
	
	return 0;

}

//-----------------------------------------------------------------------------
// #> ImageFilter_NodeTrak::ShowAbout()

void ImageFilter_NodeTrak::ShowAbout(HWND hWnd) {
	DialogBoxParam(
		hInst,
		MAKEINTRESOURCE(IDD_NODETRAK_ABOUT),
		hWnd,
		(DLGPROC)AboutCtrlDlgProc,
		(LPARAM)this);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_NodeTrak::Render()
//

BOOL ImageFilter_NodeTrak::Render(HWND hWnd) {

	if (!srcmap)
		return(FALSE);

	//-- Get Render Info from Bitmap

	RenderInfo *ri = srcmap->GetRenderInfo();

	if (!ri)
		return(FALSE);

	//-- Get Inode

	INode *node = Max()->GetINodeByName(data.nodename);

	if (!node)
		return(FALSE);

	//-- Track Node

	Matrix3 m         = node->GetObjTMAfterWSM(ri->renderTime[0]);
	Point3 worldPos   = m.GetRow(3);
	Point3 camPos     = worldPos * ri->worldToCam[0];

	//-- At this point, camPos.z is the Z depth. The camera looks
	//   down in the negative z direction.

	
	
	//-- Now map to screen coordinates

	Point2 screenPos = ri->MapCamToScreen(camPos);

	int x = (int)(screenPos.x+0.5f);
	int y = (int)(screenPos.y+0.5f);

	//-- Place a dot at the location

	BMM_Color_64 white = {0xFFFF,0xFFFF,0xFFFF,0};

	srcmap->PutPixels(x,y,1,&white);

	return(TRUE);

}

//-----------------------------------------------------------------------------
// #> ImageFilter_NodeTrak::LoadConfigure()

BOOL ImageFilter_NodeTrak::LoadConfigure ( void *ptr ) {
	NODETRAKDATA *buf = (NODETRAKDATA *)ptr;
	if (buf->version == NODETRAKVERSION) {
		memcpy((void *)&data,ptr,sizeof(NODETRAKDATA));
		return (TRUE);
	} else
		return (FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_NodeTrak::SaveConfigure()

BOOL ImageFilter_NodeTrak::SaveConfigure ( void *ptr ) {
	if (ptr) {
		memcpy(ptr,(void *)&data,sizeof(NODETRAKDATA));
		return (TRUE);
	} else
		return (FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_NodeTrak::EvaluateConfigure()

DWORD ImageFilter_NodeTrak::EvaluateConfigure ( ) {
	 return (sizeof(NODETRAKDATA));
}

//-- EOF: NodeTrak.cpp ------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\NodeTrak\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nodetrak.rc
//
#define IDS_DB_NODETRAK                 1
#define IDS_DB_IMAGE_FILTER             2
#define IDS_DB_NODE_TRACKER             3
#define IDS_LIBDESCRIPTION              4
#define IDD_NODETRAK_ABOUT              101
#define IDD_NODETRAK_CONTROL            102
#define IDC_IN                          1001
#define IDC_OUT                         1002
#define IDC_NODENAME                    1002
#define IDC_PICKNODE                    1003
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\OldAlpha\alpha.h ===
//-----------------------------------------------------------------------------
// ------------------
// File ....: Alpha.h
// ------------------
// Author...: Gus J Grubba
// Date ....: September 1995
// Descr....: Alpha Compositor
//
// History .: Sep, 27 1995 - Started
//            Apr, 09 1997 - Added G Channel Support (GG)
//            
//-----------------------------------------------------------------------------
        
#ifndef _ALPHACLASS_
#define _ALPHACLASS_

#define DLLEXPORT __declspec(dllexport)

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class ImageFilter_Alpha : public ImageFilter {
    
	public:
     
		//-- Constructors/Destructors
        
                       ImageFilter_Alpha( ) {}
                      ~ImageFilter_Alpha( ) {}
               
       //-- Filter Info  ---------------------------------

       const TCHAR   *Description         ( ) ;
       const TCHAR   *AuthorName          ( ) { return _T("Gus J Grubba");}
       const TCHAR   *CopyrightMessage    ( ) { return _T("Copyright 1995, Yost Group");}
       UINT           Version             ( ) { return (200);}

       //-- Filter Capabilities --------------------------
        
       DWORD          Capability          ( ) { return(IMGFLT_COMPOSITOR | IMGFLT_MASK); }

       //-- Show DLL's About box -------------------------
        
       void           ShowAbout           ( HWND hWnd );  
       BOOL           ShowControl         ( HWND hWnd ) { return (FALSE); }  

       //-- Show Time ------------------------------------
        
       BOOL           Render              ( HWND hWnd );


};

#endif

//-- EOF: Alpha.h ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\NodeTrak\nodetrak.h ===
//-----------------------------------------------------------------------------
// ---------------------
// File ....: NodeTrak.h
// ---------------------
// Author...: Gus J Grubba
// Date ....: February 1996
// Descr....: NodeTrak Image Filter
//
// History .: Feb, 21 1995 - Started
//            
//-----------------------------------------------------------------------------
        
#ifndef _NODETRAKCLASS_
#define _NODETRAKCLASS_

#define DLLEXPORT __declspec(dllexport)

//-----------------------------------------------------------------------------
//-- Configuration Block ------------------------------------------------------
//

#define NODETRAKVERSION 100

typedef struct tagNODETRAKDATA {
     DWORD	version;
     TCHAR	nodename[MAX_PATH];
} NODETRAKDATA;

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

//-- Used with DoHitByNameDialog();

class ImageFilter_NodeTrak;

class NodeDlg : public HitByNameDlgCallback {

		ImageFilter_NodeTrak *flt;

	public:

					NodeDlg(ImageFilter_NodeTrak *f) {flt = f;} 

		TCHAR		*dialogTitle()				{ return _T("Node Tracker"); }
		TCHAR		*buttonText() 				{ return _T("Ok"); }
		BOOL		singleSelect()				{ return TRUE; }
		BOOL		useFilter()					{ return FALSE; }
		BOOL		useProc()					{ return TRUE; }
		void		proc(INodeTab &nodeTab);

};

class ImageFilter_NodeTrak : public ImageFilter {
    
		NODETRAKDATA			data;
		NodeDlg					*nodeDlg;

     public:
     
        //-- Constructors/Destructors
        
                       ImageFilter_NodeTrak( );
                      ~ImageFilter_NodeTrak( ) {}
               
        //-- Filter Info  ---------------------------------

        const TCHAR   *Description         ( ) ;
        const TCHAR   *AuthorName          ( ) { return _T("Gus J Grubba");}
        const TCHAR   *CopyrightMessage    ( ) { return _T("Copyright 1996, Yost Group");}
        UINT           Version             ( ) { return (NODETRAKVERSION);}

        //-- Filter Capabilities --------------------------
        
        DWORD          Capability          ( ) { return(IMGFLT_FILTER	| 
        																IMGFLT_CONTROL); }

        //-- Show DLL's About box -------------------------
        
        void           ShowAbout           ( HWND hWnd );  
        BOOL           ShowControl         ( HWND hWnd );  

        //-- Show Time ------------------------------------
        
        BOOL           Render              ( HWND hWnd );

        //-- Filter Configuration -------------------------
        
        BOOL           LoadConfigure			( void *ptr );
        BOOL           SaveConfigure			( void *ptr );
        DWORD          EvaluateConfigure		( );
        
        //-- Local Methods --------------------------------
        
		BOOL				Control					(HWND ,UINT ,WPARAM ,LPARAM );
		void				SetNodeName				(TCHAR *name) {_tcscpy(data.nodename,name);}

};

#endif

//-- EOF: NodeTrak.h ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\OldAlpha\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by alpha.rc
//
#define IDS_DB_ALPHA                    1
#define IDS_DB_IMAGE_FILTER             2
#define IDS_DB_ALPHA_COMP               3
#define IDS_PROCESS_Z                   4
#define IDS_PROCESS_RGBA                5
#define IDS_PROCESS_MTLID               6
#define IDS_PROCESS_NODEID              7
#define IDS_PROCESS_UV                  8
#define IDS_PROCESS_NORMAL              9
#define IDS_PROCESS_REALPIX             10
#define IDS_LIBDESCRIPTION              11
#define IDD_ALPHA_ABOUT                 101
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\OldAlpha\alpha.cpp ===
//-----------------------------------------------------------------------------
// --------------------
// File ....: Alpha.cpp
// --------------------
// Author...: Gus J Grubba
// Date ....: September 1995
// Descr....: Alpha Compositor
//
// History .: Sep, 27 1995 - Started
//            Apr, 09 1997 - Added G Channel Support (GG)
//            
//-----------------------------------------------------------------------------
        
//-- Include files

#include <Max.h>
#include <bmmlib.h>
#include <fltlib.h>
#include "Alpha.h"
#include "resource.h"

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
     switch (fdwReason) {
         case DLL_PROCESS_ATTACH:
              if (hInst)
                 return(FALSE);
              hInst = hDLLInst;
              break;
         case DLL_PROCESS_DETACH:
              hInst  = NULL;
              break;
         case DLL_THREAD_ATTACH:
              break;
         case DLL_THREAD_DETACH:
              break;
     }
     return TRUE;
}

//-----------------------------------------------------------------------------
// Helper

TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Alpha Class Description

class ALPHAClassDesc:public ClassDesc {
     
     public:

        int             IsPublic     ( )                   { return 1;                }
        void           *Create       ( BOOL loading=FALSE) { return new ImageFilter_Alpha; }
        const TCHAR    *ClassName    ( )                   { return GetString(IDS_DB_ALPHA);     }
        SClass_ID       SuperClassID ( )                   { return FLT_CLASS_ID;  }
        Class_ID        ClassID      ( )                   { return Class_ID(ALPHACLASSID,1);    }
        const TCHAR    *Category     ( )                   { return GetString(IDS_DB_IMAGE_FILTER); }
};

static ALPHAClassDesc ALPHADesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
     return GetString(IDS_LIBDESCRIPTION); 
}

DLLEXPORT int LibNumberClasses ( ) { 
     return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
     switch(i) {
        case  0: return &ALPHADesc; break;
        default: return 0;        break;
     }
}

DLLEXPORT ULONG LibVersion ( )  { 
     return ( VERSION_3DSMAX ); 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

const TCHAR *ImageFilter_Alpha::Description( ) {
	return GetString(IDS_DB_ALPHA_COMP);
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

     switch (message) {
        
        case WM_INITDIALOG: {
             CenterWindow(hWnd,GetParent(hWnd));
             SetCursor(LoadCursor(NULL,IDC_ARROW));
             return 1;
        }

        case WM_COMMAND:

             switch (LOWORD(wParam)) {
                
                case IDOK:              
                     EndDialog(hWnd,1);
                     break;

                case IDCANCEL:
                     EndDialog(hWnd,0);
                     break;
        
             }
             return 1;

     }
     
     return 0;

}

//-----------------------------------------------------------------------------
// #> ImageFilter_Alpha::ShowAbout()

void ImageFilter_Alpha::ShowAbout(HWND hWnd) {
     DialogBoxParam(
        hInst,
        MAKEINTRESOURCE(IDD_ALPHA_ABOUT),
        hWnd,
        (DLGPROC)AboutCtrlDlgProc,
        (LPARAM)this);
}

//-----------------------------------------------------------------------------
// *> fLerp()
//

static _inline float fLerp(float a, float b, int i) {
   float f = i / 65535.0f;
   if (f > 1.0f) f = 1.0f;
   return((1.0f-f)*a + f*b);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Alpha::Render()
//
//    Private member Bitmap *srcmap has source bitmap
//    Private member Bitmap *frgmap has foreground bitmap
//    Private member Bitmap *mskmap has mask (if any)
//

BOOL ImageFilter_Alpha::Render(HWND hWnd) {

	BMM_Color_64 *s64,*src64	= NULL;
	BMM_Color_64 *f64,*fgd64	= NULL;
	WORD         *m16,*mask16	= NULL;

	int mwidth;
     
	if (!srcmap)
		return (FALSE);

	if (!frgmap)
		return (FALSE);

	int width	= srcmap->Width();
	int height	= srcmap->Height();

	//-- Allocate Background Line
     
	if ((src64=(BMM_Color_64 *)calloc(width,sizeof(BMM_Color_64)))==NULL)
		return (FALSE);

	//-- Allocate Foreground Line
     
	if ((fgd64=(BMM_Color_64 *)calloc(width,sizeof(BMM_Color_64)))==NULL)
		return (FALSE);

	//-- Allocate Mask Line
     
	if (mskmap) {
		mask16 = (WORD *)calloc(width,sizeof(WORD));
		mwidth = min(width,mskmap->Width());
	}  

	BOOL result = TRUE;
	BOOL abort  = FALSE;
     
	//----------------------------------------------------------------
	//-- Handle G Channels (if any)

	DWORD src_channels = srcmap->ChannelsPresent();
	DWORD frg_channels = frgmap->ChannelsPresent();

	if (frg_channels || src_channels) {

		//------------------------------------------------------------
		//-- Z Channel
				
		if (frg_channels & BMM_CHAN_Z && !abort && result) {
		
			if (!(src_channels & BMM_CHAN_Z))
				srcmap->CreateChannels(BMM_CHAN_Z);
		
			DWORD type;
			float *sbuffer = (float *)srcmap->GetChannel(BMM_CHAN_Z,type);
			float *fbuffer = (float *)frgmap->GetChannel(BMM_CHAN_Z,type);

			//-- Display what's going on

			SendMessage(hWnd,FLT_TEXTMSG,0,(LPARAM)GetString(IDS_PROCESS_Z));

			for (int iy = 0; iy < height; iy++) {
				
				//-- Progress Report
        
				SendMessage(hWnd,FLT_PROGRESS,iy,height-1);

				//-- Check for Abort
        
				SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

				if (abort) {
					result = FALSE;
					break;
				}   
        
				f64 = fgd64;

				//-- Get Foreground line (RGBA Image)
        
				if (frgmap->GetLinearPixels(0,iy,width,fgd64)!=1) {
					result = FALSE;
					break;
				}

				//-- Handle Mask -------------------------------------
		        
				if (mask16) {
					
					if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
						result = FALSE;
						break;
					}
		           
					m16 = mask16;
					for (int ix = 0; ix < width; ix++,f64++,m16++,sbuffer++,fbuffer++) {
						if (*m16 > 0x7FFF) {
							if (f64->a > 0x7FFF)
								*sbuffer = *fbuffer;
						}
					}

				//-- Unmasked ----------------------------------------
		
				} else {
					for (int ix = 0; ix < width; ix++,f64++,sbuffer++,fbuffer++) {
						if (f64->a > 0x7FFF)
							*sbuffer = *fbuffer;
					}
				}

			}

		}

		//------------------------------------------------------------
		//-- Material Effects Channel

		if (frg_channels & BMM_CHAN_MTL_ID && !abort && result) {
		
			if (!(src_channels & BMM_CHAN_MTL_ID))
				srcmap->CreateChannels(BMM_CHAN_MTL_ID);
		
			DWORD type;
			BYTE *sbuffer = (BYTE *)srcmap->GetChannel(BMM_CHAN_MTL_ID,type);
			BYTE *fbuffer = (BYTE *)frgmap->GetChannel(BMM_CHAN_MTL_ID,type);

			//-- Display what's going on

			SendMessage(hWnd,FLT_TEXTMSG,0,(LPARAM)GetString(IDS_PROCESS_MTLID));

			for (int iy = 0; iy < height; iy++) {
				
				//-- Progress Report
        
				SendMessage(hWnd,FLT_PROGRESS,iy,height-1);

				//-- Check for Abort
        
				SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

				if (abort) {
					result = FALSE;
					break;
				}   
        
				f64 = fgd64;

				//-- Get Foreground line (RGBA Image)
        
				if (frgmap->GetLinearPixels(0,iy,width,fgd64)!=1) {
					result = FALSE;
					break;
				}

				//-- Handle Mask -------------------------------------
		        
				if (mask16) {
					
					if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
						result = FALSE;
						break;
					}
		           
					m16 = mask16;
					for (int ix = 0; ix < width; ix++,f64++,m16++,sbuffer++,fbuffer++) {
						if (*m16 > 0x7FFF) {
							if (f64->a > 0x7FFF)
								*sbuffer = *fbuffer;
						}
					}

				//-- Unmasked ----------------------------------------
		
				} else {
					for (int ix = 0; ix < width; ix++,f64++,sbuffer++,fbuffer++) {
						if (f64->a > 0x7FFF)
							*sbuffer = *fbuffer;
					}
				}

			}

		}

		//------------------------------------------------------------
		//-- Node ID Channel

		if (frg_channels & BMM_CHAN_NODE_ID && !abort && result) {
		
			if (!(src_channels & BMM_CHAN_NODE_ID))
				srcmap->CreateChannels(BMM_CHAN_NODE_ID);
		
			DWORD type;
			WORD *sbuffer = (WORD *)srcmap->GetChannel(BMM_CHAN_NODE_ID,type);
			WORD *fbuffer = (WORD *)frgmap->GetChannel(BMM_CHAN_NODE_ID,type);

			//-- Display what's going on

			SendMessage(hWnd,FLT_TEXTMSG,0,(LPARAM)GetString(IDS_PROCESS_NODEID));

			for (int iy = 0; iy < height; iy++) {
				
				//-- Progress Report
        
				SendMessage(hWnd,FLT_PROGRESS,iy,height-1);

				//-- Check for Abort
        
				SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

				if (abort) {
					result = FALSE;
					break;
				}   
        
				f64 = fgd64;

				//-- Get Foreground line (RGBA Image)
        
				if (frgmap->GetLinearPixels(0,iy,width,fgd64)!=1) {
					result = FALSE;
					break;
				}

				//-- Handle Mask -------------------------------------
		        
				if (mask16) {
					
					if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
						result = FALSE;
						break;
					}
		           
					m16 = mask16;
					for (int ix = 0; ix < width; ix++,f64++,m16++,sbuffer++,fbuffer++) {
						if (*m16 > 0x7FFF) {
							if (f64->a > 0x7FFF)
								*sbuffer = *fbuffer;
						}
					}

				//-- Unmasked ----------------------------------------
		
				} else {
					for (int ix = 0; ix < width; ix++,f64++,sbuffer++,fbuffer++) {
						if (f64->a > 0x7FFF)
							*sbuffer = *fbuffer;
					}
				}

			}

		}

		//------------------------------------------------------------
		//-- UV Coordinates Channel


		if (frg_channels & BMM_CHAN_UV && !abort && result) {
		
			if (!(src_channels & BMM_CHAN_UV))
				srcmap->CreateChannels(BMM_CHAN_UV);
		
			DWORD type;
			Point2 *sbuffer = (Point2 *)srcmap->GetChannel(BMM_CHAN_UV,type);
			Point2 *fbuffer = (Point2 *)frgmap->GetChannel(BMM_CHAN_UV,type);

			//-- Display what's going on

			SendMessage(hWnd,FLT_TEXTMSG,0,(LPARAM)GetString(IDS_PROCESS_UV));

			for (int iy = 0; iy < height; iy++) {
				
				//-- Progress Report
        
				SendMessage(hWnd,FLT_PROGRESS,iy,height-1);

				//-- Check for Abort
        
				SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

				if (abort) {
					result = FALSE;
					break;
				}   
        
				f64 = fgd64;

				//-- Get Foreground line (RGBA Image)
        
				if (frgmap->GetLinearPixels(0,iy,width,fgd64)!=1) {
					result = FALSE;
					break;
				}

				//-- Handle Mask -------------------------------------
		        
				if (mask16) {
					
					if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
						result = FALSE;
						break;
					}
		           
					m16 = mask16;
					for (int ix = 0; ix < width; ix++,f64++,m16++,sbuffer++,fbuffer++) {
						if (*m16 > 0x7FFF) {
							if (f64->a > 0x7FFF)
								*sbuffer = *fbuffer;
						}
					}

				//-- Unmasked ----------------------------------------
		
				} else {
					for (int ix = 0; ix < width; ix++,f64++,sbuffer++,fbuffer++) {
						if (f64->a > 0x7FFF)
							*sbuffer = *fbuffer;
					}
				}

			}

		}

		//------------------------------------------------------------
		//-- Normals Channel

		if (frg_channels & BMM_CHAN_NORMAL && !abort && result) {
		
			if (!(src_channels & BMM_CHAN_NORMAL))
				srcmap->CreateChannels(BMM_CHAN_NORMAL);
		
			DWORD type;
			DWORD *sbuffer = (DWORD *)srcmap->GetChannel(BMM_CHAN_NORMAL,type);
			DWORD *fbuffer = (DWORD *)frgmap->GetChannel(BMM_CHAN_NORMAL,type);

			//-- Display what's going on

			SendMessage(hWnd,FLT_TEXTMSG,0,(LPARAM)GetString(IDS_PROCESS_NORMAL));

			for (int iy = 0; iy < height; iy++) {
				
				//-- Progress Report
        
				SendMessage(hWnd,FLT_PROGRESS,iy,height-1);

				//-- Check for Abort
        
				SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

				if (abort) {
					result = FALSE;
					break;
				}   
        
				f64 = fgd64;

				//-- Get Foreground line (RGBA Image)
        
				if (frgmap->GetLinearPixels(0,iy,width,fgd64)!=1) {
					result = FALSE;
					break;
				}

				//-- Handle Mask -------------------------------------
		        
				if (mask16) {
					
					if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
						result = FALSE;
						break;
					}
		           
					m16 = mask16;
					for (int ix = 0; ix < width; ix++,f64++,m16++,sbuffer++,fbuffer++) {
						if (*m16 > 0x7FFF) {
							if (f64->a > 0x7FFF)
								*sbuffer = *fbuffer;
						}
					}

				//-- Unmasked ----------------------------------------
		
				} else {
					for (int ix = 0; ix < width; ix++,f64++,sbuffer++,fbuffer++) {
						if (f64->a > 0x7FFF)
							*sbuffer = *fbuffer;
					}
				}

			}

		}

		//------------------------------------------------------------
		//-- Real Colors Channel

		if (frg_channels & BMM_CHAN_REALPIX && !abort && result) {
		
			if (!(src_channels & BMM_CHAN_REALPIX))
				srcmap->CreateChannels(BMM_CHAN_REALPIX);
		
			DWORD type;
			RealPixel *sbuffer = (RealPixel *)srcmap->GetChannel(BMM_CHAN_REALPIX,type);
			RealPixel *fbuffer = (RealPixel *)frgmap->GetChannel(BMM_CHAN_REALPIX,type);

			//-- Display what's going on

			SendMessage(hWnd,FLT_TEXTMSG,0,(LPARAM)GetString(IDS_PROCESS_REALPIX));

			for (int iy = 0; iy < height; iy++) {
				
				//-- Progress Report
        
				SendMessage(hWnd,FLT_PROGRESS,iy,height-1);

				//-- Check for Abort
        
				SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

				if (abort) {
					result = FALSE;
					break;
				}   
        
				f64 = fgd64;

				//-- Get Foreground line (RGBA Image)
        
				if (frgmap->GetLinearPixels(0,iy,width,fgd64)!=1) {
					result = FALSE;
					break;
				}

				//-- Handle Mask -------------------------------------
		        
				if (mask16) {
					
					if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
						result = FALSE;
						break;
					}
		           
					m16 = mask16;
					for (int ix = 0; ix < width; ix++,f64++,m16++,sbuffer++,fbuffer++) {
						float sr,sg,sb;
						float fr,fg,fb;
						float tr,tg,tb;
						ExpandRealPixel(*sbuffer,sr,sg,sb);
						ExpandRealPixel(*fbuffer,fr,fg,fb);
						tr = fLerp(sr, fr, f64->a);
						tg = fLerp(sg, fg, f64->a);
						tb = fLerp(sb, fb, f64->a);
						if (*m16 < 65530) {
							if (*m16) {
								sr = fLerp(tr,sr,*m16);
								sg = fLerp(tg,sg,*m16);
								sb = fLerp(tb,sb,*m16);
							} else {
								sr = tr;
								sg = tg;
								sb = tb;
							}
						}
						*sbuffer = MakeRealPixel(sr,sg,sb);
					}

				//-- Unmasked ----------------------------------------
		
				} else {
					for (int ix = 0; ix < width; ix++,f64++,sbuffer++,fbuffer++) {
						float sr,sg,sb;
						float fr,fg,fb;
						ExpandRealPixel(*sbuffer,sr,sg,sb);
						ExpandRealPixel(*fbuffer,fr,fg,fb);
						sr = fLerp(sr, fr, f64->a);
						sg = fLerp(sg, fg, f64->a);
						sb = fLerp(sb, fb, f64->a);
						*sbuffer = MakeRealPixel(sr,sg,sb);
					}
				}

			}

		}

	}

	//----------------------------------------------------------------
	//-- Handle RGBA Image

	if (!abort && result) {

		//-- Display what's going on

		SendMessage(hWnd,FLT_TEXTMSG,0,(LPARAM)GetString(IDS_PROCESS_RGBA));

		for (int iy = 0; iy < height; iy++) {

			//-- Progress Report
	        
			SendMessage(hWnd,FLT_PROGRESS,iy,height-1);

			//-- Check for Abort
	        
			SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

			if (abort) {
				result = FALSE;
				break;
			}   
	        
			s64 = src64;
			f64 = fgd64;

			//-- Get Source line
	        
			if (srcmap->GetLinearPixels(0,iy,width,src64)!=1) {
				result = FALSE;
				break;
			}

			//-- Get Foreground line
	        
			if (frgmap->GetLinearPixels(0,iy,width,fgd64)!=1) {
				result = FALSE;
				break;
			}

			//-- Handle Mask ----------------------------------
	        
			if (mask16) {
				
				int r,g,b,a;
	           
				if (mskmap->Get16Gray(0,iy,mwidth,mask16)!=1) {
					result = FALSE;
					break;
				}
	           
				m16 = mask16;
				for (int ix = 0; ix < width; ix++,s64++,f64++,m16++) {
	              
					r = Lerp(s64->r, f64->r, f64->a);
					g = Lerp(s64->g, f64->g, f64->a);
					b = Lerp(s64->b, f64->b, f64->a);
					a = max(s64->a,f64->a);

					if (*m16 < 65530) {
						if (*m16) {
							s64->r = Lerp(r,s64->r,*m16);
							s64->g = Lerp(g,s64->g,*m16);
							s64->b = Lerp(b,s64->b,*m16);
							s64->a = Lerp(a,s64->a,*m16);
						} else {
							s64->r = r;
							s64->g = g;
							s64->b = b;
							s64->a = a;
						}
					}
	           
				}
	           
			//-- Unmasked -------------------------------------
	        
			} else {
	        
				for (int ix = 0; ix < width; ix++,f64++,s64++) {
				
					s64->r = Lerp(s64->r, f64->r, f64->a);
					s64->g = Lerp(s64->g, f64->g, f64->a);
					s64->b = Lerp(s64->b, f64->b, f64->a);
					s64->a = max(s64->a,f64->a);

				}

	        }

	        //-- Output Line
	        
	        if (srcmap->PutPixels(0,iy,width,src64)!=1) {
	           result = FALSE;
	           break;
	        }

		}

	}
     
	if (mask16)
		free(mask16);
        
	if (src64)
		free(src64);
        
	if (fgd64)
		free(fgd64);
        
	return(result);

}

//-- EOF: Alpha.cpp --------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\pdalpha\pdalpha.h ===
//-----------------------------------------------------------------------------
// ---------------------
// File ....: PdAlpha.h
// ---------------------
// Author...: Gus J Grubba
// Date ....: February 1996
// Descr....: PdAlpha Image Filter
//
// History .: Feb, 21 1995 - Started
//            
//-----------------------------------------------------------------------------
        
#ifndef _PDALPHACLASS_
#define _PDALPHACLASS_

#define DLLEXPORT __declspec(dllexport)

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class ImageFilter_PdAlpha : public ImageFilter {
    
     public:
     
        //-- Constructors/Destructors
        
                       ImageFilter_PdAlpha( ) {}
                      ~ImageFilter_PdAlpha( ) {}
               
        //-- Filter Info  ---------------------------------

        const TCHAR   *Description         ( ) ;
        const TCHAR   *AuthorName          ( ) { return _T("Gus J Grubba");}
        const TCHAR   *CopyrightMessage    ( ) { return _T("Copyright 1996, Yost Group");}
        UINT           Version             ( ) { return (100);}

        //-- Filter Capabilities --------------------------
        
        DWORD          Capability          ( ) { return(IMGFLT_FILTER | IMGFLT_COMPOSITOR);}

        //-- Show DLL's About box -------------------------
        
        void           ShowAbout           ( HWND hWnd );  

        //-- Show Time ------------------------------------
        
        BOOL           Render              ( HWND hWnd );

};

#endif

//-- EOF: PdAlpha.h ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\pdalpha\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pdalpha.rc
//
#define IDS_DB_PDALPHA                  1
#define IDS_DB_IMAGE_FILTER             2
#define IDS_DB_PSEUDO_ALPHA             3
#define IDS_LIBDESCRIPTION              4
#define IDD_PDALPHA_ABOUT               101
#define IDD_PDALPHA_CONTROL             102
#define IDC_IN                          1001
#define IDC_OUT                         1002
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Stars\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by stars.rc
//
#define IDS_STARS                       1
#define IDS_IMAGE_FILTER                2
#define IDS_STARS_FILTER                3
#define IDS_NOT_PERSPECTIVE             4
#define IDS_NO_RENDERINFO               5
#define IDS_CANT_OPEN                   6
#define IDS_BAD_FILE                    7
#define IDS_STARFIELD_ERROR             8
#define IDS_CAMERA_NOT_FOUND            9
#define IDS_OUT_OF_MEMORY               10
#define IDS_STARFIELD                   11
#define IDD_STARS_ABOUT                 101
#define IDD_STARS_CONTROL               102
#define IDC_RANDOM                      1006
#define IDC_CUSTOM                      1007
#define IDC_CUST_FILENAME               1008
#define IDC_USEBLUR                     1009
#define IDC_LINEAR                      1010
#define IDC_LOG                         1011
#define IDC_BACK                        1013
#define IDC_FORE                        1014
#define IDC_CAMERAS                     1015
#define IDC_AMOUNT_EDIT                 1028
#define IDC_COUNT_EDIT                  1029
#define IDC_DIM_EDIT                    1030
#define IDC_BRITE_EDIT                  1031
#define IDC_SEED_EDIT4                  1032
#define IDC_SIZE_EDIT                   1032
#define IDC_SEED_EDIT5                  1033
#define IDC_DIMMING_EDIT                1033
#define IDC_SEED_EDIT                   1034
#define IDC_AMOUNT_SPIN                 1048
#define IDC_COUNT_SPIN                  1049
#define IDC_DIM_SPIN                    1050
#define IDC_BRITE_SPIN                  1051
#define IDC_SEED_SPIN4                  1052
#define IDC_SIZE_SPIN                   1052
#define IDC_SEED_SPIN5                  1053
#define IDC_DIMMING_SPIN                1053
#define IDC_COUNT_SPIN2                 1054
#define IDC_SEED_SPIN                   1054
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\pdalpha\pdalpha.cpp ===
//-----------------------------------------------------------------------------
// ----------------------
// File ....: PdAlpha.cpp
// ----------------------
// Author...: Gus J Grubba
// Date ....: February 1996
// Descr....: Pseudo Alpha Image Filter
//
// History .: Feb, 23 1995 - Started
//            
//-----------------------------------------------------------------------------
        
//-- Include files

#include <Max.h>
#include <bmmlib.h>
#include <fltlib.h>
#include "PdAlpha.h"
#include "resource.h"

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
     switch (fdwReason) {
         case DLL_PROCESS_ATTACH:
              if (hInst)
                 return(FALSE);
              hInst = hDLLInst;
              break;
         case DLL_PROCESS_DETACH:
              hInst  = NULL;
              break;
         case DLL_THREAD_ATTACH:
              break;
         case DLL_THREAD_DETACH:
              break;
     }
     return TRUE;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// PdAlpha Class Description

class PDALPHAClassDesc:public ClassDesc {
     
     public:

        int             IsPublic     ( )                   { return 1;                }
        void           *Create       ( BOOL loading=FALSE) { return new ImageFilter_PdAlpha; }
        const TCHAR    *ClassName    ( )                   { return GetString(IDS_DB_PDALPHA);     }
        SClass_ID       SuperClassID ( )                   { return FLT_CLASS_ID;  }
        Class_ID        ClassID      ( )                   { return Class_ID(PDALPHACLASSID,0);    }
        const TCHAR    *Category     ( )                   { return GetString(IDS_DB_IMAGE_FILTER); }

};

static PDALPHAClassDesc PDALPHADesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
     return GetString(IDS_LIBDESCRIPTION); 
}

DLLEXPORT int LibNumberClasses ( ) { 
     return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
     switch(i) {
        case  0: return &PDALPHADesc; break;
        default: return 0;        break;
     }
}

DLLEXPORT ULONG LibVersion ( )  { 
     return ( VERSION_3DSMAX ); 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

const TCHAR *ImageFilter_PdAlpha::Description( ) 
{
	return GetString(IDS_DB_PSEUDO_ALPHA);
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

     switch (message) {
        
        case WM_INITDIALOG: {
             CenterWindow(hWnd,GetParent(hWnd));
             SetCursor(LoadCursor(NULL,IDC_ARROW));
             return 1;
        }

        case WM_COMMAND:

             switch (LOWORD(wParam)) {
                
                case IDOK:              
                     EndDialog(hWnd,1);
                     break;

                case IDCANCEL:
                     EndDialog(hWnd,0);
                     break;
        
             }
             return 1;

     }
     
     return 0;

}

//-----------------------------------------------------------------------------
// #> ImageFilter_PdAlpha::ShowAbout()

void ImageFilter_PdAlpha::ShowAbout(HWND hWnd) {
     DialogBoxParam(
        hInst,
        MAKEINTRESOURCE(IDD_PDALPHA_ABOUT),
        hWnd,
        (DLGPROC)AboutCtrlDlgProc,
        (LPARAM)this);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_PdAlpha::Render()
//

BOOL ImageFilter_PdAlpha::Render(HWND hWnd) {

     BMM_Color_64 pixel;
     BMM_Color_64 *l64,*line64 = NULL;
     BMM_Color_64 *f64,*fgnd64 = NULL;

     BOOL result = TRUE;
     BOOL abort  = FALSE;
     
	  int iy,ix;

     if (!srcmap)
        goto done;

	//-- Allocate Line Buffers -------------------------------------

     if ((line64=(BMM_Color_64 *)calloc(srcmap->Width(),sizeof(BMM_Color_64)))==NULL)
        goto done;

     if (frgmap) {
     	if ((fgnd64=(BMM_Color_64 *)calloc(srcmap->Width(),sizeof(BMM_Color_64)))==NULL)
        	goto done;
	}

	//-- Get Key ---------------------------------------------------

	if (!frgmap) {
		if (srcmap->GetLinearPixels(0,0,1,&pixel)!=1)
			goto done;
	} else {
		if (frgmap->GetLinearPixels(0,0,1,&pixel)!=1)
			goto done;
	}

	//-- Process ---------------------------------------------------

     for (iy = 0; iy < srcmap->Height(); iy++) {

        //-- Progress Report
        
        SendMessage(hWnd,FLT_PROGRESS,iy,srcmap->Height()-1);

        //-- Check for Abort
        
        SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

        if (abort)
			goto done;
        
        //-- Get line
        
        l64 = line64;

        if (srcmap->GetLinearPixels(0,iy,srcmap->Width(),line64)!=1)
			goto done;

		//-- Working as a filter ------------------------------------

		if (!frgmap) {

        	for (ix = 0; ix < srcmap->Width(); ix++,l64++) {
        	   if (l64->r == pixel.r && l64->g == pixel.g && l64->b == pixel.b)
        	   	l64->a = 0;
				else
        	   	l64->a = 0xFFFF;
        	}

		//-- Working as a layer -------------------------------------

		} else {
		
        	f64 = fgnd64;

			if (frgmap->GetLinearPixels(0,iy,srcmap->Width(),fgnd64)!=1)
				goto done;

        	for (ix = 0; ix < srcmap->Width(); ix++,l64++,f64++) {
        	   if (f64->r != pixel.r && f64->g != pixel.g && f64->b != pixel.b)
        	   	*l64 = *f64;
        	}

		}
           
        //-- Output Line
        
        if (srcmap->PutPixels(0,iy,srcmap->Width(),line64)!=1)
			goto done;

     }

	result = TRUE;
     
	done:

	if (line64)
		free(line64);
        
	if (fgnd64)
		free(fgnd64);
		
     return(result);

}

//-- EOF: PdAlpha.cpp ------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Stars\stars.cpp ===
//-----------------------------------------------------------------------------
// -------------------
// File	....:	stars.cpp
// -------------------
// Author...:	Tom Hudson
// Date	....:	April 1996
// Descr....:	Stars Image Filter
//
// History	.:	April 25 1996 -	Started
//				
//-----------------------------------------------------------------------------
		
//--	Include files

#include <Max.h>
#include <bmmlib.h>
#include <fltlib.h>
#include <maxapi.h>
#include "resource.h"
#include "stars.h"
#include "pixelbuf.h"

//--	Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

static ISpinnerControl	*dimspin = NULL;
static ISpinnerControl	*britespin = NULL;
static ISpinnerControl	*sizespin = NULL;
static ISpinnerControl	*amtspin = NULL;
static ISpinnerControl	*dimmingspin = NULL;
static ISpinnerControl	*seedspin = NULL;
static ISpinnerControl	*countspin = NULL;

//--    Handy Stuff --------------------------------------------------------------

#define MAXIV 0xff00	// 255 * 256
static BMM_Color_48 white = {MAXIV,MAXIV,MAXIV};

#define MAX(a,b) ((a>b) ? a:b)

/* Some trig defines */

#define PI_45 0.7853981f		/* Some angles in radians */
#define PI_90 1.5707963f
#define PI_135 2.3561945f
#define PI_180 3.1415927f
#define PI_225 3.9269908f
#define PI_270 4.712389f
#define PI_315 5.4977871f
#define PI_360 6.2831853f

#define RAD_DEG 57.29578f	/* Radians -> degrees conversion */

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//--	DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)	{
	switch (fdwReason) {
		 case	DLL_PROCESS_ATTACH:
				if (hInst)
					return(FALSE);
				hInst = hDLLInst;
				break;
		 case	DLL_PROCESS_DETACH:
				hInst =	NULL;
				break;
		 case	DLL_THREAD_ATTACH:
				break;
		 case	DLL_THREAD_DETACH:
				break;
	}
	return TRUE;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Stars	Class	Description

class STARSClassDesc:public ClassDesc {
	
	public:

		int				IsPublic ( )					{ return	1; }
		void			*Create (BOOL loading=FALSE)	{ return	new ImageFilter_Stars; }
		const	TCHAR	*ClassName ( )					{ return	GetString(IDS_STARS);	}
		SClass_ID		SuperClassID ( )				{ return	FLT_CLASS_ID; }
		Class_ID		ClassID	( )						{ return	STARS_CLASS_ID; }
		const	TCHAR	*Category ( )					{ return	GetString(IDS_IMAGE_FILTER); }

};

static STARSClassDesc STARSDesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription (	) { 
 	return GetString(IDS_STARS_FILTER); 
}

DLLEXPORT int	LibNumberClasses ( ) { 
	return 1; 
}

DLLEXPORT ClassDesc	*LibClassDesc(int	i) {
	switch(i) {
		case 0:		return &STARSDesc;	break;
		default:	return 0;			break;
	}
}

DLLEXPORT ULONG LibVersion (	)	{ 
	return (VERSION_3DSMAX);	
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Stars::ImageFilter_Stars()
//

ImageFilter_Stars::ImageFilter_Stars() {
	data.version = STARSVERSION;
	data.camera[0] = 0;
	data.dimmest = 0;
	data.brightest = 255;
	data.briteType = BRITE_LINEAR;
	data.size = 1.5f;
	data.useBlur = TRUE;
	data.blurAmount = 75;
	data.blurDim = 40;
	data.dataType = DATA_RANDOM;
	data.seed = 12345;
	data.count = 15000;
	strcpy(data.filename,"earth.stb");
	data.compositing = COMP_BACK;
	stardata = NULL;
	pos1 = pos2 = NULL;
	}

void ImageFilter_Stars::FreeData() {
	if(stardata) {
		delete [] stardata;
		stardata = NULL;
		}
	if(pos1) {
		delete [] pos1;
		pos1 = NULL;
		}
	if(pos2) {
		delete [] pos2;
		pos2 = NULL;
		}
	}

void ImageFilter_Stars::EnableStarControls(HWND hWnd) {
	BOOL random = (data.dataType == DATA_RANDOM) ? TRUE : FALSE;
	if(random) {
		seedspin->Enable();
		countspin->Enable();
		EnableWindow(GetDlgItem(hWnd,IDC_CUST_FILENAME), FALSE);
		}
	else {
		seedspin->Disable();
		countspin->Disable();
		EnableWindow(GetDlgItem(hWnd,IDC_CUST_FILENAME), TRUE);
		}
	}

//-----------------------------------------------------------------------------
// #> ImageFilter_Stars::Control()
//

BOOL ImageFilter_Stars::Control(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)	{

	switch (message) {

		case WM_INITDIALOG:	{
			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));

			// Get the cameras in the scene and load 'em into the listbox
			LoadCameras(hWnd);
						
			CheckRadioButton(
				hWnd,
				IDC_LINEAR,
				IDC_LOG,
				data.briteType == BRITE_LINEAR ? IDC_LINEAR : IDC_LOG
			);
			
			CheckRadioButton(
				hWnd,
				IDC_RANDOM,
				IDC_CUSTOM,
				data.dataType == DATA_RANDOM ? IDC_RANDOM : IDC_CUSTOM
			);

			CheckDlgButton(hWnd, IDC_USEBLUR, data.useBlur);
			
			dimspin	= GetISpinner(GetDlgItem(hWnd, IDC_DIM_SPIN));
			dimspin->LinkToEdit( GetDlgItem(hWnd,IDC_DIM_EDIT), EDITTYPE_INT );
			dimspin->SetLimits(	0,255, FALSE );
			dimspin->SetValue(data.dimmest,FALSE);

			britespin	= GetISpinner(GetDlgItem(hWnd, IDC_BRITE_SPIN));
			britespin->LinkToEdit( GetDlgItem(hWnd,IDC_BRITE_EDIT), EDITTYPE_INT );
			britespin->SetLimits(	0,255, FALSE );
			britespin->SetValue(data.brightest,FALSE);

			sizespin	= GetISpinner(GetDlgItem(hWnd, IDC_SIZE_SPIN));
			sizespin->LinkToEdit( GetDlgItem(hWnd,IDC_SIZE_EDIT), EDITTYPE_FLOAT );
			sizespin->SetLimits(	0.001f, 100.0f, FALSE );
			sizespin->SetValue(data.size,FALSE);

			amtspin	= GetISpinner(GetDlgItem(hWnd, IDC_AMOUNT_SPIN));
			amtspin->LinkToEdit( GetDlgItem(hWnd,IDC_AMOUNT_EDIT), EDITTYPE_INT );
			amtspin->SetLimits(	0,100, FALSE );
			amtspin->SetValue(data.blurAmount,FALSE);
			
			dimmingspin	= GetISpinner(GetDlgItem(hWnd, IDC_DIMMING_SPIN));
			dimmingspin->LinkToEdit( GetDlgItem(hWnd,IDC_DIMMING_EDIT), EDITTYPE_INT );
			dimmingspin->SetLimits(	0,100, FALSE );
			dimmingspin->SetValue(data.blurDim,FALSE);

			seedspin	= GetISpinner(GetDlgItem(hWnd, IDC_SEED_SPIN));
			seedspin->LinkToEdit( GetDlgItem(hWnd,IDC_SEED_EDIT), EDITTYPE_INT );
			seedspin->SetLimits(0, 99999, FALSE );
			seedspin->SetValue(data.seed, FALSE);

			countspin	= GetISpinner(GetDlgItem(hWnd, IDC_COUNT_SPIN));
			countspin->LinkToEdit( GetDlgItem(hWnd,IDC_COUNT_EDIT), EDITTYPE_INT );
			countspin->SetLimits(1, 1000000, FALSE );
			countspin->SetValue(data.count,FALSE);

			SetDlgItemText(hWnd, IDC_CUST_FILENAME, data.filename);

			EnableStarControls(hWnd);

			CheckRadioButton(
				hWnd,
				IDC_BACK,
				IDC_FORE,
				data.compositing == COMP_BACK ? IDC_BACK : IDC_FORE
				);
			}
			return 1;

		case WM_COMMAND:

			switch (LOWORD(wParam)) {

				case IDC_CAMERAS: {
					switch(HIWORD(wParam)) {
						case CBN_SELCHANGE: {
							int selection = SendDlgItemMessage(hWnd, IDC_CAMERAS, CB_GETCURSEL, 0, 0);
							if(selection != CB_ERR) {
								SendDlgItemMessage(hWnd, IDC_CAMERAS, CB_GETLBTEXT, selection, (LPARAM)data.camera);
								}
							}
							break;
						}
					}
					break;

				case IDC_RANDOM:
				case IDC_CUSTOM:
					data.dataType = IsDlgButtonChecked(hWnd,IDC_RANDOM) ? DATA_RANDOM : DATA_CUSTOM;
					EnableStarControls(hWnd);
					break;
					
				case IDOK: {
					data.dimmest = dimspin->GetIVal();
					data.brightest = britespin->GetIVal();
					data.briteType = IsDlgButtonChecked(hWnd,IDC_LINEAR) ? BRITE_LINEAR : BRITE_LOG;
					data.size = sizespin->GetFVal();
					data.useBlur = IsDlgButtonChecked(hWnd,IDC_USEBLUR) ? TRUE : FALSE;
					data.blurAmount = amtspin->GetIVal();
					data.blurDim = dimmingspin->GetIVal();
					data.dataType = IsDlgButtonChecked(hWnd,IDC_RANDOM) ? DATA_RANDOM : DATA_CUSTOM;
					data.seed= seedspin->GetIVal();					
					data.count= countspin->GetIVal();
					GetDlgItemText(hWnd, IDC_CUST_FILENAME, data.filename, 255);
					data.compositing = IsDlgButtonChecked(hWnd,IDC_BACK) ? COMP_BACK : COMP_FORE;
					int selection = SendDlgItemMessage(hWnd, IDC_CAMERAS, CB_GETCURSEL, 0, 0);
					if(selection != CB_ERR) {
						SendDlgItemMessage(hWnd, IDC_CAMERAS, CB_GETLBTEXT, selection, (LPARAM)data.camera);
						}
					data.compositing = IsDlgButtonChecked(hWnd,IDC_BACK) ? COMP_BACK : COMP_FORE;
					EndDialog(hWnd,1);
					}
					break;

				case IDCANCEL:
					EndDialog(hWnd,0);
					break;

			}

			return 1;

		case WM_DESTROY:
			  if (dimspin) {
				  ReleaseISpinner(dimspin);
				  dimspin = NULL;
			  }
			  if (britespin) {
				  ReleaseISpinner(britespin);
				  britespin = NULL;
			  }
			  if (sizespin) {
				  ReleaseISpinner(sizespin);
				  sizespin = NULL;
			  }
			  if (amtspin) {
				  ReleaseISpinner(amtspin);
				  amtspin = NULL;
			  }
			  if (dimmingspin) {
				  ReleaseISpinner(dimmingspin);
				  dimmingspin = NULL;
			  }
			  if (seedspin) {
				  ReleaseISpinner(seedspin);
				  seedspin = NULL;
			  }
			  if (countspin) {
				  ReleaseISpinner(countspin);
				  countspin = NULL;
			  }
			  break;

	}

	return 0;

}

//-----------------------------------------------------------------------------
// *> ControlDlgProc()
//

BOOL CALLBACK ControlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)	{
     static ImageFilter_Stars *flt = NULL;
     if (message == WM_INITDIALOG) 
        flt = (ImageFilter_Stars *)lParam;
     if (flt) 
        return (flt->Control(hWnd,message,wParam,lParam));
     else
        return(FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Stars::ShowControl()

BOOL ImageFilter_Stars::ShowControl(HWND hWnd) {
	InitCustomControls(hInst);
     return (DialogBoxParam(
        hInst,
        MAKEINTRESOURCE(IDD_STARS_CONTROL),
        hWnd,
        (DLGPROC)ControlDlgProc,
        (LPARAM)this));
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)	{
	switch (message) {
		case WM_INITDIALOG:
			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			return 1;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:				  
				case IDCANCEL:
					EndDialog(hWnd,1);
					break;
			}
			return 1;
	}
	return 0;
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Stars::ShowAbout()

void ImageFilter_Stars::ShowAbout(HWND hWnd)	{
	DialogBoxParam(
		hInst,
		MAKEINTRESOURCE(IDD_STARS_ABOUT),
		hWnd,
		(DLGPROC)AboutCtrlDlgProc,
		(LPARAM)this);
}

static void
RemoveScaling(Matrix3 &m) {
	for (int i=0; i<3; i++)
		m.SetRow(i,Normalize(m.GetRow(i)));
	}

void ImageFilter_Stars::ComputeCamera(INode *node, TimeValue t, CameraInfo *ci) {
	const ObjectState& os = node->EvalWorldState(t);
	
	// compute camera transform
	CameraState cs;
	Interval iv;
	CameraObject *cam = (CameraObject *)os.obj;
	iv.SetInfinite();
	Matrix3 camtm = node->GetObjTMAfterWSM(t,&iv);
	RemoveScaling(camtm);
	camtm.NoTrans();		// Make sure it's centered about the camera!
	ci->tm = Inverse(camtm);
	cam->EvalCameraState(t,iv,&cs);
	ci->fov = cs.fov;  
	}

/* Plot the pixel in the specified color at v luminosity (0-255) */

void ImageFilter_Stars::Plot(int x, int y, int v, BMM_Color_48 *c) {
	UINT r,g,b;
	BMM_Color_64 mappix;

	if((field_type==EVEN_LINES && (y&1)) || (field_type==ODD_LINES && ((y&1)==0)))
	 return;

	if(x<=0 || y<=0 || x>=srcmap->Width() || y>=srcmap->Height())
	 return;

	if (srcmap->GetLinearPixels(x,y,1,&mappix)!=1) {
		assert(0);
		return;
		}

	unsigned int pr,pg,pb;

	if(data.compositing == COMP_BACK && mappix.a != 0) {
		UINT a = mappix.a >> 8;
		// If totally opaque, forget it!
		if(a == 255)
			return;
		UINT ia = 255 - a;
		pr = (UINT)c->r * v * ia / 65025;
		pg = (UINT)c->g * v * ia / 65025;
		pb = (UINT)c->b * v * ia / 65025;
		}
	else {
		pr = (UINT)c->r * v / 255;
		pg = (UINT)c->g * v / 255;
		pb = (UINT)c->b * v / 255;
		}
	r=(UINT)mappix.r+pr;
	g=(UINT)mappix.g+pg;
	b=(UINT)mappix.b+pb;
	mappix.r=(WORD)((r>MAXIV) ? MAXIV:r);
	mappix.g=(WORD)((g>MAXIV) ? MAXIV:g);
	mappix.b=(WORD)((b>MAXIV) ? MAXIV:b);

    srcmap->PutPixels(x,y,1,&mappix);
	}


/*------------------------------------------------------------
Dan's Handy-Dandy Floating-Point Rectancle Plotter (DHDFPRP) (TM)...
	
	Render an anti-aliased floating point rectangle on pixel grid.
	x,y,w,h are floating point screen coords. 

	Tom's modified version: x&y are center of rectangle

	This could be sped up using fixed point.

-------------------------------------------------------------*/

#define frac(z) fmod(z,1.0f)
#define whole(z) (z-fmod(z,1.0f))

void ImageFilter_Stars::FRect(float x, float y, float w, float h,int brite) {
	int xa,xb,ya,yb,i,j;
	float x2,y2,lfrac,rfrac,tfrac,bfrac,xfrac,yfrac;
	x -= (w/2.0f);
	y -= (h/2.0f);
	x2 = x + w;
	y2 = y + h;
  	xa = (int)x;
	xb = (int)x2;
  	ya = (int)y;
	yb = (int)y2;
	lfrac = (float)(1.0-frac(x));	
	rfrac = (float)frac(x2);
	tfrac = (float)(1.0-frac(y));
	bfrac = (float)frac(y2);
	if (xa==xb) {
		xfrac = lfrac+rfrac-1.0f;
		if (ya==yb) { 
			/* --- only one pixel effected */
			Plot(xa,ya,(int)(xfrac*(tfrac+bfrac-1.0f)*brite),&white);	
			}
		else {  
			/* --- column of pixels */
			Plot(xa,ya,(int)(xfrac*tfrac*brite),&white);
			for (j=ya+1; j<yb; j++) Plot(xa,j,(int)(xfrac*brite),&white);
			Plot(xa,yb,(int)(xfrac*bfrac*brite),&white);
			}
		}
	else {
		if (ya==yb) { 
			/* --- row of pixels */
			yfrac = tfrac+bfrac-1.0f;
			Plot(xa,ya,(int)(yfrac*lfrac*brite),&white);
			for (i=xa+1; i<xb; i++) Plot(i,ya,(int)(yfrac*brite),&white);
			Plot(xb,ya,(int)(yfrac*rfrac*brite),&white);
			}
		else {  
			/* general case */

			/* --- top row */
			Plot(xa,ya,(int)(tfrac*lfrac*brite),&white);
			for (i=xa+1; i<xb; i++) Plot(i,ya,(int)(tfrac*brite),&white);
			Plot(xb,ya,(int)(tfrac*rfrac*brite),&white);

			/* --- middle (whole pixels ) */
			for (j=ya+1; j<yb; j++) {
				Plot(xa,j,(int)(lfrac*brite),&white);
				for (i=xa+1; i<xb; i++) Plot(i,j,(int)(brite),&white);
				Plot(xb,j,(int)(rfrac*brite),&white);
				}

			/* --- bottom row */
			Plot(xa,yb,(int)(bfrac*lfrac*brite),&white);
			for (i=xa+1; i<xb; i++) Plot(i,yb,(int)(bfrac*brite),&white);
			Plot(xb,yb,(int)(bfrac*rfrac*brite),&white);
			}
		}
	}

/* Find angle for given vector, and its 90-degree offset	*/
/* Returns angles in radians					*/
/* Returns 0 if angle indeterminate				*/

int ImageFilter_Stars::FindAngle(float deltax,float deltay,float *angle,float *angle90) {
	float awk,a90wk;

	if(deltax==0.0)
	 {
	 if(deltay==0.0)
	  {
	  if(angle)
	   *angle=0.0f;
	  if(angle90)
	   *angle90=0.0f;
	  return(0);
	  }

	 if(deltay<0.0f)
	  awk=PI_270;
	 else
	  awk=PI_90;
	 goto get_90;
	 }
	if(deltay==0.0)
	 {
	 if(deltax<0.0)
	  awk=PI_180;
	 else
	  awk=0.0f;
	 goto get_90;
	 }

	awk=(float)atan(deltay/deltax);
	if(deltax<0)
	 awk+=PI_180;
	while(awk<0.0f)
	 awk+=PI_360;
	while(awk>=PI_360)
	 awk-=PI_360;

	get_90:
	a90wk=awk+PI_90;
	while(a90wk>=PI_360)
	 a90wk-=PI_360;

	if(angle)
	 *angle=awk;
	if(angle90)
	 *angle90=a90wk;

	return(1);
	}


/* Antialiased line routine */
/* Draws lines from floating-point positions */

void ImageFilter_Stars::AALine(float x1,float y1,float x2,float y2,float width,int brite) {
	int ix,midct;
	float dx,dy,adx,ady,minorax,temp,angle,slope,length;
	float leftmost,rightmost,topmost,botmost,lfrac,rfrac,tfrac,bfrac;
	float lxpos,lypos,rxpos,rypos,txpos,typos,bxpos,bypos,xpos,ypos;

	/* Adjust blur coordinates using percentage of shutter-open time */

	dx=x2-x1;
	x1+=blurpct*dx;
	dy=y2-y1;
	y1+=blurpct*dy;

	/* Dim line based on length */

	if(data.blurDim)
	 {
	 float bdmult=(float)data.blurDim/100.0f;
	 length=(float)sqrt(dx*dx+dy*dy)*bdmult+width;
	 brite=(int)((float)brite/(length/width));
	 }

#ifdef NEWCODE
	/* Dim line based on length */

	if(data.blurDim)
	 {
	 // Calc new length
	 dx = x2-x1;
	 dy = y2-y1;

	 float bdmult=(float)data.blurDim/100.0f;
	 length=(float)sqrt(dx*dx+dy*dy);
	 if(length > 0.0f) {
		float effectiveLength = length * bdmult;
		if(effectiveLength < 1.0f)
			effectiveLength = 1.0f;
		brite=(int)((float)brite/effectiveLength);
		}
	 }
#endif

	/* Special cases -- dot, hline, vline */

	if(x1==x2)
	 {
	 if(y1==y2)	/* No line, really - just plot a dot */
	  FRect(x1,y1,width,width,brite);
	 else		/* Vertical line */
	  FRect(x1,(y1+y2)/2.0f,width,(float)fabs(y2-y1)+width,brite);
	 return;
	 }
	else
	 {
	 if(y1==y2)	/* Horizontal line */
	  {
	  FRect((x1+x2)/2.0f,y1,(float)fabs(x2-x1)+width,width,brite);
	  return;
	  }
	 }

	/* orient line left->right */

	if(x2<x1)
	 {
	 temp=x1;
	 x1=x2;
	 x2=temp;
	 temp=y1;
	 y1=y2;
	 y2=temp; 
	 }
	dx=x2-x1;
	dy=y2-y1;
	adx=(float)fabs(dx);
	ady=(float)fabs(dy);
	FindAngle(dx,dy,&angle,NULL);
	minorax=(float)(fabs(sin(angle))+fabs(cos(angle)));
	if(adx>ady)	/* Horizontally major */
	 {
	 slope=dy/dx;

	 /* Plot leftmost pixels */
	 leftmost=x1-(width/2.0f);
	 lfrac=1.0f-(float)frac(leftmost);
	 lxpos=(float)((int)(leftmost+0.5f));
	 lypos=y1-(x1-lxpos)*slope;
	 FRect(lxpos,lypos,1.0f,width,(int)(brite*lfrac));

	 /* Plot rightmost pixels */
	 rightmost=x2+(width/2.0f);
	 rfrac=(float)frac(rightmost);
	 rxpos=(int)rightmost+0.5f;
	 rypos=y2+(rxpos-x2)*slope;
	 FRect(rxpos,rypos,1.0f,width,(int)(brite*rfrac));

	 xpos=lxpos+1.0f;
	 ypos=lypos+slope;
	 midct=(int)rightmost-1-(int)leftmost;
	 for(ix=0; ix<midct; ++ix,xpos+=1.0f,ypos+=slope)
	  FRect(xpos,ypos,1.0f,width,brite);
	 }
	else		/* vertically major */
	 {
	 if(y2<y1)	/* Make sure line is top->bottom */
	  {
	  temp=y1;
	  y1=y2;
	  y2=temp;
	  temp=x1;
	  x1=x2;
	  x2=temp; 
	  }

	 slope=dx/dy;

	 /* Plot topmost pixels */
	 topmost=y1-(width/2.0f);
	 tfrac=(float)(1.0-frac(topmost));
	 typos=(float)((int)(topmost+0.5f));
	 txpos=x1-(y1-typos)*slope;
	 FRect(txpos,typos,width,1.0f,(int)(brite*tfrac));

	 /* Plot bottommost pixels */
	 botmost=y2+(width/2.0f);
	 bfrac=(float)frac(botmost);
	 bypos=(float)((int)(botmost+0.5f));
	 bxpos=x2+(bypos-y2)*slope;
	 FRect(bxpos,bypos,width,1.0f,(int)(brite*bfrac));

	 ypos=typos+1.0f;
	 xpos=txpos+slope;
	 midct=abs((int)botmost-1-(int)topmost);
	 for(ix=0; ix<midct; ++ix,ypos+=1.0f,xpos+=slope)
	  FRect(xpos,ypos,width,1.0f,brite);
	 }
	}

/* Tom's Floating-point antialiased circle plotter	*/
/* X,Y are center of circle				*/

int ImageFilter_Stars::FCirc(float x, float y, float radius, float aspect, int brite, BMM_Color_48 *c) {
	int ix,iy,minx,miny,maxx,maxy,in1,in2,in3,in4,layout,obrite;
	float xf,yf,pxl,pxh,pyl,pyh,dxl,dxh,dyl,dyh,d1,d2,d3,d4,v1,v2,v3,v4;
	float rsqr,alpha,alpha1,alpha2;

	/* Find screen coords that bound the floating-point circle */
	minx=(int)(x-radius);
	maxx=(int)(x+radius);
	miny=(int)(y-radius*aspect);
	maxy=(int)(y+radius*aspect);

	/* Calc radius squared */
	rsqr=radius*radius;

	/* Go thru pixel box, processing each */
	for(ix=minx,xf=minx-x; ix<=maxx; ++ix,xf+=1.0f)
		{
		pxl=xf;
		pxh=xf+1.0f;
		dxl=pxl*pxl;
		dxh=pxh*pxh;
		for(iy=miny,yf=miny-y; iy<=maxy; ++iy,yf+=1.0f)
			{
			pyl=yf/dev_aspect;
			pyh=(yf+1.0f)/dev_aspect;
			dyl=pyl*pyl;
			dyh=pyh*pyh;

			/* See how far each corner of pixel is from center */
			d1=dxl+dyl;
			d2=dxl+dyh;
			d3=dxh+dyh;
			d4=dxh+dyl;
			obrite=brite;

			if(d1<rsqr && d2<rsqr && d3<rsqr && d4<rsqr)
				{
				Plot(ix,iy,obrite,c);
				}
			else
			if(d1<rsqr || d2<rsqr || d3<rsqr || d4<rsqr)
				{
				/* Figure out pixel coverage */
				d1=(float)sqrt(d1)-radius;
				d2=(float)sqrt(d2)-radius;
				d3=(float)sqrt(d3)-radius;
				d4=(float)sqrt(d4)-radius;
				in1=(d1<0.0) ? 1:0;
				in2=(d2<0.0) ? 1:0;
				in3=(d3<0.0) ? 1:0;
				in4=(d4<0.0) ? 1:0;
				layout=in1 | (in2<<1) | (in3<<2) | (in4<<3);
				switch(layout)
					{
					case 1:	/* D1 in, rest out */
						v1= -d1;
						v2= d4;
						v3= d2;
						goto onein;
					case 2:	/* D2 in, rest out */
						v1= -d2;
						v2= d1;
						v3= d3;
						goto onein;
					case 4:	/* D3 in, rest out */
						v1= -d3;
						v2= d2;
						v3= d4;
						goto onein;
					case 8:	/* D4 in, rest out */
						v1= -d4;
						v2= d3;
						v3= d1;

						onein:
						alpha1= v1/(v1+v2);
						alpha2= v1/(v1+v3);
						alpha=MAX(alpha1,alpha2)/2.0f;
						break;
					case 3: /* D1/D2 in */
						v1=-d1;
						v2=-d2;
						v3=d4;
						v4=d3;
						goto twoin;
					case 6: /* D2/D3 in */
						v1=-d2;
						v2=-d3;
						v3=d1;
						v4=d4;
						goto twoin;
					case 9: /* D4/D1 in */
						v1=-d4;
						v2=-d1;
						v3=d3;
						v4=d2;
						goto twoin;
					case 12: /* D3/D4 in */
						v1=-d3;
						v2=-d4;
						v3=d2;
						v4=d1;

						twoin:
						alpha1= v1/(v1+v3);
						alpha2= v2/(v2+v4);
						alpha=(alpha1+alpha2)/2.0f;
						break;
					case 14: /* D1 out, rest in */
						v1= d1;
						v2= -d4;
						v3= -d2;
						goto oneout;
					case 13: /* D2 out, rest in */
						v1= d2;
						v2= -d1;
						v3= -d3;
						goto oneout;
					case 11: /* D3 out, rest in */
						v1= d3;
						v2= -d4;
						v3= -d2;
						goto oneout;
					case 7: /* D4 out, rest in */
						v1= d4;
						v2= -d3;
						v3= -d1;

						oneout:
						alpha1= v2/(v2+v1);
						alpha2= v3/(v3+v1);
						alpha=MAX(alpha1,alpha2)/2.0f+0.5f;
						break;
					}
				Plot(ix,iy,(int)((float)obrite*alpha),c);
				}
			}
		}
	return(1);
	}

static BOOL EnumerateNodes(INode *start, NodeCallBack &findCam) {
	int nodes = start->NumberOfChildren();
	for(int i = 0; i < nodes; ++i) {
		INode *node = start->GetChildNode(i);
		if(!findCam.CallBack(node))
			return FALSE;		// Stop enumerating
		if(!EnumerateNodes(node,findCam))
			return FALSE;
		}
	return TRUE;
	}

BOOL FindCameraNode::CallBack(INode *n) {
	TSTR camName(n->GetName());
	if(camName == name) {
		Object *obj = n->GetObjectRef();
		if(obj && obj->SuperClassID() == CAMERA_CLASS_ID) {
			node = n;
			return FALSE;	// Got it -- No more enumerating
			}
		}
	return TRUE;	// This isn't it -- keep going!
	}

BOOL CameraFiller::CallBack(INode *n) {
	Object *obj = n->GetObjectRef();
	if(obj && obj->SuperClassID() == CAMERA_CLASS_ID) {
		if(obj && obj->SuperClassID() == CAMERA_CLASS_ID)
			SendDlgItemMessage(hWnd, id, CB_ADDSTRING, 0, (LPARAM)n->GetName());
		ok = TRUE;
		}
	return TRUE;	// This isn't it -- keep going!
	}

//-----------------------------------------------------------------------------
// #> ImageFilter_Stars::Render()
//

BOOL ImageFilter_Stars::Render(HWND hWnd) {
	BOOL			result			= TRUE;

	// Grab info on the view and such
	RenderInfo *rinfo = srcmap->GetRenderInfo();
	if(!rinfo) {
		ErrorMessage(IDS_NO_RENDERINFO);
		return FALSE;
		}
	if(rinfo->projType != ProjPerspective) {
		ErrorMessage(IDS_NOT_PERSPECTIVE);
		return FALSE;
		}
	dev_aspect = srcmap->Aspect();
	blurpct=1.0f - ((float)data.blurAmount / 100.0f);

	// We have a valid condition for generating a starfield -- do it!

	// Get the stars

	if(data.dataType == DATA_CUSTOM) {
		FILE *istream;
		int p;

		// Try just the raw name they gave
		if((istream=fopen(data.filename,"rb"))!=NULL)
			goto got_file;

		// Search thru the plugin paths
		for(p = 0; p < Max()->GetPlugInEntryCount(); ++p) {
			TCHAR *dir = Max()->GetPlugInDir(p);
			TCHAR fname[256];
			_tcsncpy(fname,dir,255);
			_tcsncat(fname,data.filename,255);
			if((istream=fopen(fname,"rb"))!=NULL)
				goto got_file;
			}

		ErrorMessage(IDS_CANT_OPEN);
		return FALSE;

		got_file:
		if(fread(&starcount,sizeof(int),1,istream)!=1)
			{
			bad_infile:
			ErrorMessage(IDS_BAD_FILE);
			fclose(istream);
			FreeData();
			return FALSE;
			}
		// Establish how big the file is so we can verify its authenticity as a star file
		fseek(istream, 0L, SEEK_END);
		int filesize = ftell(istream);
		fseek(istream, 4L, SEEK_SET);

		// Make sure the file is valid
		if(starcount == 0 || filesize != (int)((starcount * sizeof(Star)) + 4))
			goto bad_infile;

		/* Allocate room for stars */

		stardata = new Star[starcount];
		if(!stardata) {
			no_ram:
			ErrorMessage(IDS_OUT_OF_MEMORY);
			fclose(istream);
			FreeData();
			return FALSE;
			}
		pos1 = new StarPos[starcount];
		if(!pos1)
			goto no_ram;
		if(data.useBlur) {
			pos2 = new StarPos[starcount];
			if(!pos2)
				goto no_ram;
			}
		else
			pos2 = NULL;

		if(fread(stardata,sizeof(Star),starcount,istream) != (size_t)starcount)
			goto bad_infile;

		fclose(istream);
		}
	else {
		starcount = data.count;
		stardata = new Star[starcount];
		pos1 = new StarPos[starcount];
		if(data.useBlur)
			pos2 = new StarPos[starcount];
		else
			pos2 = NULL;

		rand.Seed(data.seed);
		for(int ix=0; ix<starcount; ++ix)
			{
			Point3 p;

			p.x=(float)(rand.Random() & 0x0fff)-2048;
			p.y=(float)(rand.Random() & 0x0fff)-2048;
			p.z=(float)(rand.Random() & 0x0fff)-2048;

			/* Make sure all stars are equidistant at 1000 units */

			stardata[ix].p = 1000.0f * Normalize(p);
			stardata[ix].fmag=10.0f - (((float)(rand.Random() & 0x0fff)/409.5f) *
				((float)(rand.Random() & 0x0fff) / 4095.0f));
			stardata[ix].mag = 0;
			}
		}

	// Set up some stuff...

	float factor2=((float)data.brightest - (float)data.dimmest) / 10.0f;
	for(int ix=0; ix<starcount; ++ix) {
		float mag=stardata[ix].fmag;
		if(data.briteType == BRITE_LOG)
			stardata[ix].mag=(int)(pow(10.0f - mag, 2.407f));
		else
			stardata[ix].mag=(int)((10.0f - mag) * factor2) + data.dimmest;
		}

	// Grab the camera that's used for the shot
	
	INode *camNode;
	TSTR ourCamera(data.camera);
	FindCameraNode findCam(ourCamera);
	EnumerateNodes(Max()->GetRootNode(), findCam);
	if(!findCam.Found()) {
		ErrorMessage(IDS_CAMERA_NOT_FOUND);
		FreeData();
		return FALSE;
		}

	// If we get here, we have a valid camera node -- Grab the transform(s) for it
	camNode = findCam.node;
	if(rinfo->fieldRender)
		{
		CameraInfo prevcam, cam1, cam2;

		ComputeCamera(camNode, rinfo->renderTime[0]-(rinfo->renderTime[1]-rinfo->renderTime[0]), &prevcam);
		ComputeCamera(camNode, rinfo->renderTime[0], &cam1);
		ComputeCamera(camNode, rinfo->renderTime[1], &cam2);

		/* First, even scan lines */
		Process((rinfo->fieldOdd) ? ODD_LINES:EVEN_LINES, rinfo, &cam1, &prevcam);

		/* Next, odd scan lines */
		Process((rinfo->fieldOdd) ? EVEN_LINES:ODD_LINES, rinfo, &cam2, &cam1);
		}
	else
		{
		CameraInfo prevcam, camera;

		ComputeCamera(camNode, rinfo->renderTime[0] - 160, &prevcam);
		ComputeCamera(camNode, rinfo->renderTime[0], &camera);

		Process(ALL_LINES, rinfo, &camera, &prevcam);
		}

	FreeData();
	return(TRUE);

}

void ImageFilter_Stars::TransformStars(CameraInfo *c, StarPos *p) {
	float fsx,fsy;
	float centerx,centery,camzfac,camw2,camh2;
	int dwidth,dheight;
	int ix,sx,sy;

	camzfac=(float)tan((PI_180 - c->fov)/2.0f);
	camw2=srcmap->Width()/2.0f;
	camh2=camw2 * -dev_aspect;

	dwidth = srcmap->Width();
	dheight = srcmap->Height();
	centerx = (float)dwidth / 2.0f;
	centery = (float)dheight / 2.0f;

	for(ix=0; ix<starcount; ++ix)
		{
		Point3 tp = stardata[ix].p * c->tm;
		if(tp.z < -100.0f)
			{
			p[ix].x=fsx=centerx + tp.x / -tp.z * camzfac * camw2;
			p[ix].y=fsy=centery + tp.y / -tp.z * camzfac * camh2;
			sx=(int)fsx;
			sy=(int)fsy;
			if(sx>=0 && sx<dwidth && sy>=0 && sy<dheight) {
				p[ix].vis=1;	/* Onscreen */
				}
			else
				p[ix].vis=0;	/* Offscreen */
			}
		else
			p[ix].vis= -1;	/* Behind -- no useful coord */
		}
	}

void ImageFilter_Stars::Process(int type, RenderInfo *rinfo, CameraInfo *i1, CameraInfo *i2) {
	int ix;
	StarPos *p1,*p2;
	field_type=type;

	/* If using motion blur, calc last star positions */

	if(data.useBlur)
		TransformStars(i2,pos2);

	/* Now calc current star positions */

	TransformStars(i1,pos1);

	/* Now plot each star if it's visible */

	if(data.useBlur)
		{
		for(ix=0,p1=pos1,p2=pos2; ix<starcount; ++ix,++p1,++p2)
			{
			if((p1->vis+p2->vis)>0)
				AALine(p2->x,p2->y,p1->x,p1->y,data.size,stardata[ix].mag);
			}
		}
	else
		{
		float ysize=data.size*dev_aspect;
		for(ix=0,p1=pos1; ix<starcount; ++ix,++p1)
			{
			if(p1->vis==1)
				{
				if(data.size<1.0)
					FRect(p1->x,p1->y,data.size,ysize,
						stardata[ix].mag);
				else
					FCirc(p1->x,p1->y,data.size/2.0f,dev_aspect,
						stardata[ix].mag,&white);
				}
			}
		}
	}

BOOL ImageFilter_Stars::LoadCameras(HWND hWnd)	{
	BOOL ok = FALSE;
	CameraFiller camFiller(hWnd, IDC_CAMERAS);
	SendDlgItemMessage(hWnd, IDC_CAMERAS, CB_RESETCONTENT, 0, 0);
	EnumerateNodes(Max()->GetRootNode(), camFiller);
	
	if(camFiller.OK()) {
		// See if our data matches one of 'em
		int item = SendDlgItemMessage(hWnd, IDC_CAMERAS, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)data.camera);
		if(item != CB_ERR)
			SendDlgItemMessage(hWnd, IDC_CAMERAS, CB_SETCURSEL, item, 0);
		else
			SendDlgItemMessage(hWnd, IDC_CAMERAS, CB_SETCURSEL, 0, 0);
		}
	return camFiller.OK();
	}

//-----------------------------------------------------------------------------
// #> ImageFilter_Stars::LoadConfigure()

BOOL ImageFilter_Stars::LoadConfigure ( void *ptr ) {
     STARSDATA *buf = (STARSDATA *)ptr;
     if (buf->version == STARSVERSION) {
        memcpy((void *)&data,ptr,sizeof(STARSDATA));
        return (TRUE);
     } else
        return (FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Stars::SaveConfigure()

BOOL ImageFilter_Stars::SaveConfigure ( void *ptr ) {
     if (ptr) {
        memcpy(ptr,(void *)&data,sizeof(STARSDATA));
		return (TRUE);
	} else
        return (FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Stars::EvaluateConfigure()

DWORD ImageFilter_Stars::EvaluateConfigure ( ) {
	return (sizeof(STARSDATA));
}

void ImageFilter_Stars::ErrorMessage(int id) {
	TSTR s1(GetString(IDS_STARFIELD_ERROR));
	TSTR s2(GetString(id));
	Max()->Log()->LogEntry(SYSLOG_ERROR,DISPLAY_DIALOG,s1.data(),s2.data());
	}


//--	EOF: Stars.cpp --------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Wipe\wipe.h ===
//-----------------------------------------------------------------------------
// -----------------
// File ....: Wipe.h
// -----------------
// Author...: Gus J Grubba
// Date ....: February 1996
// Descr....: Wipe Transition
//
// History .: Feb, 18 1996 - Started
//            
//-----------------------------------------------------------------------------
        
#ifndef _WIPECLASS_
#define _WIPECLASS_

#define DLLEXPORT __declspec(dllexport)

//-----------------------------------------------------------------------------
//-- Configuration Block ------------------------------------------------------
//

#define WIPEVERSION 100

typedef struct tagWIPEDATA {
     DWORD	version;
     int	type;
	BOOL	reverse;
	BOOL	overlap;
} WIPEDATA;

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class ImageFilter_Wipe : public ImageFilter {
    
     public:

		WIPEDATA			data;
     
        //-- Constructors/Destructors
        
                       ImageFilter_Wipe( );
                      ~ImageFilter_Wipe( ) {}
               
        //-- Filter Info  ---------------------------------

        const TCHAR   *Description         ( ) ;
        const TCHAR   *AuthorName          ( ) { return _T("Gus J Grubba");}
        const TCHAR   *CopyrightMessage    ( ) { return _T("Copyright 1996, Yost Group");}
        UINT           Version             ( ) { return (WIPEVERSION);}

        //-- Filter Capabilities --------------------------
        
        DWORD          Capability          ( ) { return(IMGFLT_COMPOSITOR | 
        																IMGFLT_FILTER 		| 
        																IMGFLT_CONTROL); }

        //-- Show DLL's About box -------------------------
        
        void           ShowAbout				( HWND hWnd );  
        BOOL           ShowControl				( HWND hWnd );

        //-- Show Time ------------------------------------
        
        BOOL           Render					( HWND hWnd );

        //-- Filter Configuration -------------------------
        
        BOOL           LoadConfigure			( void *ptr );
        BOOL           SaveConfigure			( void *ptr );
        DWORD          EvaluateConfigure		( );
        
        //-- Local Methods --------------------------------
        
		BOOL				Control					(HWND ,UINT ,WPARAM ,LPARAM );

};

#endif

//-- EOF: Wipe.h --------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Wipe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wipe.rc
//
#define IDS_DB_WIPE                     1
#define IDS_DB_IMAGE_FILTER             2
#define IDS_DB_SIMPLE_WIPE              3
#define IDS_LIBDESCRIPTION              4
#define IDD_WIPE_ABOUT                  101
#define IDD_WIPE_CONTROL                102
#define IDB_RIGHT                       105
#define IDB_LEFT                        106
#define IDB_UP                          107
#define IDB_DOWN                        108
#define IDB_DOWN_NEG                    109
#define IDB_LEFT_NEG                    110
#define IDB_RIGHT_NEG                   111
#define IDB_UP_NEG                      112
#define IDC_RIGHT                       1002
#define IDC_LEFT                        1003
#define IDC_UP                          1004
#define IDC_DOWN                        1005
#define IDC_REVERSE                     1006
#define IDC_OVERLAP                     1007
#define IDC_RIGHT_POS                   1008
#define IDC_LEFT_POS                    1009
#define IDC_UP_POS                      1010
#define IDC_DOWN_POS                    1011
#define IDC_RIGHT_NEG                   1012
#define IDC_DOWN_NEG                    1013
#define IDC_UP_NEG                      1014
#define IDC_NORMAL                      1014
#define IDC_LEFT_NEG                    1015
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Stars\stars.h ===
//-----------------------------------------------------------------------------
// ---------------------
// File ....: stars.h
// ---------------------
// Author...: Tom Hudson
// Date ....: April 1996
// Descr....: Starfield Image Filter
//
// History .: April 25 1996 - Started
//            
//-----------------------------------------------------------------------------
        
#ifndef _STARSCLASS_
#define _STARSCLASS_

#define DLLEXPORT __declspec(dllexport)

// Class ID
#define STARS_CLASS_ID Class_ID(0x97621334,0x652136f2)

//-----------------------------------------------------------------------------
//-- Configuration Block ------------------------------------------------------
//

#define BRITE_LINEAR 0
#define BRITE_LOG 1

#define DATA_RANDOM 0
#define DATA_CUSTOM 1

#define COMP_BACK 0
#define COMP_FORE 1

#define STARSVERSION 100

// Forward references
extern TCHAR *GetString(int id);

// Node enumeration callback
class NodeCallBack {
	public:
		virtual BOOL CallBack(INode *n)=0;	// Return TRUE to keep going
	};

class FindCameraNode : public NodeCallBack {
	public:
		TSTR name;
		INode *node;
		FindCameraNode(TSTR n) { name=n; node=NULL; }
		BOOL CallBack(INode *n);
		BOOL Found() { return (node == NULL) ? FALSE : TRUE; }
	};

class CameraFiller : public NodeCallBack {
	public:
		BOOL ok;
		HWND hWnd;
		int id;
		CameraFiller(HWND h, int i) { ok=FALSE; hWnd=h; id=i; }
		BOOL CallBack(INode *n);
		BOOL OK() { return ok; }
	};

//Random number generator class
class RandGen {
	public:
		ULONG next;
		RandGen() { next = 1; }
		void Seed(ULONG seed) { next = seed; }
		int Random() { next=next*1103515245 + 12345; return((unsigned int)(next/65536) % 32768); }
	};

typedef struct tagSTARSDATA {
	DWORD version;
	TCHAR camera[256];
	int dimmest, brightest;
	int briteType;
	float size;
	BOOL useBlur;
	int blurAmount, blurDim;
	int dataType;
	int seed, count;
	char filename[256];
	int compositing;
} STARSDATA;

// Misc data types

/* Star database */

#pragma pack(1)
typedef struct
{
Point3 p;
float fmag;
unsigned char mag;
} Star;
#pragma pack()

typedef struct
{
float x,y;
short vis;
} StarPos;

// Camera view info

typedef struct
{
Matrix3 tm;
float fov;
} CameraInfo;

// Process() line types

#define EVEN_LINES 1
#define ODD_LINES 2
#define ALL_LINES 3

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class ImageFilter_Stars : public ImageFilter {
    
		STARSDATA       data;

		/* Pointer to star database */

		Star *stardata;
		StarPos *pos1, *pos2;

		int starcount;
		float dev_aspect;
		int field_type;
		float blurpct;
		RandGen rand;

	public:
     
        //-- Constructors/Destructors
        
                       ImageFilter_Stars( );
                      ~ImageFilter_Stars( ) { FreeData(); }
               
        //-- Filter Info  ---------------------------------

        const TCHAR   *Description         ( ) { return GetString(IDS_STARFIELD);}
        const TCHAR   *AuthorName          ( ) { return _T("Tom Hudson");}
        const TCHAR   *CopyrightMessage    ( ) { return _T("Copyright 1996, Hudson/O'Connell Design");}
        UINT           Version             ( ) { return (STARSVERSION);}

        //-- Filter Capabilities --------------------------
        
        DWORD          Capability          ( ) { return(IMGFLT_FILTER | IMGFLT_CONTROL); }

        //-- Show DLL's About & Control box ---------------
        
        void           ShowAbout           ( HWND hWnd );  
        BOOL           ShowControl         ( HWND hWnd );  

        //-- Showtime -------------------------------------
        
        BOOL           Render              ( HWND hWnd );

        //-- Filter Configuration -------------------------
        
        BOOL           LoadConfigure			( void *ptr );
        BOOL           SaveConfigure			( void *ptr );
        DWORD          EvaluateConfigure		( );

        //-- Local Methods --------------------------------
        
		BOOL			Control					(HWND ,UINT ,WPARAM ,LPARAM );
		void			Process	(int lines, RenderInfo *rinfo, CameraInfo *i1, CameraInfo *i2);
		BOOL			LoadCameras ( HWND hWnd );
		void			ComputeCamera(INode *node, TimeValue t, CameraInfo *ci);
		void			TransformStars (CameraInfo *c, StarPos *p);
		void			Plot(int x, int y, int v, BMM_Color_48 *c);
		void			FRect(float x, float y, float w, float h,int brite);
		void			AALine(float x1,float y1,float x2,float y2,float width,int brite);
		int				FCirc(float x, float y, float radius, float aspect, int brite, BMM_Color_48 *c);
		int				FindAngle(float deltax,float deltay,float *angle,float *angle90);
		void			FreeData();
		void			ErrorMessage(int id);
		void			EnableStarControls(HWND hWnd);
};

#endif

//-- EOF: stars.h ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Filters\Wipe\wipe.cpp ===
//-----------------------------------------------------------------------------
// -------------------
// File ....: Wipe.cpp
// -------------------
// Author...: Gus J Grubba
// Date ....: February 1996
// Descr....: Wipe Transition
//
// History .: Feb, 18 1996 - Started
//            
//-----------------------------------------------------------------------------
        
//-- Include files

#include <Max.h>
#include <bmmlib.h>
#include <fltlib.h>
#include "Wipe.h"
#include "resource.h"

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
     switch (fdwReason) {
         case DLL_PROCESS_ATTACH:
              if (hInst)
                 return(FALSE);
              hInst = hDLLInst;
              break;
         case DLL_PROCESS_DETACH:
              hInst  = NULL;
              break;
         case DLL_THREAD_ATTACH:
              break;
         case DLL_THREAD_DETACH:
              break;
     }
     return TRUE;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Wipe Class Description

class WIPEClassDesc:public ClassDesc {
     
     public:

        int             IsPublic     ( )                   { return 1;                }
        void           *Create       ( BOOL loading=FALSE) { return new ImageFilter_Wipe; }
        const TCHAR    *ClassName    ( )                   { return GetString(IDS_DB_WIPE);     }
        SClass_ID       SuperClassID ( )                   { return FLT_CLASS_ID;  }
        Class_ID        ClassID      ( )                   { return Class_ID(WIPECLASSID,0);    }
        const TCHAR    *Category     ( )                   { return GetString(IDS_DB_IMAGE_FILTER); }

};

static WIPEClassDesc WIPEDesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
     return GetString(IDS_LIBDESCRIPTION); 
}

DLLEXPORT int LibNumberClasses ( ) { 
     return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
     switch(i) {
        case  0: return &WIPEDesc; break;
        default: return 0;        break;
     }
}

DLLEXPORT ULONG LibVersion ( )  { 
     return ( VERSION_3DSMAX ); 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

const TCHAR *ImageFilter_Wipe::Description( ) 
{
	return GetString(IDS_DB_SIMPLE_WIPE);
}

//-----------------------------------------------------------------------------
// *> ControlDlgProc()
//

BOOL	CALLBACK	ControlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)	{
     static ImageFilter_Wipe *flt = NULL;
     if (message == WM_INITDIALOG) 
        flt = (ImageFilter_Wipe *)lParam;
     if (flt) 
        return (flt->Control(hWnd,message,wParam,lParam));
     else
        return(FALSE);
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {
	switch (message) {
        case WM_INITDIALOG:
			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			return 1;
        case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:              
				case IDCANCEL:
					EndDialog(hWnd,1);
					break;
			}
			return 1;
	}
	return 0;
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Wipe::ImageFilter_Wipe()
//

ImageFilter_Wipe::ImageFilter_Wipe() {
	data.version	= WIPEVERSION;
	data.type		= IDC_RIGHT;
	data.reverse	= FALSE;
	data.overlap	= TRUE;
}

//-----------------------------------------------------------------------------
// *> ToggleItem()
//

void ToggleItem ( HWND hWnd, int item, BOOL flag ) {
	HWND hDlg = GetDlgItem(hWnd,item);
	if (flag)
		ShowWindow(hDlg,SW_SHOW);
	else
		ShowWindow(hDlg,SW_HIDE);
}

//-----------------------------------------------------------------------------
// *> HandleIcons()
//

void HandleIcons( HWND hWnd, BOOL reverse ) {
	ToggleItem(hWnd,IDC_RIGHT_POS,reverse);
	ToggleItem(hWnd,IDC_LEFT_POS,	reverse);
	ToggleItem(hWnd,IDC_RIGHT_NEG,!reverse);
	ToggleItem(hWnd,IDC_LEFT_NEG,	!reverse);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Wipe::Control()
//

BOOL	ImageFilter_Wipe::Control(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)	{

	static WIPEDATA tempdata;

	switch (message) {

		case WM_INITDIALOG:

			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));

			tempdata = data;

			//-- Handle Direction ----------------

			CheckRadioButton(
				hWnd,
				IDC_RIGHT,
				IDC_DOWN,
				tempdata.type
			);

			//-- Options -------------------------

			CheckRadioButton(
				hWnd,
				IDC_REVERSE,
				IDC_NORMAL,
				(tempdata.reverse ? IDC_REVERSE : IDC_NORMAL)
			);

			HandleIcons(hWnd,tempdata.reverse);

			return 1;

		case WM_COMMAND:

			switch (LOWORD(wParam)) {

				case IDC_RIGHT:
				case IDC_LEFT:
					tempdata.type = LOWORD(wParam);
					break;

				case IDC_REVERSE:
				case IDC_NORMAL:
					tempdata.reverse = IsDlgButtonChecked(hWnd,IDC_REVERSE);
					HandleIcons(hWnd,tempdata.reverse);
					break;

				case IDOK:
					data = tempdata;
					EndDialog(hWnd,1);
					break;

				case IDCANCEL:
					EndDialog(hWnd,0);
					break;

			}

			return 1;

	}

	return 0;

}

//-----------------------------------------------------------------------------
// #> ImageFilter_Wipe::ShowAbout()

void ImageFilter_Wipe::ShowAbout(HWND hWnd) {
     DialogBoxParam(
        hInst,
        MAKEINTRESOURCE(IDD_WIPE_ABOUT),
        hWnd,
        (DLGPROC)AboutCtrlDlgProc,
        (LPARAM)this);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Wipe::ShowControl()

BOOL ImageFilter_Wipe::ShowControl(HWND hWnd) {
     return (DialogBoxParam(
        hInst,
        MAKEINTRESOURCE(IDD_WIPE_CONTROL),
        hWnd,
        (DLGPROC)ControlDlgProc,
        (LPARAM)this));
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Wipe::Render()
//
//	 This filter act as both a filter and as a layer. If the foreground map is
//	 present, we are a layer and we use it. Otherwise, we simply use a pseudo
//	 (black) map.
//

BOOL ImageFilter_Wipe::Render(HWND hWnd) {

	BMM_Color_64 *l64,*line64 = NULL;
	BMM_Color_64 *f64,*fgnd64 = NULL;

	int iy,x0,x1;

	BOOL abort  = FALSE;
	BOOL result = FALSE;

	//-- Calculate Lerp value

	float count = (float)(max(ifi->FilterRange.Count()-1,1));
	float lerp 	= (float)((ifi->QueueRange.Current() - ifi->FilterRange.First())) / count;
     
     if (!srcmap)
        goto done;

     //-- Allocate Background Line
     
     if ((line64=(BMM_Color_64 *)calloc(srcmap->Width(),sizeof(BMM_Color_64)))==NULL)
        goto done;

     //-- Allocate Foreground Line
     
     if ((fgnd64=(BMM_Color_64 *)calloc(srcmap->Width(),sizeof(BMM_Color_64)))==NULL)
        goto done;

	//------------------------------------------------------------------------
	//-- Process Image -------------------------------------------------------

	for (iy = 0; iy < srcmap->Height(); iy++) {

        //-- Progress Report
        
        SendMessage(hWnd,FLT_PROGRESS,iy,srcmap->Height()-1);

        //-- Check for Abort
        
        SendMessage(hWnd,FLT_CHECKABORT,0,(LPARAM)(BOOL *)&abort);

        if (abort)
        	goto done;
        
        l64 = line64;
        f64 = fgnd64;

        //-- Get Source line
        
		if (!data.overlap) {
        	if (srcmap->GetLinearPixels(0,iy,srcmap->Width(),line64)!=1)
        		goto done;
		}

		//-- Push Image Into Background - Left to Right (Layer) ------------

		if (data.type == IDC_RIGHT && data.reverse && frgmap) {
     	   
			if (frgmap->GetLinearPixels(0,iy,srcmap->Width(),fgnd64)!=1)
				goto done;
			x1 = (int)(lerp * (float)srcmap->Width());
			x0 = max(srcmap->Width() - x1 - 1,0);
			if (x1) srcmap->PutPixels(0,iy,x1,&fgnd64[x0]);

		//-- Push Image Out of Background - Left to Right (Layer) ----------

		} else if (data.type == IDC_RIGHT && !data.reverse && frgmap) {

			if (frgmap->GetLinearPixels(0,iy,srcmap->Width(),fgnd64)!=1)
				goto done;
			x1 = srcmap->Width() - (int)(lerp * (float)srcmap->Width());
			x0 = max(srcmap->Width() - x1 - 1,0);
			if (x1) srcmap->PutPixels(x0,iy,x1,fgnd64);

		//-- Push Image Into Background - Right to Left (Layer) ------------

		} else if (data.type == IDC_LEFT && data.reverse && frgmap) {

			if (frgmap->GetLinearPixels(0,iy,srcmap->Width(),fgnd64)!=1)
				goto done;
		  	x1 = (int)(lerp * (float)srcmap->Width());
		  	x0 = max(srcmap->Width() - x1 - 1,0);
		  	if (x1) srcmap->PutPixels(x0,iy,x1,fgnd64);

		//-- Push Image Out of Background - Right to Left (Layer) ----------

		} else if (data.type == IDC_LEFT && !data.reverse && frgmap) {
	
			if (frgmap->GetLinearPixels(0,iy,srcmap->Width(),fgnd64)!=1)
				goto done;
			x1 = srcmap->Width() - (int)(lerp * (float)srcmap->Width());
			x0 = max(srcmap->Width() - x1 - 1,0);
			if (x1) srcmap->PutPixels(0,iy,x1,&fgnd64[x0]);

		//-- Push Black Into Background - Left to Right (Filter) -----------

		} else if (data.type == IDC_RIGHT && !data.reverse && !frgmap) {
     	   
			x1 = (int)(lerp * (float)srcmap->Width());
			x0 = max(srcmap->Width() - x1 - 1,0);
			if (x1) srcmap->PutPixels(0,iy,x1,&fgnd64[x0]);

		//-- Push Black Out of Background - Left to Right (Filter) ---------

		} else if (data.type == IDC_RIGHT && data.reverse && !frgmap) {

			x1 = srcmap->Width() - (int)(lerp * (float)srcmap->Width());
			x0 = max(srcmap->Width() - x1 - 1,0);
			if (x1) srcmap->PutPixels(x0,iy,x1,fgnd64);

		//-- Push Black Into Background - Right to Left (Filter) -----------

		} else if (data.type == IDC_LEFT && !data.reverse && !frgmap) {

		  	x1 = (int)(lerp * (float)srcmap->Width());
		  	x0 = max(srcmap->Width() - x1 - 1,0);
		  	if (x1) srcmap->PutPixels(x0,iy,x1,fgnd64);

		//-- Push Black Out of Background - Right to Left (Filter) ---------

		} else if (data.type == IDC_LEFT && data.reverse && !frgmap) {
	
			x1 = srcmap->Width() - (int)(lerp * (float)srcmap->Width());
			x0 = max(srcmap->Width() - x1 - 1,0);
			if (x1) srcmap->PutPixels(0,iy,x1,&fgnd64[x0]);
		
		}

	}
		
   	result = TRUE;

   	done:
     
   	if (line64)
   		free(line64);
        
   	if (fgnd64)
   		free(fgnd64);
        
   	return(result);

}

//-----------------------------------------------------------------------------
// #> ImageFilter_Wipe::LoadConfigure()

BOOL ImageFilter_Wipe::LoadConfigure ( void *ptr ) {
     WIPEDATA *buf = (WIPEDATA *)ptr;
     if (buf->version == WIPEVERSION) {
        memcpy((void *)&data,ptr,sizeof(WIPEDATA));
        return (TRUE);
     } else
        return (FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Wipe::SaveConfigure()

BOOL ImageFilter_Wipe::SaveConfigure ( void *ptr ) {
     if (ptr) {
        memcpy(ptr,(void *)&data,sizeof(WIPEDATA));
        return (TRUE);
     } else
        return (FALSE);
}

//-----------------------------------------------------------------------------
// #> ImageFilter_Wipe::EvaluateConfigure()

DWORD ImageFilter_Wipe::EvaluateConfigure ( ) {
      return (sizeof(WIPEDATA));
}

//-- EOF: Wipe.cpp ------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\GSphere\gsphere.cpp ===
/**********************************************************************
 *<
	FILE: gsphere2.cpp

	DESCRIPTION:  Geodesic Sphere Object
				  Edition 2 rewritten using ParamBlock2's

	CREATED BY: Steve Anderson
				Ed 2. John Wainwright

	HISTORY: created 12/18/95

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/
#include "prim.h"
#include "iparamm2.h"
#include "Simpobj.h"
#include "surf_api.h"

#define GSPHERE_CLASS_ID 0
#define PBLOCK_REF_NO	 0
ClassDesc* GetGSphereDesc();

// JBW: IParamArray has gone since the class variable UI paramters are stored in static ParamBlocks
//      all corresponding class vars have gone, including the ParamMaps since they are replaced 
//      by the new descriptors
class GSphereObject : public SimpleObject2
{
	public:	
		// Class vars
		static IObjParam *ip;
		static BOOL typeinCreate;

// JBW: minimal constructor, call MakeAutoParamBlocks() on my ClassDesc to
//      have all the declared per-instance P_AUTO_CONSTRUCT blocks made, initialized and
//      wired in.
		GSphereObject() { GetGSphereDesc()->MakeAutoParamBlocks(this); }
		
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam  *ip, ULONG flags, Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags, Animatable *next);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_GEOSPHERE); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
		
		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		void GetCollapseTypes(Tab<Class_ID> &clist, Tab<TSTR*> &nlist);

		// From GeomObject
		int IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm);
		
		// Animatable methods		
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return Class_ID(GSPHERE_CLASS_ID, 32670); } 
// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock2; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock2->ID() == id) ? pblock2 : NULL; } // return id'd ParamBlock

// JBW: the Load() post-load callback insertion has gone since versioning is 
//		handled automatically by virtue of permanent parameter IDs.  These IDs
//		are defined in enums and are never retired so that old versions can be
//		automatically re-mapped to new ones
//
//      Note that this is only true in new plug-ins; old plug-ins need to 
//		continue to support version re-mapping as before for version up until
//		converting to the new descriptors
		IOResult Load(ILoad *iload);
		
// JBW: all the IParamArray methods are gone since we don't need them for the class variables

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
// JBW: the GetParamName() and GetParamDim() function have gone	as this all 
//      is available in the descriptors. REFMSG_GET_PARAM_NAME, etc. become unnecessary as well
};

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

//--- ClassDescriptor and class vars ---------------------------------

// The class descriptor for gsphere
class GSphereClassDesc: public ClassDesc2 
{
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new GSphereObject; }
	const TCHAR *	ClassName() { return GetString(IDS_GEOSPHERE_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(GSPHERE_CLASS_ID, 32670); }
	const TCHAR* 	Category() { return GetString(IDS_RB_PRIMITIVES); }
// JBW:  the ResetClassParams() has gone since this is automatic now
//       using the default values in the descriptors

// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("GeoSphere"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
};

static GSphereClassDesc gsphereDesc;
ClassDesc* GetGSphereDesc() { return &gsphereDesc; }

IObjParam* GSphereObject::ip = NULL;
BOOL GSphereObject::typeinCreate       = FALSE;

// JBW:  all the old static class variables have gone, most now hosted in 
//       static param blocks

// Misc stuff
#define MAX_SEGMENTS	200
#define MIN_SEGMENTS	1

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float(1.0E30)

#define DEF_SEGMENTS	4
#define DEF_RADIUS		float(0.0)
#define DEF_BASETYPE	2
#define DEF_SMOOTH		1
#define DEF_HEMI		0
#define DEF_BASEPIVOT	0
#define DEF_MAPPING		0

// JBW: Here follows the new parameter block descriptors.  There are now 3, 
//      two new STATIC ones to hold the old class var parameters, one for the main
//		per-instance parameters.  Apart from all the extra 
//      metadata you see in the definitions, one important new idea is the
//      folding of ParamMap description info into the parameter descriptor and
//      providing a semi-automatic rollout desipaly mechanism.
//      

// Parameter Block definitions

// JBW: First come the position and version independent IDs for each
//      of the blocks and the parameters in each block.  These IDs are used
//	    in subsequent Get/SetValue() parameter access, etc. and for version-independent
//      load and save

// block IDs
enum { geo_creation_type, geo_type_in, geo_params, };
// geo_creation_type param IDs
enum { geo_create_meth, };
// geo_type_in param IDs
enum { geo_ti_pos, geo_ti_radius, };
// geo_param param IDs
enum { geo_radius, geo_segs, geo_type, geo_hemi, geo_smooth, geo_basepivot, geo_mapping, };

// JBW: here are the two static block descriptors.  This form of 
//      descriptor declaration uses a static NParamBlockDesc instance whose constructor
//      uses a varargs technique to walk through all the param definitions.
//      It has the advantage of supporting optional and variable type definitions, 
//      but may generate a tad more code than a simple struct template.  I'd
//      be interested in opinions about this.

//      I'll briefly describe the first definition so you can figure the others.  Note
//      that in certain places where strings are expected, you supply a string resource ID rather than
//      a string at it does the lookup for you as needed.
//
//		line 1: block ID, internal name, local (subanim) name, flags
//																 AUTO_UI here means the rollout will
//																 be automatically created (see BeginEditParams for details)
//      line 2: since AUTO_UI was set, this line gives: 
//				dialog resource ID, rollout title, flag test, appendRollout flags
//		line 3: required info for a parameter:
//				ID, internal name, type, flags, local (subanim) name
//		lines 4-6: optional parameter declaration info.  each line starts with a tag saying what
//              kind of spec it is, in this case default value, value range, and UI info as would
//              normally be in a ParamUIDesc less range & dimension
//	    the param lines are repeated as needed for the number of parameters defined.

// class creation type block
static ParamBlockDesc2 geo_crtype_blk ( geo_creation_type, _T("GeosphereCreationType"), 0, &gsphereDesc, P_CLASS_PARAMS + P_AUTO_UI, 
	//rollout
	IDD_GSPHERE1, IDS_CREATION_METHOD, BEGIN_EDIT_CREATE, 0, NULL,
	// params
	geo_create_meth,  _T("creationMethod"), 		TYPE_INT, 		0, IDS_CREATION_METHOD, 	 
		p_default, 		1, 
		p_range, 		0, 1, 
		p_ui, 			TYPE_RADIO, 	2, IDC_CREATEDIAMETER, IDC_CREATERADIUS, 
		end, 
	end
	);

// class type-in block
static ParamBlockDesc2 geo_typein_blk ( geo_type_in, _T("GeosphereTypeIn"),  0, &gsphereDesc, P_CLASS_PARAMS + P_AUTO_UI, 
	//rollout
	IDD_GSPHERE3, IDS_KEYBOARD_ENTRY, BEGIN_EDIT_CREATE, APPENDROLL_CLOSED, NULL,
	// params
	geo_ti_pos, 			_T("typeInPos"), 		TYPE_POINT3, 		0, 	IDS_RB_POS,
		p_default, 		Point3(0,0,0), 
		p_range, 		-99999999.0, 99999999.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_UNIVERSE, IDC_TI_POSX, IDC_TI_POSXSPIN, IDC_TI_POSY, IDC_TI_POSYSPIN, IDC_TI_POSZ, IDC_TI_POSZSPIN, SPIN_AUTOSCALE, 
		end, 
	geo_ti_radius, 		_T("typeInRadius"), 		TYPE_FLOAT, 		0, 	IDS_RB_RADIUS, 
		p_default, 		25.0, 
		p_range, 		MIN_RADIUS, MAX_RADIUS, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_UNIVERSE, IDC_RADIUS, IDC_RADSPINNER, SPIN_AUTOSCALE, 
		end, 
	end
	);

// JBW: this descriptor defines the main per-instance parameter block.  It is flagged as AUTO_CONSTRUCT which
//      means that the CreateInstance() will automatically create one of these blocks and set it to the reference
//      number given (0 in this case, as seen at the end of the line).

// per instance geosphere block
static ParamBlockDesc2 geo_param_blk ( geo_params, _T("GeosphereParameters"),  0, &gsphereDesc, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF_NO, 
	//rollout
	IDD_GSPHERE2, IDS_PARAMETERS, 0, 0, NULL,
	// params
	geo_hemi, 	_T("hemisphere"),		TYPE_BOOL, 		P_ANIMATABLE,				IDS_HEMI,
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_HEMI, 
		end, 
	geo_segs, 	_T("segs"), 			TYPE_INT, 		P_ANIMATABLE, 	IDS_RB_SEGS, 
		p_default, 		4, 
		p_range, 		MIN_SEGMENTS, MAX_SEGMENTS, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_SEGMENTS, IDC_SEGSPINNER, 0.05f, 
		end, 
	geo_radius,  _T("radius"), 			TYPE_FLOAT, 	P_ANIMATABLE + P_RESET_DEFAULT, 	IDS_RB_RADIUS, 
		p_default, 		0.0,	
		p_ms_default,	25.0,
		p_range, 		MIN_RADIUS, MAX_RADIUS, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_UNIVERSE, IDC_RADIUS, IDC_RADSPINNER, SPIN_AUTOSCALE, 
		end, 
	geo_type, 	_T("baseType"),			TYPE_INT, 		0,				IDS_BASETYPE,
		p_default, 		2, 
		p_range, 		0, 2, 
		p_ui, 			TYPE_RADIO, 	3, IDC_TETRA, IDC_OCTA, IDC_ICOSA, 
		end, 
	geo_basepivot, 	_T("baseToPivot"), 	TYPE_BOOL, 		0,				IDS_BASEPIVOT, 
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_BASEPIVOT, 
		end, 
	geo_smooth, 	_T("smooth"), 		TYPE_BOOL, 		P_ANIMATABLE,				IDS_RB_SMOOTH,
		p_default, 		TRUE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_OBSMOOTH, 
		end, 
	geo_mapping, 	_T("mapCoords"), 	TYPE_BOOL, 		0,				IDS_MAPPING,
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_MAPPING, 
		end, 
	end
	);

// JBW: pre-ParamBlock2 version info, similar to old scheme except here we
//      install ParamBlockDesc2 parameter IDs into the ParamBlockDescIDs for
//      each version so the post-load callback can do the right mapping to the new ParamBlock2
#define NUM_OLDVERSIONS	3

static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, geo_radius },		
	{ TYPE_INT, NULL, TRUE,   geo_segs },
	{ TYPE_INT, NULL, FALSE,  geo_type },
	{ TYPE_INT, NULL, FALSE,  geo_smooth }
};

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, geo_radius },		
	{ TYPE_INT, NULL, TRUE,   geo_segs },
	{ TYPE_INT, NULL, FALSE,  geo_type },
	{ TYPE_INT, NULL, FALSE,  geo_hemi },
	{ TYPE_INT, NULL, FALSE,  geo_smooth }
};

static ParamBlockDescID descVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, geo_radius },
	{ TYPE_INT, NULL, TRUE,   geo_segs },
	{ TYPE_INT, NULL, FALSE,  geo_type },
	{ TYPE_INT, NULL, FALSE,  geo_hemi },
	{ TYPE_INT, NULL, FALSE,  geo_smooth },
	{ TYPE_INT, NULL, FALSE,  geo_basepivot },
	{ TYPE_INT, NULL, FALSE,  geo_mapping }
};
#define PBLOCK_LENGTH	7  

// Array of old ParamBlock Ed. 1 versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc (descVer0, 4, 0),
	ParamVersionDesc (descVer1, 5, 1),
	ParamVersionDesc (descVer2, 7, 2),
};

// JBW:  for loading old ParamBlock versions, register an Ed. 2 param block converter post-load callback
//       This one takes the ParamBlockDescID version array as before, but now takes the 
//       ParamBlockDesc2 for the block to describe the current version and will convert the loaded ParamBlock
//       into a corresponding ParamBlock2
IOResult
GSphereObject::Load(ILoad *iload) 
{	
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, NUM_OLDVERSIONS, &geo_param_blk, this, PBLOCK_REF_NO);
	iload->RegisterPostLoadCallback(plcb);
	return IO_OK;
}

//--- TypeInDlgProc --------------------------------
class GSphereTypeInDlgProc : public ParamMap2UserDlgProc {
public:
	GSphereObject *so;

	GSphereTypeInDlgProc(GSphereObject *s) {so=s;}
	BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	void DeleteThis() {delete this;}
};

BOOL GSphereTypeInDlgProc::DlgProc(
		TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	if (msg != WM_COMMAND) return FALSE;
	if (LOWORD(wParam) != IDC_TI_CREATE) return FALSE;
// JBW: access to STATIC paramblock data is via functions on
//      on the descriptor
	if (geo_typein_blk.GetFloat(geo_ti_radius) == 0.0) return TRUE;
	
	// We only want to set the value if the object is 
	// not in the scene.
	if (so->TestAFlag(A_OBJ_CREATING)) {
		so->pblock2->SetValue(geo_radius, 0, geo_typein_blk.GetFloat(geo_ti_radius));
		}
	so->typeinCreate = TRUE;

	Matrix3 tm(1);
	tm.SetTrans(geo_typein_blk.GetPoint3(geo_ti_pos));
	so->suspendSnap = FALSE;
	so->ip->NonMouseCreate(tm);
	// NOTE that calling NonMouseCreate will cause this
	// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
	return TRUE;	
}

//--- GSphere methods -------------------------------

// JBW: the GeoSphere constructor has gone.  The paramblock creation and wiring and
//		the intial value setting is automatic now.

// JBW: BeginEditParams() becomes much simpler with automatic UI param blocks.
//      you redirect the BeginEditParams() to the ClassDesc instance and it
//      throws up the appropriate rollouts.

void GSphereObject::BeginEditParams(IObjParam *ip, ULONG flags, Animatable *prev)
{
	SimpleObject::BeginEditParams(ip, flags, prev);
	this->ip = ip;

	// If this has been freshly created by type-in, set creation values:
	if (typeinCreate) {
		pblock2->SetValue (geo_radius, 0, geo_typein_blk.GetFloat(geo_ti_radius));
		typeinCreate = FALSE;
	}

	// throw up all the appropriate auto-rollouts
	gsphereDesc.BeginEditParams(ip, this, flags, prev);
	// install a callback for the type in.
	geo_typein_blk.SetUserDlgProc(new GSphereTypeInDlgProc(this));
}
		
// JBW: similarly for EndEditParams and you also don't have to snapshot
//		current parameter values as initial values for next object as
//		this is automatic for the new ParamBlock params unless disabled.

void GSphereObject::EndEditParams(IObjParam *ip, ULONG flags, Animatable *next)
{		
	SimpleObject::EndEditParams(ip, flags, next);
	this->ip = NULL;
	// tear down the appropriate auto-rollouts
	gsphereDesc.EndEditParams(ip, this, flags, next);
}

// CONSTRUCTING THE MESH:

// To construct a geodesic sphere, we take a tetrahedron, subdivide each face into
// segs^2 faces, and project the vertices onto the sphere of the correct radius.

// This subdivision produces 3 kinds of vertices: 4 "corner" vertices, which are the
// original tetrahedral vertices; "edge" vertices, those that lie on the tetrahedron's
// edges, and "face" vertices.  There are 6 edges with (segs-1) verts on each, and
// 4 faces with (segs-1)*(segs-2)/2 verts.

// We construct these vertices in this order: the first four are the corner vertices.
// Then we use spherical interpolation to place edge vertices along each edge.
// Finally, we use the same interpolation to produce face vertices between the edge
// vertices.


// Assumed in the following function: the vertices have the same radius, or
// distance from the origin, and they have nontrivial cross product.

void SphericalInterpolate (Mesh& amesh, int v1, int v2, int *current, int num)
	{
	int i;
	float theta, theta1, theta2, sn, cs, rad;
	Point3 a, b, c;

	if (num<2) { return; }
	a=amesh.getVert (v1);
	b=amesh.getVert (v2);
	rad = DotProd (a, a);
	if (rad==0) {
		for (i=1; i<num; i++) amesh.setVert ((*current)++, a);
		return;
	}
	cs = DotProd (a, b) / rad;
	LimitValue (cs, -1.0f, 1.0f);
	theta = (float) acos (cs);
	sn = Sin (theta);

	for (i=1; i<num; i++) {
		theta1 = (theta*i)/num;
		theta2 = (theta*(num-i))/num;
		c = (a*Sin(theta2) + b*Sin(theta1))/sn;
		amesh.setVert ((*current)++, c);
	}
}

// The order we produced the verts in makes for difficult face construction.  Thus
// we use the following functions to find the index of the vertex in a given row, 
// given column, of a given basetype face.

// (Each face is viewed as a triangular grid of vertices.  The orientation of the
// triangle is such that it "points up", so rows are "horizontal" while columns
// are diagonal: column 0 is the left edge of the triangle.)

int tetra_find_vert_index (int s, int f, int r, int c)
{						// segs, face, row, column.
	if (r==0) {
		if (f<3) { return 0; }
		else { return 1; }
	}
	
	if (c==0) {
		if (r==s) {
			if (f<3) { return f+1; }
			else { return 3; }
		}
		if (f<3) { return 4+(s-1)*f+r-1; }
		else { return 4+(s-1)*4+r-1; }
	}

	if (c==r) {
		if (r==s) {
			if (f<3) { return (f+1)%3+1; }
			else { return 2; }
		}
		else {
			if (f<3) { return 4+(s-1)*((f+1)%3)+r-1; }
			else { return 4+(s-1)*3+r-1; }
		}
	}

	if (r==s) {
		switch (f) {
		case 0: return 4+(s-1)*3 + c-1;
		case 1: return 4+(s-1)*5 + c-1;
		case 2:	return 4+(s-1)*4 + s-1-c;
		case 3:	return 4+(s-1)*5 + s-1-c;
		}
	}
	
	return 4 + (s-1)*6 + f*(s-1)*(s-2)/2 + (r-2)*(r-1)/2 + c-1;
}

int hemi_tetra_find_vert_index (int s, int f, int r, int c)
{								// segs, face, row, column.
	if (r==0) return 0;
	
	if (c==0) {
		if (r==s) return f+1;
		return 4+(s-1)*f+r-1;
	}

	if (c==r) {
		if (r==s) return (f+1)%3+1;
		return 4+(s-1)*((f+1)%3)+r-1;
	}

	if (r==s) return 4 + (s-1)*(f+3) + c-1;
	
	return 4 + (s-1)*6 + f*(s-1)*(s-2)/2 + (r-2)*(r-1)/2 + c-1;
}

int octa_find_vert_index (int s, int f, int r, int c)
{						// segs, face, row, column.

	if (r==0) { // Top corner of face
		if (f<4) return 0;
		return 5;
	}

	if (r==s) {
		if (((f<4)&&(c==0)) || ((f>3)&&(c==r))) return f%4+1;
		if (((f>3)&&(c==0)) || ((f<4)&&(c==r))) return (f+1)%4+1;
		if (f<4) return 6+(s-1)*(8+f)+c-1;
		return 6+(s-1)*(4+f)+s-1-c;
	}

	if (c==0) {  // r is between 0 and s.
		if (f<4) return 6+(s-1)*f + r-1;
		return 6+(s-1)*((f+1)%4+4) + r-1;
	}
	
	if (c==r) {
		if (f<4) return 6+(s-1)*((f+1)%4) + r-1;
		return 6+(s-1)*f + r-1;
	}

	return 6 + (s-1)*12 + f*(s-1)*(s-2)/2 + (r-1)*(r-2)/2 + c-1;
}

int hemi_octa_find_vert_index (int s, int f, int r, int c)
{								// segs, face, row, column.
	if (r==0) return 0;

	if (r==s) {	// Bottom row.
		if (c==0) return f+1;
		if (c==r) return (f+1)%4+1;
		return 5+(s-1)*(4+f)+c-1;
	}

	if (c==0) return 5+(s-1)*f + r-1;
	if (c==r) return 5+(s-1)*((f+1)%4) + r-1;

	return 5 + (s-1)*8 + f*(s-1)*(s-2)/2 + (r-1)*(r-2)/2 + c-1;
}

int icosa_find_vert_index (int s, int f, int r, int c)
{							// segs, face, row, column

	if (r==0) {	// Top corner of face
		if (f<5) { return 0; }
		if (f>14) { return 11; }
		return f-4;
	}

	if ((r==s) && (c==0)) { // Lower left corner of face
		if (f<5) { return f+1; }
		if (f<10) { return (f+4)%5 + 6; }
		if (f<15) { return (f+1)%5 + 1; }
		return (f+1)%5 + 6;
	}
	
	if ((r==s) && (c==s)) { // Lower right corner
		if (f<5) { return (f+1)%5+1; }
		if (f<10) { return f+1; }
		if (f<15) { return f-9; }
		return f-9;
	}

	if (r==s) { // Bottom edge
		if (f<5) { return 12 + (5+f)*(s-1) + c-1; }
		if (f<10) { return 12 + (20+(f+4)%5)*(s-1) + c-1; }
		if (f<15) { return 12 + (f-5)*(s-1) + s-1-c; }
		return 12 + (5+f)*(s-1) + s-1-c;
	}

	if (c==0) { // Left edge
		if (f<5) { return 12 + f*(s-1) + r-1; }
		if (f<10) { return 12 + (f%5+15)*(s-1) + r-1; }
		if (f<15) { return 12 + ((f+1)%5+15)*(s-1) + s-1-r; }
		return 12 + ((f+1)%5+25)*(s-1) + r-1;
	}

	if (c==r) { // Right edge
		if (f<5) { return 12 + ((f+1)%5)*(s-1) + r-1; }
		if (f<10) { return 12 + (f%5+10)*(s-1) + r-1; }
		if (f<15) { return 12 + (f%5+10)*(s-1) + s-1-r; }
		return 12 + (f%5+25)*(s-1) + r-1;
	}
	
	// Not an edge or corner.
	return 12 + 30*(s-1) + f*(s-1)*(s-2)/2 + (r-1)*(r-2)/2 + c-1;
}

int hemi_icosa_find_vert_index (int s, int f, int r, int c)
{								// segs, face, row, column
	int frow = f/5, f0=f%5, f1=(f+1)%5, f4=(f+4)%5;
	int grow = f/10, g0=f%10, g1=(f+1)%10, g9=(f+9)%10;
	int parity = f%2, h0=g0/2, h1=(h0+1)%5, h4=(h0+4)%5;

	if (r==0) {	// Top corner of face
		switch (grow) {
		case 0: return frow ? f0+11 : 0;
		case 1: return h0 + 1;
		case 2:	return g0 + 16;
		case 3:	return parity ? h0+11 : h0+6;
		}
	}

	if ((r==s) && (c==0)) { // Lower left corner of face
		switch (grow) {
		case 0:	return frow ? f1+1 : f0+1;
		case 1:	return parity ? h0+6 : h4+11;
		case 2:	return parity ? h1+6 : h0+11;
		case 3:	return g9+16;
		}
	}

	if ((r==s) && (c==s)) { // Lower right corner
		switch (grow) {
		case 0: return frow ? f0+1 : f1+1;
		case 1: return parity ? h0+11 : h0+6;
		case 2: return parity ? h0+11 : h0+6;
		case 3: return g0+16;
		}
	}

	if (r==s) { // Bottom edge
		switch (grow) {
		case 0:
			if (frow)	return 26 + (5+f0)*(s-1) + s-1-c;
						return 26 + (5+f0)*(s-1) + c-1;
		case 1:
			if (parity)	return 26 + (h0+25)*(s-1) + c-1;
						return 26 + (h0+30)*(s-1) + c-1;
		case 2:
			if (parity) return 26 + (h1+30)*(s-1) + s-1-c;
						return 26 + (h0+25)*(s-1) + s-1-c;
		case 3:			return 26 + (g9+55)*(s-1) + c-1;
		}
	}

	if (c==0) { // Left edge
		switch (grow) {
		case 0:
			if (frow)	return 26 + (20+f1)*(s-1) + s-1-r;
						return 26 + f0*(s-1) + r-1;
		case 1:
			if (parity)	return 26 + (h0+10)*(s-1) + r-1;
						return 26 + (h0+20)*(s-1) + r-1;
		case 2:
			if (parity)	return 26 + (38+h0*4)*(s-1) + s-1-r;
						return 26 + (36+h0*4)*(s-1) + s-1-r;
		case 3:			return 26 + (g9*2+36)*(s-1) + r-1;
		}
	}

	if (c==r) { // Right edge
		switch (grow) {
		case 0:
			if (frow)	return 26 + (15+f0)*(s-1) + s-1-r;
						return 26 +	f1*(s-1) + r-1;
		case 1:
			if (parity)	return 26 + (h0+15)*(s-1) + r-1;
						return 26 + (h0+10)*(s-1) + r-1;
		case 2:
			if (parity)	return 26 + (37+h0*4)*(s-1) + s-1-r;
						return 26 + (35+h0*4)*(s-1) + s-1-r;
		case 3:			return 26 + (g0*2+35)*(s-1) + r-1;
		}
	}
	
	// Not an edge or corner.
	return 26 + 65*(s-1) + f*(s-1)*(s-2)/2 + (r-1)*(r-2)/2 + c-1;
}

int find_vert_index (int basetype, int segs, int face, int row, int column)
{
	switch (basetype) {
	case 0: return tetra_find_vert_index (segs, face, row, column);
	case 1: return hemi_tetra_find_vert_index (segs, face, row, column);
	case 2: return octa_find_vert_index (segs, face, row, column);
	case 3: return hemi_octa_find_vert_index (segs, face, row, column);
	case 4: return icosa_find_vert_index (segs, face, row, column);
	default: return hemi_icosa_find_vert_index (segs, face, row, column);
	}
}


BOOL GSphereObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock2->GetValue(geo_mapping, 0, genUVs, v);
	return genUVs; 
	}

void GSphereObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock2->SetValue(geo_mapping, 0, sw);				
	}


// Now put it all together sensibly
#define EPSILON 1e-5f
void GSphereObject::BuildMesh(TimeValue t)
	{
	int i;
	int nf=0, nv=0;
	int segs, basetype, nverts, nfaces, nsections;
	int row, column, face, a, b, c, d;
	float radius, subrad, subz, theta, sn, cs;
	BOOL smooth, hemi, tverts, basePivot;

	// Start the validity interval at forever and whittle it down.
	ivalid = FOREVER;
	pblock2->GetValue(geo_radius, t, radius, ivalid);
	pblock2->GetValue(geo_segs, t, segs, ivalid);
	pblock2->GetValue(geo_hemi, t, hemi, ivalid);
	pblock2->GetValue(geo_smooth, t, smooth, ivalid);
	pblock2->GetValue(geo_type, t, basetype, ivalid);
	pblock2->GetValue(geo_basepivot, t, basePivot, ivalid);
	pblock2->GetValue(geo_mapping, t, tverts, ivalid);
	LimitValue(segs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(radius, MIN_RADIUS, MAX_RADIUS);
	
	basetype = basetype*2 + hemi;

	switch (basetype) {
		case 0:  nsections = 4;  break;
		case 1:  nsections = 3;  break;
		case 2:  nsections = 8;  break;
		case 3:  nsections = 4;  break;
		case 4:  nsections = 20; break;
		default: nsections = 40; break;
	}

	if (hemi) {
		nfaces = nsections * segs*segs + ((basetype==5) ? (segs*10) : (segs*nsections));
		nverts = nsections * (segs-1)*(segs-2)/2 + 1;	// face verts, including origin.
		switch (basetype) {
		case 1:
			nverts += 6*(segs-1) + 4;
			break;
		case 3:
			nverts += 8*(segs-1) + 5;
			break;
		case 5:
			nverts += 65*(segs-1) + 26;
			break;
		}
	} else {
		nfaces = nsections * segs * segs;
		nverts = nfaces/2 + 2;
	}
	
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	mesh.setSmoothFlags(smooth != 0);
	mesh.setNumTVerts (0);
	mesh.setNumTVFaces (0);

	switch (basetype) {
	case 0: // Based on tetrahedron
		// First four tetrahedral vertices 
		mesh.setVert (nv++, (float)0.0, (float)0.0, radius);
		mesh.setVert (nv++, radius*(Sqrt(8.f/9.f)), (float)0.0, -radius/((float)3.));
		mesh.setVert (nv++, -radius*(Sqrt(2.f/9.f)), radius*(Sqrt(2.f/3.f)), -radius/((float)3.));
		mesh.setVert (nv++, -radius*(Sqrt(2.f/9.f)), -radius*(Sqrt(2.f/3.f)), -radius/((float)3.));

		// Edge vertices
		SphericalInterpolate (mesh, 0, 1, &nv, segs);
		SphericalInterpolate (mesh, 0, 2, &nv, segs);
		SphericalInterpolate (mesh, 0, 3, &nv, segs);
		SphericalInterpolate (mesh, 1, 2, &nv, segs);
		SphericalInterpolate (mesh, 1, 3, &nv, segs);
		SphericalInterpolate (mesh, 2, 3, &nv, segs);

		// Face vertices
		for (i=1; i<segs-1; i++) SphericalInterpolate (mesh, 4+i, 4+(segs-1)+i, &nv, i+1);
		for (i=1; i<segs-1; i++) SphericalInterpolate (mesh, 4+(segs-1)+i, 4+2*(segs-1)+i, &nv, i+1);
		for (i=1; i<segs-1; i++) SphericalInterpolate (mesh, 4+2*(segs-1)+i, 4+i, &nv, i+1);
		for (i=1; i<segs-1; i++) SphericalInterpolate (mesh, 4+4*(segs-1)+i, 4+3*(segs-1)+i, &nv, i+1);
		break;

	case 1:	// Hemi-tetrahedron
		// Modified four tetrahedral verts.  (Yes, I'm making this up -- no, it's not really geodesic)
		mesh.setVert (nv++, 0.0f, 0.0f, radius);
		mesh.setVert (nv++, radius, 0.0f, 0.0f);
		mesh.setVert (nv++, -radius/2.0f, radius*(Sqrt(.75)), 0.0f);
		mesh.setVert (nv++, -radius/2.0f, -radius*(Sqrt(.75)), 0.0f);

		// Edge Vertices
		SphericalInterpolate (mesh, 0, 1, &nv, segs);
		SphericalInterpolate (mesh, 0, 2, &nv, segs);
		SphericalInterpolate (mesh, 0, 3, &nv, segs);
		SphericalInterpolate (mesh, 1, 2, &nv, segs);
		SphericalInterpolate (mesh, 2, 3, &nv, segs);
		SphericalInterpolate (mesh, 3, 1, &nv, segs);

		// Face vertices
		for (i=1; i<segs-1; i++) SphericalInterpolate (mesh, 4+i, 4+(segs-1)+i, &nv, i+1);
		for (i=1; i<segs-1; i++) SphericalInterpolate (mesh, 4+(segs-1)+i, 4+2*(segs-1)+i, &nv, i+1);
		for (i=1; i<segs-1; i++) SphericalInterpolate (mesh, 4+2*(segs-1)+i, 4+i, &nv, i+1);

		// Last point:
		mesh.setVert (nv++, 0.0f, 0.0f, 0.0f);

		break;

	case 2: //Based on the Octahedron
		// First 6 octahedral vertices
		mesh.setVert (nv++, (float)0, (float)0, radius);
		mesh.setVert (nv++, radius, (float)0, (float)0);
		mesh.setVert (nv++, (float)0, radius, (float)0);
		mesh.setVert (nv++, -radius, (float)0, (float)0);
		mesh.setVert (nv++, (float)0, -radius, (float)0);
		mesh.setVert (nv++, (float)0, (float)0, -radius);

		// Edge vertices
		for (face=0; face<4; face++) SphericalInterpolate (mesh, 0, face+1, &nv, segs);
		for (face=0; face<4; face++) SphericalInterpolate (mesh, 5, face+1, &nv, segs);
		for (face=0; face<4; face++) SphericalInterpolate (mesh, face+1, (face+1)%4+1, &nv, segs);

		// Face vertices
		for (face=0; face<4; face++) {
			for (i=1; i<segs-1; i++) {
				SphericalInterpolate (mesh, 6+face*(segs-1)+i, 6+((face+1)%4)*(segs-1)+i, &nv, i+1);
			}
		}
		for (face=0; face<4; face++) {
			for (i=1; i<segs-1; i++) {
				SphericalInterpolate (mesh, 6+((face+1)%4+4)*(segs-1)+i, 6+(face+4)*(segs-1)+i, &nv, i+1);
			}
		}
		break;

	case 3: // Hemioctahedron -- this one's perfect every time.
		// First 5 octahedral vertices
		mesh.setVert (nv++, (float)0, (float)0, radius);
		mesh.setVert (nv++, radius, (float)0, (float)0);
		mesh.setVert (nv++, (float)0, radius, (float)0);
		mesh.setVert (nv++, -radius, (float)0, (float)0);
		mesh.setVert (nv++, (float)0, -radius, (float)0);

		// Edge vertices
		for (face=0; face<4; face++) SphericalInterpolate (mesh, 0, face+1, &nv, segs);
		for (face=0; face<4; face++) SphericalInterpolate (mesh, face+1, (face+1)%4+1, &nv, segs);

		// Face vertices
		for (face=0; face<4; face++) {
			for (i=1; i<segs-1; i++) {
				SphericalInterpolate (mesh, 5+face*(segs-1)+i, 5+((face+1)%4)*(segs-1)+i, &nv, i+1);
			}
		}

		// Last point:
		mesh.setVert (nv++, 0.0f, 0.0f, 0.0f);
		break;

	case 4:  // Based on the Icosahedron
		// First 12 icosahedral vertices
		mesh.setVert (nv++, (float)0, (float)0, radius);
		subz = Sqrt (.2f) * radius;
		subrad = 2*subz;
		for (face=0; face<5; face++) {
			theta = 2*PI*face/5;
			SinCos (theta, &sn, &cs);
			mesh.setVert (nv++, subrad*cs, subrad*sn, subz);
		}
		for (face=0; face<5; face++) {
			theta = PI*(2*face+1)/5;
			SinCos (theta, &sn, &cs);
			mesh.setVert (nv++, subrad*cs, subrad*sn, -subz);
		}
 		mesh.setVert (nv++, (float)0, (float)0, -radius);

		// Edge vertices: 6*5*(segs-1) of these.
		for (face=0; face<5; face++) SphericalInterpolate (mesh, 0, face+1, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, face+1, (face+1)%5+1, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, face+1, face+6, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, face+1, (face+4)%5+6, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, face+6, (face+1)%5+6, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, 11, face+6, &nv, segs);
		
		// Face vertices: 4 rows of 5 faces each.
		for (face=0; face<5; face++) {
			for (i=1; i<segs-1; i++) {
				SphericalInterpolate (mesh, 12+face*(segs-1)+i, 12+((face+1)%5)*(segs-1)+i, &nv, i+1);
			}
		}	
		for (face=0; face<5; face++) {
			for (i=1; i<segs-1; i++) {
				SphericalInterpolate (mesh, 12+(face+15)*(segs-1)+i, 12+(face+10)*(segs-1)+i, &nv, i+1);
			}
		}	
		for (face=0; face<5; face++) {
			for (i=1; i<segs-1; i++) {
				SphericalInterpolate (mesh, 12+((face+1)%5+15)*(segs-1)+segs-2-i, 12+(face+10)*(segs-1)+segs-2-i, &nv, i+1);
			}
		}	
		for (face=0; face<5; face++) {
			for (i=1; i<segs-1; i++) {
				SphericalInterpolate (mesh, 12+((face+1)%5+25)*(segs-1)+i, 12+(face+25)*(segs-1)+i, &nv, i+1);
			}
		}
		break;	

	case 5:  // HemiIcosahedron, based loosely on a segs-2 icosahedron
		// First 26 icosahedral vertices: 
		mesh.setVert (nv++, 0.0f, 0.0f, radius);
		subz = Sqrt (.2f) * radius;
		subrad = 2*subz;
		for (face=0; face<5; face++) {
			theta = 2*PI*face/5.0f;
			SinCos (theta, &sn, &cs);
			mesh.setVert (face+6, subrad*cs, subrad*sn, subz);
			SphericalInterpolate (mesh, 0, face+6, &nv, 2);
		}
		nv += 5;
		for (face=0; face<5; face++) SphericalInterpolate (mesh, face+6, (face+1)%5+6, &nv, 2);
		for (face=0; face<10; face++) {
			theta = 2*PI*face/10.0f + PI/10.0f;
			SinCos (theta, &sn, &cs);
			mesh.setVert (nv++, radius*cs, radius*sn, 0.0f);
		}

		// Edge vertices: 13*5*(segs-1) of these.
		for (face=0; face<5; face++) SphericalInterpolate (mesh, 0, face+1, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, face+1, (face+1)%5+1, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, face+1, face+6, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, face+1, face+11, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, face+1, (face+4)%5+11, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, face+6, face+11, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, (face+4)%5+11, face+6, &nv, segs);
		for (face=0; face<5; face++) {
			SphericalInterpolate (mesh, face+6, face*2+16, &nv, segs);
			SphericalInterpolate (mesh, face+11, face*2+16, &nv, segs);
			SphericalInterpolate (mesh, face+11, face*2+17, &nv, segs);
			SphericalInterpolate (mesh, (face+1)%5+6, face*2+17, &nv, segs);
		}
		for (face=0; face<10; face++) SphericalInterpolate (mesh, face+16, (face+1)%10+16, &nv, segs);
		
		// Face vertices: representing 40 faces, 8 groups of 5.
		for (face=0; face<5; face++) {	// Top 5:
			for (i=1; i<segs-1; i++) {
				SphericalInterpolate (mesh, 26+face*(segs-1)+i, 26+((face+1)%5)*(segs-1)+i, &nv, i+1);
			}
		}	
		for (face=0; face<5; face++) {	// Stellation of above
			for (i=1; i<segs-1; i++) {
				SphericalInterpolate (mesh, 26+((face+1)%5+20)*(segs-1)+segs-2-i, 26+(face+15)*(segs-1)+segs-2-i, &nv, i+1);
			}
		}	
		for (face=0; face<5; face++) {	// Rest of this level
			for (i=1; i<segs-1; i++) {
				SphericalInterpolate (mesh, 26+(face+20)*(segs-1)+i, 26+(face+10)*(segs-1)+i, &nv, i+1);
			}
			for (i=1; i<segs-1; i++) {
				SphericalInterpolate (mesh, 26+(face+10)*(segs-1)+i, 26+(face+15)*(segs-1)+i, &nv, i+1);
			}
		}	
		for (face=0; face<10; face++) {	// Downward-pointing faces in lowest level
			for (i=1; i<segs-1; i++) {
				SphericalInterpolate (mesh, 26+(face*2+36)*(segs-1)+segs-2-i, 26+(face*2+35)*(segs-1)+segs-2-i, &nv, i+1);
			}
		}
		for (face=0; face<10; face++) {	// Upward-pointing faces in lowest level
			int f9 = (face+9)%10;
			for (i=1; i<segs-1; i++) {
				SphericalInterpolate (mesh, 26+(f9*2+36)*(segs-1)+i, 26+(face*2+35)*(segs-1)+i, &nv, i+1);
			}
		}

		mesh.setVert (nv++, 0.0f, 0.0f, 0.0f);
		break;	
	}

	// Now make faces 
	// Set all smoothing, edge flags
	for (i=0; i<nfaces; i++) mesh.faces[i].setEdgeVisFlags(1, 1, 1);
	if (!smooth) for (i=0; i<nfaces; i++) mesh.faces[i].setSmGroup (0);
	else {
		if (hemi) {
			int sp_faces = nsections*segs*segs;
			for (i=0; i<sp_faces; i++) {
				mesh.faces[i].setSmGroup (1);
				mesh.faces[i].setMatID (1);
			}
			for (; i<nfaces; i++) {
				mesh.faces[i].setSmGroup (2);
				mesh.faces[i].setMatID (0);
			}
		} else {
			for (i=0; i<nfaces; i++) {
				mesh.faces[i].setSmGroup(1);
				mesh.faces[i].setMatID (1);
			}
		}
	}

	for (face=0; face<nsections; face++) {
		for (row=0; row<segs; row++) {
			for (column=0; column<=row; column++) {
				a = find_vert_index (basetype, segs, face, row, column);
				b = find_vert_index (basetype, segs, face, row+1, column);
				c = find_vert_index (basetype, segs, face, row+1, column+1);
				mesh.faces[nf].setVerts (a, b, c);
				nf++;
				if (column<row) {
					d = find_vert_index (basetype, segs, face, row, column+1);
					mesh.faces[nf].setVerts (a, c, d);
					nf++;
				}
			}
		}
	}
	
	if (hemi) {
		int bfaces, bfoffset;
		switch (basetype) {
		case 1: bfaces=3, bfoffset=0; break;
		case 3: bfaces=4, bfoffset=0; break;
		case 5: bfaces=10, bfoffset=30; break;
		}
		for (face=0; face<bfaces; face++) {
			for (column=0; column<segs; column++) {
				a = find_vert_index (basetype, segs, face+bfoffset, segs, column);
				b = find_vert_index (basetype, segs, face+bfoffset, segs, column+1);
				c = nv-1;
				mesh.faces[nf].setVerts (b, a, c);
				nf++;
			}
		}
	}

	// Textured verts, if required: do standard spherical deal.
	Matrix3 id(1);
	if (tverts) mesh.ApplyUVWMap (MAP_SPHERICAL, 1.0f, 1.0f, 1.0f, 0, 0, 0, 0, id);

	if (basePivot && (!hemi)) for (i=0; i<nverts; i++) mesh.verts[i].z += radius;

	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
}

class GSphereObjCreateCallBack : public CreateMouseCallBack {
	IPoint2 sp0;
	GSphereObject *ob;
	Point3 p0;
public:
	int proc( ViewExp *vpt, int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	void SetObj(GSphereObject *obj) {ob = obj;}
};

int GSphereObjCreateCallBack::proc(ViewExp *vpt, int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;
	Point3 p1, center;

	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m, m, NULL, SNAP_IN_3D);
	}


	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
		case 0:  // only happens with MOUSE_POINT msg
			ob->suspendSnap = TRUE;				
			sp0 = m;
			p0 = vpt->SnapPoint(m, m, NULL, SNAP_IN_3D);
			mat.SetTrans(p0);
			break;
		case 1:
			mat.IdentityMatrix();
			if (geo_crtype_blk.GetInt(geo_create_meth)) {
				p1 = vpt->SnapPoint(m, m, NULL, SNAP_IN_3D);
				r = Length(p1-p0);
				mat.SetTrans(p0);
			} else {
				p1 = vpt->SnapPoint(m, m, NULL, SNAP_IN_3D);
				center = (p0+p1)/float(2);
				mat.SetTrans(center);
				r = Length(center-p0);
				mat.SetTrans(center);
			} 
			ob->pblock2->SetValue(geo_radius, 0, r);
			geo_param_blk.InvalidateUI();

			if (flags&MOUSE_CTRL) {
				float ang = (float)atan2(p1.y-p0.y, p1.x-p0.x);					
				mat.PreRotateZ(ob->ip->SnapAngle(ang));
			}

			if (msg==MOUSE_POINT) {
				ob->suspendSnap = FALSE;
				return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
			}
			break;					   
		}
	} else {
		if (msg == MOUSE_ABORT) return CREATE_ABORT;
	}

	return TRUE;
}

static GSphereObjCreateCallBack gsphereCreateCB;

CreateMouseCallBack* GSphereObject::GetCreateMouseCallBack() 
	{
	gsphereCreateCB.SetObj(this);
	return(&gsphereCreateCB);
	}


BOOL GSphereObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock2->GetValue(geo_radius, t, radius, FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}

// From GeomObject
int GSphereObject::IntersectRay(
		TimeValue t, Ray& ray, float& at, Point3& norm)
	{
	int smooth;
	pblock2->GetValue(geo_smooth, t, smooth, FOREVER);
	if (!smooth) {
		return SimpleObject::IntersectRay(t, ray, at, norm);
		}	
	
	float r;
	float a, b, c, ac4, b2, at1, at2;
	float root;
	BOOL neg1, neg2;

	pblock2->GetValue(geo_radius, t, r, FOREVER);

	a = DotProd(ray.dir, ray.dir);
	b = DotProd(ray.dir, ray.p) * 2.0f;
	c = DotProd(ray.p, ray.p) - r*r;
	
	ac4 = 4.0f * a * c;
	b2 = b*b;

	if (ac4 > b2) return 0;

	// We want the smallest positive root
	root = Sqrt(b2-ac4);
	at1 = (-b + root) / (2.0f * a);
	at2 = (-b - root) / (2.0f * a);
	neg1 = at1<0.0f;
	neg2 = at2<0.0f;
	if (neg1 && neg2) return 0;
	else
	if (neg1 && !neg2) at = at2;
	else 
	if (!neg1 && neg2) at = at1;
	else
	if (at1<at2) at = at1;
	else at = at2;
	
	norm = Normalize(ray.p + at*ray.dir);

	return 1;
	}

void GSphereObject::InvalidateUI() 
{
	// if this was caused by a NotifyDependents from pblock2, LastNotifyParamID()
	// will contain ID to update, else it will be -1 => inval whole rollout
	geo_param_blk.InvalidateUI(pblock2->LastNotifyParamID());
}

RefTargetHandle GSphereObject::Clone(RemapDir& remap) 
{
	GSphereObject* newob = new GSphereObject();	
	newob->ReplaceReference(0, pblock2->Clone(remap));
	newob->ivalid.SetEmpty();	
	return(newob);
}

#ifndef NO_NURBS

Object *
BuildNURBSSphere(float radius, BOOL hemi, BOOL recenter, BOOL genUVs)
{
	NURBSSet nset;

	Point3 center(0, 0, 0);
	Point3 northAxis(0, 0, 1);
	Point3 refAxis(0, -1, 0);

	float startAngleU = -PI;
	float endAngleU = PI;
	float startAngleV;
	if (hemi)
		startAngleV = 0.0f;
	else
		startAngleV = -HALFPI;
	float endAngleV = HALFPI;
	if (recenter) {
		if (hemi)
			center = Point3(0.0f, 0.0f, 0.0f);
		else
			center = Point3(0.0f, 0.0f, radius);
	}

	NURBSCVSurface *surf = new NURBSCVSurface();
	nset.AppendObject(surf);
	surf->SetGenerateUVs(genUVs);

	if (hemi) {
		surf->SetTextureUVs(0, 0, Point2(0.0f, 0.5f));
		surf->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
		surf->SetTextureUVs(0, 2, Point2(1.0f, 0.5f));
		surf->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));
	} else {
		surf->SetTextureUVs(0, 0, Point2(0.0f, 0.0f));
		surf->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
		surf->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
		surf->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));
	}

	surf->FlipNormals(TRUE);
	surf->Renderable(TRUE);
	char bname[80];
	char sname[80];
	strcpy(bname, GetString(IDS_GEOSPHERE));
	sprintf(sname, "%s%s", bname, GetString(IDS_CT_SURF));
	surf->SetName(sname);
	GenNURBSSphereSurface(radius, center, northAxis, refAxis, 
					startAngleU, endAngleU, startAngleV, endAngleV,
					FALSE, *surf);

	if (hemi) {
		// now create caps on the ends
		NURBSCapSurface *cap0 = new NURBSCapSurface();
		nset.AppendObject(cap0);
		cap0->SetGenerateUVs(genUVs);
		cap0->SetParent(0);
		cap0->SetEdge(0);
		cap0->FlipNormals(TRUE);
		cap0->Renderable(TRUE);
		char sname[80];
		sprintf(sname, "%s%s%", bname, GetString(IDS_CT_CAP));
		cap0->SetName(sname);
	}

	Matrix3 mat;
	mat.IdentityMatrix();
	Object *ob = CreateNURBSObject(NULL, &nset, mat);
	return ob;
}

#endif

Object* GSphereObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
#ifndef NO_NURBS
	if (obtype == EDITABLE_SURF_CLASS_ID) {
		Interval valid = FOREVER;
		float radius;
		int recenter, hemi, genUVs;
		pblock2->GetValue(geo_radius, t, radius, valid);
		pblock2->GetValue(geo_hemi, t, hemi, valid);	
		pblock2->GetValue(geo_basepivot, t, recenter, valid);
		pblock2->GetValue(geo_mapping, t, genUVs, valid);
		Object *ob = BuildNURBSSphere(radius, hemi, recenter, genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM, valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM, valid);
		ob->UnlockObject();
		return ob;
		
	} else 
#endif

        {
            return SimpleObject::ConvertToType(t, obtype);
		}
	}

int GSphereObject::CanConvertToType(Class_ID obtype)
	{
#ifndef NO_NURBS
	if (obtype==defObjectClassID ||
		obtype==triObjectClassID || obtype==EDITABLE_SURF_CLASS_ID) {
#else
	if (obtype==defObjectClassID ||
		obtype==triObjectClassID) {
#endif
		return 1;
	} else {
		return SimpleObject::CanConvertToType(obtype);
		}
	}


void GSphereObject::GetCollapseTypes(Tab<Class_ID> &clist, Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);
#ifndef NO_NURBS
    Class_ID id = EDITABLE_SURF_CLASS_ID;
    TSTR *name = new TSTR(GetString(IDS_SM_NURBS_SURFACE));
    clist.Append(1, &id);
    nlist.Append(1, &name);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\GSphere\prim.h ===
/**********************************************************************
 *<
	FILE: prim.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __PRIM__H
#define __PRIM__H

#include "Max.h"
#include "resource.h"

TCHAR *GetString(int id);

extern ClassDesc* GetGSphereDesc();

extern HINSTANCE hInstance;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\GSphere\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PRIM.RC
//
#define IDC_TETRA                       0
#define IDC_OCTA                        1
#define IDC_ICOSA                       2
#define IDD_GSPHERE1                    179
#define IDD_GSPHERE2                    180
#define IDD_GSPHERE3                    181
#define IDC_RADIUS                      1000
#define IDC_SEGMENTS                    1001
#define IDC_CREATEDIAMETER              1002
#define IDC_CREATERADIUS                1003
#define IDC_SEGSPINNER                  1004
#define IDC_RADSPINNER                  1005
#define IDC_OBSMOOTH                    1006
#define IDC_TI_POSX                     3019
#define IDC_TI_POSXSPIN                 3020
#define IDC_TI_POSY                     3021
#define IDC_TI_POSYSPIN                 3022
#define IDC_TI_CREATE                   3023
#define IDC_TI_POSZ                     3024
#define IDC_TI_POSZSPIN                 3025
#define IDC_HEMI                        3071
#define IDC_BASEPIVOT                   3073
#define IDC_MAPPING                     3074
#define IDS_RB_RADIUS                   30045
#define IDS_RB_SEGS                     30046
#define IDS_RB_POS                      30047
#define IDS_RB_SMOOTH                   30048
#define IDS_RB_PRIMITIVES               30264
#define IDS_GEOSPHERE                   30265
#define IDS_KEYBOARD_ENTRY              30266
#define IDS_CREATION_METHOD             30267
#define IDS_BASETYPE                    30268
#define IDS_LIBDESCRIPTION              30269
#define IDS_PARAMETERS                  30270
#define IDS_HEMI                        30271
#define IDS_BASEPIVOT                   30272
#define IDS_MAPPING                     30273
#define IDS_SM_NURBS_SURFACE            30274
#define IDS_CT_SURF                     30275
#define IDS_CT_CAP                      30276
#define IDS_GEOSPHERE_CLASS             30277
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        182
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         3075
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\GSphere\prim.cpp ===
/**********************************************************************
 *<
	FILE: prim.cpp

	DESCRIPTION:   DLL implementation of primitives

	CREATED BY: Dan Silva

	HISTORY: created 12 December 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "prim.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();
	}

	return(TRUE);
}


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESCRIPTION); }

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 1;}


__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
	case 0: return GetGSphereDesc();
	default: return 0;
	}
}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\BitmapInfo.cpp ===
//-----------------------------------------------------------------------------
// -------------------------
// File ....: BitmapInfo.cpp
// -------------------------
// Author...: Gus J Grubba
// Date ....: September 1998
//
// Implementation of CMaxBitmapInfo
//
//-----------------------------------------------------------------------------
      
#include "stdafx.h"
#include "Comsrv.h"
#include "BitmapInfo.h"

//-----------------------------------------------------------------------------
// CMaxBitmapInfo::CMaxBitmapInfo()

CMaxBitmapInfo::CMaxBitmapInfo() {
	width			= 720;
	height			= 486;
	gamma			= 1.2f;
	aspect			= 1.0f;
	channels		= CHAN_NONE;
	process_gamma	= FALSE;
}

//-----------------------------------------------------------------------------
// CMaxBitmapInfo::get_Width

STDMETHODIMP CMaxBitmapInfo::get_Width(short *pVal) {
	*pVal = width;
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxBitmapInfo::put_Width

STDMETHODIMP CMaxBitmapInfo::put_Width(short newVal) {
	width = newVal;
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxBitmapInfo::get_Height

STDMETHODIMP CMaxBitmapInfo::get_Height(short *pVal) {
	*pVal = height;
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxBitmapInfo::put_Height

STDMETHODIMP CMaxBitmapInfo::put_Height(short newVal) {
	height = newVal;
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxBitmapInfo::get_ProcessGamma

STDMETHODIMP CMaxBitmapInfo::get_ProcessGamma(BOOL *pVal) {
	*pVal = process_gamma;
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxBitmapInfo::put_ProcessGamma

STDMETHODIMP CMaxBitmapInfo::put_ProcessGamma(BOOL newVal) {
	process_gamma = newVal;
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxBitmapInfo::get_Gamma

STDMETHODIMP CMaxBitmapInfo::get_Gamma(float *pVal) {
	*pVal = gamma;
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxBitmapInfo::put_Gamma

STDMETHODIMP CMaxBitmapInfo::put_Gamma(float newVal) {
	gamma = newVal;
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxBitmapInfo::get_Aspect

STDMETHODIMP CMaxBitmapInfo::get_Aspect(float *pVal) {
	*pVal = aspect;
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxBitmapInfo::put_Aspect

STDMETHODIMP CMaxBitmapInfo::put_Aspect(float newVal) {
	aspect = newVal;
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxBitmapInfo::get_Channels

STDMETHODIMP CMaxBitmapInfo::get_Channels(MAXGBufferFlags *pVal) {
	*pVal = (MAXGBufferFlags)channels;
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxBitmapInfo::put_Channels

STDMETHODIMP CMaxBitmapInfo::put_Channels(MAXGBufferFlags newVal) {
	channels = newVal;
	return S_OK;
}

//-- EOF: BitmapInfo.cpp ------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\BitmapInfo.h ===
//-----------------------------------------------------------------------------
// -----------------------
// File ....: BitmapInfo.h
// -----------------------
// Author...: Gus J Grubba
// Date ....: September 1998
//
// Declaration of the CMaxBitmapInfo
//
//-----------------------------------------------------------------------------

#ifndef __BITMAPINFO_H_
#define __BITMAPINFO_H_

#include "resource.h"       // main symbols

//-----------------------------------------------------------------------------
//--  Class Definition --------------------------------------------------------
//-----------------------------------------------------------------------------
// CMaxBitmapInfo

class ATL_NO_VTABLE CMaxBitmapInfo : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMaxBitmapInfo, &CLSID_MaxBitmapInfo>,
	public IDispatchImpl<IMaxBitmapInfo, &IID_IMaxBitmapInfo, &LIBID_COMSRVLib> {
public:
	CMaxBitmapInfo();

DECLARE_REGISTRY_RESOURCEID(IDR_BITMAPINFO)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMaxBitmapInfo)
	COM_INTERFACE_ENTRY(IMaxBitmapInfo)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:

	//-----------------------------------------------------
	//-- IMaxBitmapInfo Public Interface

	STDMETHOD(get_Channels)		(/*[out, retval]*/ MAXGBufferFlags *pVal);
	STDMETHOD(put_Channels)		(/*[in]*/ MAXGBufferFlags newVal);
	STDMETHOD(get_Aspect)		(/*[out, retval]*/ float *pVal);
	STDMETHOD(put_Aspect)		(/*[in]*/ float newVal);
	STDMETHOD(get_Gamma)		(/*[out, retval]*/ float *pVal);
	STDMETHOD(put_Gamma)		(/*[in]*/ float newVal);
	STDMETHOD(get_ProcessGamma)	(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_ProcessGamma)	(/*[in]*/ BOOL newVal);
	STDMETHOD(get_Height)		(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_Height)		(/*[in]*/ short newVal);
	STDMETHOD(get_Width)		(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_Width)		(/*[in]*/ short newVal);

private:

	//-----------------------------------------------------
	//-- Local

	short	width,height;
	float	gamma,aspect;
	BOOL	process_gamma;
	DWORD	channels;
	
};

#endif //__BITMAPINFO_H_

//-- EOF: BitmapInfo.h --------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\MaxRenderer.h ===
//-----------------------------------------------------------------------------
// ------------------------
// File ....: MaxRenderer.h
// ------------------------
// Author...: Gus J Grubba
// Date ....: September 1998
//
// IMaxRenderer Interface
//
//-----------------------------------------------------------------------------
      
#ifndef __MAXRENDERER_H_
#define __MAXRENDERER_H_

#include "resource.h"

//-- MAX Include files

#include <Max.h>
#include <bmmlib.h>
#include <guplib.h>
#include "mscom.h"

class CamListImp;
class maxRndProgressCB;

typedef struct tagEventProxys {
	IStream*	pStream;
	IDispatch*	p;
} EventProxys;

//-----------------------------------------------------------------------------
//--  Class Definition --------------------------------------------------------
//-----------------------------------------------------------------------------
// #> CProxy_IMaxRendererEvents
//

template <class T>
class CProxy_IMaxRendererEvents : public IConnectionPointImpl<T, &IID__IMaxRendererEvents, CComDynamicUnkArray> {
public:
	HRESULT Fire_OnEnumCameras(BSTR CameraName) {
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)	{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL) {
				VariantClear(&varResult);
				pvars[0] = CameraName;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnRenderProgress(LONG Done, LONG Total)	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)	{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL) {
				VariantClear(&varResult);
				pvars[1] = Done;
				pvars[0] = Total;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnRenderMessage(BSTR Message) {
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)	{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL) {
				VariantClear(&varResult);
				pvars[0] = Message;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnRenderDone() {
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)	{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)	{
				VariantClear(&varResult);
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return varResult.scode;
	
	}
};

//-----------------------------------------------------------------------------
//--  Class Definition --------------------------------------------------------
//-----------------------------------------------------------------------------
// #> CMaxRenderer
//

class ATL_NO_VTABLE CMaxRenderer : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMaxRenderer, &CLSID_MaxRenderer>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CMaxRenderer>,
	public IDispatchImpl<IMaxRenderer, &IID_IMaxRenderer, &LIBID_COMSRVLib>,
	public CProxy_IMaxRendererEvents< CMaxRenderer >,
	public GUP_MSCOM {
public:
	CMaxRenderer();
	~CMaxRenderer();

DECLARE_REGISTRY_RESOURCEID(IDR_MAXRENDERER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMaxRenderer)
	COM_INTERFACE_ENTRY(IMaxRenderer)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CMaxRenderer)
CONNECTION_POINT_ENTRY(IID__IMaxRendererEvents)
END_CONNECTION_POINT_MAP()

	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:

	//-----------------------------------------------------
	//-- IMaxRenderer Public Interface

	STDMETHOD(get_RenderFieldOrder)		(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_RenderFieldOrder)		(/*[in]*/ long newVal);
	STDMETHOD(get_RenderAtmosphere)		(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_RenderAtmosphere)		(/*[in]*/ BOOL newVal);
	STDMETHOD(get_RenderForceTwoSide)	(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_RenderForceTwoSide)	(/*[in]*/ BOOL newVal);
	STDMETHOD(get_RenderHidden)			(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_RenderHidden)			(/*[in]*/ BOOL newVal);
	STDMETHOD(get_RenderSuperBlack)		(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_RenderSuperBlack)		(/*[in]*/ BOOL newVal);
	STDMETHOD(get_RenderColorCheck)		(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_RenderColorCheck)		(/*[in]*/ BOOL newVal);
	STDMETHOD(get_RenderFieldRender)	(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_RenderFieldRender)	(/*[in]*/ BOOL newVal);
	STDMETHOD(get_AnimationEnd)			(/*[out, retval]*/ float *pVal);
	STDMETHOD(put_AnimationEnd)			(/*[in]*/ float newVal);
	STDMETHOD(get_AnimationStart)		(/*[out, retval]*/ float *pVal);
	STDMETHOD(put_AnimationStart)		(/*[in]*/ float newVal);

	STDMETHOD(ExecuteMAXScriptFile)		(/*[in]*/ BSTR FileName);
	STDMETHOD(ExecuteMAXScriptString)	(/*[in]*/ BSTR String);
	STDMETHOD(GetPreviewLine)			(/*[in]*/ long line, /*[in]*/ long width, /*[out, retval]*/ SAFEARRAY **psa);
	STDMETHOD(GetLine)					(/*[in]*/ MAXchannelTypes type, /*[in]*/ long line, /*[in]*/ BOOL linear, /*[out, retval]*/ SAFEARRAY **psa);
	STDMETHOD(SetRegion)				(/*[in]*/ short x,/*[in]*/ short y,/*[in]*/ short w,/*[in]*/ short h);
	STDMETHOD(CancelRenderer)			(void);
	STDMETHOD(CloseRenderer)			(void);
	STDMETHOD(OpenRenderer)				(/*[in]*/ BSTR CameraName, /*[in]*/ IMaxBitmapInfo* pMap, /*[in]*/ BOOL region);
	STDMETHOD(RenderFrame)				(/*[in]*/ float Time, /*[in]*/ float Duration);
	STDMETHOD(EnumCameras)				(void);
	STDMETHOD(LoadScene)				(/*[in]*/ BSTR SceneName);
	STDMETHOD(SaveScene)				(/*[in]*/ BSTR SceneName);
	STDMETHOD(ImportFile)				(/*[in]*/ BSTR FileName);
	 
	//-----------------------------------------------------
	//-- Local

	STDMETHODIMP	AllocAndGetLine	(long line, BOOL linear, BMM_Color_64 **pix);
	STDMETHODIMP	GetChannel		(long line, long depth, long channel, SAFEARRAY **psa);
	STDMETHODIMP	GetLine24x48	(long line, BOOL linear, BOOL b24, SAFEARRAY **psa);
	STDMETHODIMP	GetBGRLine24x48	(long line, BOOL linear, BOOL b24, SAFEARRAY **psa);
	STDMETHODIMP	GetLine32		(long line, BOOL linear, SAFEARRAY **psa);
	STDMETHODIMP	GetBGRLine32	(long line, BOOL linear, SAFEARRAY **psa);
	STDMETHODIMP	GetBGRLine64	(long line, BOOL linear, SAFEARRAY **psa);
	STDMETHODIMP	GetLine64		(long line, BOOL linear, SAFEARRAY **psa);
	
	void			ReadBitmapInfo	(IMaxBitmapInfo* pBif);
	void			CreateBitmap	( );
	void			DestroyBitmap	( );
	void			RenderThread	( );
	
	//-----------------------------------------------------
	//-- Data

	RECT					region_rect;
	bool					rendering,renderopen,renderregion;
	long					rndtime;
	float					rnddur;
	Bitmap*					rndmap;
	BitmapInfo				bi;
	CamListImp*				clp;
	maxRndProgressCB*		rndCB;
	HANDLE					RenderThreadHandle;
	DWORD					RenderThreadId,image_channels;
	Tab<EventProxys>		aProxy;

	//-----------------------------------------------------
	//-- Threaded Proxys

	HRESULT OnEnumCameras(BSTR CameraName) {
		CComVariant varResult;
		CComVariant* pvars = new CComVariant[1];
		for (int i = 0; i < aProxy.Count(); i++)	{
			if (aProxy[i].p != NULL) {
				VariantClear(&varResult);
				pvars[0] = CameraName;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				aProxy[i].p->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	}
	

	HRESULT OnRenderProgress(LONG Done, LONG Total)	{
		CComVariant varResult;
		CComVariant* pvars = new CComVariant[2];
		for (int i = 0; i < aProxy.Count(); i++)	{
			if (aProxy[i].p != NULL) {
				VariantClear(&varResult);
				pvars[1] = Done;
				pvars[0] = Total;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				aProxy[i].p->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	}
	
	HRESULT OnRenderMessage(BSTR Message) {
		CComVariant varResult;
		CComVariant* pvars = new CComVariant[1];
		for (int i = 0; i < aProxy.Count(); i++)	{
			if (aProxy[i].p != NULL) {
				VariantClear(&varResult);
				pvars[0] = Message;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				aProxy[i].p->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	}
	
	HRESULT OnRenderDone() {
		CComVariant varResult;
		for (int i = 0; i < aProxy.Count(); i++)	{
			if (aProxy[i].p != NULL) {
				VariantClear(&varResult);
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				aProxy[i].p->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return varResult.scode;
	}


};

//-----------------------------------------------------------------------------
//--  Class Definition --------------------------------------------------------
//-----------------------------------------------------------------------------
// #> CamListImp
//

class CamListImp: public ITreeEnumProc {
	public:
		TCHAR			name[128];
		CMaxRenderer*	cmax;
		INode*			camNode;
		bool			fire_back;
		CamListImp	( ) {Reset();}
		int				callback	( INode* node );
		void			Reset		( ) { 
			camNode		= NULL;
			cmax		= NULL;
			fire_back	= true;
		}
};

//-----------------------------------------------------------------------------
//--  Class Definition --------------------------------------------------------
//-----------------------------------------------------------------------------
// #> maxRendProgressCallback
//

class maxRndProgressCB : public RendProgressCallback {
	public:
		void	SetTitle		( const TCHAR *title );
		int		Progress		( int done, int total );
		CMaxRenderer* cmax;
		bool	abort;
};

#endif //__MAXRENDERER_H_

//-- EOF: MaxRenderer.h -------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\comsrv.cpp ===
//-----------------------------------------------------------------------------
// ---------------------
// File ....: comsrv.cpp
// ---------------------
// Author...: Gus J Grubba
// Date ....: September 1998
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "comsrv.h"

#include "comsrv_i.c"
#include "MaxRenderer.h"
#include "BitmapInfo.h"

#ifdef _DEBUG
#include <mmsystem.h>
#endif

const DWORD dwTimeOut	= 0;	// time for EXE to be idle before shutting down
const DWORD dwPause		= 1000; // time to wait for threads to finish up

//-----------------------------------------------------------------------------
// *> MonitorProc()
//
//    Passed to CreateThread to monitor the shutdown event

static DWORD WINAPI MonitorProc(void* pv) {
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

//-----------------------------------------------------------------------------
// #> CExeModule::Unlock()

LONG CExeModule::Unlock() {
#if 1
	SetEvent(hEventShutdown);
	return 0;
#else
	LONG l = CComModule::Unlock();
	if (l == 0) {
		bActivity = true;
		SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
	}
	return l;
#endif
}

//-----------------------------------------------------------------------------
// #> CExeModule::MonitorShutdown()

void CExeModule::MonitorShutdown() {
#if 1
	WaitForSingleObject(hEventShutdown, INFINITE);
	#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
	CoSuspendClassObjects();
	#endif
#else
	while (1) {
		WaitForSingleObject(hEventShutdown, INFINITE);
		DWORD dwWait=0;
		do {
			bActivity = false;
			dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
		} while (dwWait == WAIT_OBJECT_0);
        //-- timed out
		if (!bActivity && m_nLockCnt == 0) { // if no activity let's really bail
			#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
            CoSuspendClassObjects();
            if (!bActivity && m_nLockCnt == 0)
			#endif
                break;
        }
    }
#endif
	CloseHandle(hEventShutdown);
	CloseHandle(hMonitorThread);
	#ifdef _DEBUG
	PlaySound("chimes.wav",NULL,SND_FILENAME|SND_ASYNC);
	#endif
	PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

//-----------------------------------------------------------------------------
// #> CExeModule::StartMonitor()

bool CExeModule::StartMonitor() {
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    return (h != NULL);
}

//-----------------------------------------------------------------------------
//

CExeModule _Module;
BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MaxRenderer,	CMaxRenderer)
OBJECT_ENTRY(CLSID_MaxBitmapInfo, CMaxBitmapInfo)
END_OBJECT_MAP()

//-----------------------------------------------------------------------------
// *> FindOneToken()

LPCTSTR FindToken(LPCTSTR p1) {
    TCHAR p2[] = _T("-/");
    while (p1 != NULL && *p1 != NULL) {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL) {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

//-----------------------------------------------------------------------------
// *> OpenKeyAndSetValue()

bool OpenKeyAndSetValue(LPCTSTR szKeyName, LPCTSTR szValue) {
	HKEY	hKey;
	long	retVal;
    retVal = RegOpenKeyEx(HKEY_CLASSES_ROOT,szKeyName,0,KEY_WRITE,&hKey);
	if (retVal == ERROR_SUCCESS) {
		RegSetValue(hKey,__TEXT(""),REG_SZ,szValue,lstrlen(szValue));
		RegCloseKey(hKey);
	}
	return retVal == ERROR_SUCCESS;
}

//-----------------------------------------------------------------------------
// *> RegisterCOM()

bool RegisterCOM(HINSTANCE MaxhInstance) {
	
	_Module.UpdateRegistryFromResource(IDR_Comsrv, TRUE);
	HRESULT hRes = _Module.RegisterServer(TRUE);
    _ASSERTE(SUCCEEDED(hRes));
	
	//-- Update Server Location

	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(MaxhInstance,szModule,_MAX_PATH);
	TCHAR szKeyName[256];
	TCHAR keyLocalServer[] = {"LocalServer32"};
	
	//-- MaxRenderer Class

	TCHAR clsidApp[] = {"{4AD72E6E-5A4B-11D2-91CB-0060081C257E}"};
	wsprintf(szKeyName,"CLSID\\%s\\%s",clsidApp,keyLocalServer);
	OpenKeyAndSetValue(szKeyName,szModule);

	//-- MaxBitmapInfo Class

	_tcscpy(clsidApp,_T("{D888A162-6543-11D2-91CC-0060081C257E}"));
	wsprintf(szKeyName,"CLSID\\%s\\%s",clsidApp,keyLocalServer);
	OpenKeyAndSetValue(szKeyName,szModule);

	return true;

}

//-----------------------------------------------------------------------------
// *> UnRegisterCOM()

bool UnRegisterCOM( ) {
	_Module.UpdateRegistryFromResource(IDR_Comsrv, FALSE);
	return(_Module.UnregisterServer(TRUE) != 0);
}

//-----------------------------------------------------------------------------
// *> StartServer()

bool StartServer( HINSTANCE hInstance, HINSTANCE MaxhInstance, int registerCOM ) {

	bool res = true;

	HRESULT hRes = CoInitialize(NULL);
    _ASSERTE(SUCCEEDED(hRes));
	_Module.Init(ObjectMap, hInstance, &LIBID_COMSRVLib);
	_Module.dwThreadID = GetCurrentThreadId();

	switch (registerCOM) {
		case 1:
			res = UnRegisterCOM();
			CoUninitialize();
            return res;
		case 2:
			res = RegisterCOM(MaxhInstance);
			CoUninitialize();
            return res;
	}

	//-- Register Classes (Runtime)

    _Module.StartMonitor();
	hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
		REGCLS_SINGLEUSE);
    _ASSERTE(SUCCEEDED(hRes));
	
	return res;

}

//-----------------------------------------------------------------------------
// *> StopServer()

void StopServer( ) {
    _Module.Unlock();
	_Module.RevokeClassObjects();
	Sleep(dwPause);
	_Module.Term();
	CoUninitialize();
}

//-- EOF: comsrv.cpp ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\MaxRenderer.cpp ===
//-----------------------------------------------------------------------------
// --------------------------
// File ....: MaxRenderer.cpp
// --------------------------
// Author...: Gus J Grubba
// Date ....: September 1998
//
// Implementation of CMaxRenderer
//
//-----------------------------------------------------------------------------
      
#include "stdafx.h"
#include "Comsrv.h"
#include "MaxRenderer.h"
#ifdef _DEBUG
#include <mmsystem.h>
#endif

#pragma warning(disable:4800)
extern TCHAR *GetString(int id);

//-----------------------------------------------------------------------------
// *> renderThread()
//

void renderThread( PVOID Parameter ) {
	CMaxRenderer* cmax = (CMaxRenderer *)Parameter;
	cmax->RenderThread();
}

//-----------------------------------------------------------------------------
// #> CamListImp::callback()
//

int CamListImp::callback(INode *node) {
	Interface *max = cmax->Max();
	const ObjectState& os = node->EvalWorldState(max->GetTime());
	Object* ob = os.obj;
	if (ob!=NULL) {
		if (ob->SuperClassID()==CAMERA_CLASS_ID) {
			if (fire_back) {
				USES_CONVERSION;
				LPOLESTR b_name = T2OLE(node->GetName());
				cmax->Fire_OnEnumCameras(b_name);
			} else {
				if (!camNode) {
					if (!_tcscmp(node->GetName(),name)) {
						camNode = node;
						return TREE_ABORT;
					}
				}   
			}

		}
	}
	return TREE_CONTINUE;
}

//-----------------------------------------------------------------------------
// #> maxRndProgressCB::SetTitle()
//

void maxRndProgressCB::SetTitle( const TCHAR *title ) {
	if (cmax) {
		USES_CONVERSION;
		LPOLESTR b_text = T2OLE(title);
		cmax->OnRenderMessage(b_text);
	}
}

//-----------------------------------------------------------------------------
// #> maxRndProgressCB::Progress()
//

int maxRndProgressCB::Progress( int done, int total ) {
	if (cmax && total)
		cmax->OnRenderProgress(done,total);
	if (abort)
		return (RENDPROG_ABORT);
	else   
		return (RENDPROG_CONTINUE);
}

//-----------------------------------------------------------------------------
// CMaxRenderer::InterfaceSupportsErrorInfo()

STDMETHODIMP CMaxRenderer::InterfaceSupportsErrorInfo(REFIID riid) {
	static const IID* arr[] = {
		&IID_IMaxRenderer
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++) {
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::CMaxRenderer()
//

CMaxRenderer::CMaxRenderer() {
	Max()->SetNetServer();
	ShowWindow(MaxWnd(),SW_MINIMIZE);
	SetWindowLong(MaxWnd(),GWL_STYLE,WS_VISIBLE | WS_CAPTION);
	clp			= NULL;
	rndCB		= NULL;
	rndmap		= NULL;
	rendering	= false;
	renderopen	= false;
	memset(&region_rect,0,sizeof(RECT));
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::~CMaxRenderer()
//

CMaxRenderer::~CMaxRenderer() {
	DestroyBitmap();
}

//-----------------------------------------------------------------------------
// CMaxRenderer::get_AnimationStart()

STDMETHODIMP CMaxRenderer::get_AnimationStart(float *pVal){
	Interface *max = Max();
	Interval i = max->GetAnimRange();
	*pVal = ((float)i.Start() / (float)GetTicksPerFrame());
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::put_AnimationStart()

STDMETHODIMP CMaxRenderer::put_AnimationStart(float newVal){
	Interface *max = Max();
	Interval i = max->GetAnimRange();
	i.SetStart((int)(newVal * (float)GetTicksPerFrame()));
	max->SetAnimRange(i);
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::get_AnimationEnd()

STDMETHODIMP CMaxRenderer::get_AnimationEnd(float *pVal){
	Interface *max = Max();
	Interval i = max->GetAnimRange();
	*pVal = ((float)i.End() / (float)GetTicksPerFrame());
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::put_AnimationEnd()

STDMETHODIMP CMaxRenderer::put_AnimationEnd(float newVal) {
	Interface *max = Max();
	Interval i = max->GetAnimRange();
	i.SetEnd((int)(newVal * (float)GetTicksPerFrame()));
	max->SetAnimRange(i);
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::get_RenderFieldRender()

STDMETHODIMP CMaxRenderer::get_RenderFieldRender(BOOL *pVal){
	Interface *max = Max();
	*pVal = max->GetRendFieldRender();
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::put_RenderFieldRender()

STDMETHODIMP CMaxRenderer::put_RenderFieldRender(BOOL newVal){
	Interface *max = Max();
	max->SetRendFieldRender(newVal);
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::get_RenderColorCheck()

STDMETHODIMP CMaxRenderer::get_RenderColorCheck(BOOL *pVal) {
	Interface *max = Max();
	*pVal = max->GetRendColorCheck();
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::put_RenderColorCheck()

STDMETHODIMP CMaxRenderer::put_RenderColorCheck(BOOL newVal){
	Interface *max = Max();
	max->SetRendColorCheck(newVal);
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::get_RenderSuperBlack()

STDMETHODIMP CMaxRenderer::get_RenderSuperBlack(BOOL *pVal){
	Interface *max = Max();
	*pVal = max->GetRendSuperBlack();
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::put_RenderSuperBlack()

STDMETHODIMP CMaxRenderer::put_RenderSuperBlack(BOOL newVal){
	Interface *max = Max();
	max->SetRendSuperBlack(newVal);
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::get_RenderHidden()

STDMETHODIMP CMaxRenderer::get_RenderHidden(BOOL *pVal){
	Interface *max = Max();
	*pVal = max->GetRendHidden();
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::put_RenderHidden()

STDMETHODIMP CMaxRenderer::put_RenderHidden(BOOL newVal){
	Interface *max = Max();
	max->SetRendHidden(newVal);
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::get_RenderForceTwoSide()

STDMETHODIMP CMaxRenderer::get_RenderForceTwoSide(BOOL *pVal){
	Interface *max = Max();
	*pVal = max->GetRendForce2Side();
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::put_RenderForceTwoSide()

STDMETHODIMP CMaxRenderer::put_RenderForceTwoSide(BOOL newVal){
	Interface *max = Max();
	max->SetRendForce2Side(newVal);
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::get_RenderAtmosphere()

STDMETHODIMP CMaxRenderer::get_RenderAtmosphere(BOOL *pVal){
	Interface *max = Max();
	*pVal = max->GetRendAtmosphere();
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::put_RenderAtmosphere()

STDMETHODIMP CMaxRenderer::put_RenderAtmosphere(BOOL newVal){
	Interface *max = Max();
	max->SetRendAtmosphere(newVal);
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::get_RenderFieldOrder()

STDMETHODIMP CMaxRenderer::get_RenderFieldOrder(long *pVal){
	Interface *max = Max();
	*pVal = max->GetRendFieldOrder();
	return S_OK;
}

//-----------------------------------------------------------------------------
// CMaxRenderer::put_RenderFieldOrder()

STDMETHODIMP CMaxRenderer::put_RenderFieldOrder(long newVal){
	Interface *max = Max();
	max->SetRendFieldOrder(newVal);
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::LoadScene()
//

STDMETHODIMP CMaxRenderer::LoadScene(BSTR SceneName) {
	LPTSTR filename;
	USES_CONVERSION;
	filename = OLE2T(SceneName);
	Interface *max = Max();
	if (!max->LoadFromFile(filename)) {
		TCHAR errtxt[MAX_PATH];
		wsprintf(errtxt,GetString(IDS_NO_FILE_ERROR),filename);
		return Error(errtxt);
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::SaveScene()
//

STDMETHODIMP CMaxRenderer::SaveScene(BSTR SceneName) {
	LPTSTR filename;
	USES_CONVERSION;
	filename = OLE2T(SceneName);
	Interface *max = Max();
	if (!max->SaveToFile(filename)) {
		TCHAR errtxt[MAX_PATH];
		wsprintf(errtxt,GetString(IDS_NO_FILE_ERROR),filename);
		return Error(errtxt);
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::ImportFile()
//

STDMETHODIMP CMaxRenderer::ImportFile(BSTR FileName) {
	LPTSTR filename;
	USES_CONVERSION;
	filename = OLE2T(FileName);
	Interface *max = Max();
	if (!max->ImportFromFile(filename,TRUE)) {
		TCHAR errtxt[MAX_PATH];
		wsprintf(errtxt,GetString(IDS_NO_FILE_ERROR),filename);
		return Error(errtxt);
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::EnumCameras()
//

STDMETHODIMP CMaxRenderer::EnumCameras() {
	if (rendering)
		return Error(GetString(IDS_MAX_BUSY));
	clp = new CamListImp;
	clp->Reset();
	clp->cmax = this;
	#ifdef _DEBUG
	PlaySound("chimes.wav",NULL,SND_FILENAME|SND_ASYNC);
	#endif
	EnumTree(clp);
	delete clp;
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::RenderFrame()
//

STDMETHODIMP CMaxRenderer::RenderFrame(float Time, float Duration) {

	#ifdef _DEBUG
	PlaySound("chimes.wav",NULL,SND_FILENAME|SND_ASYNC);
	#endif

	if (rendering)
		return Error(GetString(IDS_MAX_BUSY));
	
	if (!renderopen)
		return Error(GetString(IDS_RENDERER_NOT_OPEN));

	if (renderregion) {
		if (!(region_rect.bottom+region_rect.right))
			return Error(GetString(IDS_RECT_NOT_SET));
	}
	
	CreateBitmap();

	Interface *max = Max();
	_ASSERTE(max);

	rndtime = (int)(Time * (float)GetTicksPerFrame());
	rnddur	= Duration;

	//-- Marshal Outgoing Interfaces

	CMaxRenderer* pT = static_cast<CMaxRenderer*>(this);
	int nConnectionIndex;
	int nConnections = m_vec.GetSize();
	for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++) {
		pT->Lock();
		CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
		pT->Unlock();
		IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
		EventProxys ep;
		ep.p = NULL;
		HRESULT hr = CoMarshalInterThreadInterfaceInStream(
			IID_IDispatch,
			pDispatch,
			&ep.pStream);
		_ASSERTE(SUCCEEDED(hr));
		aProxy.Append(1,&ep);
	}

	//-- Launch Render Thread

	SECURITY_ATTRIBUTES SecurityAttributes;
	SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	SecurityAttributes.lpSecurityDescriptor = NULL;  // Use default ACL
	SecurityAttributes.bInheritHandle       = FALSE; // No inheritance

	RenderThreadHandle = CreateThread(
			&SecurityAttributes, 
			0, 
			(LPTHREAD_START_ROUTINE)renderThread,
			(LPVOID)this,
			0, 
			&RenderThreadId);
										 
	if (RenderThreadHandle == NULL) {
		while (aProxy.Count()) {
			aProxy[0].pStream->Release();
			aProxy.Delete(0,1);
			aProxy.Shrink();
		}
		delete rndCB;
		return Error(GetString(IDS_THREAD_ERROR));
	} else
		CloseHandle(RenderThreadHandle);

	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::OpenRenderer()
//

STDMETHODIMP CMaxRenderer::OpenRenderer(BSTR CameraName, IMaxBitmapInfo* pBif, BOOL region) {

	if (renderopen)
		return Error(GetString(IDS_MAX_BUSY));

	renderregion = bool(region);

	Interface *max = Max();
	_ASSERTE(max);

	ReadBitmapInfo(pBif);

	//-- Define Camera

	clp = new CamListImp;
	clp->Reset();
	clp->fire_back	= false;
	clp->cmax		= this;
	USES_CONVERSION;
	LPTSTR a_name = OLE2T(CameraName);
	_tcscpy(clp->name,a_name);
	EnumTree(clp);

	if (!clp->camNode) {
		TCHAR errtxt[MAX_PATH];
		wsprintf(errtxt,GetString(IDS_NO_CAMERA_ERROR),a_name);
		delete clp;
		return Error(errtxt);
	}
	
	int res;

	if (region) {
		short w,h;
		pBif->get_Width(&w);
		pBif->get_Height(&h);
		res = max->OpenCurRenderer(clp->camNode,NULL,RENDTYPE_REGIONCROP,int(w),int(h));
	} else
		res = max->OpenCurRenderer(clp->camNode,NULL);

	if (!res) {
		delete clp;
		return Error(GetString(IDS_OPEN_RENDERER_ERROR));
	}

	delete clp;
	renderopen = true;
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::CloseRenderer()
//

STDMETHODIMP CMaxRenderer::CloseRenderer() {
	if (!renderopen)
		return Error(GetString(IDS_RENDERER_NOT_OPEN));
	if (rendering) {
		rndCB->abort = true;
		int dur = 50;
		while (--dur && rendering)
			Sleep(100);
	}
	renderopen = false;
	Interface *max = Max();
	ATLASSERT(max);
	max->CloseCurRenderer();
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::CancelRenderer()
//

STDMETHODIMP CMaxRenderer::CancelRenderer() {
	if (rendering)
		rndCB->abort = true;
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::GetPreviewLine()
//

STDMETHODIMP CMaxRenderer::GetPreviewLine(long line, long width, SAFEARRAY **psa) {
	_ASSERTE(psa);
	if (!rndmap)
		return Error(GetString(IDS_BITMAP_NOT_CREATED));
	BMM_Color_64 *pix;
	AllocAndGetLine(line,TRUE,&pix);
	int size = width * 3;
	*psa = SafeArrayCreateVector(VT_UI1,0,size);
	_ASSERTE(*psa);
	BYTE *data;
	SafeArrayAccessData(*psa,(void**)&data);
	_ASSERTE(data);
	float step = (float)((float)rndmap->Width() / (float)width);
	for (int i = 0; i < width; i++) {
		BMM_Color_64 *p = pix +	(long)(step * (float)i);
		*data++ = (BYTE)(p->b >> 8);
		*data++ = (BYTE)(p->g >> 8);
		*data++ = (BYTE)(p->r >> 8);
	}
	LocalFree(pix);
	SafeArrayUnaccessData(*psa);
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::SetRegion()
//

STDMETHODIMP CMaxRenderer::SetRegion(short x,short y,short w,short h) {
	region_rect.top = y;
	region_rect.left = x;
	region_rect.bottom = y + h;
	region_rect.right = x + w;
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::GetLine()
//

STDMETHODIMP CMaxRenderer::GetLine(MAXchannelTypes type, long line, BOOL linear, SAFEARRAY **psa) {
	_ASSERTE(psa);
	if (!rndmap)
		return Error(GetString(IDS_BITMAP_NOT_CREATED));
	switch (type) {
		case TYPE_RGB24:
			return GetLine24x48(line,linear,TRUE,psa);
		case TYPE_RGB48:
			return GetLine24x48(line,linear,FALSE,psa);
		case TYPE_RGBA32:
			return GetLine32(line,linear,psa);
		case TYPE_RGBA64:
			return GetLine64(line,linear,psa);
		case TYPE_BGR24:
			return GetBGRLine24x48(line,linear,TRUE,psa);
		case TYPE_BGR48:
			return GetBGRLine24x48(line,linear,FALSE,psa);
		case TYPE_BGRA32:
			return GetBGRLine32(line,linear,psa);
		case TYPE_BGRA64:
			return GetBGRLine64(line,linear,psa);
		case TYPE_Z32:
			return GetChannel(line,sizeof(float),CHAN_Z,psa);
		case TYPE_MTLID8:
			return GetChannel(line,sizeof(BYTE),CHAN_MTL_ID,psa);
		case TYPE_NODEID16:
			return GetChannel(line,sizeof(WORD),CHAN_NODE_ID,psa);
		case TYPE_UV64:
			return GetChannel(line,sizeof(Point2),CHAN_UV,psa);
		case TYPE_NORMAL32:
			return GetChannel(line,sizeof(float),CHAN_NORMAL,psa);
		case TYPE_REALPIXDEP:
			return GetChannel(line,sizeof(RealPixel),CHAN_REALPIX,psa);
		case TYPE_COVERAGE8:
			return GetChannel(line,sizeof(BYTE),CHAN_COVERAGE,psa);
		case TYPE_BGRGB24:
			return GetChannel(line,3,CHAN_BG,psa);
		case TYPE_NODEIDX16:
			return GetChannel(line,sizeof(WORD),CHAN_NODE_RENDER_ID,psa);
	}
	return Error(GetString(IDS_UNDEFINED_TYPE));
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::AllocAndGetLine()
//

STDMETHODIMP CMaxRenderer::AllocAndGetLine(long line, BOOL linear, BMM_Color_64 **pix) {
	_ASSERTE(pix);
	*pix = (BMM_Color_64 *)LocalAlloc(LPTR,rndmap->Width() * sizeof(BMM_Color_64));
	_ASSERTE(*pix);
	if (linear)
		rndmap->GetLinearPixels(0,line,rndmap->Width(),*pix);
	else
		rndmap->GetPixels(0,line,rndmap->Width(),*pix);
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::GetChannel()
//

STDMETHODIMP CMaxRenderer::GetChannel(long line, long depth, long channel, SAFEARRAY **psa) {
	int size = rndmap->Width() * depth;
	*psa = SafeArrayCreateVector(VT_UI1,0,size);
	_ASSERTE(*psa);
	BYTE *data;
	SafeArrayAccessData(*psa,(void**)&data);
	_ASSERTE(data);
	memset(data,0,size);
	if (rndmap->ChannelsPresent() & channel) {
		DWORD type;
		BYTE *b = (BYTE *)rndmap->GetChannel(channel,type);
		if (b) {
			BYTE *ptr = b + (line * size);
			memcpy(data,ptr,size);
		}
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::GetLine24x48()
//

STDMETHODIMP CMaxRenderer::GetLine24x48(long line, BOOL linear, BOOL b24, SAFEARRAY **psa) {
	BMM_Color_64 *pix;
	AllocAndGetLine(line,linear,&pix);
	int size = rndmap->Width() * 3;
	if (!b24)
		size = size << 1;
	*psa = SafeArrayCreateVector(VT_UI1,0,size);
	_ASSERTE(*psa);
	BYTE *data;
	SafeArrayAccessData(*psa,(void**)&data);
	_ASSERTE(data);
	BMM_Color_64 *p = pix;
	if (b24) {
		for (int i = 0; i < rndmap->Width(); i++, p++) {
			*data++ = (BYTE)(p->r >> 8);
			*data++ = (BYTE)(p->g >> 8);
			*data++ = (BYTE)(p->b >> 8);
		}
	} else {
		WORD *t = (WORD *)(void *)data;
		for (int i = 0; i < rndmap->Width(); i++, p++) {
			*t++ = p->r;
			*t++ = p->g;
			*t++ = p->b;
		}
	}
	LocalFree(pix);
	SafeArrayUnaccessData(*psa);
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::GetBGRLine24x48()
//

STDMETHODIMP CMaxRenderer::GetBGRLine24x48(long line, BOOL linear, BOOL b24, SAFEARRAY **psa) {
	BMM_Color_64 *pix;
	AllocAndGetLine(line,linear,&pix);
	int size = rndmap->Width() * 3;
	if (!b24)
		size = size << 1;
	*psa = SafeArrayCreateVector(VT_UI1,0,size);
	_ASSERTE(*psa);
	BYTE *data;
	SafeArrayAccessData(*psa,(void**)&data);
	_ASSERTE(data);
	BMM_Color_64 *p = pix;
	if (b24) {
		for (int i = 0; i < rndmap->Width(); i++, p++) {
			*data++ = (BYTE)(p->b >> 8);
			*data++ = (BYTE)(p->g >> 8);
			*data++ = (BYTE)(p->r >> 8);
		}
	} else {
		WORD *t = (WORD *)(void *)data;
		for (int i = 0; i < rndmap->Width(); i++, p++) {
			*t++ = p->b;
			*t++ = p->g;
			*t++ = p->r;
		}
	}
	LocalFree(pix);
	SafeArrayUnaccessData(*psa);
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::GetLine32()
//

STDMETHODIMP CMaxRenderer::GetLine32(long line, BOOL linear, SAFEARRAY **psa) {
	BMM_Color_64 *pix;
	AllocAndGetLine(line,linear,&pix);
	int size = rndmap->Width() * 4;
	*psa = SafeArrayCreateVector(VT_UI1,0,size);
	_ASSERTE(*psa);
	BYTE *data;
	SafeArrayAccessData(*psa,(void**)&data);
	_ASSERTE(data);
	BMM_Color_64 *p = pix;
	for (int i = 0; i < rndmap->Width(); i++, p++) {
		*data++ = (BYTE)(p->r >> 8);
		*data++ = (BYTE)(p->g >> 8);
		*data++ = (BYTE)(p->b >> 8);
		*data++ = (BYTE)(p->a >> 8);
	}
	LocalFree(pix);
	SafeArrayUnaccessData(*psa);
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::GetBGRLine32()
//

STDMETHODIMP CMaxRenderer::GetBGRLine32(long line, BOOL linear, SAFEARRAY **psa) {
	BMM_Color_64 *pix;
	AllocAndGetLine(line,linear,&pix);
	int size = rndmap->Width() * 4;
	*psa = SafeArrayCreateVector(VT_UI1,0,size);
	_ASSERTE(*psa);
	BYTE *data;
	SafeArrayAccessData(*psa,(void**)&data);
	_ASSERTE(data);
	BMM_Color_64 *p = pix;
	for (int i = 0; i < rndmap->Width(); i++, p++) {
		*data++ = (BYTE)(p->b >> 8);
		*data++ = (BYTE)(p->g >> 8);
		*data++ = (BYTE)(p->r >> 8);
		*data++ = (BYTE)(p->a >> 8);
	}
	LocalFree(pix);
	SafeArrayUnaccessData(*psa);
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::GetBGRLine64()
//

STDMETHODIMP CMaxRenderer::GetBGRLine64(long line, BOOL linear, SAFEARRAY **psa) {
	BMM_Color_64 *pix;
	AllocAndGetLine(line,linear,&pix);
	int size = rndmap->Width() * 4;
	*psa = SafeArrayCreateVector(VT_UI1,0,size);
	_ASSERTE(*psa);
	BYTE *data;
	SafeArrayAccessData(*psa,(void**)&data);
	_ASSERTE(data);
	BMM_Color_64 *p = pix;
	WORD *t = (WORD *)(void *)data;
	for (int i = 0; i < rndmap->Width(); i++, p++) {
		*t++ = p->b;
		*t++ = p->g;
		*t++ = p->r;
		*t++ = p->a;
	}
	LocalFree(pix);
	SafeArrayUnaccessData(*psa);
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::GetLine64()
//

STDMETHODIMP CMaxRenderer::GetLine64(long line, BOOL linear, SAFEARRAY **psa) {
	int size = rndmap->Width() * 8;
	*psa = SafeArrayCreateVector(VT_UI1,0,size);
	_ASSERTE(*psa);
	BMM_Color_64 *pix;
	SafeArrayAccessData(*psa,(void**)&pix);
	_ASSERTE(pix);
	if (linear)
		rndmap->GetLinearPixels(0,line,rndmap->Width(),pix);
	else
		rndmap->GetPixels(0,line,rndmap->Width(),pix);
	SafeArrayUnaccessData(*psa);
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::ExecuteMAXScriptFile()
//

STDMETHODIMP CMaxRenderer::ExecuteMAXScriptFile(BSTR FileName) {
	LPTSTR filename;
	USES_CONVERSION;
	filename = OLE2T(FileName);
	if (!ExecuteFileScript(filename))
		return Error(GetString(IDS_SCRIPT_ERROR));
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::ExecuteMAXScriptString()
//

STDMETHODIMP CMaxRenderer::ExecuteMAXScriptString(BSTR String) {
	LPTSTR string;
	USES_CONVERSION;
	string = OLE2T(String);
	if (!ExecuteStringScript(string))
		return Error(GetString(IDS_SCRIPT_ERROR));
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::ReadBitmapInfo()
//

void CMaxRenderer::ReadBitmapInfo(IMaxBitmapInfo* pBif) {
	short s;
	float f;
	pBif->get_Width(&s);
	bi.SetWidth(s);
	pBif->get_Height(&s);
	bi.SetHeight(s);
	pBif->get_Gamma(&f);
	bi.SetGamma(f);
	pBif->get_Aspect(&f);
	bi.SetAspect(f);
	BOOL b;
	pBif->get_ProcessGamma(&b);
	bi.SetFlags(MAP_HAS_ALPHA);
	bi.ResetCustomFlag(0xFFFFFFFF);
	if (b)
		bi.SetCustomFlag(BMM_CUSTOM_GAMMA);
	bi.SetType(BMM_TRUE_64);
	pBif->get_Channels((MAXGBufferFlags *)(void *)&image_channels);
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::CreateBitmap()
//

void CMaxRenderer::CreateBitmap( ) {
	long w,h;
	if (renderregion) {
		w = region_rect.right - region_rect.left + 1;
		h = region_rect.bottom - region_rect.top + 1;
	} else {
		w = bi.Width();
		h = bi.Height();
	}
	if (rndmap) {
		if (rndmap->Width() == w &&
			rndmap->Height() == h)
			return;
		DestroyBitmap();
	}
	BitmapInfo tbi = bi;
	tbi.SetWidth(short(w));
	tbi.SetHeight(short(h));
	rndmap = Bmi()->Create(&tbi);
	_ASSERTE(rndmap);
	if (image_channels)
		rndmap->PrepareGChannels(image_channels);
}

//-----------------------------------------------------------------------------
// #> CMaxRenderer::DestroyBitmap()
//

void CMaxRenderer::DestroyBitmap() {
	if (rndmap) {
		rndmap->DeleteThis();
		rndmap = NULL;
	}
}

//-----------------------------------------------------------------------------
// CMaxRenderer::RenderThread()

void CMaxRenderer::RenderThread() {

    HRESULT hRes = CoInitialize(NULL);
	_ASSERTE(SUCCEEDED(hRes));

	//-- Marshal Outgoing Interfaces
	
	for (int i = 0; i < aProxy.Count(); i++) {
		hRes = CoGetInterfaceAndReleaseStream(aProxy[i].pStream,IID_IDispatch,(void **)&aProxy[i].p);
		_ASSERTE(SUCCEEDED(hRes));
	}

	rendering		= true;
	rndCB			= new maxRndProgressCB;
	rndCB->abort	= false;
	rndCB->cmax		= this;
	Interface *max	= Max();
	_ASSERTE(max);

	RECT *r;
	if (renderregion)
		r = &region_rect;
	else
		r = NULL;

	max->CurRendererRenderFrame(rndtime,rndmap,rndCB,rnddur,NULL,r);
	rendering		= false;

	OnRenderDone();

	while (aProxy.Count()) {
		aProxy.Delete(0,1);
		aProxy.Shrink();
	}

	CoUninitialize();
	delete rndCB;

}

//-- EOF: MaxRenderer.cpp -----------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\mscom.h ===
//-----------------------------------------------------------------------------
// ----------------
// File ....: mscom.h
// ----------------
// Author...: Gus J Grubba
// Date ....: October 1995
// Descr....: MSCOM File I/O Module
//
// History .: Oct, 26 1995 - Started
//            
//
//
//-----------------------------------------------------------------------------
        
#ifndef _MSCOMCLASS_
#define _MSCOMCLASS_

#define DLLEXPORT __declspec(dllexport)

#define _REGISTERCOM	_T("RegisterMAXRenderer")
#define _UNREGISTERCOM	_T("UnregisterMAXRenderer")

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//


class GUP_MSCOM : public GUP {
    
	public:
     
		//-- Constructors/Destructors
        
				GUP_MSCOM		( );
				~GUP_MSCOM		( );
	
		//-- GUP Methods

		DWORD	Start			( );
		void	Stop			( );
		DWORD	Control			( DWORD parameter );

		//-- Private Control Methods (For Utility PlugIn Access)

		bool	IsCOMRegistered	( );
		bool	RegisterCOM		( );
		bool	UnRegisterCOM	( );

};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// MSCOM Class Description

class mClassDesc:public ClassDesc {
	
	public:
												
		int             IsPublic     ( );
		void           *Create       ( BOOL );
		const TCHAR    *ClassName    ( );
		SClass_ID       SuperClassID ( );
		Class_ID        ClassID      ( );
		const TCHAR    *Category     ( );

};

#endif

//-- EOF: mscom.h -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\mscom.cpp ===
//-----------------------------------------------------------------------------
// --------------------
// File ....: mscom.cpp
// --------------------
// Author...: Gus J Grubba
// Date ....: October 1998
// Descr....: MS COM/DCOM Server for 3D Studio MAX
//
// History .: Oct, 1 1998 - Started
//            
//-----------------------------------------------------------------------------

//-- Include files

#include <Max.h>
#include <bmmlib.h>
#include <guplib.h>

#define _IN_MSCOM_
#include "mscom.h"

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

extern bool StartServer	( HINSTANCE hInstance, HINSTANCE MaxhInstance, int registerCOM );
extern void StopServer	( );
extern LPCTSTR FindToken(LPCTSTR p1);

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
	switch (fdwReason) {
		 case DLL_PROCESS_ATTACH:
				if (hInst)
					return(FALSE);
				hInst = hDLLInst;
				break;
		 case DLL_PROCESS_DETACH:
				hInst  = NULL;
				break;
		 case DLL_THREAD_ATTACH:
				break;
		 case DLL_THREAD_DETACH:
				break;
	}
	return TRUE;
}

//-----------------------------------------------------------------------------
//-- Resource String Helper

TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

int             mClassDesc::IsPublic     ( )		{ return 1; }
void           *mClassDesc::Create       ( BOOL )	{ return new GUP_MSCOM; }
const TCHAR    *mClassDesc::ClassName    ( )		{ return _T("MaxRenderer COM Server"); }
SClass_ID       mClassDesc::SuperClassID ( )		{ return GUP_CLASS_ID; }
Class_ID        mClassDesc::ClassID      ( )		{ return Class_ID(470000002,0); }
const TCHAR    *mClassDesc::Category     ( )		{ return _T("Global Utility PlugIn"); }

static mClassDesc cdesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
	return _T("MaxRenderer COM server global utility (Kinetix)"); 
}

DLLEXPORT int LibNumberClasses ( ) { 
	return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
	switch(i) {
		case  0: return &cdesc;	break;
		default: return 0;		break;
	}
}

DLLEXPORT ULONG LibVersion ( )  { 
	return ( VERSION_3DSMAX ); 
}

//-----------------------------------------------------------------------------
// #> GUP_MSCOM::GUP_MSCOM()

GUP_MSCOM::GUP_MSCOM( ) { 

}

GUP_MSCOM::~GUP_MSCOM ( ) {

}

//-----------------------------------------------------------------------------
// #> GUP_MSCOM::Start()

DWORD GUP_MSCOM::Start( ) {
	
	bool toregister		= false;
	bool tounregister	= false;

	LPTSTR lpCmdLine;
	lpCmdLine = GetCommandLine();
	LPCTSTR lpszToken = FindToken(lpCmdLine);
	while (lpszToken != NULL) {
		if (lstrcmpi(lpszToken,_REGISTERCOM)==0) {
			toregister = true;
			break;
		}
		if (lstrcmpi(lpszToken,_UNREGISTERCOM)==0) {
			tounregister = true;
			break;
		}
		lpszToken = FindToken(lpszToken);
	}

	//-----------------------------------------------------
	//-- If not registered

	if (!IsCOMRegistered()) {

		//-- We are registering ourselves
		
		if (toregister) {
			StartServer(hInst,MaxInst(),2);
			return GUPRESULT_ABORT;
		}
		
		//-- Not registered and not registering, no need to
		//   stay around.

		return GUPRESULT_NOKEEP;
	
	//-----------------------------------------------------
	//-- If registered
	
	} else {

		//-- Unregistering COM/DCOM server

		if (tounregister) {
			StartServer(hInst,MaxInst(),1);
			return GUPRESULT_ABORT;
		}

	}

	//-----------------------------------------------------
	//-- Normal Operation
	
	StartServer(hInst,MaxInst(),0);	
	return GUPRESULT_KEEP;
}

//-----------------------------------------------------------------------------
// #> GUP_MSCOM::Stop()

void GUP_MSCOM::Stop( ) {
	if (IsCOMRegistered())
		StopServer();
}

//-----------------------------------------------------------------------------
// #> GUP_MSCOM::Control()

DWORD GUP_MSCOM::Control( DWORD parameter ) {
	switch (parameter) {
		case 0:	return (DWORD)IsCOMRegistered();
		case 1:	return (DWORD)RegisterCOM();
		case 2:	return (DWORD)UnRegisterCOM();
	}
	return 0;
}

//-----------------------------------------------------------------------------
// #> GUP_MSCOM::IsCOMRegistered()

bool GUP_MSCOM::IsCOMRegistered( ) {
	TCHAR szKeyName[256];
	TCHAR clsidApp[] = {"{4AD72E6E-5A4B-11D2-91CB-0060081C257E}"};
	wsprintf(szKeyName,"CLSID\\%s",clsidApp);
	HKEY	hKey;
	long retVal = RegOpenKeyEx(HKEY_CLASSES_ROOT,szKeyName,0,KEY_READ,&hKey);
	if (retVal == ERROR_SUCCESS) {
		RegCloseKey(hKey);
		return true;
	}
	return false;
}

//-----------------------------------------------------------------------------
// #> GUP_MSCOM::RegisterCOM()

bool GUP_MSCOM::RegisterCOM( ) {
	if (IsCOMRegistered())
		return false;
	bool res = StartServer(hInst,MaxInst(),2);
	return res;
}

//-----------------------------------------------------------------------------
// #> GUP_MSCOM::UnRegisterCOM()

bool GUP_MSCOM::UnRegisterCOM( ) {
	bool res = StartServer(hInst,MaxInst(),1);
	return res;
}

//-- EOF: mscom.cpp -----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by comsrv.rc
//
#define IDS_PROJNAME                    100
#define IDR_Comsrv                      100
#define IDR_MAXRENDERER                 101
#define IDS_NO_FILE_ERROR               101
#define IDR_BITMAPINFO                  102
#define IDS_NO_CAMERA_ERROR             102
#define IDS_OPEN_RENDERER_ERROR         103
#define IDS_INVALID_BITMAP_HANDLE       104
#define IDS_THREAD_ERROR                105
#define IDS_MAX_BUSY                    106
#define IDS_SINK_ERROR                  107
#define IDR_MAXBITMAP                   108
#define IDS_STREAM_ERROR                110
#define IDS_BITMAP_NOT_CREATED          111
#define IDS_RENDERER_NOT_OPEN           112
#define IDS_UNDEFINED_TYPE              113
#define IDS_SCRIPT_ERROR                114
#define IDS_RENDER_PARAM_ERROR          115
#define IDS_RECT_NOT_SET                115
#define IDI_MAXICON                     201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__4AD72E64_5A4B_11D2_91CB_0060081C257E__INCLUDED_)
#define AFX_STDAFX_H__4AD72E64_5A4B_11D2_91CB_0060081C257E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
    HANDLE hMonitorThread;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4AD72E64_5A4B_11D2_91CB_0060081C257E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

//_ATL_STATIC_REGISTRY
//_ATL_MIN_CRT


//        WIN32,_DEBUG,_WINDOWS,_MBCS
//_WINDLL,WIN32,NDEBUG,_WINDOWS,_MBCS,_ATL_DLL

//#ifndef _DEBUG
//#define _DEBUG
//#include <atlimpl.cpp>
//#undef _DEBUG
//#else
#include <atlimpl.cpp>
//#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\MaxClient\MaxClient.cpp ===
//-----------------------------------------------------------------------------
// MaxClient.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
//#include <objbase.h>
#include <atlbase.h>
#include <atlcom.h>
#include <atlimpl.cpp>

#include "MaxClient.h"
#include "MaxClientDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CComModule _Module;
BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

//-----------------------------------------------------------------------------
// CMaxClientApp

BEGIN_MESSAGE_MAP(CMaxClientApp, CWinApp)
	//{{AFX_MSG_MAP(CMaxClientApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

//-----------------------------------------------------------------------------
// #> CMaxClientApp::CMaxClientApp()
//

CMaxClientApp::CMaxClientApp() {

}

//-----------------------------------------------------------------------------
// The one and only CMaxClientApp object

CMaxClientApp theApp;

//-----------------------------------------------------------------------------
// #> CMaxClientApp::IsTypeLibRegistered()

bool CMaxClientApp::IsTypeLibRegistered( ) {
	HKEY hKey;
	long retVal = RegOpenKeyEx(HKEY_CLASSES_ROOT,"TypeLib\\{4AD72E61-5A4B-11D2-91CB-0060081C257E}",0,KEY_READ,&hKey);
	if (retVal == ERROR_SUCCESS) {
		RegCloseKey(hKey);
		return true;
	}
	return false;
}


//-----------------------------------------------------------------------------
// #> CMaxClientApp::RegisterTypeLibrary()
//

bool CMaxClientApp::RegisterTypeLibrary() {
	bool result = false;
	char szFileName[MAX_PATH];
	GetModuleFileName(m_hInstance,szFileName,MAX_PATH);
	OLECHAR wszFileName[MAX_PATH];
	mbstowcs(wszFileName, szFileName, MAX_PATH);
	ITypeLib *ptl = 0;
	HRESULT hr = LoadTypeLib(wszFileName, &ptl);
	if (SUCCEEDED(hr)) {
		hr = RegisterTypeLib(ptl, wszFileName, 0);
		ptl->Release();
		result = true;
	}
	return result;
}

//-----------------------------------------------------------------------------
// CMaxClientApp initialization

BOOL CMaxClientApp::InitInstance() {

	HRESULT hr = CoInitialize(NULL);
	_ASSERTE(SUCCEEDED(hr));
	_Module.Init(ObjectMap,m_hInstance);
	
	//-- Handle Registration

	if (!IsTypeLibRegistered()) {
		if (!RegisterTypeLibrary()) {

			//-- Won't do much...

		}
	}

	#ifdef _AFXDLL
	Enable3dControls();
	#else
	Enable3dControlsStatic();
	#endif

	CMaxClientDlg dlg;
	m_pMainWnd = &dlg;
	dlg.DoModal();
	CoUninitialize();
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\MaxClient\MaxClientDlg.h ===
// MaxClientDlg.h : header file
//

#if !defined(AFX_MAXCLIENTDLG_H__4E380CA1_5DB1_11D2_91CB_0060081C257E__INCLUDED_)
#define AFX_MAXCLIENTDLG_H__4E380CA1_5DB1_11D2_91CB_0060081C257E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#import "..\..\..\..\..\exe\stdplugs\comsrv.gup"  no_namespace named_guids

class CMaxRendererEvents;

//#define SINKDECL void __stdcall
//#define SINKDECL HRESULT

//-----------------------------------------------------------------------------
// CMaxClientDlg dialog

class CMaxClientDlg : public CDialog {
// Construction
public:
	CMaxClientDlg(CWnd* pParent = NULL);
	~CMaxClientDlg();
	
	IMaxBitmapInfo*					pBif;
	IMaxRenderer*					pMax;
	
	CComPtr<IUnknown>				ptrEventsUnk;
	CComObject<CMaxRendererEvents>* pMaxEvents;

	HBITMAP		hPreview;
	BYTE*		pPreview;
	long		preview_curline;
	bool		bInitialized,bMaxFileLoaded,bCameraDefined,bRendering;
	DWORD		cookie;

	bool	CreateObjectInstance	(REFCLSID rclsid,REFIID riid,LPVOID *ppv);
	void	UpdateServerEdit		( );
	void	ResetCamera				(bool b = true);
	void	UpdatePreview			(long Done, long Total);
	void	UpdateControls			( );
	void	StartSink				( );
	void	StopSink				( );

// Dialog Data
	//{{AFX_DATA(CMaxClientDlg)
	enum { IDD = IDD_MAXCLIENT_DIALOG };
	CEdit	m_ServerControl;
	CButton	m_LocalButton;
	CButton	m_CreateButton;
	CStatic	m_PreviewWindow;
	CEdit	m_ScriptTextControl;
	CButton	m_ScriptButtonControl;
	CButton	m_CancelRenderControl;
	CButton	m_ListCameraControl;
	CProgressCtrl	m_ProgressControl;
	CStatic	m_MessagesControl;
	CComboBox	m_CamerasControl;
	CButton	m_RenderButton;
	CEdit	m_MaxFileEdit;
	CButton	m_LoadButton;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMaxClientDlg)
	public:
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CMaxClientDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnCreateInstance();
	afx_msg void OnLoadMaxFile();
	afx_msg void OnListcameras();
	afx_msg void OnRender();
	afx_msg void OnCancelRender();
	afx_msg void OnScript();
	afx_msg void OnLocal();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//-----------------------------------------------------------------------------
//-- Client Connection Point

class CMaxRendererEvents : 
		public IDispatchImpl<_IMaxRendererEvents,&IID__IMaxRendererEvents,&LIBID_COMSRVLib>,
		public CComObjectRoot {
	
	public:

		CMaxRendererEvents(){};

	BEGIN_COM_MAP(CMaxRendererEvents)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(_IMaxRendererEvents)
	END_COM_MAP()

	//-- Sink Methods

	STDMETHODIMP OnEnumCameras			( BSTR CameraName );
    STDMETHODIMP OnRenderProgress		( long Done, long Total );
    STDMETHODIMP OnRenderMessage		( BSTR Message );
    STDMETHODIMP OnRenderDone			( void );

	STDMETHODIMP raw_OnEnumCameras		( BSTR CameraName )			{ return OnEnumCameras		( CameraName ); }
	STDMETHODIMP raw_OnRenderProgress	( long Done, long Total )	{ return OnRenderProgress	( Done, Total ); }
	STDMETHODIMP raw_OnRenderMessage	( BSTR Message )			{ return OnRenderMessage	( Message ); }
	STDMETHODIMP raw_OnRenderDone		( void )					{ return OnRenderDone		( ); }

	//-- Local Helpers

	CMaxClientDlg *dlg;
	void	SetParentIface (CMaxClientDlg *p)	{ dlg = p; }

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAXCLIENTDLG_H__4E380CA1_5DB1_11D2_91CB_0060081C257E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\MaxClient\MaxClient.h ===
// MaxClient.h : main header file for the MAXCLIENT application
//

#if !defined(AFX_MAXCLIENT_H__4E380C9F_5DB1_11D2_91CB_0060081C257E__INCLUDED_)
#define AFX_MAXCLIENT_H__4E380C9F_5DB1_11D2_91CB_0060081C257E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CMaxClientApp:
// See MaxClient.cpp for the implementation of this class
//

class CMaxClientApp : public CWinApp
{
public:
	CMaxClientApp();
	bool	IsTypeLibRegistered		( );
	bool	RegisterTypeLibrary		( );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMaxClientApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMaxClientApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAXCLIENT_H__4E380C9F_5DB1_11D2_91CB_0060081C257E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\MaxClient\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	MaxClient.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\MaxClient\MaxClientDlg.cpp ===
// MaxClientDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MaxClient.h"
#include "MaxClientDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define NOCAMERA	"No Cameras" 

#define PREV_WIDTH		320
#define PREV_HEIGHT		240

#define OUTPUT_WIDTH	640
#define OUTPUT_HEIGHT	480

//#define RENDER_REGION

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();
// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD){
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::CMaxClientDlg()
//

CMaxClientDlg::CMaxClientDlg(CWnd* pParent)	: CDialog(CMaxClientDlg::IDD, pParent) {
	//{{AFX_DATA_INIT(CMaxClientDlg)
	//}}AFX_DATA_INIT
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	bInitialized	= false;
	bMaxFileLoaded	= false;
	bCameraDefined	= false;
	bRendering		= false;
	pMaxEvents		= NULL;
	pPreview		= NULL;
	hPreview		= NULL;
	preview_curline	= 0;
	cookie			= 0;
	pMax			= NULL;
	pBif			= NULL;
}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::CMaxClientDlg()
//

CMaxClientDlg::~CMaxClientDlg( ) {


}
	
//-----------------------------------------------------------------------------
// #> CMaxClientDlg::DoDataExchange()
//

void CMaxClientDlg::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMaxClientDlg)
	DDX_Control(pDX, IDC_SERVERNAME, m_ServerControl);
	DDX_Control(pDX, IDC_LOCAL, m_LocalButton);
	DDX_Control(pDX, IDC_CREATE, m_CreateButton);
	DDX_Control(pDX, IDC_PREVIEW_WINDOW, m_PreviewWindow);
	DDX_Control(pDX, IDC_SCRIPTEDIT, m_ScriptTextControl);
	DDX_Control(pDX, IDC_SCRIPT, m_ScriptButtonControl);
	DDX_Control(pDX, IDC_CANCEL_RENDER, m_CancelRenderControl);
	DDX_Control(pDX, IDC_LISTCAMERAS, m_ListCameraControl);
	DDX_Control(pDX, IDC_RENDER_PROGRESS, m_ProgressControl);
	DDX_Control(pDX, IDC_RENDER_MESSAGES, m_MessagesControl);
	DDX_Control(pDX, IDC_CAMERAS, m_CamerasControl);
	DDX_Control(pDX, IDC_RENDER, m_RenderButton);
	DDX_Control(pDX, IDC_MAXFILENAME, m_MaxFileEdit);
	DDX_Control(pDX, IDC_LOAD, m_LoadButton);
	//}}AFX_DATA_MAP
}

//-----------------------------------------------------------------------------
// #> Message Map
//

BEGIN_MESSAGE_MAP(CMaxClientDlg, CDialog)
	//{{AFX_MSG_MAP(CMaxClientDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_CREATE, OnCreateInstance)
	ON_BN_CLICKED(IDC_LOAD, OnLoadMaxFile)
	ON_BN_CLICKED(IDC_LISTCAMERAS, OnListcameras)
	ON_BN_CLICKED(IDC_RENDER, OnRender)
	ON_BN_CLICKED(IDC_CANCEL_RENDER, OnCancelRender)
	ON_BN_CLICKED(IDC_SCRIPT, OnScript)
	ON_BN_CLICKED(IDC_LOCAL, OnLocal)
	ON_BN_CLICKED(IDC_REMOTE, OnLocal)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::OnInitDialog()
//

BOOL CMaxClientDlg::OnInitDialog() {
	
	CDialog::OnInitDialog();
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);
	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL) {
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty()) {
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}
//	SetIcon(m_hIcon, TRUE);
//	SetIcon(m_hIcon, FALSE);
	SetClassLong(m_hWnd,GCL_HICON,(LONG)m_hIcon);
	
	//-------------------------------------------

	CheckRadioButton(IDC_LOCAL,IDC_REMOTE,IDC_LOCAL);

	UpdateServerEdit();
	ResetCamera();
	UpdateControls();
	return TRUE;
}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::OnSysCommand()
//

void CMaxClientDlg::OnSysCommand(UINT nID, LPARAM lParam) {
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	} else {
		CDialog::OnSysCommand(nID, lParam);
	}
}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::OnPaint()
//
void CMaxClientDlg::OnPaint() {
	if (IsIconic())	{
		CPaintDC dc(this);
		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;
		dc.DrawIcon(x, y, m_hIcon);
	} else {
		CDialog::OnPaint();
	}
}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::OnQueryDragIcon()
//

HCURSOR CMaxClientDlg::OnQueryDragIcon() {
	return (HCURSOR) m_hIcon;
}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::UpdateServerEdit()
//

void CMaxClientDlg::UpdateServerEdit() {
	BOOL flag = IsDlgButtonChecked(IDC_LOCAL);
	m_ServerControl.EnableWindow(!flag);
}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::UpdateServerEdit()
//

void CMaxClientDlg::OnLocal() {
	UpdateServerEdit();	
}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::UpdateControls()
//

void CMaxClientDlg::UpdateControls() {
	BOOL flag;
	flag = (BOOL)bInitialized;
	m_CreateButton.EnableWindow(!flag);
	if (flag) {
		m_ServerControl.EnableWindow(FALSE);
		m_LocalButton.EnableWindow(FALSE);
	}
	m_LoadButton.EnableWindow(flag);
	m_ScriptButtonControl.EnableWindow(flag);
	flag = (flag && bMaxFileLoaded);
	m_ListCameraControl.EnableWindow(flag);
	m_CamerasControl.EnableWindow(flag);
	flag = (flag && bMaxFileLoaded && bCameraDefined);
	m_RenderButton.EnableWindow(flag);
	m_CancelRenderControl.EnableWindow((BOOL)bRendering);
}

//-----------------------------------------------------------------------------
// #> CMaxRendererEvents::ResetCamera()
//

void CMaxClientDlg::ResetCamera(bool addnocamera) {
	bCameraDefined	= false;
	m_CamerasControl.ResetContent();
	if (addnocamera)
		m_CamerasControl.AddString(NOCAMERA);
	m_CamerasControl.SetCurSel(0);
}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::CreateObjectInstance()
//

bool CMaxClientDlg::CreateObjectInstance(REFCLSID rclsid,REFIID riid,LPVOID *ppv) {

	HRESULT hr;

	//-- If local, simply use registry

	if (IsDlgButtonChecked(IDC_LOCAL)) {
		
		hr = CoCreateInstance(rclsid,NULL,CLSCTX_LOCAL_SERVER,riid,ppv);

		if (FAILED(hr)) {
			MessageBox("Error Creating Local Instance of object");
			return false;
		}

	//-- If remote, use given server name

	} else {

		TCHAR server_name[MAX_PATH];
		if (!GetDlgItemText(IDC_SERVERNAME,server_name,MAX_PATH)) {
			MessageBox("Need a server name if not set to Local");
			return false;
		} else {

			COSERVERINFO server;
			memset(&server,0,sizeof(COSERVERINFO));
			_bstr_t s_name(server_name);
			server.pwszName = s_name;
			MULTI_QI mq;
			memset(&mq,0,sizeof(MULTI_QI));
			mq.pIID = &riid;

			hr = CoCreateInstanceEx(rclsid,NULL,CLSCTX_REMOTE_SERVER | CLSCTX_LOCAL_SERVER,&server,1,&mq);

			if (FAILED(hr) || FAILED(mq.hr)) {
				TCHAR txt[256];
				wsprintf(txt,"Error Creating Remote Instance (hr:%0X)",hr);
				MessageBox(txt);
				return false;
			} else
				*ppv = mq.pItf;

		}

	}

	return true;

}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::OnCreateInstance()
//

void CMaxClientDlg::OnCreateInstance() {
	HCURSOR oldcur = SetCursor(LoadCursor(NULL,IDC_WAIT));
	if (CreateObjectInstance(CLSID_MaxRenderer,IID_IMaxRenderer,(void **)&pMax)) {
		if (CreateObjectInstance(CLSID_MaxBitmapInfo,IID_IMaxBitmapInfo,(void **)&pBif)) {
			bInitialized = true;
			StartSink();
		} else
			pMax->Release();
	}
	UpdateControls();
	SetCursor(oldcur);
}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::OnLoadMaxFile()
//

void CMaxClientDlg::OnLoadMaxFile() {
	TCHAR a_name[MAX_PATH];
	if (!GetDlgItemText(IDC_MAXFILENAME,a_name,MAX_PATH))
		return;
	_bstr_t b_name(a_name);
	try {
		HRESULT hr = pMax->LoadScene(b_name);
		if (FAILED(hr)) {
			CString txt;
			txt.Format("Error loading %s",a_name);
			MessageBox(LPCTSTR(txt),"Load MAX Scene");
		} else {
			bMaxFileLoaded	= true;
			ResetCamera();
		}
	} catch(_com_error& e) {
		TRACE("Error Loading %s\n",a_name);
		TRACE("%s\n",e.ErrorMessage());
		if (e.ErrorInfo()) {
			TRACE("%s\n",e.Description());
		}
	}
	UpdateControls();
}

//-----------------------------------------------------------------------------
// #> CMaxRendererEvents::OnScript()
//

void CMaxClientDlg::OnScript() {
	TCHAR a_name[MAX_PATH];
	if (!GetDlgItemText(IDC_SCRIPTEDIT,a_name,MAX_PATH))
		return;
	_bstr_t b_name(a_name);
	try {
		HRESULT hr = pMax->ExecuteMAXScriptString(b_name);
		if (FAILED(hr)) {
			CString txt;
			txt.Format("Error executing %s",a_name);
			MessageBox(LPCTSTR(txt),"Execute MAX Script");
		}
	} catch(_com_error& e) {
		TRACE("Error Executing %s\n",a_name);
		TRACE("%s\n",e.ErrorMessage());
		if (e.ErrorInfo()) {
			TRACE("%s\n",e.Description());
		}
	}
}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::OnRender()
//

void CMaxClientDlg::OnRender() {

	m_ProgressControl.SetRange(0,100);
	m_ProgressControl.SetPos(0);
	
	try {

		if (!pPreview)
			pPreview = (BYTE *)LocalAlloc(LPTR,PREV_WIDTH * PREV_HEIGHT * 3);
		_ASSERTE(pPreview);

		preview_curline = 0;

		//-- Define Output Bitmap

		pBif->Width				= OUTPUT_WIDTH;		//-- Final Image Width
		pBif->Height			= OUTPUT_HEIGHT;	//-- Final Image Height
		pBif->Aspect			= 1.0f;				//-- Final Image Aspect Ratio
		
		//-- Optional Settings
		
		pBif->Channels			= CHAN_NONE;		//-- No Special G Buffer Channels
		pBif->Gamma				= 1.2f;				//-- Gamma Setting
		pBif->ProcessGamma		= TRUE;				//-- Enable Gamma Processing

		//-- Get Camera Name
		
		CString CameraName;
		int idx = m_CamerasControl.GetCurSel();
		m_CamerasControl.GetLBText(idx,CameraName);

		//-- Open Renderer
		
		USES_CONVERSION;
		LPOLESTR b_name = T2OLE(LPCTSTR(CameraName));

#ifdef RENDER_REGION

		pMax->OpenRenderer(b_name,pBif,TRUE);		//-- Open Renderer with camera and Output Settings

#else

		pMax->OpenRenderer(b_name,pBif,FALSE);		//-- Open Renderer with camera and Output Settings

#endif

		//-- Frame Number
		//
		//   The frame number is a float. Time between frames can be specified
		//   with a resolution up to around 1/4000 of a frame.

		TCHAR framestr[MAX_PATH];
		GetDlgItemText(IDC_FRAMENUMBER,framestr,MAX_PATH);
		float frameno = (float)(atof(framestr));

		//-- Start Render

#ifdef RENDER_REGION

		pMax->SetRegion(80,80,OUTPUT_WIDTH-81,OUTPUT_HEIGHT-81);

#endif
		
		pMax->RenderFrame(frameno,1.0f);					//-- Frame Number and Duration
		bRendering = true;

	} catch(_com_error& e) {
		TRACE("Error Rendering Frame\n");
		TRACE("%s\n",e.ErrorMessage());
		if (e.ErrorInfo()) {
			TRACE("%s\n",e.Description());
		}
	}

	UpdateControls();

}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::OnCancelRender()
//

void CMaxClientDlg::OnCancelRender() {
	pMax->CancelRenderer();
	m_MessagesControl.SetWindowText("Cancel Pending...");
}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::OnListcameras()
//

void CMaxClientDlg::OnListcameras() {
	ResetCamera(false);
	try {												//-- Exception Handling
		pMax->EnumCameras();							//-- Ask MAX to Enumerate Cameras
		if (m_CamerasControl.GetCount())				//-- If any Camera
			bCameraDefined = true;						//-- Enable rest of controls
		else
			ResetCamera();
		m_CamerasControl.SetCurSel(0);					//-- Set default to first Camera
	} catch(_com_error& e) {							//-- Handle exception
		TRACE("Error Enumerating Cameras\n");
		TRACE("%s\n",e.ErrorMessage());
		if (e.ErrorInfo()) {
			TRACE("%s\n",e.Description());
		}
	}
	UpdateControls();
}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::UpdatePreview()
//

void CMaxClientDlg::UpdatePreview(long Done, long Total) {

	bool new_data = false;

	try {

#ifdef RENDER_REGION

		int output_height	= OUTPUT_HEIGHT - 81 - 80 + 1;
		int prev_height		= PREV_HEIGHT / 2;
		int prev_width		= PREV_WIDTH  / 2;
		int x_offset		= 80;
		int y_offset		= 80;

#else

		int output_height	= OUTPUT_HEIGHT;
		int prev_height		= PREV_HEIGHT;
		int prev_width		= PREV_WIDTH;
		int x_offset		= 0;
		int y_offset		= 0;

#endif

		//-- Scale vertical image

		int top		= (Done * prev_height) / Total;
		float step	= (float)((float)output_height / (float)prev_height);

		//-- Collect some lines

		for (int i = preview_curline; i < top; i++) {
			int line = (int)(step * (float)i);
			SAFEARRAY *psa = pMax->GetPreviewLine(line,prev_width);	//-- It will scale to the given width
			BYTE *data;
			SafeArrayAccessData(psa,(void**)&data);

			BYTE *target = ((prev_height - i - 1 + y_offset) * PREV_WIDTH * 3 + (x_offset * 3)) + pPreview;
			memcpy(target,data,prev_width * 3);

			SafeArrayUnaccessData(psa);
			SafeArrayDestroy(psa);
			new_data = true;
		}
		
		//-- Silly little progress white line

		if (top < prev_height) {
			BYTE *target = ((prev_height - top - 1 + y_offset) * PREV_WIDTH * 3 + (x_offset *3)) + pPreview;
			memset(target,255,prev_width * 3);
		}

		preview_curline = top;

	} catch(_com_error& e) {
		TRACE("Error Loading Bitmap\n");
		TRACE("%s\n",e.ErrorMessage());
		if (e.ErrorInfo()) {
			TRACE("%s\n",e.Description());
		}
	}

	if (new_data) {

		//-- Very ugly but it works...

		DeleteObject(hPreview);

		BITMAPINFO bmi;
		memset(&bmi,0,sizeof(BITMAPINFO));
		bmi.bmiHeader.biSize		= sizeof(BITMAPINFOHEADER);
		bmi.bmiHeader.biBitCount	= 24;
		bmi.bmiHeader.biWidth		= PREV_WIDTH;
		bmi.bmiHeader.biHeight		= PREV_HEIGHT;
		bmi.bmiHeader.biPlanes		= 1;
		bmi.bmiHeader.biCompression	= BI_RGB;
		
		HDC hdc = ::GetDC(NULL);
		hPreview = CreateCompatibleBitmap(hdc,PREV_WIDTH,PREV_HEIGHT);
		SetDIBits(hdc,hPreview,0,PREV_HEIGHT,pPreview,&bmi,DIB_RGB_COLORS);

		m_PreviewWindow.SetBitmap(hPreview);
		m_PreviewWindow.InvalidateRect(NULL);
	}

}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::StopSink()
//

void CMaxClientDlg::StopSink() {
	if (pMaxEvents)
		AtlUnadvise(pMax,IID__IMaxRendererEvents,cookie);
	if (pMax) pMax = 0;
	if (ptrEventsUnk) ptrEventsUnk = 0;
	bInitialized	= false;
	bMaxFileLoaded	= false;
	ResetCamera();
	UpdateControls();
}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::StartSink()
//

void CMaxClientDlg::StartSink() {
	if (!pMaxEvents) {
		pMaxEvents	= new CComObject<CMaxRendererEvents>;
		ptrEventsUnk= pMaxEvents;
		HRESULT hr	= AtlAdvise(pMax,ptrEventsUnk,IID__IMaxRendererEvents,&cookie);
		if (FAILED(hr)) {
			pMaxEvents = 0;
			StopSink();
		} else
			pMaxEvents->SetParentIface(this);
	}
}

//-----------------------------------------------------------------------------
// #> CMaxClientDlg::DestroyWindow()
//

BOOL CMaxClientDlg::DestroyWindow() {
	StopSink();
	if (hPreview)
		DeleteObject(hPreview);
	if (pPreview)
		LocalFree(pPreview);
	if (pBif)
		pBif->Release();
	if (pMax)
		pMax->Release();
	return CDialog::DestroyWindow();
}

//-----------------------------------------------------------------------------
// #> CMaxRendererEvents::OnEnumCameras()
//

STDMETHODIMP CMaxRendererEvents::OnEnumCameras( BSTR CameraName ) {
	LPTSTR cameraname;
	USES_CONVERSION;
	cameraname = OLE2T(CameraName);
	dlg->m_CamerasControl.AddString(cameraname);
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRendererEvents::OnRenderProgress()
//

STDMETHODIMP CMaxRendererEvents::OnRenderProgress( long Done, long Total ) {
	dlg->m_ProgressControl.SetPos((Done*100)/Total);
	dlg->UpdatePreview(Done,Total);
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRendererEvents::OnRenderMessage()
//

STDMETHODIMP CMaxRendererEvents::OnRenderMessage( BSTR Message ) {
	LPTSTR msg;
	USES_CONVERSION;
	msg = OLE2T(Message);
	dlg->m_MessagesControl.SetWindowText(msg);
	return S_OK;
}

//-----------------------------------------------------------------------------
// #> CMaxRendererEvents::OnRenderDone()
//

STDMETHODIMP CMaxRendererEvents::OnRenderDone( void ) {
	dlg->pMax->CloseRenderer();
	dlg->bRendering = false;
	dlg->UpdatePreview(100,100);
	dlg->m_ProgressControl.SetPos(0);
	dlg->m_MessagesControl.SetWindowText("Rendering Complete");
	dlg->UpdateControls();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\MaxClient\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4E380CA3_5DB1_11D2_91CB_0060081C257E__INCLUDED_)
#define AFX_STDAFX_H__4E380CA3_5DB1_11D2_91CB_0060081C257E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _WIN32_WINNT 0x400
#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4E380CA3_5DB1_11D2_91CB_0060081C257E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\gup\comsrv\MaxClient\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MaxClient.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_MAXCLIENT_DIALOG            102
#define IDR_MAINFRAME                   128
#define IDB_PREVIEW                     129
#define IDR_TYPELIBRARY                 1
#define IDC_CREATE                      1000
#define IDC_MAXFILENAME                 1001
#define IDC_LOAD                        1002
#define IDC_RENDER                      1003
#define IDC_FRAMENUMBER                 1004
#define IDC_LISTCAMERAS                 1006
#define IDC_CAMERAS                     1007
#define IDC_RENDER_PROGRESS             1009
#define IDC_RENDER_MESSAGES             1010
#define IDC_CANCEL_RENDER               1013
#define IDC_SCRIPT                      1015
#define IDC_PREVIEW_WINDOW              1016
#define IDC_SCRIPTEDIT                  1017
#define IDC_LOCAL                       1018
#define IDC_SERVERNAME                  1019
#define IDC_REMOTE                      1021

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1022
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\BendMod\BENDMOD.CPP ===
/*===========================================================================*\
  How To Create an Object Modifier Plug-In

  FILE: BendMod.cpp

  DESCRIPTION:  Bend OSM

  CREATED BY: Dan Silva & Rolf Berteig

  HISTORY: created 30 Jauary, 1995

  Copyright (c) 1994, All Rights Reserved.
\*===========================================================================*/
#include "max.h"
#include "resource.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"

#define BIGFLOAT	float(999999)

// The unique Class_ID of this modifier.  It is specified as 
// two 32-bit quantities.
#define BEND_CID Class_ID(0x21066be6, 0x462d11cd)

// This is the Class_ID for the world space modifier version of Bend
#define BENDWSM_CID Class_ID(0x73cc4a3d, 0x3a304fb5)

// This is the DLL instance handle passed in when the plug-in is 
// loaded at startup.
HINSTANCE hInstance;

// This function returns a pointer to a string in the string table of
// the resource library.  Note that this function maintains the buffer
// and that only one string is loaded at a time.  Therefore if you intend
// to use this string, you must copy to another buffer since it will 
// be overwritten on the next GetString() call.
TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

// The bend modifier is subclasses off the SimpleMod class that handles 
// the implementation of many methods from the base classes.
class BendMod : public SimpleMod {	
	public:
		static IParamMap *pmapParam;

		BendMod();

		// --- Interhited virtual methods of Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_BENDMOD); }  
		virtual Class_ID ClassID() { return BEND_CID;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);

		// --- Interhited virtual methods of ReferenceMaker
		IOResult Load(ILoad *iload);

		// --- Interhited virtual methods of ReferenceTarget
		RefTargetHandle Clone(RemapDir& remap = NoRemap());

		// --- Interhited virtual methods of BaseObject
		TCHAR *GetObjectName() { return GetString(IDS_RB_BEND2);}

		// --- Interhited virtual methods of SimpleMod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		BOOL GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis);
		void InvalidateUI() {if (pmapParam) pmapParam->Invalidate();}
	};

// This the the class whose Map method is called to deforms each point.
class BendDeformer: public Deformer {
	public:
		Matrix3 tm,invtm, tmAbove, tmBelow;
		Box3 bbox;
		TimeValue time;
		float r, from, to;
		int doRegion;
		BendDeformer();
		BendDeformer(
			TimeValue t, ModContext &mc,
			float angle, float dir, int naxis, 
			float from, float to, int doRegion, 
			Matrix3& modmat, Matrix3& modinv);
		void SetAxis(Matrix3 &tmAxis);
		void CalcR(int axis, float angle);
		// This is the deformers callback method which gets
		// called for each point. 
		Point3 Map(int i, Point3 p); 
	};

// This is the class to create the world space modifier version of Bend.
class BendWSM : public SimpleOSMToWSMObject {
	public:
		BendWSM() {}
		BendWSM(BendMod *m) : SimpleOSMToWSMObject(m) {}

		// --- Interhited virtual methods of Animatable
		void DeleteThis() { delete this; }
		SClass_ID SuperClassID() {return WSM_OBJECT_CLASS_ID;}
		Class_ID ClassID() {return BENDWSM_CID;} 

		// --- Interhited virtual methods of ReferenceTarget
		RefTargetHandle Clone(RemapDir& remap)
			{return (new BendWSM((BendMod*)mod->Clone(remap)))->SimpleOSMToWSMClone(this,remap);}

		// --- Interhited virtual methods of BaseObject
		TCHAR *GetObjectName() {return GetString(IDS_RB_BEND2);}
	};

//--- ClassDescriptor and class vars ---------------------------------

IParamMap *BendMod::pmapParam = NULL;


//--- Parameter map/block descriptors -------------------------------

//--- Parameter map/block descriptors -------------------------------
// The parameter map descriptors define the properties of a parameter
// such as the type (spinner, radio button, check box, etc.), which
// resource ID they refer to, and which index into the virtual array
// they use.
#define PB_ANGLE	0
#define PB_DIR		1
#define PB_AXIS		2
#define PB_DOREGION	3
#define PB_FROM		4
#define PB_TO		5


//
//
// Parameters
static int axisIDs[] = {IDC_X,IDC_Y,IDC_Z};

static ParamUIDesc descParam[] = {
	// Angle
	ParamUIDesc(
		PB_ANGLE,
		EDITTYPE_FLOAT,
		IDC_ANGLE,IDC_ANGLESPINNER,
		-BIGFLOAT,BIGFLOAT,
		0.5f),

	// Direction
	ParamUIDesc(
		PB_DIR,
		EDITTYPE_FLOAT,
		IDC_DIR,IDC_DIRSPINNER,
		-BIGFLOAT,BIGFLOAT,
		0.5f),

	// Axis
	ParamUIDesc(PB_AXIS,TYPE_RADIO,axisIDs,3),

	// Affect region
	ParamUIDesc(PB_DOREGION,TYPE_SINGLECHEKBOX,IDC_BEND_AFFECTREGION),

	// From
	ParamUIDesc(
		PB_FROM,
		EDITTYPE_UNIVERSE,
		IDC_BEND_FROM,IDC_BEND_FROMSPIN,
		-BIGFLOAT,0.0f,
		SPIN_AUTOSCALE),

	// To
	ParamUIDesc(
		PB_TO,
		EDITTYPE_UNIVERSE,
		IDC_BEND_TO,IDC_BEND_TOSPIN,
		0.0f,BIGFLOAT,		
		SPIN_AUTOSCALE),	
	};
#define PARAMDESC_LENGH 6


// The parameter block descriptor defines the type of value represented
// by the parameter (int, float, Color...) and if it is animated or not.

// This class requires these values to be initialized:
// { - ParameterType, 
//   - Not Used, must be set to NULL, 
//   - Flag which indicates if the parameter is animatable,
//   - ID of the parameter used to match a corresponding ID in the 
//     other version of the parameter block (used for backwards 
//     compatability.
//  }
// The old version of the pblock.
static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 } };

// The current version
static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },	
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 } };

#define PBLOCK_LENGTH	6

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,3,0)
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);

//--- BendDlgProc -------------------------------

// Create an instance of a class derived from ParamMapUserDlgProc.  This 
// is used to provide special processing of controls in the rollup page.
class BendDlgProc : public ParamMapUserDlgProc {
	public:
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {}
	};
static BendDlgProc theBendProc;

// The dialog proc where the special processing of the limit controls is 
// handled.  This is used to ensure the limit spinners don't 'overlap'
// one another in value.
BOOL BendDlgProc::DlgProc(
		TimeValue t,IParamMap *map,
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case CC_SPINNER_CHANGE:
			switch (LOWORD(wParam)) {
				case IDC_BEND_FROMSPIN: {
					float from, to;
					map->GetParamBlock()->GetValue(PB_FROM,t,from,FOREVER);
					map->GetParamBlock()->GetValue(PB_TO,t,to,FOREVER);
					if (from>to) {
						map->GetParamBlock()->SetValue(PB_TO,t,from);
						map->Invalidate();
						}
					break;
					}
				
				case IDC_BEND_TOSPIN: {
					float from, to;
					map->GetParamBlock()->GetValue(PB_FROM,t,from,FOREVER);
					map->GetParamBlock()->GetValue(PB_TO,t,to,FOREVER);
					if (from>to) {
						map->GetParamBlock()->SetValue(PB_FROM,t,to);
						map->Invalidate();
						}
					break;
					}
				}
			break;
		}
	return FALSE;
	}

//--- Bend methods -------------------------------


BendMod::BendMod() : SimpleMod()
	{	
	// Create a reference to the parameter block.
	// SimpleMod maintains the parameter block pointer.
	// Note that SimpleMod uses two references itself.  It provides us
	// with a #define that specifies the reference index of the parameter
	// block.  This is SIMPMOD_PBLOCKREF.
	MakeRefByID(FOREVER, SIMPMOD_PBLOCKREF, 
		CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue(PB_AXIS, TimeValue(0), 2/*Z*/);
	}

// --- Interhited virtual methods of Animatable
// This method is called by the system when the user needs 
// to edit the modifiers parameters in the command panel.  
void BendMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	// Call the SimpleMod method first to take care of its processing.
	SimpleMod::BeginEditParams(ip,flags,prev);
		
	// Create the rollup page in the command panel using our descriptors.
	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_BENDPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);	
	// Here is where the special processing of the limits controls is set.
	pmapParam->SetUserDlgProc(&theBendProc);
	}
		
// This is called by the system to terminate the editing of the
// parameters in the command panel.  
void BendMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	// We must call the SimpleMod method first to take care of its 
	// processing.
	SimpleMod::EndEditParams(ip,flags,next);
	// Remove the rollup page.
	DestroyCPParamMap(pmapParam);
	}

// --- Interhited virtual methods of ReferenceMaker
// Called by MAX when the modifier is loaded from disk.
IOResult BendMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	// This is the callback that corrects for any older versions
	// of the parameter block structure found in the MAX file 
	// being loaded.
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,SIMPMOD_PBLOCKREF));
	return IO_OK;
	}

// --- Interhited virtual methods of ReferenceTarget
// This method makes a new BendMod and copies the state of this modifier
// to the new modifier.
// This method is called when the user makes a copy of
// an object in the scene or when they press the make unique
// button in the modfier stack rollup page.
RefTargetHandle BendMod::Clone(RemapDir& remap) {	
	BendMod* newmod = new BendMod();	
	newmod->ReplaceReference(SIMPMOD_PBLOCKREF,pblock->Clone(remap));
	newmod->SimpleModClone(this);
	return(newmod);
	}

// --- Interhited virtual methods of SimpleMod
// This returns the vality interval of the modifier. The SimpleMod
// class calls this method and combines the result with the 
// validity interval of the controllers controlling the gizmo and center
// to form the total validity interval.
Interval BendMod::GetValidity(TimeValue t)
	{
	float f;	
	// Start our interval at forever...
	Interval valid = FOREVER;
	// Intersect each parameters interval to narrow it down.
	pblock->GetValue(PB_ANGLE,t,f,valid);
	pblock->GetValue(PB_DIR,t,f,valid);	
	pblock->GetValue(PB_FROM,t,f,valid);
	pblock->GetValue(PB_TO,t,f,valid);
	// Return the final validity interval.
	return valid;
	}

BOOL BendMod::GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis)
	{
	int limit;
	pblock->GetValue(PB_DOREGION,t,limit,FOREVER);
	pblock->GetValue(PB_FROM,t,zmin,FOREVER);
	pblock->GetValue(PB_TO,t,zmax,FOREVER);
	pblock->GetValue(PB_AXIS,t,axis,FOREVER);
	return limit?TRUE:FALSE;
	}

BendDeformer::BendDeformer() 
	{ 
	tm.IdentityMatrix();
	time = 0;	
	}

void BendDeformer::SetAxis(Matrix3 &tmAxis)
	{
	Matrix3 itm = Inverse(tmAxis);
	tm    = tm*tmAxis;
	invtm =	itm*invtm;
	}

void BendDeformer::CalcR(int axis, float angle)
	{
	float len = float(0);
	if (!doRegion) {
		switch (axis) {
			case 0:  len = bbox.pmax.x - bbox.pmin.x; break;
			case 1:	 len = bbox.pmax.y - bbox.pmin.y; break;
			case 2:  len = bbox.pmax.z - bbox.pmin.z; break;
			}
	} else {
		len = to-from;
		}

	// Skip the singularity
	if (fabs(angle) <0.0001) {
		r = float(0);
	} else {
		r = len/angle;
		}	
	}

// This is the deformers callback method which actually gets
// called for each selected point. It deforms the point passed
// and returns it.
Point3 BendDeformer::Map(int i, Point3 p)
	{
	float x, y, c, s, yr;
	if (r==0 && !doRegion) return p;
	// The point is first transformed by the tm.  This is typical
	// for all modifiers. See the Advanced Topics section on the 
	// Geometry Pipeline for more details.
	p = p * tm;
	if (doRegion) {
		if (p.z<from) {
			return tmBelow * p * invtm;			
		} else 
		if (p.z>to) {
			return tmAbove * p * invtm;
			}
		}	
	if (r==0) return p * invtm;
	x = p.x;
	y = p.z;
	yr = y/r;
	c = float(cos(PI-yr));
	s = float(sin(PI-yr));
	p.x = r*c + r - x*c;
	p.z = r*s - x*s;
	// The point is finally transformed by the inverse of the tm.
	p = p * invtm;
	return p;
	}

BendDeformer::BendDeformer(
		TimeValue t, ModContext &mc,
		float angle, float dir, int naxis, 
		float from, float to, int doRegion,
		Matrix3& modmat, Matrix3& modinv) 
	{	
	this->doRegion = doRegion;
	this->from = from;
	this->to   = to;
	Matrix3 mat;
	Interval valid;	
	time   = t;	

	tm = modmat;
	invtm = modinv;
	mat.IdentityMatrix();
	
	switch (naxis) {
		case 0: mat.RotateY( -HALFPI );	 break; //X
		case 1: mat.RotateX( HALFPI );  break; //Y
		case 2: break;  //Z
		}
	mat.RotateZ(DegToRad(dir));	
	SetAxis(mat);	
	assert (mc.box);
	bbox = *mc.box;
	CalcR(naxis,DegToRad(angle));
	
	// Turn this off for a sec.
	this->doRegion = FALSE;
		
	float len  = to-from;
	float rat1, rat2;
	if (len==0.0f) {
		rat1 = rat2 = 1.0f;
	} else {
		rat1 = to/len;
		rat2 = from/len;
		}
	Point3 pt;
	tmAbove.IdentityMatrix();
	tmAbove.Translate(Point3(0.0f,0.0f,-to));
	tmAbove.RotateY(DegToRad(angle * rat1));
	tmAbove.Translate(Point3(0.0f,0.0f,to));
	pt = Point3(0.0f,0.0f,to);
	tmAbove.Translate((Map(0,pt*invtm)*tm)-pt);

	tmBelow.IdentityMatrix();
	tmBelow.Translate(Point3(0.0f,0.0f,-from));
	tmBelow.RotateY(DegToRad(angle * rat2));	
	tmBelow.Translate(Point3(0.0f,0.0f,from));
	pt = Point3(0.0f,0.0f,from);
	tmBelow.Translate((Map(0,pt*invtm)*tm)-pt);	
	
	this->doRegion = doRegion;
	} 

// Provides a reference to our callback object to handle the deformation.
Deformer& BendMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	float angle, dir, from, to;
	int axis;	
	int doRegion;
	pblock->GetValue(PB_ANGLE,t,angle,FOREVER);
	pblock->GetValue(PB_DIR,t,dir,FOREVER);
	pblock->GetValue(PB_AXIS,t,axis,FOREVER);
	pblock->GetValue(PB_FROM,t,from,FOREVER);
	pblock->GetValue(PB_TO,t,to,FOREVER);
	pblock->GetValue(PB_DOREGION,t,doRegion,FOREVER);
	static BendDeformer deformer;
	deformer = BendDeformer(t,mc,angle,dir,axis,from,to,doRegion,mat,invmat);
	return deformer;
	}

// Returns the dimension of the requested parameter.  The dimension is the 
// type and magnitude of the values used by that parameter.
ParamDimension *BendMod::GetParameterDim(int pbIndex)
	{
	switch (pbIndex) {
		case PB_ANGLE: 	return defaultDim; // Note: doesn't use angleDim 
										   // because the bend has been storing
										   // the angle in degrees not radians. 
										   // Changing this would invalidate 
										   // old files.
		case PB_DIR:	return defaultDim;
		case PB_FROM:	return stdWorldDim;
		case PB_TO:		return stdWorldDim;
		default:		return defaultDim;
		}
	}

// Returns the name of the parameter requested.
TSTR BendMod::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_ANGLE:	return GetString(IDS_RB_ANGLE);
		case PB_DIR:	return GetString(IDS_RB_DIRECTION);
		case PB_FROM:	return GetString(IDS_RB_FROM);
		case PB_TO:		return GetString(IDS_RB_TO);
		default:		return _T("");
		}
	}

// See the Advanced Topics section on DLL Functions and Class Descriptors
// for more information.
/*===========================================================================*\
 | The Class Descriptor
\*===========================================================================*/
class BendClassDesc:public ClassDesc {
	public:
	// The IsPublic() method should return TRUE if the plug-in can be picked
	// and assigned by the user. Some plug-ins may be used privately by other
	// plug-ins implemented in the same DLL and should not appear in lists for
	// user to choose from -- these plug-ins would return FALSE.
	int 			IsPublic() { return 1; }
	// This is the method that actually creates a new instance of
	// a plug-in class.  The system calls the correspoding 
	// DeleteThis() method of the plug-in to free the memory.  Our 
	// implementations use 'new' and 'delete'.
	void *			Create(BOOL loading = FALSE) { return new BendMod; }
	// This is the name that appears on the button
	// in the MAX user interface.
	const TCHAR *	ClassName() { return GetString(IDS_RB_BEND_CLASS); }
	// The system calls this method at startup to determine the type of object
	// this is.  In our case, we're a geometric object so we return 
	// GEOMOBJECT_CLASS_ID.  The possible options are defined in PLUGAPI.H
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	// The system calls this method to retrieve the unique
	// class id for this item.
	Class_ID		ClassID() { return BEND_CID; }
	// The category is selected
	// in the bottom most drop down list in the create branch.
	// If this is set to be an exiting category (i.e. "Primatives", ...) then
	// the plug-in will appear in that category. If the category doesn't
	// yet exists then it is created.  We use the new How To category for
	// all the example plug-ins in the How To sections.
	const TCHAR* 	Category() { return GetString(IDS_RB_HOWTO);}
	};

static BendClassDesc bendDesc;
ClassDesc* GetBendModDesc() { return &bendDesc; }

class BendWSMClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) 
		{if (loading) return new BendWSM; else return new BendWSM(new BendMod);}
	const TCHAR *	ClassName() { return GetString(IDS_RB_BEND_CLASS); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return BENDWSM_CID; }
	const TCHAR* 	Category() {return GetString(IDS_MODBASED);}
	};

static BendWSMClassDesc bendWSMDesc;
ClassDesc* GetBendWSMDesc() { return &bendWSMDesc; }

// The following five functions are used by every plug-in DLL.
/*===========================================================================*\
 | The DLL and Library Functions
\*===========================================================================*/
// This function is called by Windows when the DLL is loaded.  This 
// function may also be called many times during time critical operations
// like rendering.  Therefore developers need to be careful what they
// do inside this function.  In the code below, note how after the DLL is
// loaded the first time only a few statements are executed.
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

	if (! controlsInit) {
		controlsInit = TRUE;
		
		// Initialize MAX's custom controls
		InitCustomControls(hInstance);
		
		// Initialize Win95 controls
		InitCommonControls();
	}
	
	return(TRUE);
	}

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int LibNumberClasses() {return 2;}

// This function return the ith class descriptor
__declspec( dllexport ) ClassDesc *LibClassDesc(int i) {
	switch(i) {
		case 0: return GetBendModDesc();		
		case 1: return GetBendWSMDesc();		
		default: return 0;
		}
	}

// This function returns a string that describes the DLL.  This string appears in 
// the File / Summary Info / Plug-In Info dialog box.
__declspec( dllexport ) const TCHAR *LibDescription() { 
	return GetString(IDS_LIB_DESC); 
	}

// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\BendMod\RESOURCE.H ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BendMod.rc
//
#define IDS_RB_BENDMOD                  1
#define IDS_RB_BEND2                    2
#define IDS_RB_BEND_CLASS               3
#define IDS_MODBASED                    4
#define IDS_RB_HOWTO                    5
#define IDS_RB_PARAMETERS               6
#define IDS_RB_ANGLE                    7
#define IDS_RB_DIRECTION                8
#define IDS_RB_FROM                     9
#define IDS_RB_TO                       10
#define IDS_LIB_DESC                    11
#define IDD_BENDPARAM                   101
#define IDC_ANGLE                       1000
#define IDC_X                           1001
#define IDC_Y                           1002
#define IDC_Z                           1003
#define IDC_DIR                         1004
#define IDC_ANGLESPINNER                1005
#define IDC_DIRSPINNER                  1006
#define IDC_BEND_AFFECTREGION           1108
#define IDC_BEND_TO                     1109
#define IDC_BEND_TOSPIN                 1110
#define IDC_BEND_FROM                   1111
#define IDC_BEND_FROMSPIN               1112

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\CustCtrl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CUSTCTRL.RC
//
#define IDD_CUSTCTRL                    102
#define IDB_IMAGE                       103
#define IDB_FLYOFFIMAGE                 105
#define IDB_FLYOFFMASK                  106
#define IDB_IMAGEMASK                   107
#define IDD_MAXDLG                      116
#define IDB_TB                          159
#define IDB_TBMASK                      160
#define IDC_SPIN_EDIT                   1000
#define IDC_SPIN_SPINNER                1001
#define IDC_SPIN_TCBSPIN                1002
#define IDC_SPIN_TCBEDIT                1003
#define IDC_IMAGE                       1006
#define IDC_COLORSWATCH                 1007
#define IDC_STATUS                      1008
#define IDC_FLYOFFINDEX                 1009
#define IDC_SPINEDIT_VALUE              1010
#define IDC_TBCHECK                     1011
#define IDC_SPIN_STATUS                 1012
#define IDC_BUTTON_TEXT                 1013
#define IDC_IMAGE2D                     1014
#define IDC_TCB_GRAPH                   1015
#define IDC_DADWINDOW                   1017
#define IDC_FROM_TYPE                   1018
#define IDC_FROM_XY                     1019
#define IDC_IS_NEW                      1020
#define IDC_TO_TYPE                     1021
#define IDC_TO_XY                       1022
#define IDC_MAYBE_DROP                  1023
#define IDC_COLOR_DLG                   1024
#define IDC_TO_WHO                      1025
#define IDC_TVP_DLG                     1026
#define IDC_EXCL_DLG                    1027
#define IDC_MTL_DLG                     1028
#define IDC_EDIT                        1029
#define IDC_HBN_DLG                     1030
#define IDC_NCP_DLG                     1031
#define IDC_ARC_DLG                     1032
#define IDC_DLG1                        1033
#define IDC_INFO1                       1033
#define IDC_DLG2                        1034
#define IDC_DADBUTTON                   1034
#define IDC_INFO2                       1034
#define IDC_DLG3                        1035
#define IDC_INFO3                       1035
#define IDC_SLIDER                      1035
#define IDC_CHOOSE_DIR                  1036
#define IDC_SLIDER_EDIT                 1036
#define IDC_SLIDER1                     1037
#define IDC_SLIDER_EDIT1                1038
#define IDC_SLIDER2                     1039
#define IDC_SLIDER_EDIT2                1040
#define IDC_SLIDE_VALUE                 1042
#define IDC_SLIDE1_VALUE                1043
#define IDC_BUTTON1                     1059
#define IDC_BUTTON_CHECK                1059
#define IDC_BUTTON0                     1060
#define IDC_BUTTON_PUSH                 1060
#define IDC_TOOLBAR                     1064
#define IDC_FLYOFF                      1065

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        117
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\CustCtrl\CustCtrl.cpp ===
/*===========================================================================*\
 |    File: custctrl.cpp
 |
 | Purpose: To Demonstrate the use of the MAX Custom Controls.
 |
 |          This plug-in puts up a rollup page in the utility panel with
 |          most of the custom controls.  The comments in the source code
 |          document what is happening.  Also see the Advanced Topics 
 |          section for a description of the custom controls.
 |          Note:  This plug-in does not use Parameter Maps to manage 
 |          the user interface.  Parameter Maps can simplify UI code
 |          for many plug-ins.  See the Advanced Topics section on 
 |          Parameter Maps for more details.
 |
 | History: Mark Meier, Begun 09/28/95.
 |          MM, 04/16/96, Modified to make it a Utililty plug-in.
 |          MM, 12/20/96, Modified to use the proper C string functions. For 
 |          example, sprintf() was replaced by _stprintf().
 |          See the Advanced Topics section on Character Strings for details
 |          on the methods used to work with the MBCS character strings
 |          used by MAX.
 |          MM, 06/97, Added new demo code of dialogs and new APIs in R2.
\*===========================================================================*/
#include "max.h"		// Main MAX include file
#include "utilapi.h"	// Utility plug-in include file.
#include "resource.h"	// Resource editor include file
#include "tcbgraph.h"	// TCB Graph include file
#include "stdmat.h"		// So we can create a standard material
#include "hsv.h"		// This is so the modal color picker API can be used
#include "arcdlg.h"		// Arcball dialog include file
#include "simpobj.h"	// To get the GenBox object created by the arcdlg

/*===========================================================================*\
 | Misc defines, etc.
\*===========================================================================*/
#define MY_CATEGORY _T("How To")
#define MY_CLASSNAME _T("Custom Controls")
#define MY_CLASS_ID Class_ID(0x211f19ca, 0x67900b9e)
#define MY_LIBDESCRIPTION _T("Custom Control Tester by Mark Meier")

#define IMAGE_W 20 
#define IMAGE_H 18 
#define ICON_W 16 // Icon width - "standard" is 16
#define ICON_H 15 // Icon height - "standard" is 15
#define TB_BUT_WIDTH 22
#define TB_BUT_HEIGHT 20

#define ID_TB_1 1000 // Toolbar IDs
#define ID_TB_2 1010
#define ID_TB_3 1020

HINSTANCE hInstance;

/*===========================================================================*\
 | This is the class used by the Arc Rotate modeless dialog
\*===========================================================================*/
class MyArcDlgCB : public ArcballCallback {
	INode *node;
	Interface *ip;
	Quat qstart;
	ArcballDialog *ad;
	public:
		void StartDrag();
		void Drag(Quat q, BOOL buttonUp);
		void CancelDrag();
		void EndDrag();
		void BeingDestroyed();
		
		MyArcDlgCB() {node = NULL; ad = NULL; ip = NULL;}
		~MyArcDlgCB() {if (ad) ad->DeleteThis();}
		void SetIP(Interface *intp) {ip = intp;}
		void SetNode(INode *n) {node = n;}
		INode *GetNode() {return node;}
		void SetDialog(ArcballDialog *d) {ad = d;}
		ArcballDialog *GetDialog() {return ad;}
		void MakeMatrix(Quat q, Matrix3 &tm);
};

/*===========================================================================*\
 | This is the main plug-in class
\*===========================================================================*/
class CustCtrlUtil : public UtilityObj {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hCustCtrl, hMaxDlg;
		TCBGraphParams gp;

		// These are the handles to the custom controls in the rollup page.
		ISpinnerControl *ccSpin;
		IColorSwatch *ccColorSwatch;
		ICustEdit *ccEdit;
		ICustEdit *ccTCBEdit;
		ISpinnerControl *ccTCBSpin;
		ICustButton *ccButtonC;
		ICustButton *ccButtonP;
		ICustButton *ccFlyOff;
		ICustStatus *ccStatus;
		ICustToolbar *ccToolbar;
		ICustImage *ccImage;

		ISliderControl *ccSlider;
		ICustEdit	   *ccSliderEdit;
		ISliderControl *ccSlider1;
		ICustEdit	   *ccSliderEdit1;
		ISliderControl *ccSlider2;
		ICustEdit	   *ccSliderEdit2;

		HIMAGELIST hImageFO;
		HIMAGELIST hImageIM;
		HIMAGELIST hImageTB;
		MyArcDlgCB arcb;

		// --- Inherited Virtual Methods From UtilityObj ---
		void BeginEditParams(Interface *ip, IUtil *iu);
		void EndEditParams(Interface *ip, IUtil *iu);
		void DeleteThis() {}

		// --- Methods From CustCtrlUtil ---
		CustCtrlUtil();
		~CustCtrlUtil() {}
		void OnInitDialog(HWND hWnd);
};
static CustCtrlUtil theUtility;

/*===========================================================================*\
 | Dialog Procs
\*===========================================================================*/
// This is the dialog proc for the CUSTCTRL rollup page.
BOOL CALLBACK CustCtrlDlgProc(
	HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
	TSTR buf;
	COLORREF color;
	TCHAR s[32];
	int index;

	CustCtrlUtil *u = (CustCtrlUtil *)GetWindowLong(hWnd, GWL_USERDATA);
	if (!u && message != WM_INITDIALOG ) return FALSE;

	switch (message) {
		case WM_INITDIALOG: {
			u = (CustCtrlUtil *)lParam;
			SetWindowLong(hWnd, GWL_USERDATA, (LONG)u);
			theUtility.OnInitDialog(hWnd);
		 	return TRUE;
		}
		case WM_DESTROY: {
			// Release all our Custom Controls
			ReleaseISpinner(u->ccSpin);
			ReleaseIColorSwatch(u->ccColorSwatch);
			ReleaseICustEdit(u->ccEdit);
			ReleaseICustEdit(u->ccTCBEdit);
			ReleaseISpinner(u->ccTCBSpin);
			ReleaseICustButton(u->ccButtonP);
			ReleaseICustButton(u->ccButtonC);
			ReleaseICustButton(u->ccFlyOff);
			ReleaseICustStatus(u->ccStatus);
			ReleaseICustToolbar(u->ccToolbar);
			ReleaseICustImage(u->ccImage);
			ReleaseISlider(u->ccSlider);
			ReleaseICustEdit(u->ccSliderEdit);
			ReleaseISlider(u->ccSlider1);
			ReleaseICustEdit(u->ccSliderEdit1);
			ReleaseISlider(u->ccSlider2);
			ReleaseICustEdit(u->ccSliderEdit2);

			ImageList_Destroy(u->hImageFO);
			ImageList_Destroy(u->hImageIM);
			ImageList_Destroy(u->hImageTB);
			break;
		}
		case WM_COMMAND: {
			switch(LOWORD(wParam)) {
				// The user clicked on the Toolbar Enable checkbox.
				case IDC_TBCHECK: {
					if (IsDlgButtonChecked(hWnd, IDC_TBCHECK)) {
						// Enable the toolbar controls
						u->ccToolbar->Enable();
						// Update the images in the toolbar
						u->ccToolbar->GetICustButton(ID_TB_1)->Enable();
						u->ccToolbar->GetICustButton(ID_TB_2)->Enable();
						u->ccToolbar->GetICustButton(ID_TB_3)->Enable();
					} 
					else {
						// Disable the toolbar controls
						u->ccToolbar->Disable();
						// Update the images in the toolbar
						u->ccToolbar->GetICustButton(ID_TB_1)->Disable();
						u->ccToolbar->GetICustButton(ID_TB_2)->Disable();
						u->ccToolbar->GetICustButton(ID_TB_3)->Disable();
					};
					break;
				}
				case IDC_FLYOFF: {
					switch (HIWORD(wParam)) { // Notification codes 
						case BN_FLYOFF:
							// This notification code is sent when the user 
							// chooses a new fly off.
							index = u->ccFlyOff->GetCurFlyOff();
							_stprintf(s, _T("Fly Off Index: %d"), index);
							SetWindowText(GetDlgItem(hWnd, IDC_FLYOFFINDEX), s);
							break;
					};
					break;
				}
				case IDC_BUTTON_PUSH: {
					switch (HIWORD(wParam)) { // Notification codes 
						case BN_BUTTONDOWN:
							// Pick button is pressed.
							SetWindowText(GetDlgItem(hWnd, IDC_BUTTON_TEXT), _T("IN"));
							break;
					
						case BN_BUTTONUP:
							// Pick button is released.
							SetWindowText(GetDlgItem(hWnd, IDC_BUTTON_TEXT), _T("OUT"));
							break;

						case BN_RIGHTCLICK:
							// User has right clicked on Pick button.
							SetWindowText(GetDlgItem(hWnd, IDC_BUTTON_TEXT), _T("RIGHT"));
							break;
					};
					break;
				}
				default:
					break;
			}
			break;
		}
		case WM_NOTIFY: {
			// This is where we provide the tooltip text for the toolbar buttons...
			LPNMHDR hdr = (LPNMHDR)lParam;
			if (hdr->code == TTN_NEEDTEXT) {
				LPTOOLTIPTEXT lpttt;
				lpttt = (LPTOOLTIPTEXT)hdr;				
				switch (lpttt->hdr.idFrom) {
					case ID_TB_1:
						lpttt->lpszText = _T("Do Nothing Up");
						break;
					case ID_TB_2:
						lpttt->lpszText = _T("Do Nothing Down");
						break;
					case ID_TB_3:
						lpttt->lpszText = _T("Do Nothing Lock");
						break;
					case IDC_BUTTON_CHECK:
						if (u->ccButtonC->IsChecked())
							lpttt->lpszText = _T("Button Checked");
						else 
							lpttt->lpszText = _T("Button Un-Checked");
						break;
				};
			};
			break;
		}
		case WM_CUSTEDIT_ENTER: {
			// This message is sent when the user presses ENTER on
			// a custom edit control...
			break;
		}
		case CC_SPINNER_CHANGE: {
			switch (LOWORD(wParam)) { // Switch on ID
				case IDC_SPIN_SPINNER:
					// Update our seperate text indicator of the value.
					_stprintf(s, _T("Value: %.1f"), 
						((ISpinnerControl *)lParam)->GetFVal());
					SetWindowText(GetDlgItem(hWnd, IDC_SPINEDIT_VALUE), s);
					break;
				case IDC_SPIN_TCBSPIN:
					// Update the TCB Graph
					u->gp.tens = (((ISpinnerControl *)lParam)->GetFVal()/50.0f);
					HWND hGraph = GetDlgItem(hWnd, IDC_TCB_GRAPH);
					EnableWindow(hGraph, TRUE);
					SendMessage(hGraph,WM_SETTCBGRAPHPARAMS,0,(LPARAM)&u->gp);
					UpdateWindow(hGraph);
					break;
			};
			break;
		}
		case CC_SPINNER_BUTTONDOWN: {
			switch (LOWORD(wParam)) {
				case IDC_SPIN_SPINNER:
					// Indicate the down state of the spinner button.
					// Note this message is ALSO sent when the user enters a 
					// value by typing and then presses ENTER.  You will
					// see the DN indicator come up in the Spin MSG: line
					// if you do press ENTER.
					_stprintf(s, _T("Spin MSG: DN"));
					SetWindowText(GetDlgItem(hWnd, IDC_SPIN_STATUS), s);
					break;
			};
			break;
		}
		case CC_SPINNER_BUTTONUP: {
			switch (LOWORD(wParam)) {
				case IDC_SPIN_SPINNER:
					// Indicate the up state of the spinner button.
					_stprintf(s, _T("Spin MSG: UP"));
					SetWindowText(GetDlgItem(hWnd, IDC_SPIN_STATUS), s);
					break;
			};
			break;
		}
		case CC_COLOR_CHANGE: {
			// This message is sent when the user is changing the color
			// using the ColorSwatch control. lParam contains a pointer
			// to the ColorSwatch control.
			// What we do here is update the status control with the 
			// RGB values we get back from the ColorSwatch control.
			color = ((IColorSwatch *) lParam)->GetColor();
			_stprintf(s, _T("(%d, %d, %d)"), (int) GetRValue(color),
				(int) GetGValue(color), (int) GetBValue(color));
			u->ccStatus->SetText(s);
			break;
		}
		case CC_SLIDER_BUTTONUP:
				break;
		case CC_SLIDER_BUTTONDOWN:
				break;
		case CC_SLIDER_CHANGE: {

				int isind;
				switch (LOWORD(wParam)) { // Switch on ID
				case IDC_SLIDER:
					// Update our seperate text indicator of the value.
					_stprintf(s, _T("%.1f"), 
						((ISliderControl *)lParam)->GetFVal());
					SetWindowText(GetDlgItem(hWnd, IDC_SLIDE_VALUE), s);
					break;
				case IDC_SLIDER1:
					_stprintf(s, _T("%d"), 
						((ISliderControl *)lParam)->GetIVal());
					SetWindowText(GetDlgItem(hWnd, IDC_SLIDE1_VALUE), s);
					isind = ((ISliderControl *)lParam)->IsIndeterminate();
					// Update the TCB Graph
					if ( isind )
						((ISliderControl *)lParam)->SetIndeterminate(FALSE);
					else
						((ISliderControl *)lParam)->SetIndeterminate(TRUE);
					break;
				case IDC_SLIDER2:
					((ISliderControl *)lParam)->SetKeyBrackets(TRUE);
					break;
				}
				break;
		}
		default:
			return FALSE;
	};
	return TRUE;
}

// This is the dialog proc for the MAXDLG rollup page.
BOOL CALLBACK MaxDlgDlgProc(
	HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
	TSTR buf;

	CustCtrlUtil *u = (CustCtrlUtil *)GetWindowLong(hWnd, GWL_USERDATA);
	if (!u && message != WM_INITDIALOG ) return FALSE;

	switch (message) {
		case WM_INITDIALOG:
			u = (CustCtrlUtil *)lParam;
			SetWindowLong(hWnd, GWL_USERDATA, (LONG)u);
			SetWindowText(GetDlgItem(hWnd, IDC_INFO1), _T(""));
			SetWindowText(GetDlgItem(hWnd, IDC_INFO2), _T(""));
			SetWindowText(GetDlgItem(hWnd, IDC_INFO3), _T(""));
		 	return TRUE;

		case WM_DESTROY:
			if (u->arcb.GetDialog()) {
				u->arcb.GetDialog()->DeleteThis();
				u->arcb.SetDialog(NULL);
			}
			break;

		case WM_COMMAND: {
			switch(LOWORD(wParam)) {
				case IDC_COLOR_DLG: {
					COLORREF color;
					int ok = HSVDlg_Do(u->ip->GetMAXHWnd(), &color, NULL, NULL, _T("Pick a Color"));
					SetWindowText(GetDlgItem(hWnd, IDC_INFO1), _T(""));
					SetWindowText(GetDlgItem(hWnd, IDC_INFO2), _T(""));
					SetWindowText(GetDlgItem(hWnd, IDC_INFO3), _T(""));
					if (ok) {
						buf.printf(_T("Red=%d"), GetRValue(color));
						SetWindowText(GetDlgItem(hWnd, IDC_INFO1), buf.data());
						buf.printf(_T("Green=%d"), GetGValue(color));
						SetWindowText(GetDlgItem(hWnd, IDC_INFO2), buf.data());
						buf.printf(_T("Blue=%d"), GetBValue(color));
						SetWindowText(GetDlgItem(hWnd, IDC_INFO3), buf.data());
					}
					break;
				}
				case IDC_TVP_DLG: {
					TSTR str;
					TrackViewPick tvp;
					BOOL ok = u->ip->TrackViewPickDlg(u->ip->GetMAXHWnd(), &tvp);
					SetWindowText(GetDlgItem(hWnd, IDC_INFO1), _T(""));
					SetWindowText(GetDlgItem(hWnd, IDC_INFO2), _T(""));
					SetWindowText(GetDlgItem(hWnd, IDC_INFO3), _T(""));
					if (ok) {
						tvp.anim->GetClassName(str);
						buf.printf(_T("Anim=%s"), str);
						SetWindowText(GetDlgItem(hWnd, IDC_INFO1), buf.data());
						if (tvp.client) {
							tvp.client->GetClassName(str);
							buf.printf(_T("Client=%s"), str);
							SetWindowText(GetDlgItem(hWnd, IDC_INFO2), buf.data());
						}
						buf.printf(_T("subNum=%d"), tvp.subNum);
						SetWindowText(GetDlgItem(hWnd, IDC_INFO3), buf.data());
					}
					break;
				}
				case IDC_EXCL_DLG: {
					NameTab nl;
					int ok = u->ip->DoExclusionListDialog(&nl);
					SetWindowText(GetDlgItem(hWnd, IDC_INFO1), _T(""));
					SetWindowText(GetDlgItem(hWnd, IDC_INFO2), _T(""));
					SetWindowText(GetDlgItem(hWnd, IDC_INFO3), _T(""));
					if (ok) {
						buf.printf(_T("# Picked=%d"), nl.Count());
						SetWindowText(GetDlgItem(hWnd, IDC_INFO1), buf.data());
					}
					break;
				}
				case IDC_MTL_DLG: {
					BOOL newMat, cancel;
					MtlBase *m = u->ip->DoMaterialBrowseDlg(u->ip->GetMAXHWnd(),
						BROWSE_MATSONLY|BROWSE_INCNONE, newMat, cancel);
					SetWindowText(GetDlgItem(hWnd, IDC_INFO1), _T(""));
					SetWindowText(GetDlgItem(hWnd, IDC_INFO2), _T(""));
					SetWindowText(GetDlgItem(hWnd, IDC_INFO3), _T(""));
					if (!cancel) {
						buf.printf(_T("%s"), m->GetName());
						SetWindowText(GetDlgItem(hWnd, IDC_INFO1), buf.data());
					}
					break;
				}
				case IDC_HBN_DLG: {
					BOOL ok = u->ip->DoHitByNameDialog();
					SetWindowText(GetDlgItem(hWnd, IDC_INFO1), _T(""));
					SetWindowText(GetDlgItem(hWnd, IDC_INFO2), _T(""));
					SetWindowText(GetDlgItem(hWnd, IDC_INFO3), _T(""));
					if (ok) {
						buf.printf(_T("# selected=%d"), u->ip->GetSelNodeCount());
						SetWindowText(GetDlgItem(hWnd, IDC_INFO1), buf.data());
					}
					break;
				}
				case IDC_NCP_DLG: {
					DWORD color;
					BOOL ok = u->ip->NodeColorPicker(u->ip->GetMAXHWnd(), color);
					SetWindowText(GetDlgItem(hWnd, IDC_INFO1), _T(""));
					SetWindowText(GetDlgItem(hWnd, IDC_INFO2), _T(""));
					SetWindowText(GetDlgItem(hWnd, IDC_INFO3), _T(""));
					if (ok) {
						buf.printf(_T("Red=%d"), GetRValue(color));
						SetWindowText(GetDlgItem(hWnd, IDC_INFO1), buf.data());
						buf.printf(_T("Green=%d"), GetGValue(color));
						SetWindowText(GetDlgItem(hWnd, IDC_INFO2), buf.data());
						buf.printf(_T("Blue=%d"), GetBValue(color));
						SetWindowText(GetDlgItem(hWnd, IDC_INFO3), buf.data());
					}
					break;
				}
				case IDC_ARC_DLG: {
					if (u->arcb.GetDialog())
						u->arcb.GetDialog()->DeleteThis();
					GenBoxObject *gb = (GenBoxObject *)CreateInstance(GEOMOBJECT_CLASS_ID, Class_ID(BOXOBJ_CLASS_ID, 0));
					gb->SetParams(10.0f, 20.0f, 30.0f);
					INode *node = u->ip->CreateObjectNode(gb);
					TSTR name(_T("MyDemoBox"));
					u->ip->MakeNameUnique(name);
					node->SetName(name);
					u->ip->SelectNode(node);
					u->ip->ExecuteMAXCommand(MAXCOM_ZOOMEXT_SEL_ALL);

					u->arcb.SetIP(u->ip);
					u->arcb.SetNode(node);
					ArcballDialog *ad = CreateArcballDialog(&u->arcb, 
						u->ip->GetMAXHWnd(), _T("Arc Rotate Node"));
					u->arcb.SetDialog(ad);
				}
				break;
				case IDC_CHOOSE_DIR: {
					TCHAR dir[256];
					TCHAR desc[256];
					_tcscpy(desc, _T("Desc String"));
					u->ip->ChooseDirectory(u->ip->GetMAXHWnd(), 
						_T("Title String"), dir, desc);
					buf.printf(_T("Dir and Label"));
					SetWindowText(GetDlgItem(hWnd, IDC_INFO1), buf.data());
					buf.printf(_T("%s"), dir);
					SetWindowText(GetDlgItem(hWnd, IDC_INFO2), buf.data());
					buf.printf(_T("%s"), desc);
					SetWindowText(GetDlgItem(hWnd, IDC_INFO3), buf.data());
				}
				break;
			};
			break;
		}
		default:
			return FALSE;
	};
	return TRUE;
}

/*===========================================================================*\
 | Inheritec virtual methods from UtilityObj
\*===========================================================================*/
void CustCtrlUtil::BeginEditParams(Interface *ip, IUtil *iu) {
	this->iu = iu;
	this->ip = ip;

	// Add the rollup page for the CUSTCTRL dialog 
	hCustCtrl = ip->AddRollupPage(
		hInstance, 
		MAKEINTRESOURCE(IDD_CUSTCTRL),
		CustCtrlDlgProc,
		_T("MAX Custom Controls"), 
		(LPARAM)this);		

	// Add the rollup page for the MAXDLG dialog 
	hMaxDlg = ip->AddRollupPage(
		hInstance, 
		MAKEINTRESOURCE(IDD_MAXDLG),
		MaxDlgDlgProc,
		_T("MAX Standard Dialogs"), 
		(LPARAM)this);		
}
	
void CustCtrlUtil::EndEditParams(Interface *ip, IUtil *iu) {
	// Delete the rollup pages
	ip->DeleteRollupPage(hCustCtrl);		
	ip->DeleteRollupPage(hMaxDlg);		
	hCustCtrl = NULL;				
	hMaxDlg = NULL;
}

/*===========================================================================*\
 | Methods of CustCtrlUtil
\*===========================================================================*/
CustCtrlUtil::CustCtrlUtil() { 
	iu = NULL;
	ip = NULL;
	hCustCtrl = NULL;
	hMaxDlg = NULL; 
}

// Initialize all the Custom Controls
void CustCtrlUtil::OnInitDialog(HWND hWnd) {
	// Init the TCB values
	gp.tens = 0.0f;
	gp.bias = 0.0f;
	gp.cont = 0.0f;
	gp.easeFrom = 0.0f;
	gp.easeTo = 0.0f;

	// Initialize the Custom Edit Control
	ccEdit = GetICustEdit(GetDlgItem(hWnd, IDC_EDIT));
	ccEdit->SetText(_T("Hello world"));

 	// Initialize the Custom Spinner Control
 	ccSpin = GetISpinner(GetDlgItem(hWnd, IDC_SPIN_SPINNER));
	ccSpin->SetLimits(0.0f, 100.0f, FALSE);
	ccSpin->SetResetValue(100.0f); // Right click reset value
	ccSpin->SetValue(100.0f, FALSE); // FALSE = don't send notify yet.
	ccSpin->LinkToEdit(GetDlgItem(hWnd, IDC_SPIN_EDIT), 
		EDITTYPE_UNIVERSE);
	/*
	 * NOTE: the above code could be replaced with the following 
	 * simplified call when using integer or float spinners:

	ccSpin = SetupFloatSpinner(hWnd, IDC_SPIN_SPINNER,
		IDC_SPIN_EDIT, 0.0f, 100.0f, 100.0f);

	 * The integer version is called SetupIntSpinner()...
	*/

	ccSlider  = SetupFloatSlider(hWnd, IDC_SLIDER,IDC_SLIDER_EDIT, 0.0f, 100.0f, 30.0f, 10);
	ccSlider->SetResetValue(25.0f);
	
	ccSlider1 = SetupIntSlider(hWnd, IDC_SLIDER1, IDC_SLIDER_EDIT1, 0, 100, 50, 10);
	ccSlider1->SetResetValue(25);

	// Initialize the Custom Slider Control
	ccSlider2 = GetISlider(GetDlgItem(hWnd, IDC_SLIDER2));
	ccSlider2->SetLimits (0.0f, 100.0f, FALSE);
	ccSlider2->SetResetValue(50.0f); //Right click reset value
	ccSlider2->SetValue(50.0f, FALSE); // FALSE = don't send notify yet
	ccSlider2->LinkToEdit(GetDlgItem(hWnd, IDC_SLIDER_EDIT2), EDITTYPE_UNIVERSE);
	ccSlider2->SetNumSegs(10);

	//The previous calls could be replaced with the following simplified call

	//	ccSlider2 = SetupUniverseSlider(hWnd, IDC_SLIDER2,IDC_SLIDER_EDIT2, 0.0f, 100.0f, 50.0f, 10);
	
	SetSliderDragNotify(FALSE);

	// Init the TCB Graph spinner
	ccTCBSpin = SetupFloatSpinner(hWnd, IDC_SPIN_TCBSPIN,
		IDC_SPIN_TCBEDIT, 0.0f, 50.0f, 0.0f);
	ccTCBSpin->SetResetValue(0.0f);


	// Initialize the Custom Button Control-Push Button
	ccButtonP = GetICustButton(GetDlgItem(hWnd, IDC_BUTTON_PUSH));
	ccButtonP->SetType(CBT_PUSH);
	ccButtonP->SetRightClickNotify(TRUE);
	ccButtonP->SetButtonDownNotify(TRUE);
	ccButtonP->SetTooltip(TRUE, &(_T("Push Button Tooltip")));
	SetWindowText(GetDlgItem(hWnd, IDC_BUTTON_TEXT), _T("OUT"));// Indicator

	// Initialize the Custom Button Control-Check Button
	ccButtonC = GetICustButton(GetDlgItem(hWnd, IDC_BUTTON_CHECK));
	ccButtonC->SetType(CBT_CHECK);
	// Set the color when pressed - GREEN_WASH is defined in custcont.h
	ccButtonC->SetHighlightColor(GREEN_WASH);
	// Set tooltip to use text based on program state
	ccButtonC->SetTooltip(TRUE, LPSTR_TEXTCALLBACK);

	// Initialize the Custom Button Control-Fly Off
	ccFlyOff = GetICustButton(GetDlgItem(hWnd, IDC_FLYOFF));
	// These FlyOffData indicies control the appearance of the flyoff
	// buttons for each of four states:
	// { Out&Enabled, In&Enabled, Out&Disabled, In&Disabled }
	// This flyoff treats each case as the same and thus all the indicies
	// are the same.
	FlyOffData fod[3] = { // We have three different icons.
		{ 0,0,0,0 },
		{ 1,1,1,1 },
		{ 2,2,2,2 },
		};
	ccFlyOff->SetFlyOff(3, fod, ip->GetFlyOffTime(), 0 /* Initial value */, 
		FLY_RIGHT);
	// Here we load up the images for the flyoff...
	hImageFO = ImageList_Create(IMAGE_W, IMAGE_H, TRUE, 3, 3);
	HBITMAP hBitmap = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_FLYOFFIMAGE));
	HBITMAP hMask = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_FLYOFFMASK));
	ImageList_Add(hImageFO, hBitmap, hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);
	ccFlyOff->SetImage(hImageFO, 0,0,0,0, IMAGE_W, IMAGE_H);

	// Initialize the Custom Image Control
	// Our image is 80x50 pixels...
	ccImage = GetICustImage(GetDlgItem(hWnd, IDC_IMAGE));
	hImageIM = ImageList_Create(80, 50, TRUE, 1, 0);
	hBitmap = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_IMAGE));
	hMask = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_IMAGEMASK));
	ImageList_Add(hImageIM, hBitmap, hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);
	// Normal one...
	ccImage->SetImage(hImageIM, 0, 80, 50);

	// Initialize the Custom Toolbar Control
	ccToolbar = GetICustToolbar(GetDlgItem(hWnd, IDC_TOOLBAR));
	ccToolbar->SetBottomBorder(TRUE);
	ccToolbar->SetTopBorder(TRUE);
	hImageTB = ImageList_Create(16, 15, TRUE, 8, 0);
	hBitmap = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_TB));
	hMask = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_TBMASK));
	ImageList_Add(hImageTB, hBitmap, hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);
	ccToolbar->SetImage(hImageTB);

	// Add a little space at the left edge
	ccToolbar->AddTool(ToolSeparatorItem(3));
	// Add two push buttons
	// These buttons have two images each
	// An Enabled state and a Disabled state.
	// The indicies point to a specific 16 pixel chunk of the resource image.
	ccToolbar->AddTool(
		ToolButtonItem(CTB_PUSHBUTTON,  0,0,2,2,  16,15,
			TB_BUT_WIDTH,TB_BUT_HEIGHT,ID_TB_1));	
	ccToolbar->AddTool(
		ToolButtonItem(CTB_PUSHBUTTON,  1,1,3,3,  16,15,
			TB_BUT_WIDTH,TB_BUT_HEIGHT,ID_TB_2));	
	// A little more space
	ccToolbar->AddTool(ToolSeparatorItem(6));
	// Add a check button.  This button uses four different images for 
	// the possible states:
	// Out&Enabled, In&Enabled, Out&Disabled, In&Disabled
	// The indicies point to a specific 16 pixel chunk of the resource image.
	ccToolbar->AddTool(
		ToolButtonItem(CTB_CHECKBUTTON,  4,5,6,7,  16,15,
			TB_BUT_WIDTH,TB_BUT_HEIGHT,ID_TB_3));	
	// These methods allow the button to be highlighted in a specific color.
	// GREEN_WASH is the standard color for MAX buttons.
	ICustButton *getCustButton;
	getCustButton = ccToolbar->GetICustButton(ID_TB_3);
	getCustButton->SetCheckHighlight(TRUE);
	getCustButton->SetHighlightColor(GREEN_WASH);
	ReleaseICustButton(getCustButton);

	// Set the TB Enabled check box to true by default.
	CheckDlgButton(hWnd,IDC_TBCHECK, TRUE);

	// Initialize the Custom Status Control
	ccStatus = GetICustStatus(GetDlgItem(hWnd, IDC_STATUS));
	ccStatus->SetTextFormat(STATUSTEXT_CENTERED);
	ccStatus->SetText(_T("(0,255,128)"));

	// Initialize the Color Swatch Control
	ccColorSwatch = GetIColorSwatch(
		GetDlgItem(hWnd, IDC_COLORSWATCH),
		RGB(0,255,128), _T("ColorSwatch Dialog Box"));
	ccColorSwatch->SetColor(RGB(0,255,128), TRUE);
}

/*===========================================================================*\
 | Arc rotate callback methods
\*===========================================================================*/
void MyArcDlgCB::StartDrag() {
	Matrix3 tm = node->GetNodeTM(ip->GetTime());
	qstart = Quat(tm);
}

void MyArcDlgCB::Drag(Quat q, BOOL buttonUp) {
	Matrix3 tm;
	MakeMatrix(qstart*q, tm);
	node->SetNodeTM(ip->GetTime(), tm);
	ip->RedrawViews(ip->GetTime());
}

void MyArcDlgCB::CancelDrag() {
	Matrix3 tm;
	MakeMatrix(qstart, tm);
	node->SetNodeTM(ip->GetTime(), tm);
	ip->RedrawViews(ip->GetTime());
}

void MyArcDlgCB::EndDrag() {
}

void MyArcDlgCB::BeingDestroyed() {
	theUtility.ip->DeleteNode(node);
	ad = NULL;
}

void MyArcDlgCB::MakeMatrix(Quat q, Matrix3 &tm) {
	float ang[3];
	tm.IdentityMatrix();
	QuatToEuler(q, ang);
	tm.RotateX(ang[0]);
	tm.RotateY(ang[1]);
	tm.RotateZ(ang[2]);
}

/*===========================================================================*\
 | Class Descriptor
\*===========================================================================*/
class UtilityClassDesc : public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theUtility;}
	const TCHAR *	ClassName() {return MY_CLASSNAME;}
	SClass_ID		SuperClassID() {return SClass_ID(UTILITY_CLASS_ID);}
	Class_ID		ClassID() {return MY_CLASS_ID;}
	const TCHAR* 	Category() {return MY_CATEGORY;}
};
static UtilityClassDesc utilityCDesc;

/*===========================================================================*\
 | Lib and DLL Functions
\*===========================================================================*/
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {	
	hInstance = hinstDLL;
	if (! controlsInit) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitTCBGraph(hInstance);
		InitCommonControls();
	}
	return(TRUE);
}

__declspec(dllexport) const TCHAR *LibDescription() { 
	return MY_LIBDESCRIPTION;
}

__declspec(dllexport) int LibNumberClasses() { 
	return 1;
}

__declspec(dllexport) ClassDesc* LibClassDesc(int i) { 
	return &utilityCDesc; 
}

__declspec(dllexport) ULONG LibVersion() { 
	return VERSION_3DSMAX; 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Misc\audio.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992, 1993  Microsoft Corporation.  All Rights Reserved.
 * 
 **************************************************************************/

#ifdef __cplusplus
extern "C"
{
#endif

BOOL FAR aviaudioPlay(
	HWND hwnd, PAVISTREAM pavi, 
	LONG lCur, LONG lStart, LONG lEnd, 
	BOOL fWait, BOOL repeat);

void FAR aviaudioMessage(HWND hwnd, unsigned msg, WORD wParam, LONG lParam);
void FAR aviaudioStop(void);
LONG FAR aviaudioTime(void);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Misc\fog.cpp ===
/**********************************************************************
 *<
	FILE: fog.cpp	

	DESCRIPTION: Simple fog atmospheric effect

	CREATED BY: Rolf Berteig

	HISTORY: 11/21/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "rendpch.h"
#include "imtl.h"
#include "render.h"  
#include <bmmlib.h>
#include "iparamm.h"
#include "texutil.h"
#include "resource.h"
#include "stdmat.h"

Class_ID fogClassID(FOG_CLASS_ID,0);
#define FOG_CLASSNAME GetString(IDS_RB_FOG)

//--- Parameter Maps ----------------------------------------------------

#define PB_COLOR	0
#define PB_USEMAP	1
#define PB_USEOPAC	2
#define PB_FOGBG	3
#define PB_TYPE		4
#define PB_NEAR		5
#define PB_FAR		6
#define PB_TOP		7
#define PB_BOTTOM	8
#define PB_DENSITY	9
#define PB_FALLOFF	10
#define PB_HNOISE	11
#define PB_SCALE	12
#define PB_ANGLE	13
#define PB_PHASE	14
#define PB_EXP		15


class FogDlgProc;

class FogDADMgr: public DADMgr {
	FogDlgProc *dlg;
	public:
		FogDADMgr() { dlg =NULL;}
		void Init(FogDlgProc *d) {dlg = d; }
		// called on the draggee to see what if anything can be dragged from this x,y
		SClass_ID GetDragType(HWND hwnd, POINT p) { return TEXMAP_CLASS_ID; }
		// called on potential dropee to see if can drop type at this x,y
		BOOL OkToDrop(ReferenceTarget *dropThis, HWND hfrom, HWND hto, POINT p, SClass_ID type, BOOL isNew);
		int SlotOwner() { return OWNER_SCENE; }  
		ReferenceTarget *GetInstance(HWND hwnd, POINT p, SClass_ID type);
		void Drop(ReferenceTarget *dropThis, HWND hwnd, POINT p, SClass_ID type);
		BOOL AutoTooltip() { return TRUE; }
	};


class FogAtmos : public StdFog {
	public:
		// Parameters
		IParamBlock *pblock;
		Texmap *map, *opac;
		CRITICAL_SECTION csect;
		
		// Caches
		Color fogColor;
		float nearF, farF, top, bottom, density, far_minus_near, fog_range;
		float scale, angle, phase;
		int type, falloff, useMap, useOpac, hnoise, fogBG, exponential;
		Interval valid;		

		static FogDlgProc *dlg;

		FogAtmos();
		~FogAtmos() { 	DeleteCriticalSection(&csect);		}
		void UpdateCaches(TimeValue t);

		// Methods from StdFog:
		void SetColorMap(Texmap *tex) {	ReplaceReference(1,tex); tex->InitSlotType(MAPSLOT_ENVIRON); }
		void SetOpacMap(Texmap *tex) {	ReplaceReference(2,tex); tex->InitSlotType(MAPSLOT_ENVIRON); }
		void SetColor(Color c, TimeValue t){ pblock->SetValue(PB_COLOR,t,c); }		
		void SetUseMap(BOOL onoff){ pblock->SetValue(PB_USEMAP,0,onoff); }		
		void SetUseOpac(BOOL onoff){ pblock->SetValue(PB_USEOPAC,0,onoff); }		
		void SetFogBackground(BOOL onoff) { pblock->SetValue(PB_FOGBG,0,onoff); }		
		void SetType(int type) { pblock->SetValue(PB_TYPE,0,type); }		
		void SetNear(float v, TimeValue t) { pblock->SetValue(PB_NEAR,t,v); }		
		void SetFar(float v, TimeValue t){ pblock->SetValue(PB_FAR,t,v); }		
		void SetTop(float v, TimeValue t) { pblock->SetValue(PB_TOP,t,v); }		
		void SetBottom(float v, TimeValue t) { pblock->SetValue(PB_BOTTOM,t,v); }		
		void SetDensity(float v, TimeValue t) { pblock->SetValue(PB_DENSITY,t,v); }		
		void SetFalloffType(int tp) { pblock->SetValue(PB_FALLOFF,0,tp); }		
		void SetUseNoise(BOOL onoff)  { pblock->SetValue(PB_HNOISE,0,onoff); }		
		void SetNoiseScale(float v, TimeValue t){ pblock->SetValue(PB_SCALE,t,v); }		
		void SetNoiseAngle(float v, TimeValue t) { pblock->SetValue(PB_ANGLE,t,v); }		
		void SetNoisePhase(float v, TimeValue t) { pblock->SetValue(PB_PHASE,t,v); }		

		Color GetColor(TimeValue t) { return pblock->GetColor(PB_COLOR,t); }
		BOOL GetUseMap() { return pblock->GetInt(PB_USEMAP,0); }
		BOOL GetUseOpac() { return pblock->GetInt(PB_USEOPAC,0); }
		Texmap *GetColorMap() { return map; } 
		Texmap *GetOpacMap() { return opac; }
		BOOL GetFogBackground() { return pblock->GetInt(PB_FOGBG,0); }
		int GetType() { return pblock->GetInt(PB_TYPE,0); }
		float GetNear(TimeValue t) { return pblock->GetFloat(PB_NEAR,t); }
		float GetFar(TimeValue t) { return pblock->GetFloat(PB_FAR,t); }
		float GetTop(TimeValue t) { return pblock->GetFloat(PB_BOTTOM,t); }
		float GetBottom(TimeValue t) { return pblock->GetFloat(PB_TOP,t); }
		float GetDensity(TimeValue t) { return pblock->GetFloat(PB_DENSITY,t); }
		int GetFalloffType() { return pblock->GetInt(PB_FALLOFF,0); }
		BOOL GetUseNoise() { return pblock->GetInt(PB_HNOISE,0); }
		float GetNoiseScale( TimeValue t) { return pblock->GetFloat(PB_SCALE,t); }
		float GetNoiseAngle( TimeValue t) { return pblock->GetFloat(PB_ANGLE,t); }
		float GetNoisePhase( TimeValue t) { return pblock->GetFloat(PB_PHASE,t); }


		// Animatable/Reference
		int NumSubs() {return 3;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int NumRefs() {return 3;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		Class_ID ClassID() {return fogClassID;}
		void GetClassName(TSTR& s) {s=FOG_CLASSNAME;}
		void DeleteThis() {delete this;}
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message);

		void RescaleWorldUnits(float f);
		IOResult Load(ILoad *iload);

		// Atmospheric
		TSTR GetName() {return FOG_CLASSNAME;}
		AtmosParamDlg *CreateParamDialog(IRendParams *ip);
		int RenderBegin(TimeValue t, ULONG flags);
		int RenderEnd(TimeValue t);
		void Update(TimeValue t, Interval& valid);
		void Shade(ShadeContext& sc,const Point3& p0,const Point3& p1,Color& color, Color& trans, BOOL isBG=FALSE);		
	};

class FogParamDlg : public AtmosParamDlg {
	public:
		FogAtmos *fog;
		IRendParams *ip;
		IParamMap *pmap;

		FogParamDlg(FogAtmos *f,IRendParams *i);
		Class_ID ClassID() {return fogClassID;}
		ReferenceTarget* GetThing() {return fog;}
		void SetThing(ReferenceTarget *m);		
		void DeleteThis();
	};


class FogClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new FogAtmos; }
	const TCHAR *	ClassName() { return FOG_CLASSNAME; }
	SClass_ID		SuperClassID() { return ATMOSPHERIC_CLASS_ID; }
	Class_ID 		ClassID() { return fogClassID; }
	const TCHAR* 	Category() { return _T("");  }
	};

static FogClassDesc fogCD;
ClassDesc* GetFogDesc() {return &fogCD;}

static int typeIDs[] = {IDC_FOG_REGULAR,IDC_FOG_LAYERED};
static int falloffIDs[] = {IDC_FOG_TOPFALLOFF,IDC_FOG_BOTTOMFALLOFF,IDC_FOG_NOFALLOFF};

static ParamUIDesc descParam[] = {
	
	// Fog color
	ParamUIDesc(PB_COLOR,TYPE_COLORSWATCH,IDC_FOG_COLOR),
	
	// Use map
	ParamUIDesc(PB_USEMAP,TYPE_SINGLECHEKBOX,IDC_FOG_USEMAP),

	// Use opac
	ParamUIDesc(PB_USEOPAC,TYPE_SINGLECHEKBOX,IDC_FOG_USEOPAC),

	// Fog background
	ParamUIDesc(PB_FOGBG,TYPE_SINGLECHEKBOX,IDC_FOG_FOGBG),

	// Type
	ParamUIDesc(PB_TYPE,TYPE_RADIO,typeIDs,2),

	// Near
	ParamUIDesc(
		PB_NEAR,
		EDITTYPE_FLOAT,
		IDC_FOG_NEAR,IDC_FOG_NEARSPIN,
		0.0f,100.0f,
		0.1f,
		stdPercentDim),

	// Far
	ParamUIDesc(
		PB_FAR,
		EDITTYPE_FLOAT,
		IDC_FOG_FAR,IDC_FOG_FARSPIN,
		0.0f,100.0f,
		0.1f,
		stdPercentDim),

	// Top
	ParamUIDesc(
		PB_TOP,
		EDITTYPE_UNIVERSE,
		IDC_FOG_TOP,IDC_FOG_TOPSPIN,
		-999999999.0f,999999999.0f,
		0.1f),

	// Bottom
	ParamUIDesc(
		PB_BOTTOM,
		EDITTYPE_UNIVERSE,
		IDC_FOG_BOTTOM,IDC_FOG_BOTTOMSPIN,
		-999999999.0f,999999999.0f,
		0.1f),

	// Density
	ParamUIDesc(
		PB_DENSITY,
		EDITTYPE_FLOAT,
		IDC_FOG_DENISITY,IDC_FOG_DENISITYSPIN,
		0.0f,999999999.0f,
		0.1f),

	// Falloff
	ParamUIDesc(PB_FALLOFF,TYPE_RADIO,falloffIDs,3),

	// HNoise
	ParamUIDesc(PB_HNOISE,TYPE_SINGLECHEKBOX,IDC_FOG_HNOISE),

	// Scale
	ParamUIDesc(
		PB_SCALE,
		EDITTYPE_FLOAT,
		IDC_FOG_SCALE,IDC_FOG_SCALESPIN,
		0.0f,999999999.0f,
		0.01f),

	// Angle
	ParamUIDesc(
		PB_ANGLE,
		EDITTYPE_FLOAT,
		IDC_FOG_ANGLE,IDC_FOG_ANGLESPIN,
		0.0f,90.0f,
		0.1f,
		stdAngleDim),

	// Phase
	ParamUIDesc(
		PB_PHASE,
		EDITTYPE_FLOAT,
		IDC_FOG_PHASE,IDC_FOG_PHASESPIN,
		-999999999.0f,999999999.0f,
		0.1f),	

	// Exponential
	ParamUIDesc(PB_EXP,TYPE_SINGLECHEKBOX,IDC_FOG_EXP),
	};
#define PARAMDESC_LENGH 16

static ParamBlockDescID descVer0[] = {
	{ TYPE_POINT3, NULL, TRUE, 0 }, // color
	{ TYPE_INT, NULL, FALSE, 1 },	// use map	
	{ TYPE_INT, NULL, FALSE, 2 },	// fog background
	{ TYPE_INT, NULL, FALSE, 3 },	// type
	{ TYPE_FLOAT, NULL, TRUE, 4 },	// near
	{ TYPE_FLOAT, NULL, TRUE, 5 },	// far
	{ TYPE_FLOAT, NULL, TRUE, 6 }, 	// top
	{ TYPE_FLOAT, NULL, TRUE, 7 },	// bottom
	{ TYPE_FLOAT, NULL, TRUE, 8 },	// density
	{ TYPE_INT, NULL, FALSE, 9 }}; 	// falloff

static ParamBlockDescID descVer1[] = {
	{ TYPE_RGBA, NULL, TRUE, 0 },	// color
	{ TYPE_INT, NULL, FALSE, 1 },	// use map
	{ TYPE_INT, NULL, FALSE, 10 },	// use opac
	{ TYPE_INT, NULL, FALSE, 2 },	// fog background
	{ TYPE_INT, NULL, FALSE, 3 },	// type
	{ TYPE_FLOAT, NULL, TRUE, 4 },	// near
	{ TYPE_FLOAT, NULL, TRUE, 5 },	// far
	{ TYPE_FLOAT, NULL, TRUE, 6 }, 	// top
	{ TYPE_FLOAT, NULL, TRUE, 7 },	// bottom
	{ TYPE_FLOAT, NULL, TRUE, 8 },	// density
	{ TYPE_INT, NULL, FALSE, 9 },	// falloff
	{ TYPE_INT, NULL, FALSE, 11 },	// hnoise
	{ TYPE_FLOAT, NULL, TRUE, 12 },	// scale
	{ TYPE_FLOAT, NULL, TRUE, 13 },	// angle
	{ TYPE_FLOAT, NULL, TRUE, 14 },	// phase	
	}; 	

static ParamBlockDescID descVer2[] = {
	{ TYPE_RGBA, NULL, TRUE, 0 },	// color
	{ TYPE_INT, NULL, FALSE, 1 },	// use map
	{ TYPE_INT, NULL, FALSE, 10 },	// use opac
	{ TYPE_INT, NULL, FALSE, 2 },	// fog background
	{ TYPE_INT, NULL, FALSE, 3 },	// type
	{ TYPE_FLOAT, NULL, TRUE, 4 },	// near
	{ TYPE_FLOAT, NULL, TRUE, 5 },	// far
	{ TYPE_FLOAT, NULL, TRUE, 6 }, 	// top
	{ TYPE_FLOAT, NULL, TRUE, 7 },	// bottom
	{ TYPE_FLOAT, NULL, TRUE, 8 },	// density
	{ TYPE_INT, NULL, FALSE, 9 },	// falloff
	{ TYPE_INT, NULL, FALSE, 11 },	// hnoise
	{ TYPE_FLOAT, NULL, TRUE, 12 },	// scale
	{ TYPE_FLOAT, NULL, TRUE, 13 },	// angle
	{ TYPE_FLOAT, NULL, TRUE, 14 },	// phase	
	{ TYPE_INT, NULL, FALSE, 15},   // exponential
	}; 	

#define PBLOCK_LENGTH	16

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,10,0),	
	ParamVersionDesc(descVer1,15,1),
	};

#define NUM_OLDVERSIONS	2

#define CURRENT_VERSION	2
static ParamVersionDesc curVersion(descVer2,PBLOCK_LENGTH,CURRENT_VERSION);


//--- FogDlgProc ----------------------------------------------------------

class FogDlgProc : public ParamMapUserDlgProc {
	public:
		IParamMap *pmap;
		FogAtmos *fog;
		IRendParams *ip;
		HWND hWnd;
		ICustButton *mapBut[2];
		FogDADMgr dadMgr;

		FogDlgProc(IParamMap *pmap,FogAtmos *f,IRendParams *i);
		~FogDlgProc();

		void AssignMap(int which);
		void SetMap(int which, Texmap *m);
		void Init();
		void SetState();
		void Invalidate() {pmap->Invalidate();}//{ if (hWnd) InvalidateRect(hWnd,NULL,0); }
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};
  
//------------------------------------------------------------------------------
// Drag And Drop manager
//------------------------------------------------------------------------------

BOOL FogDADMgr::OkToDrop(ReferenceTarget *dropThis, HWND hfrom, HWND hto, POINT p, SClass_ID type, BOOL isNew) {
	if (hfrom==hto) return FALSE;
	return (type==TEXMAP_CLASS_ID)?1:0;
	}

ReferenceTarget *FogDADMgr::GetInstance(HWND hwnd, POINT p, SClass_ID type) {
	if (hwnd==GetDlgItem(dlg->hWnd,IDC_FOG_MAPNAME))
		return dlg->fog->map;
	if (hwnd==GetDlgItem(dlg->hWnd,IDC_FOG_OPACNAME))
		return dlg->fog->opac;
	return NULL;
	}

void FogDADMgr::Drop(ReferenceTarget *dropThis, HWND hwnd, POINT p, SClass_ID type) {
	Texmap *m = (Texmap *)dropThis;
	if (hwnd==GetDlgItem(dlg->hWnd,IDC_FOG_MAPNAME))
		dlg->SetMap(1, (Texmap *)dropThis);
	if (hwnd==GetDlgItem(dlg->hWnd,IDC_FOG_OPACNAME))
		dlg->SetMap(2, (Texmap *)dropThis);
	}

//------------------------------------------------------------------------------

FogDlgProc::FogDlgProc(IParamMap *pmap,FogAtmos *f,IRendParams *i) 
	{
	this->pmap = pmap;
	fog = f;
	ip  = i;
	fog->dlg = this;
	dadMgr.Init(this);
	}

FogDlgProc::~FogDlgProc()
	{
	fog->dlg = NULL;
	}

void FogDlgProc::SetMap(int which, Texmap *m) {
	fog->ReplaceReference(which,m);
	if (m) {
		assert(m->SuperClassID()==TEXMAP_CLASS_ID);
		Texmap *tm = (Texmap*)m;
		tm->RecursInitSlotType(MAPSLOT_ENVIRON);
		fog->pblock->SetValue(which==1?PB_USEMAP:PB_USEOPAC,0,1);
		}
	Init();
	}

void FogDlgProc::AssignMap(int which)
	{
	BOOL newMat, cancel;
	MtlBase *m = ip->DoMaterialBrowseDlg(
		hWnd,BROWSE_MAPSONLY|BROWSE_INCNONE,newMat,cancel);
	if (!cancel) 
		SetMap(which,(Texmap *)m);
	}

void FogDlgProc::Init()
	{
	if (fog->map) {
		mapBut[0]->SetText(fog->map->GetFullName());
	} else {
		mapBut[0]->SetText(GetString(IDS_DS_NONE));
		}
	if (fog->opac) {
		mapBut[1]->SetText(fog->opac->GetFullName());
	} else {
		mapBut[1]->SetText(GetString(IDS_DS_NONE));
		}
	}

void FogDlgProc::SetState()
	{
	int type, hnoise;
	fog->pblock->GetValue(PB_TYPE,0,type,FOREVER);	
	fog->pblock->GetValue(PB_HNOISE,0,hnoise,FOREVER);		

	EnableWindow(GetDlgItem(hWnd,IDC_FOG_REGULARLABEL),!type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_NEARLABEL),!type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_NEAR),!type);		
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_FARLABEL),!type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_FAR),!type);		
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_EXP),!type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_LAYEREDLABEL),type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_TOPLABEL),type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_TOP),type);		
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_BOTTOMLABEL),type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_BOTTOM),type);		
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_DENSITYLABEL),type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_DENISITY),type);		
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_HNOISE),type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_SCALELABEL),type && hnoise);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_SCALE),type && hnoise);		
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_FALLOFFLABEL),type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_TOPFALLOFF),type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_BOTTOMFALLOFF),type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_NOFALLOFF),type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_ANGLELABEL),type && hnoise);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_ANGLE),type && hnoise);		
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_PHASELABEL),type && hnoise);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_PHASE),type && hnoise);		

	ISpinnerControl *iSpin;
	iSpin = GetISpinner(GetDlgItem(hWnd,IDC_FOG_TOPSPIN));
	if (type) iSpin->Enable(); else iSpin->Disable();
	ReleaseISpinner(iSpin);

	iSpin = GetISpinner(GetDlgItem(hWnd,IDC_FOG_BOTTOMSPIN));
	if (type) iSpin->Enable(); else iSpin->Disable();
	ReleaseISpinner(iSpin);

	iSpin = GetISpinner(GetDlgItem(hWnd,IDC_FOG_DENISITYSPIN));
	if (type) iSpin->Enable(); else iSpin->Disable();
	ReleaseISpinner(iSpin);

	iSpin = GetISpinner(GetDlgItem(hWnd,IDC_FOG_SCALESPIN));
	if (type && hnoise) iSpin->Enable(); else iSpin->Disable();
	ReleaseISpinner(iSpin);

	iSpin = GetISpinner(GetDlgItem(hWnd,IDC_FOG_ANGLESPIN));
	if (type && hnoise) iSpin->Enable(); else iSpin->Disable();
	ReleaseISpinner(iSpin);

	iSpin = GetISpinner(GetDlgItem(hWnd,IDC_FOG_PHASESPIN));
	if (type && hnoise) iSpin->Enable(); else iSpin->Disable();
	ReleaseISpinner(iSpin);

	iSpin = GetISpinner(GetDlgItem(hWnd,IDC_FOG_NEARSPIN));
	if (!type) iSpin->Enable(); else iSpin->Disable();
	ReleaseISpinner(iSpin);

	iSpin = GetISpinner(GetDlgItem(hWnd,IDC_FOG_FARSPIN));
	if (!type) iSpin->Enable(); else iSpin->Disable();
	ReleaseISpinner(iSpin);
	/*
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_NEARSPIN),!type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_FARSPIN),!type);		
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_TOPSPIN),type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_BOTTOMSPIN),type);
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_DENISITYSPIN),type);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_SCALESPIN),type && hnoise);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_ANGLESPIN),type && hnoise);	
	EnableWindow(GetDlgItem(hWnd,IDC_FOG_PHASESPIN),type && hnoise);	
	*/
	}

BOOL FogDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,
		UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			this->hWnd = hWnd;
			mapBut[0] = GetICustButton(GetDlgItem(hWnd, IDC_FOG_MAPNAME));		
			mapBut[1] = GetICustButton(GetDlgItem(hWnd, IDC_FOG_OPACNAME));		
			mapBut[0]->SetDADMgr(&dadMgr);
			mapBut[1]->SetDADMgr(&dadMgr);
			Init();
			SetState();
			break;

		case WM_DESTROY:
			ReleaseICustButton(mapBut[0]);
			ReleaseICustButton(mapBut[1]);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_FOG_HNOISE:
				case IDC_FOG_REGULAR:
				case IDC_FOG_LAYERED:
					SetState();
					break;	
				case IDC_FOG_MAPNAME:
					AssignMap(1);
					break;
				case IDC_FOG_OPACNAME:
					AssignMap(2);
					break;
				}
			break;
		}
	
	return FALSE;
	}


//--- FogParamDlg -------------------------------------------------------


FogParamDlg::FogParamDlg(FogAtmos *f,IRendParams *i) 
	{
	fog = f;
	ip  = i;	
	pmap = CreateRParamMap(
		descParam,PARAMDESC_LENGH,
		fog->pblock,
		i,
		hInstance,
		MAKEINTRESOURCE(IDD_FOG_PARAMS),
		GetString(IDS_RB_FOGPARAMS),
		0);
	
	pmap->SetUserDlgProc(new FogDlgProc(pmap,fog,ip));	
	}

void FogParamDlg::SetThing(ReferenceTarget *m)
	{
	assert(m->ClassID()==fog->ClassID());
	fog = (FogAtmos*)m;
	pmap->SetParamBlock(fog->pblock);
	pmap->SetUserDlgProc(new FogDlgProc(pmap,fog,ip));	
	if (fog->dlg) {
		fog->dlg->fog = fog;		
		fog->dlg->Init();
		fog->dlg->SetState();
		}
	}

void FogParamDlg::DeleteThis()
	{
	DestroyRParamMap(pmap);
	delete this;
	}

//--- FogAtmos ----------------------------------------------------------

FogDlgProc *FogAtmos::dlg = NULL;

FogAtmos::FogAtmos()
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer2, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);
	map  = NULL;
	opac = NULL;
	valid.SetEmpty();
	InitializeCriticalSection(&csect);

	pblock->SetValue(PB_COLOR,0,Point3(1,1,1));		
	pblock->SetValue(PB_FAR,0,1.0f);
	pblock->SetValue(PB_TOP,0,100.0f);	
	pblock->SetValue(PB_DENSITY,0,50.0f);	
	pblock->SetValue(PB_FALLOFF,0,FALLOFF_NONE);
	pblock->SetValue(PB_SCALE,0,20.0f);
	pblock->SetValue(PB_ANGLE,0,DegToRad(5.0f));	
	pblock->SetValue(PB_FOGBG,0,TRUE);
	}

IOResult FogAtmos::Load(ILoad *iload)
	{
	Atmospheric::Load(iload);
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}

AtmosParamDlg *FogAtmos::CreateParamDialog(IRendParams *ip)
	{	
	return new FogParamDlg(this,ip);
	}

Animatable* FogAtmos::SubAnim(int i)
	{
	switch (i) {
		case 0: return pblock;
		case 1: return map;
		case 2: return opac;
		default: return NULL;
		}
	}

TSTR FogAtmos::SubAnimName(int i)
	{
	switch (i) {
		case 0: return GetString(IDS_RB_PARAMETERS);
		case 1: return GetString(IDS_RB_FOGTEXMAP);
		case 2: return GetString(IDS_RB_FOGOPACMAP);
		default: return _T("");
		}
	}

RefTargetHandle FogAtmos::GetReference(int i)
	{
	switch (i) {
		case 0: return pblock;
		case 1: return map;
		case 2: return opac;
		default: return NULL;
		}
	}

void FogAtmos::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case 0: pblock = (IParamBlock*)rtarg; break;
		case 1: map = (Texmap*)rtarg; 
			if (dlg) dlg->Init();					
			break;
		case 2: opac = (Texmap*)rtarg; 
			if (dlg) dlg->Init();					
			break;
		}
	}

void FogAtmos::RescaleWorldUnits(float f) {
	if (TestAFlag(A_WORK1))
		return;
	SetAFlag(A_WORK1);
	pblock->RescaleParam(PB_TOP,f);	
	pblock->RescaleParam(PB_BOTTOM,f);	
	//pblock->RescaleParam(PB_SCALE,f);	
	}

RefResult FogAtmos::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
	{
	switch (message) {
		case REFMSG_CHANGE:
			valid.SetEmpty();
			if (dlg) {
				dlg->Invalidate();
				if (hTarget==opac||hTarget==map)
					dlg->Init();
				}
			break;

		case REFMSG_NODE_NAMECHANGE:
			if (dlg&&(hTarget==map||hTarget==opac)) {
				if (map) {
					TSTR name = map->GetFullName();
					dlg->mapBut[0]->SetText(name);
					}
				if (opac) {
					TSTR name = opac->GetFullName();
					dlg->mapBut[1]->SetText(name);
					}
				}
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_COLOR: 	gpd->dim = stdColor255Dim; break;
				case PB_NEAR:
				case PB_FAR:	gpd->dim = stdPercentDim; break;
				case PB_TOP:
				case PB_PHASE:
				case PB_BOTTOM:	gpd->dim = stdWorldDim; break;
				case PB_ANGLE:	gpd->dim = stdAngleDim; break;
				default: 		gpd->dim = defaultDim;
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_COLOR:		gpn->name = GetString(IDS_RB_FOGCOLOR); break;
				case PB_NEAR:		gpn->name = GetString(IDS_RB_NEARPERCENT); break;
				case PB_FAR:		gpn->name = GetString(IDS_RB_FARPERCENT); break;
				case PB_TOP:		gpn->name = GetString(IDS_RB_TOP); break;
				case PB_BOTTOM:		gpn->name = GetString(IDS_RB_BOTTOM); break;
				case PB_DENSITY:	gpn->name = GetString(IDS_RB_DENSITY); break;
				case PB_SCALE:		gpn->name = GetString(IDS_RB_FOGSCALE); break;
				case PB_ANGLE:		gpn->name = GetString(IDS_RB_ANGLE2); break;
				case PB_PHASE:		gpn->name = GetString(IDS_RB_PHASE); break;
				case PB_USEMAP:		gpn->name = GetString(IDS_RB_USECOLORMAP); break;
				case PB_USEOPAC:	gpn->name = GetString(IDS_RB_USEOPACMAP); break;
				case PB_FOGBG:		gpn->name = GetString(IDS_RB_FOGBG); break;
				case PB_TYPE:		gpn->name = GetString(IDS_RB_FOGTYPE); break;
				case PB_FALLOFF:	gpn->name = GetString(IDS_RB_FALLOFF); break;
				case PB_HNOISE:		gpn->name = GetString(IDS_RB_HNOISE); break;				
				case PB_EXP:		gpn->name = GetString(IDS_RB_EXP); break;
				default:			gpn->name = _T(""); break;
				}
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}

void FogAtmos::Update(TimeValue t, Interval& valid)
	{
	if (map) map->Update(t,valid);
	if (opac) opac->Update(t,valid);
	}

int FogAtmos::RenderBegin(TimeValue t, ULONG flags)
	{
	return 0;
	}

int FogAtmos::RenderEnd(TimeValue t)
	{
	return 0;
	}

#define EPSILON	0.001f

void FogAtmos::UpdateCaches(TimeValue t)
	{
	EnterCriticalSection(&csect);
	if (!valid.InInterval(t)) {
		valid = FOREVER;		
		pblock->GetValue(PB_COLOR,t,fogColor,valid);
		pblock->GetValue(PB_USEMAP,t,useMap,valid);
		pblock->GetValue(PB_USEOPAC,t,useOpac,valid);
		pblock->GetValue(PB_NEAR,t,nearF,valid);
		pblock->GetValue(PB_FAR,t,farF,valid);
		pblock->GetValue(PB_TOP,t,top,valid);
		pblock->GetValue(PB_BOTTOM,t,bottom,valid);
		pblock->GetValue(PB_DENSITY,t,density,valid);
		pblock->GetValue(PB_TYPE,t,type,valid);
		pblock->GetValue(PB_FALLOFF,t,falloff,valid);
		pblock->GetValue(PB_HNOISE,t,hnoise,valid);
		pblock->GetValue(PB_SCALE,t,scale,valid);
		pblock->GetValue(PB_ANGLE,t,angle,valid);
		pblock->GetValue(PB_PHASE,t,phase,valid);
		pblock->GetValue(PB_FOGBG,t,fogBG,valid);
		pblock->GetValue(PB_EXP,t,exponential,valid);
		if (exponential) {
			// Take the natural log since we're going to be
			// exponentiating later on.
			farF   = 1.0f-farF;
			nearF  = 1.0f-nearF;
			if (farF  < EPSILON) farF  = EPSILON;
			if (nearF < EPSILON) nearF = EPSILON;
			farF  = -(float)log(farF);
			nearF = -(float)log(nearF);
			}
		far_minus_near = farF - nearF;
		if (top<bottom) {
			float tmp = top;
			top = bottom;
			bottom = tmp;
			}
		fog_range = top-bottom;
		density /= 100.0f;
		if (!map) useMap   = FALSE;
		if (!opac) useOpac = FALSE;
		if (scale != 0.0) scale = 400.0f/scale;
		}
	LeaveCriticalSection(&csect);
	}

inline float CalcPercent(
		float np, float fp, 
		float nF, float fF,
		float nmf,float z)
	{
	float pct;
	if (z<np) pct = nF;
	else
	if (z>fp) pct = fF;
	else
		pct = (z-np)/(fp-np) * nmf + nF;
	return pct;
	}

void FogAtmos::Shade(
		ShadeContext& sc,const Point3& p0,const Point3& p1,
		Color& color, Color& trans, BOOL isBG)
	{	
	float np = sc.CamNearRange(), fp = sc.CamFarRange(), pct; 
	UpdateCaches(sc.CurTime());
	Color opacColor, fogCol=fogColor;	

	if (isBG && !fogBG) return;

	if (useMap && map) {		
		fogCol = map->EvalColor(sc);
		}
	if (useOpac && opac) {		
		opacColor = opac->EvalColor(sc);
		}

	if (type==0) { // Regular		
		if (exponential) {
			Point3 pt0 = sc.PointTo(p0,REF_CAMERA);
			Point3 pt1 = sc.PointTo(p1,REF_CAMERA);
			float z0 = (float)fabs(pt0.z);
			float z1 = (float)fabs(pt1.z);
			float pct0 = CalcPercent(
				np, fp, nearF, farF,
				far_minus_near, z0);
			float pct1 = CalcPercent(
				np, fp, nearF, farF,
				far_minus_near, z1);
			
			if (!useOpac) {
				pct = 1.0f - (float)exp(pct0-pct1);
			} else {
				pct = pct0-pct1;
				}
		
		} else {				
			Point3 p = sc.PointTo(p1,REF_CAMERA);			
			float z = (float)fabs(p.z);
			if (z<np) pct = nearF;
			else
			if (z>fp) pct = farF;
			else
				pct = (z-np)/(fp-np) * far_minus_near + nearF;

			assert(pct<=1.0f);		
			}

		if (useOpac) {
			if (exponential) {
				opacColor.r = 1.0f - (float)exp(opacColor.r*pct);
				opacColor.g = 1.0f - (float)exp(opacColor.g*pct);
				opacColor.b = 1.0f - (float)exp(opacColor.b*pct);

				color += (fogCol-color)*opacColor;
				trans *= Color(1.0f-opacColor.r,1.0f-opacColor.g,1.0f-opacColor.b);
			} else {
				color += (fogCol-color)*opacColor*pct;			
				trans *= Color(1.0f-opacColor.r,1.0f-opacColor.g,1.0f-opacColor.b)
						*(1.0f-pct);
				}
		} else {
			color += (fogCol-color)*pct;
			trans *= 1.0f-pct;
			}
			
	} else { // Layered
		
		// Layered won't work in non-camera views
		if (sc.ProjType()==PROJ_PARALLEL) return;

		Point3 wp0 = sc.PointTo(p0,REF_WORLD);
		Point3 wp1 = sc.PointTo(p1,REF_WORLD);
		if (wp0==wp1) return;
		float dx, dy, dz, za, zb, l, a, b, s, tmp, pct;

		// Compute deltas
		dx = wp1.x-wp0.x;
		dy = wp1.y-wp0.y;
		za = wp0.z;
		zb = wp1.z;
		if (zb<za) {tmp = za; za = zb; zb = tmp;}

		// Are we in the layer
		if (zb<bottom || za>top) return;

		// RB 8/15/97: dz should never be less than 0.
		//if (zb==za) {pct = 1.0f; goto do_lfog;}
		dz = zb-za;
		
		// RB: 9/22/97: It's OK for dz to approach 0. I'm not sure
		// why I had this line in here limiting dz to 1.
		//if (dz<1.0f) dz = 1.0f;
		
		// RB 2/19/99: We can approach 0 but we don't want to divide by 0.
		if (dz<0.0001f) dz = 0.0001f;

		l = (float)sqrt(dx*dx + dy*dy);
		a = (za-bottom)/fog_range;			
		b = (zb-bottom)/fog_range;			
		if (b>1.0f) b = 1.0f;
		if (a<0.0f) a = 0.0f;
		switch (falloff) {
			case FALLOFF_NONE:
				s = (b-a);
				break;
			case FALLOFF_BOTTOM:
				tmp = a; a = 1-b; b = 1-tmp; 
			case FALLOFF_TOP:
				s = b + b*b*(1-b) - a - a*a*(1-a);
				break;
			}		

		if (!useOpac) {
			pct = 1.0f - (float)exp(-s*density*l/dz);
		} else {
			pct = -s*density*l/dz;
			}
	//do_lfog:

		if (hnoise) {			
			Point3 v = Normalize(wp1-wp0);			
			float a2 = (float)asin(v.z);
			if (fabs(a2)<angle) {
				float a1 = (float)atan2(v.y,v.x);
				float n  = noise3(
					Point3(a1*scale,a2*scale-phase,phase))+1.0f;
				if (n>1.0f) n = 1.0f;
				float u = (float)fabs(a2)/angle;
				pct *= u*(1.0f - (n*(1.0f-u)));
				}
			}

		if (useOpac) {
			opacColor.r = 1.0f - (float)exp(opacColor.r*pct);
			opacColor.g = 1.0f - (float)exp(opacColor.g*pct);
			opacColor.b = 1.0f - (float)exp(opacColor.b*pct);

			color += (fogCol-color)*opacColor;
			trans *= Color(1.0f-opacColor.r,1.0f-opacColor.g,1.0f-opacColor.b);

			//color += (fogCol-color)*opacColor*pct;
			//trans *= Color(1.0f-opacColor.r,1.0f-opacColor.g,1.0f-opacColor.b)
			//			*(1.0f-pct);			
		} else {
			color += (fogCol-color)*pct;
			trans *= 1.0f-pct;
			}
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Misc\audio.c ===
/****************************************************************************
 *
 *  AUDIO.C
 *
 *  Simple routines to play audio using an AVIStream to get data.
 *
 *  Uses global variables, so only one instance at a time.
 *  (Usually, there's only one sound card, so this isn't so bad.
 *
 **************************************************************************/

/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992, 1993  Microsoft Corporation.  All Rights Reserved.
 * 
 **************************************************************************/
#include "strbasic.h"

#ifdef WIN95STUFF

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <vfw.h>
#include "audio.h"
#include "muldived.h"

/*--------------------------------------------------------------+
| ****************** AUDIO PLAYING SUPPORT ******************** |
+--------------------------------------------------------------*/

static	HWAVEOUT	shWaveOut = 0;	/* Current MCI device ID */
static	LONG		slBegin;
static	LONG		slWaveBegin;
static	LONG		slCurrent;
static	LONG		slEnd;
static	LONG		slWaveEnd;
static	BOOL		sfLooping;
static	BOOL		sfPlaying = FALSE;

static LONG sTotal;
static LONG sPlayed;

#define MAX_AUDIO_BUFFERS	16
#define MIN_AUDIO_BUFFERS	2
#define AUDIO_BUFFER_SIZE	16384

static	WORD		swBuffers;	    // total # buffers
static	WORD		swBuffersOut;	    // buffers device has
static	WORD		swNextBuffer;	    // next buffer to fill
static	LPWAVEHDR	salpAudioBuf[MAX_AUDIO_BUFFERS];

static	PAVISTREAM	spavi;		    // stream we're playing
static	LONG		slSampleSize;	    // size of an audio sample

static	LONG		sdwBytesPerSec;
static	LONG		sdwSamplesPerSec;

/*---------------------------------------------------------------+
| aviaudioCloseDevice -- close the open audio device, if any.    | 
+---------------------------------------------------------------*/
void NEAR aviaudioCloseDevice(void)
	{
    WORD	w;

    if (shWaveOut) {
		while (swBuffers > 0) {
		    --swBuffers;
		    waveOutUnprepareHeader(shWaveOut, salpAudioBuf[swBuffers],
					sizeof(WAVEHDR));
	    	GlobalFreePtr((LPSTR) salpAudioBuf[swBuffers]);
			}	
	
		w = waveOutClose(shWaveOut);

		shWaveOut = NULL;	
    	}
	}

/*--------------------------------------------------------------+
| aviaudioOpenDevice -- get ready to play waveform data.	|
+--------------------------------------------------------------*/
BOOL FAR aviaudioOpenDevice(HWND hwnd, PAVISTREAM pavi)
	{
    WORD		w;
    LPVOID		lpFormat;
    LONG		cbFormat;
    AVISTREAMINFO	strhdr;

    if (!pavi)		// no wave data to play
		return FALSE;
    
    if (shWaveOut)	// already something playing
		return TRUE;

    spavi = pavi;

    AVIStreamInfo(pavi, &strhdr, sizeof(strhdr));

    slSampleSize = (LONG) strhdr.dwSampleSize;
    if (slSampleSize <= 0 || slSampleSize > AUDIO_BUFFER_SIZE)
		return FALSE;
    
    AVIStreamFormatSize(pavi, 0, &cbFormat);

    lpFormat = GlobalAllocPtr(GHND, cbFormat);
    if (!lpFormat)
		return FALSE;

    AVIStreamReadFormat(pavi, 0, lpFormat, &cbFormat);

    sdwSamplesPerSec = ((LPWAVEFORMAT) lpFormat)->nSamplesPerSec;
    sdwBytesPerSec = ((LPWAVEFORMAT) lpFormat)->nAvgBytesPerSec;
    
    w = waveOutOpen(&shWaveOut, (UINT)WAVE_MAPPER, lpFormat,
			(DWORD) (UINT) hwnd, 0L, CALLBACK_WINDOW);

    //
    // Maybe we failed because someone is playing sound already.
    // Shut any sound off, and try once more before giving up.
    //
    if (w) {
		sndPlaySound(NULL, 0);
		w = waveOutOpen(&shWaveOut, (UINT)WAVE_MAPPER, lpFormat,
			(DWORD) (UINT)hwnd, 0L, CALLBACK_WINDOW);
    	}
		    
    if (w != 0) {
		/* Show error message here? */	
		return FALSE;
    	}
    
    for (swBuffers = 0; swBuffers < MAX_AUDIO_BUFFERS; swBuffers++) {
		if (!(salpAudioBuf[swBuffers] = 
			(LPWAVEHDR)GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, 
				(DWORD)(sizeof(WAVEHDR) + AUDIO_BUFFER_SIZE))))
		    break;
		
		salpAudioBuf[swBuffers]->dwFlags = WHDR_DONE;
		salpAudioBuf[swBuffers]->lpData = (LPSTR) salpAudioBuf[swBuffers] 
							    + sizeof(WAVEHDR);
		salpAudioBuf[swBuffers]->dwBufferLength = AUDIO_BUFFER_SIZE;
		if (!waveOutPrepareHeader(shWaveOut, salpAudioBuf[swBuffers], 
						sizeof(WAVEHDR)))
		    continue;
	
		GlobalFreePtr((LPSTR) salpAudioBuf[swBuffers]);
		break;
    	}
    
    if (swBuffers < MIN_AUDIO_BUFFERS) {
		aviaudioCloseDevice();
		return FALSE;
    	}

    swBuffersOut = 0;
    swNextBuffer = 0;

    sfPlaying = FALSE;
    
    return TRUE;
	}


/*--------------------------------------------------------------+
| aviaudioTime -						|
| Return the time in milliseconds corresponding to the		|
| currently playing audio sample, or -1 if no audio is playing.	|
|								|
| WARNING: Some sound cards are pretty inaccurate!		|
+--------------------------------------------------------------*/
LONG FAR aviaudioTime(void)
	{
    MMTIME	mmtime;
    
    if (!sfPlaying)
	return -1;

    mmtime.wType = TIME_SAMPLES;
    
    waveOutGetPosition(shWaveOut, &mmtime, sizeof(mmtime));

    if (mmtime.wType == TIME_SAMPLES)
		return AVIStreamSampleToTime(spavi, slBegin)
			+ muldiv32(mmtime.u.sample, 1000, sdwSamplesPerSec);
    else if (mmtime.wType == TIME_BYTES)
		return AVIStreamSampleToTime(spavi, slBegin)
			+ muldiv32(mmtime.u.cb, 1000, sdwBytesPerSec);
    else
		return -1;
	}


/*--------------------------------------------------------------+
| aviaudioiFillBuffers -					|
| Fill up any empty audio buffers and ship them out to the	|
| device.							|
+--------------------------------------------------------------*/
BOOL NEAR aviaudioiFillBuffers(void)
	{
    LONG		lRead;
    WORD		w;
    LONG		lSamplesToPlay;
    
    /* We're not playing, so do nothing. */
    if (!sfPlaying)
		return TRUE;
    
    while (swBuffersOut < swBuffers) {		
		if (sPlayed >= sTotal) {
			if (sfLooping) {
				/* Looping, so go to the beginning. */
				slCurrent = slBegin;
				sPlayed   = 0;
			} else {
				break;
				}
			}

		if (slCurrent >= slWaveEnd) {
	    	slCurrent = slWaveBegin;			
			}

		/* Figure out how much data should go in this buffer */
		lSamplesToPlay = slWaveEnd - slCurrent;
		if (lSamplesToPlay + sPlayed > sTotal) {
			lSamplesToPlay = sTotal - sPlayed;
			}

		if (lSamplesToPlay > AUDIO_BUFFER_SIZE / slSampleSize)
	    	lSamplesToPlay = AUDIO_BUFFER_SIZE / slSampleSize;


		AVIStreamRead(spavi, slCurrent, lSamplesToPlay,
			      salpAudioBuf[swNextBuffer]->lpData,
			      AUDIO_BUFFER_SIZE,
			      &salpAudioBuf[swNextBuffer]->dwBufferLength,
			      &lRead);
	
		if (lRead != lSamplesToPlay) {
		    return FALSE;
			}
		slCurrent += lRead;
		sPlayed   += lRead;

		w = waveOutWrite(shWaveOut, salpAudioBuf[swNextBuffer],sizeof(WAVEHDR));
	
		if (w != 0) {
	    	return FALSE;
			}
	
		++swBuffersOut;
		++swNextBuffer;
		if (swNextBuffer >= swBuffers) {
		    swNextBuffer = 0;
			}
   		}

    if (swBuffersOut == 0 && sPlayed >= sTotal)
		aviaudioStop();
    
    /* We've filled all of the buffers we can or want to. */
    return TRUE;
	}

/*--------------------------------------------------------------+
| aviaudioPlay -- Play audio, starting at a given frame		|
|								|
+--------------------------------------------------------------*/
BOOL FAR aviaudioPlay(
	HWND hwnd, PAVISTREAM pavi, 
	LONG lCur, LONG lStart, LONG lEnd, 
	BOOL fWait, BOOL repeat)
	{
    LONG aviStart = AVIStreamStartTime(pavi);
    LONG aviEnd   = AVIStreamEndTime(pavi);
	LONG aviLen   = aviEnd-aviStart;
	
    if (!aviaudioOpenDevice(hwnd,pavi)) return FALSE;    

	if (!sfPlaying) {
		waveOutPause(shWaveOut);
		}
	
	if (lStart < aviStart) {
		LONG d = (aviStart-lStart)/aviLen + 1;
		lStart += d * aviLen;
		lEnd   += d * aviLen;
		lCur   += d * aviLen;
		}
	if (lStart > aviEnd) {
		LONG d = (lStart-aviEnd)/aviLen + 1;
		lStart -= d * aviLen;
		lEnd   -= d * aviLen;
		lCur   -= d * aviLen;
		}
	
	//sTotal  = ((lEnd-lStart)*sdwSamplesPerSec)/1000;
	//sPlayed = ((lCur-lStart)*sdwSamplesPerSec)/1000;
	sTotal  = MulDiv32((lEnd-lStart), sdwSamplesPerSec, 1000);
	sPlayed = MulDiv32((lCur-lStart), sdwSamplesPerSec, 1000);
	
	slBegin     = AVIStreamTimeToSample(pavi,lStart%aviLen);
	slCurrent   = AVIStreamTimeToSample(pavi,lCur%aviLen);
	slEnd       = AVIStreamTimeToSample(pavi,lEnd%aviLen);
	slWaveBegin = AVIStreamStart(pavi);
	slWaveEnd   = AVIStreamEnd(pavi);
	    
    sfLooping = repeat;

	if (!sfPlaying) {
    	sfPlaying = TRUE;
    	aviaudioiFillBuffers();		
		}

    //
    // Now unpause the audio and away it goes!
    //
    waveOutRestart(shWaveOut);
    
    //
    // Caller wants us not to return until play is finished
    //
    if (fWait) {
		while (swBuffersOut > 0) {
		    MSG msg;
			while (PeekMessage(&msg,hwnd,0,0,TRUE)) {
				TranslateMessage(&msg);
				DispatchMessage(&msg);
				}
			}
    	}
    
    return TRUE;
	}

/*--------------------------------------------------------------+
| aviaudioMessage -- handle wave messages received by		|
| window controlling audio playback.  When audio buffers are	|
| done, this routine calls aviaudioiFillBuffers to fill them	|
| up again.							|
+--------------------------------------------------------------*/
void FAR aviaudioMessage(HWND hwnd, unsigned msg, WORD wParam, LONG lParam)
	{
    if (msg == MM_WOM_DONE) {
		--swBuffersOut;
		aviaudioiFillBuffers();
    	}
	}


/*--------------------------------------------------------------+
| aviaudioStop -- stop playing, close the device.		|
+--------------------------------------------------------------*/
void FAR aviaudioStop(void)
	{
    WORD	w;

    if (shWaveOut != 0) {
		w = waveOutReset(shWaveOut);
		sfPlaying = FALSE;	
		aviaudioCloseDevice();
    	}    
	}

#endif // WIN95STUFF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Misc\simpobj.cpp ===
/**********************************************************************
 *<
	FILE: SimpObj.cpp

	DESCRIPTION:  A base class for procedural objects that fit into
	              a standard form.

	CREATED BY: Rolf Berteig

	HISTORY: created 10/10/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "core.h"
#include "control.h"
#include "paramblk.h"
#include "coremain.h"
#include "custcont.h"
#include "triobj.h"
#include "IParamM.h"
#include "mouseman.h"
#include "objmode.h"
#include "SimpObj.h"
#include "simpmod.h"
#include "patchobj.h"

//-- SimpleObject ---------------------------------------------------------

SimpleObject *SimpleObject::editOb = NULL;

SimpleObject::SimpleObject()
	{
	ivalid.SetEmpty();
	mesh.EnableEdgeList(1);
	SetAFlag(A_OBJ_CREATING);
	suspendSnap = FALSE;
	}

SimpleObject::~SimpleObject()
	{
	DeleteAllRefsFromMe();
	}

IParamArray *SimpleObject::GetParamBlock()
	{
	return pblock;
	}

int SimpleObject::GetParamBlockIndex(int id)
	{
	if (pblock && id>=0 && id<pblock->NumParams()) return id;
	else return -1;
	}

void SimpleObject::UpdateMesh(TimeValue t) 
	{
	if (!ivalid.InInterval(t) ) {
		BuildMesh(t);
		}
	}

void SimpleObject::FreeCaches() 
	{
	ivalid.SetEmpty();
	mesh.FreeAll();
	} 

void SimpleObject::GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel )
	{
	UpdateMesh(t);
	box = mesh.getBoundingBox(tm);
	}

void SimpleObject::GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt,  Box3& box ) 
	{
	UpdateMesh(t);
	box = mesh.getBoundingBox();
	}

void SimpleObject::GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box )
	{
	Matrix3 mat = inode->GetObjectTM(t);
	UpdateMesh(t);
	box = mesh.getBoundingBox();
	box = box * mat;
	}

void SimpleObject::BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev)
	{
	editOb = this;
	}

void SimpleObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next)
	{
	editOb = NULL;
	ClearAFlag(A_OBJ_CREATING);
	}

// From BaseObject
int SimpleObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) 
	{
	Point2 pt( (float)p[0].x, (float)p[0].y );
	HitRegion hitRegion;
	GraphicsWindow *gw = vpt->getGW();	
	UpdateMesh(t);
	gw->setTransform(inode->GetObjectTM(t));
	MakeHitRegion(hitRegion, type, crossing, 4, p);
	return mesh.select(gw, inode->Mtls(), &hitRegion, flags & HIT_ABORTONHIT, inode->NumMtls());
	}

void SimpleObject::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) 
	{
	if(suspendSnap)	// No snap to ourself while creating!
		return;

	Matrix3 tm = inode->GetObjectTM(t);
	GraphicsWindow *gw = vpt->getGW();
	UpdateMesh(t);
	gw->setTransform(tm);
	mesh.snap(gw, snap, p, tm);
	}

int SimpleObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) 
	{
	if (!OKtoDisplay(t)) return 0;
	GraphicsWindow *gw = vpt->getGW();
	Matrix3 mat = inode->GetObjectTM(t);	 
	UpdateMesh(t);		
	gw->setTransform(mat);
	mesh.render(gw, inode->Mtls(), 
		(flags&USE_DAMAGE_RECT) ? &vpt->GetDammageRect() : NULL, COMP_ALL, inode->NumMtls());
	return(0);
	}


// From GeomObject
int SimpleObject::IntersectRay(
		TimeValue t, Ray& ray, float& at, Point3& norm)
	{	
	UpdateMesh(t);
	return mesh.IntersectRay(ray,at,norm);	
	}


RefResult SimpleObject::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message ) 
   	{
	switch (message) {
		case REFMSG_CHANGE:
			MeshInvalid();
			if (editOb==this) InvalidateUI();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}

ObjectState SimpleObject::Eval(TimeValue time) 
	{
	return ObjectState(this);
	}

Interval SimpleObject::ObjectValidity(TimeValue time) 
	{
	UpdateMesh(time);	
	return ivalid;	
	}

int SimpleObject::CanConvertToType(Class_ID obtype) 
	{
	if (obtype==defObjectClassID||obtype==mapObjectClassID||obtype==triObjectClassID||obtype==patchObjectClassID) {
		return 1;
		}	
	return Object::CanConvertToType(obtype);
	}

Object* SimpleObject::ConvertToType(TimeValue t, Class_ID obtype) 
	{
	if (obtype==defObjectClassID||obtype==triObjectClassID||obtype==mapObjectClassID) {
		TriObject *triob;
		UpdateMesh(t);
		triob = CreateNewTriObject();
		triob->GetMesh() = mesh;
		triob->SetChannelValidity(TOPO_CHAN_NUM,ObjectValidity(t));
		triob->SetChannelValidity(GEOM_CHAN_NUM,ObjectValidity(t));		
		return triob;
		}
	else
	if (obtype == patchObjectClassID) {
		UpdateMesh(t);
		PatchObject *patchob = new PatchObject();
		patchob->patch = mesh;		// Handy Mesh->PatchMesh conversion
		patchob->SetChannelValidity(TOPO_CHAN_NUM,ObjectValidity(t));
		patchob->SetChannelValidity(GEOM_CHAN_NUM,ObjectValidity(t));		
		return patchob;
		}
	return Object::ConvertToType(t,obtype);
	}

Mesh* SimpleObject::GetRenderMesh(TimeValue t, INode *inode, View &view, BOOL& needDelete) {
	needDelete = FALSE;
	UpdateMesh(t);
	return &mesh;
	}

TSTR SimpleObject::SubAnimName(int i) 
	{ 
	return TSTR(GetResString(IDS_RB_PARAMETERS));
	}


BOOL 
SimpleObject::PolygonCount(TimeValue t, int& numFaces, int& numVerts) 
{
    UpdateMesh(t);
    numFaces = mesh.getNumFaces();
    numVerts = mesh.getNumVerts();
    return TRUE;
}

//-- SimpleWSMObject ---------------------------------------------------------

SimpleWSMObject *SimpleWSMObject::editOb = NULL;

SimpleWSMObject::SimpleWSMObject()
	{
	ivalid.SetEmpty();
	mesh.EnableEdgeList(1);
	SetAFlag(A_OBJ_CREATING);
	}

SimpleWSMObject::~SimpleWSMObject()
	{
	DeleteAllRefsFromMe();
	}

IParamArray *SimpleWSMObject::GetParamBlock()
	{
	return pblock;
	}

int SimpleWSMObject::GetParamBlockIndex(int id)
	{
	if (pblock && id>=0 && id<pblock->NumParams()) return id;
	else return -1;
	}

void SimpleWSMObject::UpdateMesh(TimeValue t) 
	{
	if (!ivalid.InInterval(t) ) {
		BuildMesh(t);
		}
	}

void SimpleWSMObject::FreeCaches() 
	{
	ivalid.SetEmpty();
	mesh.FreeAll();
	} 

void SimpleWSMObject::GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel )
	{
	UpdateMesh(t);
	box = mesh.getBoundingBox(tm);
	}

void SimpleWSMObject::GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt,  Box3& box ) 
	{
	UpdateMesh(t);
	box = mesh.getBoundingBox();
	}

void SimpleWSMObject::GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box )
	{
	Matrix3 mat = inode->GetObjectTM(t);
	UpdateMesh(t);
	box = mesh.getBoundingBox();
	box = box * mat;
	}

void SimpleWSMObject::BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev)
	{
	editOb = this;
	}

void SimpleWSMObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next)
	{
	editOb = NULL;
	ClearAFlag(A_OBJ_CREATING);
	}

// From BaseObject
int SimpleWSMObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) 
	{
	Point2 pt( (float)p[0].x, (float)p[0].y );
	HitRegion hitRegion;
	GraphicsWindow *gw = vpt->getGW();	
	Material *mtl = gw->getMaterial();
		
	UpdateMesh(t);
	gw->setTransform(inode->GetObjectTM(t));
	MakeHitRegion(hitRegion, type, crossing, 4, p);
	DWORD rlim  = gw->getRndLimits();	
	int res;

	gw->setRndLimits((rlim|GW_PICK|GW_WIREFRAME) 
		& ~(GW_ILLUM|GW_BACKCULL|GW_FLAT|GW_SPECULAR));

	res = mesh.select(gw, mtl, &hitRegion, flags & HIT_ABORTONHIT);
	
	gw->setRndLimits(rlim);
	return res;
	}

void SimpleWSMObject::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) 
	{
	if(TestAFlag(A_OBJ_CREATING))	// No snap to ourself while creating!
		return;

	Matrix3 tm = inode->GetObjectTM(t);
	GraphicsWindow *gw = vpt->getGW();
	UpdateMesh(t);
	gw->setTransform(tm);
	mesh.snap(gw, snap, p, tm);
	}


class WSMMtl: public Material {
	public:
	WSMMtl();
	};
static WSMMtl wsmMtl;

#define WSM_R	float(1.0)
#define WSM_G	float(1.0)
#define WSM_B	float(0.0)

WSMMtl::WSMMtl():Material() {
	Kd[0] = WSM_R;
	Kd[1] = WSM_G;
	Kd[2] = WSM_B;
	Ks[0] = WSM_R;
	Ks[1] = WSM_G;
	Ks[2] = WSM_B;
	shininess = (float)0.0;
	shadeLimit = GW_WIREFRAME;
	selfIllum = (float)1.0;
	}

int SimpleWSMObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) 
	{
	if (!OKtoDisplay(t)) return 0;
	GraphicsWindow *gw = vpt->getGW();	
	Matrix3 mat = inode->GetObjectTM(t);	 
	UpdateMesh(t);		
	gw->setTransform(mat);

	//mesh.render(gw, inode->Mtls(), 
	DWORD rlim  = gw->getRndLimits();
	
	gw->setRndLimits(GW_WIREFRAME|/*GW_BACKCULL|*/(rlim&GW_Z_BUFFER?GW_Z_BUFFER:0));
	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())
		//gw->setColor( LINE_COLOR, wsmMtl.Kd[0], wsmMtl.Kd[1], wsmMtl.Kd[2]);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SPACE_WARPS));

	mesh.render(gw, &wsmMtl, 
		(flags&USE_DAMAGE_RECT) ? &vpt->GetDammageRect() : NULL, COMP_ALL);
	
	gw->setRndLimits(rlim);
	return(0);
	}


RefResult SimpleWSMObject::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message ) 
   	{
	switch (message) {
		case REFMSG_CHANGE:
			MeshInvalid();
			if (editOb==this) InvalidateUI();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}

ObjectState SimpleWSMObject::Eval(TimeValue time) 
	{
	return ObjectState(this);
	}

Interval SimpleWSMObject::ObjectValidity(TimeValue time) 
	{
	UpdateMesh(time);	
	return ivalid;	
	}

TSTR SimpleWSMObject::SubAnimName(int i) 
	{ 
	return TSTR(GetResString(IDS_RB_PARAMETERS));
	}


//-- SimpleParticle ---------------------------------------------------------

SimpleParticle *SimpleParticle::editOb = NULL;
IObjParam *SimpleParticle::ip          = NULL;

SimpleParticle::SimpleParticle()
	{	
	pblock = NULL;
	valid  = FALSE;
	mvalid.SetEmpty();
	tvalid=mvalid.Start();
	}

SimpleParticle::~SimpleParticle()
	{
	DeleteAllRefsFromMe();
	}

IParamArray *SimpleParticle::GetParamBlock()
	{
	return pblock;
	}

int SimpleParticle::GetParamBlockIndex(int id)
	{
	if (pblock && id>=0 && id<pblock->NumParams()) return id;
	else return -1;
	}

TimeValue SimpleParticle::ParticleAge(TimeValue t, int i)
	{
	if (i<parts.ages.Count()) return parts.ages[i];
	else return -1;
	}

void SimpleParticle::SetParticlePosition(TimeValue t, int i, Point3 pos)
	{
	if (i<parts.points.Count()) parts.points[i]=pos;
	}

void SimpleParticle::SetParticleVelocity(TimeValue t, int i, Point3 vel)
	{
	if (i<parts.vels.Count()) parts.vels[i]=vel;
	}

void SimpleParticle::SetParticleAge(TimeValue t, int i, TimeValue age)
	{
	if (i<parts.ages.Count()) parts.ages[i]=age;
	}

void SimpleParticle::Update(TimeValue t,INode *node)
	{
	if (node) {
		if (tvalid!=t || !valid) UpdateParticles(t,node);
		}
	UpdateMesh(t);
	}

void SimpleParticle::UpdateMesh(TimeValue t) 
	{
	if (!mvalid.InInterval(t) ) {
		BuildEmitter(t,mesh);
		}
	}
	
void SimpleParticle::GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel)
	{
	Update(t);
	box = mesh.getBoundingBox(tm);
	}

void SimpleParticle::GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt,  Box3& box ) 
	{
	Matrix3 mat = inode->GetObjTMBeforeWSM(t);
	Box3 pbox;
	Update(t,inode);
	box  = mesh.getBoundingBox();
	pbox = parts.BoundBox();
	if (!pbox.IsEmpty()) box += pbox * Inverse(mat);
	}

void SimpleParticle::GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box )
	{
	Box3 pbox;
	Matrix3 mat = inode->GetObjTMBeforeWSM(t);	
	UpdateMesh(t);
	box  = mesh.getBoundingBox();
	box  = box * mat;
	pbox = parts.BoundBox();	
	if (!pbox.IsEmpty()) box += pbox;	
	}

void SimpleParticle::BeginEditParams(
		IObjParam  *ip, ULONG flags,Animatable *prev)
	{
	this->ip = ip;
	editOb   = this;
	}

void SimpleParticle::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{
	this->ip = NULL;
	editOb   = NULL;	
	}


static Matrix3 ident(1);

class ParticleMtl: public Material {
	public:
	ParticleMtl();
	};
static ParticleMtl particleMtl;

#define PARTICLE_R	float(1.0)
#define PARTICLE_G	float(1.0)
#define PARTICLE_B	float(0.0)

ParticleMtl::ParticleMtl():Material() {
	Kd[0] = PARTICLE_R;
	Kd[1] = PARTICLE_G;
	Kd[2] = PARTICLE_B;
	Ks[0] = PARTICLE_R;
	Ks[1] = PARTICLE_G;
	Ks[2] = PARTICLE_B;
	shininess = (float)0.0;
	shadeLimit = GW_WIREFRAME;
	selfIllum = (float)1.0;
	}


int SimpleParticle::HitTest(
		TimeValue t, INode *inode, int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt) 
	{	
	Update(t,inode);
	Point2 pt( (float)p[0].x, (float)p[0].y );
	HitRegion hitRegion;
	GraphicsWindow *gw = vpt->getGW();	
	MakeHitRegion(hitRegion, type, crossing, 4, p);
	DWORD rlim  = gw->getRndLimits();
	int res;

	gw->setTransform(ident);
	if (parts.HitTest(gw,&hitRegion,flags&HIT_ABORTONHIT,GetMarkerType())) {
		return TRUE;
		}
	
	if (EmitterVisible()) {
		gw->setRndLimits((rlim|GW_PICK|GW_WIREFRAME) 
			& ~(GW_ILLUM|GW_BACKCULL|GW_FLAT|GW_SPECULAR));
		gw->setTransform(inode->GetObjTMBeforeWSM(t));
		res = mesh.select(gw, &particleMtl, &hitRegion, flags & HIT_ABORTONHIT);

		gw->setRndLimits(rlim);
	} else {
		res = 0;
		}
	return res;
	}


int SimpleParticle::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) 
	{
	if (!OKtoDisplay(t)) return 0;
	Update(t,inode);
	GraphicsWindow *gw = vpt->getGW();
	DWORD rlim  = gw->getRndLimits();	
	
	// Draw emitter
	gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL| (rlim&GW_Z_BUFFER) );
	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())
		//gw->setColor( LINE_COLOR, particleMtl.Kd[0], particleMtl.Kd[1], particleMtl.Kd[2]);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_PARTICLE_EM));

	if (EmitterVisible()) {
		gw->setTransform(inode->GetObjTMBeforeWSM(t));	
		mesh.render(gw, &particleMtl, 
			(flags&USE_DAMAGE_RECT) ? &vpt->GetDammageRect() : NULL, COMP_ALL);
		}
			
	// Draw particles
	gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL| (rlim&(GW_Z_BUFFER|GW_BOX_MODE)) );
	Material *mtl = gw->getMaterial();	
	if (!inode->Selected() && !inode->IsFrozen())
		gw->setColor( LINE_COLOR, mtl->Kd[0], mtl->Kd[1], mtl->Kd[2]);

	gw->setTransform(ident);
	parts.Render(gw,GetMarkerType());

	gw->setRndLimits(rlim);
	return(0);
	}


RefResult SimpleParticle::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message ) 
   	{
	switch (message) {
		case REFMSG_CHANGE:
			MeshInvalid();
			ParticleInvalid();
			if (editOb==this) InvalidateUI();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}

void* SimpleParticle::GetInterface(ULONG id)
	{
	if (id==I_PARTICLEOBJ) {
		return this;
	} else {
		return ParticleObject::GetInterface(id);
		}
	}

ObjectState SimpleParticle::Eval(TimeValue time) 
	{
	// Clear the force fields
	fields.Resize(0);
	cobjs.Resize(0);
	return ObjectState(this);
	}

Object *SimpleParticle::MakeShallowCopy(ChannelMask channels)
	{	
	return this;
	}

void SimpleParticle::ApplyForceField(ForceField *ff)
	{
	fields.Append(1,&ff);
	}

BOOL SimpleParticle::ApplyCollisionObject(CollisionObject *co)
	{
	cobjs.Append(1,&co);
	return TRUE;
	}

Interval SimpleParticle::ObjectValidity(TimeValue time) 
	{
	Interval valid = GetValidity(time);
	UpdateMesh(time);
	return mvalid & valid;
	}

int SimpleParticle::CanConvertToType(Class_ID obtype) 
	{
	if (obtype==defObjectClassID) {
		return 1;
		}
	return Object::CanConvertToType(obtype);
	}

Object* SimpleParticle::ConvertToType(TimeValue t, Class_ID obtype) 
	{
	if (obtype==defObjectClassID) {
		return this;
	} else {
		return Object::ConvertToType(t,obtype);
		}
	}

TSTR SimpleParticle::SubAnimName(int i) 
	{ 
	return TSTR(GetResString(IDS_RB_PARAMETERS));
	}

//---SimpleOSMToWSMObject---------------------------------------------

IParamMap *SimpleOSMToWSMObject::pmapParam = NULL;

ParamBlockDescID descObjVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 }};

ParamBlockDescID descObjVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 }};

#define PBLOCK_LENGTH 4

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descObjVer0,3,0)
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descObjVer1,PBLOCK_LENGTH,CURRENT_VERSION);


static ParamUIDesc descParam[] = {
	// Length
	ParamUIDesc(
		PB_OSMTOWSM_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_OSMTOWSM_LENGTH,IDC_OSMTOWSM_LENGTHSPIN,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),

	// Width
	ParamUIDesc(
		PB_OSMTOWSM_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_OSMTOWSM_WIDTH,IDC_OSMTOWSM_WIDTHSPIN,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),

	// Height
	ParamUIDesc(
		PB_OSMTOWSM_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_OSMTOWSM_HEIGHT,IDC_OSMTOWSM_HEIGHTSPIN,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),

	// Decay
	ParamUIDesc(
		PB_OSMTOWSM_DECAY,
		EDITTYPE_FLOAT,
		IDC_OSMTOWSM_DECAY,IDC_OSMTOWSM_DECAYSPIN,
		0.0f,float(1.0E30),
		0.0001f),
	};
#define PARAMDESC_LENGH 4


SimpleOSMToWSMObject::SimpleOSMToWSMObject()
	{
	mod    = NULL;
	pblock = NULL;
	ivalid.SetEmpty();	
	}

SimpleOSMToWSMObject::SimpleOSMToWSMObject(SimpleMod *m)
	{
	mod    = NULL;
	pblock = NULL;
	ivalid.SetEmpty();
	MakeRefByID(FOREVER,0,m);
	MakeRefByID(FOREVER, 1, 
		CreateParameterBlock(descObjVer1, PBLOCK_LENGTH, 1));
	}

SimpleOSMToWSMObject* SimpleOSMToWSMObject::SimpleOSMToWSMClone(
		SimpleOSMToWSMObject *from,RemapDir& remap)
	{
	ReplaceReference(1,(ReferenceTarget*)remap.CloneRef(from->pblock));
	return this;
	}

IOResult SimpleOSMToWSMObject::Load(ILoad *iload)
	{	
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,1));
	return IO_OK;
	}

#define MESH_SEGMENTS	10

static void MakeLine(Face *f, int a,  int b)
	{
	f->setVerts(a,b,0);
	f->setSmGroup(0);
	f->setEdgeVisFlags(1,0,0);
	}

void SimpleOSMToWSMObject::BuildMesh(TimeValue t)
	{
	float l, w, h;
	ivalid = FOREVER;
	pblock->GetValue(PB_OSMTOWSM_LENGTH,t,l,ivalid);
	pblock->GetValue(PB_OSMTOWSM_WIDTH,t,w,ivalid);
	pblock->GetValue(PB_OSMTOWSM_HEIGHT,t,h,ivalid);	
	w = w/2.0f;
	l = l/2.0f;

	float zmin, zmax;
	int axis;
	BOOL limit = mod->GetModLimits(t,zmin,zmax,axis);
	if (limit) {
		mesh.setNumVerts(20*(MESH_SEGMENTS+1)+1);
		mesh.setNumFaces(20*MESH_SEGMENTS);
	} else {
		mesh.setNumVerts(12*(MESH_SEGMENTS+1)+1);
		mesh.setNumFaces(12*MESH_SEGMENTS);
		}
	
	int vi=0, fi=0;
	mesh.setVert(vi++, Point3(0.0f,0.0f,h/2.0f));

	Point3 data1[] = {
		Point3(-w, -l, 0.0f),
		Point3( w, -l, 0.0f),
		Point3( w,  l, 0.0f),
		Point3(-w,  l, 0.0f),
		Point3(-w, -l,    h),
		Point3( w, -l,    h),
		Point3( w,  l,    h),
		Point3(-w,  l,    h)};
	
	for (int j=0; j<4; j++) {		
		for (int i=0; i<=MESH_SEGMENTS; i++) {
			float u = float(i)/float(MESH_SEGMENTS);
			mesh.setVert(vi++, (1.0f-u)*data1[j] + u*data1[j+4]);
			if (i) MakeLine(&mesh.faces[fi++], vi-2, vi-1);
			}		
		}

	Point3 data2[] = {
		Point3(-w, -l, 0.0f),			
		Point3(-w,  l, 0.0f),
		Point3(-w,  l,    h),
		Point3(-w, -l,    h),
		Point3( w, -l, 0.0f),			
		Point3( w,  l, 0.0f),
		Point3( w,  l,    h),
		Point3( w, -l,    h)};

	for (j=0; j<4; j++) {		
		for (int i=0; i<=MESH_SEGMENTS; i++) {
			float u = float(i)/float(MESH_SEGMENTS);
			mesh.setVert(vi++, (1.0f-u)*data2[j] + u*data2[j+4]);
			if (i) MakeLine(&mesh.faces[fi++], vi-2, vi-1);
			}		
		}

	Point3 data3[] = {
		Point3(-w, -l, 0.0f),			
		Point3( w, -l, 0.0f),
		Point3( w, -l,    h),
		Point3(-w, -l,    h),
		Point3(-w,  l, 0.0f),			
		Point3( w,  l, 0.0f),
		Point3( w,  l,    h),
		Point3(-w,  l,    h)};

	for (j=0; j<4; j++) {		
		for (int i=0; i<=MESH_SEGMENTS; i++) {
			float u = float(i)/float(MESH_SEGMENTS);
			mesh.setVert(vi++, (1.0f-u)*data3[j] + u*data3[j+4]);
			if (i) MakeLine(&mesh.faces[fi++], vi-2, vi-1);
			}		
		}	

	if (limit) {
		Point3 data3[] = {
			Point3(-w, -l, 0.0f),
			Point3( w, -l, 0.0f),
			Point3( w,  l, 0.0f),
			Point3(-w,  l, 0.0f)};
		Point3 data1[] = {
			Point3(-l, 0.0f, 0.0f),
			Point3( l, 0.0f, 0.0f),
			Point3( l,    h, 0.0f),
			Point3(-l,    h, 0.0f)};
		Point3 data2[] = {
			Point3(0.0f ,-w, 0.0f),
			Point3(0.0f,  w, 0.0f),
			Point3(   h,  w, 0.0f),
			Point3(   h, -w, 0.0f)};
		Point3 *data[] = {data1,data2,data3};

		// Min limit
		for (j=0; j<4; j++) {
			for (int i=0; i<=MESH_SEGMENTS; i++) {
				float u = float(i)/float(MESH_SEGMENTS);
				Point3 p1, p2;
				p1[(axis+1)%3] = data[axis][j].x;
				p1[(axis+2)%3] = data[axis][j].y;
				p1[axis]       = zmin;
				p2[(axis+1)%3] = data[axis][(j+1)%4].x;
				p2[(axis+2)%3] = data[axis][(j+1)%4].y;
				p2[axis]       = zmin;				

				mesh.setVert(vi++, (1.0f-u)*p1 + u*p2);
				if (i) MakeLine(&mesh.faces[fi++], vi-2, vi-1);
				}		
			}
		// Max limit
		for (j=0; j<4; j++) {
			for (int i=0; i<=MESH_SEGMENTS; i++) {
				float u = float(i)/float(MESH_SEGMENTS);
				Point3 p1, p2;
				p1[(axis+1)%3] = data[axis][j].x;
				p1[(axis+2)%3] = data[axis][j].y;
				p1[axis]       = zmax;
				p2[(axis+1)%3] = data[axis][(j+1)%4].x;
				p2[(axis+2)%3] = data[axis][(j+1)%4].y;
				p2[axis]       = zmax;				

				mesh.setVert(vi++, (1.0f-u)*p1 + u*p2);
				if (i) MakeLine(&mesh.faces[fi++], vi-2, vi-1);
				}		
			}	
		}

	Matrix3 tm(1);
	ModContext mc;
	mc.tm = NULL;
	mc.box = new Box3;
	mc.box->pmin = Point3(-w,-l,0.0f);
	mc.box->pmax = Point3( w, l,h);
	Deformer &def = GetDecayDeformer(t,mod->GetDeformer(t,mc,tm,tm),Point3(0,0,0),ivalid);
	for (int i=0; i<mesh.getNumVerts(); i++) {
		mesh.verts[i] = def.Map(i, mesh.verts[i]);
		}
	ivalid &= mod->GetValidity(t);
	mesh.InvalidateGeomCache();
	}

	class DecayDeformer : public Deformer {
	public:
		Deformer *mdef;
		Point3 origin;
		float decay;
		DecayDeformer() {mdef=NULL;}
		DecayDeformer(Deformer *md,Point3 o,float d) {origin=o;mdef=md;decay=d;}
		Point3 Map(int i, Point3 p) {
			if (decay>0.0f) {
				float dist = Length(p-origin);
				Point3 pd = mdef->Map(i,p);
				float u = (float)exp(-dist*decay);
				return pd*u + p*(1.0f-u);
			} else {
				return mdef->Map(i,p);
				}
			}
	};
static DecayDeformer theDecayDef;

Deformer &SimpleOSMToWSMObject::GetDecayDeformer(
		TimeValue t,Deformer &mdef,Point3 origin,Interval &iv)
	{
	float d;
	pblock->GetValue(PB_OSMTOWSM_DECAY,t,d,iv);
	theDecayDef = DecayDeformer(&mdef,origin,d);
	return theDecayDef;
	}

Modifier *SimpleOSMToWSMObject::CreateWSMMod(INode *node)
	{
	return new SimpleOSMToWSMMod(node);
	}

RefTargetHandle SimpleOSMToWSMObject::GetReference(int i) 
	{
	switch (i) {
		case 0: return mod;
		case 1: return pblock;
		}
	return NULL;
	}

void SimpleOSMToWSMObject::SetReference(int i, RefTargetHandle rtarg) 
	{
	switch (i) {
		case 0: mod = (SimpleMod*)rtarg; break;
		case 1: pblock = (IParamBlock*)rtarg; break;
		}
	}

Animatable* SimpleOSMToWSMObject::SubAnim(int i)
	{
	switch (i) {
		case 0: return pblock;
		case 1: return mod->pblock;
		default: return NULL;
		}
	}

TSTR SimpleOSMToWSMObject::SubAnimName(int i)
	{
	return GetResString(IDS_RB_PARAMETERS);
	}

TSTR SimpleOSMToWSMObject::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {	
		case PB_OSMTOWSM_LENGTH: return GetResString(IDS_RB_LENGTH);
		case PB_OSMTOWSM_WIDTH:  return GetResString(IDS_RB_WIDTH);
		case PB_OSMTOWSM_HEIGHT: return GetResString(IDS_RB_HEIGHT);
		case PB_OSMTOWSM_DECAY:  return GetResString(IDS_RB_DECAY);
		default: return GetResString(IDS_RB_PARAMETERS);
		}
	}

class SimpleOSMToWSMObjectCreateCallBack: public CreateMouseCallBack {
	SimpleOSMToWSMObject *ob;
	Point3 p0,p1;
	IPoint2 sp0, sp1;	
	public:
		int proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		void SetObj(SimpleOSMToWSMObject *obj) {ob = obj;}
	};

#define BOTTOMPIV

int SimpleOSMToWSMObjectCreateCallBack::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat) 
	{
	Point3 d;
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				ob->pblock->SetValue(PB_OSMTOWSM_WIDTH,0,0.0f);
				ob->pblock->SetValue(PB_OSMTOWSM_LENGTH,0,0.0f);
				ob->pblock->SetValue(PB_OSMTOWSM_HEIGHT,0,0.0f);
				p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				p1 = p0 + Point3(.01,.01,.01);
				mat.SetTrans(float(.5)*(p0+p1));				
#ifdef BOTTOMPIV
				{
				Point3 xyz = mat.GetTrans();
				xyz.z = p0.z;
				mat.SetTrans(xyz);
				}
#endif
				break;
			case 1:
				sp1 = m;
				p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				p1.z = p0.z +(float).01; 
				
				mat.SetTrans(float(.5)*(p0+p1));
#ifdef BOTTOMPIV
				{
				Point3 xyz = mat.GetTrans();
				xyz.z = p0.z;
				mat.SetTrans(xyz);					
				}
#endif
				d = p1-p0;
								
				ob->pblock->SetValue(PB_OSMTOWSM_WIDTH,0,float(fabs(d.x)));
				ob->pblock->SetValue(PB_OSMTOWSM_LENGTH,0,float(fabs(d.y)));
				ob->pblock->SetValue(PB_OSMTOWSM_HEIGHT,0,float(fabs(d.z)));
				ob->pmapParam->Invalidate();										

				if (msg==MOUSE_POINT && 
						(Length(sp1-sp0)<3 || Length(d)<0.1f)) {
					return CREATE_ABORT;
					}
				break;
			case 2:
				p1.z = p0.z + vpt->SnapLength(vpt->GetCPDisp(p1,Point3(0,0,1),sp1,m));
				
				mat.SetTrans(float(.5)*(p0+p1));
#ifdef BOTTOMPIV
				mat.SetTrans(2,p0.z); // set the Z component of translation
#endif					
				d = p1-p0;
				
				ob->pblock->SetValue(PB_OSMTOWSM_WIDTH,0,float(fabs(d.x)));
				ob->pblock->SetValue(PB_OSMTOWSM_LENGTH,0,float(fabs(d.y)));
				ob->pblock->SetValue(PB_OSMTOWSM_HEIGHT,0,float(d.z));
				ob->pmapParam->Invalidate();				
					
				if (msg==MOUSE_POINT) {
					return CREATE_STOP;
					}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {		
		return CREATE_ABORT;
		}
	else
	if (msg == MOUSE_FREEMOVE) {
		vpt->SnapPreview(m,m);
		}

	return TRUE;
	}

static SimpleOSMToWSMObjectCreateCallBack createCB;


CreateMouseCallBack* SimpleOSMToWSMObject::GetCreateMouseCallBack()
	{
	createCB.SetObj(this);
	return &createCB;
	}

void SimpleOSMToWSMObject::BeginEditParams(
		IObjParam  *ip, ULONG flags,Animatable *prev)
	{
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	if (pmapParam) {
		pmapParam->SetParamBlock(pblock);
	} else {
		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGH,
			pblock,
			ip,
			getResMgr().getHInst(RES_ID_RB),
			MAKEINTRESOURCE(IDD_OSMTOWSMPARAMS),
			GetResString(IDS_RB_GIZMOPARAMS),
			0);
		}
	mod->BeginEditParams(ip,flags,prev);
	ip->RegisterSubObjectTypes(NULL,0);
	}

void SimpleOSMToWSMObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{
	SimpleWSMObject::EndEditParams(ip,flags,next);
	mod->EndEditParams(ip,flags,next);
	if (flags&END_EDIT_REMOVEUI) {
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		}
	}

void SimpleOSMToWSMObject::InvalidateUI()
	{
	if (pmapParam) pmapParam->Invalidate();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Misc\simpmod.cpp ===
/**********************************************************************
 *<
	FILE: simpmod.cpp

	DESCRIPTION:  Simple modifier base class

	CREATED BY: Dan Silva & Rolf Berteig

	HISTORY: created 30 Jauary, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "core.h"
#include "control.h"
#include "mouseman.h"
#include "paramblk.h"
#include "coremain.h"
#include "custcont.h"
#include "triobj.h"
#include "IParamM.h"
#include "objmode.h"
#include "simpmod.h"
#include "simpobj.h"
#include "buildver.h"
#include "resource.h"
#include "iparamb2.h"
#include "macrorec.h"

//--- SimpleMod -----------------------------------------------------------

TCHAR *GetString(int id);

IObjParam*          SimpleMod::ip          = NULL;
MoveModBoxCMode*    SimpleMod::moveMode    = NULL;
RotateModBoxCMode*  SimpleMod::rotMode 	   = NULL;
UScaleModBoxCMode*  SimpleMod::uscaleMode  = NULL;
NUScaleModBoxCMode* SimpleMod::nuscaleMode = NULL;
SquashModBoxCMode*  SimpleMod::squashMode  = NULL;
SimpleMod*          SimpleMod::editMod     = NULL;

SimpleMod::SimpleMod()
	{
	tmControl  = NULL; 
	posControl = NULL;	
	pblock     = NULL;
	MakeRefByID(FOREVER,0,NewDefaultMatrix3Controller()); 
	MakeRefByID(FOREVER,1,NewDefaultPositionController()); 
	}

SimpleMod::~SimpleMod()
	{	
	}

IParamArray *SimpleMod::GetParamBlock()
	{
	return pblock;
	}

int SimpleMod::GetParamBlockIndex(int id)
	{
	if (pblock && id>=0 && id<pblock->NumParams()) return id;
	else return -1;
	}

RefTargetHandle SimpleMod::GetReference(int i) 
	{ 
	switch (i) {
		case 0: return tmControl;
		case 1: return posControl;
		case 2: return pblock;
		default: return NULL;
		}
	}

void SimpleMod::SetReference(int i, RefTargetHandle rtarg) 
	{ 
	switch (i) {
		case 0: tmControl = (Control*)rtarg; break;
		case 1: posControl = (Control*)rtarg; break;
		case 2: pblock = (IParamBlock*)rtarg; break;
		}
	}

Animatable* SimpleMod::SubAnim(int i) 
	{ 
	switch (i) {
		case 0: return posControl;
		case 1: return tmControl;
		case 2: return pblock;		
		default: return NULL;
		}
	}

TSTR SimpleMod::SubAnimName(int i) 
	{ 
	switch (i) {
		case 0: return TSTR(GetResString(IDS_RB_CENTER));
		case 1: return TSTR(GetResString(IDS_RB_APPARATUS));
		case 2: return TSTR(GetResString(IDS_RB_PARAMETERS));
		default: return TSTR(_T(""));
		}	
	}

int SimpleMod::SubNumToRefNum(int subNum)
	{
	switch (subNum) {
		case 0: return 1;
		case 1: return 0;
		default: return -1;
		}
	}

BOOL SimpleMod::AssignController(Animatable *control,int subAnim)
	{
	ReplaceReference(SubNumToRefNum(subAnim),(ReferenceTarget*)control);
	NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
	return TRUE;
	}

Interval SimpleMod::LocalValidity(TimeValue t)
	{
	// if being edited, return NEVER forces a cache to be built 
	// after previous modifier.
	if (TestAFlag(A_MOD_BEING_EDITED))
		return NEVER;  
	Interval valid = GetValidity(t);	
	if ( tmControl ) {
		Matrix3 mat;	
		mat.IdentityMatrix();		
		tmControl->GetValue(t,&mat,valid,CTRL_RELATIVE);
		}
	if ( posControl ) {
		Matrix3 mat;	
		mat.IdentityMatrix();
		posControl->GetValue(t,&mat,valid,CTRL_RELATIVE);
		}
	return valid;
	}


void SimpleMod::SimpleModClone( SimpleMod *smodSource )
	{
	if ( smodSource->tmControl ) {		
		MakeRefByID(FOREVER,0,smodSource->tmControl->Clone()); 
		}
	if ( smodSource->posControl ) {		
		MakeRefByID(FOREVER,1,smodSource->posControl->Clone()); 
		}
	}


//  Move, Rotate, and Scale

void SimpleMod::Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin ) {
#ifdef DESIGN_VER
	t=0;
#endif
	if ( ip && ip->GetSubObjectLevel()==1 ) {
		if (tmControl==NULL) {
			MakeRefByID(FOREVER,0,NewDefaultMatrix3Controller()); 
			NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
			}		
		SetXFormPacket pckt(val,partm,tmAxis);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
		macroRecorder->OpAssign(_T("+="), mr_prop, _T("gizmo.pos"), mr_reftarg, this, mr_point3, &val);
	} else {		
		if (posControl==NULL) {
			MakeRefByID(FOREVER,1,NewDefaultPositionController()); 
			NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
			}
		Matrix3 ptm = partm;
		Interval valid;
		if ( tmControl )
			tmControl->GetValue(t,&ptm,valid,CTRL_RELATIVE);
		posControl->SetValue(t,VectorTransform(tmAxis*Inverse(ptm),val),TRUE,CTRL_RELATIVE);
		macroRecorder->OpAssign(_T("+="), mr_prop, _T("center.pos"), mr_reftarg, this, mr_point3, &val);
		}
	}


void SimpleMod::Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin ) {
#ifdef DESIGN_VER
	t=0;
#endif
	if (tmControl==NULL) {
		MakeRefByID(FOREVER,0,NewDefaultMatrix3Controller()); 
		NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
		}	
	SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
	tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	macroRecorder->OpAssign(_T("+="), mr_prop, _T("gizmo.rotation"), mr_reftarg, this, mr_quat, &val);
	}

void SimpleMod::Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin ) {
#ifdef DESIGN_VER
	t=0;
#endif
	if (tmControl==NULL) {
		MakeRefByID(FOREVER,0,NewDefaultMatrix3Controller()); 
		NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
		}		
	SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
	tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	macroRecorder->OpAssign(_T("*="), mr_prop, _T("gizmo.scale"), mr_reftarg, this, mr_point3, &val);
	}



Matrix3 SimpleMod::CompMatrix(TimeValue t, ModContext& mc, Matrix3& ntm, 
		Interval& valid, BOOL needOffset) {
	Matrix3 tm;
	
	if (mc.tm) {
		tm = *mc.tm;		
		}
	else 
		tm.IdentityMatrix();	
	if (tmControl) { 
		Matrix3 mat;
		mat.IdentityMatrix();
		tmControl->GetValue(t,&mat,valid,CTRL_RELATIVE);
		tm = tm*Inverse(mat);		
		}
	if (posControl && needOffset) {
		Matrix3 mat;
		mat.IdentityMatrix();		
		posControl->GetValue(t,&mat,valid,CTRL_RELATIVE);
		tm = tm*Inverse(mat);		
		}
	
	return Inverse(tm)*ntm;	
	}

void SimpleMod::CompOffset( TimeValue t, Matrix3& offset, Matrix3& invoffset)
	{	
	Interval valid;
	offset.IdentityMatrix();
	invoffset.IdentityMatrix();
	if ( posControl ) {				
		posControl->GetValue(t,&offset,valid,CTRL_RELATIVE);
		invoffset = Inverse(offset);
		}
	}

void SimpleMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState * os, INode *node) 
	{	
	Interval valid = GetValidity(t);
	Matrix3 modmat,minv;
	
	// These are inverted becuase that's what is usually needed for displaying/hit testing
	minv   = CompMatrix(t,mc,idTM,valid,TRUE);
	modmat = Inverse(minv);
	
	os->obj->Deform(&GetDeformer(t,mc,modmat, minv), TRUE /*TestAFlag(A_MOD_USE_SEL)*/);   //DS
	os->obj->UpdateValidity(GEOM_CHAN_NUM,valid);	
	}


int SimpleMod::HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc) {
	Interval valid;
	int savedLimits;	
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);
	Matrix3 modmat, ntm = inode->GetObjTMBeforeWSM(t);
	float zmin, zmax;
	int axis;

	if (mc->box->IsEmpty()) return 0;

	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->clearHitCode();
	
	if (ip && ip->GetSubObjectLevel() == 1) {
		Matrix3 off, invoff;
		modmat = CompMatrix(t,*mc,ntm,valid,FALSE);
		CompOffset(t,off,invoff);
		gw->setTransform(modmat);		
		if (mc->box->pmin==mc->box->pmax) {
			gw->marker(&mc->box->pmin,ASTERISK_MRKR);
		} else {
			DoModifiedBox(
				*mc->box,GetDeformer(t,*mc,invoff,off),
				DrawLineProc(gw));
			}
		}

	if (ip && ip->GetSubObjectLevel() == 1 ||
	          ip->GetSubObjectLevel() == 2 ) {
		modmat = CompMatrix(t,*mc,ntm,valid,TRUE);
		gw->setTransform(modmat);
		DrawCenterMark(DrawLineProc(gw),*mc->box);
		if (GetModLimits(t,zmin,zmax,axis)) {
			Matrix3 id(1);
			DoModifiedLimit(*mc->box,zmin,axis,GetDeformer(t,*mc,id,id),DrawLineProc(gw));
			DoModifiedLimit(*mc->box,zmax,axis,GetDeformer(t,*mc,id,id),DrawLineProc(gw));
			}
		}

	gw->setRndLimits(savedLimits);	
	if (gw->checkHitCode()) {
		vpt->LogHit(inode, mc, gw->getHitDistance(), 0, NULL); 
		return 1;
		}
	return 0;
	}

int SimpleMod::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext *mc) {
	Interval valid;
	GraphicsWindow *gw = vpt->getGW();
#ifdef DESIGN_VER
	TimeValue rt = GetCOREInterface()->GetTime();
	Matrix3 modmat, ntm = inode->GetObjTMBeforeWSM(rt), off, invoff;
#else
	Matrix3 modmat, ntm = inode->GetObjTMBeforeWSM(t), off, invoff;
#endif
	float zmin, zmax;
	int axis;

	if (mc->box->IsEmpty()) return 0;

	modmat = CompMatrix(t,*mc,ntm,valid,FALSE);
	CompOffset(t,off,invoff);
	gw->setTransform(modmat);
	if ( ip && ip->GetSubObjectLevel() == 1 ) {		
		//gw->setColor( LINE_COLOR, (float)1.0, (float)1.0, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));
	} else {
		//gw->setColor( LINE_COLOR, (float).85, (float).5, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
		}	
	if (mc->box->pmin==mc->box->pmax) {
		gw->marker(&mc->box->pmin,ASTERISK_MRKR);
	} else {
		DoModifiedBox(
			*mc->box,GetDeformer(t,*mc,invoff,off),
			DrawLineProc(gw));
		}
	
	modmat = CompMatrix(t,*mc,ntm,valid,TRUE);
	gw->setTransform(modmat);
	if ( ip && (ip->GetSubObjectLevel() == 1 ||
	            ip->GetSubObjectLevel() == 2) ) {		
		gw->setColor( LINE_COLOR, (float)1.0, (float)1.0, (float)0.0);
	} else {
		gw->setColor( LINE_COLOR, (float).85, (float).5, (float)0.0);
		}	
	DrawCenterMark(DrawLineProc(gw),*mc->box);	
	if (GetModLimits(t,zmin,zmax,axis)) {
		Matrix3 id(1);
		DoModifiedLimit(*mc->box,zmin,axis,GetDeformer(t,*mc,id,id),DrawLineProc(gw));
		DoModifiedLimit(*mc->box,zmax,axis,GetDeformer(t,*mc,id,id),DrawLineProc(gw));
		}

	return 0;	
	}

void SimpleMod::GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc) {
	Interval valid;
	GraphicsWindow *gw = vpt->getGW();
#ifdef DESIGN_VER
	// Needed for damage rectangle calcs
		TimeValue rt = GetCOREInterface()->GetTime();
		Matrix3 modmat, ntm = inode->GetObjTMBeforeWSM(rt), off, invoff;
#else
	Matrix3 modmat, ntm = inode->GetObjTMBeforeWSM(t), off, invoff;
#endif
	float zmin, zmax;
	int axis;

	if (mc->box->IsEmpty()) return;

	modmat = CompMatrix(t,*mc,ntm,valid,FALSE);
	CompOffset(t,off,invoff);	
	BoxLineProc bp1(&modmat);	
	DoModifiedBox(*mc->box, GetDeformer(t,*mc,invoff,off), bp1);
	box = bp1.Box();

	modmat = CompMatrix(t,*mc,ntm,valid,TRUE);	
	BoxLineProc bp2(&modmat);		
	DrawCenterMark(bp2,*mc->box);
	if (GetModLimits(t,zmin,zmax,axis)) {
		Matrix3 id(1);
		DoModifiedLimit(*mc->box,zmin,axis,GetDeformer(t,*mc,id,id),bp2);
		DoModifiedLimit(*mc->box,zmax,axis,GetDeformer(t,*mc,id,id),bp2);
		}
	box += bp2.Box();
	}

void SimpleMod::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Interval valid;
	Matrix3 modmat, tm, ntm = node->GetObjTMBeforeWSM(t,&valid), off, invoff;

	if (cb->Type()==SO_CENTER_PIVOT) {
		tm = CompMatrix(t,*mc,ntm,valid,TRUE);
		cb->Center(tm.GetTrans(),0);
	} else {
		modmat = CompMatrix(t,*mc,ntm,valid,FALSE);
		CompOffset(t,off,invoff);
		BoxLineProc bp1(&modmat);	
		DoModifiedBox(*mc->box, GetDeformer(t,*mc,invoff,off), bp1);
		cb->Center(bp1.Box().Center(),0);
		}
	}

void SimpleMod::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Interval valid;
	Matrix3 ntm = node->GetObjTMBeforeWSM(t,&valid);
	Matrix3 tm = CompMatrix(t,*mc,ntm,valid,TRUE);
	cb->TM(tm,0);
	}


void SimpleMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	this->ip = ip;
	editMod  = this;

	// Add our sub object type
	TSTR type1( GetResString(IDS_RB_APPARATUS) );	
	TSTR type2( GetResString(IDS_RB_CENTER) );	
	const TCHAR *ptype[] = { type1, type2 };
	ip->RegisterSubObjectTypes( ptype, 2 );

	// Create sub object editing modes.
	moveMode    = new MoveModBoxCMode(this,ip);
	rotMode     = new RotateModBoxCMode(this,ip);
	uscaleMode  = new UScaleModBoxCMode(this,ip);
	nuscaleMode = new NUScaleModBoxCMode(this,ip);
	squashMode  = new SquashModBoxCMode(this,ip);	
	
	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);
	}

void SimpleMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next)
	{
	this->ip = NULL;
	editMod  = NULL;

	TimeValue t = ip->GetTime();

	// NOTE: This flag must be cleared before sending the REFMSG_END_EDIT
	ClearAFlag(A_MOD_BEING_EDITED);

	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);

	ip->DeleteMode(moveMode);
	ip->DeleteMode(rotMode);
	ip->DeleteMode(uscaleMode);
	ip->DeleteMode(nuscaleMode);
	ip->DeleteMode(squashMode);	
	if ( moveMode ) delete moveMode;
	moveMode = NULL;
	if ( rotMode ) delete rotMode;
	rotMode = NULL;
	if ( uscaleMode ) delete uscaleMode;
	uscaleMode = NULL;
	if ( nuscaleMode ) delete nuscaleMode;
	nuscaleMode = NULL;
	if ( squashMode ) delete squashMode;
	squashMode = NULL;
	}

void SimpleMod::ActivateSubobjSel(int level, XFormModes& modes )
	{	
	switch ( level ) {
		case 1: // Modifier box
			modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,NULL);
			break;
		case 2: // Modifier Center
			modes = XFormModes(moveMode,NULL,NULL,NULL,NULL,NULL);
			break;
		}
	NotifyDependents(FOREVER,PART_DISPLAY,REFMSG_CHANGE);
	}

RefResult SimpleMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message ) 
   	{
	switch (message) {
		case REFMSG_CHANGE:
			if (editMod==this) InvalidateUI();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}


//--- SimpleMod2 -----------------------------------------------------------
// JBW 2/9/99

RefTargetHandle SimpleMod2::GetReference(int i) 
	{ 
	switch (i) {
		case 0: return tmControl;
		case 1: return posControl;
		case 2: return pblock2;
		default: return NULL;
		}
	}

void SimpleMod2::SetReference(int i, RefTargetHandle rtarg) 
	{ 
	switch (i) {
		case 0: tmControl = (Control*)rtarg; break;
		case 1: posControl = (Control*)rtarg; break;
		case 2: pblock2 = (IParamBlock2*)rtarg; break;
		}
	}

Animatable* SimpleMod2::SubAnim(int i) 
	{ 
	switch (i) {
		case 0: return posControl;
		case 1: return tmControl;
		case 2: return pblock2;		
		default: return NULL;
		}
	}

//--- SimpleWSMMod -----------------------------------------------------------


IObjParam*    SimpleWSMMod::ip			= NULL;
SimpleWSMMod* SimpleWSMMod::editMod	= NULL;


SimpleWSMMod::SimpleWSMMod()
	{	
	obRef   = NULL;
	nodeRef = NULL;
	pblock  = NULL;
	}

SimpleWSMMod::~SimpleWSMMod()
	{	
	}

IParamArray *SimpleWSMMod::GetParamBlock()
	{
	return pblock;
	}

int SimpleWSMMod::GetParamBlockIndex(int id)
	{
	if (pblock && id>=0 && id<pblock->NumParams()) return id;
	else return -1;
	}

RefTargetHandle SimpleWSMMod::GetReference(int i) 
	{ 
	switch (i) {		
		case SIMPWSMMOD_OBREF: 		return obRef;
		case SIMPWSMMOD_NODEREF:	return nodeRef;
		case SIMPWSMMOD_PBLOCKREF: 	return pblock;
		default: return NULL;
		}
	}

void SimpleWSMMod::SetReference(int i, RefTargetHandle rtarg) 
	{ 
	switch (i) {
		case SIMPWSMMOD_OBREF:		obRef   = (WSMObject*)rtarg; break;
		case SIMPWSMMOD_NODEREF:	nodeRef = (INode*)rtarg; break;
		case SIMPWSMMOD_PBLOCKREF: 	pblock  = (IParamBlock*)rtarg; break;
		}
	}

Animatable* SimpleWSMMod::SubAnim(int i) 
	{ 
	switch (i) {
		case 0: return pblock;		
		default: return NULL;
		}
	}

TSTR SimpleWSMMod::SubAnimName(int i) 
	{ 
	switch (i) {
		case 0: return TSTR(GetResString(IDS_RB_PARAMETERS));
		default: return TSTR(_T(""));
		}	
	}

Interval SimpleWSMMod::LocalValidity(TimeValue t)
	{
	// if being edited, return NEVER forces a cache to be built 
	// after previous modifier.
	if (TestAFlag(A_MOD_BEING_EDITED))
		return NEVER;  
	return GetValidity(t);	
	}

CoreExport WSMObject *SimpleWSMMod::GetWSMObject(TimeValue t)
	{
	if (nodeRef) {
		ObjectState os = nodeRef->EvalWorldState(t);
		//assert(os.obj && os.obj->SuperClassID()==WSM_OBJECT_CLASS_ID);
		if (os.obj && os.obj->SuperClassID()==WSM_OBJECT_CLASS_ID)
			 return (WSMObject*)os.obj;
		else return NULL;
	} else {
		return NULL;
		}
	}

void SimpleWSMMod::SimpleWSMModClone(SimpleWSMMod *smodSource)
	{	
	if (smodSource->pblock) ReplaceReference(SIMPWSMMOD_PBLOCKREF,smodSource->pblock->Clone());
	ReplaceReference(SIMPWSMMOD_OBREF,smodSource->obRef);
	ReplaceReference(SIMPWSMMOD_NODEREF,smodSource->nodeRef);
	}


void SimpleWSMMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState * os, INode *node) 
	{	
	Interval valid = GetValidity(t);
	Matrix3 modmat(1);
	Matrix3 minv(1);
	
	os->obj->Deform(&GetDeformer(t,mc,modmat, minv), TRUE);
	os->obj->UpdateValidity(GEOM_CHAN_NUM,valid);	
	}




void SimpleWSMMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	this->ip = ip;	
	editMod  = this;

#if 0
	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);
#endif
	}

void SimpleWSMMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next)
	{
	this->ip = NULL;
	editMod  = NULL;

#if 0	
	TimeValue t = ip->GetTime();

	// NOTE: This flag must be cleared before sending the REFMSG_END_EDIT
	ClearAFlag(A_MOD_BEING_EDITED);

	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);	
#endif
	}


RefResult SimpleWSMMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message ) 
   	{
	switch (message) {
		case REFMSG_CHANGE:
			if (editMod==this) InvalidateUI();
			break;

		case REFMSG_TARGET_DELETED:
			// THis means the WSM node is being deleted. As a result,
			// we must delete ourselves. 
			DeleteMe();  // also deletes all refs and 
						 // sends REFMSG_TARGET_DELETED to all Dependents
			return REF_STOP;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}

SvGraphNodeReference SimpleWSMMod::SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags)
	{
	SvGraphNodeReference nodeRef;
	SvGraphNodeReference childNodeRef;

//	gom->PushLevel(this);

	nodeRef = gom->AddAnimatable(this, owner, id, flags);
	if (nodeRef.stat == SVT_PROCEED)
		{
		if (GetReference(SIMPWSMMOD_NODEREF))
			{
			gom->PushLevel(GetReference(SIMPWSMMOD_NODEREF));
			childNodeRef = gom->AddAnimatable(GetReference(SIMPWSMMOD_NODEREF), this, SIMPWSMMOD_NODEREF, flags);
			if (childNodeRef.stat != SVT_DO_NOT_PROCEED)
				gom->AddReference(nodeRef.gNode, childNodeRef.gNode, REFTYPE_SUBANIM);
			gom->PopLevel();
			}
		if (GetReference(SIMPWSMMOD_PBLOCKREF))
			{
			childNodeRef = GetReference(SIMPWSMMOD_PBLOCKREF)->SvTraverseAnimGraph(gom, this, SIMPWSMMOD_PBLOCKREF, flags);
			if (childNodeRef.stat != SVT_DO_NOT_PROCEED)
				gom->AddReference(nodeRef.gNode, childNodeRef.gNode, REFTYPE_SUBANIM);
			}
		}

//	gom->PopLevel();

	return nodeRef;
	}

//---SimpleOSMToWSMMod--------------------------------------------------

SimpleOSMToWSMMod::SimpleOSMToWSMMod()
	{
	obRef   = NULL;
	nodeRef = NULL;
	pblock  = NULL;
	}

SimpleOSMToWSMMod::SimpleOSMToWSMMod(INode *node)
	{
	obRef   = NULL;
	nodeRef = NULL;
	pblock  = NULL;
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);
	}

RefTargetHandle SimpleOSMToWSMMod::Clone(RemapDir& remap)
	{
	SimpleOSMToWSMMod *mod = new SimpleOSMToWSMMod(nodeRef);
	mod->SimpleWSMModClone(this);
	return mod;
	}

TCHAR *SimpleOSMToWSMMod::GetObjectName()
	{
	SimpleOSMToWSMObject *obj = (SimpleOSMToWSMObject*)GetWSMObject(0);
	static TSTR name;	
	name = TSTR(obj->mod->GetObjectName()) + TSTR(GetString(IDS_RB_BBINDING));
	return name;
	}

Deformer& SimpleOSMToWSMMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	SimpleOSMToWSMObject *obj = (SimpleOSMToWSMObject*)GetWSMObject(t);
	if (!mc.box) mc.box = new Box3;
	float l, w, h;
	Interval ivalid = FOREVER;
	obj->pblock->GetValue(PB_OSMTOWSM_LENGTH,t,l,ivalid);
	obj->pblock->GetValue(PB_OSMTOWSM_WIDTH,t,w,ivalid);
	obj->pblock->GetValue(PB_OSMTOWSM_HEIGHT,t,h,ivalid);
	w = w/2.0f; l = l/2.0f;
	mc.box->pmin = Point3(-w,-l,0.0f);
	mc.box->pmax = Point3( w, l,h);
	//invmat = nodeRef->GetObjTMBeforeWSM(t,&ivalid);
	invmat = nodeRef->GetObjTMAfterWSM(t,&ivalid);
	mat = Inverse(invmat);
	return obj->GetDecayDeformer(t,obj->mod->GetDeformer(t,mc,mat,invmat),invmat.GetTrans(),FOREVER);
	}

Interval SimpleOSMToWSMMod::GetValidity(TimeValue t)
	{
	Interval iv = FOREVER;
	SimpleOSMToWSMObject *obj = (SimpleOSMToWSMObject*)GetWSMObject(t);
	iv &= obj->mod->GetValidity(t);
	float l, w, h, d;	
	obj->pblock->GetValue(PB_OSMTOWSM_LENGTH,t,l,iv);
	obj->pblock->GetValue(PB_OSMTOWSM_WIDTH,t,w,iv);
	obj->pblock->GetValue(PB_OSMTOWSM_HEIGHT,t,h,iv);
	obj->pblock->GetValue(PB_OSMTOWSM_DECAY,t,d,iv);
	//nodeRef->GetObjTMBeforeWSM(t,&iv);
	nodeRef->GetObjTMAfterWSM(t,&iv);
	return iv;
	}

class SimpleOSMToWSMModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) {return new SimpleOSMToWSMMod;}
	const TCHAR *	ClassName() {return _T("SimpleOSMToWSMMod");}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID;}
	Class_ID		ClassID() {return SIMPLEOSMTOWSM_CLASSID;}
	const TCHAR* 	Category() {return _T("");}
	};

static SimpleOSMToWSMModClassDesc osmTowsmDesc;
ClassDesc* GetSimpleOSMToWSMModDesc() {return &osmTowsmDesc;}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Misc\sound.cpp ===
/**********************************************************************
 *<
	FILE:  sound.cpp

	DESCRIPTION:  Some sound related functions

	CREATED BY:  Rolf Berteig -- based on examples fro VFW SDK

	HISTORY: created 2 July 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "core.h"

#ifdef WIN95STUFF

#include <mmsystem.h>
#include <vfw.h>
#include "audio.h"
#include "muldived.h"
#include "sound.h"

#define GlobalSizePtr(lp)   GlobalSize(GlobalPtrHandle(lp))
typedef BYTE  *HPBYTE;
typedef SHORT  *HPINT;

static char fileName[256] = {'\0'};


FilteredWave::FilteredWave(PAVISTREAM pavi,int resolution)
	{
	PCMWAVEFORMAT wf;
	LPVOID lpAudio=NULL;
	LONG l, lBytes;	
	DWORD *ptr, sum[2], pos, v;

	LONG s   = AVIStreamStartTime(pavi);
	LONG e   = AVIStreamEndTime(pavi);
	LONG len = e-s;

	LONG sstart = AVIStreamTimeToSample(pavi,s);
	LONG send   = AVIStreamTimeToSample(pavi,e);
	LONG slen   = send-sstart;

	HPBYTE bptr;
	HPINT iptr;
	int in, b, av[2];
	int j,k;
	DWORD i;

	sat    = NULL;
	satLen = 0;
	start  = (s*TIME_TICKSPERSEC)/1000;
	end    = (e*TIME_TICKSPERSEC)/1000;

	l = sizeof(wf);
    AVIStreamReadFormat(pavi,0,&wf,&l);
    if (!l)	{
        return;
		}
	if (wf.wf.wFormatTag != WAVE_FORMAT_PCM) {
		return;
		}

	lBytes = slen * wf.wf.nChannels * wf.wBitsPerSample/8;    
	lpAudio = GlobalAllocPtr(GHND,lBytes);    
    if (!lpAudio) {
    	return;
		}

    AVIStreamRead(pavi,sstart,slen,lpAudio,lBytes,NULL,&l);
    if (l != slen) {
        GlobalFreePtr(lpAudio);
        return;
		}
    
	satLen = (len*resolution)/(1000);
	numSum = slen/satLen;
	satLen = slen/numSum;

	sat = new DWORD[satLen * wf.wf.nChannels];
	if (!sat) {
		GlobalFreePtr(lpAudio);
		return;
		}
	channels = wf.wf.nChannels;
	ptr = sat;	
	pos = 0;
	
	//
	// First find the average value
	//
	av[0] = av[1] = 0;
	iptr = (HPINT)lpAudio;
	bptr = (HPBYTE)lpAudio;	

	for (i=0; i<(DWORD)slen; i++) {		
		if (wf.wBitsPerSample==8) {
			for (j=0;j<channels;j++) {
				av[j] += *bptr++ - 0x80;
				}	
		} else {
			for (j=0;j<channels;j++) {
				av[j] += *iptr++;				
				}
			}			
		}
	for (j=0;j<channels;j++) {
		av[j] /= slen;
		}
	
	// 
	// Now build the SAT moving the average to 0.
	//
	sum[0] = sum[1] = 0;
	iptr = (HPINT)lpAudio;
	bptr = (HPBYTE)lpAudio;		

	for (i=0; i<satLen; i++) {
		for (k=0; k<numSum; k++,pos++) {
			if (wf.wBitsPerSample==8) {
				for (j=0;j<channels;j++) {
					b = *bptr++  - av[j];
					if (b > 0x80) {
						v = (b - 0x80) * 256;						
					} else {
						v = (0x80 - b) * 256;						
						}					
					sum[j] += v;
					}	
			} else {
				for (j=0;j<channels;j++) {
					in = *iptr++ - av[j];
					if (in<0) in = -in;					
					sum[j] += in;					
					}
				}			
			}

		for (j=0;j<channels;j++) {
			*ptr++ = sum[j];
			}
		}
	
	// Find the max
	max[0] = max[1] = 0;
	for (i=1; i<satLen; i++) {
		for (j=0;j<channels;j++) {
			v = (sat[i*channels+j]-sat[(i-1)*channels+j])/numSum;
			if (v>max[j]) max[j] = v;
			}
		}

	GlobalFreePtr(lpAudio);	
	}

FilteredWave::~FilteredWave()
	{
	if (sat) delete sat;
	sat = NULL;
	}

DWORD FilteredWave::Sample(TimeValue t0,TimeValue t1,int channel)
	{
	if (!sat || channel>=channels) return 0;
	int s,e,den;

	if (end<=start) return 0;
	if (t1-t0 > end-start) {
		t0 = start;
		t1 = end;
		}
	if (t0<start) {
		int d = (end-start) * ((start-t0)/(end-start) + 1);
		t0 += d;
		t1 += d; 
		}
	t0 = t0 % (end-start);
	t1 = t1 % (end-start);
	if (t1<t0) t1 = end-1;

	//s = ((t0-start) * satLen)/(end-start);
	//e = ((t1-start) * satLen)/(end-start);
	s = MulDiv32((t0-start), satLen, (end-start));
	e = MulDiv32((t1-start), satLen, (end-start));

	if (s==e) {
		if (e) s = e-1;
		else e = s+1;
		if (s<0 || e>=(int)satLen) return 0;
		}
	assert(s>=0);
	assert(e<(int)satLen);

	den = numSum * (e-s);
	if (!den) return 0;
	else return (sat[e*channels+channel]-sat[s*channels+channel])/den;
	}


BOOL GetSoundFileName(HWND hWnd,TSTR &name,TSTR &dir)
	{
	OPENFILENAME ofn;	
	char filter[256];

	AVIBuildFilter(filter,sizeof(filter),FALSE);

	ofn.lStructSize       = sizeof(OPENFILENAME);
	ofn.hwndOwner         = hWnd;
	ofn.hInstance         = NULL;	
	ofn.lpstrTitle        = GetResString(IDS_RB_OPENSOUND);
	ofn.lpstrFilter       = filter;
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter    = 0;
	ofn.nFilterIndex      = 0;
	ofn.lpstrFile         = fileName;
	ofn.nMaxFile          = sizeof(fileName);
	ofn.lpstrFileTitle    = NULL;
	ofn.nMaxFileTitle     = 0;
	ofn.lpstrInitialDir   = dir;
	ofn.Flags             = OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY;
	ofn.nFileOffset       = 0;
	ofn.nFileExtension    = 0;
	ofn.lpstrDefExt       = NULL;
	ofn.lCustData         = 0;
	ofn.lpfnHook          = NULL;
	ofn.lpTemplateName    = NULL;

	if (GetOpenFileNamePreview(&ofn)) {
		name = fileName;
		SplitFilename(name,&dir,NULL,NULL);
		return TRUE;
	} else {
		return FALSE;
		}
	}

PAVISTREAM GetAudioStream(TSTR name,TCHAR *dir)
	{
	HRESULT		hr;
	PAVIFILE	pfile;
	PAVISTREAM	pstream = NULL;
	BOOL res = TRUE;

	// RB 5/10/99: Reworked this a bit. Added the current scene dir as a possible search location.
	// Also now using SplitPathFile() instead of doing it by hand.

 	hr = AVIFileOpen(&pfile,name,OF_READ,NULL);
	if (hr) {
		TSTR fileName, tryName;
		SplitPathFile(name, NULL, &fileName);

		// Try the given directory (which is the sound dir)
		tryName = TSTR(dir) + TSTR(_T("\\")) + fileName;
		hr = AVIFileOpen(&pfile,tryName,OF_READ,NULL);
		
		if (hr) {
			// Try the scene directory
			TSTR sceneName = GetCOREInterface()->GetCurFilePath();
			TSTR scenePath;
			SplitPathFile(sceneName, &scenePath, NULL);
			tryName = scenePath + TSTR(_T("\\")) + fileName;
			hr = AVIFileOpen(&pfile,tryName,OF_READ,NULL);
			}

#if 0
		// Try the file in the given directory
		int i = name.Length()-1;
		while (i>0) {
			if (name[i]=='\\' ||
				name[i]==':' ||
				name[i]=='/') {
				i++;
				break;
				}	
			i--;
			}
		if (name.Length()-i>0) {
			TSTR newname = TSTR(dir) + TSTR(_T("\\")) + name.Substr(i,name.Length()-i);
			hr = AVIFileOpen(&pfile,newname,OF_READ,NULL);
			}
#endif
		}
	if (hr) return NULL;

	AVIFileGetStream(pfile,&pstream,streamtypeAUDIO,0);
	AVIFileRelease(pfile);

	if (!pstream) return NULL;

	// Verify it's PCM
	PCMWAVEFORMAT wf;
	LONG l = sizeof(wf);
    AVIStreamReadFormat(pstream,0,&wf,&l);
    if (!l)	{
        AVIStreamRelease(pstream);
		return NULL;
		}
	if (wf.wf.wFormatTag != WAVE_FORMAT_PCM) {
		AVIStreamRelease(pstream);
		return NULL;
		}

	return pstream;
	}

BOOL OpenSoundFile(HWND hWnd,PAVISTREAM *pavi)
	{
	OPENFILENAME ofn;
	char filter[256];

	AVIBuildFilter(filter,sizeof(filter),FALSE);

	ofn.lStructSize       = sizeof(OPENFILENAME);
	ofn.hwndOwner         = hWnd;
	ofn.hInstance         = NULL;	
	ofn.lpstrTitle        = GetResString(IDS_RB_OPENSOUND);
	ofn.lpstrFilter       = filter;
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter    = 0;
	ofn.nFilterIndex      = 0;
	ofn.lpstrFile         = fileName;
	ofn.nMaxFile          = sizeof(fileName);
	ofn.lpstrFileTitle    = NULL;
	ofn.nMaxFileTitle     = 0;
	ofn.lpstrInitialDir   = NULL;
	ofn.Flags             = OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY;
	ofn.nFileOffset       = 0;
	ofn.nFileExtension    = 0;
	ofn.lpstrDefExt       = NULL;
	ofn.lCustData         = 0;
	ofn.lpfnHook          = NULL;
	ofn.lpTemplateName    = NULL;

	if (GetOpenFileNamePreview(&ofn)) {
		HRESULT		hr;
    	PAVIFILE	pfile;
		PAVISTREAM	pstream;
		BOOL res = TRUE;

   	 	hr = AVIFileOpen(&pfile,fileName,OF_READ,NULL);
    	if (hr) return FALSE;

		if (AVIFileGetStream(
				pfile,&pstream,streamtypeAUDIO,0) != AVIERR_OK) {			
			res = FALSE;
			goto done;
			}
		
		*pavi = pstream;

	done:
		AVIFileRelease(pfile);
		return res;
	} else {
		return FALSE;
		}
	}
	    



/////////////////////////////////////////////////////////////////////
// Micorsoft's stuff....
//
//

/*----------------------------------------------------------------------------*\
|    PaintAudio()								|
|    Draw some samples of audio inside the given rectangle			|
\*----------------------------------------------------------------------------*/

void PaintAudio(
		HDC hdc, PRECT prc, PAVISTREAM pavi, LONG lStart, LONG lLen)
	{
    LPVOID lpAudio=NULL;
    PCMWAVEFORMAT wf;
    int i;
    int x,y;
    int w,h;
    BYTE b;
    HBRUSH hbr;
    RECT rc = *prc;
    LONG    lBytes;
    LONG    l, lLenOrig = lLen;
    LONG    lWaveBeginTime = AVIStreamStartTime(pavi);
    LONG    lWaveEndTime   = AVIStreamEndTime(pavi);

    //
    // We can't draw before the beginning of the stream - adjust
    //
    if (lStart < lWaveBeginTime) {
		lLen -= lWaveBeginTime - lStart;
		lStart = lWaveBeginTime;
		// right justify the legal samples in the rectangle - don't stretch
		rc.left = rc.right - (int)muldiv32(rc.right - rc.left, lLen, lLenOrig);
	    }

    //
    // We can't draw past the end of the stream
    //
    if (lStart + lLen > lWaveEndTime) {
		lLenOrig = lLen;
		lLen = max(0, lWaveEndTime - lStart);	// maybe nothing to draw!
		// left justify the legal samples in the rectangle - don't stretch
		rc.right = rc.left + (int)muldiv32(rc.right - rc.left, lLen, lLenOrig);
	    }

    // Now start working with samples, not time
    l = lStart;
    lStart = AVIStreamTimeToSample(pavi, lStart);
    lLen   = AVIStreamTimeToSample(pavi, l + lLen) - lStart;

    //
    // Get the format of the wave data
    //
    l = sizeof(wf);
    AVIStreamReadFormat(pavi, lStart, &wf, &l);
    if (!l)
        return;

    w = rc.right - rc.left;
    h = rc.bottom - rc.top;

    //
    // We were starting before the beginning or continuing past the end.
    // We're not painting in the whole original rect --- use a dark background
    //
    if (rc.left > prc->left) {
        SelectObject(hdc, GetStockObject(DKGRAY_BRUSH));
		PatBlt(hdc, prc->left, rc.top, rc.left - prc->left,
						rc.bottom - rc.top, PATCOPY);
    	}
    if (rc.right < prc->right) {
        SelectObject(hdc, GetStockObject(DKGRAY_BRUSH));
		PatBlt(hdc, rc.right, rc.top, prc->right - rc.right,
						rc.bottom - rc.top, PATCOPY);
    	}

#define BACKBRUSH  (GetSysColor(COLOR_BTNFACE))		// background
#define MONOBRUSH  (GetSysColor(COLOR_BTNSHADOW))	// for mono audio
#define LEFTBRUSH  (RGB(0,0,255))			// left channel
#define RIGHTBRUSH (RGB(0,255,0))			// right channel
#define HPOSBRUSH  (RGB(255,0,0))			// current position
    
    //
    // Paint the background
    //
    hbr = (HBRUSH)SelectObject(hdc, CreateSolidBrush(BACKBRUSH));
    PatBlt(hdc, rc.left, rc.top, w, h, PATCOPY);
    DeleteObject(SelectObject(hdc, hbr));

    //
    // !!! we can only paint PCM data right now.  Sorry!
    //
    if (wf.wf.wFormatTag != WAVE_FORMAT_PCM)
        return;

    //
    // How many bytes are we painting? Alloc some space for them
    //
    lBytes = lLen * wf.wf.nChannels * wf.wBitsPerSample / 8;
    if (!lpAudio)
        lpAudio = GlobalAllocPtr (GHND, lBytes);
    else if ((LONG)GlobalSizePtr(lpAudio) < lBytes)
        lpAudio = GlobalReAllocPtr(lpAudio, lBytes, GMEM_MOVEABLE);
    if (!lpAudio)
        return;

    //
    // Read in the wave data
    //
    AVIStreamRead(pavi, lStart, lLen, lpAudio, lBytes, NULL, &l);
    if (l != lLen)
        return;
    
#define MulDiv(a,b,c) (UINT)((DWORD)(UINT)(a) * (DWORD)(UINT)(b) / (UINT)(c))

    //
    // !!! Flickers less painting it NOW or LATER?
    // First show the current position as a bar
    //
    //hbr = (HBRUSH)SelectObject(hdc, CreateSolidBrush(HPOSBRUSH));
    //PatBlt(hdc, prc->right / 2, prc->top, 1, prc->bottom - prc->top, PATCOPY);
    //DeleteObject(SelectObject(hdc, hbr));

    //
    // Paint monochrome wave data
    //
    if (wf.wf.nChannels == 1) {

		//
		// Draw the x-axis
		//
        hbr = (HBRUSH)SelectObject(hdc, CreateSolidBrush(MONOBRUSH));
        y = rc.top + h/2;
        PatBlt(hdc, rc.left, y, w, 1, PATCOPY);
    
		//
		// 8 bit data is centred around 0x80
		//
        if (wf.wBitsPerSample == 8) {
            for (x=0; x<w; x++) {

				// which byte of audio data belongs at this pixel?
                b = *((HPBYTE)lpAudio + muldiv32(x, lLen, w));

                if (b > 0x80) {
                    i = y - MulDiv(b - 0x80, (h / 2), 128);
                    PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY);
                	}
                else {
                    i = y + MulDiv(0x80 - b, (h / 2), 128);
                    PatBlt(hdc, rc.left + x, y, 1, i - y, PATCOPY);
                	}
            	}
        	}

		//
		// 16 bit data is centred around 0x00
		//
        else if (wf.wBitsPerSample == 16) {
            for (x=0; x<w; x++) {

				// which byte of audio data belongs at this pixel?
	            i = *((HPINT)lpAudio + muldiv32(x,lLen,w));

	            if (i > 0) {
	               i = y - (int) ((LONG)i * (h/2) / 32768);
	               PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY);
	            	}
	            else {
	               i = (int) ((LONG)i * (h/2) / 32768);
	               PatBlt(hdc, rc.left+x, y, 1, -i, PATCOPY);
	            	}
	            }
        	}
        DeleteObject(SelectObject(hdc, hbr));
	    } // endif mono

    //
    // Draw stereo waveform data
    //
    else if (wf.wf.nChannels == 2) {
		//
		// 8 bit data is centred around 0x80
		//
        if (wf.wBitsPerSample == 8) {

            // Left channel
            hbr = (HBRUSH)SelectObject(hdc, CreateSolidBrush(LEFTBRUSH));
            y = rc.top + h/4;
            PatBlt(hdc, rc.left, y, w, 1, PATCOPY);

            for (x=0; x<w; x++) {
                b = *((HPBYTE)lpAudio + muldiv32(x,lLen,w) * 2);

                if (b > 0x80) {
                    i = y - MulDiv(b-0x80,(h/4),128);
                    PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY);
                	}
                else {
                    i = y + MulDiv(0x80-b,(h/4),128);
                    PatBlt(hdc, rc.left+x, y, 1, i-y, PATCOPY);
                	}
            	}
            DeleteObject(SelectObject(hdc, hbr));
                
            // Right channel
            hbr = (HBRUSH)SelectObject(hdc, CreateSolidBrush(RIGHTBRUSH));
            y = rc.top + h * 3 / 4;
            PatBlt(hdc, rc.left, y, w, 1, PATCOPY);

            for (x=0; x<w; x++) {
                b = *((HPBYTE)lpAudio + muldiv32(x,lLen,w) * 2 + 1);

                if (b > 0x80) {
                    i = y - MulDiv(b-0x80,(h/4),128);
                    PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY);
                	}
                else {
                    i = y + MulDiv(0x80-b,(h/4),128);
                    PatBlt(hdc, rc.left+x, y, 1, i-y, PATCOPY);
                	}
            	}
            DeleteObject(SelectObject(hdc, hbr));
        }

		//
		// 16 bit data is centred around 0x00
		//
        else if (wf.wBitsPerSample == 16) {

            // Left channel
            hbr = (HBRUSH)SelectObject(hdc, CreateSolidBrush(LEFTBRUSH));
            y = rc.top + h/4;
            PatBlt(hdc, rc.left, y, w, 1, PATCOPY);

            for (x=0; x<w; x++) {
                i = *((HPINT)lpAudio + muldiv32(x,lLen,w) * 2);
                if (i > 0) {
                    i = y - (int) ((LONG)i * (h/4) / 32768);
                    PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY);
                	}
                else {
                    i = (int) ((LONG)i * (h/4) / 32768);
                    PatBlt(hdc, rc.left+x, y, 1, -i, PATCOPY);
                	}
            	}
            DeleteObject(SelectObject(hdc, hbr));

            // Right channel
            hbr = (HBRUSH)SelectObject(hdc, CreateSolidBrush(RIGHTBRUSH));
            y = rc.top + h * 3 / 4;
            PatBlt(hdc, rc.left, y, w, 1, PATCOPY);

            for (x=0; x<w; x++) {
                i = *((HPINT)lpAudio + muldiv32(x,lLen,w) * 2 + 1);
                if (i > 0) {
                	i = y - (int) ((LONG)i * (h/4) / 32768);
                	PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY);
               	 	}
                else {
                	i = (int) ((LONG)i * (h/4) / 32768);
                	PatBlt(hdc, rc.left+x, y, 1, -i, PATCOPY);
                	}
            	}
            DeleteObject(SelectObject(hdc, hbr));
        	}
    	} // endif stereo

	if (lpAudio) {
		GlobalFreePtr(lpAudio);
    	lpAudio = NULL;
		}
	}








#endif // WIN95STUFF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Misc\gizmo.cpp ===
/**********************************************************************
 *<
	FILE: gizmo.cpp

	DESCRIPTION: An apparatus object

	CREATED BY: Rolf Berteig

	HISTORY: 4-15-96

 *>	Copyright (c) 1996 Rolf Berteig, All Rights Reserved.
 **********************************************************************/

//#include "inferno.h"

#include "core.h"
#include "iparamb.h"
#include <plugapi.h>
#include "custcont.h"
#include "coremain.h"
#include "resource.h"
#include "render.h"
#include "plugin.h"
#include "mouseman.h"

#include "gizmo.h"

IParamMap *GizmoObject::pmapParam = NULL;
IObjParam *GizmoObject::ip        = NULL;

GizmoObject *GizmoObject::editOb = NULL;


GizmoObject::GizmoObject()
	{	
	pblock = NULL;
	}

GizmoObject::~GizmoObject()
	{
	DeleteAllRefsFromMe();
	}


void GizmoObject::BeginEditParams(
		IObjParam  *ip, ULONG flags,Animatable *prev)
	{
	editOb = this;
	}

void GizmoObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{
	editOb = NULL;
	}

int GizmoObject::HitTest(
		TimeValue t, INode* inode, int type, 
		int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt)
	{
	HitRegion hitRegion;
	DWORD	savedLimits;
	GraphicsWindow *gw = vpt->getGW();	
	MakeHitRegion(hitRegion, type, crossing, 4, p);
	gw->setTransform(inode->GetObjectTM(t));
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) 
		| GW_PICK) & ~GW_ILLUM);
	gw->setHitRegion(&hitRegion);
	gw->clearHitCode();	
	DrawGizmo(t,gw);
	int res = gw->checkHitCode();
	gw->setRndLimits(savedLimits);
	return res;
	}

int GizmoObject::Display(
		TimeValue t, INode* inode, 
		ViewExp *vpt, int flags)
	{
	GraphicsWindow *gw = vpt->getGW();
	Matrix3 mat = inode->GetObjectTM(t);
	Point3 color = WireColor();
	gw->setTransform(mat);	
	if (inode->Selected()) {
		gw->setColor(LINE_COLOR,GetSelColor());
	} else if(!inode->IsFrozen()) {
		gw->setColor(LINE_COLOR,color.x,color.y,color.z);
		}
		
	DrawGizmo(t,gw);
	return 0;
	}

int GizmoObject::CanConvertToType(Class_ID obtype)
	{
	return obtype==ClassID();
	}

Object* GizmoObject::ConvertToType(
		TimeValue t, Class_ID obtype)
	{
	if (obtype==ClassID()) return this;
	else return NULL;
	}

void GizmoObject::GetWorldBoundBox(
		TimeValue t, INode* inode, 
		ViewExp* vpt, Box3& box )
	{
	Matrix3 mat = inode->GetObjectTM(t);
	box.Init();
	GetBoundBox(mat,t,box);
	}

void GizmoObject::GetLocalBoundBox(
		TimeValue t, INode* inode, 
		ViewExp* vpt, Box3& box )
	{
	Matrix3 mat(1);
	box.Init();
	GetBoundBox(mat,t,box);
	}

void GizmoObject::GetDeformBBox(
		TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel)
	{
	Matrix3 mat(1);
	if (tm) mat = *tm;
	box.Init();
	GetBoundBox(mat,t,box);
	}


RefResult GizmoObject::NotifyRefChanged(
		Interval changeInt,
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:			
			if (editOb==this) InvalidateUI();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Misc\footstep.cpp ===
/**********************************************************************
 *<
	FILE: footstep.cpp

	DESCRIPTION:  A sample controller that draws foot step apparatuses

	CREATED BY: Rolf Berteig

	HISTORY: created 5/10/94

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "core.h"
#include "object.h"
#include "splshape.h"
#include "resource.h"
#include "custcont.h"
#include "units.h"
#include "mouseman.h"
#include "control.h"
#include "objmode.h"
#include "cmdmode.h"
#include "Maxapi.h"
#include "decomp.h"
#include "coremain.h"

#define FOOTSAMPLE_CLASS_ID		0x3001
#define FOOTSAMPLE_CNAME		GetResString(IDS_RB_FOOTSTEPSAMPLE)

#define NUM_FOOTSTEPS	10

class FootStepControl : public Control {
		friend class FootStepContRest;
		friend BOOL CALLBACK FootStepParamDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	private:
		BOOL showSteps;
		Matrix3 tm;
		Matrix3 fs[NUM_FOOTSTEPS];
		BitArray sel;

		static FootStepControl *editCtrl;
		static HWND hParams;
		static IObjParam *ip;
		static MoveCtrlApparatusCMode *moveMode;
		static RotateCtrlApparatusCMode *rotMode;
		static UScaleCtrlApparatusCMode *uscaleMode;
		static NUScaleCtrlApparatusCMode *nuscaleMode;
		static SquashCtrlApparatusCMode *squashMode;
		static SelectCtrlApparatusCMode *selectMode;

		void Move(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& v, BOOL localOrigin, int commit=1); 
		void Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& q, BOOL localOrigin, int commit=1);
		void Scale(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin, int commit=1);
		void SetAbsValue(TimeValue t, const Matrix3 &val,const Matrix3 &parent, int commit=1);

	public:		
		static HWND hFootParams;
		static IObjParam *iObjParams;

		FootStepControl(BOOL loading=FALSE);
		FootStepControl(const FootStepControl& ctrl);		
		FootStepControl& operator=(const FootStepControl& ctrl);
		void HoldTrack();

		// From Control
		void Copy(Control *from);
		void CommitValue(TimeValue t) {}
		void RestoreValue(TimeValue t) {}
		virtual BOOL IsLeaf() {return FALSE;}
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValue(TimeValue t, void *val, int commit=1, GetSetMethod method=CTRL_ABSOLUTE);
		
		// From control -- for apparatus manipulation
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box);
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void ActivateSubobjSel(int level, XFormModes& modes );
		void SelectSubComponent(CtrlHitRecord *hitRec, BOOL selected, BOOL all);
		void ClearSelection(int selLevel);
		int SubObjectIndex(CtrlHitRecord *hitRec);
		
		//int NumSubObjects(TimeValue t,INode *node);
		//void GetSubObjectTM(TimeValue t,INode *node,int subIndex,Matrix3& tm);
		//Point3 GetSubObjectCenter(TimeValue t,INode *node,int subIndex,int type);
		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node);

		void SubMove( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
		void SubRotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE );
		void SubScale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
		
		RefTargetHandle Clone(RemapDir& remap = NoRemap()) { return(new FootStepControl(* this)); }

		// From Animatable
		Class_ID ClassID() { return Class_ID(FOOTSAMPLE_CLASS_ID,0); }  
		SClass_ID SuperClassID() { return CTRL_MATRIX3_CLASS_ID; }  
		void GetClassName(TSTR& s) { s = FOOTSAMPLE_CNAME; }
		void DeleteThis() { delete this; }		
		int IsKeyable(){ return 0;}
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev); 
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next); 		
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage) {return REF_SUCCEED;}
	};

HWND                       FootStepControl::hParams     = NULL;
IObjParam*                 FootStepControl::ip          = NULL;
FootStepControl*           FootStepControl::editCtrl    = NULL;
MoveCtrlApparatusCMode*    FootStepControl::moveMode    = NULL;
RotateCtrlApparatusCMode*  FootStepControl::rotMode     = NULL;
UScaleCtrlApparatusCMode*  FootStepControl::uscaleMode  = NULL;
NUScaleCtrlApparatusCMode* FootStepControl::nuscaleMode = NULL;
SquashCtrlApparatusCMode*  FootStepControl::squashMode  = NULL;
SelectCtrlApparatusCMode*  FootStepControl::selectMode  = NULL;


//********************************************************
// FOOTSTEP CONTROL
//********************************************************
static Class_ID footControlClassID(FOOTSAMPLE_CLASS_ID,0); 
class FootStepClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new FootStepControl(loading); }
	const TCHAR *	ClassName() { return FOOTSAMPLE_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_MATRIX3_CLASS_ID; }
	Class_ID		ClassID() { return footControlClassID; }
	const TCHAR* 	Category() { return _T("");  }
	};
static FootStepClassDesc footStepCD;

ClassDesc *GetFootStepDescriptor()
	{
	return &footStepCD;
	}

class FootStepContRest: public RestoreObj {
	public:		
		FootStepControl *ctrl;
		Matrix3 undo,redo,undofs[NUM_FOOTSTEPS],redofs[NUM_FOOTSTEPS];
		BitArray undoSel,redoSel;
		FootStepContRest(FootStepControl *c) {
			ctrl = c;
			undo = c->tm;
			undoSel = c->sel;
			for (int i=0; i<NUM_FOOTSTEPS; i++) {
				undofs[i] = ctrl->fs[i];
				}
			}					
		void Restore(int isUndo) {			
			redo = ctrl->tm;			
			ctrl->tm = undo;
			redoSel = ctrl->sel;
			ctrl->sel = undoSel;
			for (int i=0; i<NUM_FOOTSTEPS; i++) {
				redofs[i]   = ctrl->fs[i];
				ctrl->fs[i] = undofs[i];
				}
			ctrl->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo() {
			ctrl->tm = redo;
			ctrl->sel = redoSel;
			for (int i=0; i<NUM_FOOTSTEPS; i++) {
				ctrl->fs[i] = redofs[i];				
				}
			ctrl->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		int Size() {return sizeof(FootStepContRest);}
		void EndHold() { ctrl->ClearAFlag(A_HELD); }		
	};


FootStepControl::FootStepControl(BOOL loading)
	{
	tm.IdentityMatrix();
	showSteps = TRUE;
	sel.SetSize(NUM_FOOTSTEPS);
	for (int i=0; i<NUM_FOOTSTEPS; i++) {
		fs[i].IdentityMatrix();
		Point3 t;
		t.x = i&1 ? -5.0f : 5.0f;
		t.y = float(i) * 15.0f;
		t.z = 0.0f;
		fs[i].SetTrans(t);
		}
	}

FootStepControl::FootStepControl(const FootStepControl& ctrl)
	{
	*this = ctrl;	
	}

FootStepControl& FootStepControl::operator=(const FootStepControl& ctrl)
	{
	tm = ctrl.tm;
	showSteps = ctrl.showSteps;
	sel = ctrl.sel;
	for (int i=0; i<NUM_FOOTSTEPS; i++) {
		fs[i] = ctrl.fs[i];
		}
	return (*this);
	}

void FootStepControl::Copy(Control *from)
	{
	if (from->ClassID()==ClassID()) {
	 	FootStepControl *fctrl = (FootStepControl*)from;
		*this = *fctrl;
	} else {
		Interval valid;
		tm.IdentityMatrix();
		from->GetValue(0,&tm,valid,CTRL_RELATIVE);
		}
	}

void FootStepControl::HoldTrack()
	{
	if (theHold.Holding()&&!TestAFlag(A_HELD)) {		
		theHold.Put(new FootStepContRest(this));
		SetAFlag(A_HELD);
		}
	}

void FootStepControl::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	if (method == CTRL_ABSOLUTE) {
		*((Matrix3*)val) = tm;
	} else {
		*((Matrix3*)val) = tm * *((Matrix3*)val);
		}
	}

void FootStepControl::SetValue(
		TimeValue t, void *val, int commit, GetSetMethod method)
	{
	SetXFormPacket *ptr = (SetXFormPacket*)val;
	
	HoldTrack();

	switch (ptr->command) {
		case XFORM_MOVE:
			Move(t,ptr->tmParent,ptr->tmAxis,ptr->p,ptr->localOrigin,commit);
			break;
		case XFORM_ROTATE:
			Rotate(t,ptr->tmParent,ptr->tmAxis,ptr->q,ptr->localOrigin,commit);
			break;
		case XFORM_SCALE:
			Scale(t,ptr->tmParent,ptr->tmAxis,ptr->p,ptr->localOrigin,commit);
			break;
		
		case XFORM_SET:
			SetAbsValue(t,ptr->tmAxis,ptr->tmParent,commit);
			break;
		}
	}
		

void FootStepControl::Move(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& v, 
		BOOL localOrigin, int commit)
	{
	Point3 p = VectorTransform(tmAxis*Inverse(partm),v);
	tm.Translate(p);	
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void FootStepControl::Rotate( 
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& q, 
		BOOL localOrigin, int commit)
	{
	Matrix3 mat;
	q.MakeMatrix(mat);
	mat = partm*Inverse(tmAxis)*mat*tmAxis*Inverse(partm);
	tm  = tm * mat;	
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void FootStepControl::Scale(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, 
		BOOL localOrigin, int commit)
	{
	Matrix3 mat = ScaleMatrix(val);
	mat = partm*Inverse(tmAxis)*mat*tmAxis*Inverse(partm);
	tm  = tm * mat;	
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void FootStepControl::SetAbsValue(
		TimeValue t, const Matrix3 &val,const Matrix3 &parent, int commit)
	{
	tm = val*Inverse(parent);
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}


// A foot print
#define FOOT_POINTS		14
static Point3 footPts[15] = { // NOTE: I'm pretty sure an extra point is needed in the array for GFX.
		Point3(-2,0,0),Point3(-2,-1,0),Point3(-1,-2,0),
		Point3(1,-2,0),Point3(2,-1,0),Point3(2,0,0),
		Point3(1,1,0),Point3(2,4,0),Point3(2,6,0),
		Point3(1,7,0),Point3(-1,7,0),Point3(-2,6,0),
		Point3(-2,4,0),Point3(-1,1,0)};	


int FootStepControl::Display(
		TimeValue t, INode* inode, ViewExp *vpt, int flags)
	{
	if (showSteps || editCtrl==this) {
		GraphicsWindow *gw = vpt->getGW();
		Matrix3 ntm = inode->GetNodeTM(t);		
		for (int i=0; i<NUM_FOOTSTEPS; i++) {
			if (sel[i] && editCtrl==this) {
				gw->setColor(LINE_COLOR,1.0f,0.0f,0.0f);
			} else {
				gw->setColor(LINE_COLOR,1.0f,1.0f,0.0f);
				}
			gw->setTransform(fs[i]*ntm);
			gw->polyline(FOOT_POINTS,footPts,NULL,NULL,TRUE,NULL);
			}
		}
	return 0;
	}

void FootStepControl::GetWorldBoundBox(
		TimeValue t,INode* inode, ViewExp *vpt, Box3& box)
	{
	if (showSteps || editCtrl==this) {
		Matrix3 ntm = inode->GetNodeTM(t);
		box.Init();
		for (int i=0; i<NUM_FOOTSTEPS; i++) {
			for (int j=0; j<FOOT_POINTS; j++) {
				box += fs[i]*ntm * footPts[j];
				}
			}
		}
	}

int FootStepControl::HitTest(
		TimeValue t, INode* inode, int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt)
	{
	int savedLimits, res = 0;
	GraphicsWindow *gw = vpt->getGW();
	Matrix3 ntm = inode->GetNodeTM(t);
	HitRegion hr;
	MakeHitRegion(hr,type,crossing,4,p);
	gw->setHitRegion(&hr);
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->clearHitCode();
	
	BOOL abortOnHit = flags&SUBHIT_ABORTONHIT?TRUE:FALSE; 
	BOOL selOnly    = flags&SUBHIT_SELONLY?TRUE:FALSE; 
	BOOL unselOnly  = flags&SUBHIT_UNSELONLY?TRUE:FALSE; 

	for (int i=0; i<NUM_FOOTSTEPS; i++) {
		if (selOnly && !sel[i]) continue;
		if (unselOnly && sel[i]) continue;
		gw->setTransform(fs[i]*ntm);
		gw->polyline(FOOT_POINTS,footPts,NULL,NULL,TRUE,NULL);
		if (gw->checkHitCode()) {
			res = TRUE;
			vpt->CtrlLogHit(inode,gw->getHitDistance(),i,0);
			if (abortOnHit) {
				break;
				}
			gw->clearHitCode();
			}
		}

	gw->setRndLimits(savedLimits);
	return res;
	}

void FootStepControl::ActivateSubobjSel(int level, XFormModes& modes )
	{
	if (level) {
		modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,selectMode);
		}
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);	
	}

void FootStepControl::SelectSubComponent(
		CtrlHitRecord *hitRec, BOOL selected, BOOL all)
	{
	HoldTrack();
	while (hitRec) {
		if (selected) {
			sel.Set(hitRec->hitInfo);
		} else {
			sel.Clear(hitRec->hitInfo);
			}
		if (all) hitRec = hitRec->Next();
		else break;
		}
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void FootStepControl::ClearSelection(int selLevel)	
	{
	HoldTrack();
	sel.ClearAll();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}


int FootStepControl::SubObjectIndex(CtrlHitRecord *hitRec)
	{
	int count = 0;
	for (ulong i=0; i<hitRec->hitInfo; i++) {
		if (sel[i]) count++;
		}
	return count;
	}

void FootStepControl::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,INode *node)
	{
	Matrix3 mat(1);
	if (cb->Type()==SO_CENTER_SELECTION) {
		Point3 center(0,0,0);
		Matrix3 ntm = node->GetNodeTM(t);
		for (int i=0; i<NUM_FOOTSTEPS; i++) {
			mat = fs[i] * ntm;
			center += mat.GetTrans();
			}
		center /= float(NUM_FOOTSTEPS);
		cb->Center(center,0);
	} else {		
		for (int i=0; i<NUM_FOOTSTEPS; i++) {
			if (sel[i]) {
				mat = fs[i] * node->GetNodeTM(t);
				cb->Center(mat.GetTrans(),i);
				}			
			}		
		}
	}

void FootStepControl::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,INode *node)
	{
	Matrix3 mat;	
	for (int i=0; i<NUM_FOOTSTEPS; i++) {
		if (sel[i]) {
			mat = fs[i]*node->GetNodeTM(t);
			cb->TM(mat,i);			
			}		
		}
	}

/*
int FootStepControl::NumSubObjects(TimeValue t,INode *node)
	{
	int count = 0;
	for (int i=0; i<NUM_FOOTSTEPS; i++) {
		if (sel[i]) count++;
		}
	return count;
	}

void FootStepControl::GetSubObjectTM(TimeValue t,INode *node,int subIndex,Matrix3& tm)
	{	
	int count = 0;
	for (int i=0; i<NUM_FOOTSTEPS; i++) {
		if (count == subIndex) {
			tm = fs[i]*node->GetNodeTM(t);
			return;
			}
		if (sel[i]) count++;
		}
	tm.IdentityMatrix();
	}

Point3 FootStepControl::GetSubObjectCenter(TimeValue t,INode *node,int subIndex,int type)
	{
	Matrix3 tm(1);
	if (type==SO_CENTER_SELECTION) {
		Point3 center(0,0,0);
		Matrix3 ntm = node->GetNodeTM(t);
		for (int i=0; i<NUM_FOOTSTEPS; i++) {
			tm = fs[i] * ntm;
			center += tm[3];
			}
		center /= float(NUM_FOOTSTEPS);
		return center;
	} else {
		int count = 0;
		for (int i=0; i<NUM_FOOTSTEPS; i++) {
			if (count == subIndex) {
				tm = fs[i] * node->GetNodeTM(t);
				}
			if (sel[i]) count++;
			}
		return tm[3];
		}
	}
*/

void FootStepControl::SubMove( 
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, 
		BOOL localOrigin)
	{	
	Matrix3 mat(1);
	Point3 p = VectorTransform(tmAxis*Inverse(partm),val);
	mat.Translate(p);		
	HoldTrack();
	for (int i=0; i<NUM_FOOTSTEPS; i++) {
		if (sel[i]) fs[i] = fs[i] * mat;
		}
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void FootStepControl::SubRotate( 
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, 
		BOOL localOrigin)
	{
	Matrix3 mat;
	val.MakeMatrix(mat);
	mat = partm*Inverse(tmAxis)*mat*tmAxis*Inverse(partm);
	HoldTrack();
	for (int i=0; i<NUM_FOOTSTEPS; i++) {
		if (sel[i]) fs[i] = fs[i] * mat;
		}
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void FootStepControl::SubScale( 
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, 
		BOOL localOrigin)
	{
	Matrix3 mat = ScaleMatrix(val);
	mat = partm*Inverse(tmAxis)*mat*tmAxis*Inverse(partm);
	HoldTrack();
	for (int i=0; i<NUM_FOOTSTEPS; i++) {
		if (sel[i]) fs[i] = fs[i] * mat;
		}
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}


BOOL CALLBACK FootStepParamDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	static BOOL xEnabled=TRUE;
	static BOOL yEnabled=TRUE;
	static BOOL zEnabled=TRUE;
	static BOOL xyEnabled=TRUE;
	static BOOL centerEnabled=TRUE;
	static BOOL refEnabled=TRUE;

	FootStepControl *co = (FootStepControl*)GetWindowLong(hDlg,GWL_USERDATA);
	if ( !co && message != WM_INITDIALOG ) return FALSE;
	switch ( message ) {
		case WM_INITDIALOG:
			co = (FootStepControl*)lParam;
			SetWindowLong(hDlg,GWL_USERDATA,(LONG)co);			
			CheckDlgButton(hDlg,IDC_SHOWFOOTPRINTS,co->showSteps);
			return TRUE;

		case WM_LBUTTONDOWN:case WM_LBUTTONUP:	case WM_MOUSEMOVE:
			co->ip->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {				
				case IDC_ACTIVE_X:
					co->ip->SetAxisConstraints(AXIS_X); break;
				case IDC_ACTIVE_Y:
					co->ip->SetAxisConstraints(AXIS_Y); break;
				case IDC_ACTIVE_Z:
					co->ip->SetAxisConstraints(AXIS_Z); break;
				case IDC_ACTIVE_XY:
					co->ip->SetAxisConstraints(AXIS_XY); break;
				case IDC_ACTIVE_YZ:
					co->ip->SetAxisConstraints(AXIS_YZ); break;
				case IDC_ACTIVE_ZX:
					co->ip->SetAxisConstraints(AXIS_ZX); break;

				case IDC_ACTIVE_SYS:
					co->ip->SetCoordCenter(ORIGIN_SYSTEM); break;
				case IDC_ACTIVE_SEL:
					co->ip->SetCoordCenter(ORIGIN_SELECTION); break;
				case IDC_ACTIVE_LOCAL:
					co->ip->SetCoordCenter(ORIGIN_LOCAL); break;

				case IDC_ACTIVE_VIEW:
					co->ip->SetRefCoordSys(COORDS_HYBRID); break;
				case IDC_ACTIVE_SCREEN:
					co->ip->SetRefCoordSys(COORDS_SCREEN); break;
				case IDC_ACTIVE_WORLD:
					co->ip->SetRefCoordSys(COORDS_WORLD); break;
				case IDC_ACTIVE_PARENT:
					co->ip->SetRefCoordSys(COORDS_PARENT); break;
				case IDC_ACTIVE_LOCALSYS:
					co->ip->SetRefCoordSys(COORDS_LOCAL); break;
				case IDC_ACTIVE_OBJECT:
					co->ip->SetRefCoordSys(COORDS_OBJECT); break;


				case IDC_ENABLE_X:
					xEnabled = !xEnabled;
					co->ip->EnableAxisConstraints(AXIS_X,xEnabled);
					break;
				case IDC_ENABLE_Y:
					yEnabled = !yEnabled;
					co->ip->EnableAxisConstraints(AXIS_Y,yEnabled); 
					break;
				case IDC_ENABLE_Z:
					zEnabled = !zEnabled;
					co->ip->EnableAxisConstraints(AXIS_Z,zEnabled); 
					break;
				case IDC_ENABLE_XY:					
				case IDC_ENABLE_YZ:					
				case IDC_ENABLE_ZX:
					xyEnabled = !xyEnabled;
					co->ip->EnableAxisConstraints(AXIS_XY,xyEnabled); 
					break;

				case IDC_ENABLE_SYS:
				case IDC_ENABLE_SEL:
				case IDC_ENABLE_LOCAL:
					centerEnabled = !centerEnabled;
					co->ip->EnableCoordCenter(centerEnabled); 
					break;
					
				case IDC_ENABLE_VIEW:					
				case IDC_ENABLE_SCREEN:					
				case IDC_ENABLE_WORLD:					
				case IDC_ENABLE_PARENT:					
				case IDC_ENABLE_LOCALSYS:
				case IDC_ENABLE_OBJECT:
					refEnabled = !refEnabled;
					co->ip->EnableRefCoordSys(refEnabled);
					break;


				case IDC_SHOWFOOTPRINTS:
					if (IsDlgButtonChecked(hDlg,IDC_SHOWFOOTPRINTS)) {
						co->showSteps = TRUE;
					} else {
						co->showSteps = FALSE;
						}
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

void FootStepControl::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	editCtrl = this;
	this->ip = ip;	
	hParams  = ip->AddRollupPage( 
		getResMgr().getHInst(RES_ID_RB), 
		MAKEINTRESOURCE(IDD_FOOTSTEPPARAMS),
		FootStepParamDialogProc,
		GetResString(IDS_RB_FOOTSTEPPARAMS), 
		(LPARAM)this );		
	ip->RegisterDlgWnd(hParams);	
	
	moveMode    = new MoveCtrlApparatusCMode(this,ip);
	rotMode     = new RotateCtrlApparatusCMode(this,ip);
	uscaleMode  = new UScaleCtrlApparatusCMode(this,ip);
	nuscaleMode = new NUScaleCtrlApparatusCMode(this,ip);
	squashMode  = new SquashCtrlApparatusCMode(this,ip);
	selectMode  = new SelectCtrlApparatusCMode(this,ip);

	TSTR type(GetResString(IDS_RB_FOOTPRINT));	
	TCHAR *ptype = type;
	ip->RegisterSubObjectTypes((const TCHAR**)&ptype,1);
	
	if (!showSteps) {
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		ip->RedrawViews(ip->GetTime());
		}
	}

void FootStepControl::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	editCtrl = NULL;
	if (!showSteps) {
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		ip->RedrawViews(ip->GetTime());
		}	
	ip->UnRegisterDlgWnd(hParams);
	ip->DeleteRollupPage(hParams);
	this->ip=NULL;
	hParams=NULL;

	// This ensures that the mode isn't left around after editing is
	// completed.
	ip->DeleteMode(moveMode);
	ip->DeleteMode(rotMode);
	ip->DeleteMode(uscaleMode);
	ip->DeleteMode(nuscaleMode);
	ip->DeleteMode(squashMode);
	ip->DeleteMode(selectMode);
	delete moveMode; moveMode = NULL;
	delete rotMode; rotMode = NULL;
	delete uscaleMode; uscaleMode = NULL;
	delete nuscaleMode; nuscaleMode = NULL;
	delete squashMode; squashMode = NULL;
	delete selectMode; selectMode = NULL;	
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Misc\sound.h ===
/**********************************************************************
 *<
	FILE:  sound.h

	DESCRIPTION:  Some sound related functions

	CREATED BY:  Rolf Berteig -- based on examples fro VFW SDK

	HISTORY: created 2 July 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __SOUND_H__
#define __SOUND_H__


class FilteredWave {
	private:
		DWORD *sat;
		DWORD satLen, max[2];
		int channels, numSum;
		TimeValue start, end;

	public:
		FilteredWave(PAVISTREAM pavi,int resolution);
		~FilteredWave();

		int Channels() {return channels;}
		DWORD Sample(TimeValue t0,TimeValue t1,int channel=0);  // range is 0 - 0x8000
		DWORD Max(int channel) {return max[channel];}
		TimeValue Start() {return start;}		
		TimeValue End() {return end;}
	};



CoreExport BOOL GetSoundFileName(HWND hWnd,TSTR &name,TSTR &dir);

PAVISTREAM GetAudioStream(TSTR name,TCHAR *dir);

BOOL OpenSoundFile(HWND hWnd,PAVISTREAM *pavi);


#endif // __SOUND_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Misc\TRIOBJ.CPP ===
/**********************************************************************
 *<
	FILE: triobj.cpp

	DESCRIPTION:  Triangle Mesh Object

	CREATED BY: Dan Silva

	HISTORY: created 9 September 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "core.h"
#include "Maxapi.h"
#include "object.h"
#include "triobj.h"
#include "patchobj.h"
#include "mouseman.h"
#include "coremain.h"
#include "tessint.h"
#include "MeshDelta.h"
#ifdef DESIGN_VER
#include "igeomimp.h"
#endif
#include "displace.h"

//#define TRIPIPE_DEBUG

// The first channel to just have a bit for its validity
#define BITVALIDITY_START	5

Class_ID triObjectClassID(TRIOBJ_CLASS_ID,0);

// LOCK
static int lockVar1 = 0;
static int lockVar2 = 0;
static DWORD *lockVarPtr = NULL;

class TriObjectClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading) { return new TriObject; }
	const TCHAR *	ClassName() { return _T("MeshObject"); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID 		ClassID() { return triObjectClassID; }
	const TCHAR* 	Category() { return _T("Primitive");  }
	};

static TriObjectClassDesc triObjDesc;

CoreExport ClassDesc* GetTriObjDescriptor() 
	{ 
	lockVarPtr = COREGetCodeValue();
	return &triObjDesc; 
	}

static ClassDesc* editTriObjDesc = NULL;

void RegisterEditTriObjDesc(ClassDesc *desc)
	{
	editTriObjDesc = desc;
	}

ClassDesc* GetEditTriObjDesc()
	{		
	if (editTriObjDesc) return editTriObjDesc;
	else return &triObjDesc;
	}

TriObject *CreateNewTriObject()
	{
	return (TriObject*)GetEditTriObjDesc()->Create();
	}



void MakeHitRegion(HitRegion& hr, int type, int crossing, int epsi, IPoint2 *p){
	IPoint2 v;
	hr.epsilon = epsi;
	hr.crossing = crossing;
	switch ( type ) {
		case HITTYPE_SOLID:
		case HITTYPE_POINT:
			hr.type = POINT_RGN;
			hr.pt.x = p[0].x;
			hr.pt.y = p[0].y;
			break;
		
		case HITTYPE_BOX:
			hr.type        = RECT_RGN;
			hr.rect.left   = p[0].x;
			hr.rect.right  = p[1].x;
			hr.rect.top    = p[0].y;
			hr.rect.bottom = p[1].y;
			((Box2*)(&hr.rect))->Rectify();
			break;

		case HITTYPE_CIRCLE:
			v = p[0] - p[1];
			hr.type			= CIRCLE_RGN;
			hr.circle.x		= p[0].x;
			hr.circle.y		= p[0].y;
//			hr.circle.r		= (int)sqrt((double)(v.x*v.x + v.y*v.y));
			hr.circle.r		= max(abs(v.x), abs(v.y));	// this is how the circle is drawn!! DB 3/2
			break;

		case HITTYPE_FENCE: {
			int ct = 0;
			while (p[ct].x >= 0)
				ct++;
			hr.type			= FENCE_RGN;
			hr.epsilon		= ct;
			hr.pts			= (POINT *)p;
			break;
			}
		}
	}

#if TRI_MULTI_PROCESSING

int TriObject::refCount = 0;
HANDLE TriObject::defThread = 0;
HANDLE TriObject::defMutex = 0;
HANDLE TriObject::defStartEvent = 0;
HANDLE TriObject::defEndEvent = 0;

struct DefStuff {
	TriObject *		triobj;
	Deformer *		defProc;
	int				ct;
	int				useSel;
	BitArray 		sel;
	float *vssel;
	BOOL 			exit;
} defStuff;

static DWORD WINAPI defFunc(LPVOID ptr)
{
	while(1) {
		WaitForSingleObject(TriObject::defStartEvent, INFINITE);
		if (defStuff.exit) ExitThread(0);
		if(defStuff.useSel) {
			if (defStuff.vssel) {
				for (int i=0; i<defStuff.ct; i++) {
					if(defStuff.sel[i]) {
						defStuff.triobj->SetPoint(i, defStuff.defProc->Map(i,defStuff.triobj->GetPoint(i)));
						continue;
					}
					if (defStuff.vssel[i] == 0) continue;
					Point3 & A = defStuff.triobj->GetPoint(i);
					Point3 dir = defStuff.defProc->Map (i, A) - A;
					defStuff.triobj->SetPoint (i, A+defStuff.vssel[i]*dir);
				}
			} else {
				for(int i = 0; i < defStuff.ct; i++)
					if(defStuff.sel[i])
						defStuff.triobj->SetPoint(i, defStuff.defProc->Map(i,defStuff.triobj->GetPoint(i)));
			}
		}
		else {
			for(int i = 0; i < defStuff.ct; i++)
				defStuff.triobj->SetPoint(i, defStuff.defProc->Map(i,defStuff.triobj->GetPoint(i)));
		}
		SetEvent(TriObject::defEndEvent);
	}
	return 0;
}
#endif



TriObject::TriObject() {

	// LOCK
	if (lockVarPtr && *lockVarPtr & (1<<28)) lockVar1++;

	mesh.EnableEdgeList(1);
	geomValid.SetInfinite();
	vcolorValid.SetInfinite();
	gfxdataValid.SetInfinite();
	topoValid.SetInfinite();
	texmapValid.SetInfinite();
	selectValid.SetInfinite();
	validBits = 0xffffffff;
#if TRI_MULTI_PROCESSING
	if(!refCount++) {
		DWORD threadID;
		defStuff.exit = FALSE;
		defStartEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		defEndEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		defMutex = CreateMutex(NULL, FALSE, NULL);
	   	defThread = CreateThread(NULL, 0, defFunc, (LPVOID)defStartEvent, 0, &threadID);
		}
#endif		

	SetDisplacmentApproxToPreset(0);
	mSubDivideDisplacement = false;
	mSplitMesh = true;
	mDisableDisplacement = false;

	//DebugPrint("TriObject:0x%x\n",this);
	}

TriObject::~TriObject() {
#ifdef TRIPIPE_DEBUG
	DebugPrint ("TriObject(%08x)::Deleting (%08x)\n", this, ~GetChannelLocks());
#endif
	mesh.FreeChannels(~GetChannelLocks(),TRUE);

#if TRI_MULTI_PROCESSING
	if(--refCount == 0) {
		//TerminateThread(defThread, 0);		
		defStuff.exit = TRUE;
		SetEvent(defStartEvent);
		WaitForSingleObject(defThread, INFINITE);

		CloseHandle(defThread);
		CloseHandle(defEndEvent);
		CloseHandle(defStartEvent);
		CloseHandle(defMutex);		
		}
#endif
	
	//DebugPrint("~TriObject:0x%x\n",this);
	}

// From BaseObject

int TriObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) {
	
	// LOCK
	if (lockVarPtr && *lockVarPtr & (1<<29)) lockVar2++;

	HitRegion hitRegion;
	GraphicsWindow *gw = vpt->getGW();
	MakeHitRegion(hitRegion,type,crossing,4,p);	
	gw->setTransform(inode->GetObjectTM(t));
//	hitRegion.epsilon = 4;	 -- this is wrong! It screws up fence picking! DB 6/28/97
//	hitRegion.crossing = crossing;
	return mesh.select( gw, inode->Mtls(), &hitRegion, flags & HIT_ABORTONHIT, inode->NumMtls() );
	}

void TriObject::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) {
	Matrix3 tm = inode->GetObjectTM(t);	
	GraphicsWindow *gw = vpt->getGW();
	gw->setTransform(tm);
	// If we snap, transform the best snap world from its local coords to world
	mesh.snap( gw, snap, p, tm );
	}

int TriObject::Display(TimeValue t, INode *inode, ViewExp* vpt, int flags) {
	Matrix3 tm;
	GraphicsWindow *gw = vpt->getGW();
	gw->setTransform(inode->GetObjectTM(t));
	mesh.render( gw, inode->Mtls(),
		(flags&USE_DAMAGE_RECT) ? &vpt->GetDammageRect() : NULL, 
		COMP_ALL | ((flags&DISP_SHOWSUBOBJECT)?COMP_OBJSELECTED:0),
		inode->NumMtls());
		// RB: The mesh flag COMP_OBJSELECTED is sort of misnamed. When this bit is set, sub object things (like ticks and selected faces) will be drawn.
	
	// LOCK
	if (lockVar1<lockVar2) {
		for (int i=0; i<mesh.getNumVerts(); i++) {
			mesh.verts[i] *= 0.99f;
			}
		}


	return(0);
	}

// From Object

class TriObjCreateCallBack: public CreateMouseCallBack {
	public:
		virtual int proc( ViewExp* vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
	};

int TriObjCreateCallBack::proc(ViewExp* vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat) {
	switch ( msg ) {
		case MOUSE_POINT:
			if ( point == 0 ) {
				}
			break;
		case MOUSE_ABORT:
			break;
		case MOUSE_MOVE:			
			break;
		}
	return TRUE;
	}

static TriObjCreateCallBack triCreateCB;

CreateMouseCallBack* TriObject::GetCreateMouseCallBack() {
	return(&triCreateCB);
	}

RefTargetHandle TriObject::Clone(RemapDir& remap) {
	TriObject* newob = new TriObject;
	newob->mesh = mesh;
	newob->mDispApprox = mDispApprox;
	newob->mSubDivideDisplacement = mSubDivideDisplacement;
	newob->mSplitMesh = mSplitMesh;
	newob->mDisableDisplacement = mDisableDisplacement;
	return newob;
	}

// From GeomObject
int TriObject::IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm)
	{
	return mesh.IntersectRay(ray,at,norm);
	}

ObjectHandle TriObject::CreateTriObjRep(TimeValue t) {
	return(ObjectHandle(this));
	}

void TriObject::GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel ) 
	{	
	if ( tm || useSel ) {
		box.Init();
		BitArray sel;
		float *vssel = NULL;
		if ( useSel ) {
			sel = mesh.VertexTempSel();
			vssel = mesh.getVSelectionWeights ();
			}
		for ( int i = 0; i < mesh.getNumVerts(); i++ ) {
			if ( !useSel || sel[i] || (vssel&&vssel[i])) {
				if ( tm ) {
					box += *tm * mesh.getVert(i);
				} else {
					box += mesh.getVert(i);
					}
				}
			}
	} else {
		box = mesh.getBoundingBox();
		}
	}

void TriObject::GetLocalBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box ) {
	GetDeformBBox(t,box);
	}

void TriObject::GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box )
	{
	Box3	meshBox;

	Matrix3 mat = inode->GetObjectTM(t);
	
	GetLocalBoundBox(t,inode,vpt,meshBox);
	if(meshBox.IsEmpty())
		box = meshBox;
	else {
		box.Init();
		for(int i = 0; i < 8; i++)
			box += mat * meshBox[i];
		}
	}

// Reference Managment.
//


// This is only called if the object MAKES references to other things.
RefResult TriObject::NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message ) {
	return(REF_SUCCEED);
	}

ObjectState TriObject::Eval(TimeValue time) {
	return(ObjectState(this));
	}

// get and set the validity interval for the nth channel
Interval TriObject::ChannelValidity(TimeValue t, int nchan) {
	switch(nchan) {
		case GEOM_CHAN_NUM: return geomValid; break;
		case VERT_COLOR_CHAN_NUM: return vcolorValid; break;
		case TOPO_CHAN_NUM: return topoValid; break;
		case TEXMAP_CHAN_NUM: return texmapValid; break;
		case SELECT_CHAN_NUM: return selectValid; break;
		case GFX_DATA_CHAN_NUM: return gfxdataValid; break;
		default:
			return((chMask[nchan]&validBits) ? FOREVER: NEVER);
		}
	}

// the modifier modifies.
void TriObject::SetChannelValidity(int nchan, Interval v) {
	switch(nchan) {
		case GEOM_CHAN_NUM: geomValid = v; break;
		case VERT_COLOR_CHAN_NUM: vcolorValid = v; break;
		case TOPO_CHAN_NUM: topoValid = v; break;
		case TEXMAP_CHAN_NUM: texmapValid = v; break;
		case SELECT_CHAN_NUM: selectValid = v; break;
		case GFX_DATA_CHAN_NUM: gfxdataValid = v; break;
		default :
			//if (v.InInterval(0)) validBits|= chMask[nchan];
			if (!(v==NEVER)) validBits|= chMask[nchan];
			else validBits &= ~chMask[nchan];
			break;
		}
	}	

void TriObject::InvalidateChannels(ChannelMask channels) {
	for (int i=0; i<NUM_OBJ_CHANS; i++) {
		if (channels&chMask[i]) {
			switch(i) {
				case GEOM_CHAN_NUM: geomValid.SetEmpty(); break;
				case VERT_COLOR_CHAN_NUM: vcolorValid.SetEmpty(); break;
				case TOPO_CHAN_NUM: topoValid.SetEmpty(); break;
				case TEXMAP_CHAN_NUM: texmapValid.SetEmpty(); break;
				case SELECT_CHAN_NUM: selectValid.SetEmpty(); break;
				case GFX_DATA_CHAN_NUM: gfxdataValid.SetEmpty(); break;
				default: validBits &= ~chMask[i]; break;
				}
			}
		}
	}

Interval TriObject::ObjectValidity(TimeValue t){
	Interval iv;
	iv.SetInfinite();
	iv &= geomValid;
	iv &= vcolorValid;
	iv &= topoValid;
	iv &= texmapValid;
	iv &= selectValid;
	iv &= gfxdataValid;
	
	if (!(validBits&chMask[SUBSEL_TYPE_CHAN_NUM])) iv.SetEmpty();
	if (!(validBits&chMask[DISP_ATTRIB_CHAN_NUM])) iv.SetEmpty();
	/*
	for (int i=BITVALIDITY_START; i<NUM_OBJ_CHANS; i++)
		if (!(validBits&chMask[i])) {
			iv.SetEmpty();
			break;
			}
	*/
	return iv;
	}

Interval TriObject::ConvertValidity(TimeValue t){
	Interval iv = FOREVER;	
	if (geomValid.InInterval(t)) iv &= geomValid;
	if (vcolorValid.InInterval(t)) iv &= vcolorValid;
	if (topoValid.InInterval(t)) iv &= topoValid;	
	if (texmapValid.InInterval(t)) iv &= texmapValid;	
	if (selectValid.InInterval(t)) iv &= selectValid;	
	return iv;
	}

int TriObject::CanConvertToType(Class_ID cid) {
	if (cid==defObjectClassID) return 1;
	if (cid==mapObjectClassID) return 1;
	if (cid==triObjectClassID) return 1;
	if (cid==patchObjectClassID) return 1;
#ifdef DESIGN_VER
	if (cid == GENERIC_AMSOLID_CLASS_ID) return 1;
#endif
	return 0;
	}


Object* TriObject::ConvertToType(TimeValue t, Class_ID cid) {
	if (cid==defObjectClassID) return this;
	if (cid==mapObjectClassID) return this;
	if (cid==triObjectClassID) return this;
	if (cid==patchObjectClassID) {
		PatchObject *patchob = new PatchObject();
		patchob->patch = mesh;
		patchob->SetChannelValidity(TOPO_CHAN_NUM,ConvertValidity(t));
		patchob->SetChannelValidity(GEOM_CHAN_NUM,ConvertValidity(t));
//		patchob->SetChannelValidity(TEXMAP_CHAN_NUM,ConvertValidity(t));
//		patchob->SetChannelValidity(SELECT_CHAN_NUM,ConvertValidity(t));
		return patchob;
		}
#ifdef DESIGN_VER
	if (cid == GENERIC_AMSOLID_CLASS_ID)
	{
		Object* solid = (Object*)CreateInstance(GEOMOBJECT_CLASS_ID, GENERIC_AMSOLID_CLASS_ID);
		assert(solid);
		if(solid)
		{
			IGeomImp* cacheptr = (IGeomImp*)(solid->GetInterface(I_GEOMIMP));
			assert(cacheptr);
			if(cacheptr)
			{
//				bool res = cacheptr->createConvexHull(mesh.verts, mesh.getNumVerts());
				cacheptr->Init((void*)&mesh, MAX_MESH_ID);
				bool res = !cacheptr->isNull();

				solid->ReleaseInterface(I_GEOMIMP, cacheptr);
				solid->SetChannelValidity(TOPO_CHAN_NUM,ConvertValidity(t));
				solid->SetChannelValidity(GEOM_CHAN_NUM,ConvertValidity(t));
				if(res)
					return solid;
			}
		}
	}
#endif
	return NULL;
	}

BOOL 
TriObject::PolygonCount(TimeValue t, int& numFaces, int& numVerts) 
{
    numFaces = GetMesh().getNumFaces();
    numVerts = GetMesh().getNumVerts();
    return TRUE;
}

typedef int (* GTess)(void *obj, SurfaceType type, Matrix3 *otm, Mesh *mesh,
							TessApprox *tess, TessApprox *disp, View *view,
							Mtl* mtl, BOOL dumpMiFile, BOOL splitMesh);
static GTess psGTessFunc = NULL;

// This function get the function to do GAP Tessellation from
// tessint.dll.  This is required because of the link order between
// core.dll and tessint.dll and gmi.dll.  -- Charlie Thaeler
static void
GetGTessFunction()
{
    if (psGTessFunc)
        return;
    // Get the library handle for tessint.dll
    HINSTANCE hInst = NULL;
	hInst = LoadLibraryEx(_T("tessint.dll"), NULL, 0);
    assert(hInst);

    psGTessFunc = (GTess)GetProcAddress(hInst, _T("GapTessellate"));
	assert(psGTessFunc);
}


Mesh*
TriObject::GetRenderMesh(TimeValue t, INode *inode, View &view, BOOL& needDelete)
{
	if (mDisableDisplacement || !(view.flags & RENDER_MESH_DISPLACEMENT_MAP)) {
		needDelete = FALSE;
		return &mesh;
	}
	// need to check the mesh and see if any face has a matId the requires displacment mapping
	BOOL needDisp = FALSE;

	// Get the material
	Mtl* pMtl = inode ? inode->GetMtl() : NULL;

	if (pMtl) {
		// does the mesh as a whole need it
		if (pMtl->Requirements(mesh.mtlIndex)&MTLREQ_DISPLACEMAP)
			needDisp = TRUE;

		if (!needDisp) {
			for (int f = 0; f < mesh.numFaces; f++) {
				if (pMtl->Requirements(mesh.getFaceMtlIndex(f))&MTLREQ_DISPLACEMAP) {
					needDisp = TRUE;
					break;
				}
			}
		}

		if (needDisp) {
            if (mesh.getNumFaces() == 0)
                return &mesh;

			Matrix3 otm;
			if (inode)
				otm = inode->GetObjectTM(t);
			else
				otm.IdentityMatrix();
			GetGTessFunction();
			if (mSubDivideDisplacement && psGTessFunc) {
				// if we have a material that does displacement mapping and if we can do it
				Mesh *pMesh = new Mesh();
				needDelete = TRUE;
				(*psGTessFunc)((void *)&mesh, MAX_MESH, &otm, pMesh, NULL,
								&mDispApprox, &view, pMtl, FALSE, mSplitMesh);
				needDelete = TRUE;
				return pMesh;
			} else {
				Mesh *pMesh = new Mesh(mesh);
				needDelete = TRUE;

                BOOL hasUVs = pMesh->tvFace != NULL;
				pMesh->buildRenderNormals();

				// now displace the verts
				BitArray vertsSet;
				vertsSet.SetSize(pMesh->numVerts);

				for (int f = 0; f < pMesh->numFaces; f++) {
					Face *pFace = &pMesh->faces[f];
					TVFace *pTVFace = &pMesh->tvFace[f];
					int matid = pFace->getMatID();
					for (int v = 0; v < 3; v++) {
						int vidx = pFace->v[v];
						if (vertsSet[vidx])
							continue; // displace only once
						Point3 norm = pMesh->getNormal(vidx);
						norm.Normalize();
						Point3& vert = pMesh->getVert(vidx);

						UVVert uvvert;
                        if (hasUVs)
                            uvvert = pMesh->getTVert(pTVFace->t[v]);
                        else {
                            uvvert.x = 0.0;
                            uvvert.y = 0.0;
                        }

						pMesh->buildBoundingBox();
						Box3 bbox = pMesh->getBoundingBox();
						float dispScale = Length(bbox.pmax - bbox.pmin)/10.0f;

						float disp = GetDisp(pMtl, pMesh, f, pFace->getMatID(), vert, uvvert.x, uvvert.y, otm) * dispScale;
						vert += (norm * disp);
						vertsSet.Set(vidx);
					}
				}
				return pMesh;
			}
		}
	}

	needDelete = FALSE;
	return &mesh;
}

BOOL
TriObject::CanDoDisplacementMapping()
{
	GetGTessFunction();
	if (psGTessFunc && !mDisableDisplacement)
		return TRUE;
	return FALSE;
}

void
TriObject::DisableDisplacementMapping(BOOL disable)
{
	mDisableDisplacement = disable?true:false;
}


static void
GetCfgFilename( TCHAR *filename ) {
	_tcscpy(filename, GetCOREInterface()->GetDir(APP_MAXROOT_DIR));
	int len = _tcslen(filename);
	if (len) {
	   if (_tcscmp(&filename[len-1],_T("\\")))
		 _tcscat(filename,_T("\\"));

}
	_tcscat(filename, _T("3dsmax.ini"));
}

// The Defaults
TessType sTypes[3] = {TESS_LDA, TESS_LDA, TESS_LDA};
TessSubdivStyle sSubDivs[3] = {SUBDIV_TREE, SUBDIV_TREE, SUBDIV_TREE};
BOOL sViewDeps[3] = {FALSE, FALSE, FALSE};
int sUSteps[3] = {2, 2, 2};
int sVSteps[3] = {2, 2, 2};
float sAngles[3] = {10.0f, 4.0f, 2.0f};
float sDists[3] = {20.0f, 10.0f, 5.0f};
float sEdges[3] = {20.0f, 10.0f, 5.0f};
int sMinSubs[3] = {0, 0, 0};
int sMaxSubs[3] = {2, 3, 4};
int sMaxTris[3] = {20000, 20000, 20000};


static TCHAR* sPresetNames[] = {
    _T("TessPreset1"),
    _T("TessPreset2"),
    _T("TessPreset3"),
};

#include "..\..\cfgmgr\cfgmgr.h"

void
TriObject::SetDisplacmentApproxToPreset(int preset)
{
    TCHAR sectionName[64];
    _stprintf(sectionName, _T("%s%s"), _T("MeshDisp"), sPresetNames[preset]);

    // If no entry in .ini file, then use defaults
    if (!getCfgMgr().sectionExists(sectionName)) {
		mDispApprox.type = sTypes[preset];
		mDispApprox.subdiv = sSubDivs[preset];
		mDispApprox.view = sViewDeps[preset];
		mDispApprox.u = sUSteps[preset];
		mDispApprox.v = sVSteps[preset];
		mDispApprox.ang = sAngles[preset];
		mDispApprox.dist = sDists[preset];
		mDispApprox.edge = sEdges[preset];
		mDispApprox.minSub = sMinSubs[preset];
		mDispApprox.maxSub = sMaxSubs[preset];
		mDispApprox.maxTris = sMaxTris[preset];
        NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		return;
	}

    getCfgMgr().setSection(sectionName);

    assert(getCfgMgr().keyExists(_T("Type")));
    int t;
    getCfgMgr().getInt(_T("Type"), &t);
    mDispApprox.type = (TessType) t;
    
    assert(getCfgMgr().keyExists(_T("SubdivStyle")));
    int style;
    getCfgMgr().getInt(_T("SubdivStyle"), &style);
    mDispApprox.subdiv = (TessSubdivStyle) style;

    assert(getCfgMgr().keyExists(_T("ViewDep")));
    int viewdep;
    getCfgMgr().getInt(_T("ViewDep"), &viewdep);
    mDispApprox.view = (BOOL) viewdep;

    assert(getCfgMgr().keyExists(_T("USteps")));
    int usteps;
    getCfgMgr().getInt(_T("USteps"), &usteps);
    mDispApprox.u = usteps;

    assert(getCfgMgr().keyExists(_T("VSteps")));
    int vsteps;
    getCfgMgr().getInt(_T("VSteps"), &vsteps);
    mDispApprox.v = vsteps;

    assert(getCfgMgr().keyExists(_T("Angle")));
    float angle;
    getCfgMgr().getFloat(_T("Angle"), &angle);
    mDispApprox.ang = angle;

    assert(getCfgMgr().keyExists(_T("Dist")));
    float dist;
    getCfgMgr().getFloat(_T("Dist"), &dist);
    mDispApprox.dist = dist;

    assert(getCfgMgr().keyExists(_T("Edge")));
    float edge;
    getCfgMgr().getFloat(_T("Edge"), &edge);
    mDispApprox.edge = edge;

    assert(getCfgMgr().keyExists(_T("MinSub")));
    int minSub;
    getCfgMgr().getInt(_T("MinSub"), &minSub);
    mDispApprox.minSub = minSub;

    assert(getCfgMgr().keyExists(_T("MaxSub")));
    int maxSub;
    getCfgMgr().getInt(_T("MaxSub"), &maxSub);
    mDispApprox.maxSub = maxSub;

    assert(getCfgMgr().keyExists(_T("MaxTris")));
    int maxTris;
    getCfgMgr().getInt(_T("MaxTris"), &maxTris);
    mDispApprox.maxTris = maxTris;
    NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
}

void
SetDisplacmentPreset(int preset, TessApprox approx)
{
    TCHAR sectionName[64];
    _stprintf(sectionName, _T("%s%s"), _T("MeshDisp"), sPresetNames[preset]);

    getCfgMgr().setSection(sectionName);

    getCfgMgr().putInt(_T("Type"),        approx.type);
    getCfgMgr().putInt(_T("SubdivStyle"), approx.subdiv);
    getCfgMgr().putInt(_T("ViewDep"),     approx.view);
    getCfgMgr().putInt(_T("USteps"),      approx.u);
    getCfgMgr().putInt(_T("VSteps"),      approx.v);
    getCfgMgr().putFloat(_T("Angle"),     approx.ang);
    getCfgMgr().putFloat(_T("Dist"),      approx.dist);
    getCfgMgr().putFloat(_T("Edge"),      approx.edge);
    getCfgMgr().putInt(_T("MinSub"),      approx.minSub);
    getCfgMgr().putInt(_T("MaxSub"),      approx.maxSub);
    getCfgMgr().putInt(_T("MaxTris"),     approx.maxTris);
}

#define copyFlags(dest, source, mask) dest =  ((dest&(~mask))|(source&mask))

void TriObject::CopyValidity(TriObject *fromOb, ChannelMask channels) {
	if (channels&GEOM_CHANNEL) geomValid = fromOb->geomValid;
	if (channels&VERTCOLOR_CHANNEL) vcolorValid = fromOb->vcolorValid;
	if (channels&TOPO_CHANNEL) topoValid = fromOb->topoValid;
	if (channels&TEXMAP_CHANNEL) texmapValid = fromOb->texmapValid;
	if (channels&SELECT_CHANNEL) selectValid = fromOb->selectValid;
	if (channels&GFX_DATA_CHANNEL) gfxdataValid = fromOb->gfxdataValid;
	copyFlags(validBits, fromOb->validBits,channels);
	}
	 
Object *TriObject::MakeShallowCopy(ChannelMask channels) {
	TriObject* newob = CreateNewTriObject();
#ifdef TRIPIPE_DEBUG
	DebugPrint ("TriObject(%08x)::MakeShallowCopy (%08x): %08x\n", this, channels, newob);
#endif
	newob->mesh.ShallowCopy(&mesh,channels);
	newob->CopyValidity(this,channels);
	newob->mDispApprox = mDispApprox;
	newob->mSubDivideDisplacement = mSubDivideDisplacement;
	newob->mSplitMesh = mSplitMesh;
	newob->mDisableDisplacement = mDisableDisplacement;
	return newob;
	}

void TriObject::ShallowCopy(Object* fromOb, ChannelMask channels) {	
#ifdef TRIPIPE_DEBUG
	DebugPrint ("TriObject(%08x)::ShallowCopy (%08x, %08x)\n", this, fromOb, channels);
#endif
	if (fromOb->IsSubClassOf(triObjectClassID)) {
		TriObject *fob = (TriObject *)fromOb;
		mesh.ShallowCopy(&fob->mesh,channels);
		mDispApprox = fob->mDispApprox;
		mSubDivideDisplacement = fob->mSubDivideDisplacement;
		mSplitMesh = fob->mSplitMesh;
		mDisableDisplacement = fob->mDisableDisplacement;
		CopyValidity(fob,channels);
		}
	}

void TriObject::NewAndCopyChannels(ChannelMask channels) {
#ifdef TRIPIPE_DEBUG
	DebugPrint ("TriObject(%08x)::NewAndCopyChannels (%08x)\n", this, channels);
#endif
	if (channels)
		mesh.NewAndCopyChannels(channels);
	}

void TriObject::FreeChannels(ChannelMask chan) {
#ifdef TRIPIPE_DEBUG
	DebugPrint ("TriObject(%08x)::FreeChannels (%08x)\n", this, chan);
#endif
	mesh.FreeChannels(chan&(~GetChannelLocks()),0);
	}

DWORD TriObject::GetSubselState() {
	return ( (mesh.selLevel&MESH_VERTEX) |
	         (mesh.selLevel&MESH_FACE) |
		     (mesh.selLevel&MESH_EDGE) );
	}

void TriObject::SetSubSelState(DWORD s)
	{
	switch (s) {
		case 0:	mesh.selLevel = MESH_OBJECT; break;
		case 1: mesh.selLevel = MESH_VERTEX; break;
		case 2: mesh.selLevel = MESH_FACE; break;
		case 3: mesh.selLevel = MESH_EDGE; break;
		}
	}

BOOL TriObject::CheckObjectIntegrity()
	{
	for (int i=0; i<mesh.getNumFaces(); i++) {		
		for (int j=0; j<3; j++) {
			if (mesh.faces[i].v[j] >= (DWORD)mesh.getNumVerts()) {
				TSTR buf;
				buf.printf(GetResString(IDS_DB_TRIOBJ_DESC),
					i,j,mesh.faces[i].v[j],mesh.getNumVerts(), mesh.faces, mesh.getNumFaces());
				MessageBox(NULL,buf,GetResString(IDS_DB_INVALID_FACE),MB_ICONEXCLAMATION|MB_TASKMODAL|MB_OK);
				return FALSE;
				}
			}
		}
	
	if (mesh.tvFace) {
		for (int i=0; i<mesh.getNumFaces(); i++) {		
			for (int j=0; j<3; j++) {
				if (mesh.tvFace[i].t[j] >= (DWORD)mesh.numTVerts) {
					TSTR buf;
					buf.printf(GetResString(IDS_DB_TV_DESC), i,j,mesh.tvFace[i].t[j],mesh.numTVerts);
					MessageBox(NULL,buf,GetResString(IDS_DB_INVALID_TV_FACE),MB_ICONEXCLAMATION|MB_TASKMODAL|MB_OK);
					return FALSE;
					}
				}
			}
		}

	return TRUE;
	}

BOOL TriObject::HasUVW() {
	return mesh.tvFace?1:0;
}

BOOL TriObject::HasUVW (int mapChannel) {
	return mesh.mapSupport (mapChannel);
}


BOOL TriObject::IsPointSelected (int i) 
{ 
	BitArray sel = mesh.vertSel;
	return sel[i]?TRUE:FALSE;
}

float TriObject::PointSelection (int i) 
{
	// Get vertex selection weights, if present
	// otherwise, fall back to IsPointSelected
	// HarryD, april-2-99
	float *vssel = mesh.getVSelectionWeights ();
	if (vssel) return vssel[i];
	else return IsPointSelected(i)?1.0f:0.0f;
}

void TriObject::TopologyChanged() { mesh.InvalidateTopologyCache(); mesh.BuildStripsAndEdges(); }

void TriObject::Deform(Deformer *defProc,int useSel) {
	int nv = NumPoints();
	int i;
	if ( useSel ) {
		BitArray sel = mesh.VertexTempSel();
		float *vssel = mesh.getVSelectionWeights ();
#if TRI_MULTI_PROCESSING
		WaitForSingleObject(defMutex, INFINITE);
		defStuff.triobj = this;
		defStuff.defProc = defProc;
		defStuff.ct = nv / 2;
		defStuff.useSel = 1;
		defStuff.sel = sel;
		defStuff.vssel = vssel;
		SetEvent(defStartEvent);
		Sleep(0);
		if (vssel) {
			for (i=nv/2; i<nv; i++) {
				if(sel[i]) {
					SetPoint(i,defProc->Map(i,GetPoint(i)));
					continue;
				}
				if (vssel[i]==0) continue;
				Point3 & A = GetPoint(i);
				Point3 dir = defProc->Map(i,A) - A;
				SetPoint(i,A+vssel[i]*dir);
			}
		} else {
			for (i=nv/2; i<nv; i++) if(sel[i]) SetPoint(i,defProc->Map(i,GetPoint(i)));
		}
		WaitForSingleObject(defEndEvent, INFINITE);
		ReleaseMutex(defMutex);
#else
		if (vssel) {
			for (i=0; i<nv; i++) {
				if(sel[i]) {
					SetPoint(i,defProc->Map(i,GetPoint(i)));
					continue;
				}
				if (vssel[i]==0) continue;
				Point3 & A = GetPoint(i);
				Point3 dir = defProc->Map(i,A) - A;
				SetPoint(i,A+vssel[i]*dir);
			}
		} else {
			for (i=0; i<nv; i++) if (sel[i]) SetPoint(i,defProc->Map(i,GetPoint(i)));
		}
#endif
	} else {
#if TRI_MULTI_PROCESSING
		WaitForSingleObject(defMutex, INFINITE);
		defStuff.triobj = this;
		defStuff.defProc = defProc;
		defStuff.ct = nv / 2;
		defStuff.useSel = 0;
		SetEvent(defStartEvent);
		Sleep(0);
		for (i=nv/2; i<nv; i++) 
			SetPoint(i,defProc->Map(i,GetPoint(i)));
		WaitForSingleObject(defEndEvent, INFINITE);
		ReleaseMutex(defMutex);
#else
		for (i=0; i<nv; i++) 
			SetPoint(i,defProc->Map(i,GetPoint(i)));
#endif
	}
	PointsWereChanged();
} 

#define VALIDITY_CHUNK 	2301
#define VALIDITY_CHUNK2	2303
#define VALIDITY_CHUNK3	2304
#define MESH_CHUNK 2302
#define TESS_APPROX_CHUNK 2305
#define DO_SUBDIV_CHUNK 2306
#define DO_DISPMAP_CHUNK 2307
#define SPLITMESH_CHUNK 2308

IOResult TriObject::Save(ISave *isave) {
	ULONG nb;
	isave->BeginChunk(VALIDITY_CHUNK3);
	isave->Write(&geomValid,sizeof(Interval), &nb);
	isave->Write(&vcolorValid,sizeof(Interval), &nb);
	isave->Write(&topoValid,sizeof(Interval), &nb);
	isave->Write(&texmapValid,sizeof(Interval), &nb);
	isave->Write(&selectValid,sizeof(Interval), &nb);
	isave->Write(&validBits,sizeof(DWORD), &nb);
	isave->EndChunk();

	isave->BeginChunk(MESH_CHUNK);
	mesh.Save(isave);
	isave->EndChunk();

	isave->BeginChunk(TESS_APPROX_CHUNK);
	mDispApprox.Save(isave);
	isave->EndChunk();

	isave->BeginChunk(DO_SUBDIV_CHUNK);
	BOOL subdiv = mSubDivideDisplacement?TRUE:FALSE;
	isave->Write(&subdiv,sizeof(BOOL), &nb);
	isave->EndChunk();

	isave->BeginChunk(SPLITMESH_CHUNK);
	BOOL splitmesh = mSplitMesh?TRUE:FALSE;
	isave->Write(&splitmesh,sizeof(BOOL), &nb);
	isave->EndChunk();

	isave->BeginChunk(DO_DISPMAP_CHUNK);
	BOOL disDisp = mDisableDisplacement?TRUE:FALSE;
	isave->Write(&disDisp,sizeof(BOOL), &nb);
	isave->EndChunk();

	return IO_OK;
	}

IOResult  TriObject::Load(ILoad *iload) {
	ULONG nb;
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VALIDITY_CHUNK:
				res = iload->Read(&geomValid,sizeof(Interval), &nb);
				res = iload->Read(&topoValid,sizeof(Interval), &nb);
				res = iload->Read(&validBits,sizeof(DWORD), &nb);
				texmapValid = FOREVER;
				selectValid = FOREVER;
				vcolorValid = FOREVER;
				iload->SetObsolete();
				break;
			case VALIDITY_CHUNK2:
				res = iload->Read(&geomValid,sizeof(Interval), &nb);
				res = iload->Read(&topoValid,sizeof(Interval), &nb);
				res = iload->Read(&texmapValid,sizeof(Interval), &nb);
				res = iload->Read(&selectValid,sizeof(Interval), &nb);
				res = iload->Read(&validBits,sizeof(DWORD), &nb);				
				vcolorValid = FOREVER;
				break;
			case VALIDITY_CHUNK3:
				res = iload->Read(&geomValid,sizeof(Interval), &nb);
				res = iload->Read(&vcolorValid,sizeof(Interval), &nb);
				res = iload->Read(&topoValid,sizeof(Interval), &nb);
				res = iload->Read(&texmapValid,sizeof(Interval), &nb);
				res = iload->Read(&selectValid,sizeof(Interval), &nb);
				res = iload->Read(&validBits,sizeof(DWORD), &nb);				
				break;
			case MESH_CHUNK:
				res = mesh.Load(iload);
				break;
			case TESS_APPROX_CHUNK:
				res = mDispApprox.Load(iload);
				break;
			case DO_SUBDIV_CHUNK: {
				BOOL subdiv;
				res = iload->Read(&subdiv, sizeof(BOOL), &nb);
				mSubDivideDisplacement = subdiv ? true:false;
				break; }
			case SPLITMESH_CHUNK: {
				BOOL splitmesh;
				res = iload->Read(&splitmesh, sizeof(BOOL), &nb);
				mSplitMesh = splitmesh ? true:false;
				break; }
			case DO_DISPMAP_CHUNK: {
				BOOL disDisp;
				res = iload->Read(&disDisp, sizeof(BOOL), &nb);				
				mDisableDisplacement = disDisp ? true:false;
				break; }
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	
	// RB 3-18-96:
	// this will strip out faces that either have indices
	// that are out of range or have two or more indices that
	// are equal.
	// Optionally we could put up a warning if either of these
	// two calls return TRUE.
	//	mesh.RemoveDegenerateFaces();	// Removed by SCA 1999.04.28: causes problems loading EMesh Teapots, for example.
	mesh.RemoveIllegalFaces();

	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();

	return IO_OK;
	}




void TriObject::RescaleWorldUnits(float f) {
	if (TestAFlag(A_WORK1))
		return;
	SetAFlag(A_WORK1);
	for (int i=0; i<mesh.numVerts; i++)
		mesh.verts[i] *= f;	
	mesh.buildBoundingBox();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

void* TriObject::GetInterface(ULONG id)
{
#ifdef DESIGN_VER
	typedef void* (*CREATEFUNCPTR)();
	switch(id)
	{
	case I_GEOMIMP:
		{
			HINSTANCE hDllInst = ::LoadLibrary("geomimp.dll");
			if(hDllInst)
			{
				CREATEFUNCPTR CreateInstance = (CREATEFUNCPTR)::GetProcAddress(hDllInst, "CreateMeshAdapter");
				assert(CreateInstance != NULL);
				if(CreateInstance != NULL)
				{
					IGeomImp* ip = 	(IGeomImp*)CreateInstance();
					assert(ip);
					ip->Init(&mesh);
					return ip;
				}
			}
		}
		break;
	default:
		break;
	}
#endif
	return GeomObject::GetInterface(id);
}

void TriObject::ReleaseInterface(ULONG id,void *i)
{
#ifdef DESIGN_VER
	switch(id)
	{
	case I_GEOMIMP:
		{
			//this interface was a tearoff
			delete i;
			return;
		}
		break;
	default:
		break;
	}
#endif
	GeomObject::ReleaseInterface(id, i);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Misc\soundobj.cpp ===
/**********************************************************************
 *<
	FILE:  soundobj.cpp

	DESCRIPTION:  Sound plug-in object base class

	CREATED BY:  Rolf Berteig

	HISTORY: created 2 July 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "core.h"
#include "object.h"
#include "undolib.h"
#include "control.h"
#include "Maxapi.h"
#include "decomp.h"
#include "coremain.h"
#include "soundobj.h"
#include <mmsystem.h>
#include <vfw.h>
#include "audio.h"
#include "sound.h"
#include "custcont.h"
#include "istdplug.h"
#include "notetrck.h"

#ifdef WIN95STUFF

// CORE.DLL instance handle in coremain.cpp
extern HINSTANCE hInstance;

#define TimeValToMS(t) ((t*1000)/TIME_TICKSPERSEC)
#define MSToTimeVal(ms) ((ms*TIME_TICKSPERSEC)/1000)


#define FILTER_RES	1200

class DefSoundObj;

class WaveAnimChild : public ReferenceTarget {
	friend class SoundObjRestore;
	public:
		DefSoundObj *snd;
		void Init(DefSoundObj *snd);

		// Animatable methods
		void DeleteThis() {}
		virtual SClass_ID SuperClassID() {return SClass_ID(SOUNDOBJ_CLASS_ID);}
		Class_ID ClassID() {return Class_ID(DEF_SOUNDOBJ_CLASS_ID,1);}
		void GetClassName(TSTR& s) {s=GetResString(IDS_RB_SOUNDOBJECT);}
		
		int TrackParamsType() {return TRACKPARAMS_WHOLE;}
		void EditTrackParams(
			TimeValue t,
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags);
		int PaintTrack(			
			ParamDimensionBase *dim,
			HDC hdc,
			Rect& rcTrack,
			Rect& rcPaint,
			float zoom,
			int scroll,
			DWORD flags );
		int GetTrackVSpace( int lineHeight ) {return 8;}
		int PaintFCurves(			
			ParamDimensionBase *dim,
			HDC hdc,
			Rect& rcGraph,
			Rect& rcPaint,
			float tzoom,
			int tscroll,
			float vzoom,
			int vscroll,
			DWORD flags );
		BOOL IsAnimated() {return TRUE;}

		// Reference methods
		RefResult AutoDelete() {return REF_SUCCEED;}
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message) {return REF_SUCCEED;}
	};

class MetronomeAnimChild : public ReferenceTarget {
	public:
		DefSoundObj *snd;		
		void Init(DefSoundObj *snd);
		
		// Animatable methods
		void DeleteThis() {}
		virtual SClass_ID SuperClassID() {return SClass_ID(SOUNDOBJ_CLASS_ID);}
		Class_ID ClassID() {return Class_ID(DEF_SOUNDOBJ_CLASS_ID,2);}
		void GetClassName(TSTR& s) {s=GetResString(IDS_RB_SOUNDOBJECT);}
		
		int TrackParamsType() {return TRACKPARAMS_WHOLE;}
		void EditTrackParams(
			TimeValue t,
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags);
		int PaintTrack(			
			ParamDimensionBase *dim,
			HDC hdc,
			Rect& rcTrack,
			Rect& rcPaint,
			float zoom,
			int scroll,
			DWORD flags );
		int GetTrackVSpace( int lineHeight ) {return 1;}
		BOOL IsAnimated() {return TRUE;}

		// Reference methods
		RefResult AutoDelete() {return REF_SUCCEED;}
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message) {return REF_SUCCEED;}
	};


// Isn't it ironic for a sound object to be def? :)
class DefSoundObj : 
		public SoundObj,
		public IWaveSound {

	friend static void CALLBACK PlayCallback(
		UINT idEvent,UINT reserved,DWORD user,DWORD reserved1,DWORD reserved2);
	friend static void CALLBACK BeepCallback(
		UINT idEvent,UINT reserved,DWORD user,DWORD reserved1,DWORD reserved2);
	friend static BOOL CALLBACK SoundParamsWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
	friend class SoundObjRestore;

	private:
		HWND hWndDum, hParams;
		BOOL playing, waveActive, metroActive;
		UINT playTimer,period,beepTimer,beepPeriod;
		DWORD calls, bpMinute, bpMeasure, beepCalls, beepEnd, beepStart, beepWrap;
		TimeValue t0, t1, st;
		PAVISTREAM pavi;
		TSTR sndFile;
		FilteredWave *wave;
		WaveAnimChild waveAnim;
		MetronomeAnimChild metroAnim;
		Interval range;
		IObjParam *ip;

		void SetupDummyWindow();

	public:
		DefSoundObj();
		~DefSoundObj();

		BOOL Play(TimeValue tStart,TimeValue t0,TimeValue t1,TimeValue frameStep);
		void Scrub(TimeValue t0,TimeValue t1);
		TimeValue Stop();
		TimeValue GetTime();
		BOOL Playing() {return playing;}
		void SaveSound(PAVIFILE pfile,TimeValue t0,TimeValue t1);
		void SetMute(BOOL mute) {waveActive = !mute;}
		BOOL IsMute() {return !waveActive;}
		void Hold();
		void SetSoundFile(PAVISTREAM stream,TSTR &file);

		// From IWaveSound
		TSTR GetSoundFileName() {return sndFile;}
		BOOL SetSoundFileName(TSTR name);
		void SetStartTime(TimeValue t);
		TimeValue GetStartTime();
		TimeValue GetEndTime();

		// Animatable methods
		void* GetInterface(ULONG id);
		void DeleteThis() {delete this;}
		Class_ID ClassID() {return Class_ID(DEF_SOUNDOBJ_CLASS_ID,0);}
		void GetClassName(TSTR& s) {s=GetResString(IDS_RB_DEFSOUND);}
		int TrackParamsType() {return TRACKPARAMS_WHOLE;}
		void EditTrackParams(
			TimeValue t,
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags);
		int Paint(			
			HDC hdc,
			Rect& rcTrack,
			Rect& rcPaint,
			float zoom,
			int scroll,
			DWORD flags,
			int which );
		int GetTrackVSpace( int lineHeight ) {return 1;}
		Interval GetTimeRange(DWORD flags) {return range;}
		void MapKeys(TimeMap *map,DWORD flags);
		BOOL IsAnimated() {return TRUE;}

		int NumSubs()  {return wave?2:1; }
		Animatable* SubAnim(int i) {if (i==0) return &metroAnim; else return &waveAnim;}
		TSTR SubAnimName(int i) {if (i==0) return GetResString(IDS_RB_METRONOME); else return GetResString(IDS_RB_WAVEFORM);}		

		// Reference methods
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message) {return REF_SUCCEED;}
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};

void WaveAnimChild::Init(DefSoundObj *snd) {this->snd=snd;}
int WaveAnimChild::PaintTrack(ParamDimensionBase *dim,HDC hdc,Rect& rcTrack,Rect& rcPaint,float zoom,int scroll,DWORD flags )
	{return snd->Paint(hdc,rcTrack,rcPaint,zoom,scroll,flags,1);}
void WaveAnimChild::EditTrackParams(TimeValue t,ParamDimensionBase *dim,TCHAR *pname,HWND hParent,IObjParam *ip,DWORD flags)
	{snd->EditTrackParams(t,dim,pname,hParent,ip,flags);}

void MetronomeAnimChild::Init(DefSoundObj *snd) {this->snd=snd;}
int MetronomeAnimChild::PaintTrack(ParamDimensionBase *dim,HDC hdc,Rect& rcTrack,Rect& rcPaint,float zoom,int scroll,DWORD flags )
	{return snd->Paint(hdc,rcTrack,rcPaint,zoom,scroll,flags,0);}
void MetronomeAnimChild::EditTrackParams(TimeValue t,ParamDimensionBase *dim,TCHAR *pname,HWND hParent,IObjParam *ip,DWORD flags)
	{snd->EditTrackParams(t,dim,pname,hParent,ip,flags);}


class DefSoundObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1;}
	void *			Create(BOOL loading) {return new DefSoundObj;}
	const TCHAR *	ClassName() { return GetResString(IDS_RB_DEFSOUND); }
	SClass_ID		SuperClassID() { return SClass_ID(SOUNDOBJ_CLASS_ID); }
	Class_ID 		ClassID() { return Class_ID(DEF_SOUNDOBJ_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	};
static DefSoundObjClassDesc sndObjDesc;
ClassDesc *GetSoundObjDescriptor() {return &sndObjDesc;}

class SoundObjRestore : public RestoreObj {	
	public:
		DefSoundObj *snd;
		Interval undo,redo;
		SoundObjRestore(DefSoundObj *snd) {this->snd=snd;undo=snd->range;}   		
		void Restore(int isUndo) 
			{
			redo = snd->range;
			snd->range = undo;
			snd->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
			snd->waveAnim.NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
			}
		void Redo() 
			{
			snd->range = redo;
			snd->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
			snd->waveAnim.NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
			}
		void EndHold() {snd->ClearAFlag(A_HELD);}
	};


static void CALLBACK PlayCallback(
		UINT idEvent,UINT reserved,DWORD user,DWORD reserved1,DWORD reserved2)
	{
	DefSoundObj *dobj = (DefSoundObj*)user;
	// Should probably have a semaphore for this
	dobj->calls++;
	}


#define WM_BEEPME	WM_USER+10
#define BEAT1_FREQ	1000
#define BEAT1_DUR	10
#define BEATN_FREQ	2000
#define BEATN_DUR	10

static void CALLBACK BeepCallback(
		UINT idEvent,UINT reserved,DWORD user,DWORD reserved1,DWORD reserved2)
	{
	DefSoundObj *dobj = (DefSoundObj*)user;	
	TimeValue t = dobj->GetTime();
	
	DWORD c = ++dobj->beepCalls;
	if (dobj->beepCalls >= dobj->beepEnd) {
		dobj->beepCalls = dobj->beepStart-1;
		dobj->beepTimer = 
			timeSetEvent(dobj->beepWrap,1,BeepCallback,(DWORD)dobj,TIME_ONESHOT);
	} else {
		dobj->beepTimer = 
			timeSetEvent(dobj->beepPeriod,1,BeepCallback,(DWORD)dobj,TIME_ONESHOT);
		}	

	if( (c%dobj->bpMeasure)==0 ) {		
		Beep(BEAT1_FREQ,BEAT1_DUR);
	} else {
		Beep(BEATN_FREQ,BEATN_DUR);
		}	
	}

DefSoundObj::DefSoundObj() 
	{
	hWndDum     = NULL;
	hParams     = NULL;
	playing     = FALSE;
	bpMinute    = 60;
	bpMeasure   = 4;
	pavi        = NULL;	
	wave        = NULL;
	waveActive  = FALSE;
	metroActive = FALSE;
	playTimer   = 0;
	beepTimer   = 0;
	SetupDummyWindow();
	waveAnim.Init(this);
	metroAnim.Init(this);
	range.SetEmpty();
	t1 = t0 = 0;
	ip = NULL;

	hWndDum = CreateWindow(
		_T("SOUNDDUMMYWINDOW"), NULL,
		WS_POPUP,
		0,0,0,0, 
		NULL,
		NULL,
		hInstance,
		NULL );
	}

DefSoundObj::~DefSoundObj()
	{
	if (Playing()) Stop();
	if (pavi) {
		AVIStreamRelease(pavi);
		pavi = NULL;
		}
	if (wave) delete wave;
	if (hWndDum) DestroyWindow(hWndDum);	
	if (hParams) DestroyWindow(hParams);
	}

BOOL DefSoundObj::Play(TimeValue tStart,TimeValue t0,TimeValue t1,TimeValue frameStep)
	{
	if (hParams) {
		TSTR buf1 = GetResString(IDS_RB_CANTPLAYSOUND);
		TSTR buf2 = GetResString(IDS_RB_SOUND);
		MessageBox(NULL,buf1,buf2,MB_OK|MB_ICONSTOP|MB_TASKMODAL);
		return FALSE;
		}		
	LONG mst  = TimeValToMS(tStart);
	LONG mt0  = TimeValToMS(t0);
	LONG mt1  = TimeValToMS(t1);		

	calls     = 0;
	this->t0  = t0;
	this->t1  = t1;
	st        = tStart;
	period    = (1000*frameStep)/(TIME_TICKSPERSEC*4);	
	if (!period) period = 1; 	
	
	timeBeginPeriod(period);
	
	if (pavi && waveActive) {
		LONG shift = TimeValToMS(range.Start());
		aviaudioPlay(hWndDum,pavi,mst-shift,mt0-shift,mt1-shift,FALSE,TRUE);
		}

	if (metroActive) {			
		beepPeriod = 60000 / bpMinute;		
		beepCalls  = mst/beepPeriod;
		beepEnd    = mt1/beepPeriod;
		beepStart  = mt0/beepPeriod;
		int mod    = (mt0%beepPeriod);
		beepWrap   = (mod?(beepPeriod - mod):0) + (mt1%beepPeriod);
		if (beepWrap==0) beepWrap = beepPeriod;
		LONG d     = beepPeriod - (mst%beepPeriod);
		beepTimer  = timeSetEvent(d,1,BeepCallback,(DWORD)this,TIME_ONESHOT);
		}

	playTimer = timeSetEvent(period,1,PlayCallback,(DWORD)this,TIME_PERIODIC);		
	playing = TRUE;

	return TRUE;
	}

void DefSoundObj::Scrub(TimeValue t0,TimeValue t1)
	{
	if (pavi && waveActive) {
		LONG shift = TimeValToMS(range.Start());
		aviaudioPlay(hWndDum,pavi,
			TimeValToMS(t0)-shift,
			TimeValToMS(t0)-shift,
			TimeValToMS(t1)-shift,FALSE,FALSE);
		}
	}

TimeValue DefSoundObj::Stop()
	{
	if (pavi && waveActive) {
		aviaudioStop();		
		}

	if (metroActive) {
		if (beepTimer) {
			timeKillEvent(beepTimer);
			beepTimer = 0;
			}		
		}

	timeKillEvent(playTimer);
	timeEndPeriod(period);
	playTimer = 0;
	playing   = FALSE;
	return GetTime();
	}

void DefSoundObj::SaveSound(PAVIFILE pfile,TimeValue t0,TimeValue t1)
	{
	AVISTREAMINFO sInfo;
	PAVISTREAM stream;
	HRESULT	hr;
	LPVOID	lpFormat;
	LONG	cbFormat;
	void *lpBuffer;
	LONG start, end, read;
	LONG plBytes, plSamples, sampPerSec;
	LONG sTotal, sSaved;
	LONG slBegin, slCurrent, slEnd, slWaveBegin, slWaveEnd;

	if (!pavi) return;
	if (!waveActive) return;

	// Adjust for time shift.
	t0 -= range.Start();
	t1 -= range.Start();

	AVIStreamInfo(pavi,&sInfo,sizeof(sInfo));
	hr = AVIFileCreateStream(pfile,&stream,&sInfo);
    if (hr != AVIERR_OK) return;		
	
	AVIStreamFormatSize(pavi,0,&cbFormat);
    lpFormat = GlobalAllocPtr(GHND,cbFormat);
    if (!lpFormat) {
		AVIStreamRelease(stream);
		return;
		}
    AVIStreamReadFormat(pavi,0,lpFormat,&cbFormat);
	AVIStreamSetFormat(stream,0,lpFormat,cbFormat);
	sampPerSec = ((LPWAVEFORMAT)lpFormat)->nSamplesPerSec;
	GlobalFreePtr(lpFormat);

	#define BUFFER_SIZE	1024

	if (!(lpBuffer = malloc(BUFFER_SIZE))) {
		AVIStreamRelease(stream);
		return;
		}
	
	LONG aviStart = AVIStreamStartTime(pavi);
    LONG aviEnd   = AVIStreamEndTime(pavi);
	LONG aviLen   = aviEnd-aviStart;
	start = TimeValToMS(t0);
	end   = TimeValToMS(t1);
	
	if (start < aviStart) {
		LONG d = (aviStart-start)/aviLen + 1;
		start += d * aviLen;
		end   += d * aviLen;		
		}
	if (start > aviEnd) {
		LONG d = (start-aviEnd)/aviLen + 1;
		start -= d * aviLen;
		end   -= d * aviLen;		
		}
	
	sTotal = ((end-start)*sampPerSec)/1000;
	// I kluged this in because there are wav files with dwSampleSize set to 1024
	// instead of some reasonable value like 2 or 4.  Heuristically, dividing by
	// this number seems to get us what we need.
	// It is safe to say that I don't know what is really going on - DB 2/17/96
	if(sInfo.dwSampleSize > 16)
		sTotal /= sInfo.dwSampleSize;
	sSaved = 0;

	slBegin     = AVIStreamTimeToSample(pavi,start%aviLen);
	slCurrent   = slBegin;
	slEnd       = AVIStreamTimeToSample(pavi,end%aviLen);
	slWaveBegin = AVIStreamStart(pavi);
	slWaveEnd   = AVIStreamEnd(pavi);
	
	while (sSaved < sTotal) {
		
		if (slCurrent >= slWaveEnd) {
	    	slCurrent = slWaveBegin;			
			}

		read = slWaveEnd - slCurrent;

		if (read + sSaved > sTotal) {
			read = sTotal - sSaved;
			}

		if (read > BUFFER_SIZE / (int)sInfo.dwSampleSize) {
			read = BUFFER_SIZE / (int)sInfo.dwSampleSize;
			}

		AVIStreamRead(pavi,slCurrent,read,lpBuffer,BUFFER_SIZE,&plBytes,&plSamples);
		AVIStreamWrite(stream,sSaved,read,lpBuffer,BUFFER_SIZE,AVIIF_KEYFRAME,&plSamples,&plBytes);
		
		slCurrent += read;
		sSaved += read;
		}

	free(lpBuffer);
	AVIStreamRelease(stream);
	}


TimeValue DefSoundObj::GetTime()
	{
	int c = calls;
	TimeValue len = (c*period*TIME_TICKSPERSEC)/1000;
	TimeValue t = st + len;
	if (t > t1 && t1!=t0) {
		return (t-t0)%(t1-t0) + t0;
	} else {
		return t;
		}	
	}

void DefSoundObj::Hold()
	{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		theHold.Put(new SoundObjRestore(this));
		SetAFlag(A_HELD);
		}
	}

void DefSoundObj::MapKeys(TimeMap *map,DWORD flags)
	{
	if (wave && !playing) {
		Hold();
		TimeValue st = map->map(range.Start());
		range.Set(st,range.End() + st-range.Start());
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		waveAnim.NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		}
	}

void DefSoundObj::SetStartTime(TimeValue t)
	{	
	if (Playing()) Stop();
	Hold();
	range.Set(t,t + range.End()-range.Start());	
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	waveAnim.NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

TimeValue DefSoundObj::GetStartTime()
	{
	return range.Start();
	}

TimeValue DefSoundObj::GetEndTime()
	{
	return range.End();
	}


#define WAVE_FCURVE_HEIGHT	4

int WaveAnimChild::PaintFCurves(			
			ParamDimensionBase *dim,
			HDC hdc,
			Rect& rcGraph,
			Rect& rcPaint,
			float tzoom,
			int tscroll,
			float vzoom,
			int vscroll,
			DWORD flags )
	{
	int org = (rcGraph.top+rcGraph.bottom)/2; //ValueToScreen(0.0f,rcPaint.h()-1,vzoom,vscroll);
	Rect rp = rcPaint;
	Rect rg = rcGraph;

	rg.top    = org - rcGraph.h()/WAVE_FCURVE_HEIGHT;
	rg.bottom = org + rcGraph.h()/WAVE_FCURVE_HEIGHT;
	rp.top    = rg.top;
	rp.bottom = rg.bottom;
	
	snd->Paint(hdc,rg,rp,tzoom,tscroll,flags,1);
	return 0;
	}


int DefSoundObj::Paint(			
		HDC hdc,
		Rect& rcTrack,
		Rect& rcPaint,
		float zoom,
		int scroll,
		DWORD flags,
		int which )
	{
	TimeValue t,tp,p = MSToTimeVal(60000/bpMinute);
	TimeValue tl = ScreenToTime(rcPaint.left,zoom,scroll);
	TimeValue tr = ScreenToTime(rcPaint.right,zoom,scroll) + p;
	
	if (which==0) {
		tl -= tl%p + p;		
		SelectObject(hdc,GetStockObject(BLACK_PEN));	
		SelectObject(hdc,GetStockObject(BLACK_BRUSH));	
		for (t=tl; t<=tr; t+=p) {
			int x = TimeToScreen(t,zoom,scroll);
			if ((t/p)%bpMeasure==0) {			
				Rectangle(hdc,x-3,rcTrack.top+3,x+4,rcTrack.top+7);			
				}		
			Rectangle(hdc,x-1,rcTrack.top+1,x+2,rcTrack.top+9);				
			}
	} else {
		HPEN cpen = CreatePen(PS_SOLID,0,RGB(100,100,100));
		HPEN pen[2][2];
		pen[0][0] = CreatePen(PS_SOLID,0,RGB(0,0,100));
		pen[0][1] = CreatePen(PS_SOLID,0,RGB(0,0,200));
		pen[1][0] = CreatePen(PS_SOLID,0,RGB(100,0,0));
		pen[1][1] = CreatePen(PS_SOLID,0,RGB(200,0,0));

		for (int i=0; i<wave->Channels(); i++) {
			int xl = rcPaint.left;
			int xr = rcPaint.right;
			DWORD val;
			int y, dy, max = wave->Max(i);
			if (max==0) max=1;

			dy = (rcTrack.bottom - rcTrack.top)/
				 (wave->Channels()*2);
			y  = rcTrack.top + dy * (i*2+1);			

			SelectObject(hdc,cpen);
			MoveToEx(hdc,xl,y,NULL);
			LineTo(hdc,xr+1,y);			

			SelectObject(hdc,pen[i]);

			tp = ScreenToTime(xl-1,zoom,scroll) ;
			for (; xl<=xr; xl++) {
				t   = ScreenToTime(xl,zoom,scroll) - range.Start();
				val	= wave->Sample(tp,t,i);
				tp  = t;
				if (t>=wave->Start()&&t<=wave->End()) {
					SelectObject(hdc,pen[i][1]);
				} else {
					SelectObject(hdc,pen[i][0]);
					}
				MoveToEx(hdc, xl, y - (dy*val)/max, NULL);
				LineTo(hdc, xl, y + (dy*val)/max);
				}
			}

		SelectObject(hdc,GetStockObject(BLACK_PEN));
		DeleteObject(cpen);
		DeleteObject(pen[0][0]);
		DeleteObject(pen[1][0]);
		DeleteObject(pen[0][1]);
		DeleteObject(pen[1][1]);
		}

	return TRACK_DONE;
	}


#define BPMIMUTE_CHUNK		0x05000
#define BPMEASURE_CHUNK		0x05001
#define SOUNDFILE_CHUNK		0x05002
#define WAVEACTIVE_CHUNK	0x05003
#define METROACTIVE_CHUNK	0x05004
#define WAVESTART_CHUNK		0x05005
#define WAVENOTES_CHUNK		0x05007
#define METRONOTES_CHUNK	0x05008

IOResult DefSoundObj::Save(ISave *isave)
	{
	ULONG nb;
	TimeValue st = range.Start();

	isave->BeginChunk(BPMIMUTE_CHUNK);
	isave->Write(&bpMinute,sizeof(bpMinute),&nb);			
	isave->EndChunk();
	
	isave->BeginChunk(BPMEASURE_CHUNK);
	isave->Write(&bpMeasure,sizeof(bpMeasure),&nb);			
	isave->EndChunk();

	isave->BeginChunk(WAVEACTIVE_CHUNK);
	isave->Write(&waveActive,sizeof(waveActive),&nb);			
	isave->EndChunk();

	isave->BeginChunk(METROACTIVE_CHUNK);
	isave->Write(&metroActive,sizeof(metroActive),&nb);			
	isave->EndChunk();
	 
	isave->BeginChunk(SOUNDFILE_CHUNK);
	isave->WriteWString((TCHAR*)sndFile);
	isave->EndChunk();
	
	// NOTE: I want this to be loaded after the sound file chunk.
	isave->BeginChunk(WAVESTART_CHUNK);
	isave->Write(&st,sizeof(st),&nb);			
	isave->EndChunk();
	
	for (int i=0; i<waveAnim.NumNoteTracks(); i++) {
		isave->BeginChunk(WAVENOTES_CHUNK);
		NoteTrack *nt = waveAnim.GetNoteTrack(i);
		nt->Save(isave);
		isave->EndChunk();
		}
	for (    i=0; i<metroAnim.NumNoteTracks(); i++) {
		isave->BeginChunk(METRONOTES_CHUNK);
		NoteTrack *nt = waveAnim.GetNoteTrack(i);
		nt->Save(isave);
		isave->EndChunk();
		}

	return IO_OK;
	}

IOResult DefSoundObj::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res;

	if (Playing()) Stop();
	if (pavi) {
		AVIStreamRelease(pavi);
		pavi = NULL;
		}
	if (wave) delete wave;
	wave = NULL;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case WAVENOTES_CHUNK: {
				NoteTrack *nt = NewDefaultNoteTrack();
				nt->Load(iload);
				waveAnim.AddNoteTrack(nt);
				break;
				}

			case METRONOTES_CHUNK: {
				NoteTrack *nt = NewDefaultNoteTrack();
				nt->Load(iload);
				metroAnim.AddNoteTrack(nt);
				break;
				}

			case BPMIMUTE_CHUNK:
				res=iload->Read(&bpMinute,sizeof(bpMinute),&nb);
				break;

			case BPMEASURE_CHUNK:
				res=iload->Read(&bpMeasure,sizeof(bpMeasure),&nb);
				break;

			case WAVEACTIVE_CHUNK:
				res=iload->Read(&waveActive,sizeof(waveActive),&nb);
				break;

			case METROACTIVE_CHUNK:
				res=iload->Read(&metroActive,sizeof(metroActive),&nb);
				break;

			case SOUNDFILE_CHUNK: {
				wchar_t *buf = NULL;
				res=iload->ReadWStringChunk(&buf);
				sndFile = buf;				
				
				PAVISTREAM stream = GetAudioStream(sndFile,iload->GetDir(APP_SOUND_DIR));
				if (stream) {
					BOOL lineChange = FALSE;					
					pavi    = stream;					
					wave = new FilteredWave(stream,FILTER_RES);
					range.Set(wave->Start(),wave->End());
					NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					NotifyDependents(FOREVER,PART_ALL,REFMSG_OBREF_CHANGE,TREE_VIEW_CLASS_ID);
				} else {
					if (sndFile.Length()) {
						TSTR buf1 = GetResString(IDS_RB_CANTOPENSOUND);
						TSTR buf2 = GetResString(IDS_RB_SOUND);
						GetCOREInterface()->Log()->LogEntry(SYSLOG_WARN,TRUE,buf2,buf1);
						}
					sndFile = (TCHAR*)NULL;	
					}
				
				break;
				}

			case WAVESTART_CHUNK: {
				TimeValue st;
				res=iload->Read(&st,sizeof(st),&nb);
				// If the wave file couldn't be loaded then don't set the range.
				if (wave) {
					range.Set(st,range.End()+st-range.Start());
					}
				break;
				}
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	
	return IO_OK;
	}




void DefSoundObj::SetSoundFile(PAVISTREAM stream,TSTR &file)
	{	
	if (pavi) AVIStreamRelease(pavi);
	pavi    = stream;
	sndFile = file;
	if (wave) delete wave;	
	wave = new FilteredWave(stream,FILTER_RES);
	range.Set(wave->Start(),wave->End());
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_OBREF_CHANGE,TREE_VIEW_CLASS_ID);
	SetSaveRequiredFlag(TRUE);
	}

BOOL DefSoundObj::SetSoundFileName(TSTR name)
	{
	PAVISTREAM stream = 
		GetAudioStream(name,
		GetCOREInterface()->GetDir(APP_SOUND_DIR));
	if (stream) {
		waveActive = TRUE;
		SetSoundFile(stream,name);
		return TRUE;
	} else {
		return FALSE;
		}
	}

void* DefSoundObj::GetInterface(ULONG id)
	{
	if (id==I_WAVESOUND) return (IWaveSound*)this;
	else return SoundObj::GetInterface(id);
	}



static TSTR lastSoundDir;
static BOOL lastSoundDirInit = FALSE;

TSTR &GetLastSoundDir(IObjParam *ip)
	{
	if (!lastSoundDirInit) {
		lastSoundDirInit = TRUE;
		lastSoundDir     = ip->GetDir(APP_SOUND_DIR);
		}
	return lastSoundDir;
	}


static BOOL CALLBACK SoundParamsWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	static BOOL picked, removed;	
	static TSTR file;
	static DWORD bpMinute, bpMeasure;

	DefSoundObj *snd = (DefSoundObj*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG: {			
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			snd = (DefSoundObj*)lParam;
			
			snd->ip->RegisterDlgWnd(hWnd);

			picked  = FALSE;
			removed = FALSE;

			ISpinnerControl *spin; 
			
			spin = GetISpinner(GetDlgItem(hWnd,IDC_BPMINUTESPIN));
			spin->SetLimits(1,60000,FALSE);
			spin->SetScale(0.1f);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_BPMINUTE),EDITTYPE_INT);
			spin->SetValue((int)snd->bpMinute,FALSE);
			ReleaseISpinner(spin);
			bpMinute = snd->bpMinute;

			spin = GetISpinner(GetDlgItem(hWnd,IDC_BPMEASURESPIN));
			spin->SetLimits(2,10000,FALSE);
			spin->SetScale(0.1f);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_BPMEASURE),EDITTYPE_INT);
			spin->SetValue((int)snd->bpMeasure,FALSE);
			ReleaseISpinner(spin);
			bpMeasure = snd->bpMeasure;

			if (snd->sndFile.Length()) {
				SetWindowText(GetDlgItem(hWnd,IDC_SOUNDNAME),snd->sndFile);
				EnableWindow(GetDlgItem(hWnd,IDC_REMOVESOUND),TRUE);
				EnableWindow(GetDlgItem(hWnd,IDC_RELOADSOUND),TRUE);
			} else {
				SetWindowText(GetDlgItem(hWnd,IDC_SOUNDNAME),GetResString(IDS_RB_NONE));
				EnableWindow(GetDlgItem(hWnd,IDC_REMOVESOUND),FALSE);
				EnableWindow(GetDlgItem(hWnd,IDC_RELOADSOUND),FALSE);
				}
			
			if (snd->waveActive) {
				CheckDlgButton(hWnd,IDC_SOUNDACTIVE,TRUE);
			} else {
				CheckDlgButton(hWnd,IDC_SOUNDACTIVE,FALSE);
				}

			if (snd->metroActive) {
				CheckDlgButton(hWnd,IDC_METROACTIVE,TRUE);
			} else {
				CheckDlgButton(hWnd,IDC_METROACTIVE,FALSE);
				}

			break;
			}

		case CC_SPINNER_CHANGE: {
			ISpinnerControl *spin = (ISpinnerControl*)lParam; 
			switch (LOWORD(wParam)) {
				case IDC_BPMINUTESPIN:
					snd->bpMinute = (int)spin->GetIVal();
					SetSaveRequiredFlag(TRUE);
					break;

				case IDC_BPMEASURESPIN:
					snd->bpMeasure = (int)spin->GetIVal();
					SetSaveRequiredFlag(TRUE);
					break;
				}
			snd->metroAnim.NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CHOOSESOUND:
					if (GetSoundFileName(hWnd,file,GetLastSoundDir(snd->ip))) {
						picked  = TRUE;
						removed = FALSE;
						CheckDlgButton(hWnd,IDC_SOUNDACTIVE,TRUE);
						SetWindowText(GetDlgItem(hWnd,IDC_SOUNDNAME),file);
						EnableWindow(GetDlgItem(hWnd,IDC_REMOVESOUND),TRUE);
						}
					break;

				case IDC_REMOVESOUND:
					removed = TRUE;	 
					picked  = FALSE;
					file    = (TCHAR*)NULL;
					SetWindowText(GetDlgItem(hWnd,IDC_SOUNDNAME),GetResString(IDS_RB_NONE));
					EnableWindow(GetDlgItem(hWnd,IDC_REMOVESOUND),FALSE);
					break;
							
				case IDC_RELOADSOUND: {
					PAVISTREAM stream = 
						GetAudioStream(snd->sndFile,snd->ip->GetDir(APP_SOUND_DIR));
					if (stream) {
						snd->SetSoundFile(stream,file);
					} else {
						MessageBox(hWnd,
							GetResString(IDS_RB_CANTOPENSOUND),
							GetResString(IDS_RB_SOUND),
							MB_OK|MB_ICONSTOP|MB_TASKMODAL);
						}
					break;
					}

				case IDOK:
					if (picked) {
						PAVISTREAM stream = 
							GetAudioStream(file,snd->ip->GetDir(APP_SOUND_DIR));
						if (stream) {
							snd->SetSoundFile(stream,file);
						} else {
							TSTR buf1 = GetResString(IDS_RB_CANTOPENSOUND);
							TSTR buf2 = GetResString(IDS_RB_SOUND);
							MessageBox(hWnd,buf1,buf2,MB_OK|MB_ICONSTOP|MB_TASKMODAL);
							}
					} else
					if (removed) {
						if (snd->pavi) AVIStreamRelease(snd->pavi);
						snd->pavi    = NULL;
						snd->sndFile = (TCHAR*)NULL;
						if (snd->wave) delete snd->wave;
						snd->wave = NULL;
						snd->range.SetEmpty();
						snd->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
						snd->NotifyDependents(FOREVER,PART_ALL,REFMSG_OBREF_CHANGE,TREE_VIEW_CLASS_ID);
						SetSaveRequiredFlag(TRUE);
						}

					snd->waveActive  = IsDlgButtonChecked(hWnd,IDC_SOUNDACTIVE);
					snd->metroActive = IsDlgButtonChecked(hWnd,IDC_METROACTIVE);
										
					DestroyWindow(hWnd);
					break;

				case IDCANCEL:
					snd->bpMinute  = bpMinute;
					snd->bpMeasure = bpMeasure;
					snd->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					snd->metroAnim.NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					DestroyWindow(hWnd);
					break;
				}
			break;

		case WM_DESTROY:
			snd->ip->UnRegisterDlgWnd(hWnd);
			snd->hParams = NULL;
			break;

		default:
			return 0;			
		}
	return 1;
	}

void DefSoundObj::EditTrackParams(
			TimeValue t,
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags)
	{
	static BOOL block = FALSE;
	if (block) return;

	this->ip = ip;

	if (Playing()) {
		block = TRUE;
		TSTR buf1 = GetResString(IDS_RB_CANTEDITSOUND);
		TSTR buf2 = GetResString(IDS_RB_SOUND);
		MessageBox(NULL,buf1,buf2,MB_OK|MB_ICONSTOP|MB_TASKMODAL);
		block = FALSE;
		return;
		}

	if (!hParams) {
		hParams = CreateDialogParam(
			getResMgr().getHInst(RES_ID_RB),
			MAKEINTRESOURCE(IDD_SOUNDPARAMS),
			hParent,
			SoundParamsWndProc,
			(LPARAM)this);
	} else {
		SetActiveWindow(hParams);
		}
	}


static LRESULT CALLBACK SoundDummyWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_BEEPME:
			Beep(wParam,lParam);
			break;

		case MM_WOM_OPEN:
		case MM_WOM_DONE:
		case MM_WOM_CLOSE:
			aviaudioMessage(hWnd,msg,wParam,lParam);
			break;

		default:
			return DefWindowProc(hWnd,msg,wParam,lParam);
		}
	return 0;
	}

void DefSoundObj::SetupDummyWindow()
	{
	static BOOL setup = FALSE;
	if (setup) return;
	setup = TRUE;	

	AVIFileInit();

	WNDCLASS  wc;

	wc.style         = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
	wc.hbrBackground = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
    wc.lpszMenuName  = NULL;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpfnWndProc   = SoundDummyWndProc;
    wc.lpszClassName = _T("SOUNDDUMMYWINDOW");

	RegisterClass(&wc);	
	}


#endif // WIN95STUFF

/*----------------------------------------------------------------------*/

SoundObj *NewDefaultSoundObj()
	{
	#ifdef WIN95STUFF
	return new DefSoundObj();
	#else
	return NULL;
	#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\ClassCfg.h ===
/**********************************************************************
 *<
	FILE: ClassCfg.h

	DESCRIPTION: local class & generic configuration file for MAXScript SDK plugins

	CREATED BY: Ravi Karra, 1998

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

// local root Value class for this plug-in

#define MS_LOCAL_ROOT_CLASS		AgniRootClassValue

// local Generic function class
#define MS_LOCAL_GENERIC_CLASS	AgniRootClassGeneric
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\DllMain.cpp ===
#include "MAXScrpt.h"
 
extern void MXSAgni_init();

HMODULE hInstance = NULL;

BOOL APIENTRY
DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
	static BOOL controlsInit = FALSE;
	switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			// Hang on to this DLL's instance handle.
			hInstance = hModule;
			if ( !controlsInit )
			{
				controlsInit = TRUE;				
				// Initialize Win95 controls
 				InitCommonControls();
				InitCustomControls(hInstance);
			}
			break;
	}
		
	return(TRUE);
}

__declspec( dllexport ) void
LibInit() { 
	// do any setup here
	MXSAgni_init();
}


__declspec( dllexport ) const TCHAR *
LibDescription() { return _T("Sample for MAXscript DLLs"); }

__declspec( dllexport ) ULONG
LibVersion() {  return VERSION_3DSMAX; }

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\ExtKeys.h ===
def_name(subNum)
def_name(point)
def_name(hollowBox)
def_name(plusSign)
def_name(asterisk)
def_name(xMarker)
def_name(bigBox)
def_name(circle)
def_name(triangle)
def_name(diamond)
def_name(smallHollowBox)
def_name(smallCircle)
def_name(smallTriangle)
def_name(smallDiamond)
def_name(rows)
def_name(numNodes)

def_name(laNode)
def_name(targNode)
def_name(suppressPrompts)
def_name(lower)
def_name(upper)
def_name(preScene)
def_name(backFace)


def_name(anim)
def_name(client)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\ExtFuncs.h ===
// exposing a series of functions
	def_visible_primitive( get_MAX_version,			"maxVersion");
	
	def_visible_primitive( is_group_head,			"isGroupHead");
	def_visible_primitive( is_group_member,			"isGroupMember");
	def_visible_primitive( is_open_group_member,	"isOpenGroupMember");
	def_visible_primitive( is_open_group_head,		"isOpenGroupHead");
	def_visible_primitive( set_group_member,		"setGroupMember");
	def_visible_primitive( set_group_head,			"setGroupHead");
	def_visible_primitive( set_group_head_open,		"setGroupHeadOpen");
	def_visible_primitive( set_group_member_open,	"setGroupMemberOpen");
	def_visible_primitive( h_marker,				"hMarker");
	def_visible_primitive( load_dlls_from_dir,		"loadDllsFromDir");
	def_visible_primitive( rescaleWorldUnits,		"rescaleWorldUnits");
	def_visible_primitive( get_INI_setting,			"getINISetting");
	def_visible_primitive( set_INI_setting,			"setINISetting");
	def_visible_primitive( get_file_version,		"getFileVersion");
	
	def_visible_primitive( getWinSizeX,				"getWinSizeX");
	def_visible_primitive( getWinSizeY,				"getWinSizeY");
	def_visible_primitive( get_viewport_dib,		"getViewportDib");
	def_visible_primitive( get_phy_context_export,	"getPhyContextExport");
//mcr_func_def
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\bmatpro.h ===
use_generic      (get,			"get");
use_generic      (put,			"put");
def_local_generic(invert,		"Invert");	
def_local_generic(setTranspose,	"SetTranspose");
def_local_generic(clear,		"clear");
def_local_generic(setSize,		"SetSize");

//Should actually be mapped_generic
use_generic		 (identity,		"Identity");
use_generic		 (plus,			"+");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\ExtClass.h ===
/**********************************************************************
 *<
	FILE: ExtClass.h

	DESCRIPTION: All the extension classes in MXSAgni.dlx

	CREATED BY: Ravi Karra, 1998

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _H_EXT_CLASS
#define _H_EXT_CLASS

#include "Funcs.h"
#include "MNBigMat.h"
#include "PhyExp.h"
#include "notetrck.h"
#include "resource.h"

declare_local_generic_class

// base class for all classes declared in MxsAgni
local_visible_class (AgniRootClassValue)
class AgniRootClassValue : public Value
{
public:
						AgniRootClassValue() { }

	ValueMetaClass*		local_base_class() { return class_tag(AgniRootClassValue); }			
						classof_methods (AgniRootClassValue, Value);
	void				collect() { delete this; }
	void				sprin1(CharStream* s) { s->puts(_T("AgniRootClassValue\n")); }
	void				gc_trace() { Value::gc_trace(); }
#	define				is_agniroot(p) ((p)->tag == class_tag(AgniRootClassValue))

#include "lclabsfn.h"
#	include "bmatpro.h"
#	include "phyblpro.h"
#	include "phymcpro.h"
//#	include "phyrgpro.h"
};

class BigMatrixValue;

// Instances of visible classes can only created and returned by other methods 
// or classes in MaxScript but cannot be created by the user. 
local_visible_class (BigMatrixRowArray)

class BigMatrixRowArray : public Value
{
public:
	BigMatrixValue	*bmv;
	int				row;
					BigMatrixRowArray(BigMatrixValue* bmv);
	void			collect() { delete this; }
	void			sprin1(CharStream* s);
	void			gc_trace();
	
#include "defimpfn.h"
	def_generic	(get,		"get");
	def_generic	(put,		"put");
};

// Instances of applyable classes can be created and returned by other methods or classes 
// in MaxScript and also by the user like bm = BigMatrix()

local_applyable_class (BigMatrixValue)

class BigMatrixValue : public AgniRootClassValue
{
public:
	BigMatrix			bm;
	BigMatrixRowArray	*rowArray;

						BigMatrixValue(int mm, int nn);
						BigMatrixValue(const BigMatrix& from);

//	ValueMetaClass*		local_base_class() { return class_tag(BigMatrixValue); }			
						classof_methods (BigMatrixValue, Value);
	
	void				collect() { delete this; }
	void				sprin1(CharStream* s);
	void				gc_trace();
#	define				is_bigmatrix(p) ((p)->tag == class_tag(BigMatrixValue))
	Value*				get_property(Value** arg_list, int count);
	Value*				set_property(Value** arg_list, int count);
	BigMatrix&			to_bigmatrix() { return bm; }

	/* operations */

#include "lclimpfn.h"
#	include "bmatpro.h"
	
};

local_visible_class (TrackViewPickValue)

class TrackViewPickValue : public Value
{

public:
	TrackViewPick		track;
	TSTR				name;
						TrackViewPickValue(TrackViewPick pick);
	void				collect() { delete this; }
	void				sprin1(CharStream* s);
	void				gc_trace();
#	define				is_trackviewpick(p) ((p)->tag == class_tag(TrackViewPick))
	Value*				get_property(Value** arg_list, int count);
	Value*				set_property(Value** arg_list, int count);	
};
#endif //_H_EXT_CLASS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\ExtClass.cpp ===
/**********************************************************************
 *<
	FILE: ExtClass.cpp

	DESCRIPTION: All the extension classes in MXSAgni.dlx

	CREATED BY: Ravi Karra, 1998

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "MAXScrpt.h"
#include "Numbers.h"
#include "MAXObj.h"
#include "Strings.h"
#include "LclClass.h"
#include "ExtClass.h"

#include "lclinsfn.h"
#	include "ExtKeys.h"

/* --------------------  local generics and names   --------------- */
#include "lclinsfn.h"
#	include "bmatpro.h"
#	include "phyblpro.h"
#	include "phymcpro.h"
//#	include "phyrgpro.h"

define_local_generic_class

local_visible_class_instance (AgniRootClassValue, _T("AgniRootClass"))

/* ------------------ BigMatrixValue indexing functions -------------------- */

Value*
BigMatrixValue::get_vf(Value** arg_list, int count)
{
	Value *arg, *result;
	int	  index;
	check_arg_count(get, 2, count + 1);
	arg = arg_list[0];
	if (!is_number(arg) || (index = arg->to_int()) < 1)
		throw TypeError ("array index must be +ve number, got: ", arg);

	if (index > bm.m)
		result = &undefined;
	else
	{
		rowArray->row = index - 1;
		result = rowArray;  
	}

	return result;
}

Value*
BigMatrixValue::put_vf(Value** arg_list, int count)
{
	throw RuntimeError (_T("Cannot directly set this value yet"));
	return arg_list[0];
}

local_visible_class_instance (BigMatrixRowArray, _T("BigMatrixRowArray"))

BigMatrixRowArray::BigMatrixRowArray(BigMatrixValue* bmv) 
{
	tag = class_tag(BigMatrixRowArray);
	this->bmv = bmv;	
}

void
BigMatrixRowArray::sprin1(CharStream* s)
{
	s->puts(_T("#("));
	for (int i = 0; i < bmv->bm.n; i++)
	{
		s->printf(_T("%.2f"), bmv->bm[row][i]);
		if (i < bmv->bm.n - 1)
			s->puts(_T(", "));
	}
	s->puts(_T(")"));	
}

Value*
BigMatrixRowArray::get_vf(Value** arg_list, int count)
{
	Value *arg, *result;
	int	  index;
	check_arg_count(get, 2, count + 1);
	arg = arg_list[0];
	if (!is_number(arg) || (index = arg->to_int()) < 1)
		throw TypeError ("array index must be +ve number, got: ", arg);

	if (index > bmv->bm.n)
		result = &undefined;
	else
		result = Float::intern(bmv->bm[row][index - 1]);  // array indexes are 1-based !!!

	return result;
}

Value*
BigMatrixRowArray::put_vf(Value** arg_list, int count)
{
	Value *arg;
	int	  index;

	check_arg_count(put, 3, count + 1);
	arg = arg_list[0];
	if (!is_number(arg) || (index = arg->to_int()) < 1)
		throw RuntimeError ("array index must be +ve number, got: ", arg);
	if (index > bmv->bm.n)
		throw RuntimeError ("array index must be < the number of columns: ", arg);
	bmv->bm[row][index - 1] = arg_list[1]->to_float();

	return arg_list[1];
}

void
BigMatrixRowArray::gc_trace()
{
	/* trace sub-objects & mark me */
	Value::gc_trace();
	if (bmv != NULL && bmv->is_not_marked())
		bmv->gc_trace();
}

/* ------------------- BigMatrixValue class instance -------------- */

// Instances of applyable classes can be created and returned by other methods or classes 
// in MaxScript and also by the user like bm = BigMatrix()

local_visible_class_instance (BigMatrixValue, _T("BigMatrix"))

Value*
BigMatrixValueClass::apply(Value** arg_list, int count)
{
	two_value_locals(a0, a1);
	Value* result;
	
	if (count == 2)
	{
		vl.a0 = arg_list[0]->eval();
		vl.a1 = arg_list[1]->eval();
		result = new BigMatrixValue (vl.a0->to_int(), vl.a1->to_int());
	}
	else
		check_arg_count(BigMatrix, 2, count);
	pop_value_locals();

	return result;
}

/* -------------------- BigMatrixValue methods ----------------------- */
BigMatrixValue::BigMatrixValue(const BigMatrix& from)
{
	tag = class_tag(BigMatrixValue);
	bm = from;
	rowArray = new BigMatrixRowArray(this);
}

BigMatrixValue::BigMatrixValue(int mm, int nn)
{
	tag = class_tag(BigMatrixValue);
	bm.SetSize(mm, nn);
	for (int m=0; m < mm; m++)
		for (int n=0; n < nn; n++)
			bm[m][n] = 0.0f;
	rowArray = new BigMatrixRowArray(this);
}

void
BigMatrixValue::gc_trace()
{
        /* trace sub-objects & mark me */
		Value::gc_trace();
		if (rowArray != NULL && rowArray->is_not_marked())
			rowArray->gc_trace();
}

void
BigMatrixValue::sprin1(CharStream* s)
{
	s->puts(_T("#BigMatrix(\n"));
	for (int m = 0; m < bm.m; m++)
	{
		s->puts(_T("\t["));
		for (int n = 0; n < bm.n; n++)
		{
			s->printf(_T("%.2f"), bm[m][n]);
			if (n < bm.n-1) 
				s->puts(",");
		}
		s->puts(_T("]"));
		if (m < bm.m-1) 
			s->puts(_T(","));
		s->puts(_T("\n"));
	}
	s->puts(_T(")\n"));
}

Value*
BigMatrixValue::get_property(Value** arg_list, int count)
{
	Value* prop = arg_list[0];
	if (prop == n_rows)
		return Integer::intern(bm.m);
	else if (prop == n_columns)
		return Integer::intern(bm.n);
	return Value::get_property(arg_list, count);
}

Value*
BigMatrixValue::set_property(Value** arg_list, int count)
{
	Value* prop = arg_list[1];	
	if (prop == n_rows)
		throw RuntimeError ("Can't directly set the row size of a BigMatrix");
	else if (prop == n_columns)
		throw RuntimeError ("Cannot directly set the column size of a BigMatrix");
	return Value::set_property(arg_list, count);
}

Value*
BigMatrixValue::plus_vf(Value** arg_list, int count)
{
	if (!is_bigmatrix(arg_list[0]))
		throw RuntimeError (_T("the right hand operand should be a BigMatrix"));
	BigMatrix& bmat = ((BigMatrixValue*)arg_list[0])->to_bigmatrix();
	if (bmat.m != bm.m || bmat.n != bm.n)
		throw RuntimeError (_T("The BigMatrix should have equal number of rows & columns"));
	
	one_value_local(result);
	vl.result = new BigMatrixValue(bm.m, bm.n);
		for (int m = 0; m < bm.m; m++)
			for (int n = 0; n < bm.n; n++)
				((BigMatrixValue*)vl.result)->bm[m][n] = bm[m][n] + bmat[m][n];
	return_value(vl.result);
}

#define Matrix3Value BigMatrixValue
#	include "lclimpfn.h"	
	def_mut_mat_fn( invert,			1, bm.Invert())
	def_mut_mat_fn( identity,		1, bm.Identity())
	def_mut_mat_fn( clear,			1, bm.Clear())
	def_mut_mat_fn( setTranspose,	2, bm.SetTranspose(((BigMatrixValue*)arg_list[0])->to_bigmatrix()))
	def_mut_mat_fn( setSize,		3, bm.SetSize(arg_list[0]->to_int(), arg_list[1]->to_int()))
#undef Matrix3Value

/* -------------------- TrackViewPickValue methods ----------------------- */
TrackViewPickValue::TrackViewPickValue(TrackViewPick pick)
{
	track = pick;
	name = track.client->SubAnimName(track.subNum);
}

void
TrackViewPickValue::sprin1(CharStream* s)
{	
	s->printf(_T("TrackViewPick:\"%s\""), name);
}

void
TrackViewPickValue::gc_trace()
{
	Value::gc_trace();
}

Value*
TrackViewPickValue::get_property(Value** arg_list, int count)
{
	Value* prop = arg_list[0];
	if (prop == n_name) return new String(name);
	else if (prop == n_anim) 
		return MAXClass::make_wrapper_for(track.anim);
	else if (prop == n_client) 
		return MAXClass::make_wrapper_for(track.client);
	else if (prop == n_subNum)
		return Integer::intern(track.subNum+1);
	return Value::get_property(arg_list, count);
}

Value*
TrackViewPickValue::set_property(Value** arg_list, int count)
{
	Value* val = arg_list[0];
	Value* prop = arg_list[1];
	if (prop == n_name || prop == n_anim || prop == n_client || prop == n_subNum)
		throw RuntimeError (GetString(IDS_READ_ONLY_PROPERTY), prop);	
	return Value::set_property(arg_list, count);
}

// Here's how you can define a struct primitive
// Can be called like trackView.pickTrackDlg() in MaxScript
def_struct_primitive( tvw_pickTrackDlg,		trackView,	"pickTrackDlg"); 

Value* 
tvw_pickTrackDlg_cf(Value** arg_list, int count)
{
	// trackView.pickTrackDlg [#mutliple]
	BOOL mult = FALSE;
	if (count == 1)
		if (arg_list[0] == n_multiple)
			mult = TRUE;
		else
			throw RuntimeError (_T("trackViewPickDlg: Unknown argument - "), arg_list[0]);
	if (mult)
	{
		Tab<TrackViewPick> picks;
		if(!MAXScript_interface->TrackViewPickMultiDlg(MAXScript_interface->GetMAXHWnd(), &picks))
			return &undefined;
		one_typed_value_local(Array* result); 
		vl.result = new Array(picks.Count());
		for(int n = 0; n < picks.Count(); n++)
			vl.result->append(new TrackViewPickValue(picks[n])); 
		return_value(vl.result);		
	}
	else
	{
		TrackViewPick pick;
		if(MAXScript_interface->TrackViewPickDlg(MAXScript_interface->GetMAXHWnd(), &pick))
			return new TrackViewPickValue(pick);
		return &undefined;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\phyblpro.h ===
def_local_generic(GetNode,			"GetNode");
def_local_generic(GetOffsetVector,	"GetOffsetVector");
def_local_generic(GetWeight,		"GetWeight");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\MXSAgni.h ===
/**********************************************************************
 *<
	FILE: MXSAgni.h

	DESCRIPTION: Main header file for MXSAgni.dlx

	CREATED BY: Ravi Karra, 1998

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#ifndef __MXSAGNI__H__
#define __MXSAGNI__H__


#include "MAXScrpt.h"
#include "Numbers.h"
#include "MAXclses.h"
#include "Streams.h"
#include "MSTime.h"
#include "MAXObj.h"
#include "Parser.h"

#define redraw_views()														\
	MAXScript_interface->RedrawViews(MAXScript_interface->GetTime())

#define get_valid_node(_node, _fn)											\
	MAXNode* nv = _node;													\
	if (is_node(nv))														\
	{																		\
		if(nv->ref_deleted)													\
			throw RuntimeError("Attempted to access to deleted object");	\
	}																		\
	else																	\
	{																		\
		throw RuntimeError (#_fn##" requires a node");						\
	}																		\
	INode* node = nv->to_node()

#endif //__MXSAGNI__H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\MXSAgni.cpp ===
/**********************************************************************
 *<
	FILE: MXSAgni.cpp

	DESCRIPTION: All the extension functions in MXSAgni.dlx

	CREATED BY: Ravi Karra, 1998

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#include "MXSAgni.h"
#include "LclClass.h"
#include "ExtClass.h"
#include "commdlg.h"
#include "Bmmlib.h"
#include "BitMaps.h"

#include "defextfn.h"
#	include "ExtKeys.h"

#include "definsfn.h"
#	include "ExtFuncs.h"

// calling functions for MXS functions declared in extfuncs.h
Value*
get_MAX_version_cf(Value** arg_list, int count)
{
	// maxVersion ()
	check_arg_count(MAXVersion, 0, count);
	return Float::intern(VERSION_3DSMAX / 100.0f);
}
 
Value*
get_root_node()
{
	return MAXNode::intern(MAXScript_interface->GetRootNode());
}

Value*
set_root_node(Value* val)
{
	throw RuntimeError ("rootNode is read-only");
    return &undefined;
}

Value*
set_rend_output_filename(Value* val)
{
	TCHAR *name = val->to_string();
	if (_tcscmp(name, _T("")) == 0)
		MAXScript_interface->SetRendSaveFile(FALSE);
	BitmapInfo& bi = MAXScript_interface->GetRendFileBI();
	bi.SetName(name);
	return val;
}

Value*
get_rend_output_filename()
{
	BitmapInfo& bi = MAXScript_interface->GetRendFileBI();
	return new String((TCHAR*)bi.Name());
}

// this is called by the dlx initializer, register the global vars here
void MXSAgni_init()
{
	CharStream* out = thread_local(current_stdout);
	out->puts(_T("--* MXSAgni.dlx 3.00 loaded *--\n"));

	// Definitions for globals and struct globals
	define_system_global("rootNode", get_root_node, set_root_node);
	define_system_global("rendOutputFilename", get_rend_output_filename, set_rend_output_filename);
#include "lclimpfn.h"
#	include "ExtKeys.h"
}

Value*
is_group_head_cf(Value** arg_list, int count)
{
	check_arg_count(isGroupHead, 1, count);	
	
	get_valid_node((MAXNode*)arg_list[0], isGroupHead);

	return node->IsGroupHead() ? &true_value : &false_value;
}

Value*
is_group_member_cf(Value** arg_list, int count)
{
	check_arg_count(isGroupMember, 1, count);
	
	get_valid_node((MAXNode*)arg_list[0], isGroupMember);

	return node->IsGroupMember() ? &true_value : &false_value;
}

Value*
is_open_group_member_cf(Value** arg_list, int count)
{
	check_arg_count(isOpenGroupMember, 1, count);
	
	get_valid_node((MAXNode*)arg_list[0], isOpenGroupMember);

	return node->IsOpenGroupMember() ? &true_value : &false_value;	
}

Value*
is_open_group_head_cf(Value** arg_list, int count)
{
	check_arg_count(isOpenGroupHead, 1, count);
	
	get_valid_node((MAXNode*)arg_list[0], isOpenGroupHead);

	return node->IsOpenGroupHead() ? &true_value : &false_value;	
}

Value*
set_group_member_cf(Value** arg_list, int count)
{
	check_arg_count(setGroupMember, 2, count);
	
	get_valid_node((MAXNode*)arg_list[0], setGroupMember);

	BOOL val = arg_list[1]->to_bool();
	
	node->SetGroupMember(val);
	return val ? &true_value : &false_value;
}

Value*
set_group_head_cf(Value** arg_list, int count)
{
	check_arg_count(setGroupHead, 2, count);
	
	get_valid_node((MAXNode*)arg_list[0], setGroupHead);

	BOOL val = arg_list[1]->to_bool();
	
	node->SetGroupMemberOpen(val);
	return val ? &true_value : &false_value;
}

Value*
set_group_head_open_cf(Value** arg_list, int count)
{
	check_arg_count(setGroupHeadOpen, 2, count);

	get_valid_node((MAXNode*)arg_list[0], setGroupHeadOpen);

	BOOL val = arg_list[1]->to_bool();
	
	node->SetGroupHeadOpen(val);
	return val ? &true_value : &false_value;
}

Value*
set_group_member_open_cf(Value** arg_list, int count)
{
	check_arg_count(setGroupMemberOpen, 2, count);

	get_valid_node((MAXNode*)arg_list[0], setGroupMemberOpen);

	BOOL val = arg_list[1]->to_bool();
	
	node->SetGroupMemberOpen(val);
	return val ? &true_value : &false_value;
}

Value*
rescaleWorldUnits_cf(Value** arg_list, int count)
{
	if (count < 1)
		throw ArgCountError (_T("rescaleWorldUnits "), 1, count);
	MAXScript_interface->RescaleWorldUnits(
		arg_list[0]->to_float(), 
		arg_list[count-1] == n_selOnly );
	redraw_views();
	return &ok;
}

Value*
h_marker_cf(Value** arg_list, int count)
{
	check_arg_count_with_keys(hMarker, 2, count);
	
	MarkerType	mt;
	int			i = 0;
	Point3		p = arg_list[0]->to_point3();
	IPoint3		d = IPoint3((int)p.x, (int)p.y, (int)p.z);
	Point3		col; 
	Value*		col_val = key_arg(color);
	
	if (col_val == &unsupplied) 
		col = Point3(255, 0, 0);
	else
		col = col_val->to_point3();
	
	while (i < count)
	{
		Value* mtype = arg_list[i];

		if(mtype == n_point)
			mt = POINT_MRKR; 
		else if(mtype == n_hollowBox)
			mt = HOLLOW_BOX_MRKR;
		else if(mtype == n_plusSign)
			mt = PLUS_SIGN_MRKR;
		else if(mtype == n_asterisk)
			mt = ASTERISK_MRKR;
		else if(mtype == n_xMarker)
			mt = X_MRKR;
		else if(mtype == n_bigBox)
			mt = BIG_BOX_MRKR;
		else if(mtype == n_circle)
			mt = CIRCLE_MRKR;
		else if(mtype == n_triangle)
			mt = TRIANGLE_MRKR;
		else if(mtype == n_diamond)
			mt = DIAMOND_MRKR;
		else if(mtype == n_smallHollowBox)
			mt = SM_HOLLOW_BOX_MRKR;
		else if(mtype == n_smallCircle)
			mt = SM_CIRCLE_MRKR;
		else if(mtype == n_smallTriangle)
			mt = SM_TRIANGLE_MRKR;
		else 
			mt = SM_DIAMOND_MRKR;
		i++;
	}

	ViewExp* vp = MAXScript_interface->GetActiveViewport();
	GraphicsWindow* gw = vp->getGW();

	gw->setColor(LINE_COLOR, col);
	gw->hMarker(&d, mt);

	gw->resetUpdateRect();
	gw->enlargeUpdateRect(NULL);
	gw->updateScreen();
	
	MAXScript_interface->ReleaseViewport(vp); 
	return &ok;
}


Value*
load_dlls_from_dir_cf(Value** arg_list, int count)
{
	check_arg_count(loadDllsFromDir, 2, count);
	return MAXScript_interface->GetDllDir().LoadDllsFromDir(
					arg_list[0]->to_string(), arg_list[1]->to_string()) ?
		&true_value : &false_value; 
}

Value*
get_INI_setting_cf(Value** arg_list, int count)
{
	TCHAR val[MAX_PATH];
	check_arg_count(getIniSetting, 3, count);
	GetPrivateProfileString(
		arg_list[1]->to_string(), 
		arg_list[2]->to_string(), 
		_T(""),	val, MAX_PATH, 
		arg_list[0]->to_string());
	return new String(val);	
}

Value*
set_INI_setting_cf(Value** arg_list, int count)
{
	check_arg_count(setINISetting, 4, count);
	WritePrivateProfileString(
		arg_list[1]->to_string(), 
		arg_list[2]->to_string(), 
		arg_list[3]->to_string(), 
		arg_list[0]->to_string());
	return &ok;
}

Value*
get_file_version_cf(Value** arg_list, int count)
{
	check_arg_count(getFileVersion, 1, count);
	
	DWORD	tmp; 
	LPTSTR	file = arg_list[0]->to_string();	
	DWORD	size = GetFileVersionInfoSize(file, &tmp);	
	if (!size) return &undefined;
	
	TCHAR*	data = (TCHAR*)malloc(size);	
	if(data && GetFileVersionInfo(file, NULL, size, data))
	{
		UINT len;
		VS_FIXEDFILEINFO *qbuf;
		TCHAR buf[256];
		if (VerQueryValue(data, "\\", (void**)&qbuf, &len))
		{
			DWORD fms = qbuf->dwFileVersionMS;
            DWORD fls = qbuf->dwFileVersionLS;
			DWORD pms = qbuf->dwProductVersionMS;
            DWORD pls = qbuf->dwProductVersionLS;
            	
			free(data);
			sprintf(buf, _T("%i,%i,%i,%i\t\t%i,%i,%i,%i"), 
				HIWORD(pms), LOWORD(pms), HIWORD(pls), LOWORD(pls),
				HIWORD(fms), LOWORD(fms), HIWORD(fls), LOWORD(fls));
			
			return new String(buf);
		}
		free(data);
	}
	return &undefined;
}

Value*
getWinSizeX_cf(Value** arg_list, int count)
{
	check_arg_count(getWinSizeX, 0, count);
	ViewExp *vpt = MAXScript_interface->GetActiveViewport();
	int sizeX = vpt->getGW()->getWinSizeX();
	MAXScript_interface->ReleaseViewport(vpt);
	return Integer::intern(sizeX);

}

Value*
getWinSizeY_cf(Value** arg_list, int count)
{
	check_arg_count(getWinSizeY, 0, count);
	ViewExp *vport = MAXScript_interface->GetActiveViewport();
	int sizeY = vport->getGW()->getWinSizeY();
	MAXScript_interface->ReleaseViewport(vport);
	return Integer::intern(sizeY);
}


Value*
get_viewport_dib_cf(Value** arg_list, int count)
{
	check_arg_count(getViewportDib, 0, count);
	ViewExp *vpt = MAXScript_interface->GetActiveViewport();
	GraphicsWindow *gw = vpt->getGW();
	BITMAPINFO *bmi = NULL;
	BITMAPINFOHEADER *bmih;
	BitmapInfo bi;
	Bitmap *bmp;
	int size;
	gw->getDIB(NULL, &size);
	bmi  = (BITMAPINFO *)malloc(size);
	bmih = (BITMAPINFOHEADER *)bmi;
	gw->getDIB(bmi, &size);
	bi.SetWidth((WORD)bmih->biWidth);
	bi.SetHeight((WORD)bmih->biHeight);
	bi.SetType(BMM_TRUE_32);
	bmp = TheManager->Create(&bi);
	bmp->OpenOutput(&bi);
	bmp->FromDib(bmi);
	bmp->Write(&bi);
	bmp->Close(&bi);
	
	MAXScript_interface->ReleaseViewport(vpt);

	return new MAXBitMap(bi, bmp);
}


//mcr_func_imp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\PhyExprt.cpp ===
/**********************************************************************
 *<
	FILE: PhyExprt.cpp

	DESCRIPTION: Physique Interface classes for MaxScript

	CREATED BY: Ravi Karra, 1998

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "MAXScrpt.h"
#include "Numbers.h"
#include "MAXObj.h"
#include "3DMath.h"
#include "LclClass.h"

#include "PhyExprt.h"

#include "defextfn.h"
#	include "ExtKeys.h"


Value*
get_phy_context_export_cf(Value** arg_list, int count)
{
	check_arg_count(GetPhyContextExport, 2, count);
	INode *node = arg_list[0]->to_node();
	Modifier *mod = arg_list[1]->to_modifier();

	if (mod->ClassID() != Class_ID(PHYSIQUE_CLASS_ID_A, PHYSIQUE_CLASS_ID_B))
		throw RuntimeError("modifier should be a Physique modifier, got:", mod->GetName());

	IPhysiqueExport *phyExport = (IPhysiqueExport *)mod->GetInterface(I_PHYINTERFACE);
	
	if (!phyExport) return &undefined;
	return new PhyContextExportValue(
		phyExport,
		(IPhyContextExport *)phyExport->GetContextInterface(node));
}


/* -------------------- PhyContextExportValue methods ----------------------- */

local_visible_class_instance (PhyContextExportValue, _T("PhyContextExport"))

PhyContextExportValue::PhyContextExportValue(IPhysiqueExport *phy, IPhyContextExport* mc)
{
	tag = class_tag(PhyContextExportValue);
	phyExport = phy;
	mcExport = mc;
}

void
PhyContextExportValue::gc_trace()
{
	phyExport->ReleaseContextInterface(mcExport);
	Value::gc_trace();
}

void
PhyContextExportValue::sprin1(CharStream* s)
{
	s->puts(_T("PhyContextExport"));
}

Value*
PhyContextExportValue::get_property(Value** arg_list, int count)
{
	Value* prop = arg_list[0];
	if (prop == n_numverts)
		return Integer::intern(mcExport->GetNumberVertices());
	return Value::get_property(arg_list, count);
}

Value*
PhyContextExportValue::set_property(Value** arg_list, int count)
{
	Value* prop = arg_list[0];
	if (prop == n_numverts)
		throw RuntimeError ("numVerts is a read only property");
	return Value::set_property(arg_list, count);
}

Value*
PhyContextExportValue::ConvertToRigid_vf(Value** arg_list, int count)
{
	check_arg_count(ConvertToRigid, 2, count + 1);
	mcExport->ConvertToRigid(arg_list[0]->to_bool());
	return arg_list[0];
}

Value*
PhyContextExportValue::AllowBlending_vf(Value** arg_list, int count)
{
	check_arg_count(AllowBlending, 2, count + 1);
	mcExport->AllowBlending(arg_list[0]->to_bool());
	return arg_list[0];
}

Value*
PhyContextExportValue::GetVertexInterface_vf(Value** arg_list, int count)
{
	check_arg_count(GetVertexInterface, 2, count + 1);
	
	Value *arg = arg_list[0];
	int	  index;
	
	if (!is_number(arg) || (index = arg->to_int()) < 1)
		throw RuntimeError ("vertex index must be +ve number, got: ", arg);
	
	if (index > mcExport->GetNumberVertices())
		throw RuntimeError ("vertex index cannot be > the number of vertices: ", arg);
	
	IPhyVertexExport* vi = mcExport->GetVertexInterface(index - 1 );
	
	if (!vi) return &undefined;

	if (vi->GetVertexType()&BLENDED_TYPE)
		return new PhyBlendedRigidVertexValue(mcExport, (IPhyBlendedRigidVertex*)vi);
	else
		return new PhyRigidVertexValue(mcExport, (IPhyRigidVertex*)vi);
}


/* -------------------- PhyRigidVertexValue methods ----------------------- */

local_visible_class_instance (PhyRigidVertexValue, _T("PhyRigidVertex"))

PhyRigidVertexValue::PhyRigidVertexValue(IPhyContextExport* mc, IPhyRigidVertex *vx)
{
	tag = class_tag(PhyRigidVertexValue);
	mcExport = mc;
	vtxExport = vx;
}

void
PhyRigidVertexValue::gc_trace()
{
	mcExport->ReleaseVertexInterface(vtxExport);
	Value::gc_trace();
}

void
PhyRigidVertexValue::sprin1(CharStream* s)
{
	s->puts(_T("PhyRigidVertex"));
}

Value*
PhyRigidVertexValue::GetNode_vf(Value** arg_list, int count)
{
	check_arg_count(GetNode, 1, count + 1);
	return new MAXNode(vtxExport->GetNode());
}

Value*
PhyRigidVertexValue::GetOffsetVector_vf(Value** arg_list, int count)
{
	check_arg_count(GetOffsetVector, 1, count + 1);
	return new Point3Value(vtxExport->GetOffsetVector());
}

/* -------------------- PhyBlendedRigidVertexValue methods ----------------------- */

local_visible_class_instance (PhyBlendedRigidVertexValue, _T("PhyBlendedRigidVertex"))

PhyBlendedRigidVertexValue::PhyBlendedRigidVertexValue(IPhyContextExport* mc, IPhyBlendedRigidVertex *vx)
{
	tag = class_tag(PhyBlendedRigidVertexValue);
	mcExport = mc;
	vtxExport = vx;
}

void
PhyBlendedRigidVertexValue::gc_trace()
{
	mcExport->ReleaseVertexInterface(vtxExport);
	Value::gc_trace();
}

void
PhyBlendedRigidVertexValue::sprin1(CharStream* s)
{
	s->puts(_T("PhyBlendedRigidVertex"));
}

Value*
PhyBlendedRigidVertexValue::get_property(Value** arg_list, int count)
{
	Value* prop = arg_list[0];
	if (prop == n_numNodes)
		return Integer::intern(vtxExport->GetNumberNodes());
	return Value::get_property(arg_list, count);
}

Value*
PhyBlendedRigidVertexValue::set_property(Value** arg_list, int count)
{
	Value* prop = arg_list[0];
	if (prop == n_numNodes)
		throw RuntimeError ("numNodes is a read only property");
	return Value::set_property(arg_list, count);
}

Value*
PhyBlendedRigidVertexValue::GetNode_vf(Value** arg_list, int count)
{
	check_arg_count(GetNode, 2, count + 1);
	Value *arg = arg_list[0];
	int	  index;
	
	if (!is_number(arg) || (index = arg->to_int()) < 1)
		throw RuntimeError ("node index must be +ve number, got: ", arg);
	
	if (index > vtxExport->GetNumberNodes())
		throw RuntimeError ("node index cannot be > the number of nodes: ", arg);

	return new MAXNode(vtxExport->GetNode(index-1));
}

Value*
PhyBlendedRigidVertexValue::GetOffsetVector_vf(Value** arg_list, int count)
{
	check_arg_count(GetOffsetVector, 2, count + 1);
	Value *arg = arg_list[0];
	int	  index;
	
	if (!is_number(arg) || (index = arg->to_int()) < 1)
		throw RuntimeError ("node index must be +ve number, got: ", arg);
	
	if (index > vtxExport->GetNumberNodes())
		throw RuntimeError ("node index cannot be > the number of nodes: ", arg);

	return new Point3Value(vtxExport->GetOffsetVector(index - 1));
}

Value*
PhyBlendedRigidVertexValue::GetWeight_vf(Value** arg_list, int count)
{
	check_arg_count(GetWeight, 2, count + 1);

	Value *arg = arg_list[0];
	int	  index;
	
	if (!is_number(arg) || (index = arg->to_int()) < 1)
		throw RuntimeError ("node index must be +ve number, got: ", arg);
	
	if (index > vtxExport->GetNumberNodes())
		throw RuntimeError ("node index cannot be > the number of nodes: ", arg);

	return new Point3Value(vtxExport->GetOffsetVector(index - 1));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\phymcpro.h ===
def_local_generic(ConvertToRigid,			"ConvertToRigid");
def_local_generic(AllowBlending,			"AllowBlending");
def_local_generic(GetVertexInterface,		"GetVertexInterface");
//def_local_generic(ReleaseVertexInterface,	"ReleaseVertexInterface");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\PhyExprt.h ===
/**********************************************************************
 *<
	FILE: PhyExprt.h

	DESCRIPTION: Physique Interface classes

	CREATED BY: Ravi Karra, 1998

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _H_PHY_EXPRT
#define _H_PHY_EXPRT

#include "ExtClass.h"
#include "PhyExp.h"

class PhyRigidVertexValue;
class PhyBlendingRigidVertexValue;

local_visible_class (PhyContextExportValue)

class PhyContextExportValue : public AgniRootClassValue
{
public:
	IPhysiqueExport		*phyExport;
	IPhyContextExport	*mcExport;

						PhyContextExportValue(IPhysiqueExport *phy, IPhyContextExport* mc);
						classof_methods (PhyContextExportValue, Value);

	void				collect() { delete this; }
	void				sprin1(CharStream* s);
	void				gc_trace();
	Value*				get_property(Value** arg_list, int count);
	Value*				set_property(Value** arg_list, int count);
	IPhyContextExport*	to_phycontextexport() { return mcExport; }

#include "lclimpfn.h"
#	include "phymcpro.h"

};

local_visible_class (PhyRigidVertexValue)

class PhyRigidVertexValue : public AgniRootClassValue
{
public:
	IPhyContextExport	*mcExport;
	IPhyRigidVertex		*vtxExport;

						PhyRigidVertexValue(IPhyContextExport *mc, IPhyRigidVertex *vx);
						classof_methods (PhyRigidVertexValue, Value);

	void				collect() { delete this; }
	void				sprin1(CharStream* s);
	void				gc_trace();
	IPhyRigidVertex*	to_phyrigidvertex() { return vtxExport; }

#include "lclimpfn.h"
#	include "phyrgpro.h"

};

local_visible_class (PhyBlendedRigidVertexValue )

class PhyBlendedRigidVertexValue : public AgniRootClassValue
{
public:
	IPhyContextExport		*mcExport;
	IPhyBlendedRigidVertex	*vtxExport;

							PhyBlendedRigidVertexValue(IPhyContextExport *mc, IPhyBlendedRigidVertex *vx);
							classof_methods (PhyBlendedRigidVertexValue, Value);

	void					collect() { delete this; }
	void					sprin1(CharStream* s);
	void					gc_trace();
	Value*					get_property(Value** arg_list, int count);
	Value*					set_property(Value** arg_list, int count);
	IPhyBlendedRigidVertex*	to_phyblendedrigidvertex() { return vtxExport; }

#include "lclimpfn.h"
#	include "phyblpro.h"

};
#endif //_H_PHY_EXPRT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\PHYEXP.H ===
/******************************************************************************
 *<
	FILE: PhyExp.h
				  
	DESCRIPTION:  Export Interface Functionality for Physique

	CREATED BY: John Chadwick with a lot of help from Jurie Horneman

	HISTORY: created July 10, 1997, modified for Version 2.0 March 5, 1998

 *>     Copyright (c) Unreal Pictures, Inc. 1997, 1998 All Rights Reserved.
 *******************************************************************************/

#ifndef PHYEXP_H
#define PHYEXP_H

#ifdef BLD_PHYSIQUE
#define PHYExport __declspec( dllexport )
#else
#define PHYExport __declspec( dllimport )
#endif

#include "max.h"
#include "modstack.h"

// this is the interface ID for a Physique Modifier	Interface
#define I_PHYINTERFACE	0x00100100 


// version control 
#define CURRENT_VERSION	1


// these are the Class ID defines for Physique Modifier: 
// Physique Class_ID = ClassID(PHYSIQUE_CLASS_ID_A, PHYSIQUE_CLASS_ID_B);
#define PHYSIQUE_CLASS_ID_A 0x00100
#define PHYSIQUE_CLASS_ID_B	0x00000


#define RIGID_TYPE		1
#define	DEFORMABLE_TYPE	2
#define	BLENDED_TYPE	4		

#define RIGID_NON_BLENDED_TYPE		(RIGID_TYPE)
#define	DEFORMABLE_NON_BLENDED_TYPE (DEFORMABLE_TYPE)
#define RIGID_BLENDED_TYPE			(RIGID_TYPE | BLENDED_TYPE)
#define DEFORMABLE_BLENDED_TYPE		(DEFORMABLE_TYPE | BLENDED_TYPE)


// Using the Physique Export Interface:
// 
//  1.	Find the Physique Modifier you which to export rigid vertex assignments from.
//		(there is a comment at the bottom of this file giving an example of this)
//
//	2.	Given Physique Modifier Modifier *phyMod get the Physique Export Interface:
//		IPhysiqueExport *phyExport = (IPhysqiueExport *)phyMod->GetInterface(I_PHYINTERFACE);		
//
//  3.	For a given Object's INode get this ModContext Interface from the Physique Export Interface:
//		IPhyContextExport *contextExport = (IPhyContextExport *)phyExport->GetContextInterface(INode* nodePtr);
//
//  4.  For each vertex of the Object get the Vertex Interface from the ModContext Export Interface:
//		IPhyVertexExport *vtxExport = (IPhyVertexExport *)contextExport->GetVertexInterface(int i);	
//		NOTE: only Rigid Vertices are currently supported: (see ConvertToRigid(TRUE) to make all vertices rigid)
//		IPhyRigidVertex *rigidExport = (IPhyRigidVertex *)contextExport->GetVertexInterface(int i);
//
//  5.	Get the INode for each Rigid Vertex Interface:
//		INode *nodePtr = rigidExport->GetNode();
//
//  6.	Get the Point3 Offset Vector in INode coordinates for each Rigid Vertex Interface:
//		Point3 offsetVector = rigidExport->GetOffsetVector();





// IPhyVertexExport: this is the base class for Vertex Export Interface
//					 NOTE: currently only RIGID_TYPE vertices are supported (IPhyRigidVertex)
//					 When a vertex is not assigned Rigid in Physique, the VertexInterface will be NULL
//					 Unless you call IPhyContextExport->ConvertToRigid(TRUE) (see IPhyContextExport below)
//					 With ConvertToRigid(TRUE) you will always get a IPhyRigidVertex 
//					 from IPhyContextExport->GetVertexInterface(i) 

class IPhyVertexExport
{
	public:

		PHYExport virtual ~IPhyVertexExport() {}

		// NOTE: currently only type RIGID_TYPE is supported
		PHYExport virtual int GetVertexType() = 0;
};



class IPhyRigidVertex : public IPhyVertexExport
{
	public:

		PHYExport virtual ~IPhyRigidVertex() {}

		// GetNode() will return the INode pointer of the link of the given VertexInterface
		PHYExport virtual INode *GetNode() = 0;

		// GetOffsetVector() will return the coordinates of the vertex 
		// in the local coordinates of associated INode pointer from GetNode
		// this is NOT THE SAME as the .vph file coordinates. (It is simpler)
		// the world coordinates of the vertex have been transformed by the Inverse	of the INode pointer.
		PHYExport virtual Point3 GetOffsetVector() = 0;
};

class IPhyBlendedRigidVertex : public IPhyVertexExport
{
	public:

		PHYExport virtual ~IPhyBlendedRigidVertex() {}

		// GetNumberNodes() returns the number of nodes assigned to the given VertexInterface
		PHYExport virtual int GetNumberNodes() = 0;

		// GetNode(i) will return the i'th INode pointer of the link of the given VertexInterface
		PHYExport virtual INode *GetNode(int i) = 0;

		// GetOffsetVector(i) will return the coordinates of the vertex 
		// in the local coordinates of associated i'th INode pointer from GetNode(i)
		// this is NOT THE SAME as the .vph file coordinates. (It is simpler)
		// the world coordinates of the vertex have been transformed by the Inverse	of the INode pointer.
		PHYExport virtual Point3 GetOffsetVector(int i) = 0;

		// GetWeight(i) will return the weight of the vertex associated with the i'th Node
		// pointer from GetNode(i)
		PHYExport virtual float GetWeight(int i) = 0;
};





// IPhyContextExport: This class can be returned by :
// passing the INode pointer of an Object with the given Physique Modifier's IPhysiqueExport::GetContextInterface(node)
// If this Node does contain the Physique Modifier associated with this interface an interface to this object's
// interface is returned (several object's may share the same physique modifier), else returns NULL.

class IPhyContextExport
{
	public:

		PHYExport virtual ~IPhyContextExport() {}
		
		// this returns the number of vertices for the given modContext's Object
		PHYExport virtual int GetNumberVertices() = 0;

		// If ConvertToRigid is set to TRUE, all GetVertexInterface calls will be IPhyRigidVertex OR IPhyBlendedRigidVertex.
		// Vertices which are not Rigid in Physique will be converted to Rigid for the VertexInterface.
		// When ConvertToRigid is set to FALSE, GetVertexInterface for non-Rigid vertices currently returns NULL.
		// By default, if you do not call ConvertToRigid, it is set to FALSE.
		PHYExport virtual void ConvertToRigid(BOOL flag = TRUE) = 0;

		// If AllowBlending is set to FALSE then GetVertexInterface will return a non-blended subclass.
		// Currently the only valid VertexInterface subclasses are IPhyRigidVertex, and IPhyBlendedRigidVertex.
		// When AllowBlending is FALSE, either IPhyRigidVertex or NULL will be returned.
		// If ConvertToRigid is TRUE and AllowBlending is FALSE, all vertices will return
		// IPhyRigidVertex. By default AllowBlending is set to TRUE.
		PHYExport virtual void AllowBlending(BOOL flag = TRUE) = 0;

		// GetVertexInterface return's a VertexInterface (IPhyVertexExport *) for the i'th vertex.
		// If ConvertToRigid has been set to TRUE, then all VertexInterfaces will return IPhyRigidVertex OR IPhyBlendedRigidVertex.
		// When ConvertToRigid has been set to FALSE, non-Rigid vertices will return NULL (CURRENTLY).
		PHYExport virtual IPhyVertexExport *GetVertexInterface(int i) = 0;

		// You must call ReleaseVertexInterface to delete the VertexInterface when finished with it.
		PHYExport virtual void ReleaseVertexInterface(IPhyVertexExport *vertexExport) = 0;
};


// IPhysiqueExport: This class can be returned by calling the method GetInterface() for a Physique Modifier
// given Modifier *mod points to a Physique Modifier, then:
// IPhysiqueExport *phyInterface = (IPhysiqueExport *)( mod->GetInterface(I_PHYINTERFACE) );
// will return the interface for this Physique Modifier, else returns NULL.

class IPhysiqueExport
{
	public:
		
		PHYExport virtual ~IPhysiqueExport() {}

		//GetContextInterface will return a pointer to IPhyContextExport Interface for a given INode.
		// Ff the given INode does not contain the Physique Modifier of this IPhysique Export then NULL is returned.
		PHYExport virtual IPhyContextExport *GetContextInterface(INode* nodePtr) = 0;

		// You must call ReleaseContextInterface to delete the COntextInterface when finished with it.
		PHYExport virtual void ReleaseContextInterface(IPhyContextExport *contextExport) = 0;
};

// example code to find if a given node contains a Physique Modifier
// DerivedObjectPtr requires you include "modstack.h" from the MAX SDK

/*Modifier* FindPhysiqueModifier (INode* nodePtr)
{
	// Get object from node. Abort if no object.
	Object* ObjectPtr = nodePtr->GetObjectRef();
	

	if (!ObjectPtr) return NULL;

	// Is derived object ?
	if (ObjectPtr->SuperClassID() == GEN_DERIVOB_CLASS_ID)
	{
		// Yes -> Cast.
		IDerivedObject* DerivedObjectPtr = static_cast<IDerivedObject*>(ObjectPtr);

		// Iterate over all entries of the modifier stack.
		int ModStackIndex = 0;
		while (ModStackIndex < DerivedObjectPtr->NumModifiers())
		{
			// Get current modifier.
			Modifier* ModifierPtr = DerivedObjectPtr->GetModifier(ModStackIndex);

			// Is this Physique ?
			if (ModifierPtr->ClassID() == Class_ID(PHYSIQUE_CLASS_ID_A, PHYSIQUE_CLASS_ID_B))
			{
				// Yes -> Exit.
				return ModifierPtr;
			}

			// Next modifier stack entry.
			ModStackIndex++;
		}
	}

	// Not found.
	return NULL;
}*/




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\phyrgpro.h ===
def_local_generic(GetNode,			"GetNode");
def_local_generic(GetOffsetVector,	"GetOffsetVector");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\MXSAgni\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MXSAgni.rc
//
#define IDS_APPENDING_KEYS_DIRECTLY_NOT_YET_SUPPORTED 5
#define IDS_ARRAY_INDEX_MUST_BE_VE_NUMBER_GOT 6
#define IDS_ASSIGNING_TO_KEY_ARRAY_DIRECTLY_NOT_YET_SUPPORTED 7
#define IDS_CANNOT_SET_KEY_ARRAY_SIZE_DIRECTLY 8
#define IDS_INVALID_TIME_VALUE_FOR_ADDNEWKEY 9
#define IDS_KEY_INDEX_OUT_OF_RANGE_IN_DELETEITEM 10
#define IDS_KEY_INDEX_OUT_OF_RANGE_IN_DELETEKEY 11
#define IDS_KEY_NO_LONGER_EXISTS_IN_CONTROLLER 12
#define IDS_UNRECOGNIZED_FLAG_FOR_ADDNEWKEY 13
#define IDS_UNRECOGNIZED_FLAG_FOR_DELETEKEYS 14
#define IDS_ANIMATABLE                  2013
#define IDS_READ_ONLY_PROPERTY          2254
#define IDS_CANNOT_DIRECTLY_SET_KEY_ARRAY 2513
#define IDS_RK_FUNCTION_NEEDS_NOTETRACK_GOT 2661
#define IDS_RK_NO_SUCH_NOTETRACK_FUNCTION_FOR 2662
#define IDS_RK_INDEX_SHOULD_BE_LE_NUM_NOTETRACKS_GOT 2663

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\TESTDLX\CLASSCFG.H ===
/*	ClassCfg.h - local class & generic configuration file for MAXScript SDK plugins
 *
 *  John Wainwright, 1998
 */
 
// local root Value class for this plug-in

#define MS_LOCAL_ROOT_CLASS		ListValue

// local Generic function class
#define MS_LOCAL_GENERIC_CLASS	ListGeneric
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\TESTDLX\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TestDLX.rc
//
#define IDS_SPINNER_TYPE_MUST_BE_INTEGER_OR_FLOAT 1
#define IDS_SPINNER_RANGE_MUST_BE_A_VECTOR 2

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\TESTDLX\TESTDLX.CPP ===
#include "MAXScrpt.h"
 
extern void tester_init();

HMODULE hInstance = NULL;

BOOL APIENTRY
DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
	static BOOL controlsInit = FALSE;
	switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			// Hang on to this DLL's instance handle.
			hInstance = hModule;
			if ( !controlsInit )
			{
				controlsInit = TRUE;				
				// Initialize Win95 controls
 				InitCommonControls();
			}
			break;
	}
		
	return(TRUE);
}

__declspec( dllexport ) void
LibInit() { 
	// do any setup here
	tester_init();
}


__declspec( dllexport ) const TCHAR *
LibDescription() { return _T("Sample for MAXscript DLLs"); }

__declspec( dllexport ) ULONG
LibVersion() {  return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\TESTDLX\LISTPRO.H ===
/*	listpro.h - List class protocol, sample MAXScript SDK code for adding a new Value class
 *
 *  John Wainwright, 1998
 */
 
def_local_generic(car,		"car");
def_local_generic(cdr,		"cdr");
use_generic		 (plus,		"+");
use_generic		 (append,	"append");
use_generic		 (isEmpty,	"isEmpty");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\TESTDLX\DLXCLASS.H ===
/*	dlxClass.h - Sample MAXScript SDK code for adding a new Value class
 *
 *  John Wainwright, 1998
 */
 
#include "Funcs.h"

declare_local_generic_class

local_applyable_class (ListValue)

class ListValue : public Value
{
public:
	Value*		head;	// head item
	ListValue*	tail;	// rest of list

				ListValue();
				ListValue(Value* head, ListValue* tail);

	ValueMetaClass* local_base_class() { return class_tag(ListValue); } // local base class in this class's plug-in
				classof_methods(ListValue, Value);
	void		collect() { delete this; }
	void		sprin1(CharStream* s);
	void		gc_trace();
#	define		is_list(p) ((p)->tag == class_tag(ListValue))
	BOOL		_is_collection() { return 1; }

	// collection mapping
	Value*		map(node_map& m);

	// internal methods
	virtual void append(Value* v);

	// operations 
#include "lclabsfn.h"
#	include "setpro.h"

#include "lclimpfn.h"
#	include "listpro.h"

	//properties
	def_property ( count );

	Value*	get_property(Value** arg_list, int count);
	Value*	set_property(Value** arg_list, int count);
};


local_applyable_class (SetValue)

class SetValue : public ListValue
{
public:
				SetValue();

				classof_methods(SetValue, ListValue);
	void		collect() { delete this; }
#	define		is_set(p) ((p)->tag == class_tag(SetValue))

	// internal methods
	void		append(Value* v);
	BOOL		is_member(Value* v);

	// operations 
#include "defimpfn.h"
#	include "setpro.h"
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\TESTDLX\SETPRO.H ===
/*	settpro.h - Set class protocol, sample MAXScript SDK code for adding a new Value class
 *
 *  John Wainwright, 1998
 */
 
def_local_generic(isMember,		"isMember");
def_local_generic(intersection,	"intersection");
def_local_generic(union,		"union");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\TESTDLX\TESTER.CPP ===
/*	Sample MAXScript SDK code
 *
 *	Adds 3 new primitives, a new system global and a new MAX geometry
 *  object class property descriptor.  The property descriptor includes
 *  ParamBlock-hosted and accessor function-based properties
 *
 *  John Wainwright, 1997
 */
 
#include "MAXScrpt.h"
#include "Numbers.h"
#include "MAXclses.h"
#include "Streams.h"
#include "MSTime.h"
#include "MAXObj.h"
#include "Parser.h"
#include "LclClass.h"
#include "resource.h"

// define the new primitives using macros from SDK
#include "definsfn.h"
	def_visible_primitive( my_copy_file,	"myCopyFile");
	def_visible_primitive( my_file_in,		"myFileIn");

Value*
my_copy_file_cf(Value** arg_list, int count)
{
	// myCopyFile "old_file_name" "new_file_name"
	check_arg_count(myCopyFile, 2, count);
	BOOL result = CopyFile(arg_list[0]->to_string(), arg_list[1]->to_string(), TRUE);
	return result ? &true_value : &false_value;
}

// establish a new system global variable, first are the getter & stter fns
Value*
get_slider_time()
{
	return MSTime::intern(MAXScript_interface->GetTime());
}

Value*
set_slider_time(Value* val)
{
	MAXScript_interface->SetTime(val->to_timevalue());
	return val;
}

// stream-based function for the fileIn primitive
static Value* file_in(CharStream* source, int quiet)
{
	three_typed_value_locals(Parser* parser, Value* code, Value* result);

	// make a new compiler instance
	CharStream* out = thread_local(current_stdout);
	vl.parser = new Parser (out);
	if (!quiet)
		source->log_to(out);

	// loop through stream compiling & evaluating all expressions
	try
	{
		source->flush_whitespace();
		while (!source->at_eos())
		{
			vl.code = vl.parser->compile(source);
			vl.result = vl.code->eval();
			if (!quiet)
				vl.result->print();
			source->flush_whitespace();
		}
		source->close();
	}
	catch (...)
	{
		// catch any errors and tell what file we are in if any
		out->puts("Error occurred during fileIn: ");
		source->sprin1(out);
		out->puts("\n");
		throw;
	}

	// if there was one, return last expression in stream as result
	if (vl.result == NULL)
		vl.result = &ok;
	return_value(vl.result);
}

Value*
my_file_in_cf(Value** arg_list, int count)
{
	// myFileIn "filename" [quiet:true]

	// pick up arguments
	check_arg_count_with_keys(myFileIn, 1, count);
	two_typed_value_locals(FileStream* file, Value* result);
	Value* quiet = key_arg_or_default(quiet, &true_value);
	type_check(quiet, Boolean, "myFileIn quiet:");

	// open a fileStream instance on the file
	vl.file = (new FileStream)->open(arg_list[0]->to_string(), "rt");
	if (vl.file == (FileStream*)&undefined)
		throw RuntimeError ("fileIn cannot open file: ", arg_list[0]);

	// pass it to the stream-based fileIn utility function
	try
	{
		vl.result = file_in(vl.file, (quiet == &true_value));
	}
	catch (...)
	{
		// catch any errors and close the temp filestream
		vl.file->close();
		throw;
	}

	// pop value locals & return fileIn result
	return_value(vl.result);
}

// define properties for the new Capsule object

#define CAPS_RADIUS		0	// these are the ParamBlock indexes
#define CAPS_HEIGHT		1
#define CAPS_CENTERS	2
#define CAPS_SIDES		3
#define CAPS_HSEGS		4
#define CAPS_SMOOTHON	5
#define CAPS_SLICEON	6
#define CAPS_SLICEFROM	7
#define CAPS_SLICETO	8
#define CAPS_GENUVS		9

static Class_ID CAPS_CLASS_ID(0x6d3d77ac, 0x79c939a9);

// property accessor functions for a new property 'aspect'
Value* 
get_caps_aspect(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid)
{
	// compute & return capsule aspect
	IParamBlock *pb = ((Object*)obj)->GetParamBlock()->GetParamBlock();
	float h, r;
	pb->GetValue(CAPS_HEIGHT, t, h, valid);
	pb->GetValue(CAPS_RADIUS, t, r, valid);
	return Float::intern(r * 2.0f / h);
}
void
set_caps_aspect(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val)
{
	throw RuntimeError ("Sorry, cannot directly set capsule aspect");
}

// MAX object class property descriptor
MAXClass capsule
	("Capsule", CAPS_CLASS_ID, GEOMOBJECT_CLASS_ID, &geom_class, md_direct_index,
		accessors,
			paramblock,
				"radius",		CAPS_RADIUS,		TYPE_FLOAT,		15.0,
				"height",		CAPS_HEIGHT,		TYPE_FLOAT,		25.0,
				"heighttype",	CAPS_CENTERS,		TYPE_INT,		1,
				"sides",		CAPS_SIDES,			TYPE_INT,		24,
				"heightsegs",	CAPS_HSEGS,			TYPE_INT,		1,
				"smooth",		CAPS_SMOOTHON,		TYPE_BOOL,		TRUE,
				"sliceon",		CAPS_SLICEON,		TYPE_BOOL,		FALSE,
				"slicefrom",	CAPS_SLICEFROM,		TYPE_FLOAT,		0.0,
				"sliceto",		CAPS_SLICETO,		TYPE_FLOAT,		0.0,
				"mapcoords",	CAPS_GENUVS,		TYPE_BOOL,		FALSE,
				end,
			fns,
				"aspect",		get_caps_aspect,	set_caps_aspect,	TYPE_UNSPECIFIED,
				end,
			end,
		end
	);

// test new rollout

#include "3DMath.h"

TCHAR *GetString(int id)
{
	static TCHAR buf1[128], buf2[128];
	static TCHAR* bp = buf1;
	TCHAR* result = NULL;
	if (hInstance)
		result = LoadString(hInstance, id, bp, sizeof(buf1)) ? bp : NULL;
	bp = (bp == buf1) ? buf2 : buf1;   // twiddle between two buffers to help multi-getstring users
	return result;
}

/* -------------------- FooControl  ------------------- */

local_visible_class (FooControl)

class FooControl : public RolloutControl
{
public:
	float		value;
	float		max, min;
	float		scale;
	EditSpinnerType spin_type;

				FooControl(Value* name, Value* caption, Value** keyparms, int keyparm_count)
					: RolloutControl(name, caption, keyparms, keyparm_count)  { tag = class_tag(FooControl); }

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new FooControl (name, caption, keyparms, keyparm_count); }

				classof_methods (FooControl, RolloutControl);
	void		collect() { delete this; }
	void		sprin1(CharStream* s) { s->printf(_T("FooControl:%s"), name->to_string()); }

	void		add_control(Rollout *ro, HWND parent, HINSTANCE hInstance, int& current_y);
	LPCTSTR		get_control_class() { return SPINNERWINDOWCLASS; }
	void		compute_layout(Rollout *ro, layout_data* pos) { }
	BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);

	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
	void		set_enable();
};


/* -------------------- FooControl  ------------------- */

local_visible_class_instance (FooControl, "FooControl")

void
FooControl::add_control(Rollout *ro, HWND parent, HINSTANCE hInstance, int& current_y)
{
	HWND	label, edit_box, spinner;
	int		left, top, width, height;
	SIZE	size;
	TCHAR*	text = caption->eval()->to_string();	

	/* add 3 controls for a spinner: the label static, value custeditbox, & spinner itself,
	 * label & edit box are given IDs that are the spinner id * control_count & that + 1, to make
	 * sure they are unique and decodable */

	parent_rollout = ro;
	control_ID = next_id();
	WORD label_id = next_id();
	WORD edit_box_id = next_id();	

	// compute bounding box, apply layout params
	layout_data pos;
	setup_layout(ro, &pos, current_y);
	Value* fw = control_param(fieldwidth);
	int spin_width = (fw == &unsupplied) ? ro->current_width / 2 : fw->to_int() + 10;
	GetTextExtentPoint32(ro->rollout_dc, text, strlen(text), &size); 	
	int lbl_width = size.cx;
	int orig_width = lbl_width + spin_width;

	pos.width = orig_width + 2;
	pos.left = pos.left + ro->current_width - pos.width; 
	pos.height = ro->text_height + 3;
	process_layout_params(ro, &pos, current_y);

	// place spinner elements
	int cex = (fw == &unsupplied) ? pos.width * lbl_width / orig_width : pos.width - spin_width;
	cex = min(cex, pos.width);
	width = lbl_width; height = ro->text_height;
	left = pos.left + cex - width - 1; top = pos.top; 
	label = CreateWindow(_T("STATIC"),
							text,
							WS_VISIBLE | WS_CHILD | WS_GROUP,
							left, top, width, height,    
							parent, (HMENU)label_id, hInstance, NULL);

	width = pos.width - cex - 13; height = ro->text_height + 3;
	left = pos.left + cex + 1; 
	edit_box = CreateWindowEx(0,
							CUSTEDITWINDOWCLASS,
							_T(""),
							WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_GROUP,
							left, top, width, height,    
							parent, (HMENU)edit_box_id, hInstance, NULL);

	left += width; width = 10; 
	spinner = CreateWindowEx(0,
							SPINNERWINDOWCLASS,
							_T(""),
							WS_VISIBLE | WS_CHILD,
							left, top, width, height,    
							parent, (HMENU)control_ID, hInstance, NULL);

    SendDlgItemMessage(parent, label_id, WM_SETFONT, (WPARAM)ro->font, 0L);
    SendDlgItemMessage(parent, edit_box_id, WM_SETFONT, (WPARAM)ro->font, 0L);

	/* setup the spinner control */

	ISpinnerControl* spin = GetISpinner(spinner);
	Value*			 range = control_param(range);
	Value*			 type = control_param(type);
	Value*			 scaleval = control_param(scale);

	if (type == n_integer)
		spin_type = EDITTYPE_INT;
	else if (type == n_worldUnits)
		spin_type = EDITTYPE_UNIVERSE;
	else if (type == n_float || type == &unsupplied)
		spin_type = EDITTYPE_FLOAT;
	else
		throw TypeError (GetString(IDS_SPINNER_TYPE_MUST_BE_INTEGER_OR_FLOAT), type);
	
	if (ro->init_values)
	{
		if (range == &unsupplied)
		{
			min = 0.0f; max = 100.0f; value = 0.0f;
		}
		else if (is_point3(range))
		{
			Point3 p = range->to_point3();
			min = p.x; max = p.y; value = p.z;
		}
		else
			throw TypeError (GetString(IDS_SPINNER_RANGE_MUST_BE_A_VECTOR), range);

		if (scaleval == &unsupplied)
		{
				scale = (spin_type == EDITTYPE_INT) ? 1.0f : 0.1f;
		}
		else
			scale = scaleval->to_float();
	}
	
    spin->LinkToEdit(edit_box, spin_type);
	spin->SetScale(scale);
    if (spin_type == EDITTYPE_INT)
	{
		spin->SetLimits((int)min, (int)max, FALSE);
		spin->SetValue((int)value, FALSE);
	}
	else if (spin_type == EDITTYPE_UNIVERSE)
	{
		spin->SetLimits(min, max, FALSE);
		spin->SetValue(value, FALSE);
	}
	else
	{
		spin->SetLimits(min, max, FALSE);
		spin->SetValue(value, FALSE);
	}
	ReleaseISpinner(spin);
}

BOOL
FooControl::handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam)
{
	if (message == CC_SPINNER_CHANGE)
	{
		one_value_local(arg);
		/* handle CC_SPINNER_CHANGE message received for this control - call my _T('changed') event handler with
		 * with the current spinner value as the argument */
		if (spin_type == EDITTYPE_INT)
		{
			value = (float)((ISpinnerControl *)lParam)->GetIVal();
			vl.arg = Integer::intern((int)value);
		}
		else
			vl.arg = Float::intern(value = ((ISpinnerControl *)lParam)->GetFVal()); 
		try
		{
			call_event_handler(ro, n_changed, &vl.arg, 1);
		}
		catch (...)
		{
   			SendMessage(GetDlgItem(ro->page, control_ID), WM_LBUTTONUP, 0, 0); // on error, force a buttonup to release the spinner
			throw;
		}
		pop_value_locals();
		return TRUE;
	}
	return FALSE;
}

Value*
FooControl::get_property(Value** arg_list, int count)
{
	Value* prop = arg_list[0];

	if (prop == n_value)
		return (spin_type == EDITTYPE_INT) ? Integer::intern((int)value) : Float::intern(value);
	else if (prop == n_enabled)
		return enabled ? &true_value : &false_value;
	else if (prop == n_range)
		return new Point3Value (min, max, value);
	else
		return RolloutControl::get_property(arg_list, count);
}

Value*
FooControl::set_property(Value** arg_list, int count)
{
	Value* val = arg_list[0];
	Value* prop = arg_list[1];

	if (prop == n_value)
	{
		if (parent_rollout != NULL && parent_rollout->page != NULL)
		{
			value = val->to_float();
			if (parent_rollout != NULL && parent_rollout->page != NULL)
			{
				ISpinnerControl* spin = GetISpinner(GetDlgItem(parent_rollout->page, control_ID));
				if (spin_type == EDITTYPE_INT)
					spin->SetValue((int)value, FALSE);
				else
					spin->SetValue(value, FALSE);
				ReleaseISpinner(spin);
			}
		}
	}
	else if (prop == n_range)
	{
		Point3 p;
		if (is_point3(val))
			p = val->to_point3();
		else
			throw TypeError (GetString(IDS_SPINNER_RANGE_MUST_BE_A_VECTOR), val);
		min = p.x; max = p.y; value = p.z;

		if (parent_rollout != NULL && parent_rollout->page != NULL)
		{
			ISpinnerControl* spin = GetISpinner(GetDlgItem(parent_rollout->page, control_ID));
			if (spin_type == EDITTYPE_INT)
			{
				spin->SetLimits((int)p.x, (int)p.y, FALSE);
				spin->SetScale(1.0F);
				spin->SetValue((int)p.z, FALSE);
			}
			else
			{
				spin->SetLimits(p.x, p.y, FALSE);
				spin->SetScale(0.1F);
				spin->SetValue(p.z, FALSE);
			}
			ReleaseISpinner(spin);
		}
	}
	else
		return RolloutControl::set_property(arg_list, count);

	return val;
}

void
FooControl::set_enable()
{
	if (parent_rollout != NULL && parent_rollout->page != NULL)
	{
		// set spinner enable
		ISpinnerControl *spin = GetISpinner(GetDlgItem(parent_rollout->page, control_ID));
		if (enabled) spin->Enable();
		else spin->Disable();
		ReleaseISpinner(spin);
		// set editbox enable
		ICustEdit *edit = GetICustEdit(GetDlgItem(parent_rollout->page, control_ID+2));
		if (enabled) edit->Enable();
		else edit->Disable();
		ReleaseICustEdit(edit);
		// set caption enable
		HWND ctrl = GetDlgItem(parent_rollout->page, control_ID+1);
		if (ctrl)
			EnableWindow(ctrl, enabled);
	}
}

/* --------------------- plug-in init --------------------------------- */
// this is called by the dlx initializer, register the global var here
void tester_init()
{
	CharStream* out = thread_local(current_stdout);
	out->puts(_T("--* Testdlx.dlx 3.00 loaded *--\n"));
	define_system_global("mySlider", get_slider_time, set_slider_time);
	install_rollout_control(Name::intern("foo"), FooControl::create);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\MXS_Samples\TESTDLX\DLXCLASS.CPP ===
/*	dlxClass.cpp - Sample MAXScript SDK code for adding a new Value class
 *
 *  John Wainwright, 1998
 */
 
#include "MAXScrpt.h"
#include "Numbers.h"
#include "MAXObj.h"
#include "LclClass.h"
#include "dlxClass.h"

/* --------------------  local generics and names   --------------- */

#include "lclinsfn.h"
#	include "listpro.h"
#	include "setpro.h"

define_local_generic_class

def_name (head)
def_name (tail)

/* ------------------- ListValue class instance ----------------------- */

local_visible_class_instance (ListValue, "List")

Value*
ListValueClass::apply(Value** arg_list, int count)
{
	// list v1 v2 ... vn
	two_typed_value_locals(ListValue* result, Value* head);
	vl.result = new ListValue ();
	for (int i = 0; i < count; i++)
	{
		vl.head = arg_list[i]->eval();
		vl.result->append(vl.head);
	}

	return_value(vl.result);
}

/* -------------------- ListValue methods ----------------------------- */

ListValue::ListValue()
{
	tag = class_tag(ListValue);
	head = NULL;
	tail = NULL;
}

ListValue::ListValue(Value* ihead, ListValue* itail)
{
	tag = class_tag(ListValue);
	head = ihead;
	tail = itail;
}

void
ListValue::sprin1(CharStream* s)
{
	int			i=0;
	ListValue*	t;

	s->puts("(");
	for (t = this; t->head != NULL; t = t->tail)
	{
		if (i > 0)
			s->puts(", ");
		if (++i > 20) 
		{
			s->puts("...");
			break;
		}
		t->head->sprin1(s);
	};
	s->puts(")");	
}

void
ListValue::gc_trace()
{
	// mark me & trace sub-objects
	Value::gc_trace();
	if (head->is_not_marked())
		head->gc_trace();
	if (tail->is_not_marked())	// this will recurse which might overflow for big lists, should put a loop here
		tail->gc_trace();
}

Value*
ListValue::car_vf(Value** arg_list, int count)
{
	// car <list>
	return head ? head : &undefined;
}

Value*
ListValue::cdr_vf(Value** arg_list, int count)
{
	// cdr <list>
	return head ? (Value*)tail : (Value*)&undefined;
}

void
ListValue::append(Value* v)
{
	ListValue* t = this;
	while (t->head)
		t = t->tail;
	t->head = v;
	t->tail = new ListValue ();
}

Value*
ListValue::append_vf(Value** arg_list, int count)
{
	// append <list> <val>
	check_gen_arg_count(append, 2, count);
	append(arg_list[0]);
	return this;
}

Value*
ListValue::plus_vf(Value** arg_list, int count)
{
	return append_vf(arg_list, count);
}

Value*
ListValue::isEmpty_vf(Value** arg_list, int count)
{
	// isEmpty <list>
	return head ? &false_value : &true_value;
}

Value*
ListValue::get_count(Value** arg_list, int count)
{
	ListValue* t = this;
	int i = 0;
	while (t->head)
	{
		t = t->tail;
		i++;
	}
	return Integer::intern(i);
}

Value*
ListValue::set_count(Value** arg_list, int count)
{
	throw RuntimeError ("Can't directly set list size", this);
	return arg_list[0];
}

Value*
ListValue::get_property(Value** arg_list, int count)
{
	Value* prop = arg_list[0];
	if (prop == n_head)
		return head ? head : &undefined;
	else if (prop == n_tail)
		return head ? (Value*)tail : (Value*)&undefined;
	else
		return Value::get_property(arg_list, count);
}

Value*
ListValue::set_property(Value** arg_list, int count)
{
	return Value::set_property(arg_list, count);
}

Value*
ListValue::map(node_map& m)
{
	ListValue*	t;
	one_value_local(result);

	// map function over my items
	for (t = this; t->head != NULL; t = t->tail)
	{
		if (m.vfn_ptr != NULL)
			vl.result = (t->head->*(m.vfn_ptr))(m.arg_list, m.count);
		else
		{
			// temporarily replace 1st arg with this node
			Value* arg_save = m.arg_list[0];

			m.arg_list[0] = t->head;
			vl.result = (*m.cfn_ptr)(m.arg_list, m.count);
			m.arg_list[0] = arg_save;
		}
		if (m.collection != NULL)
			m.collection->append(vl.result);
	}

	pop_value_locals();
	return &ok;
}

/* ------------------- SetValue class instance ----------------------- */

local_visible_class_instance (SetValue, "PSet")

Value*
SetValueClass::apply(Value** arg_list, int count)
{
	// set v1 v2 ... vn
	two_typed_value_locals(SetValue* result, Value* head);
	vl.result = new SetValue ();
	for (int i = 0; i < count; i++)
	{
		vl.head = arg_list[i]->eval();
		vl.result->append(vl.head);
	}

	return_value(vl.result);
}

/* -------------------- SetValue methods ----------------------------- */

SetValue::SetValue()
{
	tag = class_tag(SetValue);
	head = NULL;
	tail = NULL;
}

void
SetValue::append(Value* v)
{
	ListValue* t = this;
	while (t->head)
	{
		if (t->head == v)
			return;  // don't add duplicates
		t = t->tail;
	}
	t->head = v;
	t->tail = new SetValue ();
}

BOOL
SetValue::is_member(Value* v)
{
	ListValue* t;
	for (t = this; t->head; t = t->tail)
		if (t->head == v)
			return TRUE;
	return FALSE;
}

Value*
SetValue::isMember_vf(Value** arg_list, int count)
{
	// isMember <set> <val>
	check_gen_arg_count(isMember, 2, count);
	return is_member(arg_list[0]) ? &true_value : &false_value;
}

Value*
SetValue::intersection_vf(Value** arg_list, int count)
{
	// intersection <set1> <set2>
	check_gen_arg_count(intersection, 2, count);
	Value* set2 = arg_list[0];
	type_check(set2, SetValue, "intersection()");
	one_typed_value_local(SetValue* result);
	ListValue* t;
	vl.result = new SetValue();
	for (t = (ListValue*)set2; t->head; t = t->tail)
		if (is_member(t->head))
			vl.result->append(t->head);
	return_value(vl.result);
}

Value*
SetValue::union_vf(Value** arg_list, int count)
{
	// union <set1> <set2>
	check_gen_arg_count(union, 2, count);
	Value* set2 = arg_list[0];
	type_check(set2, SetValue, "union()");
	one_typed_value_local(SetValue* result);
	ListValue* t;
	vl.result = new SetValue();
	for (t = this; t->head; t = t->tail)
		vl.result->append(t->head);
	for (t = (ListValue*)set2; t->head; t = t->tail)
		if (!vl.result->is_member(t->head))
			vl.result->append(t->head);
	return_value(vl.result);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\CUI-Test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CUITest.rc
//

#define IDS_LIBDESCRIPTION              1
#define IDS_CATEGORY                    2
#define IDS_CLASS_NAME                  3
#define IDS_PARAMS                      4
#define IDD_PANEL                       101
#define IDC_CLOSEBUTTON                 1000
#define IDC_DOSTUFF                     1000
#define IDC_COLOR                       1456
#define IDC_EDIT                        1490
#define IDC_SPIN                        1496

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\CUI-Test\CUITest.h ===
/*===========================================================================*\
 |  File: CUITest.h
 |	Header file for the CUITest Utility. Check CUITest.cpp for notes and information.
 |
\*===========================================================================*/


#include "Max.h"
#include "resource.h"
#include "utilapi.h"
#include "kbdshortcut.h" // This is for the keyboard shortcut APIs
#include "imacroscript.h" // This is to use methods of MacroDir and MacroEntry


TCHAR *GetString(int id);
extern ClassDesc* GetCUITestDesc();


/*===========================================================================*\
 | Misc defines, etc.
\*===========================================================================*/

#define MY_CATEGORY _T("How To")
#define MY_CLASSNAME _T("CUITester")
#define MY_CLASS_ID Class_ID(0x227d9df3, 0x999895ed)
#define MY_LIBDESCRIPTION _T("CUI Tester")



/*===========================================================================*\
 | Definitions for the toolbar items themselves
\*===========================================================================*/

#define TBITEM(type, bmi, cmd) \
		ToolButtonItem(type,bmi,bmi,bmi,bmi,GetCUIFrameMgr()->GetImageSize(),GetCUIFrameMgr()->GetImageSize(),GetCUIFrameMgr()->GetButtonWidth(),GetCUIFrameMgr()->GetButtonHeight(),cmd,0)
#define TBITEM2(type, bmi, bmid, cmd) \
		ToolButtonItem(type,bmi,bmi,bmid,bmid,GetCUIFrameMgr()->GetImageSize(),GetCUIFrameMgr()->GetImageSize(),GetCUIFrameMgr()->GetButtonWidth(),GetCUIFrameMgr()->GetButtonHeight(),cmd, 0)
#define TBMACRO(md) \
		ToolMacroItem(0, GetCUIFrameMgr()->GetButtonHeight(), md)

// Here a large value is used so it won't conflict with the IDs used
// by MAX.  If the ProcessMessage() method of the handler returns FALSE
// MAX will use the default CUI toolbar processing and this could invoke
// a MAX command unintentionally.  Note that this is only the case if
// it returns FALSE.
#define ID_TB_0 10000
#define ID_TB_1 10001
#define ID_TB_2 10002



/*===========================================================================*\
 | This is the main plug-in class
\*===========================================================================*/
class CUITest : public UtilityObj {
  public:
	IUtil *iu;
	Interface *ip;

	ICUIFrame *iFrame;
	HWND hWnd; // CUIFrameWindow handle
	
	CUITest() { iu = NULL; ip = NULL; iFrame = NULL; };
	~CUITest() { };

	void BeginEditParams(Interface *ip,IUtil *iu);
	void EndEditParams(Interface *ip,IUtil *iu);
	void DeleteThis() {}
};

static CUITest theCUITest;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Pcontrol\RESOURCE.H ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PControl.rc
//
#define IDS_RB_PATH                     1
#define IDS_RB_PERCENT                  2
#define IDS_RB_NONE                     3
#define IDS_RB_PICKPATH                 4
#define IDS_RB_PATHCONTROLLER           5
#define IDS_RB_ILLEGALPATH              6
#define IDS_RB_SETPERCENT               7
#define IDS_RB_PATHJOINTPARAMS          9
#define IDS_RB_PATHPARAMS               10
#define IDS_LIB_DESC                    11
#define IDD_PATHPARAMS                  123
#define IDD_PATHJOINTPARAMS             130
#define IDC_PATH_ALLOWFLIP              1003
#define IDC_PATH_CONSTVEL               1004
#define IDC_XTO                         1067
#define IDC_XTOSPIN                     1068
#define IDC_XDAMPING                    1069
#define IDC_XDAMPINGSPIN                1070
#define IDC_PICKPATH                    1087
#define IDC_PATHNAME                    1088
#define IDC_XACTIVE                     1099
#define IDC_XLIMITED                    1100
#define IDC_XEASE                       1101
#define IDC_XFROM                       1102
#define IDC_XFROMSPIN                   1103
#define IDC_PATH_FOLLOW                 1200
#define IDC_PATH_BANK                   1201
#define IDC_FOLLOW_BANKSPIN             1202
#define IDC_FOLLOW_BANK                 1203
#define IDC_FOLLOW_BANKLABEL            1204
#define IDC_FOLLOW_TRACK                1205
#define IDC_FOLLOW_TRACKSPIN            1206
#define IDC_FOLLOW_TRACKLABEL           1207
#define IDC_PATHPERCENT                 1208
#define IDC_PATHPERCENTSPIN             1209
#define IDC_FOLLOW_BANKLABEL2           1210
#define IDC_JP_XFROMLABEL               1534
#define IDC_JP_XTOLABEL                 1535
#define IDC_JP_XDAMPINGLABEL            1549
#define IDC_PATH_X                      1607
#define IDC_PATH_Y                      1608
#define IDC_PATH_Z                      1609
#define IDC_PATH_FLIP                   1610

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\CUI-Test\CUITest.cpp ===
/*===========================================================================*\
 |    File: CUITest.cpp
 |
 | Purpose: To test the CUI Toolbar APIs.  This program adds a toolbar
 |          to MAX when BeginEditParams() is called and hides it when 
 |          EndEditParams() is called.
 |
 |          Important Notes:
 |          o This file requires four image files be placed in the MAX EXE\UI 
 |            directory.  These are:
 |             CUITest_16a.bmp
 |             CUITest_16i.bmp
 |             CUITest_24a.bmp
 |             CUITest_24i.bmp
 |
 |          o It also requires CUITest.mcr to be put into EXE\UI as well.
 |
 |			NOTE: The above files can be found in the CONTENT directory, off the
 |					root directory of this project.
 |
 |
 | History: Mark Meier, 03/05/99, Began.
 |          MM, 03/14/99, Last Change.
 |			Harry Denholm, 03/28/99, Prep'd for SDK inclusion
 |
\*===========================================================================*/

// Please see the following header file for class information
#include "CUITest.h"



/*===========================================================================*\
 | Class Descriptor for the CUITest plugin
\*===========================================================================*/

class CUITestClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theCUITest;}
	const TCHAR *	ClassName() {return MY_CLASSNAME;}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return MY_CLASS_ID;}
	const TCHAR* 	Category() {return MY_CATEGORY;}
};
static CUITestClassDesc CUITestDesc;
ClassDesc* GetCUITestDesc() {return &CUITestDesc;}



/*===========================================================================*\
 | This class is the custom message handler installed by the method
 | ICUIFrame::InstallMsgHandler(tbMsgHandler).  It has one method,
 | ProcessMessage() which, uh, processes the messages.
\*===========================================================================*/

class TBMsgHandler : public CUIFrameMsgHandler {
	CUITest *ct;
  public:
	TBMsgHandler(CUITest *ctst)	{ this->ct = ctst; }
	int ProcessMessage(UINT message, WPARAM wParam, LPARAM lParam);
};	
static TBMsgHandler *tbMsgHandler;


int TBMsgHandler::ProcessMessage(UINT message, WPARAM wParam, LPARAM lParam) {
	switch(message) {
	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case ID_TB_0: // Dock or Float
			if (ct->iFrame->IsFloating()) {
				GetCUIFrameMgr()->DockCUIWindow(ct->hWnd, CUI_TOP_DOCK, NULL);
				GetCUIFrameMgr()->RecalcLayout(TRUE);
			}
			else {
				GetCUIFrameMgr()->FloatCUIWindow(ct->hWnd, NULL);
				GetCUIFrameMgr()->RecalcLayout(TRUE);
			}
			return TRUE;
		case ID_TB_1: // This is the check button ... ignore it.
			return TRUE;
		case ID_TB_2:
			MessageBox(NULL, _T("Pressed 2"), _T("ID_TB_2"), MB_OK);
			return TRUE;
		default: // ID not recognized -- use default CUI processing
			return FALSE;
		}
	}
	return FALSE;
}




/*===========================================================================*\
 | The Begin/EndEditParams calls, which create and destroy the toolbar
\*===========================================================================*/

void CUITest::BeginEditParams(Interface *ip,IUtil *iu) {
	this->iu = iu;
	this->ip = ip;

	if (iFrame) {
		// We have the toolbar already, just show it...(EndEditParams() hid it)
		iFrame->Hide(FALSE);
		// If the frame is floating there is no reason to 
		// recalc the layout, but if it's docked we need to do so
		if (!iFrame->IsFloating()) {
			GetCUIFrameMgr()->RecalcLayout(TRUE);
		}
	}
	else {
		// Create a simple toolbar
		// -- First create the frame
		HWND hParent = ip->GetMAXHWnd();
		hWnd = CreateCUIFrameWindow(hParent, _T("CUI Test Toolbar"), 0, 0, 250, 100);
		// iFrame->SetName();
		iFrame = GetICUIFrame(hWnd);
		iFrame->SetContentType(CUI_TOOLBAR);
		iFrame->SetPosType(CUI_HORIZ_DOCK | CUI_VERT_DOCK | CUI_FLOATABLE | CUI_SM_HANDLES);

		// -- Now create the toolbar window
		HWND hToolbar = CreateWindow(
				CUSTTOOLBARWINDOWCLASS,
				NULL,
				WS_CHILD | WS_VISIBLE,
				0, 0, 250, 100,
				hWnd,
				NULL,
				hInstance,
				NULL);
		// -- Now link the toolbar to the CUI frame
		ICustToolbar *iToolBar = GetICustToolbar(hToolbar);
		iToolBar->LinkToCUIFrame(hWnd, NULL);
		iToolBar->SetBottomBorder(FALSE);
		iToolBar->SetTopBorder(FALSE);

		// Install the message handler to process the controls we'll add...
		tbMsgHandler = new TBMsgHandler(this);
		iFrame->InstallMsgHandler(tbMsgHandler);

		// -- Toss in a few controls of various sorts...
		iToolBar->SetImage(GetCUIFrameMgr()->GetDefaultImageList());
		// Get the index into the entire image list of the CUITest icons.
		int iconIndex = GetCUIFrameMgr()->GetGroupStartIndex(_T("CUITest"));
		// Add a push button
		// This one docks and undocks the toolbar if clicked...
		iToolBar->AddTool(TBITEM(CTB_PUSHBUTTON, iconIndex, ID_TB_0));

		// Add a separator
		iToolBar->AddTool(ToolSeparatorItem(8));

		// Add a check button
		// This one doesn't do anything except change to GREEN when on...
		iToolBar->AddTool(TBITEM(CTB_CHECKBUTTON, iconIndex+1, ID_TB_1));
		ICustButton* iBtn;
		(iBtn = iToolBar->GetICustButton(ID_TB_1))->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(iBtn);

		// Add a separator
		iToolBar->AddTool(ToolSeparatorItem(8));

		// Add a keyboard macro command.  In this case the Time Configuration dialog
		// is presented as an example.  In order to get the proper command ID to use
		// we must search through the names in the MAX UI shortcut table and find
		// a match.  The list of names can be reviewed in the MAX UI when setting up
		// a keyboard shortcut.
		TSTR findName = _T("Time Configuration");
		for (int i = 0; i < ip->GetShortcutCount(kShortcutMainUI); i++) {
			if (_tcscmp(findName.data(), ip->GetShortcutCommandName(kShortcutMainUI, i)) == 0) {
				int cmdID = ip->GetShortcutCommandId(kShortcutMainUI, i);
				MacroButtonData md1(kShortcutMainUI, NULL, cmdID, _T("KBD Cmd"), _T("Key Macro Tooltip"));
				iToolBar->AddTool(TBMACRO(&md1));
				break;
			}
		}

		// Add a separator
		iToolBar->AddTool(ToolSeparatorItem(8));

		// Add a macro script button to the toolbar.  This is a custom macro script
		// which is loaded, then located, then added.
		TSTR ui = ip->GetDir(APP_UI_DIR);
		TSTR path = ui + _T("\\CUITEST.MCR");
		GetMacroScriptDir().LoadMacroScripts(path.data(), FALSE);
		// Find it based on the category and name defined in the CUITest.mcr file.
		MacroEntry *me = GetMacroScriptDir().FindMacro(_T("CUITestCategory"), _T("CUITestName"));
		if (me) {
			MacroID mID = me->GetID();
			MacroButtonData md2(mID, _T("Macro Scr"), _T("Macro Script Tooltip"));
			iToolBar->AddTool(TBMACRO(&md2));
		}

		// This macro button is processed by our message handler (ID_TB_2)
		MacroButtonData md3(0, NULL, ID_TB_2, "", _T("MacroButtonData Tooltip"), 2, _T("CUITest"));
		iToolBar->AddTool(TBMACRO(&md3));
		
		// -- Set the initial floating position
		SIZE sz; RECT rect;
		iToolBar->GetFloatingCUIFrameSize(&sz);
		rect.top = 200; rect.left = 200;
		rect.right = rect.left+sz.cx; rect.bottom = rect.top+sz.cy;
		GetCUIFrameMgr()->FloatCUIWindow(hWnd, &rect);
		MoveWindow(hWnd, rect.left, rect.right, sz.cx, sz.cy, TRUE);

		// We are done, release the toolbar and frame handles
		ReleaseICustToolbar(iToolBar);
		ReleaseICUIFrame(iFrame);
	}
}
	
void CUITest::EndEditParams(Interface *ip,IUtil *iu) {
	this->iu = NULL;
	this->ip = NULL;
	// Hide the toolbar so the user can't execute anything 
	// when we're not active.
	iFrame->Hide(TRUE);
	// If the toolbar was docked we need to recalc the layout
	// so the toolbar will be removed.
	if (!iFrame->IsFloating()) {
		GetCUIFrameMgr()->RecalcLayout(TRUE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\CUI-Test\Plugin.cpp ===
#include "CUITest.h"


HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return MY_LIBDESCRIPTION; }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetCUITestDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Pcontrol\PCONTROL.CPP ===
/*===========================================================================*\
  How To Create a Controller Plug-In

  FILE: PControl.cpp
 
  DESCRIPTION: A controller that moves an object along a spline path

  CREATED BY: Rolf Berteig

  HISTORY: created 13 June 1995

  Copyright (c) 1994, All Rights Reserved.
\*===========================================================================*/
#include "max.h"
#include "resource.h"
#include "units.h"
#include "interpik.h"
#include "spline3d.h"
#include "istdplug.h"

// This is the DLL instance handle passed in when the plug-in is 
// loaded at startup.
HINSTANCE hInstance;

// This function returns a pointer to a string in the string table of
// the resource library.  Note that this function maintains the buffer
// and that only one string is loaded at a time.  Therefore if you intend
// to use this string, you must copy to another buffer since it will 
// be overwritten on the next GetString() call.
TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

// Unique class ID value
#define PCONTROL_CLASS_ID Class_ID(0x50f65c4c, 0x59863a96)

#define InterpType() ((ConstVel())?SPLINE_INTERP_NORMALIZED:SPLINE_INTERP_SIMPLE)

class PathPosition;

class PickPathMode : public PickModeCallback, public PickNodeCallback {
	public:		
		PathPosition *cont;
		
		PickPathMode(PathPosition *c) {cont=c;}
		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);
		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);
		BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{ return TRUE; }

		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}
	};

// flag values
#define PATHFLAG_FOLLOW		(1<<0)
#define PATHFLAG_BANK		(1<<1)
#define PATHFLAG_CLOSED		(1<<2)
#define PATHFLAG_ALLOWFLIP	(1<<3)
#define PATHFLAG_CONSTVEL	(1<<4)
#define PATHFLAG_FLIP		(1<<5)
#define PATHFLAG_YAXIS		(1<<6)
#define PATHFLAG_ZAXIS		(1<<7)

#define PATHPOS_PERCENT_REF	0

class PathPosition : public	IPathPosition, public TimeChangeCallback {
	public:
		Control *percent;
		INode *path;
		DWORD flags;
		float bankAmount, tracking;
		Point3 curval;
		Quat curRot;
		Interval ivalid;
		
		static HWND hPathParams;
		static IObjParam *ip;
		static ICustButton *iPick;
		static ISpinnerControl *iBank, *iTrack, *iPerc;
		static PickPathMode *pickMode;
		static PathPosition *editCont;

		PathPosition(const PathPosition &ctrl);
		PathPosition(BOOL loading=FALSE);
		~PathPosition();

		BOOL SetPathNode(INode *node);
		void SetBankAmount(float a);
		void SetTracking(float t);
		void SetFollow(BOOL f);
		void SetBank(BOOL b);
		void SetAllowFlip(BOOL f);
		void SetConstVel(BOOL cv);
		void SetFlip(BOOL onOff);
		void SetAxis(int axis);
		
		BOOL GetFollow() {return Follow();}
		float GetBankAmount();
		BOOL GetBank() {return Bank();}
		float GetTracking();
		BOOL GetAllowFlip() {return AllowFlip();}
		BOOL GetConstVel() {return ConstVel();}		

		BOOL Follow() {return flags&PATHFLAG_FOLLOW?TRUE:FALSE;}
		BOOL Bank() {return flags&PATHFLAG_BANK?TRUE:FALSE;}
		BOOL AllowFlip() {return flags&PATHFLAG_ALLOWFLIP?TRUE:FALSE;}
		BOOL ConstVel() {return flags&PATHFLAG_CONSTVEL?TRUE:FALSE;}
		BOOL GetFlip() {return flags&PATHFLAG_FLIP?TRUE:FALSE;}
		int GetAxis();		
		
		void Update(TimeValue t);
		float GetPercent(TimeValue t,Interval &valid,BOOL noClip=FALSE);
		Point3 PointOnPath(TimeValue t, ShapeObject *pathOb, Interval &valid);
		Matrix3 CalcRefFrame(TimeValue t,ShapeObject *pathOb);

		// Animatable methods
		Class_ID ClassID() { return PCONTROL_CLASS_ID; }  
		SClass_ID SuperClassID() { return CTRL_POSITION_CLASS_ID; }  		
		
		void GetClassName(TSTR& s) {s = GetString(IDS_RB_PATH);}
		void DeleteThis() {delete this;}		
		int IsKeyable() {return 0;}		

		int NumSubs()  {return 1;}
		Animatable* SubAnim(int i) {return percent;}
		TSTR SubAnimName(int i) {return GetString(IDS_RB_PERCENT);}
		int SubNumToRefNum(int subNum) {if (subNum==0) return 0; else return -1;}

		ParamDimension* GetParamDimension(int i) {return stdPercentDim;}
		BOOL AssignController(Animatable *control,int subAnim);

		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev ); 
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next ); 

		int SetProperty(ULONG id, void *data);
		void *GetProperty(ULONG id);

		// Reference methods
		int NumRefs() { return 2; };	
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage);

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// Control methods
		void Copy(Control *from);
		RefTargetHandle Clone(RemapDir& remap);
		BOOL IsLeaf() {return FALSE;}
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);	
		void SetValue(TimeValue t, void *val, int commit, GetSetMethod method) {}
		void CommitValue(TimeValue t) {percent->CommitValue(t);}
		void RestoreValue(TimeValue t) {percent->RestoreValue(t);}
		void EnumIKParams(IKEnumCallback &callback);
		BOOL CompDeriv(TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags);
		float IncIKParam(TimeValue t,int index,float delta);
		void ClearIKParam(Interval iv,int index);

		void TimeChanged(TimeValue t);
	};

class JointParamsPath : public JointParams {
	public:			 	
		JointParamsPath() : JointParams((DWORD)JNT_POS,1,100.0f) {}
		void SpinnerChange(InterpCtrlUI *ui,WORD id,ISpinnerControl *spin,BOOL interactive);
	};


//********************************************************
// PATH CONTROL
//********************************************************
PathPosition::PathPosition(const PathPosition &ctrl)
	{
	percent = NULL;
	path    = NULL;
	if (ctrl.percent) {
		ReplaceReference(PATHPOS_PERCENT_REF,ctrl.percent);
	} else {
		ReplaceReference(PATHPOS_PERCENT_REF,NewDefaultFloatController());		
		
		percent->AddNewKey(GetAnimStart(),ADDKEY_INTERP);		
		percent->AddNewKey(GetAnimEnd(),ADDKEY_INTERP);
		SuspendAnimate();
		AnimateOn();
		float val=0.0f;
		percent->SetValue(GetAnimStart(),&val);
		val =  1.0f;
		percent->SetValue(GetAnimEnd(),&val); 
		ResumeAnimate();
		}
	if (ctrl.path) {
		ReplaceReference(PATHPOS_PATH_REF,ctrl.path);
	} else {
		path = NULL;
		}
	flags      = 0;
	bankAmount = FromBankUI(0.5f);
	tracking   = FromTrackUI(0.5f);	
	curval = ctrl.curval;
	curRot = ctrl.curRot;
	ivalid = ctrl.ivalid;
	}

PathPosition::PathPosition(BOOL loading) 
	{
	percent  = NULL;
	path     = NULL;	
	curval   = Point3(0,0,0);
	curRot.Identity();
	flags      = 0;
	bankAmount = FromBankUI(0.5f);
	tracking   = FromTrackUI(0.5f);

	if (!loading) {
		ReplaceReference(PATHPOS_PERCENT_REF,NewDefaultFloatController());		
		
		percent->AddNewKey(GetAnimStart(),ADDKEY_INTERP);		
		percent->AddNewKey(GetAnimEnd(),ADDKEY_INTERP);
		SuspendAnimate();
		AnimateOn();
		float val=0.0f;
		percent->SetValue(GetAnimStart(),&val);
		val =  1.0f;
		percent->SetValue(GetAnimEnd(),&val); 
		ResumeAnimate();		
		}
	ivalid.SetEmpty();	
	}

PathPosition::~PathPosition()
	{
	DeleteAllRefsFromMe();
	}

RefTargetHandle PathPosition::Clone(RemapDir& remap)
	{
	PathPosition *p = new PathPosition(TRUE);

	if (path) {
		p->ReplaceReference(PATHPOS_PATH_REF,path);
	} else {
		p->path = NULL;
		}

	if (percent) {
		p->ReplaceReference(PATHPOS_PERCENT_REF,remap.CloneRef(percent));
	} else {
		p->ReplaceReference(PATHPOS_PERCENT_REF,NewDefaultFloatController());
		}

	p->flags      = flags;
	p->bankAmount = bankAmount;
	p->tracking   = tracking;
	p->curval     = curval;
	p->curRot     = curRot;	
	p->ivalid.SetEmpty();
	return p;
	}


void PathPosition::Copy(Control *from)
	{
	if (from->ClassID()==ClassID()) {
		PathPosition *ctrl = (PathPosition*)from;
		ReplaceReference(PATHPOS_PERCENT_REF,ctrl->percent);
		ReplaceReference(PATHPOS_PATH_REF,ctrl->path);
		curval   = ctrl->curval;
		curRot   = ctrl->curRot;
		ivalid   = ctrl->ivalid;		
	} else {		
		from->GetValue(0,&curval,ivalid);
		}
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}


float PathPosition::GetPercent(TimeValue t,Interval &valid,BOOL noClip)
	{	
	float per;
	percent->GetValue(t,&per,valid,CTRL_ABSOLUTE);	
	if (noClip) return per;
	if (per < 0.0f || per > 1.0f || (flags&PATHFLAG_CLOSED)) {
		per = (float)fmod(per,1.0f);
		}
	if (per<0.0f) per = 1.0f + per;	
	return per;
	}

Point3 PathPosition::PointOnPath(TimeValue t, ShapeObject *pathOb, Interval &valid)
	{	
	return pathOb->InterpCurve3D(t, 0, GetPercent(t,valid), InterpType()) * 
		path->GetObjTMAfterWSM(t,&valid);	
	}

// Reference frame is calculated as the following:
//
// X axis = tangent(t)
// Y axis = WorldZ cross X
// Z axis = X cross Y
//
// or if the 'Allow Upside Down' option us selected:
//
// X axis = tangent(t)
// Z axis = path normal cross X
// Y axis = Z cross X
//
// If roll is on then the reference frame is rotated about
// the tangent by rollamount * curviture.

#define DU			0.001f
#define BDU			0.01f
#define NUMSTEPS	5

Matrix3 PathPosition::CalcRefFrame(TimeValue t,ShapeObject *pathOb)
	{
	Interval valid;
	Matrix3 tm(1), otm = path->GetObjTMAfterWSM(t);
	float u = GetPercent(t,valid);	
	
	Point3 pt0, pt1;
	pt0 = pathOb->InterpCurve3D(t, 0, u-DU, InterpType()) * otm;
	pt1 = pathOb->InterpCurve3D(t, 0, u+DU, InterpType()) * otm;
	
	Point3 pathNorm(0,0,0);
	if (AllowFlip()) {
		// Compute the normal to the plane of the path by sampling points on the path
#define NUM_SAMPLES 20
		Point3 v[NUM_SAMPLES], cent(0,0,0);
		for (int i=0; i<NUM_SAMPLES; i++) {
			v[i] = pathOb->InterpCurve3D(t, 0, float(i)/float(NUM_SAMPLES), InterpType()) * otm;
			cent += v[i];
			}		
		cent /= float(NUM_SAMPLES);
		for (i=1; i<NUM_SAMPLES; i++) {
			pathNorm += Normalize((v[i]-cent)^(v[i-1]-cent));
			}
		pathNorm = Normalize(pathNorm);
		}

	// X
	tm.SetRow(0,Normalize(pt1-pt0));

	if (GetFlip()) tm.SetRow(0,-tm.GetRow(0));

	if (AllowFlip()) {
		// Choose Z in the plane of the path		
		// Z
		tm.SetRow(2,Normalize(tm.GetRow(0)^pathNorm));

		// Y
		tm.SetRow(1,tm.GetRow(2)^tm.GetRow(0));
	} else {
		// Choose Y in the world XY plane
		// Y
		tm.SetRow(1,Normalize(Point3(0,0,1)^tm.GetRow(0)));

		// Z
		tm.SetRow(2,tm.GetRow(0)^tm.GetRow(1));
		}

	// swap axis around	
	Point3 tmp;
	switch (GetAxis()) {
		case 1: 
			tmp = tm.GetRow(0);
			tm.SetRow(0,-tm.GetRow(1));
			tm.SetRow(1,tmp);
			break;
		case 2: 
			tmp = tm.GetRow(0);
			tm.SetRow(0,-tm.GetRow(2));
			tm.SetRow(2,tmp);
			break;
		}
		
	
	if (Bank()) {
		// Average over NUMSTEPS samples
		Point3 pt0, pt1, pt2, v0, v1;
		float cv = 0.0f;
		u -= float(NUMSTEPS/2+1)*tracking;
				
		if (!pathOb->CurveClosed(t,0)) {
			if (u+(NUMSTEPS+2)*tracking > 1.0f) u = 1.0f - (NUMSTEPS+2)*tracking;
			if (u<0.0f) u=0.0f;
			}

		pt1 = pathOb->InterpCurve3D(t, 0, u, InterpType()) * otm;
		u += tracking;		
		pt2 = pathOb->InterpCurve3D(t, 0, u, InterpType()) * otm;
		u += tracking;		
		for (int i=0; i<NUMSTEPS; i++) {			
			pt0 = pt1;
			pt1 = pt2;
			if (!pathOb->CurveClosed(t,0) && u>1.0f) {
				//pt2 += pt2 - pt1;
				break;
			} else {
				u   = (float)fmod(u,1.0f);
				pt2 = pathOb->InterpCurve3D(t, 0, u, InterpType()) * otm;
				}
			v0 = Normalize(pt2-pt1);
			v1 = Normalize(pt1-pt0);			
			v0.z = v1.z = 0.0f; // remove Z component.
			cv += (v0^v1).z * bankAmount / Length(pt1-pt0);
			u  += tracking;			
			}	
		if (i) {
			if (GetFlip()) cv = -cv;
			switch (GetAxis()) {
				case 0: tm.PreRotateX(cv/float(i)); break;
				case 1: tm.PreRotateY(cv/float(i)); break;
				case 2: tm.PreRotateZ(cv/float(i)); break;
				}
			}
		}

	return tm;
	}

void PathPosition::Update(TimeValue t)
	{
	ShapeObject *pathOb = NULL;
	ivalid = FOREVER;
	
	if (path) {
		ObjectState os = path->EvalWorldState(t);
		if (os.obj->SuperClassID()==SHAPE_CLASS_ID) {
			pathOb = (ShapeObject*)os.obj;
			if (!pathOb->NumberOfCurves()) {
				pathOb = NULL;
				}
			
			}
		ivalid &= os.Validity(t);
		}
	if (!pathOb) return;
	curval = PointOnPath(t,pathOb,ivalid);

	if (Follow()) {
		curRot = Quat(CalcRefFrame(t,pathOb));
	} else {
		curRot.Identity();
		}

	if (pathOb->CurveClosed(t,0)) {
		flags |= PATHFLAG_CLOSED;
	} else {
		flags &= ~PATHFLAG_CLOSED;
		}

	if (ivalid.Empty()) ivalid.SetInstant(t);
	}

void PathPosition::GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	if (!ivalid.InInterval(t)) {
		Update(t);
		}
	valid &= ivalid;
			 
	if (method==CTRL_RELATIVE) {
  		Matrix3 *mat = (Matrix3*)val;
		if (Follow()) {
			curRot.MakeMatrix(*mat);
			}
		mat->SetTrans(curval);		
	} else {
		*((Point3*)val) = curval;
		}
	}


RefTargetHandle PathPosition::GetReference(int i)
	{
	if (i==PATHPOS_PERCENT_REF) {
		return percent;
	} else {
		return path;
		}
	}

void PathPosition::SetReference(int i, RefTargetHandle rtarg)
	{
	if (i==PATHPOS_PERCENT_REF) {
		percent = (Control*)rtarg;
	} else {
		path = (INode*)rtarg;
		}
	}

RefResult PathPosition::NotifyRefChanged(
		Interval iv, 
		RefTargetHandle hTarg, 
		PartID& partID, 
		RefMessage msg) 
	{
	switch (msg) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hPathParams && 
				GetWindowLong(hPathParams,GWL_USERDATA)==(LONG)this &&
				ip) {
				TimeChanged(ip->GetTime());
				}
			break;
		case REFMSG_TARGET_DELETED:
			if (hTarg == path) {
				path = NULL;
				if (hPathParams && GetWindowLong(hPathParams,GWL_USERDATA)==(LONG)this) {
					SetWindowText(GetDlgItem(hPathParams,IDC_PATHNAME),
						GetString(IDS_RB_NONE));
					}
			} else 
			if (hTarg == percent) {
				percent = NULL;
				} 
			break;
		}
	return REF_SUCCEED;
	}

BOOL PathPosition::AssignController(Animatable *control,int subAnim)
	{
	ReplaceReference(PATHPOS_PERCENT_REF,(RefTargetHandle)control);
	NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE,TREE_VIEW_CLASS_ID,FALSE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);	
	return TRUE;
	}


class PickPathRestore : public RestoreObj {
	public:
		PathPosition *cont;
		PickPathRestore(PathPosition *c) {cont=c;}
		void Restore(int isUndo) {
			if (cont->editCont == cont && cont->hPathParams) {
				SetWindowText(GetDlgItem(cont->hPathParams,IDC_PATHNAME),
					GetString(IDS_RB_NONE));
				}									
			}
		void Redo() {
			if (cont->editCont == cont && cont->hPathParams && cont->path) {
				SetWindowText(GetDlgItem(cont->hPathParams,IDC_PATHNAME),
					cont->path->GetName());
				}
			}
		TSTR Description() { return TSTR(_T("Pick Path")); }
	};

BOOL PathPosition::SetPathNode(INode *node)
	{
	if (node->TestForLoop(FOREVER,this)==REF_SUCCEED) {
		theHold.Begin();
		ReplaceReference(PATHPOS_PATH_REF,(RefTargetHandle)node);
		theHold.Put(new PickPathRestore(this));
		theHold.Accept(GetString(IDS_RB_PICKPATH));
		ivalid.SetEmpty();
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		return TRUE;
	} else {
		return FALSE;
		}
	}

void PathPosition::SetTracking(float t)
	{
	tracking = t;
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

float PathPosition::GetTracking()
	{
	return tracking;
	}

void PathPosition::SetBankAmount(float a)
	{
	bankAmount = a;
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);		
	}

float PathPosition::GetBankAmount()
	{
	return bankAmount;
	}

void PathPosition::SetFollow(BOOL f)
	{
	if (f) {
		flags |= PATHFLAG_FOLLOW;
	} else {
		flags &= ~PATHFLAG_FOLLOW;
		}
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

void PathPosition::SetAllowFlip(BOOL f)
	{
	if (f) {
		flags |= PATHFLAG_ALLOWFLIP;
	} else {
		flags &= ~PATHFLAG_ALLOWFLIP;
		}
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

void PathPosition::SetConstVel(BOOL cv)
	{
	if (cv) {
		flags |= PATHFLAG_CONSTVEL;
	} else {
		flags &= ~PATHFLAG_CONSTVEL;
		}
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

void PathPosition::SetBank(BOOL b)
	{
	if (b) {
		flags |= PATHFLAG_BANK;
	} else {
		flags &= ~PATHFLAG_BANK;
		}
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);	
	}

void PathPosition::SetFlip(BOOL onOff)
	{
	if (onOff) flags |= PATHFLAG_FLIP;
	else flags &= ~PATHFLAG_FLIP;
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);	
	}

void PathPosition::SetAxis(int axis)
	{
	switch (axis) {
		case 0:
			flags &= ~PATHFLAG_YAXIS;
			flags &= ~PATHFLAG_ZAXIS;
			break;
		case 1:
			flags &= ~PATHFLAG_ZAXIS;
			flags |= PATHFLAG_YAXIS;
			break;
		case 2:
			flags |= PATHFLAG_ZAXIS;
			flags &= ~PATHFLAG_YAXIS;
			break;
		}
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

int PathPosition::GetAxis()
	{
	if (flags&PATHFLAG_YAXIS) return 1;
	if (flags&PATHFLAG_ZAXIS) return 2;
	return 0;
	}


void PathPosition::TimeChanged(TimeValue t)
	{
	if (iPerc) {
		iPerc->SetValue(100.0f*GetPercent(t,FOREVER,TRUE),FALSE);
		if (percent && percent->IsKeyAtTime(t,0)) {
			iPerc->SetKeyBrackets(TRUE);
		} else {
			iPerc->SetKeyBrackets(FALSE);
			}
		}
	}


/*--------------------------------------------------------------------*/
// PathPosition UI

HWND PathPosition::hPathParams          = NULL;
IObjParam *PathPosition::ip             = NULL;
ICustButton *PathPosition::iPick        = NULL;
PickPathMode *PathPosition::pickMode    = NULL;
ISpinnerControl *PathPosition::iBank    = NULL;
ISpinnerControl *PathPosition::iTrack   = NULL;
ISpinnerControl *PathPosition::iPerc    = NULL;
PathPosition *PathPosition::editCont    = NULL;

BOOL PickPathMode::Filter(INode *node)
	{
	if (node) {
		ObjectState os = node->EvalWorldState(0);
		if (os.obj->SuperClassID()==SHAPE_CLASS_ID) {
			SetCursor(cont->ip->GetSysCursor(SYSCUR_SELECT));
			return TRUE;
			}
		}
	return FALSE;
	}

BOOL PickPathMode::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{
	INode *node = cont->ip->PickNode(hWnd,m);
	if (node) {
		ObjectState os = node->EvalWorldState(0);
		if (os.obj->SuperClassID()==SHAPE_CLASS_ID) {
			SetCursor(cont->ip->GetSysCursor(SYSCUR_SELECT));
			return TRUE;
			}
		}
	return FALSE;
	}

BOOL PickPathMode::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	if (node) {
		ObjectState os = node->EvalWorldState(0);
		if (os.obj->SuperClassID()==SHAPE_CLASS_ID) {
			if (cont->SetPathNode(node)) {
				SetWindowText(GetDlgItem(cont->hPathParams,IDC_PATHNAME),
					node->GetName());
				
				cont->ip->SetStdCommandMode(CID_OBJMOVE);
				cont->ip->RedrawViews(cont->ip->GetTime());						
			} else {
				TSTR buf1 = GetString(IDS_RB_PATHCONTROLLER);
				TSTR buf2 = GetString(IDS_RB_ILLEGALPATH);
				MessageBox(ip->GetMAXHWnd(),buf2,buf1,MB_OK|MB_ICONEXCLAMATION);
				}
			}
		}
	return TRUE;
	}

void PickPathMode::EnterMode(IObjParam *ip)
	{cont->iPick->SetCheck(TRUE);}

void PickPathMode::ExitMode(IObjParam *ip)
	{cont->iPick->SetCheck(FALSE);}

static void SetControlStates(HWND hDlg)
	{
	BOOL follow = IsDlgButtonChecked(hDlg,IDC_PATH_FOLLOW);
	BOOL bank   = IsDlgButtonChecked(hDlg,IDC_PATH_BANK);
	
	if (follow) {
		EnableWindow(GetDlgItem(hDlg,IDC_PATH_BANK),TRUE);
		EnableWindow(GetDlgItem(hDlg,IDC_PATH_ALLOWFLIP),TRUE);
		EnableWindow(GetDlgItem(hDlg,IDC_PATH_X),TRUE);
		EnableWindow(GetDlgItem(hDlg,IDC_PATH_Y),TRUE);
		EnableWindow(GetDlgItem(hDlg,IDC_PATH_Z),TRUE);
		EnableWindow(GetDlgItem(hDlg,IDC_PATH_FLIP),TRUE);
	} else {
		EnableWindow(GetDlgItem(hDlg,IDC_PATH_BANK),FALSE);
		EnableWindow(GetDlgItem(hDlg,IDC_PATH_ALLOWFLIP),FALSE);
		EnableWindow(GetDlgItem(hDlg,IDC_PATH_X),FALSE);
		EnableWindow(GetDlgItem(hDlg,IDC_PATH_Y),FALSE);
		EnableWindow(GetDlgItem(hDlg,IDC_PATH_Z),FALSE);
		EnableWindow(GetDlgItem(hDlg,IDC_PATH_FLIP),FALSE);
		}

	if (bank && follow) {
		EnableWindow(GetDlgItem(hDlg,IDC_FOLLOW_BANKLABEL),TRUE);
		EnableWindow(GetDlgItem(hDlg,IDC_FOLLOW_BANKSPIN),TRUE);		
		EnableWindow(GetDlgItem(hDlg,IDC_FOLLOW_TRACKLABEL),TRUE);
		EnableWindow(GetDlgItem(hDlg,IDC_FOLLOW_TRACKSPIN),TRUE);
	} else {
		EnableWindow(GetDlgItem(hDlg,IDC_FOLLOW_BANKLABEL),FALSE);
		EnableWindow(GetDlgItem(hDlg,IDC_FOLLOW_BANKSPIN),FALSE);
		EnableWindow(GetDlgItem(hDlg,IDC_FOLLOW_TRACKLABEL),FALSE);
		EnableWindow(GetDlgItem(hDlg,IDC_FOLLOW_TRACKSPIN),FALSE);
		}
	}

BOOL CALLBACK PathParamDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	PathPosition *co = (PathPosition*)GetWindowLong(hDlg,GWL_USERDATA);
	if ( !co && message != WM_INITDIALOG ) return FALSE;
	switch ( message ) {             
		case WM_INITDIALOG:
			co = (PathPosition*)lParam;
			SetWindowLong( hDlg, GWL_USERDATA, (LONG)co );
			if (co->path) {
				SetWindowText(GetDlgItem(hDlg,IDC_PATHNAME),
					co->path->GetName());
			} else {
				SetWindowText(GetDlgItem(hDlg,IDC_PATHNAME),
					GetString(IDS_RB_NONE));
				}
			co->iPick = GetICustButton(GetDlgItem(hDlg,IDC_PICKPATH));
			co->iPick->SetType(CBT_CHECK);
			co->iPick->SetHighlightColor(GREEN_WASH);

			co->iBank = GetISpinner(GetDlgItem(hDlg,IDC_FOLLOW_BANKSPIN));			
			co->iBank->SetLimits(-999999,999999,FALSE);			
			co->iBank->SetScale(0.01f);
			co->iBank->LinkToEdit(GetDlgItem(hDlg,IDC_FOLLOW_BANK),EDITTYPE_FLOAT);
			co->iBank->SetValue(ToBankUI(co->bankAmount),FALSE);

			co->iTrack = GetISpinner(GetDlgItem(hDlg,IDC_FOLLOW_TRACKSPIN));			
			co->iTrack->SetLimits(0.01f,10.0f,FALSE);			
			co->iTrack->SetScale(0.01f);
			co->iTrack->LinkToEdit(GetDlgItem(hDlg,IDC_FOLLOW_TRACK),EDITTYPE_FLOAT);
			co->iTrack->SetValue(ToTrackUI(co->tracking),FALSE);
			
			co->iPerc = GetISpinner(GetDlgItem(hDlg,IDC_PATHPERCENTSPIN));
			co->iPerc->SetLimits(float(-999999999),float(999999999),FALSE);
			co->iPerc->SetScale(0.1f);
			co->iPerc->LinkToEdit(GetDlgItem(hDlg,IDC_PATHPERCENT),EDITTYPE_FLOAT);
			co->iPerc->SetValue(100.0f*co->GetPercent(co->ip->GetTime(),FOREVER,TRUE),FALSE);

			if (co->Follow()) {
				CheckDlgButton(hDlg,IDC_PATH_FOLLOW,TRUE);
			} else {
				CheckDlgButton(hDlg,IDC_PATH_FOLLOW,FALSE);
				}

			if (co->Bank()) {
				CheckDlgButton(hDlg,IDC_PATH_BANK,TRUE);
			} else {
				CheckDlgButton(hDlg,IDC_PATH_BANK,FALSE);
				}

			if (co->AllowFlip()) {
				CheckDlgButton(hDlg,IDC_PATH_ALLOWFLIP,TRUE);
			} else {
				CheckDlgButton(hDlg,IDC_PATH_ALLOWFLIP,FALSE);
				}

			CheckDlgButton(hDlg,IDC_PATH_CONSTVEL,co->ConstVel());
			
			CheckDlgButton(hDlg,IDC_PATH_FLIP,co->GetFlip());
			CheckDlgButton(hDlg,IDC_PATH_X,co->GetAxis()==0);
			CheckDlgButton(hDlg,IDC_PATH_Y,co->GetAxis()==1);
			CheckDlgButton(hDlg,IDC_PATH_Z,co->GetAxis()==2);
			
			SetControlStates(hDlg);
			return TRUE;

		case WM_LBUTTONDOWN:case WM_LBUTTONUP:	case WM_MOUSEMOVE:
			co->ip->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;

		case CC_SPINNER_BUTTONDOWN:
			if (LOWORD(wParam)==IDC_PATHPERCENTSPIN) {
				theHold.Begin();
				}
			break;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
			if (LOWORD(wParam)==IDC_PATHPERCENTSPIN) {
				if (HIWORD(wParam)) {
					theHold.Accept(GetString(IDS_RB_SETPERCENT));
				} else {
					theHold.Cancel();
					}
				}
			break;

		case CC_SPINNER_CHANGE:
			switch (LOWORD(wParam)) {
				case IDC_PATHPERCENTSPIN: {
					float v = co->iPerc->GetFVal()/100.0f;
					co->percent->SetValue(
						co->ip->GetTime(),&v);
					co->ip->RedrawViews(co->ip->GetTime());
					break;
					}

				case IDC_FOLLOW_BANKSPIN:
					co->SetBankAmount(FromBankUI(co->iBank->GetFVal()));
					co->ip->RedrawViews(co->ip->GetTime());
					break;

				case IDC_FOLLOW_TRACKSPIN:
					co->SetTracking(FromTrackUI(co->iTrack->GetFVal()));
					co->ip->RedrawViews(co->ip->GetTime());
					break;
				}
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_PICKPATH:
					co->ip->SetPickMode(co->pickMode);
					break;
				
				case IDC_PATH_X:
					co->SetAxis(0);
					co->ip->RedrawViews(co->ip->GetTime());
					break;
				case IDC_PATH_Y:
					co->SetAxis(1);
					co->ip->RedrawViews(co->ip->GetTime());
					break;
				case IDC_PATH_Z:
					co->SetAxis(2);
					co->ip->RedrawViews(co->ip->GetTime());
					break;

				case IDC_PATH_FLIP:
					co->SetFlip(IsDlgButtonChecked(hDlg,IDC_PATH_FLIP));
					co->ip->RedrawViews(co->ip->GetTime());
					break;
				
				case IDC_PATH_CONSTVEL:
					co->SetConstVel(IsDlgButtonChecked(hDlg,IDC_PATH_CONSTVEL));
					co->ip->RedrawViews(co->ip->GetTime());
					break;

				case IDC_PATH_FOLLOW:
					co->SetFollow(IsDlgButtonChecked(hDlg,IDC_PATH_FOLLOW));					
					SetControlStates(hDlg);
					co->ip->RedrawViews(co->ip->GetTime());
					break;

				case IDC_PATH_ALLOWFLIP:
					co->SetAllowFlip(IsDlgButtonChecked(hDlg,IDC_PATH_ALLOWFLIP));	
					SetControlStates(hDlg);
					co->ip->RedrawViews(co->ip->GetTime());
					break;

				case IDC_PATH_BANK:
					co->SetBank(IsDlgButtonChecked(hDlg,IDC_PATH_BANK));
					SetControlStates(hDlg);
					co->ip->RedrawViews(co->ip->GetTime());
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

void PathPosition::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{	
	this->ip = ip;
	editCont = this;
	if (flags&BEGIN_EDIT_HIERARCHY) {
		
		// No IK if follow is on
		if (Follow()) return;

		JointParamsPath *jp = (JointParamsPath*)GetProperty(PROPID_JOINTPARAMS);
		InterpCtrlUI *ui;	

		if (!jp) {
			jp = new JointParamsPath();
			SetProperty(PROPID_JOINTPARAMS,jp);
			}

		if (prev &&
			prev->ClassID()==ClassID() && 
		    (ui = (InterpCtrlUI*)prev->GetProperty(PROPID_INTERPUI))) {
			JointParams *prevjp = (JointParams*)prev->GetProperty(PROPID_JOINTPARAMS);
			prevjp->EndDialog(ui);
			ui->cont = this;
			ui->ip   = ip;
			prev->SetProperty(PROPID_INTERPUI,NULL);
			JointDlgData *jd = (JointDlgData*)GetWindowLong(ui->hParams,GWL_USERDATA);
			jd->jp = jp;
			jp->InitDialog(ui);
		} else {
			ui = new InterpCtrlUI(NULL,ip,this);
			DWORD f=0;
			if (!jp || !jp->RollupOpen()) f = APPENDROLL_CLOSED;	

			ui->hParams = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_PATHJOINTPARAMS),
				JointParamDlgProc,
				GetString(IDS_RB_PATHJOINTPARAMS), 
				(LPARAM)new JointDlgData(ui,jp),f);	
			}
	
		SetProperty(PROPID_INTERPUI,ui);		
	} else {	
		pickMode    = new PickPathMode(this);
		hPathParams = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_PATHPARAMS),
			PathParamDialogProc,
			GetString(IDS_RB_PATHPARAMS), 
			(LPARAM)this );		
		ip->RegisterDlgWnd(hPathParams);		
		ip->RegisterTimeChangeCallback(this);
		}
	SetWindowLong( hPathParams, GWL_USERDATA, (LONG)this );		
	}

void PathPosition::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	editCont = NULL;
	if (next && next->ClassID()==ClassID() && !hPathParams) return;

	if (hPathParams) {		
		ip->UnRegisterTimeChangeCallback(this);
		ip->ClearPickMode();
		delete pickMode;
		pickMode = NULL;
		ip->UnRegisterDlgWnd(hPathParams);
		ip->DeleteRollupPage(hPathParams);
		hPathParams = NULL;
	} else {
		int index = aprops.FindProperty(PROPID_INTERPUI);
		if (index>=0) {
			InterpCtrlUI *ui = (InterpCtrlUI*)aprops[index];
			if (ui->hParams) {
				ip->UnRegisterDlgWnd(ui->hParams);
				ip->DeleteRollupPage(ui->hParams);			
				}
			index = aprops.FindProperty(PROPID_INTERPUI);
			if (index>=0) {
				delete aprops[index];
				aprops.Delete(index,1);
				}
			}	
		}
	}

int PathPosition::SetProperty(ULONG id, void *data)
	{
	if (id==PROPID_JOINTPARAMS) {		
		if (!data) {
			int index = aprops.FindProperty(id);
			if (index>=0) {
				aprops.Delete(index,1);
				}
		} else {
			JointParamsPath *jp = (JointParamsPath*)GetProperty(id);
			if (jp) {
				*jp = *((JointParamsPath*)data);
				delete (JointParamsPath*)data;
			} else {
				aprops.Append(1,(AnimProperty**)&data);
				}					
			}
		return 1;
	} else
	if (id==PROPID_INTERPUI) {		
		if (!data) {
			int index = aprops.FindProperty(id);
			if (index>=0) {
				aprops.Delete(index,1);
				}
		} else {
			InterpCtrlUI *ui = (InterpCtrlUI*)GetProperty(id);
			if (ui) {
				*ui = *((InterpCtrlUI*)data);
			} else {
				aprops.Append(1,(AnimProperty**)&data);
				}					
			}
		return 1;
	} else {
		return Animatable::SetProperty(id,data);
		}
	}

void* PathPosition::GetProperty(ULONG id)
	{
	if (id==PROPID_INTERPUI || id==PROPID_JOINTPARAMS) {
		int index = aprops.FindProperty(id);
		if (index>=0) {
			return aprops[index];
		} else {
			return NULL;
			}
	} else {
		return Animatable::GetProperty(id);
		}
	}


#define JOINTPARAMPATH_CHUNK	0x1001
#define FOLLOW_CHUNK			0x1002
#define BANK_CHUNK				0x1003
#define BANKAMOUNT_CHUNK		0x1004
#define	TRACKING_CHUNK			0x1005
#define ALLOWFLIP_CHUNK			0x1006
#define CONSTVEL_CHUNK			0x1007
#define AXIS_CHUNK				0x1008
#define FLIP_CHUNK				0x1009

IOResult PathPosition::Save(ISave *isave)
	{	
	JointParamsPath *jp = (JointParamsPath*)GetProperty(PROPID_JOINTPARAMS);
	ULONG nb;

	if (jp) {
		isave->BeginChunk(JOINTPARAMPATH_CHUNK);
		jp->Save(isave);
		isave->EndChunk();
		}
	
	if (Follow()) {
		isave->BeginChunk(FOLLOW_CHUNK);		
		isave->EndChunk();
		}
	if (Bank()) {
		isave->BeginChunk(BANK_CHUNK);		
		isave->EndChunk();
		}
	if (AllowFlip()) {
		isave->BeginChunk(ALLOWFLIP_CHUNK);		
		isave->EndChunk();
		}
	if (ConstVel()) {
		isave->BeginChunk(CONSTVEL_CHUNK);		
		isave->EndChunk();
		}
	if (GetFlip()) {
		isave->BeginChunk(FLIP_CHUNK);		
		isave->EndChunk();
		}

	int axis = GetAxis();
	isave->BeginChunk(AXIS_CHUNK);		
	isave->Write(&axis,sizeof(axis),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(BANKAMOUNT_CHUNK);		
	isave->Write(&bankAmount,sizeof(bankAmount),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(TRACKING_CHUNK);		
	isave->Write(&tracking,sizeof(tracking),&nb);
	isave->EndChunk();
	
	return IO_OK;
	}

IOResult PathPosition::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case FLIP_CHUNK:
				flags |= PATHFLAG_FLIP;
				break;

			case AXIS_CHUNK: {
				int axis;
				res=iload->Read(&axis,sizeof(axis),&nb);
				SetAxis(axis);
				break;
				}				

			case CONSTVEL_CHUNK:
				flags |= PATHFLAG_CONSTVEL;
				break;

			case FOLLOW_CHUNK:
				flags |= PATHFLAG_FOLLOW;
				break;

			case BANK_CHUNK:
				flags |= PATHFLAG_BANK;
				break;

			case ALLOWFLIP_CHUNK:
				flags |= PATHFLAG_ALLOWFLIP;
				break;

			case BANKAMOUNT_CHUNK:
				res=iload->Read(&bankAmount,sizeof(bankAmount),&nb);
				break;

			case TRACKING_CHUNK:
				res=iload->Read(&tracking,sizeof(tracking),&nb);
				break;

			case JOINTPARAMPATH_CHUNK: {
				JointParamsPath *jp = new JointParamsPath;
				jp->Load(iload);
				SetProperty(PROPID_JOINTPARAMS,jp);
				break;
				}
			}		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	return IO_OK;
	}

//-------------------------------------------------------------
//
// IK
//


void PathPosition::EnumIKParams(IKEnumCallback &callback)
	{
	JointParamsPath *jp = (JointParamsPath*)GetProperty(PROPID_JOINTPARAMS);
	if (jp && jp->Active(0) && !Follow()) {
		callback.proc(this,0);
		}
	}

BOOL PathPosition::CompDeriv(TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags)
	{
	JointParamsPath *jp = (JointParamsPath*)GetProperty(PROPID_JOINTPARAMS);
	if (!jp || !jp->Active(0) || Follow()) return FALSE;
	Point3 zero(0,0,0);
	if (path) {
		ObjectState os = path->EvalWorldState(t);
		if (os.obj->SuperClassID()==SHAPE_CLASS_ID) {
			ShapeObject *pathOb = (ShapeObject*)os.obj;
			if (pathOb->NumberOfCurves()) {
				Point3 p0,p1,d;
				float per,dt=0.01f;
				percent->GetValue(t,&per,ivalid,CTRL_ABSOLUTE);
				per = (float)fmod(per,1.0f);
				if (per<0.0f) per = 1.0f + per;
				if (dt+per>1.0f) dt = -dt;
				p0 = pathOb->InterpCurve3D(t,0,per, InterpType());
				p1 = pathOb->InterpCurve3D(t,0,per+dt, InterpType());
				if (os.GetTM()) {
					p0 = p0 * (*os.GetTM());
					p1 = p1 * (*os.GetTM());
					}
				d = (p1-p0)/dt;
				for (int j=0; j<derivs.NumEndEffectors(); j++) {
					if (flags&POSITION_DERIV) {
						derivs.DP(d,j);
						}
					if (flags&ROTATION_DERIV) {
						derivs.DR(zero,j);
						}
					}
				
				derivs.NextDOF();
				ptm.SetTrans(p0);
				return TRUE;
				}
			}	
		}
	
	for (int j=0; j<derivs.NumEndEffectors(); j++) {
		if (flags&POSITION_DERIV) {
			derivs.DP(zero,j);
			}
		if (flags&ROTATION_DERIV) {
			derivs.DR(zero,j);
			}
		}
	derivs.NextDOF();
	return FALSE;
	}

float PathPosition::IncIKParam(TimeValue t,int index,float delta)
	{
	JointParamsPath *jp = (JointParamsPath*)GetProperty(PROPID_JOINTPARAMS);
	float v=0.0f;
	BOOL gotV=FALSE;
	if (fabs(delta) > 0.01f) {
		if (delta<0) delta = -0.01f;
		else delta = 0.01f;
		}
	if (jp) {		
		if (jp->Limited(0)) {			
			Interval valid;
			percent->GetValue(t,&v,valid,CTRL_ABSOLUTE);
			gotV = TRUE;
			}
		delta = jp->ConstrainInc(0,v,delta);
		}	
	// If the path is not closed, do not let it go off the end.
	if (!(flags&PATHFLAG_CLOSED)) {
		if (!gotV) {
			Interval valid;
			percent->GetValue(t,&v,valid,CTRL_ABSOLUTE);
			}
		if (v + delta < 0.0f) delta = -v;
		if (v + delta > 1.0f) delta = 1.0f-v;
		}
	percent->SetValue(t,&delta,FALSE,CTRL_RELATIVE);
	return delta;
	}

void PathPosition::ClearIKParam(Interval iv,int index) 
	{
	if (percent) percent->DeleteTime(iv,TIME_INCRIGHT|TIME_NOSLIDE);	
	}

void JointParamsPath::SpinnerChange(
		InterpCtrlUI *ui,WORD id,ISpinnerControl *spin,BOOL interactive)
	{
	float val;
	BOOL set = FALSE;

	switch (id) {
		case IDC_XFROMSPIN:
			val = min[0] = spin->GetFVal()/scale; 
			set = TRUE;
			break;
		case IDC_XTOSPIN:
			val = max[0] = spin->GetFVal()/scale;
			set = TRUE;
			break;
		
		case IDC_XDAMPINGSPIN:
			damping[0] = spin->GetFVal(); break;
		}
	
	if (set && interactive) {
		PathPosition *c = (PathPosition*)ui->cont;
 		c->percent->SetValue(ui->ip->GetTime(),&val,TRUE,CTRL_ABSOLUTE);
		ui->ip->RedrawViews(ui->ip->GetTime(),REDRAW_INTERACTIVE);
		}
	}

class PathClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new PathPosition(loading); }
	const TCHAR *	ClassName() { return GetString(IDS_RB_PATH); }
	SClass_ID		SuperClassID() { return CTRL_POSITION_CLASS_ID; }
	Class_ID		ClassID() { return PCONTROL_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
	};
static PathClassDesc pathCD;

// The following five functions are used by every plug-in DLL.
/*===========================================================================*\
 | The DLL and Library Functions
\*===========================================================================*/
// This function is called by Windows when the DLL is loaded.  This 
// function may also be called many times during time critical operations
// like rendering.  Therefore developers need to be careful what they
// do inside this function.  In the code below, note how after the DLL is
// loaded the first time only a few statements are executed.
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

	if (! controlsInit) {
		controlsInit = TRUE;
		
		// Initialize MAX's custom controls
		InitCustomControls(hInstance);
		
		// Initialize Win95 controls
		InitCommonControls();
	}
	
	return(TRUE);
	}

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int LibNumberClasses() {return 1;}

// This function return the ith class descriptor
__declspec( dllexport ) ClassDesc *LibClassDesc(int i) {
	switch(i) {
		case 0: &pathCD;
		default: return 0;
		}
	}

// This function returns a string that describes the DLL.  This string appears in 
// the File / Summary Info / Plug-In Info dialog box.
__declspec( dllexport ) const TCHAR *LibDescription() { 
	return GetString(IDS_LIB_DESC);
	}

// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\MorpherAPI\MorpherMXS\MorpherMXS.h ===
/*===========================================================================*\
 | 
 |  FILE:	MorpherMXS.h
 |			A new MAX Script Plugin that adds Morpher modifier access
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 5-4-99
 | 
\*===========================================================================*/

#include "MAXScrpt.h"

// Various MAX and MXS includes
#include "Numbers.h"
#include "MAXclses.h"
#include "Streams.h"
#include "MSTime.h"
#include "MAXObj.h"
#include "Parser.h"
#include "3DMath.h"
#include "Numbers.h"

#include "max.h"
#include "stdmat.h"

// Morpher header
#include "wm3.h"

// define the new primitives using macros from SDK
#include "definsfn.h"



BOOL check_ValidMorpher(ReferenceTarget* obj,Value** arg_list);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\MorpherAPI\MorpherMXS\MorpherMXS.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	MorpherMXS.cpp
 |			A new MAX Script Plugin that adds Morpher modifier access
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 5-4-99
 | 
\*===========================================================================*/

#include "MorpherMXS.h"




/*===========================================================================*\
 |	Define our new functions
\*===========================================================================*/

// To check whether a modifier is a valid Morpher mod
def_visible_primitive( is_morpher,				"IsValidMorpherMod");

// UI access
def_visible_primitive( wm3_refeshchannelUI,		"WM3_RefreshChannelListUI");
def_visible_primitive( wm3_refeshmcpUI,			"WM3_RefreshChannelParamsUI");
def_visible_primitive( wm3_setscrollpos,		"WM3_SetChannelPos");
def_visible_primitive( wm3_setscrollsel,		"WM3_SetChannelSel");

// Morph Channel access
def_visible_primitive( wm3_mc_bfn,				"WM3_MC_BuildFromNode");
def_visible_primitive( wm3_mc_rebuild,			"WM3_MC_Rebuild");
def_visible_primitive( wm3_mc_delete,			"WM3_MC_Delete");

def_visible_primitive( wm3_mc_getname,			"WM3_MC_GetName");
def_visible_primitive( wm3_mc_setname,			"WM3_MC_SetName");

def_visible_primitive( wm3_mc_getamount,		"WM3_MC_GetValue");
def_visible_primitive( wm3_mc_setamount,		"WM3_MC_SetValue");

def_visible_primitive( wm3_mc_hastarget,		"WM3_MC_HasTarget");
def_visible_primitive( wm3_mc_gettarget,		"WM3_MC_GetTarget");

def_visible_primitive( wm3_mc_isvalid,			"WM3_MC_IsValid");
def_visible_primitive( wm3_mc_hasdata,			"WM3_MC_HasData");

def_visible_primitive( wm3_mc_isactive,			"WM3_MC_IsActive");
def_visible_primitive( wm3_mc_setactive,		"WM3_MC_SetActive");

def_visible_primitive( wm3_mc_getuselimits,		"WM3_MC_GetUseLimits");
def_visible_primitive( wm3_mc_setuselimits,		"WM3_MC_SetUseLimits");

def_visible_primitive( wm3_mc_getlimitmax,		"WM3_MC_GetLimitMAX");
def_visible_primitive( wm3_mc_getlimitmin,		"WM3_MC_GetLimitMIN");
def_visible_primitive( wm3_mc_setlimitmax,		"WM3_MC_SetLimitMAX");
def_visible_primitive( wm3_mc_setlimitmin,		"WM3_MC_SetLimitMIN");

def_visible_primitive( wm3_mc_getvertsel,		"WM3_MC_GetUseVertexSel");
def_visible_primitive( wm3_mc_setvertsel,		"WM3_MC_SetUseVertexSel");

def_visible_primitive( wm3_mc_getmemuse,		"WM3_MC_GetMemUse");

// Lowlevel morph info access
def_visible_primitive( wm3_mc_getnumpts,		"WM3_MC_NumPts");
def_visible_primitive( wm3_mc_getnummpts,		"WM3_MC_NumMPts");
def_visible_primitive( wm3_mc_getmorphpoint,	"WM3_MC_GetMorphPoint");
def_visible_primitive( wm3_mc_getmorphweight,	"WM3_MC_GetMorphWeight");

// Cache access
def_visible_primitive( wm3_rebuildIMC,			"WM3_RebuildInternalCache");



/*===========================================================================*\
 |	Check to see if modifier is valid as a Morpher Mod
\*===========================================================================*/

BOOL check_ValidMorpher(ReferenceTarget* obj,Value** arg_list){
	if(obj->ClassID()!=Class_ID(0x17bb6854, 0xa5cba2a3)) return FALSE;
	else return TRUE;
}


/*===========================================================================*\
 |	MAXScript Plugin Initialization
\*===========================================================================*/

__declspec( dllexport ) void
LibInit() { 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\MorpherAPI\MorpherMXS\MCFunc.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	MCFunc.cpp
 |			Implimentations of the moprhChannel functions of MorpherMXS
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 5-4-99
 | 
\*===========================================================================*/

#include "MorpherMXS.h"




/*===========================================================================*\
 |	Given the <target object> from the scene, this function initializes the 
 |  channel with all necessary data
\*===========================================================================*/

Value*
wm3_mc_bfn_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_bfn, 3, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_BuildFromNode [Morpher Modifier] [Channel Index] [Target]");
	type_check(arg_list[1], Integer, "WM3_MC_BuildFromNode [Morpher Modifier] [Channel Index] [Target]");
	type_check(arg_list[2], MAXNode, "WM3_MC_BuildFromNode [Morpher Modifier] [Channel Index] [Target]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	INode *node = arg_list[2]->to_node();
	mp->ReplaceReference(101+sel,node);
	mp->chanBank[sel].buildFromNode( node );

	return &true_value;
}


/*===========================================================================*\
 |	Rebuilds optimization and morph data in this channel
 |  Use this after changing the channel's target
\*===========================================================================*/

Value*
wm3_mc_rebuild_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_rebuild, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_Rebuild [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_Rebuild [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();
	mp->chanBank[sel].rebuildChannel();

	return &true_value;
}


/*===========================================================================*\
 |	Deletes the channel
\*===========================================================================*/

Value*
wm3_mc_delete_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_delete, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_Delete [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_Delete [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	if(mp->chanBank[sel].mConnection) 
		mp->DeleteReference(101+sel);

	// Ask channel to reset itself
	mp->chanBank[sel].ResetMe();

	// Reassign paramblock info
	ParamBlockDescID *channelParams = new ParamBlockDescID[1];

	ParamBlockDescID add;
	add.type=TYPE_FLOAT;
	add.user=NULL;
	add.animatable=TRUE;
	add.id=1;
	channelParams[0] = add;

	mp->MakeRefByID(FOREVER, 1+sel, CreateParameterBlock(channelParams,1,1));	
	assert(mp->chanBank[sel].cblock);

	Control *c = (Control*)CreateInstance(CTRL_FLOAT_CLASS_ID,GetDefaultController(CTRL_FLOAT_CLASS_ID)->ClassID());

	mp->chanBank[sel].cblock->SetValue(0,0,0.0f);
	mp->chanBank[sel].cblock->SetController(0,c);

	delete channelParams;

	// Refresh system
	mp->Update_channelFULL();
	mp->Update_channelParams();	
	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);

	Interface *ip = MAXScript_interface;
	ip->RedrawViews(ip->GetTime());

	return &true_value;
}


/*===========================================================================*\
 |	Retrieves the name of the morpher channel
\*===========================================================================*/

Value*
wm3_mc_getname_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_getname, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_GetName [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_GetName [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	return new String(mp->chanBank[sel].mName);
}


/*===========================================================================*\
 |	Sets the name of the channel to be <string name>
\*===========================================================================*/

Value*
wm3_mc_setname_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_setname, 3, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_SetName [Morpher Modifier] [Channel Index] [Name String]");
	type_check(arg_list[1], Integer, "WM3_MC_SetName [Morpher Modifier] [Channel Index] [Name String]");
	type_check(arg_list[2], String, "WM3_MC_SetName [Morpher Modifier] [Channel Index] [Name String]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();
	mp->chanBank[sel].mName = arg_list[2]->to_string();
	return &true_value;
}


/*===========================================================================*\
 |	Returns the weighting value of the channel
\*===========================================================================*/

Value*
wm3_mc_getamount_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_getamount, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_GetValue [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_GetValue [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	// The value of the channel - ie, its weighted percentage
	float tmpVal;
	mp->chanBank[sel].cblock->GetValue(0, MAXScript_interface->GetTime(), tmpVal, FOREVER);

	return Float::intern(tmpVal);
}


/*===========================================================================*\
 |	Sets the weighted value of the channel
\*===========================================================================*/

Value*
wm3_mc_setamount_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_setamount, 3, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_SetValue [Morpher Modifier] [Channel Index] [Value]");
	type_check(arg_list[1], Integer, "WM3_MC_SetValue [Morpher Modifier] [Channel Index] [Value]");
	type_check(arg_list[2], Float, "WM3_MC_SetValue [Morpher Modifier] [Channel Index] [Value]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();
	mp->chanBank[sel].cblock->SetValue(0, MAXScript_interface->GetTime(), arg_list[2]->to_float());
	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);

	Interface *ip = MAXScript_interface;
	ip->RedrawViews(ip->GetTime());

	return &true_value;
}


/*===========================================================================*\
 |	Returns TRUE if the channel has an active connection to a scene object
\*===========================================================================*/

Value*
wm3_mc_hastarget_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_hastarget, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_HasTarget [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_HasTarget [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	if(mp->chanBank[sel].mConnection!=NULL) return &true_value;
	else return &false_value;
}


/*===========================================================================*\
 |	Returns a pointer to the object in the scene the channel is connected to
\*===========================================================================*/

Value*
wm3_mc_gettarget_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_gettarget, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_GetTarget [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_GetTarget [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	if(mp->chanBank[sel].mConnection!=NULL) return new MAXNode(mp->chanBank[sel].mConnection);
	else return &false_value;
}


/*===========================================================================*\
 |	Returns TRUE if the channel has not been marked as an invalid channel
\*===========================================================================*/

Value*
wm3_mc_isvalid_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_isvalid, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_IsValid [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_IsValid [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	if(!mp->chanBank[sel].mInvalid) return &true_value;
	else return &false_value;
}


/*===========================================================================*\
 |	Returns TRUE if the channel has some morpher data in it (Indicator: BLUE)
\*===========================================================================*/

Value*
wm3_mc_hasdata_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_hasdata, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_HasData [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_HasData [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	if(mp->chanBank[sel].mActive) return &true_value;
	else return &false_value;
}


/*===========================================================================*\
 |	Returns TRUE if the channel is turned on and used in the Morph
\*===========================================================================*/

Value*
wm3_mc_isactive_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_isactive, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_IsActive [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_IsActive [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	if(mp->chanBank[sel].mActiveOverride) return &true_value;
	return &false_value;
}



/*===========================================================================*\
 |	Sets wether or not the channel is used in the morph results or not
\*===========================================================================*/

Value*
wm3_mc_setactive_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_setactive, 3, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_SetActive [Morpher Modifier] [Channel Index] [true/false]");
	type_check(arg_list[1], Integer, "WM3_MC_SetActive [Morpher Modifier] [Channel Index] [true/false]");
	type_check(arg_list[2], Boolean, "WM3_MC_SetActive [Morpher Modifier] [Channel Index] [true/false]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	mp->chanBank[sel].mActiveOverride = arg_list[2]->to_bool();
	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);

	Interface *ip = MAXScript_interface;
	ip->RedrawViews(ip->GetTime());

	return &true_value;
}



/*===========================================================================*\
 |	Returns TRUE if the 'Use Limits' checkbox is on
\*===========================================================================*/

Value*
wm3_mc_getuselimits_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_getuselimits, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_GetUseLimits [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_GetUseLimits [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	if(mp->chanBank[sel].mUseLimit) return &true_value;
	return &false_value;
}


/*===========================================================================*\
 |	Turns on and off the 'Use Limits' checkbox
\*===========================================================================*/

Value*
wm3_mc_setuselimits_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_setuselimits, 3, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_SetUseLimits [Morpher Modifier] [Channel Index] [true/false]");
	type_check(arg_list[1], Integer, "WM3_MC_SetUseLimits [Morpher Modifier] [Channel Index] [true/false]");
	type_check(arg_list[2], Boolean, "WM3_MC_SetUseLimits [Morpher Modifier] [Channel Index] [true/false]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	mp->chanBank[sel].mUseLimit = arg_list[2]->to_bool();
	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);

	Interface *ip = MAXScript_interface;
	ip->RedrawViews(ip->GetTime());

	return &true_value;
}


/*===========================================================================*\
 |	Returns the upper limit for the channel values (only used if 'Use Limits' is on)
\*===========================================================================*/

Value*
wm3_mc_getlimitmax_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_getlimitmax, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_GetLimitMAX [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_GetLimitMAX [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	return Float::intern(mp->chanBank[sel].mSpinmax);
}


/*===========================================================================*\
 |	Returns the lower limit for the channel values (only used if 'Use Limits' is on)
\*===========================================================================*/

Value*
wm3_mc_getlimitmin_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_getlimitmin, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_GetLimitMIN [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_GetLimitMIN [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	return Float::intern(mp->chanBank[sel].mSpinmin);
}


/*===========================================================================*\
 |	Sets the high limit for the channel's value
\*===========================================================================*/

Value*
wm3_mc_setlimitmax_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_setlimitmax, 3, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_SetLimitMAX [Morpher Modifier] [Channel Index] [Float Value]");
	type_check(arg_list[1], Integer, "WM3_MC_SetLimitMAX [Morpher Modifier] [Channel Index] [Float Value]");
	type_check(arg_list[2], Float, "WM3_MC_SetLimitMAX [Morpher Modifier] [Channel Index] [Float Value]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	mp->chanBank[sel].mSpinmax = arg_list[2]->to_float();
	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);

	Interface *ip = MAXScript_interface;
	ip->RedrawViews(ip->GetTime());

	return &true_value;
}


/*===========================================================================*\
 |	Sets the lower limit for the channel's value
\*===========================================================================*/

Value*
wm3_mc_setlimitmin_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_setlimitmin, 3, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_SetLimitMIN [Morpher Modifier] [Channel Index] [Float Value]");
	type_check(arg_list[1], Integer, "WM3_MC_SetLimitMIN [Morpher Modifier] [Channel Index] [Float Value]");
	type_check(arg_list[2], Float, "WM3_MC_SetLimitMIN [Morpher Modifier] [Channel Index] [Float Value]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	mp->chanBank[sel].mSpinmin = arg_list[2]->to_float();
	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);

	Interface *ip = MAXScript_interface;
	ip->RedrawViews(ip->GetTime());

	return &true_value;
}


/*===========================================================================*\
 |	Returns TRUE if the 'Use Vertex Selection' button is on
\*===========================================================================*/

Value*
wm3_mc_getvertsel_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_getvertsel, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_GetUseVertexSel [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_GetUseVertexSel [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	if(mp->chanBank[sel].mUseSel) return &true_value;
	return &false_value;
}


/*===========================================================================*\
 |	Sets whether or not to use vertex selection in this channel
\*===========================================================================*/

Value*
wm3_mc_setvertsel_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_setvertsel, 3, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_SetUseVertexSel [Morpher Modifier] [Channel Index] [true/false]");
	type_check(arg_list[1], Integer, "WM3_MC_SetUseVertexSel [Morpher Modifier] [Channel Index] [true/false]");
	type_check(arg_list[2], Boolean, "WM3_MC_SetUseVertexSel [Morpher Modifier] [Channel Index] [true/false]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	mp->chanBank[sel].mUseSel = arg_list[2]->to_bool();
	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);

	Interface *ip = MAXScript_interface;
	ip->RedrawViews(ip->GetTime());

	return &true_value;
}


/*===========================================================================*\
 |	Returns an estimation of how many bytes this channel takes up in memory
\*===========================================================================*/

Value*
wm3_mc_getmemuse_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_getmemuse, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_GetMemUse [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_GetMemUse [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	float tmSize = 0.0f;
	tmSize += mp->chanBank[sel].getMemSize();

	return Float::intern(tmSize);
}


/*===========================================================================*\
 |	The actual number of points in this channel
\*===========================================================================*/

Value*
wm3_mc_getnumpts_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_getnumpts, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_NumPts [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_NumPts [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	return Integer::intern(mp->chanBank[sel].nPts);
}


/*===========================================================================*\
 |  The number of 'morphable points' in this channel
 |  'morphable points' are those that are different to the original object
\*===========================================================================*/

Value*
wm3_mc_getnummpts_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_getnummpts, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_NumMPts [Morpher Modifier] [Channel Index]");
	type_check(arg_list[1], Integer, "WM3_MC_NumMPts [Morpher Modifier] [Channel Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	return Integer::intern(mp->chanBank[sel].nmPts);
}


/*===========================================================================*\
 |	Gets a Point3 value of the <index> point in the channel
\*===========================================================================*/

Value*
wm3_mc_getmorphpoint_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_getmorphpoint, 3, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_GetMorphPoint [Morpher Modifier] [Channel Index] [Index]");
	type_check(arg_list[1], Integer, "WM3_MC_GetMorphPoint [Morpher Modifier] [Channel Index] [Index]");
	type_check(arg_list[2], Integer, "WM3_MC_GetMorphPoint [Morpher Modifier] [Channel Index] [Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	return new Point3Value(mp->chanBank[sel].mPoints[arg_list[2]->to_int()]);
}


/*===========================================================================*\
 |	Gets a floating point value of the <index> weight in the channel
\*===========================================================================*/

Value*
wm3_mc_getmorphweight_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_mc_getmorphweight, 3, count);
	type_check(arg_list[0], MAXModifier, "WM3_MC_GetMorphWeight [Morpher Modifier] [Channel Index] [Index]");
	type_check(arg_list[1], Integer, "WM3_MC_GetMorphWeight [Morpher Modifier] [Channel Index] [Index]");
	type_check(arg_list[2], Integer, "WM3_MC_GetMorphWeight [Morpher Modifier] [Channel Index] [Index]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>100) sel = 99;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();

	return Float::intern((float)mp->chanBank[sel].mWeights[arg_list[2]->to_int()]);
}


/*===========================================================================*\
 |	Resets the internal object cache, forcing a complete rebuild.
\*===========================================================================*/

Value*
wm3_rebuildIMC_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_rebuildIMC, 1, count);
	type_check(arg_list[0], MAXModifier, "WM3_RebuildInternalCache [Morpher Modifier]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();
	mp->MC_Local.NukeCache();
	mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);

	Interface *ip = MAXScript_interface;
	ip->RedrawViews(ip->GetTime());

	return &true_value;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\MorpherAPI\MorpherMXS\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			A new MAX Script Plugin that adds Morpher modifier access
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 5-4-99
 | 
\*===========================================================================*/

#include "MAXScrpt.h"


HMODULE hInstance = NULL;

BOOL APIENTRY
DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
	static BOOL controlsInit = FALSE;
	switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			// Hang on to this DLL's instance handle.
			hInstance = hModule;
			if ( !controlsInit )
			{
				controlsInit = TRUE;				
				// Initialize Win95 controls
 				InitCommonControls();
			}
			break;
	}
		
	return(TRUE);
}

__declspec( dllexport ) const TCHAR *
LibDescription() { return _T("Tex_on MAX Script SDK Example (Function)"); }

__declspec( dllexport ) ULONG
LibVersion() {  return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\MorpherAPI\Include\wM3.h ===
/*===========================================================================*\
 | 
 |  FILE:	wM3.h
 |			Weighted Morpher for MAX R3
 |			Main header file
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 22-5-98
 |			Prep'd for MorpherAPI 4-4-99
 | 
\*===========================================================================*/


#ifndef __MORPHR3__H
#define __MORPHR3__H

#define MorphExport __declspec( dllexport )


#include <Max.h>
#include <istdplug.h>
#include <meshadj.h>
#include <modstack.h>
#include <imtl.h>
#include <texutil.h>
#include <stdmat.h>
#include <macrorec.h>


static Class_ID M3MatClassID(0x4b9937e0, 0x3a1c3da4);
#define MR3_CLASS_ID		Class_ID(0x17bb6854, 0xa5cba2a3)
#define MR3_NUM_CHANNELS	100

#define MR3_MORPHERVERSION	010


// Save codes for the morphChannel class
#define MR3_POINTCOUNT		0x0100
#define MR3_SELARRAY		0x0110
#define MR3_NAME			0x0120
#define MR3_PARAMS			0x0130
#define MR3_POINTDATA_MP	0x0140
#define MR3_POINTDATA_MW	0x0150
#define MR3_POINTDATA_MD	0x0160
#define MR3_POINTDATA_MO	0x0170

// Save codes for the MorphR3 class
#define MR3_MARKERNAME		0x0180
#define MR3_MARKERINDEX		0x0185
#define MR3_MC_CHUNK		0x0190
#define MR3_MC_SUBCHUNK		0x0200
#define MR3_FLAGS			0x0210



// paramblock index table
#define PB_OV_USELIMITS		0
#define PB_OV_SPINMIN		1
#define PB_OV_SPINMAX		2
#define PB_OV_USESEL		3
#define PB_AD_VALUEINC		4
#define PB_CL_AUTOLOAD		5


// Channel operation flags
#define OP_MOVE				0
#define OP_SWAP				1


// two handy macros to set cursors for busy or normal operation
#define UI_MAKEBUSY			SetCursor(LoadCursor(NULL, IDC_WAIT));
#define UI_MAKEFREE			SetCursor(LoadCursor(NULL, IDC_ARROW));
			

// Morph Material ui defines
#define NSUBMTL 10

// Updater flags
#define UD_NORM				0
#define UD_LINK				1


class MorphR3;
class M3Mat;
class M3MatDlg;
class MCRestore;


/*===========================================================================*\
 | Morph channel manager class
 | Storage for all the morph data needed
\*===========================================================================*/

class morphChannel
{
public:

	// Construct/Destruct
	~morphChannel();
	morphChannel();

	MorphR3		*mp;

	// Number of points and morphable points
	int			nPts;
	int			nmPts;

	// Actual morphable points
	Point3*		mPoints;
	Point3*		mDeltas;
	double*		mWeights;
	// Point indicies that are different from the host
	// mesh. This is a simple but efficient way to speed up the
	// morphing process.
	int*		mOptdata;
	// BitArray to check against for point selection
	BitArray	mSel;
	// INode that we use to update and reload from, if possible
	INode*		mConnection;
	// Name for the morph channel
	TSTR		mName;

	// Various, non-animatable stuff
	// mActive is TRUE if the channel has data in it in some form
	// mModded is TRUE if the channel has been changed in SOME form.
	//		ie, had its name changed or similar
	// mUseLimit is TRUE if the channel limits are turned on
	// mSpinmin and mSpinmax are the two clamp values for channel limits
	// mUseSel is TRUE if the channel respects vertex/point selection
	BOOL		mActive, mModded, mUseLimit, mUseSel;
	float		mSpinmin,mSpinmax;

	// TRUE if the channel has been marked as bad. It will not be 
	// considered when building the morph results.
	BOOL		mInvalid;

	// Channel enabled/disabled
	BOOL		mActiveOverride;

	// paramblock for the morph channels values
	IParamBlock* cblock;
	

	// Delete and reset channel
	// Note that the paramblock needs to be manually built and wired in
	MorphExport void ResetMe();


	MorphExport void AllocBuffers( int sizeA, int sizeB );

	// Do some rough calculations about how much space this channel
	// takes up
	// This isn't meant to be fast or terribly accurate!
	MorphExport float getMemSize();


	// The rebuildChannel call will recalculate the optimization data
	// and refill the mSel selection array. This will be called each time a
	// targeted node is changed, or any of the 'Update Target' buttons is
	// pressed on the UI
	MorphExport void rebuildChannel();

	// Initialize a channel using a scene node
	MorphExport void buildFromNode( INode *node , BOOL resetTime=TRUE , TimeValue t=0 );

	// Transfer data to another channel
	MorphExport morphChannel& operator=(morphChannel& from);

	// Load/Save channel to stream
	MorphExport IOResult Save(ISave* isave);
	MorphExport IOResult Load(ILoad* iload);
};


// Internally-used local object morph cache
class morphCache
{

public:

	BOOL CacheValid;

	Point3*		oPoints;
	double*		oWeights;
	BitArray	sel;

	int		Count;

	morphCache ();
	~morphCache () { NukeCache(); }

	MorphExport void MakeCache(Object *obj);
	MorphExport void NukeCache();

	MorphExport BOOL AreWeCached();
};



/*===========================================================================*\
 | Modifer class definition
\*===========================================================================*/
class MorphR3 : public Modifier, TimeChangeCallback {
	public:

		// Access to the interface
		static IObjParam *ip;
		
		// Pointer to the morph channels
		morphChannel		*chanBank;
		
		// Currently selected channel (0-9)
		int					chanSel;
		
		// Currently viewable channel banks (0-99)
		int					chanNum;

		// Spinners from main page
		ISpinnerControl		*chanSpins[10];

		// Spinners from global settings page
		ISpinnerControl		*glSpinmin,*glSpinmax;

		// Spinners from the channel params dlg
		ISpinnerControl		*cSpinmin,*cSpinmax;

		// Global parameter block
		IParamBlock			*pblock;

		// The window handles for the 4 rollout pages
		HWND hwGlobalParams, hwChannelList,	hwChannelParams, hwAdvanced, hwLegend;

		// For the namer dialog
		ICustEdit			*newname;

		// Morph Cache
		morphCache MC_Local;

		BOOL tccI;
		char trimD[50];

		// 'Save as Current' support
		BOOL recordModifications;
		int recordTarget;


		// Marker support
		Tab<int>			markerIndex;
		NameTab				markerName;
		int					markerSel;


		// Channel operation flag for dialog use
		int					cOp;
		int					srcIdx;


		// Handles the scroll bar on the channel list UI
		MorphExport void VScroll(int code, short int cpos );
		// Clamps channel number to valid range
		MorphExport void Clamp_chanNum();

		
		MorphExport void ChannelOp(int src, int targ, int flags);


		MorphExport void Update_channelParams();


		// evaluate the value increments setting
		MorphExport float GetIncrements();
		// SetScale on the channel list spinners
		MorphExport void Update_SpinnerIncrements();

		// Functions to update the channel list dialog box:
		MorphExport void Update_colorIndicators();
		MorphExport void Update_channelNames();
		MorphExport void Update_channelValues();
		MorphExport void Update_channelLimits();
		MorphExport void Update_channelInfo();
		MorphExport void Update_channelMarkers();
		// Seperated cause this function is pretty expensive
		// Lots done, complete update - calls all functions above
		MorphExport void Update_channelFULL();
		
		// Used to trim fp values to a number of decimal points
		MorphExport float TrimDown(float value, int decimalpts);

		BOOL inRender;
};



/*===========================================================================*\
 |
 | Morph Material definitions
 |
\*===========================================================================*/

class M3MatDlg : public ParamDlg {
	public:		
		HWND hwmedit;

		IMtlParams *ip;

		M3Mat *theMtl;

		HWND hPanel; 

		ICustButton *iBut[NSUBMTL];
		ICustButton *bBut;
		ICustButton *pickBut;

		MtlDADMgr dadMgr;

		BOOL valid;

		MorphExport void VScroll(int code, short int cpos );
		MorphExport void Clamp_listSel();

		MorphExport void UpdateMorphInfo(int upFlag);
};

class M3Mat : public Mtl {	
	public:
		M3MatDlg *dlg;

		// 100 materials for 100 morph channels, plus 1 base material
		Mtl *mTex[101];
		BOOL mapOn[100];

		BOOL inRender;

		// Morph mod pointer
		MorphR3	*morphp;
		TSTR obName;

		// Temp node pointer used in the mtl pickmode
		INode *Wnode;

		IParamBlock *pblock;

		Interval ivalid;
		int listSel;
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\MorpherAPI\MorpherMXS\UIFunc.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	MCFunc.cpp
 |			Implimentations of the UI/toplevel functions of MorpherMXS
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 5-4-99
 | 
\*===========================================================================*/

#include "MorpherMXS.h"


/*===========================================================================*\
 |	Given a modifier, return TRUE if Morpher, FALSE if not
\*===========================================================================*/

Value*
is_morpher_cf(Value** arg_list, int count)
{
	check_arg_count(is_morpher, 1, count);
	type_check(arg_list[0], MAXModifier, "IsValidMorpherMod [Morpher Modifier]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	return &true_value;
}


/*===========================================================================*\
 |	Refresh the channel list UI
\*===========================================================================*/

Value*
wm3_refeshchannelUI_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_refeshchannelUI, 1, count);
	type_check(arg_list[0], MAXModifier, "WM3_RefreshChannelListUI [Morpher Modifier]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();
	mp->Update_channelFULL();

	return &true_value;
}


/*===========================================================================*\
 |	Refresh the channel parameters' UI
\*===========================================================================*/

Value*
wm3_refeshmcpUI_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_refeshmcpUI, 1, count);
	type_check(arg_list[0], MAXModifier, "WM3_RefreshChannelParamsUI [Morpher Modifier]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();
	mp->Update_channelParams();

	return &true_value;
}


/*===========================================================================*\
 |	Set the position of the scroll bar (auto-clamped by VScroll fn) (1-91)
\*===========================================================================*/

Value*
wm3_setscrollpos_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_setscrollpos, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_SetChannelPos [Morpher Modifier] [NewPos]");
	type_check(arg_list[1], Integer, "WM3_SetChannelPos [Morpher Modifier] [NewPos]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();
	mp->VScroll(SB_THUMBPOSITION,(arg_list[1]->to_int()-1));

	return &true_value;
}


/*===========================================================================*\
 |	Set which button is selected on the channel list (1-10)
\*===========================================================================*/

Value*
wm3_setscrollsel_cf(Value** arg_list, int count)
{
	check_arg_count(wm3_setscrollsel, 2, count);
	type_check(arg_list[0], MAXModifier, "WM3_SetChannelSel [Morpher Modifier] [NewSel]");
	type_check(arg_list[1], Integer, "WM3_SetChannelSel [Morpher Modifier] [NewSel]");

	ReferenceTarget* obj = arg_list[0]->to_modifier();	
	if( !check_ValidMorpher(obj,arg_list) ) return &false_value;

	int sel = arg_list[1]->to_int(); sel -= 1;
	if(sel>9) sel = 9;
	if(sel<0) sel = 0;

	MorphR3 *mp = (MorphR3*)arg_list[0]->to_modifier();
	mp->chanSel = sel;
	mp->Update_channelFULL();

	return &true_value;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\MorpherAPI\MorpherView\MorpherView.h ===
/*===========================================================================*\
 | 
 |  FILE:	MorpherView.h
 |			MorpherView Utility - demonstrates use of MorpherAPI access
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 4-4-99
 | 
\*===========================================================================*/

#ifndef __RFXUTIL__H
#define __RFXUTIL__H

#include "max.h"
#include "iparamm2.h"
#include "utilapi.h"

#include "resource.h"

// Morpher include file
#include "wm3.h"

#define	MRVUTIL_CLASSID		Class_ID(0x12877dcc, 0x78227462)


TCHAR *GetString(int id);
extern ClassDesc* GetMorpherViewDesc();



/*===========================================================================*\
 |	MorphViewUtil class defn
\*===========================================================================*/

class MorphViewUtil : public UtilityObj {
	public:

		IUtil *iu;
		Interface *ip;

		// Windows handle of our UI
		HWND hPanel;


		// For the morpher modifier pickmode
		ICustButton *pickBut,*bnode;
		INode *Wnode;

		// Our target morpher pointer
		MorphR3	*mp;


		//Constructor/Destructor
		MorphViewUtil();
		~MorphViewUtil();

		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);

		void LoadMorpherInfo( HWND hWnd );
		void LoadChannelInfo( HWND hWnd, int idx );
};

static MorphViewUtil theMVUtility;


/*===========================================================================*\
 |	Morpher modifier picker, similar to the one in the Morpher Material
\*===========================================================================*/

class GetMorphMod : 
		public PickModeCallback,
		public PickNodeCallback 
{
	public:				
		BOOL isPicking;
		MorphViewUtil *mvup;

		GetMorphMod() {
			mvup = NULL;
			isPicking=FALSE;
		}

		BOOL  HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);		
		BOOL  Pick(IObjParam *ip,ViewExp *vpt);		
		BOOL  Filter(INode *node);
		BOOL  RightClick(IObjParam *ip,ViewExp *vpt) {return TRUE;}

		void  EnterMode(IObjParam *ip);
		void  ExitMode(IObjParam *ip);		

		PickNodeCallback *GetFilter() {return this;}
};

static GetMorphMod theModPickmode;


/*===========================================================================*\
 |	Morpher target picker, same as the one used in the modifier
 |	Used to choose a node in the scene to use as a target
\*===========================================================================*/

class GetMorphTarget : 
		public PickModeCallback,
		public PickNodeCallback {
	public:				
		MorphR3 *mp;
		MorphViewUtil *mvup;
		int idx;

		BOOL isPicking;

		GetMorphTarget() {
			mp=NULL;
			isPicking=FALSE;
		}

		BOOL  HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);		
		BOOL  Pick(IObjParam *ip,ViewExp *vpt);		
		BOOL  Filter(INode *node);
		BOOL  RightClick(IObjParam *ip,ViewExp *vpt) {return TRUE;}

		void  EnterMode(IObjParam *ip);
		void  ExitMode(IObjParam *ip);		

		PickNodeCallback *GetFilter() {return this;}
		
	};

static GetMorphTarget theTargetPickMode;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\MorpherAPI\MorpherView\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			MorpherView Utility - demonstrates use of MorpherAPI access
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 4-4-99
 | 
\*===========================================================================*/

#include "MorpherView.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetMorpherViewDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\MorpherAPI\MorpherView\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MorpherView.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_LIBDESC                     4
#define IDS_CATEGORY                    5
#define IDD_MRV_UTIL                    102
#define IDD_GETMORPH                    117
#define IDC_CLOSE                       1001
#define IDC_OBJNAME                     1002
#define IDC_COMBO1                      1003
#define IDC_MCLIST                      1003
#define IDC_NPTS                        1004
#define IDC_NMPTS                       1005
#define IDC_MNAME                       1006
#define IDC_MINVALID                    1007
#define IDC_MACTIVEOVERRIDE             1008
#define IDC_MCONNECTION                 1009
#define IDC_MMODDED                     1010
#define IDC_MACTIVE                     1011
#define IDC_DEL                         1012
#define IDC_REBUILD                     1013
#define IDC_GETMEM                      1014
#define IDC_VALUE                       1015
#define IDC_GET                         1075
#define IDC_BUILDNODE                   1076
#define IDC_MODLIST                     1079

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\MorpherAPI\MorpherView\ReadMC.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	ReadMC.cpp
 |			MorpherView Utility - demonstrates use of MorpherAPI access
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 4-4-99
 | 
\*===========================================================================*/

/*===========================================================================*\
 |	This file shows how to extract data from the morphChannel class
 |	And present it in meaningful form. As well as drive the various MC functions
\*===========================================================================*/


#include "MorpherView.h"



/*===========================================================================*\
 |	Load the channels and their names out of a chosen Morpher Modifier
\*===========================================================================*/

void MorphViewUtil::LoadMorpherInfo( HWND hWnd )
{
	HWND mcList = GetDlgItem(hWnd,IDC_MCLIST);
	SendMessage(mcList,CB_RESETCONTENT,0,0);

	for(int i=0;i<100;i++)
	{
		char s[255];
		sprintf(s,"%i - %s",i+1,mp->chanBank[i].mName);
		SendMessage(mcList,CB_ADDSTRING,0,(LPARAM)s);
	}
	SendMessage(mcList,CB_SETCURSEL ,(WPARAM)0,0);
	LoadChannelInfo(hWnd,0);
}

/*===========================================================================*\
 |	Load the data out of a morph channel and display it
\*===========================================================================*/

void MorphViewUtil::LoadChannelInfo( HWND hWnd, int idx )
{
	// Channel name (mName)
	SetWindowText(GetDlgItem(hWnd,IDC_MNAME),mp->chanBank[idx].mName);

	// The two point counts, nPts and nmPts
	char s[255];
	sprintf(s,"%i",mp->chanBank[idx].nPts);
	SetWindowText(GetDlgItem(hWnd,IDC_NPTS),s);
	sprintf(s,"%i",mp->chanBank[idx].nmPts);
	SetWindowText(GetDlgItem(hWnd,IDC_NMPTS),s);

	// The various states of the channels
	SetCheckBox(hWnd,IDC_MMODDED,mp->chanBank[idx].mModded);
	SetCheckBox(hWnd,IDC_MACTIVE,mp->chanBank[idx].mActive);
	SetCheckBox(hWnd,IDC_MINVALID,!mp->chanBank[idx].mInvalid);
	SetCheckBox(hWnd,IDC_MACTIVEOVERRIDE,mp->chanBank[idx].mActiveOverride);
	SetCheckBox(hWnd,IDC_MCONNECTION,(mp->chanBank[idx].mConnection!=NULL));

	// The value of the channel - ie, its weighted percentage
	float tmpVal;
	mp->chanBank[idx].cblock->GetValue(0, ip->GetTime(), tmpVal, FOREVER);
	sprintf(s,"%.1f%%",tmpVal);
	SetWindowText(GetDlgItem(hWnd,IDC_VALUE),s);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\MorpherAPI\MorpherView\MorpherView.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	MorpherView.cpp
 |			MorpherView Utility - demonstrates use of MorpherAPI access
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 4-4-99
 | 
\*===========================================================================*/

#include "MorpherView.h"


/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class MorphViewClassDesc:public ClassDesc {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create( BOOL loading )		{ return &theMVUtility; }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return UTILITY_CLASS_ID; }
	Class_ID 		ClassID()					{ return MRVUTIL_CLASSID; }
	const TCHAR* 	Category()					{ return GetString(IDS_CATEGORY);  }
	void ResetClassParams (BOOL fileReset);
};

static MorphViewClassDesc MorpherViewCD;
ClassDesc* GetMorpherViewDesc() {return &MorpherViewCD;}

// Reset all the utility values on File/Reset
void MorphViewClassDesc::ResetClassParams (BOOL fileReset) 
{
}



/*===========================================================================*\
 |	Dialog Handler for the MorpherView Utility
\*===========================================================================*/

static BOOL CALLBACK DefaultDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	int notify = HIWORD(wParam);

	switch (msg) {
		case WM_INITDIALOG:
			theMVUtility.Init(hWnd);
			break;

		case WM_DESTROY:
			theMVUtility.Destroy(hWnd);
			break;

		case WM_COMMAND:
			
			// If the user chooses a channel from the list,
			// Ask the LoadChannelInfo fn to update the info for us
			if (notify==CBN_SELCHANGE){
				if(id==IDC_MCLIST){
					int mcSel = SendMessage(GetDlgItem(hWnd, IDC_MCLIST), CB_GETCURSEL, 0, 0);
					theMVUtility.LoadChannelInfo(hWnd,mcSel);
				}
			}

			switch (LOWORD(wParam)) {
				case IDC_CLOSE:
					theMVUtility.iu->CloseUtility();
					break;

				// Start the pick mode to get a morpher pointer
				case IDC_GET:
					{
						theModPickmode.mvup = &theMVUtility;
						theMVUtility.ip->SetPickMode(&theModPickmode);
					break;}


				// Ask the channel for a memory usage approximation
				case IDC_GETMEM:
					{
					MorphR3 *mp = theMVUtility.mp;
					int mcSel = SendMessage(GetDlgItem(hWnd, IDC_MCLIST), CB_GETCURSEL, 0, 0);

						if(mp)
						{
							float tmSize = 0.0f;
							tmSize += mp->chanBank[mcSel].getMemSize();
							char s[50];
							sprintf(s,"%i KB", (int)tmSize/1000);
							SetWindowText(GetDlgItem(hWnd,IDC_GETMEM),s);					
						}
					break;}


				// Rebuild the channel
				// If it has a INode connection, rebuild from that
				// Otherwise, just call rebuildChannel()
				case IDC_REBUILD:
					{
					MorphR3 *mp = theMVUtility.mp;
					int mcSel = SendMessage(GetDlgItem(hWnd, IDC_MCLIST), CB_GETCURSEL, 0, 0);

						if(mp)
						{
							if(mp->chanBank[mcSel].mConnection)
							{
								mp->chanBank[mcSel].buildFromNode(mp->chanBank[mcSel].mConnection);
							}
							else if(mp->chanBank[mcSel].mActive)
							{
								mp->chanBank[mcSel].rebuildChannel();
							}

							// Refresh system
							mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
							theMVUtility.ip->RedrawViews(theMVUtility.ip->GetTime());
							theMVUtility.LoadChannelInfo(hWnd,mcSel);
						}
					break;}


				// Delete a channel, and reassign it a new paramblock (necessary)
				case IDC_DEL:
					{
					MorphR3 *mp = theMVUtility.mp;
					int mcSel = SendMessage(GetDlgItem(hWnd, IDC_MCLIST), CB_GETCURSEL, 0, 0);

						if(mp)
						{
							if(mp->chanBank[mcSel].mConnection) 
								mp->DeleteReference(101+mcSel);

							// Ask channel to reset itself
							mp->chanBank[mcSel].ResetMe();

							// Reassign paramblock info
							ParamBlockDescID *channelParams = new ParamBlockDescID[1];

							ParamBlockDescID add;
							add.type=TYPE_FLOAT;
							add.user=NULL;
							add.animatable=TRUE;
							add.id=1;
							channelParams[0] = add;

							mp->MakeRefByID(FOREVER, 1+mcSel, CreateParameterBlock(channelParams,1,1));	
							assert(mp->chanBank[mcSel].cblock);

							Control *c = (Control*)CreateInstance(CTRL_FLOAT_CLASS_ID,GetDefaultController(CTRL_FLOAT_CLASS_ID)->ClassID());

							mp->chanBank[mcSel].cblock->SetValue(0,0,0.0f);
							mp->chanBank[mcSel].cblock->SetController(0,c);

							delete channelParams;

							// Refresh system
							mp->Update_channelFULL();
							mp->Update_channelParams();	
							mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
							mp->NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);
							theMVUtility.ip->RedrawViews(theMVUtility.ip->GetTime());
							theMVUtility.LoadMorpherInfo(hWnd);
							theMVUtility.LoadChannelInfo(hWnd,mcSel);
						}
					break;}


				// Pick a node from the scene, and use it to build a new channel
				// See MorphPick.cpp for code
				case IDC_BUILDNODE:
					{
					MorphR3 *mp = theMVUtility.mp;
					int mcSel = SendMessage(GetDlgItem(hWnd, IDC_MCLIST), CB_GETCURSEL, 0, 0);

						if(mp)
						{
							theTargetPickMode.mvup = &theMVUtility;
							theTargetPickMode.idx = mcSel;
							theTargetPickMode.mp = mp;
							theMVUtility.ip->SetPickMode(&theTargetPickMode);
						}
					break;}
			}
			break;


		default:
			return FALSE;
	}
	return TRUE;
}



/*===========================================================================*\
 |  Utility implimentations
\*===========================================================================*/

MorphViewUtil::MorphViewUtil()
{
	iu = NULL;
	ip = NULL;	
	hPanel = NULL;
	pickBut = NULL;
	bnode = NULL;
	Wnode = NULL;
	mp = NULL;
}

MorphViewUtil::~MorphViewUtil()
{

}

/*===========================================================================*\
 |	Load and Unload our UI panel
\*===========================================================================*/

void MorphViewUtil::BeginEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = iu;
	this->ip = ip;

	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_MRV_UTIL),
		DefaultDlgProc,
		GetString(IDS_PARAMETERS),
		0);
}
	
void MorphViewUtil::EndEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
	pickBut = NULL;
	bnode = NULL;
	Wnode = NULL;
	mp = NULL;
}


/*===========================================================================*\
 |	Initialize the UI panel - register the two custom pick buttons
\*===========================================================================*/

void MorphViewUtil::Init(HWND hWnd)
{
	pickBut = GetICustButton(GetDlgItem(hWnd,IDC_GET));
	pickBut->SetHighlightColor(GREEN_WASH);
	pickBut->SetType(CBT_CHECK);

	bnode = GetICustButton(GetDlgItem(hWnd,IDC_BUILDNODE));
	bnode->SetHighlightColor(GREEN_WASH);
	bnode->SetType(CBT_CHECK);

	hPanel = hWnd;
}


/*===========================================================================*\
 |	Unload the UI panel
\*===========================================================================*/

void MorphViewUtil::Destroy(HWND hWnd)
{
	if(pickBut)
	{
		ReleaseICustButton(pickBut);
		pickBut = NULL;
	}
	if(bnode)
	{
		ReleaseICustButton(bnode);
		bnode = NULL;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\PerVertexData\CustomVData.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	CustomVData.cpp
 |			Project to demonstrate custom data per vertex
 |			Simply allows user to define a custom value and bind it to a vertex
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 6-4-99
 | 
\*===========================================================================*/

#include "CustomVData.h"


IObjParam* CVDModifier::ip = NULL;


/*===========================================================================*\
 |	Class Descriptor OSM
\*===========================================================================*/

class CVDClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create( BOOL loading )		{ return new CVDModifier; }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return OSM_CLASS_ID; }
	Class_ID 		ClassID()					{ return CVD_CLASSID; }
	const TCHAR* 	Category()					{ return _T("");  }

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()				{ return _T("CVDMod"); }
	HINSTANCE		HInstance()					{ return hInstance; }
};

static CVDClassDesc CVDCD;
ClassDesc* GetCustomVDataDesc() {return &CVDCD;}


/*===========================================================================*\
 |	Basic implimentation of a dialog handler
\*===========================================================================*/

BOOL CVDModDlgProc::DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}


/*===========================================================================*\
 |	Paramblock2 Descriptor
\*===========================================================================*/

static ParamBlockDesc2 cvd_param_blk ( cvd_params, _T("CVDParams"),  0, &CVDCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_CUSTOMDATA, IDS_PARAMETERS, 0, 0, NULL, 
	// params
	cvd_codev,	_T("Custom Data Value"),	TYPE_FLOAT,	P_ANIMATABLE,	IDS_CVD,
		p_default,		5.0f,
		p_range, 		-900.0f, 900.0f, 
		p_ui,			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_CVD_EDIT, IDC_CVD_SPIN, 1.0f,
		end,
	end
	);



/*===========================================================================*\
 |	Constructor
 |  Ask the ClassDesc2 to make the AUTO_CONSTRUCT paramblocks and wire them in
\*===========================================================================*/

CVDModifier::CVDModifier()
	{
	CVDCD.MakeAutoParamBlocks(this);
	assert(pblock);

	// Seed the random number generator once per instance
	int rseed = randomGen.get();
	randomGen.srand(rseed);
	}



/*===========================================================================*\
 |	Invalidate our UI (or the recently changed parameter)
\*===========================================================================*/

void CVDModifier::InvalidateUI()
{
	cvd_param_blk.InvalidateUI(pblock->LastNotifyParamID());
}



/*===========================================================================*\
 |	Open and Close dialog UIs
 |	We ask the ClassDesc2 to handle Beginning and Ending EditParams for us
\*===========================================================================*/

void CVDModifier::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
{
	this->ip = ip;

	CVDCD.BeginEditParams(ip, this, flags, prev);

	cvd_param_blk.SetUserDlgProc(new CVDModDlgProc(this));
}
		
void CVDModifier::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
{
	CVDCD.EndEditParams(ip, this, flags, next);

	this->ip = NULL;
}



/*===========================================================================*\
 |	Standard clone
\*===========================================================================*/


RefTargetHandle CVDModifier::Clone(RemapDir& remap) 
{	
	CVDModifier* newmod = new CVDModifier();	
	newmod->ReplaceReference(0,pblock->Clone(remap));
	return(newmod);
}




/*===========================================================================*\
 |	Subanim & References support
\*===========================================================================*/

Animatable* CVDModifier::SubAnim(int i) 	{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
	}
TSTR CVDModifier::SubAnimName(int i) {
	switch (i) {
		case 0: return GetString(IDS_PARAMETERS);
		default: return _T("");
		}
	}

RefTargetHandle CVDModifier::GetReference(int i)
	{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
	}
void CVDModifier::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case 0: pblock = (IParamBlock2*)rtarg; break;
		}
	}
RefResult CVDModifier::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
	{
	switch (message) {
		case REFMSG_CHANGE:
			cvd_param_blk.InvalidateUI();
			break;
		}
	return REF_SUCCEED;
	}




/*===========================================================================*\
 |	The validity of our parameters
 |	Start at FOREVER, and intersect with the validity of each item
\*===========================================================================*/

Interval CVDModifier::GetValidity(TimeValue t)
{
	float f;	
	Interval valid = FOREVER;
	pblock->GetValue(cvd_codev, t, f, valid);
	return valid;
}

Interval CVDModifier::LocalValidity(TimeValue t)
{
	return GetValidity(t);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\MorpherAPI\MorpherView\MorphPick.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	MorphPick.cpp
 |			MorpherView Utility - demonstrates use of MorpherAPI access
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 4-4-99
 | 
\*===========================================================================*/

#include "MorpherView.h"



/*===========================================================================*\
 |
 | The mini-mod stack window handler, for picking a morph modifier
 |
\*===========================================================================*/


BOOL CALLBACK BindProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	MorphViewUtil *mvup = (MorphViewUtil*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!mvup && msg!=WM_INITDIALOG) return FALSE;

	int id = LOWORD(wParam);
	int notify = HIWORD(wParam);


	switch (msg) {
		case WM_INITDIALOG:{
			mvup = (MorphViewUtil*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,(LONG)mvup);

			HWND modList = GetDlgItem(hWnd,IDC_MODLIST);

			SendMessage(modList,LB_RESETCONTENT,0,0);

			POINT lpPt; GetCursorPos(&lpPt);
			SetWindowPos(hWnd, NULL, lpPt.x, lpPt.y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);

			Object *pObj = mvup->Wnode->GetObjectRef();
			IDerivedObject *pDerObj = NULL;
			Modifier *pMod = NULL;

			if( pObj->SuperClassID() == GEN_DERIVOB_CLASS_ID) 
			{
				pDerObj = (IDerivedObject *) pObj;

				for(int i = 0 ; i < pDerObj->NumModifiers() ; i++ )
				{
					pMod = pDerObj->GetModifier(i);	
					SendMessage(modList,LB_ADDSTRING,0,(LPARAM) (LPCTSTR) pMod->GetName());
				}
			}

			SendMessage(modList,LB_SETCURSEL ,(WPARAM)-1,0);

			break;}


		case WM_COMMAND:

			if (notify==LBN_SELCHANGE){
				if(id==IDC_MODLIST){
					int mkSel = SendMessage(GetDlgItem(hWnd, IDC_MODLIST), LB_GETCURSEL, 0, 0);
					if(mkSel>=0){

						Object *pObj = mvup->Wnode->GetObjectRef();
						IDerivedObject *pDerObj = NULL;
						Modifier *pMod = NULL;

						if( pObj->SuperClassID() == GEN_DERIVOB_CLASS_ID) 
						{
							pDerObj = (IDerivedObject *) pObj;
							pMod = pDerObj->GetModifier(mkSel);	
							if(pMod->ClassID() == MR3_CLASS_ID) EnableWindow(GetDlgItem(hWnd,IDOK),TRUE);
							else EnableWindow(GetDlgItem(hWnd,IDOK),FALSE);
						}


					}
				}
			}

			switch (id) {
				case IDOK:
				{
					int mkSel = SendMessage(GetDlgItem(hWnd, IDC_MODLIST), LB_GETCURSEL, 0, 0);
					if(mkSel>=0){

						Object *pObj = mvup->Wnode->GetObjectRef();
						IDerivedObject *pDerObj = NULL;
						Modifier *pMod = NULL;

						if( pObj->SuperClassID() == GEN_DERIVOB_CLASS_ID) 
						{
							pDerObj = (IDerivedObject *) pObj;
							pMod = pDerObj->GetModifier(mkSel);	

							mvup->mp = (MorphR3*)pMod;
							SetWindowText(GetDlgItem(mvup->hPanel,IDC_OBJNAME),mvup->Wnode->GetName());
							InvalidateRect(mvup->hPanel,NULL,TRUE);
							mvup->LoadMorpherInfo(mvup->hPanel);
						}


					}
				}
				case IDCANCEL:
					EndDialog(hWnd,1);
				break;
				}
			break;
		
		

		default:
			return FALSE;
		}
	return TRUE;
	}



/*===========================================================================*\
 |
 | Pickmode support
 |
\*===========================================================================*/


BOOL  GetMorphMod::Filter(INode *node)
{
	return TRUE;
}


BOOL  GetMorphMod::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
{	
	if (ip->PickNode(hWnd,m,this)) {
		return TRUE;
	} else {
		return FALSE;
		}
}

BOOL  GetMorphMod::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();

	if (node) {

		mvup->Wnode = node;

		int res = DialogBoxParam( 
			hInstance, 
			MAKEINTRESOURCE( IDD_GETMORPH ),
			GetDlgItem(mvup->hPanel,IDC_GET),
			(DLGPROC)BindProc,
			(LPARAM)(MorphViewUtil*)mvup);

	}
	
	return TRUE;
}


void  GetMorphMod::EnterMode(IObjParam *ip)
{
	isPicking=TRUE;
	if (mvup->pickBut) mvup->pickBut->SetCheck(TRUE);
}

void  GetMorphMod::ExitMode(IObjParam *ip)
{
	isPicking=FALSE;
	if (mvup->pickBut) mvup->pickBut->SetCheck(FALSE);
}






/*===========================================================================*\
 |
 | The pickmode for choosing nodes out of the scene to use as targets
 |
\*===========================================================================*/


BOOL  GetMorphTarget::Filter(INode *node)
{
	Interval valid; 
	
	ObjectState os = node->GetObjectRef()->Eval(mvup->ip->GetTime());

	if( os.obj->IsDeformable() == FALSE ) return FALSE;

	// Check for same-num-of-verts-count
	if( os.obj->NumPoints()!=mp->MC_Local.Count) return FALSE;

	node->BeginDependencyTest();
	mp->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
	if (node->EndDependencyTest()) {		
		return FALSE;
	} else {
		return TRUE;
		
		}
}


BOOL  GetMorphTarget::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
{	
	if (mvup->ip->PickNode(hWnd,m,this)) {
		return TRUE;
	} else {
		return FALSE;
		}
}

BOOL  GetMorphTarget::Pick(IObjParam *ip,ViewExp *vpt)
	{
	
	INode *node = vpt->GetClosestHit();
	if (node) {
		// Make the node reference, and then ask the channel to load itself

		UI_MAKEBUSY

		mp->ReplaceReference(101+idx,node);
		mp->chanBank[idx].buildFromNode(node);
		mvup->LoadMorpherInfo(mvup->hPanel);

		UI_MAKEFREE
	}
	
	return TRUE;
}


void  GetMorphTarget::EnterMode(IObjParam *ip)
{
	isPicking=TRUE;
	if (mvup->bnode) mvup->bnode->SetCheck(TRUE);
}

void  GetMorphTarget::ExitMode(IObjParam *ip)
{
	isPicking=FALSE;
	if (mvup->bnode) mvup->bnode->SetCheck(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\PerVertexData\ApplyCustom.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	ApplyCustom.cpp
 |			Project to demonstrate custom data per vertex
 |			Simply allows user to define a custom value and bind it to a vertex
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 6-4-99
 | 
\*===========================================================================*/

#include "CustomVData.h"



/*===========================================================================*\
 |	ModifyObject will do all the work in a full modifier
\*===========================================================================*/

#define MY_CHANNEL		5


void CVDModifier::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
{
	if (!os->obj->IsSubClassOf(triObjectClassID)) return;

	// Get a mesh from input object
	TriObject *tobj = (TriObject*)os->obj;
	Mesh* mesh = &tobj->GetMesh();
	int numVert = mesh->getNumVerts();

	// Get parameters from pblock
	float sparam = 0.0f; 
	Interval valid = FOREVER;
	pblock->GetValue(cvd_codev, t, sparam, valid);

		// Take over the channel, realloc with size == number of verts
		mesh->setVDataSupport(MY_CHANNEL,TRUE);

		// Get a pointer back to the floating point array
		float *vdata = mesh->vertexFloat(MY_CHANNEL);
		if(vdata)
		{
			// loop through all verticies
			// Ask the random number generator for a value bound to the
			//	paramblock value
			// and encode it into the vertex.
			for(int i=0;i<numVert;i++)
			{
				vdata[i] = randomGen.getf(sparam);
			}
		}

}



/*===========================================================================*\
 |	NotifyInputChanged is called each time the input object is changed in some way
 |	We can find out how it was changed by checking partID and message
\*===========================================================================*/

void CVDModifier::NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc)
{
	if( (partID&PART_TOPO) || (partID&PART_GEOM) || (partID&PART_SELECT) )
	{
		NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\PerVertexData\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CustomVData.rc
//
#define IDS_CLASSNAME                   1
#define IDC_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_LIBDESC                     4
#define IDS_SIMPLE                      5
#define IDS_COLORV                      6
#define IDS_VDATA                       7
#define IDS_CVD                         8
#define IDD_SKELETON_PMOD               101
#define IDD_CUSTOMDATA                  101
#define IDC_SIMPLE_EDIT                 1004
#define IDC_CVD_EDIT                    1004
#define IDC_SIMPLE_SPIN                 1006
#define IDC_CVD_SPIN                    1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\PerVertexData\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Project to demonstrate custom data per vertex
 |			Simply allows user to define a custom value and bind it to a vertex
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 6-4-99
 | 
\*===========================================================================*/

#include "CustomVData.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetCustomVDataDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\PerVertexData\TestExporter\ConfigMgr.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	ConfigMgr.cpp
 |			Skeleton project and code for a Scene Exporter 
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 26-3-99
 | 
\*===========================================================================*/
/*===========================================================================*\
 |	Config manager from the Skeleton Exporter - just saves the radio button status
\*===========================================================================*/


#include "CVDExport.h"


// change the name when using this skeleton
#define		CFG_FILENAME		"cvd_export.cfg"
#define		CFG_VERSION			0x001


/*===========================================================================*\
 |  Get the config file's full name on the disk
\*===========================================================================*/

TSTR CVDExporter::GetConfigFilename()
{
	TSTR filename;
	
	filename += ip->GetDir(APP_PLUGCFG_DIR);
	filename += "\\";
	filename += CFG_FILENAME;

	return filename;
}

/*===========================================================================*\
 |  Load and save the values
\*===========================================================================*/

void CVDExporter::SaveExporterConfig()
{
	// Open the configuration file for writing
	TSTR filename = GetConfigFilename();
	FILE* cfgStream;

	cfgStream = fopen(filename, "wb");
	if (!cfgStream)
		return;

	// Write CFG version
	_putw(CFG_VERSION,				cfgStream);

	_putw(searchtype,				cfgStream);

	fclose(cfgStream);
}


BOOL CVDExporter::LoadExporterConfig()
{
	// Open the configuration file for reading
	TSTR filename = GetConfigFilename();

	// If the file doesn't exist yet, write out the defaults
	if(!DoesFileExist(filename)) SaveExporterConfig();


	FILE* cfgStream;

	cfgStream = fopen(filename, "rb");
	if (!cfgStream)
		return FALSE;

	// First item is a file version
	int fileVersion = _getw(cfgStream);

	if (fileVersion > CFG_VERSION) {
		// Unknown version
		fclose(cfgStream);
		return FALSE;
	}

	searchtype = _getw(cfgStream);

	fclose(cfgStream);

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\PerVertexData\CustomVData.h ===
/*===========================================================================*\
 | 
 |  FILE:	CustomVData.h
 |			Project to demonstrate custom data per vertex
 |			Simply allows user to define a custom value and bind it to a vertex
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 6-4-99
 | 
\*===========================================================================*/

#ifndef __CVDSKEL__H
#define __CVDSKEL__H

#include "max.h"
#include "iparamm2.h"
#include "istdplug.h"
#include "meshadj.h"
#include "modstack.h"
#include "macrorec.h"
#include "random.h"
#include "resource.h"


#define	CVD_CLASSID		Class_ID(0x4fd31c27, 0xa9323c7)


TCHAR *GetString(int id);
extern ClassDesc* GetCustomVDataDesc();


// Paramblock2 name
enum { cvd_params, }; 
// Paramblock2 parameter list
enum { cvd_codev, };



/*===========================================================================*\
 |	CVDModifier class defn
\*===========================================================================*/

class CVDModifier : public Modifier{
	public:

		// Access to the interface
		static IObjParam *ip;

		// Global parameter block
		IParamBlock2	*pblock;

		// Our random number generator
	    Random  randomGen;


		//Constructor/Destructor
		CVDModifier();
		~CVDModifier() {}
		void DeleteThis() { delete this; }


		// Plugin identification
		void GetClassName(TSTR& s) { s= TSTR(GetString(IDS_CLASSNAME)); }  
		virtual Class_ID ClassID() { return CVD_CLASSID;}		
		TCHAR *GetObjectName() { return GetString(IDS_CLASSNAME); }


		// Defines the behavior for this modifier
		// This is currently setup to be basic geometry 
		// modification of deformable objects
		ChannelMask ChannelsUsed()  { return PART_GEOM|PART_TOPO; }
		ChannelMask ChannelsChanged() { return PART_GEOM|PART_TOPO; }
		Class_ID InputType() { return triObjectClassID; }
		BOOL ChangeTopology() {return FALSE;}


		// Calculate the local validity from the parameters
		Interval LocalValidity(TimeValue t);
		Interval GetValidity(TimeValue t);


		// Object modification and notification of change
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		void NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc);


		// Reference support
		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		
		// SubAnim support
		int NumSubs() { return 1; }
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);


		// Direct paramblock access
		int	NumParamBlocks() { return 1; }	
		IParamBlock2* GetParamBlock(int i) { return pblock; }
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; }
		int GetParamBlockIndex(int id) {return id;}

		// Does not use createmouse callbacks
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}

		// Load and unload our UI
		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);
		void InvalidateUI();
};


/*===========================================================================*\
 |	Dialog Processor
\*===========================================================================*/

class CVDModDlgProc : public ParamMap2UserDlgProc 
{
	public:
		CVDModifier *cvdm;

		CVDModDlgProc() {}
		CVDModDlgProc(CVDModifier *cvdm_in) { cvdm = cvdm_in; }

		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { }

		void SetThing(ReferenceTarget *m) {
			cvdm = (CVDModifier*)m;
			}

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\PerVertexData\TestExporter\CVDExport.h ===
/*===========================================================================*\
 | 
 |  FILE:	CVDExport.h
 |			A simple exporter that scans the scene for our custom data
 |			and if found, exports it to an ASCII file
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 16-4-99
 | 
\*===========================================================================*/
/*===========================================================================*\
 |	Most of this project is a converted Skeleton Exporter
 |	The main functionality and the area of most interest is in DoExport.cpp
\*===========================================================================*/


#ifndef __CVDEXP__H
#define __CVDEXP__H

#include "max.h"
#include "resource.h"
#include "iparamm2.h"
#include "modstack.h"


#define	CVDEXP_CLASSID		Class_ID(0x3e816f85, 0x92f7904)


TCHAR *GetString(int id);
extern ClassDesc* GetCVDExportDesc();

/*===========================================================================*\
 |	CVDExporter class defn
\*===========================================================================*/

class CVDExporter : public SceneExport {
public:
	CVDExporter();
	~CVDExporter();

	// Preferences values
	int searchtype;

	// Used in DoExport
	BOOL exportSelected;
	FILE *fileStream;
	Interface* ip;



	// Number of extensions we support
	int ExtCount();
	const TCHAR * Ext(int n);

	// The bookkeeping functions
	const TCHAR * LongDesc();
	const TCHAR * ShortDesc();
	const TCHAR * AuthorName();
	const TCHAR * CopyrightMessage();
	const TCHAR * OtherMessage1();
	const TCHAR * OtherMessage2();

	// Version number of this exporter
	unsigned int Version();

	// Show an about box
	void ShowAbout(HWND hWnd);

	// Do the actual export
	int DoExport(const TCHAR *name,ExpInterface *ei,Interface *i, BOOL suppressPrompts=FALSE, DWORD options=0);

	// Returns whether we support the extended exporter options
	BOOL SupportsOptions(int ext, DWORD options);

	// Scene enumeration
	BOOL nodeEnum(INode* node,Interface *ip);


	// Configuration file management
	BOOL LoadExporterConfig();
	void SaveExporterConfig();
	TSTR GetConfigFilename();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\PerVertexData\TestExporter\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			A simple exporter that scans the scene for our custom data
 |			and if found, exports it to an ASCII file
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 16-4-99
 | 
\*===========================================================================*/

#include "CVDExport.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetCVDExportDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\PerVertexData\TestExporter\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CVDExport.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_SEARCH                      3
#define IDS_LIBDESC                     4
#define IDS_EXT_01                      5
#define IDS_SHORTDESC                   6
#define IDS_LONGDESC                    7
#define IDS_AUTHOR                      8
#define IDS_COPYRIGHT                   9
#define IDD_CVDEXP                      101
#define IDD_ABOUT                       102
#define IDC_OK                          1001
#define IDC_CANCEL                      1002
#define IDC_SEARCH1                     1003
#define IDC_SEARCH2                     1004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\ScriptPlugin\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Utility that accesses a scripted plugin's parameters
 |			Demonstrates SDK -> MAX Script plugins techniques
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 7-4-99
 | 
\*===========================================================================*/

#include "Utility.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSCPUtilDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\PerVertexData\TestExporter\CVDExport.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	CVDExport.cpp
 |			A simple exporter that scans the scene for our custom data
 |			and if found, exports it to an ASCII file
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 16-4-99
 | 
\*===========================================================================*/

#include "CVDExport.h"




/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class CVDExportClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()				{ return TRUE; }
	void *			Create( BOOL loading )	{ return new CVDExporter; }
	const TCHAR *	ClassName()				{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()			{ return SCENE_EXPORT_CLASS_ID; }
	Class_ID 		ClassID()				{ return CVDEXP_CLASSID; }
	const TCHAR* 	Category()				{ return _T("");  }

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()			{ return _T("CVDExporter"); }
	HINSTANCE		HInstance()				{ return hInstance; }
};

static CVDExportClassDesc CVDExportCD;
ClassDesc* GetCVDExportDesc() {return &CVDExportCD;}



/*===========================================================================*\
 |	Basic implimentation of a dialog handler
\*===========================================================================*/

static BOOL CALLBACK CustomDialogHandler(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}



/*===========================================================================*\
 |  Constructor/Destructor - just initialize any variables or memory
\*===========================================================================*/

CVDExporter::CVDExporter()
{
	searchtype = 1;
}

CVDExporter::~CVDExporter()
{
}

/*===========================================================================*\
 |  Return how many extensions we support, and what they are
\*===========================================================================*/

int CVDExporter::ExtCount() { return 1; }

const TCHAR * CVDExporter::Ext(int n)
{
	switch(n) {
		case 0:
			return GetString(IDS_EXT_01);
		}
	return _T("");

}


/*===========================================================================*\
 |  Return various information about our scene exporter
\*===========================================================================*/

const TCHAR * CVDExporter::LongDesc()
{
	return GetString(IDS_LONGDESC);
}

const TCHAR * CVDExporter::ShortDesc()
{
	return GetString(IDS_SHORTDESC);
}

const TCHAR * CVDExporter::AuthorName()
{
	return GetString(IDS_AUTHOR);
}

const TCHAR * CVDExporter::CopyrightMessage()
{
	return GetString(IDS_COPYRIGHT);
}

const TCHAR * CVDExporter::OtherMessage1() { return _T(""); }
const TCHAR * CVDExporter::OtherMessage2() { return _T(""); }

// Version number = (version * 100)
unsigned int CVDExporter::Version()
{
	return 100;
}



/*===========================================================================*\
 |  Show about box
\*===========================================================================*/

static BOOL CALLBACK AboutDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	CVDExporter *se = (CVDExporter*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!se && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG:	
			// Update class pointer
			se = (CVDExporter*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_DESTROY:
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_OK:
					EndDialog(hWnd,1);
				break;
			}
			break;

		default:
			return FALSE;
		}	
	return TRUE;
	}

void CVDExporter::ShowAbout(HWND hWnd)
{
	DialogBoxParam(
		hInstance,
		MAKEINTRESOURCE(IDD_ABOUT),
		hWnd,
		AboutDlgProc,
		(LPARAM)this);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\ScriptPlugin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ScP_Read.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_LIBDESC                     4
#define IDS_CATEGORY                    5
#define IDD_SKELUTIL                    102
#define IDD_SCPLUTIL                    102
#define IDC_BTN1                        1000
#define IDC_CLOSE                       1001
#define IDC_GM1                         1003
#define IDC_GM2                         1004
#define IDC_DIFFUSE                     1702

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\PerVertexData\TestExporter\DoExport.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	DoExport.cpp
 |			A simple exporter that scans the scene for our custom data
 |			and if found, exports it to an ASCII file
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 16-4-99
 | 
\*===========================================================================*/
/*===========================================================================*\
 |	This is where all the finding of exportable Custom Vertex Data gets done
 |	All the main processing is done on each node during the enumeration
\*===========================================================================*/


#include "CVDExport.h"


/*===========================================================================*\
 |  Determine what options we support
\*===========================================================================*/

BOOL CVDExporter::SupportsOptions(int ext, DWORD options)
{
	switch(ext) {
		case 0:
			if(options & SCENE_EXPORT_SELECTED) return TRUE;
			else return FALSE;
			break;
		}
	return FALSE;
}



/*===========================================================================*\
 |  Preferences dialog handler
\*===========================================================================*/

static BOOL CALLBACK PrefsDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	CVDExporter *se = (CVDExporter*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!se && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG:	
			// Update class pointer
			se = (CVDExporter*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);

			// Setup preferences initial state
			SetCheckBox(hWnd,IDC_SEARCH1+se->searchtype,TRUE);
			break;

		case WM_DESTROY:
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CANCEL:
					EndDialog(hWnd,1);
					break;

				case IDC_OK:
					// Retrieve preferences
					se->searchtype = GetCheckBox(hWnd,IDC_SEARCH1)?0:1;

					EndDialog(hWnd,0);
				break;
			}
			break;

		default:
			return FALSE;
		}	
	return TRUE;
} 



/*===========================================================================*\
 |  For every node we get, try and find some custom data
 |	'channel' method will just see if the channel needed is present
 |	'modifier' method will see if the modifier exists in the modstack 
\*===========================================================================*/

// from the CVD exporter
#define MY_CHANNEL		5

BOOL CVDExporter::nodeEnum(INode* node,Interface *ip) 
{
	if(exportSelected && node->Selected() == FALSE)
		return TREE_CONTINUE;

	// Check for user cancel
	if (ip->GetCancel())
		return FALSE;


	if(!exportSelected || node->Selected()) 
	{
		// Check to see if we can see the modifier first
		if(searchtype==0)
		{
			fprintf(fileStream, "Checking Node : %s\n",node->GetName());

			BOOL foundMod = FALSE;

			// Get an object reference from the node
			Object *pObj = node->GetObjectRef();
			IDerivedObject *pDerObj = NULL;
			Modifier *pMod = NULL;

			// Is it a derived object?
			if( pObj->SuperClassID() == GEN_DERIVOB_CLASS_ID) 
			{
				pDerObj = (IDerivedObject *) pObj;

				// Cycle through modifiers, looking for ours by Class_ID
				for(int i = 0 ; i < pDerObj->NumModifiers() ; i++ )
				{
						pMod = pDerObj->GetModifier(i);
						if(pMod->ClassID()==Class_ID(0x4fd31c27, 0xa9323c7)) foundMod = TRUE;
				}
			}

			// Did we find a modifier we can use?
			if(foundMod)
			{
				// Collapse object to usable TriObject mesh
				ObjectState os = node->EvalWorldState(ip->GetTime());
				if (os.obj->SuperClassID()==GEOMOBJECT_CLASS_ID 
					&& os.obj->IsRenderable() 
					&& os.obj->IsDeformable()) 
				{
					TriObject *tobj = (TriObject *)os.obj;
					Mesh* mesh = &tobj->GetMesh();
					int numVert = mesh->getNumVerts();

					// Check for channel existance
					if(mesh->vDataSupport(MY_CHANNEL))
					{
						// Get the float array of values
						float *outDV = mesh->vertexFloat(MY_CHANNEL);
						for(int i=0;i<numVert;i++)
						{
							fprintf(fileStream, "Vertex %i : CVD [%.2f]\n",i,outDV[i]);
						}
					}
				}

			}
			fprintf(fileStream, "\n");
		}
		// Do a channel search instead - just collapse and check channel
		// You could change the value of MY_CHANNEL to be 0 and use a channel
		// search to dump out the soft selection of the nodes in the scene (for example)
		else
		{
			fprintf(fileStream, "Checking Node : %s, Channel %i\n",node->GetName(),MY_CHANNEL);
				
			ObjectState os = node->EvalWorldState(ip->GetTime());
			if (os.obj->SuperClassID()==GEOMOBJECT_CLASS_ID 
				&& os.obj->IsRenderable() 
				&& os.obj->IsDeformable()) 
			{
				TriObject *tobj = (TriObject *)os.obj;
				Mesh* mesh = &tobj->GetMesh();
				int numVert = mesh->getNumVerts();

				if(mesh->vDataSupport(MY_CHANNEL))
				{
					float *outDV = mesh->vertexFloat(MY_CHANNEL);
					for(int i=0;i<numVert;i++)
					{
						fprintf(fileStream, "Vertex %i : CVD [%.2f]\n",i,outDV[i]);
					}
				}
			}

			fprintf(fileStream, "\n");
		}
	}


	// Recurse through this node's children, if any
	for (int c = 0; c < node->NumberOfChildren(); c++) {
		if (!nodeEnum(node->GetChildNode(c), ip))
			return FALSE;
	}


	return TRUE;
}



/*===========================================================================*\
 |  Do the export to the file
\*===========================================================================*/

int	CVDExporter::DoExport(const TCHAR *name,ExpInterface *ei,Interface *i, BOOL suppressPrompts, DWORD options)
{
	// Set local interface pointer
	ip = i;

	// load the configuration from disk
	// so that it can be used in our dialog box
	if(!LoadExporterConfig()) return 0;

	if(!suppressPrompts)
	{

		// Show preferences setup dialog
		int res = DialogBoxParam(
			hInstance,
			MAKEINTRESOURCE(IDD_CVDEXP),
			i->GetMAXHWnd(),
			PrefsDlgProc,
			(LPARAM)this);

		// User clicked 'Cancel'
		if(res!=0) return 0;

	}

	exportSelected = (options & SCENE_EXPORT_SELECTED) ? TRUE : FALSE;


	// Open a filestream for writing out to
	fileStream = _tfopen(name,_T("wt"));
	if (!fileStream) {
		return 0;
	}


	// Print out a title for the file header
	fprintf(fileStream, "Results of the Custom Data Per Vertex Search\n");

	// Print out the state of the search parameter
	fprintf(fileStream, "Search Type Chosen: %s\n\n", searchtype?"Channel":"Modifier");


	// Simple root node -> children enumeration
	// This will get the root node, and then cycle through its children (ie, the basic scene nodes)
	// It will then recurse to search their children, and then their children, etc
	int numChildren = i->GetRootNode()->NumberOfChildren();

	for (int idx=0; idx<numChildren; idx++) {
		if (i->GetCancel())
			break;
		nodeEnum(i->GetRootNode()->GetChildNode(idx), i);
	}

	fclose(fileStream);


	// Save the current configuration back out to disk
	// for use next time the exporter is run
	SaveExporterConfig();


	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\ScriptPlugin\Utility.h ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Utility that accesses a scripted plugin's parameters
 |			Demonstrates SDK -> MAX Script plugins techniques
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 7-4-99
 | 
\*===========================================================================*/
/*===========================================================================*\
 |	Please read the notes/techniques text in ScP_Read.cpp for more info
\*===========================================================================*/


#ifndef __SCPUTIL__H
#define __SCPUTIL__H

#include "max.h"
#include "iparamm2.h"
#include "iparamb2.h"
#include "utilapi.h"

#include "resource.h"


// Utility class ID
#define	SCPUTIL_CLASSID		Class_ID(0x2cb46e2a, 0x48ba025f)

// GameMtl class ID
#define GAMEMTL_CLASSID		Class_ID(0x67296df6, 0)


TCHAR *GetString(int id);
extern ClassDesc* GetSCPUtilDesc();



/*===========================================================================*\
 |	SCPUtility class defn
\*===========================================================================*/

class SCPUtility : public UtilityObj {
	public:

		IUtil *iu;
		Interface *ip;

		// Windows handle of our UI
		HWND hPanel;
		IColorSwatch *cs;

		//Constructor/Destructor
		SCPUtility();
		~SCPUtility();

		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);
};

static SCPUtility theSCPUtil;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Atmospheric\Atmospheric.h ===
/*===========================================================================*\
 | 
 |  FILE:	Atmospheric.h
 |			Skeleton project and code for a Atmospheric effect
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 31-3-99
 | 
\*===========================================================================*/

#ifndef __RFXSKEL__H
#define __RFXSKEL__H

#include "max.h"
#include <bmmlib.h>
#include "iparamm2.h"
#include "render.h"  
#include "texutil.h"
#include "gizmo.h"
#include "gizmoimp.h"
#include "istdplug.h"
#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	ATMOS_CLASSID		Class_ID(0x76433eca, 0x79ed048b)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonAtmosDesc();


// Paramblock2 name
enum { skatmos_params, }; 
// Paramblock2 parameter list
enum { skatmos_simple_param, skatmos_gizmos, };


/*===========================================================================*\
 |	Validator class for ParamBlock2
\*===========================================================================*/

class SkeletonAtmospheric;

class GizmoValidatorClass : public PBValidator
{
	public:
		SkeletonAtmospheric *atp;
	private:
		BOOL Validate(PB2Value &v);
};


/*===========================================================================*\
 |	SkeletonAtmospheric class defn
\*===========================================================================*/

class SkeletonAtmospheric : public Atmospheric {
	public:
		// Parameters
		IParamBlock2 *pblock; 
		GizmoValidatorClass validator;

		SkeletonAtmospheric();
		~SkeletonAtmospheric() {}
		void DeleteThis() {delete this;}

		// SubAnim support
		int NumSubs() {return 1;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		
		// Reference support
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message);

		// Direct paramblock access
		int	NumParamBlocks() { return 1; }	
		IParamBlock2* GetParamBlock(int i) { return pblock; }
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; }

		// Plugin identification
		Class_ID ClassID() {return ATMOS_CLASSID;}
		void GetClassName(TSTR& s) {s=GetString(IDS_CLASSNAME);}
		TSTR GetName() {return GetString(IDS_CLASSNAME);}


		// Create our UI
		AtmosParamDlg *CreateParamDialog(IRendParams *ip);


		// Called before and after rendering time
		int RenderBegin(TimeValue t, ULONG flags);
		int RenderEnd(TimeValue t);


		// Doing the actual rendering 
		void Update(TimeValue t, Interval& valid);
		void Shade(ShadeContext& sc,const Point3& p0,const Point3& p1,Color& color, Color& trans, BOOL isBG);


		// Support for gizmos in our atmospheric
		int NumGizmos() ;
		INode *GetGizmo(int i);
		void DeleteGizmo(int i);
		void InsertGizmo(int i, INode *node);
		void AppendGizmo(INode *node);
		BOOL OKGizmo(INode *node); 
 		void EditGizmo(INode *node);
};



/*===========================================================================*\
 |	Dialog Processor
\*===========================================================================*/

class SkeletonAtmosDlgProc : public ParamMap2UserDlgProc 
{
	public:
		SkeletonAtmospheric *ska;

		SkeletonAtmosDlgProc() {}
		SkeletonAtmosDlgProc(SkeletonAtmospheric *ska_in) { ska = ska_in; }

		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { }

		void SetThing(ReferenceTarget *m) {
			ska = (SkeletonAtmospheric*)m;
			}

};


/*===========================================================================*\
 |	Parammap handler
\*===========================================================================*/

class SkelAtmosParamDlg : public AtmosParamDlg 
{
	public:
		SkeletonAtmospheric *atmos;
		IRendParams *ip;
		IParamMap2 *pmap;

		SkelAtmosParamDlg(IRendParams *i,SkeletonAtmospheric *a);
		Class_ID ClassID() {return ATMOS_CLASSID;}
		ReferenceTarget* GetThing() {return atmos;}
		void SetThing(ReferenceTarget *m);		
		void DeleteThis();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Examples\ScriptPlugin\ScP_Read.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	ScP_Read.cpp
 |			Utility that accesses a scripted plugin's parameters
 |			Demonstrates SDK -> MAX Script plugins techniques
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 7-4-99
 | 
\*===========================================================================*/

/*===========================================================================*\
 |
 |	NOTES:
 |	
 |	The scripted plugin MS code is found at the bottom of this CPP file - 
 |	copy and paste it into MAX Script while running R3, assign a new GameMtl
 |	to an object and then run this utility. Choosing the assigned material
 |	will load its custom values out using ParamBlock2 methods and display them
 |	in the interface.
 |
 |
 |	TECHNIQUE:
 |
 |	This is a simple example of accessing Scripted Plugins using the SDK. One
 |	of the main principles is that you, the developer, will probably know exactly
 |	how your scripted plugin is built so you can get the information out of it
 |	quite precisely. Even if you don't know the exact structure, however, these 
 |	techniques still do work to some extent.
 |
 |	Basically, when you create a scripted plugin, and define some parameters
 |	for it's interface, it will create ParamBlock2 instances for each block
 |	of parameters you define in script. These are accessable through the 
 |	class Animatable method GetParamBlock(...). In this way, once you get
 |	hold of a pointer to your new scripted plugin in the scene, you can 
 |	have total control over the state of your custom values.
 |
 |	Also, if your scripted plugin is overriding the UI of an existing plugin,
 |	or if it is extending the UI in some way, the original plugin that lies
 |	'underneith' the scripted plugin is called the delegate. You can get access
 |	to this original plugin, as it is stored at Reference 0 of your custom plugin.
 |	In this way, you can still control the delegate that your scripted plugin
 |	controls.
 |	If, however, the scripted plugin creates a brand new plugin type, the paramblock2
 |	items are stored upwards from Reference 0. It is advisable to use GetParamBlock
 |  in any case.
 |
\*===========================================================================*/



#include "Utility.h"


/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SCPClassDesc:public ClassDesc {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create( BOOL loading )		{ return &theSCPUtil; }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return UTILITY_CLASS_ID; }
	Class_ID 		ClassID()					{ return SCPUTIL_CLASSID; }
	const TCHAR* 	Category()					{ return GetString(IDS_CATEGORY);  }
	void ResetClassParams (BOOL fileReset);
};

static SCPClassDesc SCPUtilCD;
ClassDesc* GetSCPUtilDesc() {return &SCPUtilCD;}

// Reset all the utility values on File/Reset
void SCPClassDesc::ResetClassParams (BOOL fileReset) 
{
}



/*===========================================================================*\
 |	Dialog Handler for the Utility
 |  All the action happens in here - check the IDC_BTN1 handler to see
 |	how we access the scripted plugin's data
\*===========================================================================*/

static BOOL CALLBACK DefaultDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg) {
		case WM_INITDIALOG:
			theSCPUtil.Init(hWnd);
			break;

		case WM_DESTROY:
			theSCPUtil.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CLOSE:
					theSCPUtil.iu->CloseUtility();
					break;

				case IDC_BTN1:
					{
					// Open a material browser to find the material to inspect
					Interface *ip = theSCPUtil.ip;

					BOOL newMat,cancel;
					MtlBase *mtlb = ip->DoMaterialBrowseDlg(hWnd,BROWSE_MATSONLY|BROWSE_INSTANCEONLY,newMat,cancel);


					if(!cancel&&mtlb)
					{
						// Check to see if this is one of ours
						if(mtlb->ClassID() == GAMEMTL_CLASSID)
						{

						Mtl *scp = (Mtl*)mtlb;

						// Get the number of pblock2s and references on the mtl
						int num_pblock2 = scp->NumParamBlocks();
						int num_refs = scp->NumRefs();

							// Get the custom parameters
							// We defined two custom parameters in our scripted plugin
							// called GM_Custom1 and GM_Custom2
							// When we walk through the retrieved paramblock2, we can
							// get access to the hardwired internal name and check that
							// against our own names, to see if its the parameter we want
							// This way, its position-independant : it doesn't matter
							// where the parameters ARE in the pblock2, we will find them.
							if(num_pblock2>0)
							{
								// Get the first paramblock2 (the only one in our scripted plugin)
								IParamBlock2 *pb2 = scp->GetParamBlock(0);
								// The the descriptor to 'decode'
								ParamBlockDesc2 *pdc = pb2->GetDesc();

								// Loop through all the defined parameters therein
								for(int i=0;i<pdc->count;i++)
								{
									// Get a ParamDef structure for the parameter
									ParamDef pD = pdc->paramdefs[i];
									

									// Now compare against our names
									// When we match against one we want, we get the 
									// ParamID from the ParamDef and pass it to GetValue of ParamBlock2
									// which will retrieve us the value
									if(stricmp(pD.int_name,"GM_Custom1")==0)
									{
										int itmp = pb2->GetInt(pD.ID,theSCPUtil.ip->GetTime());

										char s[255];
										sprintf(s,"%i",itmp);
										SetWindowText(GetDlgItem(hWnd,IDC_GM1),s);
									}

									if(stricmp(pD.int_name,"GM_Custom2")==0)
									{
										float ftmp = pb2->GetFloat(pD.ID,theSCPUtil.ip->GetTime());

										char s[255];
										sprintf(s,"%.1f%%",ftmp);
										SetWindowText(GetDlgItem(hWnd,IDC_GM2),s);
									}

								}

								// Mustn't forget to...
								pb2->ReleaseDesc();
							}


							// With a scripted plugin that overrides/extends an existing plugin,
							// the original "delegate" is kept as Reference 0.
							// If the scripted plugin is a brand new one, Ref 0 will be the first
							// paramblock2, and ref n will be paramblock2 n, if applicable.
							//
							// In this case, we get a poitner back to the original Standard Material
							// that we override, and get its Diffuse color
							Mtl *delegate = (Mtl*)scp->GetReference(0);
							theSCPUtil.cs->SetColor(delegate->GetDiffuse());

						}
						else
						{
							// The user chose something that wasn't a GameMtl class
							MessageBox(hWnd,"Chosen Material Is NOT a GAMEMTL!","Error",MB_OK);
						}
					}

					}
					break;
			}
			break;


		default:
			return FALSE;
	}
	return TRUE;
}



/*===========================================================================*\
 |  Utility implimentations
\*===========================================================================*/

SCPUtility::SCPUtility()
{
	iu = NULL;
	ip = NULL;	
	hPanel = NULL;
}

SCPUtility::~SCPUtility()
{

}


void SCPUtility::BeginEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = iu;
	this->ip = ip;

	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_SCPLUTIL),
		DefaultDlgProc,
		GetString(IDS_PARAMETERS),
		0);
}
	
void SCPUtility::EndEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
}


void SCPUtility::Init(HWND hWnd)
{
	cs = GetIColorSwatch(GetDlgItem(hWnd,IDC_DIFFUSE),Color(0,0,0),_T("Diffuse"));
}

void SCPUtility::Destroy(HWND hWnd)
{
	ReleaseIColorSwatch(cs);
	cs = NULL;
}



/*===========================================================================*\


-- ----------------------------------------------------------
-- Simple example Scripted Plugin
-- For use with the ScPRead Utility in MAXSDK\HOWTO\R3_EXAMPLES
--
-- Harry Denholm, Discreet 1999
--
-- ----------------------------------------------------------


plugin Material GameMtl
    name:"GameMtl"
    classID:#(0x67296df6, 0x0)
    extends:Standard replaceUI:True version:1
(

	-- the parameters list equates to a ParamBlock2
	-- Each one is put into a new PB2, which you can access 
	-- through the GetParamBlock() call
	-- The name we specify in here becomes the hardwired 'internal name' in the
	-- ParamDef structure
	parameters main rollout:params
	(
    	GM_Custom1  type:#integer animatable:true ui:GM_Custom1  default:10
	   	on GM_Custom1 set val do (
			Delegate.glossiness = val;
			Delegate.specularLevel = val;
			)

    	GM_Custom2  type:#float animatable:true ui:GM_Custom2 default:100
	   	on GM_Custom2 set val do (
			Delegate.opacity = val;
			Delegate.filterColor = Color (val*2) 0 0
			)
	)

	-- Define the UI layout
	-- We have two parameters that will affect the delegate plugin (standardMtl)
	-- and two that are custom, and controlled by the parameter definition above	
    rollout params "Default Parameters"
    (
		label sp1 height:15
		ColorPicker GMdiffuse "Diffuse Color :       " color:[250,0,0] across:2
		ColorPicker GMillum   "SelfIllumination :    " color:[0,0,0]
		label sp2 height:15
		group "Custom Paramters"
		(
			Spinner GM_Custom1 "Custom 1 : " range:[0,100,10] width:90 align:#center
			Slider GM_Custom2 "Custom 2 : " range:[0,100,100] width:150 align:#center
		)
		
		fn updateParams =
		(
			Delegate.diffuse = GMdiffuse.color
			Delegate.selfIllumColor = GMillum.color
		)
		
		on params open do ( updateParams() )
		on GMdiffuse changed col do ( updateParams() )
		on GMillum changed col do ( updateParams() )

	)
)

\*===========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Atmospheric\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Atmospheric effect
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 31-3-99
 | 
\*===========================================================================*/

#include "Atmospheric.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonAtmosDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Atmospheric\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Atmospheric.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_SIMPLE                      3
#define IDS_LIBDESC                     4
#define IDS_GIZMOS                      5
#define IDD_SKELETON_ATMOS              107
#define IDC_ADDGIZMO                    1157
#define IDC_GIZMOLIST                   1333
#define IDC_DELGIZMO                    1334
#define IDC_SIMPLE                      1702

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Atmospheric\Atmospheric.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Atmospheric.cpp
 |			Skeleton project and code for a Atmospheric effect
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 31-3-99
 | 
\*===========================================================================*/

#include "Atmospheric.h"



/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonAtmosClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()				{ return TRUE; }
	void *			Create( BOOL loading )	{ return new SkeletonAtmospheric; }
	const TCHAR *	ClassName()				{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()			{ return ATMOSPHERIC_CLASS_ID; }
	Class_ID 		ClassID()				{ return ATMOS_CLASSID; }
	const TCHAR* 	Category()				{ return _T("");  }

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()			{ return _T("SkeletonAtmospheric"); }
	HINSTANCE		HInstance()				{ return hInstance; }
};

static SkeletonAtmosClassDesc SkeletonAtmosCD;
ClassDesc* GetSkeletonAtmosDesc() {return &SkeletonAtmosCD;}



/*===========================================================================*\
 |	Basic implimentation of a dialog handler
\*===========================================================================*/

BOOL SkeletonAtmosDlgProc::DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}



/*===========================================================================*\
 |	Gizmo object validator
 |	This routine works with ParamBlock2 to check each incoming gizmo
 |	to check it is okay to use
\*===========================================================================*/

// All the code is already in OKGizmo, so pass to that
BOOL GizmoValidatorClass::Validate(PB2Value &v) 
{
	INode *node = (INode*) v.r;

	if (node->TestForLoop(FOREVER,(ReferenceMaker *) atp)!=REF_SUCCEED) return FALSE;

	return atp->OKGizmo(node);
}



/*===========================================================================*\
 |	Paramblock2 Descriptor
 |	In an atmospheric, which stores references to gizmos, we can use the INODE_TAB
 |	parameter type of PB2, which will automate the entire UI and reference management
 |	for us. Groovy!
\*===========================================================================*/

static ParamBlockDesc2 skatmos_param_blk ( skatmos_params, _T("SkeletonAtmosParameters"),  0, &SkeletonAtmosCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_SKELETON_ATMOS, IDS_PARAMETERS, 0, 0, NULL, 
	// params
	skatmos_gizmos,    _T("Gizmos"),  TYPE_INODE_TAB, 0, P_AUTO_UI,	IDS_GIZMOS,
		p_ui,	TYPE_NODELISTBOX, IDC_GIZMOLIST,	IDC_ADDGIZMO,	0,	IDC_DELGIZMO,
		end,
	skatmos_simple_param, _T("Color"),	TYPE_RGBA, P_ANIMATABLE, IDS_SIMPLE,
		p_default, Color(0,0,0),
		p_ui, TYPE_COLORSWATCH, IDC_SIMPLE,
		end,
	end
	);



/*===========================================================================*\
 |	Constructor
 |  Ask the ClassDesc2 to make the AUTO_CONSTRUCT paramblocks and wire them in
\*===========================================================================*/

SkeletonAtmospheric::SkeletonAtmospheric()
{
	SkeletonAtmosCD.MakeAutoParamBlocks(this);
	assert(pblock);

	validator.atp = this;
}



/*===========================================================================*\
 |	Ask the ClassDesc2 to make the AUTO_UI SkeletonAtmosDlgProc
\*===========================================================================*/

EffectParamDlg *SkeletonAtmospheric::CreateParamDialog(IRendParams *ip)
{	
	skatmos_param_blk.ParamOption(skatmos_gizmos,p_validator,&validator);
	return new SkelAtmosParamDlg(ip,this);
}



/*===========================================================================*\
 |	Subanim & References support
\*===========================================================================*/

Animatable* SkeletonAtmospheric::SubAnim(int i) 	{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
	}
TSTR SkeletonAtmospheric::SubAnimName(int i) {
	switch (i) {
		case 0: return GetString(IDS_PARAMETERS);
		default: return _T("");
		}
	}

RefTargetHandle SkeletonAtmospheric::GetReference(int i)
	{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
	}
void SkeletonAtmospheric::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case 0: pblock = (IParamBlock2*)rtarg; break;
		}
	}
RefResult SkeletonAtmospheric::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
	{
	switch (message) {
		case REFMSG_TARGET_DELETED:
			{
				for(int i=0;i<NumGizmos();i++)
				{
					if((INode*)hTarget==GetGizmo(i)) DeleteGizmo(i);
				}
			}
			break;

		case REFMSG_CHANGE:
			skatmos_param_blk.InvalidateUI();
			break;
		}
	return REF_SUCCEED;
	}


/*===========================================================================*\
 |	Support for getting/setting gizmos  
\*===========================================================================*/

int SkeletonAtmospheric::NumGizmos() 
{
	return pblock->Count(skatmos_gizmos);
}

INode *SkeletonAtmospheric::GetGizmo(int i) 
{
	INode *node = NULL;
	Interval iv;
	pblock->GetValue(skatmos_gizmos,0,node,iv, i);
	return node;
}

void SkeletonAtmospheric::DeleteGizmo(int i)
{
	pblock->Delete(skatmos_gizmos, i,1); 
	skatmos_param_blk.InvalidateUI();

	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

void SkeletonAtmospheric::InsertGizmo(int i, INode *node)
{
	pblock->SetValue(skatmos_gizmos, 0, node, i);
}

void SkeletonAtmospheric::AppendGizmo(INode *node)
{
	pblock->Append(skatmos_gizmos, 1, &node);
}

BOOL SkeletonAtmospheric::OKGizmo(INode *node)
{
	// check for duplicates in the gizmo list
	for(int i=0;i<NumGizmos();i++) { if(node==GetGizmo(i)) return FALSE; }

	ObjectState os = node->EvalWorldState(GetCOREInterface()->GetTime());
	if (os.obj->ClassID()==SPHEREGIZMO_CLASSID) return TRUE;
	if (os.obj->ClassID()==CYLGIZMO_CLASSID) return TRUE;
	if (os.obj->ClassID()==BOXGIZMO_CLASSID) return TRUE;
	return FALSE;
}

void SkeletonAtmospheric::EditGizmo(INode *node)
{
}



/*===========================================================================*\
 |	Parammap handler implimentation
\*===========================================================================*/

SkelAtmosParamDlg::SkelAtmosParamDlg(IRendParams *i,SkeletonAtmospheric *a) 
{
	atmos = a;
	ip    = i;	

	pmap = CreateRParamMap2(
		atmos->pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_SKELETON_ATMOS),
		GetString(IDS_PARAMETERS),
		0);

	pmap->SetUserDlgProc(new SkeletonAtmosDlgProc(atmos));
}

void SkelAtmosParamDlg::SetThing(ReferenceTarget *m)
{
	assert(m->ClassID()==atmos->ClassID());
	atmos = (SkeletonAtmospheric*)m;
	pmap->SetParamBlock(atmos->pblock);	
}

void SkelAtmosParamDlg::DeleteThis()
{
	ip->EndPickMode();
	DestroyRParamMap2(pmap);
	delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Atmospheric\AtmosShade.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	AtmosShade.cpp
 |			Skeleton project and code for a Atmospheric effect
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 31-3-99
 | 
\*===========================================================================*/

#include "Atmospheric.h"



/*===========================================================================*\
 |	This method is called once per frame when the renderer begins.  
\*===========================================================================*/

void SkeletonAtmospheric::Update(TimeValue t, Interval& valid)
{
}


/*===========================================================================*\
 |	Called to initialize or clear up before and after rendering  
 |	These will get called once each, not per frame
\*===========================================================================*/

int SkeletonAtmospheric::RenderBegin(TimeValue t, ULONG flags)
{
	return 0;
}

int SkeletonAtmospheric::RenderEnd(TimeValue t)
{
	return 0;
}



/*===========================================================================*\
 |	The actual shading of our atmospheric space
 |	Creates a simple raycast, tests each gizmo, shades gizmo space in param color
\*===========================================================================*/

// Hacked out of Combustion, for demonstration purposes
inline BOOL IntersectSphere(
		Matrix3 tm, Ray &ray,float r)
{	
	Ray ray2;

	ray2 = ray;

	ray2.p   = ray2.p * tm;
	ray2.dir = VectorTransform(tm,ray2.dir);

	float a, b, c, ac4, b2;

	a = DotProd(ray2.dir,ray2.dir);
	b = DotProd(ray2.dir,ray2.p) * 2.0f;
	c = DotProd(ray2.p,ray2.p) - r*r;
	
	ac4 = 4.0f * a * c;
	b2 = b*b;

	if (ac4 > b2) return FALSE;

	return TRUE;
}


void SkeletonAtmospheric::Shade(
		ShadeContext& sc,const Point3& p0,const Point3& p1,
		Color& color, Color& trans, BOOL isBG)
{
	if(NumGizmos()<=0) return;

	// Get the color from our paramblock
	Color pColor;
	pblock->GetValue(skatmos_simple_param, sc.CurTime(), pColor, FOREVER);


	// Setup the ray to cast
	Point3 wp0, wp1, v;
	float len;
	Ray ray;

	wp0   = sc.PointTo(p0,REF_WORLD);
	wp1   = sc.PointTo(p1,REF_WORLD);
	ray.p = wp0;
	v     = wp1-wp0;
	len   = Length(v);
	if (len==0.0f) return;
	ray.dir = v/len;


	// Start out color is clear and black
	Color c;
	c.Black();
	float o = 0.0f;

	// For each gizmo, do some tracing
	// If we hit a sphere, centered on each gizmo's center, set to color
	for (int i=0; i<NumGizmos(); i++) 
	{
		INode *gizmo = GetGizmo(i);
		if(gizmo)
		{
			Matrix3 tm = Inverse(gizmo->GetObjTMAfterWSM(sc.CurTime()));
			if(IntersectSphere(tm,ray,20.0f)) { c=pColor; o=0.6f; }
		}
	}

	// Combine with incoming color.
	color += c-(color*o);
	trans *= 1.0f-o;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\ColorPicker\ColorPicker.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	ColorPicker.cpp
 |			Skeleton project and code for a plugin ColorPicker
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 27-1-99
 | 
\*===========================================================================*/

#include "ColorPicker.h"



/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class ColPickClassDesc:public ClassDesc {
	public:
	int 			IsPublic()				{ return TRUE; }
	void *			Create(BOOL loading)	{ return new SkeletonColorPicker; }
	const TCHAR *	ClassName()				{ return GetString(IDS_CLASSNAME); 	}
	SClass_ID		SuperClassID()			{ return COLPICK_CLASS_ID; }
	Class_ID 		ClassID()				{ return SKELCP_CLASSID; }
	const TCHAR* 	Category()				{ return _T("");  }
	};

ColPickClassDesc theColPickClassDesc;

ClassDesc *GetSkeletonCPDesc() { return &theColPickClassDesc; }




/*===========================================================================*\
 |	ColorPicker methods
\*===========================================================================*/


ColorPicker* SkeletonColorPicker::CreateColorPicker(HWND hwndOwner, DWORD initColor,
													IPoint2* spos, HSVCallback *pcallback,
													TCHAR *name, int objClr) 
{
	return new SkeletonModeless(hwndOwner,initColor,spos,pcallback,name,objClr);
}	


int SkeletonColorPicker::ModalColorPicker(HWND hwndOwner, DWORD *lpc, IPoint2 *spos,
										  HSVCallback *callBack, TCHAR *name) 
{
	int res = 0;
	SkeletonCPDialog SCPD(hwndOwner,*lpc,spos,callBack,name);
	res = SCPD.StartModal();

	if(lpc)		*lpc = SCPD.GetColor();
	if(spos)	*spos = SCPD.GetPosition();

	return res;
}



/*===========================================================================*\
 |	SkeletonModeless methods
\*===========================================================================*/


SkeletonModeless::SkeletonModeless(HWND hwndOwner, DWORD initColor, 
								   IPoint2* pos, HSVCallback* callback, 
								   TCHAR *name, int objClr)
{
	hwnd = NULL; SCPD = NULL;
	SCPD = new SkeletonCPDialog(hwndOwner,initColor,pos,callback,name,objClr,this);
	hwnd = SCPD->StartModeless();
}


void SkeletonModeless::Destroy() {
	if(hwnd) DestroyWindow(hwnd);
}

SkeletonModeless::~SkeletonModeless() {
	Destroy();
	if(SCPD) delete SCPD;
	hwnd = NULL; SCPD = NULL;
}


// Transactions with the dialog handler
void SkeletonModeless::SetNewColor (DWORD color, TCHAR *name)
{
	SCPD->SetNewColor(color,name);
}

void SkeletonModeless::ModifyColor (DWORD color)
{
	SCPD->ModifyColor(color);
}

void SkeletonModeless::InstallNewCB(DWORD col, HSVCallback *pcb, TCHAR *name)
{
	SCPD->InstallNewCB(col,pcb,name);
}

DWORD SkeletonModeless::GetColor()
{
	return SCPD->GetColor();
}

IPoint2 SkeletonModeless::GetPosition()
{
	return SCPD->GetPosition();
}


IPoint2 SkeletonCPDialog::initPos(354,94);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\ColorPicker\ColorPicker.h ===
/*===========================================================================*\
 | 
 |  FILE:	ColorPicker.h
 |			Skeleton project and code for a plugin ColorPicker
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 27-1-99
 | 
\*===========================================================================*/

#ifndef __COLPSKEL__H
#define __COLPSKEL__H

#include "max.h"
#include <bmmlib.h>
#include <math.h>
#include "gamma.h"
#include "gport.h"
#include "hsv.h"

#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	SKELCP_CLASSID		Class_ID(0x7d209b8, 0x41210287)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonCPDesc();

class SkeletonModeless;



/*===========================================================================*\
 |	SkeletonCPDialog class
\*===========================================================================*/

class SkeletonCPDialog
{

public:
	HWND	hwOwner;
	HWND	hwPanel;
	
	DWORD	origRGB;
    DWORD	currentRGB;

	IPoint2 curPos;
	TSTR	colName;

	HSVCallback *callback;
	static IPoint2 initPos;
	BOOL	objColor;
	SkeletonModeless *sm;


	// Modeless and Modal support
	BOOL	Modeless;
	int		StartModal();
	HWND	StartModeless();


	// Construct and initialize
	SkeletonCPDialog(HWND hOwner, DWORD col,  IPoint2* pos,
			HSVCallback *cb, TCHAR *name, int objClr = 0, SkeletonModeless *smp = NULL);
	~SkeletonCPDialog();
	void DoPaint(HWND hWnd);


	// Modify the dialog's settings
	void SetNewColor (DWORD color, TCHAR *name);
	void ModifyColor (DWORD color);
	DWORD GetColor();
	IPoint2 GetPosition();
	void InstallNewCB(DWORD col, HSVCallback *pcb, TCHAR *name);
};

// The dialog proc
BOOL CALLBACK SkelDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

/*===========================================================================*\
 |	SkeletonColorPicker class definition
\*===========================================================================*/


class SkeletonColorPicker: public ColPick 
{
public:

	SkeletonColorPicker() {}
	~SkeletonColorPicker() {}

	// Do Modal dialog
	int ModalColorPicker(
		HWND hwndOwner, 		// owning window
		DWORD *lpc,				// pointer to color to be edited
	    IPoint2 *spos, 			// starting position, set to ending position
	    HSVCallback *callBack,	// called when color changes
		TCHAR *name				// name of color being edited
	    );

	// Create Modeless dialog.
	ColorPicker *CreateColorPicker(
		HWND hwndOwner,   
		DWORD initColor,  
		IPoint2* spos,    
		HSVCallback *pcallback,
		TCHAR *name, 	  
		BOOL isObjectColor);


	const TCHAR *	ClassName()		{ return GetString(IDS_CLASSNAME);	}
	Class_ID 		ClassID()		{ return SKELCP_CLASSID; }

	void DeleteThis() {	delete this; }

	int Execute(int cmd, ULONG arg1=0, ULONG arg2=0, ULONG arg3=0) {return 0; } 
};



/*===========================================================================*\
 |	SkeletonModeless class definition
\*===========================================================================*/

class SkeletonModeless: public ColorPicker 
{

	HWND hwnd;
	SkeletonCPDialog *SCPD;

public:
		SkeletonModeless(HWND hwndOwner, DWORD initColor, IPoint2* pos, HSVCallback* callback, TCHAR *name, int objClr);

		~SkeletonModeless();
		void DeleteThis() { delete this; }

		void SetNewColor (DWORD color, TCHAR *name);
		void ModifyColor (DWORD color);
		void InstallNewCB(DWORD col, HSVCallback *pcb, TCHAR *name);

		DWORD GetColor();
		IPoint2 GetPosition();
		void Destroy();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\ColorPicker\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a RenderEffect
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 27-1-99
 | 
\*===========================================================================*/

#include "ColorPicker.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonCPDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\ColorPicker\Dialog.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Dialog.cpp
 |			Skeleton project and code for a plugin ColorPicker
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 27-1-99
 | 
\*===========================================================================*/


#include "ColorPicker.h"


#define RANDOM( a )		( ( (float)rand()/(float)RAND_MAX)*(a) )



// Redraw the color display frame on my UI
// This is purely skeleton-specific
void RedrawColorBox(HWND hWnd)
{
	HWND item = GetDlgItem(hWnd,IDC_COLBOX);
	Rect rect;
	GetClientRect(item,&rect);
	InvalidateRect (hWnd, &(RECT)rect, TRUE);
	UpdateWindow(hWnd);
}



/*===========================================================================*\
 |	The main dialog handler for our color picker
\*===========================================================================*/

BOOL CALLBACK SkelDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	SkeletonCPDialog *cp = (SkeletonCPDialog*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!cp && msg!=WM_INITDIALOG) return FALSE;

    switch (msg)
	    {

		case WM_INITDIALOG:
			{
				// Update the class pointer
				cp = (SkeletonCPDialog*)lParam;
				SetWindowLong(hWnd,GWL_USERDATA,lParam);

				// Remove the black frame, and replace it with an ownerdrawn style
				LONG style = GetWindowLong(GetDlgItem(hWnd,IDC_COLBOX),GWL_STYLE);
				style &= ~(SS_BLACKFRAME);
				style |= SS_OWNERDRAW;
				SetWindowLong(GetDlgItem(hWnd,IDC_COLBOX),GWL_STYLE,style);

				// Reposition and rename the dialog
				SetWindowPos(hWnd,NULL,cp->initPos.x,cp->initPos.y,0,0,SWP_NOSIZE|SWP_NOZORDER);
				SetWindowText(hWnd,cp->colName);

				// Set default arrow cursor
				SetCursor(LoadCursor(NULL, IDC_ARROW));
			
				// Show the window
				ShowWindow(GetDlgItem(hWnd,IDC_ADDCOLOR),cp->objColor);

				RedrawColorBox(hWnd);
				cp->hwPanel = hWnd;
			break;}



		// Repaint the dialog
		case WM_PAINT:  cp->DoPaint(hWnd);	break;



		case WM_COMMAND:
			switch (LOWORD(wParam)) {

				// Randomize the current color
				// I wanted the skeleton to do 'something' with it :)
				case IDC_RANDOM:
					cp->currentRGB = RGB(RANDOM(255),RANDOM(255),RANDOM(255));
					if (cp->callback)
						cp->callback->ColorChanged(cp->currentRGB,1);
					RedrawColorBox(hWnd);
					break;

				// If we are in 'Add Custom Color' mode, send the current
				// color back as the chosen color to add to the list
				case IDC_ADDCOLOR:
					SendMessage(GetParent(hWnd), WM_ADD_COLOR, (WPARAM)cp->currentRGB, 0);
					RedrawColorBox(hWnd);
				break;

				// Reset the current color to the original
				case IDC_RESET:
					cp->currentRGB = cp->origRGB;
					if (cp->callback)
						cp->callback->ColorChanged(cp->currentRGB,1);
					RedrawColorBox(hWnd);
					break;

				// Close this colorpicker
				case IDC_CLOSE:
					SendMessage(hWnd,WM_CLOSE,0,0);
					break;
			}
			break;


		// On a move operation, save the location
		case WM_SIZE:
		case WM_MOVE:
			{
				RECT r;
				GetWindowRect(hWnd,&r);
				cp->curPos.x = cp->initPos.x = r.left; 
				cp->curPos.y = cp->initPos.y = r.top; 
			break;}
		

		// Shutdown the color picker, return final values
		case WM_CLOSE:
		case WM_DESTROY:
			{
				RECT r;
				GetWindowRect(hWnd,&r);
				cp->curPos.x = r.left; 
				cp->curPos.y = r.top; 

				if (cp->callback) 
					cp->callback->BeingDestroyed(cp->curPos);

				SetWindowLong(hWnd, GWL_USERDATA, LONG(0));

				if(cp->Modeless) 
				{
					delete cp;
					cp=NULL;
					DestroyWindow(hWnd);
				}
				else EndDialog(hWnd,0);

			break;}

	    default:
	        return FALSE;
	    }
    return TRUE;
}



/*===========================================================================*\
 |	Paint a color swatch onto the dialog surface
\*===========================================================================*/

void SkeletonCPDialog::DoPaint(HWND hWnd)
{
	PAINTSTRUCT ps;
	HPEN Pen; HBRUSH Brush; HWND item;

	BeginPaint (hWnd,  &ps);

	item = GetDlgItem(hWnd,IDC_COLBOX);
	Rect rect;
	GetClientRect(item,&rect);
	HDC hdc = GetDC(item);

	Rect tR = rect;
	tR.right--;
	tR.bottom--;
	Rect3D(hdc,tR,FALSE);


	// Original Color
	Pen = CreatePen( PS_SOLID , 1 , (COLORREF)origRGB );
	Brush = CreateSolidBrush((COLORREF)origRGB);
	SelectObject(hdc,Pen);
	SelectObject(hdc,Brush);

	Rectangle( hdc, 1,1,(rect.w()-2)/2,rect.h()-2);

	DeleteObject(Pen);
	DeleteObject(Brush);

	// Current Color
	Pen = CreatePen( PS_SOLID , 1 , (COLORREF)currentRGB );
	Brush = CreateSolidBrush((COLORREF)currentRGB);
	SelectObject(hdc,Pen);
	SelectObject(hdc,Brush);

	Rectangle( hdc, (rect.w()-2)/2,1,rect.w()-2,rect.h()-2);

	DeleteObject(Pen);
	DeleteObject(Brush);



	ReleaseDC(item,hdc);
	EndPaint (hWnd, &ps);
}



/*===========================================================================*\
 |	Different ways to run the dialog
\*===========================================================================*/

int SkeletonCPDialog::StartModal()
{
	Modeless = FALSE;
	return (int)DialogBoxParam(
		hInstance, 
		MAKEINTRESOURCE(IDD_COLPICK_SKEL), 
		hwOwner, 
		SkelDlgProc,
		(LPARAM)this);
}

HWND SkeletonCPDialog::StartModeless()
{
	Modeless = TRUE;
	return (HWND)CreateDialogParam(
		hInstance, 
		MAKEINTRESOURCE(IDD_COLPICK_SKEL), 
		hwOwner, 
		SkelDlgProc,
		(LPARAM)this);
}


/*===========================================================================*\
 |	Dialog class handler constructor/destructor
\*===========================================================================*/

SkeletonCPDialog::SkeletonCPDialog(HWND hOwner, DWORD col,  IPoint2* pos,
								HSVCallback *cb, TCHAR *name, int objClr, SkeletonModeless *smp)
{
	hwOwner = hOwner;
	origRGB = currentRGB = col;
	if(pos) curPos = initPos = *pos;
	callback = cb;
	colName = name;
	Modeless = FALSE;
	hwPanel = NULL;
	objColor = objClr?TRUE:FALSE;
	sm = smp;
}

SkeletonCPDialog::~SkeletonCPDialog()
{
	if(hwPanel) hwPanel = NULL;
}



/*===========================================================================*\
 |	Various information callbacks
\*===========================================================================*/

void SkeletonCPDialog::SetNewColor (DWORD color, TCHAR *name)
{
	colName = name;
	origRGB = currentRGB = color;
	SetWindowText(hwPanel,colName);
	InvalidateRect(hwPanel,NULL,FALSE);
}

void SkeletonCPDialog::ModifyColor (DWORD color)
{
	currentRGB=color;
	InvalidateRect(hwPanel,NULL,FALSE);
}

DWORD SkeletonCPDialog::GetColor()
{
	return currentRGB;
}

IPoint2 SkeletonCPDialog::GetPosition()
{
	return curPos;
}

void SkeletonCPDialog::InstallNewCB(DWORD col, HSVCallback *pcb, TCHAR *name)
{
	if (callback) 
		callback->ColorChanged(currentRGB,1);
	callback = pcb;
    currentRGB = origRGB = col;
	colName = name;
	SetWindowText(hwPanel,colName);
	InvalidateRect(hwPanel,NULL,FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\GlobalUtility\GlobalUtility.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	GlobalUtility.cpp
 |			Skeleton project and code for a Global Utility Plugin (GUP)
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#include "GlobalUtility.h"


/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonGUPClassDesc:public ClassDesc {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create( BOOL loading )		{ return new SkeletonGUP; }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return GUP_CLASS_ID; }
	Class_ID 		ClassID()					{ return SKGUP_CLASSID; }
	const TCHAR* 	Category()					{ return _T("");  }
};

static SkeletonGUPClassDesc SkeletonGUPCD;
ClassDesc* GetGUPDesc() {return &SkeletonGUPCD;}



/*===========================================================================*\
 |	Global Utility interface (start/stop/control)
\*===========================================================================*/

// Activate and Stay Resident
// The GUPRESULT_KEEP tells MAX that we want to remain loaded in the system
// Check the SDK Help File for other returns, to change the behavior
DWORD SkeletonGUP::Start( ) {
	SkeletonViewWindow *skvw = new SkeletonViewWindow(this);
	Max()->RegisterViewWindow(skvw);
	return GUPRESULT_KEEP;
}


// We do nothing when the GUP unloads
void SkeletonGUP::Stop( ) {

}



DWORD SkeletonGUP::Control( DWORD parameter ) {
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\ColorPicker\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ColorPicker.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_LIBDESC                     4
#define IDD_COLPICK_SKEL                101
#define IDC_CLOSE                       1000
#define IDC_COLBOX                      1001
#define IDC_ADDCOLOR                    1002
#define IDC_RANDOM                      1003
#define IDC_RESET                       1004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\GlobalUtility\GlobalUtility.h ===
/*===========================================================================*\
 | 
 |  FILE:	GlobalUtility.h
 |			Skeleton project and code for a Global Utility Plugin (GUP)
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#ifndef __GUPSKEL__H
#define __GUPSKEL__H


#include <Max.h>
#include <bmmlib.h>
#include <guplib.h>

#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	SKGUP_CLASSID		Class_ID(0x52d735b4, 0x4ad1587)


TCHAR *GetString(int id);
extern ClassDesc* GetGUPDesc();


class SkeletonGUP : public GUP {
	public:
      
		SkeletonGUP		( ) {}
		~SkeletonGUP	( ) {}
	
		// GUP Methods
		DWORD	Start			( );
		void	Stop			( );
		DWORD	Control			( DWORD parameter );
};


// ViewWindow subclass for putting a custom window in a MAX viewport
class SkeletonViewWindow : public ViewWindow
{
	SkeletonGUP *gupPtr;

public:

	SkeletonViewWindow( SkeletonGUP *gP ) { gupPtr = gP; }
	~SkeletonViewWindow() { gupPtr = NULL; }

	TCHAR *GetName() { return GetString(IDS_VIEWWIN_NAME); }
	HWND CreateViewWindow(HWND hParent, int x, int y, int w, int h);
	void DestroyViewWindow(HWND hWnd);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\GlobalUtility\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Global Utility Plugin (GUP)
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#include "GlobalUtility.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetGUPDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\GlobalUtility\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by GlobalUtility.rc
//
#define IDS_LIBDESC                     1
#define IDS_CLASSNAME                   2
#define IDS_VIEWWIN_NAME                3
#define IDD_VIEWPANEL                   102
#define IDC_FRAME                       1003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\GlobalUtility\ViewWindow.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	ViewWindow.cpp
 |			Test of the ViewWindow class
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#include "GlobalUtility.h"


BOOL CALLBACK ViewpanelProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	SkeletonGUP *gp = (SkeletonGUP*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!gp && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {

		// Update the pointer to the GUP 
		case WM_INITDIALOG:{
			gp = (SkeletonGUP*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,(LONG)gp);
			break;}

		// Resize/move any controls on our page
		case WM_SIZE:{
			int w = LOWORD(lParam);
			int h = HIWORD(lParam);
			SetWindowPos(GetDlgItem(hWnd,IDC_FRAME), NULL, 10, 10, w-20, h-20, SWP_NOZORDER);
			break;}


		// Make us the active viewpanel
		case WM_LBUTTONDOWN:
			gp->Max()->MakeExtendedViewportActive(hWnd);
			break;


		// Display the list of view windows
		case WM_RBUTTONDOWN:{
			POINT lpPt; GetCursorPos(&lpPt);
			RECT r;
			GetWindowRect(hWnd,&r);
			lpPt.x -= r.left;
			lpPt.y -= r.top;

			gp->Max()->MakeExtendedViewportActive(hWnd);
			gp->Max()->PutUpViewMenu(hWnd,lpPt);
			break;}


		default:
			return FALSE;
	}
	return TRUE;
}


HWND SkeletonViewWindow::CreateViewWindow(HWND hParent, int x, int y, int w, int h)
{
	// Create a dialog box, parented to the viewpane
	// Pass in the pointer to the GUP
	HWND newWnd = CreateDialogParam(
		(HINSTANCE)hInstance,
		MAKEINTRESOURCE(IDD_VIEWPANEL),
		hParent,
		(DLGPROC)ViewpanelProc,
		(LPARAM)(SkeletonGUP*)gupPtr);

	// Set the window's position
	SetWindowPos(newWnd, NULL, x, y, w, h, SWP_NOZORDER);
	ShowWindow(newWnd,TRUE);

	return newWnd;
}

void SkeletonViewWindow::DestroyViewWindow(HWND hWnd)
{
	EndDialog(hWnd,0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Helper\Helper.h ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Helper object
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 16-3-99
 | 
\*===========================================================================*/

#ifndef __HELPSKEL__H
#define __HELPSKEL__H

#include "max.h"
#include "iparamm2.h"
#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	HELP_CLASSID		Class_ID(0x7bb85668, 0x3ac32c1f)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonHelperDesc();


// Paramblock2 name
enum { shelp_params, }; 
// Paramblock2 parameter list
enum { shelp_simple_param, };




class SkeletontHelpObject: public HelperObject 
{
	public:			
		IParamBlock2 *pblock2;
		static IObjParam *ip;

		// Snap suspension flag (TRUE during creation only)
		BOOL suspendSnap;
					
		float simple;
 		int extDispFlags;

		SkeletontHelpObject();
		
		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		void SetExtendedDisplay(int flags);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CreateMouseCallBack* GetCreateMouseCallBack();

		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		void InvalidateUI();

		// From Object
		ObjectState Eval(TimeValue time);

		void InitNodeName(TSTR& s) { s = GetString(IDS_CLASSNAME); }
		ObjectHandle ApplyTransform(Matrix3& matrix) {return this;}
		Interval ObjectValidity(TimeValue t);

		// We don't convert to anything
		int CanConvertToType(Class_ID obtype) {return FALSE;}
		Object* ConvertToType(TimeValue t, Class_ID obtype) {assert(0);return NULL;}
		
		void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
		void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
		int DoOwnSelectHilite()	{ return 1; }

		// Animatable methods
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return HELP_CLASSID; }  
		void GetClassName(TSTR& s) { s = GetString(IDS_CLASSNAME); }
		int IsKeyable(){ return 0;}
		
		// Direct paramblock access
		int	NumParamBlocks() { return 1; }	
		IParamBlock2* GetParamBlock(int i) { return pblock2; }
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock2->ID() == id) ? pblock2 : NULL; }

		int NumSubs() { return 1; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);

		// From ref
 		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );		
};				

class SkeletonHelperCreateCallBack : public CreateMouseCallBack {
	SkeletontHelpObject *sho;
	IPoint2 sp0;
	Point3 p0;

	public:
	
	int proc( ViewExp *vpt, int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	void SetObj(SkeletontHelpObject *obj) {sho = obj;}
};


/*===========================================================================*\
 |	Dialog Processor
\*===========================================================================*/

class SkeletonHelpDlgProc : public ParamMap2UserDlgProc 
{
	public:
		SkeletontHelpObject *sho;

		SkeletonHelpDlgProc() {}
		SkeletonHelpDlgProc(SkeletontHelpObject *sho_in) { sho = sho_in; }

		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { }

		void SetThing(ReferenceTarget *m) {
			sho = (SkeletontHelpObject*)m;
			}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Helper\Helper.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Helper object
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 16-3-99
 | 
\*===========================================================================*/

#include "Helper.h"


IObjParam* SkeletontHelpObject::ip = NULL;


/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonHelperClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create( BOOL loading )		{ return new SkeletontHelpObject; }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return HELPER_CLASS_ID; }
	Class_ID 		ClassID()					{ return HELP_CLASSID; }
	const TCHAR* 	Category()					{ return _T("");  }

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()				{ return _T("SkeletonHelper"); }
	HINSTANCE		HInstance()					{ return hInstance; }
};

static SkeletonHelperClassDesc SkeletonHelpCD;
ClassDesc* GetSkeletonHelperDesc() {return &SkeletonHelpCD;}




/*===========================================================================*\
 |	Basic implimentation of a dialog handler
\*===========================================================================*/

BOOL SkeletonHelpDlgProc::DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}


/*===========================================================================*\
 |	Paramblock2 Descriptor
\*===========================================================================*/

static ParamBlockDesc2 shelp_param_blk ( shelp_params, _T("SkeletonSimpleObjParams"),  0, &SkeletonHelpCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_SKELETON_HELPER, IDS_PARAMETERS, 0, 0, NULL, 
	// params
	shelp_simple_param,	_T("HelperParameter"),	TYPE_FLOAT,	P_ANIMATABLE,	IDS_SIMPLE,
		p_default,		0.0f,
		p_range, 		0.0f, 65535.0f, 
		p_ui,			TYPE_SPINNER, EDITTYPE_UNIVERSE, IDC_SIMPLE_EDIT, IDC_SIMPLE_SPIN, 0.1f,
		end,
	end
	);




/*===========================================================================*\
 |	Constructor
 |  Ask the ClassDesc2 to make the AUTO_CONSTRUCT paramblocks and wire them in
\*===========================================================================*/

SkeletontHelpObject::SkeletontHelpObject()
	{
	SkeletonHelpCD.MakeAutoParamBlocks(this);
	assert(pblock2);
	suspendSnap = FALSE;
	}



/*===========================================================================*\
 |	Invalidate our UI (or the recently changed parameter)
\*===========================================================================*/

void SkeletontHelpObject::InvalidateUI()
{
	shelp_param_blk.InvalidateUI(pblock2->LastNotifyParamID());
}



/*===========================================================================*\
 |	Open and Close dialog UIs
 |	We ask the ClassDesc2 to handle Beginning and Ending EditParams for us
\*===========================================================================*/

void SkeletontHelpObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
{
	this->ip = ip;

	SkeletonHelpCD.BeginEditParams(ip, this, flags, prev);
	shelp_param_blk.SetUserDlgProc(new SkeletonHelpDlgProc(this));

}
		
void SkeletontHelpObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
{
	SkeletonHelpCD.EndEditParams(ip, this, flags, next);

	this->ip = NULL;
}



/*===========================================================================*\
 |	Clone the helper
\*===========================================================================*/

RefTargetHandle SkeletontHelpObject::Clone(RemapDir& remap) {
	SkeletontHelpObject* newob = new SkeletontHelpObject();	
	newob->ReplaceReference(0,pblock2->Clone(remap));
	return(newob);
	}


/*===========================================================================*\
 |	Subanim & References support
\*===========================================================================*/

Animatable* SkeletontHelpObject::SubAnim(int i) 	{
	switch (i) {
		case 0: return pblock2;
		default: return NULL;
		}
	}
TSTR SkeletontHelpObject::SubAnimName(int i) {
	switch (i) {
		case 0: return GetString(IDS_PARAMETERS);
		default: return _T("");
		}
	}

RefTargetHandle SkeletontHelpObject::GetReference(int i)
	{
	switch (i) {
		case 0: return pblock2;
		default: return NULL;
		}
	}
void SkeletontHelpObject::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case 0: pblock2 = (IParamBlock2*)rtarg; break;
		}
	}
RefResult SkeletontHelpObject::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
	{
	switch (message) {
		case REFMSG_CHANGE:
			shelp_param_blk.InvalidateUI();
			break;
		}
	return REF_SUCCEED;
	}


/*===========================================================================*\
 |	The validity of our parameters
 |	Start at FOREVER, and intersect with the validity of each item
\*===========================================================================*/

Interval SkeletontHelpObject::ObjectValidity(TimeValue t)
	{
	float f;	
	Interval valid = FOREVER;
	pblock2->GetValue(shelp_simple_param, t, f, valid);
	return valid;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Helper\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Helper.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_LIBDESC                     4
#define IDS_SIMPLE                      5
#define IDD_SKELETON_HELPER             180
#define IDC_SIMPLE_EDIT                 1004
#define IDC_SIMPLE_SPIN                 1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Helper\HelpMesh.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Helper object
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 16-3-99
 | 
\*===========================================================================*/

#include "Helper.h"




/*===========================================================================*\
 |	Mouse creation 
\*===========================================================================*/

int SkeletonHelperCreateCallBack::proc(ViewExp *vpt, int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;
	Point3 p1, center;

	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m, m, NULL, SNAP_IN_3D);
	}


	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {

		case 0:
			sho->suspendSnap = TRUE;				
			sp0 = m;
			p0 = vpt->SnapPoint(m, m, NULL, SNAP_IN_3D);
			mat.SetTrans(p0);
			break;


		case 1:
			mat.IdentityMatrix();
			
			p1 = vpt->SnapPoint(m, m, NULL, SNAP_IN_3D);
			r = Length(p1-p0);
			mat.SetTrans(p0);

			sho->pblock2->SetValue(shelp_simple_param, 0, r);

			if (msg==MOUSE_POINT) {
				sho->suspendSnap = FALSE;
				return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
			}
			break;					   
		}
	} else {
		if (msg == MOUSE_ABORT) return CREATE_ABORT;
	}

	return TRUE;
}

static SkeletonHelperCreateCallBack HelperCreateCB;

CreateMouseCallBack* SkeletontHelpObject::GetCreateMouseCallBack() 
{
	HelperCreateCB.SetObj(this);
	return(&HelperCreateCB);
}

void SkeletontHelpObject::SetExtendedDisplay(int flags)
{
	extDispFlags = flags;
}




/*===========================================================================*\
 |	Bounding Box calculation
\*===========================================================================*/

void SkeletontHelpObject::GetLocalBoundBox(
		TimeValue t, INode* inode, ViewExp* vpt, Box3& box ) 
	{
	float sz; Interval ivalid = FOREVER;	
	pblock2->GetValue(shelp_simple_param,t,sz,ivalid);

	box = Box3(Point3((float)-sz,(float)-sz,(float)-sz), Point3((float)sz,(float)sz,(float)sz));
	}

void SkeletontHelpObject::GetWorldBoundBox(
		TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
	{
	Matrix3 tm;
	tm = inode->GetObjectTM(t);
	float sz; Interval ivalid = FOREVER;	
	pblock2->GetValue(shelp_simple_param,t,sz,ivalid);

	Point3 lo = tm.GetTrans();
	Point3 hi = tm.GetTrans();

	lo.x -= sz; lo.y -= sz; lo.z -= sz;
	hi.x += sz; hi.y += sz; hi.z += sz;
	 
	box = Box3(lo, hi);
	}



/*===========================================================================*\
 |	Hit Testing and Object Snapping 
\*===========================================================================*/

int SkeletontHelpObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) {
	Matrix3 tm(1);	
	HitRegion hitRegion;
	DWORD	savedLimits;
	float sz; Interval ivalid = FOREVER;	
	pblock2->GetValue(shelp_simple_param,t,sz,ivalid);

	Point3 pt1((float)sz,0.0f,0.0f), pt2((float)-sz,0.0f,0.0f), pt3(0.0f,(float)sz,0.0f), pt4(0.0f,(float)-sz,0.0f);

	vpt->getGW()->setTransform(tm);
	GraphicsWindow *gw = vpt->getGW();	
	Material *mtl = gw->getMaterial();

   	tm = inode->GetObjectTM(t);		
	MakeHitRegion(hitRegion, type, crossing, 4, p);

	gw->setRndLimits(((savedLimits = gw->getRndLimits())|GW_PICK)&~GW_ILLUM);
	gw->setHitRegion(&hitRegion);
	gw->clearHitCode();

	vpt->getGW()->setTransform(tm);
	vpt->getGW()->marker(&pt1,SM_CIRCLE_MRKR);
	vpt->getGW()->marker(&pt2,SM_CIRCLE_MRKR);
	vpt->getGW()->marker(&pt3,SM_CIRCLE_MRKR);
	vpt->getGW()->marker(&pt4,SM_CIRCLE_MRKR);

	gw->setRndLimits(savedLimits);
	
	if((hitRegion.type != POINT_RGN) && !hitRegion.crossing)
		return TRUE;
	return gw->checkHitCode();
	}

void SkeletontHelpObject::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt)
	{
	if(suspendSnap)
		return;

	}



/*===========================================================================*\
 |	Display the actual helper
\*===========================================================================*/

int SkeletontHelpObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) 
{
	Matrix3 tm(1);
	float sz; Interval ivalid = FOREVER;	
	pblock2->GetValue(shelp_simple_param,t,sz,ivalid);

	Point3 pt1((float)sz,0.0f,0.0f), pt2((float)-sz,0.0f,0.0f), pt3(0.0f,(float)sz,0.0f), pt4(0.0f,(float)-sz,0.0f);
	
	tm = inode->GetObjectTM(t);	
	vpt->getGW()->setTransform(tm);

	if(!inode->IsFrozen())
		vpt->getGW()->setColor(LINE_COLOR,GetUIColor(COLOR_POINT_OBJ));

	vpt->getGW()->marker(&pt1,SM_CIRCLE_MRKR);
	vpt->getGW()->marker(&pt2,SM_CIRCLE_MRKR);
	vpt->getGW()->marker(&pt3,SM_CIRCLE_MRKR);
	vpt->getGW()->marker(&pt4,SM_CIRCLE_MRKR);
	return(0);
}

ObjectState SkeletontHelpObject::Eval(TimeValue time)
{
	return ObjectState(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Helper\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Helper object
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 16-3-99
 | 
\*===========================================================================*/

#include "Helper.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonHelperDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Material\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Material.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_SIMPLE                      3
#define IDS_LIBDESC                     4
#define IDS_MTL1                        5
#define IDS_MTL1ON                      6
#define IDC_SIMPLE_EDIT                 1032
#define IDD_SKELETON_MATERIAL           1047
#define IDC_SIMPLE_SPIN                 1052
#define IDC_MTL1                        1061
#define IDC_MTLON1                      1642

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Material\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Material
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 11-3-99
 | 
\*===========================================================================*/

#include "Material.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonMtlDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Material\Material.h ===
/*===========================================================================*\
 | 
 |  FILE:	Material.h
 |			Skeleton project and code for a Material
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 11-3-99
 | 
\*===========================================================================*/

#ifndef __MTLSKEL__H
#define __MTLSKEL__H

#include "max.h"
#include <bmmlib.h>
#include "iparamm2.h"
#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	MTL_CLASSID		Class_ID(0x22c0542e, 0x37232afa)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonMtlDesc();


// Paramblock2 name
enum { mtl_params, }; 
// Paramblock2 parameter list
enum { mtl_simple_param, mtl_mat1, mtl_mat1_on };


// How many submtl's we support
#define NSUBMTL		1


/*===========================================================================*\
 |	SkeletonMaterial class defn
\*===========================================================================*/

class SkeletonMaterial : public Mtl {	
	public:

		// various variables
		float simple;
		Mtl *submtl[NSUBMTL];		
		BOOL mapOn[NSUBMTL];
		Interval ivalid;

		// Parameter and UI management
		IParamBlock2 *pblock; 	
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		Interval Validity(TimeValue t);
		void Reset();


		SkeletonMaterial(BOOL loading);
		Class_ID ClassID() {return MTL_CLASSID; }
		SClass_ID SuperClassID() {return MATERIAL_CLASS_ID;}
		void GetClassName(TSTR& s) {s=GetString(IDS_CLASSNAME);}  
		void DeleteThis() {delete this;}
		

		void NotifyChanged();


		// From MtlBase and Mtl
		void SetAmbient(Color c, TimeValue t);		
		void SetDiffuse(Color c, TimeValue t);		
		void SetSpecular(Color c, TimeValue t);
		void SetShininess(float v, TimeValue t);
		Color GetAmbient(int mtlNum=0, BOOL backFace=FALSE);
	    Color GetDiffuse(int mtlNum=0, BOOL backFace=FALSE);
		Color GetSpecular(int mtlNum=0, BOOL backFace=FALSE);
		float GetXParency(int mtlNum=0, BOOL backFace=FALSE);
		float GetShininess(int mtlNum=0, BOOL backFace=FALSE);		
		float GetShinStr(int mtlNum=0, BOOL backFace=FALSE);
		float WireSize(int mtlNum=0, BOOL backFace=FALSE);
				

		// Shade and displacement calculation
		void Shade(ShadeContext& sc);
		float EvalDisplacement(ShadeContext& sc); 
		Interval DisplacementValidity(TimeValue t); 
	

		// SubMaterial access methods
		int NumSubMtls() {return NSUBMTL;}
		Mtl* GetSubMtl(int i);
		void SetSubMtl(int i, Mtl *m);
		TSTR GetSubMtlSlotName(int i);
		TSTR GetSubMtlTVName(int i);

		// SubTexmap access methods
		int NumSubTexmaps() {return 0;}
		Texmap* GetSubTexmap(int i);
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);
		TSTR GetSubTexmapTVName(int i);

		// Number of subanims
		int NumSubs() {return 1+NSUBMTL;} 
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum;}

		// Number of references
 		int NumRefs() {return 1+NSUBMTL;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);


		RefTargetHandle Clone(RemapDir &remap = NoRemap());


		IOResult Save(ISave *isave); 
		IOResult Load(ILoad *iload); 


		// Direct Paramblock2 access
		int	NumParamBlocks() { return 1; }
		IParamBlock2* GetParamBlock(int i) { return pblock; }
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } 
		BOOL SetDlgThing(ParamDlg* dlg);
};



/*===========================================================================*\
 |	Dialog Processor
\*===========================================================================*/

class SkelMtlDlgProc : public ParamMap2UserDlgProc 
{
	public:
		IParamMap *pmap;
		SkeletonMaterial *sm;

		SkelMtlDlgProc(SkeletonMaterial *m) {sm = m;}		
		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { }
		void SetThing(ReferenceTarget *m) {
			sm = (SkeletonMaterial*)m;
			}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Material\MtlShade.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	MtlShade.cpp
 |			Skeleton project and code for a Material
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 11-3-99
 | 
\*===========================================================================*/

#include "Material.h"



/*===========================================================================*\
 |	Determine the characteristics of the material
\*===========================================================================*/

void SkeletonMaterial::SetAmbient(Color c, TimeValue t) {}		
void SkeletonMaterial::SetDiffuse(Color c, TimeValue t) {}		
void SkeletonMaterial::SetSpecular(Color c, TimeValue t) {}
void SkeletonMaterial::SetShininess(float v, TimeValue t) {}
				
Color SkeletonMaterial::GetAmbient(int mtlNum, BOOL backFace)
{
	return submtl[0]?submtl[0]->GetAmbient(mtlNum,backFace):Color(0,0,0);
}

Color SkeletonMaterial::GetDiffuse(int mtlNum, BOOL backFace)
{
	return submtl[0]?submtl[0]->GetDiffuse(mtlNum,backFace):Color(0,0,0);
}

Color SkeletonMaterial::GetSpecular(int mtlNum, BOOL backFace)
{
	return submtl[0]?submtl[0]->GetSpecular(mtlNum,backFace):Color(0,0,0);
}

float SkeletonMaterial::GetXParency(int mtlNum, BOOL backFace)
{
	return submtl[0]?submtl[0]->GetXParency(mtlNum,backFace):Color(0,0,0);
}

float SkeletonMaterial::GetShininess(int mtlNum, BOOL backFace)
{
	return submtl[0]?submtl[0]->GetShininess(mtlNum,backFace):Color(0,0,0);
}

float SkeletonMaterial::GetShinStr(int mtlNum, BOOL backFace)
{
	return submtl[0]?submtl[0]->GetShinStr(mtlNum,backFace):Color(0,0,0);
}

float SkeletonMaterial::WireSize(int mtlNum, BOOL backFace)
{
	return submtl[0]?submtl[0]->WireSize(mtlNum,backFace):Color(0,0,0);
}

		
/*===========================================================================*\
 |	Actual shading takes place
\*===========================================================================*/

void SkeletonMaterial::Shade(ShadeContext& sc) 
{
	Mtl *sm1 = mapOn[0]?submtl[0]:NULL;
	if (gbufID) sc.SetGBufferID(gbufID);

	if(sm1) sm1->Shade(sc);

	sc.out.c*=simple;
}

float SkeletonMaterial::EvalDisplacement(ShadeContext& sc)
{
	Mtl *sm1 = mapOn[0]?submtl[0]:NULL;
	return (sm1)?sm1->EvalDisplacement(sc):0.0f;
}

Interval SkeletonMaterial::DisplacementValidity(TimeValue t)
{
	Mtl *sm1 = mapOn[0]?submtl[0]:NULL;

	Interval iv; iv.SetInfinite();
	if(sm1) iv &= sm1->DisplacementValidity(t);

	return iv;	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Material\Material.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Material.cpp
 |			Skeleton project and code for a Material
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 11-3-99
 | 
\*===========================================================================*/

#include "Material.h"



/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonMaterialClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create( BOOL loading )		{ return new SkeletonMaterial(loading); }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return MATERIAL_CLASS_ID; }
	Class_ID 		ClassID()					{ return MTL_CLASSID; }
	const TCHAR* 	Category()					{ return _T("");  }

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()				{ return _T("SkeletonMaterial"); }
	HINSTANCE		HInstance()					{ return hInstance; }
};

static SkeletonMaterialClassDesc SkelMtlCD;
ClassDesc* GetSkeletonMtlDesc() {return &SkelMtlCD;}



/*===========================================================================*\
 |	Basic implimentation of a dialog handler
\*===========================================================================*/

BOOL SkelMtlDlgProc::DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}



/*===========================================================================*\
 |	Paramblock2 Descriptor
\*===========================================================================*/

static ParamBlockDesc2 smtl_param_blk ( mtl_params, _T("SkeletonMaterial parameters"),  0, &SkelMtlCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 1, 
	//rollout
	IDD_SKELETON_MATERIAL, IDS_PARAMETERS, 0, 0, NULL, 
	// params
	mtl_mat1,			_T("mtl_mat1"),			TYPE_MTL,	P_OWNERS_REF,	IDS_MTL1,
		p_refno,		0,
		p_submtlno,		0,		
		p_ui,			TYPE_MTLBUTTON, IDC_MTL1,
		end,
	mtl_mat1_on,		_T("mtl_mat1_on"),		TYPE_BOOL,		0,				IDS_MTL1ON,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MTLON1,
		end,
	mtl_simple_param,	_T("mtl_simple_param"),	TYPE_FLOAT,		P_ANIMATABLE,	IDS_SIMPLE,
		p_default,		1.0f,
		p_range,		0.0f, 1.0f,
		p_ui,			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SIMPLE_EDIT, IDC_SIMPLE_SPIN, 0.1f,
		end,

	end
	);



/*===========================================================================*\
 |	Constructor and Reset systems
 |  Ask the ClassDesc2 to make the AUTO_CONSTRUCT paramblocks and wire them in
\*===========================================================================*/

void SkeletonMaterial::Reset() 
{
	ivalid.SetEmpty();
	for (int i=0; i<NSUBMTL; i++) {
		DeleteReference(i);
		mapOn[i] = 1;
		}

	SkelMtlCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
}

SkeletonMaterial::SkeletonMaterial(BOOL loading) 
{
	for (int i=0; i<NSUBMTL; i++) submtl[i] = NULL;
	pblock = NULL;

	if (!loading) 
		Reset();
}

ParamDlg* SkeletonMaterial::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) 
{
	IAutoMParamDlg* masterDlg = SkelMtlCD.CreateParamDlgs(hwMtlEdit, imp, this);
	smtl_param_blk.SetUserDlgProc(new SkelMtlDlgProc(this));

	return masterDlg;
}

BOOL SkeletonMaterial::SetDlgThing(ParamDlg* dlg)
{
	return FALSE;
}

Interval SkeletonMaterial::Validity(TimeValue t)
{
	Interval valid = FOREVER;		

	for (int i=0; i<NSUBMTL; i++) 
	{
		if (submtl[i]) 
			valid &= submtl[i]->Validity(t);
	}
	
	float u;
	pblock->GetValue(mtl_simple_param,t,u,valid);
	return valid;
}


/*===========================================================================*\
 |	Subanim & References support
\*===========================================================================*/

RefTargetHandle SkeletonMaterial::GetReference(int i) 
{
	if (i < NSUBMTL )
		return submtl[i];
	else return pblock;
}

void SkeletonMaterial::SetReference(int i, RefTargetHandle rtarg) 
{
	if (i < NSUBMTL)
		submtl[i] = (Mtl *)rtarg; 
	else pblock = (IParamBlock2 *)rtarg; 
}

TSTR SkeletonMaterial::SubAnimName(int i) 
{
	if (i < NSUBMTL)
		return GetSubMtlTVName(i);
	else return TSTR(_T(""));
}

Animatable* SkeletonMaterial::SubAnim(int i) {
	if (i < NSUBMTL)
		return submtl[i]; 
	else return pblock;
	}

RefResult SkeletonMaterial::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) 
{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
				ParamID changing_param = pblock->LastNotifyParamID();
				smtl_param_blk.InvalidateUI(changing_param);
				}
			break;

		}
	return(REF_SUCCEED);
}



/*===========================================================================*\
 |	SubMtl get and set
\*===========================================================================*/

Mtl* SkeletonMaterial::GetSubMtl(int i)
{
	if (i < NSUBMTL )
		return submtl[i];
	return NULL;
}

void SkeletonMaterial::SetSubMtl(int i, Mtl *m)
{
	ReplaceReference(i,m);
	if (i==0)
	{
		smtl_param_blk.InvalidateUI(mtl_mat1);
		ivalid.SetEmpty();
	}	
}

TSTR SkeletonMaterial::GetSubMtlSlotName(int i)
{
	switch(i) {
		case 0:  return TSTR(GetString(IDS_MTL1)); 
		default: return TSTR(_T(""));
	}
}

TSTR SkeletonMaterial::GetSubMtlTVName(int i)
{
	return GetSubMtlSlotName(i);
}


/*===========================================================================*\
 |	Texmap get and set
 |  By default, we support none
\*===========================================================================*/

Texmap* SkeletonMaterial::GetSubTexmap(int i)
{
	return NULL;
}

void SkeletonMaterial::SetSubTexmap(int i, Texmap *m)
{
}

TSTR SkeletonMaterial::GetSubTexmapSlotName(int i)
{
	return _T("");
}

TSTR SkeletonMaterial::GetSubTexmapTVName(int i)
{
	return GetSubTexmapSlotName(i);
}



/*===========================================================================*\
 |	Standard IO
\*===========================================================================*/

#define MTL_HDR_CHUNK 0x4000

IOResult SkeletonMaterial::Save(ISave *isave) { 
	IOResult res;
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	return IO_OK;
	}	

IOResult SkeletonMaterial::Load(ILoad *iload) { 
	IOResult res;
	int id;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	return IO_OK;
	}




/*===========================================================================*\
 |	Updating and cloning
\*===========================================================================*/


RefTargetHandle SkeletonMaterial::Clone(RemapDir &remap) {
	SkeletonMaterial *mnew = new SkeletonMaterial(FALSE);
	*((MtlBase*)mnew) = *((MtlBase*)this); 
	mnew->ReplaceReference(NSUBMTL,remap.CloneRef(pblock));

	mnew->ivalid.SetEmpty();	
	for (int i = 0; i<NSUBMTL; i++) {
		mnew->submtl[i] = NULL;
		if (submtl[i])
			mnew->ReplaceReference(i,remap.CloneRef(submtl[i]));
		mnew->mapOn[i] = mapOn[i];
		}
	return (RefTargetHandle)mnew;
	}

void SkeletonMaterial::NotifyChanged() 
{
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

void SkeletonMaterial::Update(TimeValue t, Interval& valid) 
{		
	if (!ivalid.InInterval(t)) {

		ivalid.SetInfinite();
		pblock->GetValue( mtl_mat1_on, t, mapOn[0], ivalid);
		pblock->GetValue( mtl_simple_param, t, simple, ivalid);

		for (int i=0; i<NSUBMTL; i++) {
			if (submtl[i]) 
				submtl[i]->Update(t,ivalid);
			}
		}
	valid &= ivalid;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\MAXScriptSDK\Class\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			MAX Script SDK Example - adding a value class to MAX Script
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 1-4-99
 | 
\*===========================================================================*/

#include "MAXScrpt.h"


HMODULE hInstance = NULL;


BOOL APIENTRY
DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
	static BOOL controlsInit = FALSE;
	switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			// Hang on to this DLL's instance handle.
			hInstance = hModule;
			if ( !controlsInit )
			{
				controlsInit = TRUE;				
				// Initialize Win95 controls
 				InitCommonControls();
			}
			break;
	}
		
	return(TRUE);
}

__declspec( dllexport ) const TCHAR *
LibDescription() { return _T("SimpleStore MAX Script SDK Example (Class)"); }

__declspec( dllexport ) ULONG
LibVersion() {  return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\MAXScriptSDK\Class\SimpleStore.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			MAX Script SDK Example - adding a value class to MAX Script
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 1-4-99
 | 
\*===========================================================================*/

#include "MAXScrpt.h"

// Various MAX and MXS includes
#include "Numbers.h"
#include "MAXclses.h"
#include "Streams.h"
#include "MSTime.h"
#include "MAXObj.h"
#include "Parser.h"

#include "max.h"
#include "stdmat.h"

// define the new primitives using macros from SDK
#include "definsfn.h"
#include "defimpfn.h"	


// Redefine so we can export our custom class
#ifdef ScripterExport
	#undef ScripterExport
#endif
#define ScripterExport __declspec( dllexport )



/*===========================================================================*\
 |	A very simple new class - just mimicks the Point3 storage class
 |  The type of class built is entirely subjective and up to the developer
\*===========================================================================*/

applyable_class (SimpleStore)

class SimpleStore : public Value
{

public:
	Point3 iValue;

	// The various ways to contruct this class
	ScripterExport	SimpleStore();
	ScripterExport	SimpleStore(float x,float y,float z);

	classof_methods(SimpleStore, Value);

	// Garbage collection
	void			collect() { delete this; }

	// Print out our contents in readable form
	ScripterExport	void	sprin1(CharStream* s);	

	// Make a new instance of this class, based on some parameters
	static Value*	make(Value**arg_list, int count);

	// Define some operators
	use_generic( eq,		"=");
	use_generic( ne,		"!=");

	// Define some functions (is zeroify a word?)
	def_visible_generic( zeroify,	"zeroify");			

	// Define some properties
	def_property ( x );
	def_property ( y );
	def_property ( z );


	// Cast back to MAXSDK value
	Point3&		to_max_point3() { return iValue; }
};


visible_class_instance (SimpleStore, _T("SimpleStore"))



/*===========================================================================*\
 |	Implimentations of any class functions
\*===========================================================================*/

Value*														
SimpleStore::zeroify_vf(Value** arg_list, int count)			
{															
	check_arg_count(isEmpty, 1, count + 1);	
	iValue = Point3(0,0,0);

	return &true_value;
}



/*===========================================================================*\
 |	Class-level constructors
\*===========================================================================*/

SimpleStore::SimpleStore()
{
	tag = class_tag(SimpleStore);	
}

SimpleStore::SimpleStore(float x,float y,float z)
{
	tag = class_tag(SimpleStore);
	iValue = Point3(x,y,z);
}



/*===========================================================================*\
 |	Accessor macros - 4 values needed:
 |	name of class to use | name of property | code to access our variable | code to set our variable
\*===========================================================================*/

def_fn_prop_accessors (SimpleStore, x, 
					   Float::intern(iValue.x), 
					   iValue.x = (val->to_float()))

def_fn_prop_accessors (SimpleStore, y, 
					   Float::intern(iValue.y), 
					   iValue.y = (val->to_float()))

def_fn_prop_accessors (SimpleStore, z, 
					   Float::intern(iValue.z), 
					   iValue.z = (val->to_float()))



/*===========================================================================*\
 |	Fill in the == and != operators
 |	Give the macro two values - our internal value, and a cast for the incoming Value
\*===========================================================================*/

def_eq_op(SimpleStore, to_point3, iValue)
def_ne_op(SimpleStore, to_point3, iValue)



/*===========================================================================*\
 |	Two important calls:
 |	'make' asks us to construct a basic new instance of the class
 |	'apply' is used to iterate variables, Eval()ing them as we go (notice different class)
\*===========================================================================*/

Value*
SimpleStore::make(Value**arg_list, int count)
{
	check_arg_count(make, 3, count);

	float x = arg_list[0]->to_float(), y = arg_list[1]->to_float(), z = arg_list[2]->to_float();
	return new SimpleStore (x, y, z);
}

Value*
SimpleStoreClass::apply(Value** arg_list, int count)
{
	init_thread_locals();
	three_value_locals(x1, y1, z1);
	Value* result;
	
	if (count == 3)
	{
		vl.x1 = arg_list[0]->eval();
		vl.y1 = arg_list[1]->eval();
		vl.z1 = arg_list[2]->eval();
		result =  new SimpleStore((vl.x1->to_float()), (vl.y1->to_float()), (vl.z1->to_float()));
	}
	else
		check_arg_count(SimpleStore, 3, count);
	pop_value_locals();	

	return result;
}


/*===========================================================================*\
 |	Print out the contents of the class
\*===========================================================================*/

void
SimpleStore::sprin1(CharStream* s)
{
	s->printf(_T("[X:%.2f  Y:%.2f  Z:%.2f]"), iValue.x, iValue.y, iValue.z);
}


/*===========================================================================*\
 |	MAXScript Plugin Initialization
\*===========================================================================*/

__declspec( dllexport ) void
LibInit() { 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\MAXScriptSDK\Function\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			MAX Script SDK Example - adding a new function to the language
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 1-4-99
 | 
\*===========================================================================*/

#include "MAXScrpt.h"


HMODULE hInstance = NULL;

BOOL APIENTRY
DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
	static BOOL controlsInit = FALSE;
	switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			// Hang on to this DLL's instance handle.
			hInstance = hModule;
			if ( !controlsInit )
			{
				controlsInit = TRUE;				
				// Initialize Win95 controls
 				InitCommonControls();
			}
			break;
	}
		
	return(TRUE);
}

__declspec( dllexport ) const TCHAR *
LibDescription() { return _T("Tex_on MAX Script SDK Example (Function)"); }

__declspec( dllexport ) ULONG
LibVersion() {  return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\MAXScriptSDK\Function\Tex_on.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			MAX Script SDK Example - adding a new function to the language
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 1-4-99
 | 
\*===========================================================================*/

#include "MAXScrpt.h"

// Various MAX and MXS includes
#include "Numbers.h"
#include "MAXclses.h"
#include "Streams.h"
#include "MSTime.h"
#include "MAXObj.h"
#include "Parser.h"

#include "max.h"
#include "stdmat.h"

// define the new primitives using macros from SDK
#include "definsfn.h"




/*===========================================================================*\
 |	Define our new functions
 |	These will turn on texture map display at all levels for a given object
\*===========================================================================*/

def_visible_primitive( all_tex_on,			"TurnAllTexturesOn");
def_visible_primitive( all_tex_off,			"TurnAllTexturesOff");




/*===========================================================================*\
 |	This is used below, as our recursive function to turn on texture maps
\*===========================================================================*/

class CMtlEnum 
{
	public:

		virtual void  proc(MtlBase *m, BOOL state, Interface *ip)
		{
			// Check for stdmaterial, get the diffuse map and turn it on/off
			if(m->ClassID()==Class_ID(DMTL_CLASS_ID, 0)) 
			{
				StdMat *smat = (StdMat*)m;
				Texmap *bt = smat->GetSubTexmap(ID_DI);

				if(state) ip->ActivateTexture(bt, smat); 
				else ip->DeActivateTexture(bt, smat);
			}
		}
};

// Static instance of our recursive function
CMtlEnum CEnym;


// Do the material enumeration
void CEnumMtlTree(MtlBase *mb, CMtlEnum &tenum, BOOL state, Interface *ip) 
{
	// Call the recursion
	tenum.proc(mb,state,ip);
	if (IsMtl(mb)) 
	{
		// Go through all the sub materials
		Mtl *m = (Mtl *)mb;
		for (int i=0; i<m->NumSubMtls(); i++) 
		{
			Mtl *sm = m->GetSubMtl(i);
			if (sm) 
				CEnumMtlTree(sm,tenum,state,ip);
		}
	}
}




/*===========================================================================*\
 |	Implimentations of our new function calls
 |	notice the appended '_cf' to show its the function implimentation
\*===========================================================================*/

Value*
all_tex_on_cf(Value** arg_list, int count)
{
	// Make sure we have the correct number of arguments (2)
	check_arg_count(all_tex_on, 1, count);

	// Check to see if the arguments match up to what we expect
	// We want to use 'TurnAllTexturesOn <object to use>'
	type_check(arg_list[0], MAXNode, "TurnAllTexturesOn [Object]");

	// Get a good interface pointer
	Interface *ip = MAXScript_interface;

	// Get a INode pointer from the argument passed to us
	INode *node = arg_list[0]->to_node();

	// Recurse and turn all textures on
	MtlBase* mat = (MtlBase*)node->GetMtl();
	if (mat)
		CEnumMtlTree(mat,CEnym,TRUE,ip);

	// redraw and update
	node->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE); 
	ip->RedrawViews(ip->GetTime());

	return &true_value;
}


// For code notes, see above
Value*
all_tex_off_cf(Value** arg_list, int count)
{
	check_arg_count(all_tex_on, 1, count);
	type_check(arg_list[0], MAXNode, "TurnAllTexturesOff [Object]");

	Interface *ip = MAXScript_interface;
	INode *node = arg_list[0]->to_node();

	// The only difference is the FALSE state flag
	MtlBase* mat = (MtlBase*)node->GetMtl();
	if (mat)
		CEnumMtlTree(mat,CEnym,FALSE,ip);

	node->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE); 
	ip->RedrawViews(ip->GetTime());

	return &true_value;
}


/*===========================================================================*\
 |	MAXScript Plugin Initialization
\*===========================================================================*/

__declspec( dllexport ) void
LibInit() { 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\MAXScriptSDK\SysVariable\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			MAX Script SDK Example - adding a new system variable
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 1-4-99
 | 
\*===========================================================================*/

#include "MAXScrpt.h"

 
HMODULE hInstance = NULL;

BOOL APIENTRY
DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
	static BOOL controlsInit = FALSE;
	switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			// Hang on to this DLL's instance handle.
			hInstance = hModule;
			if ( !controlsInit )
			{
				controlsInit = TRUE;				
				// Initialize Win95 controls
 				InitCommonControls();
			}
			break;
	}
		
	return(TRUE);
}

__declspec( dllexport ) const TCHAR *
LibDescription() { return _T("NumPlugs MAX Script SDK Example (SystemVariable)"); }

__declspec( dllexport ) ULONG
LibVersion() {  return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\MAXScriptSDK\UIControl\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			MAX Script SDK Example - adding a new UI element to the language
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 1-4-99
 | 
\*===========================================================================*/

#include "MAXScrpt.h"

 
HMODULE hInstance = NULL;

BOOL APIENTRY
DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
	static BOOL controlsInit = FALSE;
	switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			// Hang on to this DLL's instance handle.
			hInstance = hModule;
			if ( !controlsInit )
			{
				controlsInit = TRUE;				
				// Initialize Win95 controls
 				InitCommonControls();
			}
			break;
	}
		
	return(TRUE);
}

__declspec( dllexport ) const TCHAR *
LibDescription() { return _T("Simple UI MAX Script SDK Example (UIControl)"); }

__declspec( dllexport ) ULONG
LibVersion() {  return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\ObjectSnap\ObjectSnap.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	ObjectSnap.cpp
 |			Skeleton project and code for an Object Snap extension
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 2-2-99
 | 
\*===========================================================================*/

#include "ObjectSnap.h"



/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonOSnapClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create( BOOL loading ) { return new SkeletonSnap; }
	const TCHAR *	ClassName() { return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID() { return OSNAP_CLASS_ID; }
	Class_ID 		ClassID() { return OSNAP_CLASSID; }
	const TCHAR* 	Category() { return GetString(IDS_CATEGORY);  }
};

static SkeletonOSnapClassDesc SkeletonOSNCD;
ClassDesc* GetSkeletonOSnapDesc() {return &SkeletonOSNCD;}



/*===========================================================================*\
 |	Snap identifiers and object checking
\*===========================================================================*/

TSTR *SkeletonSnap::snapname(int index)
{
	return &name[index];
}

TSTR *SkeletonSnap::tooltip(int index)
{
	return &name[index];
}


SkeletonSnap::SkeletonSnap()
{
	tools = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_ICONS));
	masks = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_MASK));
	name[DEFSNAP] = TSTR(GetString(IDS_SKELSNAP));
	markerdata[DEFSNAP] = OsnapMarker(CDPD_SIZE,custMarker_dat,custMarker_vis);
}

SkeletonSnap::~SkeletonSnap()
{
	DeleteObject(tools);
	DeleteObject(masks);
}

boolean SkeletonSnap::ValidInput(SClass_ID scid, Class_ID cid)
{
	boolean sc_ok = FALSE;
	sc_ok |= (scid == GEOMOBJECT_CLASS_ID)? TRUE : FALSE;
	return sc_ok;
}



/*===========================================================================*\
 |	Return our custom point
\*===========================================================================*/

OsnapMarker *SkeletonSnap::GetMarker(int index)
{
	return &(markerdata[index]);
} 



/*===========================================================================*\
 |	The actual Snapping function itself
\*===========================================================================*/

void SkeletonSnap::Snap(Object* pobj, IPoint2 *p, TimeValue t)
{	
	//local copy of the cursor position
	Point2 fp = Point2((float)p->x, (float)p->y);

	BOOL got_snap= FALSE; int i;


	// Check to see if the snap #1 is active
	if(	GetActive(DEFSNAP))
	{

		// A simple 'Snap to deformable point' snap routine
		if(pobj->IsDeformable())
		{
			int numPts = pobj->NumPoints();
			Point3 *checkPoints = new Point3[1];

			for(i=0;i<numPts;i++)
			{
				checkPoints[0] = pobj->GetPoint(i);
				if(CheckPotentialHit(checkPoints,0,fp))
					theman->RecordHit(new OsnapHit(checkPoints[0], this, DEFSNAP, NULL));
			}
		}
	
	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\MAXScriptSDK\SysVariable\NumPlugs.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			MAX Script SDK Example - adding a new system variable
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 1-4-99
 | 
\*===========================================================================*/

#include "MAXScrpt.h"

// Various MAX and MXS includes
#include "Numbers.h"
#include "MAXclses.h"
#include "Streams.h"
#include "MSTime.h"
#include "MAXObj.h"
#include "Parser.h"

#include "max.h"

// define the new primitives using macros from SDK
#include "definsfn.h"



/*===========================================================================*\
 |	The new get/set functions for our system variable
 |	We will use the DLLDirectory methods to see how many plugins are loaded in MAX
\*===========================================================================*/

Value*
get_numplugs()
{
	// Get a pointer to the interface
	Interface *ip = MAXScript_interface;

	// Get the DLLDir, and ask for a count
	DllDir *dl = ip->GetDllDirectory();
	return Integer::intern(dl->Count());
}

Value*
set_numplugs(Value* val)
{
	// We can't SET the number of loaded plugins.. so return false
	return &false_value;
}



/*===========================================================================*\
 |	MAXScript Plugin Initialization
 |	Ask MAX Script to regester us a new system variable
\*===========================================================================*/

__declspec( dllexport ) void
LibInit() { 
	define_system_global("NumPlugins", get_numplugs, set_numplugs);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\MAXScriptSDK\UIControl\SimpleUI.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			MAX Script SDK Example - adding a new UI element to the language
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 1-4-99
 | 
\*===========================================================================*/

#include "MAXScrpt.h"

// Various MAX and MXS includes
#include "Numbers.h"
#include "MAXclses.h"
#include "Streams.h"
#include "MSTime.h"
#include "MAXObj.h"
#include "Parser.h"
#include "ColorVal.h"
#include "Rollouts.h"

#include "max.h"
#include "shellapi.h"
#include "commdlg.h"
#include "utilapi.h"
#include "bmmlib.h"


// Redefine so we can export our custom class
#ifdef ScripterExport
	#undef ScripterExport
#endif
#define ScripterExport __declspec( dllexport )


// flag to say when we have registered our custom controls
static BOOL SUI_Reg = FALSE;



/*===========================================================================*\
 |	We will define the name of our new window class, as well as
 |	any custom event names and internal value names we intend to use
\*===========================================================================*/

// Window Classes
#define SIMPLE_WINDOWCLASS _T("SIMPLE_WINDOWCLASS")
//-----


// My MXS Event Handlers
#define n_clicked		Name::intern(_T("clicked"))
//-----


// My MXS Custom Names
#define n_inout			Name::intern(_T("inout"))
//-----



/*===========================================================================*\
 |	Class definition of our new RolloutControl
 |	visible_class macro registers this class as exportable to MAX Script
\*===========================================================================*/

class SimpleUI_Control;
visible_class (SimpleUI_Control)


class SimpleUI_Control : public RolloutControl
{
public:

	// custom parameters
	BOOL inout;
	

		// Constructor
		SimpleUI_Control(Value* name, Value* caption, Value** keyparms, int keyparm_count)
			: RolloutControl(name, caption, keyparms, keyparm_count)  
		{ 
			tag = class_tag(SimpleUI_Control);
		}

		static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new SimpleUI_Control (name, caption, keyparms, keyparm_count); }


		classof_methods (SimpleUI_Control, RolloutControl);


		// Garbage collection
		void		collect() { delete this; }

		// Print out the internal name of the control to MXS
		void		sprin1(CharStream* s) { s->printf(_T("SimpleUI_Control:%s"), name->to_string()); }

		// Add the control itself to a rollout window
		void		add_control(Rollout *ro, int id, HWND parent, HINSTANCE hInstance, int& current_y);

		// Return the window class name 
		LPCTSTR		get_control_class() { return SIMPLE_WINDOWCLASS; }

		// Top-level call for changing rollout layout. We don't process this.
		void		compute_layout(Rollout *ro, layout_data* pos) { }

		// Handle any messages coming in from the system
		BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);

		// 3 Functions to handle setting and getting custom values in this control
		Value*		get_property(Value** arg_list, int count);
		Value*		set_property(Value** arg_list, int count);
		void		set_enable();
};



/*===========================================================================*\
 |	Dialog handler for our custom window class
 |	Just paint a button type thing on the window, and capture clicks -> MXS
\*===========================================================================*/

LRESULT CALLBACK SUI_WndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
	// Get back at our stored class pointer
	SimpleUI_Control *SUI = (SimpleUI_Control*)GetWindowLong(hWnd,GWL_USERDATA);

	switch ( message ) {
	

		// We catch a mouse down, fire it back to MXS as an 'event'
		case WM_LBUTTONDOWN:
			{
				init_thread_locals();
				one_value_local(arg);
				
				// Get the location of the click
				int xPos = LOWORD(lParam);
				int yPos = HIWORD(lParam);

				// Put it into a MXS acceptable value
				vl.arg = new Point2Value((float)xPos,(float)yPos);

				// Call the event handler with 'n_clicked'
				// MXS will now receive the event and pass it to the dialog rollout
				SUI->call_event_handler(SUI->parent_rollout, n_clicked, &vl.arg, 1);
				pop_value_locals();
			}
			break;


		// Do some drawing onto the control's surface
		case WM_PAINT:
			{
				// begin paint cycle
				PAINTSTRUCT ps;
				HDC hdc;
				hdc = BeginPaint( hWnd, &ps );

				// Do some simple drawing (a 3D frame)
				Rect rect;
				GetClientRect(hWnd,&rect);
				rect.left ++;rect.top ++;rect.right --;rect.bottom --;
				Rect3D(hdc,rect,SUI->inout);
				rect.left ++;rect.top ++;rect.right --;rect.bottom --;
				Rect3D(hdc,rect,SUI->inout);


				// end paint cycle
				EndPaint( hWnd, &ps );
				return 0;
			}

	}

	return TRUE;
}

visible_class_instance (SimpleUI_Control,_T("SimpleUI_Control"));



/*===========================================================================*\
 |	Implimentations of the class functions
\*===========================================================================*/

void
SimpleUI_Control::add_control(Rollout *ro, int id, HWND parent, HINSTANCE hInstance, int& current_y)
{
	HWND	simpleUI;
	TCHAR*	text = caption->eval()->to_string();

	// We'll hang onto these...
	parent_rollout = ro;
	control_ID = id;

	// compute bounding box, apply layout params
	layout_data pos;
	setup_layout(ro, &pos, current_y);
	
	// supply some layout defaults
	Value* Wtmp = control_param(width);
	if(Wtmp==&unsupplied) pos.width = 120;
	Value* Htmp = control_param(height);
	if(Htmp==&unsupplied) pos.height = 20;


	// Load in some values from the user, if they were given...
	Value* Btmp = control_param(inout);
	if(Btmp==&unsupplied) inout = FALSE;
	else
		inout = Btmp->to_bool();


	// Pass the info back to MXS to 
	// let it calculate final position
	process_layout_params(ro, &pos, current_y);


	// Have we already registered this wndclass?
	if(!SUI_Reg)				
	{
		WNDCLASS wc;

		// Just a simple UI frame control thing
		wc.style         = CS_HREDRAW | CS_VREDRAW;
		wc.hInstance     = hInstance;
		wc.hIcon         = NULL;
		wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
		wc.hbrBackground = GetSysColorBrush(COLOR_WINDOW);
		wc.lpszMenuName  = NULL;
		wc.cbClsExtra    = 0;
		wc.cbWndExtra    = 0;
		wc.lpfnWndProc   = SUI_WndProc;
		wc.lpszClassName = SIMPLE_WINDOWCLASS;
		RegisterClass(&wc);	
		SUI_Reg = TRUE;
	}


	simpleUI = CreateWindow(
							SIMPLE_WINDOWCLASS,
							text,
							WS_VISIBLE | WS_CHILD | WS_GROUP,
							pos.left, pos.top, pos.width, pos.height,    
							parent, (HMENU)id, hInstance, NULL);


	// Squirrel away the class pointer, as we need this in the dlg proc
	SetWindowLong(simpleUI, GWL_USERDATA, (DWORD)this);	
}



BOOL
SimpleUI_Control::handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam)
{
	// Deligate, Deligate...
	// All messages processing is done in our dlg proc
	if (message == WM_PAINT)
	{
   		SendMessage(GetDlgItem(ro->page, control_ID), WM_PAINT, wParam, lParam);
		return TRUE;
	}
	return FALSE;
}



Value*
SimpleUI_Control::get_property(Value** arg_list, int count)
{
	Value* prop = arg_list[0];

	if (prop == n_inout)
		return inout? &true_value : &false_value;
	else
		return RolloutControl::get_property(arg_list, count);
}



Value*
SimpleUI_Control::set_property(Value** arg_list, int count)
{
	Value* val = arg_list[0];
	Value* prop = arg_list[1];

	if (prop == n_inout)
	{
		if (parent_rollout != NULL && parent_rollout->page != NULL)
		{
			inout = val->to_bool();

			HWND item = (GetDlgItem(parent_rollout->page, control_ID));

			// rebuild the dialog item
			// have to do this to update in loops on a page
			InvalidateRect(item,NULL,FALSE);
	   		SendMessage(GetDlgItem(parent_rollout->page, control_ID), WM_PAINT, 0, 0);
		}
		return val;
	}
	else return RolloutControl::set_property(arg_list, count);
}

void
SimpleUI_Control::set_enable()
{
	// Enable/disable the window item and refresh 
	HWND ctrl = GetDlgItem(parent_rollout->page, control_ID);
	if (ctrl)
	{
		EnableWindow(ctrl, enabled);
		InvalidateRect(ctrl,NULL,FALSE);
   		SendMessage(GetDlgItem(parent_rollout->page, control_ID), WM_PAINT, 0, 0);
	}

}



/*===========================================================================*\
 |	MAXScript Plugin Initialization
 |	Ask MAX Script to regester us as a new UI insertable control
\*===========================================================================*/

__declspec( dllexport ) void
LibInit() { 
	install_rollout_control(Name::intern("SimpleUI_Control"), SimpleUI_Control::create);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\ObjectSnap\ObjectSnap.h ===
/*===========================================================================*\
 | 
 |  FILE:	ObjectSnap.h
 |			Skeleton project and code for an Object Snap extension
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 2-2-99
 | 
\*===========================================================================*/

#ifndef __OSNAPSKEL__H
#define __OSNAPSKEL__H

#include "max.h"
#include "osnapapi.h"
#include "simpobj.h"
#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	OSNAP_CLASSID		Class_ID(0x6ce9517c, 0x3c3133f7)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonOSnapDesc();


// Number of snaps supported
#define SNAPCOUNT	1

// Index's of snaps
#define DEFSNAP		0



/*===========================================================================*\
 |	Custom display point data -- a larger box than normal
\*===========================================================================*/

#define CDPD_SIZE	5

static IPoint3 custMarker_dat[CDPD_SIZE]=
{ 
 IPoint3(5,      5,      0),
 IPoint3(-5,      5,      0),
 IPoint3(-5,      -5,      0),
 IPoint3(5,      -5,      0),
 IPoint3(5,      5,      0)
};

static int custMarker_vis[CDPD_SIZE]=
{
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS
};

/*===========================================================================*\
 |	SkeletonSnap class defn
\*===========================================================================*/

class SkeletonSnap : public Osnap 
{

private:
	//A local array of subsnap names 
	TSTR name[SNAPCOUNT]; 

	// Static list of our custom markers
	OsnapMarker markerdata[SNAPCOUNT];

	// Appearance bitmaps
	HBITMAP tools; 
	HBITMAP masks; 

public:

	SkeletonSnap();
	~SkeletonSnap();

	// The number of snaps we support, and their names
	int numsubs(){return SNAPCOUNT;} 
	TSTR *snapname(int index); 
	TSTR *tooltip(int index);

	// plugin naming and category
	TCHAR* Category(){return GetString(IDS_CATEGORY);}
	Class_ID ClassID() { return OSNAP_CLASSID; }

	// Check to see if the input object is something we support
	boolean ValidInput(SClass_ID scid, Class_ID cid);

	// Get the type of marker to display. NULL = default.
	OsnapMarker *GetMarker(int index);

	// Accelerator key mapping
	WORD AccelKey(int index){return 0;};
	
	// Get the visual display of our snap
	HBITMAP getTools(){return tools;} 
	HBITMAP getMasks(){return masks;} 
	
	// Snap the point
	void Snap(Object* pobj, IPoint2 *p, TimeValue t);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\ObjectSnap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ObjectSnap.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_LIBDESC                     4
#define IDS_CATEGORY                    5
#define IDS_SKELSNAP                    6
#define IDB_MASK                        104
#define IDB_ICONS                       105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\ObjectSnap\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for an Object Snap extension
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1999
 |			All Rights Reserved.
 |
 |  HIST:	Started 2-2-99
 | 
\*===========================================================================*/

#include "ObjectSnap.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonOSnapDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\PreFilter\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PreFilter.rc
//
#define IDS_COMMENT                     1
#define IDS_BLANK                       2
#define IDS_CLASSNAME                   3
#define IDS_PARAM1                      4
#define IDS_PARAM2                      5
#define IDS_PARAMETERS                  6
#define IDS_LIBDESC                     7
#define IDS_PARAM1_PN                   8
#define IDS_PARAM2_PN                   9

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\PreFilter\PreFilter.h ===
/*===========================================================================*\
 | 
 |  FILE:	PreFilter.cpp
 |			Skeleton project and code for a Prefilter Kernel
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#ifndef __KERNSKEL__H
#define __KERNSKEL__H

#include "max.h"
#include "render.h"
#include "iparamm.h"

#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	KERN_CLASSID		Class_ID(0x11781c8a, 0x13d059bc)


extern ClassDesc* GetSkeletonKernDesc();
TCHAR *GetString(int id);



/*===========================================================================*\
 |	Parameter Block defines
\*===========================================================================*/

#define PB_S1	0
#define PB_S2	1

#define SKBLOCK_LENGTH 2

// Version definition
#define SKNUM_OLDVERSIONS	0
#define SKCURRENT_VERSION	1



/*===========================================================================*\
 |	SkeletonKernel class defn
\*===========================================================================*/

class SkeletonKernel: public FilterKernel {
	private:
		// We store 2 parameters
		double param1, param2;

	public:
		// Parameters
		IParamBlock *pblock;
		

		SkeletonKernel();
		~SkeletonKernel() { 	};
		void DeleteThis() {delete this;};


		// Animatable/Reference
		int NumSubs() {return 1;};
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);

		// References
		int NumRefs() {return 1;};
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message);
		RefTargetHandle Clone( RemapDir &remap );

		// ClassID/ClassName identifiers
		Class_ID ClassID() {return KERN_CLASSID;};
		void GetClassName(TSTR& s) {s=GetString(IDS_CLASSNAME);};

		// Standard load/save
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);

		TSTR GetName() { return GetString(IDS_CLASSNAME); }

		// Kernel parameter setup and handling
		long GetNFilterParams();
		TCHAR * GetFilterParamName( long nParam );
		double GetFilterParam( long nParam );
		void SetFilterParam( long nParam, double val );
		TCHAR * GetDefaultComment();

		void Update(TimeValue t, Interval& valid);


		// Actual kernel function
		double KernelFn( double x, double y );

		// Kernel functionality queries
		long GetKernelSupport();
		long GetKernelSupportY();
		bool Is2DKernel();
		bool IsVariableSz();
		void SetKernelSz( double x, double y = 0.0 );
		void GetKernelSz( double& x, double& y );
		bool IsNormalized();
		bool HasNegativeLobes();
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\PreFilter\PreFilter.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	PreFilter.cpp
 |			Skeleton project and code for a Prefilter Kernel
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#include "PreFilter.h"



/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonKernClassDesc:public ClassDesc {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create(BOOL loading)		{ return new SkeletonKernel; }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return FILTER_KERNEL_CLASS_ID; }
	Class_ID 		ClassID()					{ return KERN_CLASSID; }
	const TCHAR* 	Category()					{ return _T("");  }
};

static SkeletonKernClassDesc SkeletonKernCD;
ClassDesc* GetSkeletonKernDesc() {return &SkeletonKernCD;}



/*===========================================================================*\
 |	Parameter Block
\*===========================================================================*/

static ParamBlockDescID SkeletonKernDescV0[] = {
	{ TYPE_FLOAT, NULL, TRUE, PB_S1 }, 
	{ TYPE_FLOAT, NULL, TRUE, PB_S2 } 
}; 	

static ParamVersionDesc curSkeletonVersion( SkeletonKernDescV0, SKBLOCK_LENGTH, SKCURRENT_VERSION );



/*===========================================================================*\
 |	Kernel Parameter returns - basic custom parameter support
\*===========================================================================*/

// Number of parameters we support
long SkeletonKernel::GetNFilterParams() { return 2; }

// Get the name of parameter #nParam
TCHAR * SkeletonKernel::GetFilterParamName( long nParam )
{ 
	return GetString( nParam ? IDS_PARAM2:IDS_PARAM1 );
}

// Get the value of parameter #nParam
double SkeletonKernel::GetFilterParam( long nParam )
{
	return nParam ? param2 : param1;
}

// Set our parameter variables
void SkeletonKernel::SetFilterParam( long nParam, double val )
{
	if (nParam) {  
		param2 = val;	
		pblock->SetValue( PB_S2, 0, float( val ) );		
 	} else { 
		param1 = val; 
		pblock->SetValue( PB_S1, 0, float( val ) );		
	}
}

void SkeletonKernel::Update(TimeValue t, Interval& valid){
	float val;
	pblock->GetValue( PB_S1, t, val, valid ); param1 = val;
	pblock->GetValue( PB_S2, t, val, valid ); param2 = val;
}



/*===========================================================================*\
 |	Kernel Description
\*===========================================================================*/

TCHAR * SkeletonKernel::GetDefaultComment() 
{
	return GetString(IDS_COMMENT); 
}



/*===========================================================================*\
 |	Constructor, Load & Save
\*===========================================================================*/

SkeletonKernel::SkeletonKernel()
{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(SkeletonKernDescV0, SKBLOCK_LENGTH, SKCURRENT_VERSION));
	assert(pblock);

	param1 = 0.3f;
	param2 = 0.6f;
	pblock->SetValue(PB_S1, 0, (float)param1 );		
	pblock->SetValue(PB_S2, 0, (float)param2 );		
}

IOResult SkeletonKernel::Load(ILoad *iload)
{
	FilterKernel::Load(iload);
	return IO_OK;
}
IOResult SkeletonKernel::Save(ISave *isave)
{
	FilterKernel::Save(isave);
	return IO_OK;
}



/*===========================================================================*\
 |	Subanim & References support
\*===========================================================================*/

Animatable* SkeletonKernel::SubAnim(int i) 
{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
	}
}

TSTR SkeletonKernel::SubAnimName(int i) 
{
	switch (i) {
		case 0: return GetString(IDS_PARAMETERS);
		default: return _T("");
	}
}

RefTargetHandle SkeletonKernel::GetReference(int i)
{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
	}
}

void SkeletonKernel::SetReference(int i, RefTargetHandle rtarg)
{
	switch (i) {
		case 0: pblock = (IParamBlock*)rtarg; break;
	}
}

RefResult SkeletonKernel::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	GetParamName * gpn;

	switch (message) {
		case REFMSG_CHANGE:
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim * gpd = (GetParamDim*)partID;
				gpd->dim = defaultDim;
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_S1:			gpn->name = GetString(IDS_PARAM1_PN); break;
				case PB_S2:			gpn->name = GetString(IDS_PARAM2_PN); break;
				default:			gpn->name = _T(""); break;
			}
			return REF_STOP; 
		}
	}
	return REF_SUCCEED;
}

RefTargetHandle SkeletonKernel::Clone( RemapDir &remap )
{
	SkeletonKernel* skNew = new SkeletonKernel();
	skNew->ReplaceReference(0,remap.CloneRef(pblock));
	return (RefTargetHandle)skNew;
}



/*===========================================================================*\
 |	Calculate a result
\*===========================================================================*/

double SkeletonKernel::KernelFn( double x, double y )
{
	if ( x < param1 ) return 1.0f;
	if ( x > param2 ) return 1.0f;
	else return 0.0f;
}



/*===========================================================================*\
 |	Kernel functionality queries
\*===========================================================================*/

// Integer number of pixels from center to filter 0 edge.
// Must not truncate filter x dimension for 2D filters
long SkeletonKernel::GetKernelSupport(){ return 1; }

// For 2d returns y support, for 1d returns 0
long SkeletonKernel::GetKernelSupportY(){ return 0; }

// Are we 2D or Variable Size?
bool SkeletonKernel::Is2DKernel(){ return FALSE; }
bool SkeletonKernel::IsVariableSz(){ return FALSE; }

// 1-D filters ignore the y parameter, return it as 0.0
void SkeletonKernel::SetKernelSz( double x, double y ){}
void SkeletonKernel::GetKernelSz( double& x, double& y ){ x = 0.5; y = 0.0; }

// Returning true will disable the built-in normalizer
bool SkeletonKernel::IsNormalized(){ return FALSE; }

// This is for possible future optimizations
bool SkeletonKernel::HasNegativeLobes(){ return FALSE; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\PreFilter\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Prefilter Kernel
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#include "PreFilter.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonKernDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\PureModifier\PureEdit.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	PureEdit.cpp
 |			Skeleton project and code for a full modifier
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 31-3-99
 | 
\*===========================================================================*/

#include "PureModifier.h"



/*===========================================================================*\
 |	ModifyObject will do all the work in a full modifier
 |  This includes casting objects to their correct form, doing modifications
 |  changing their parameters, etc
\*===========================================================================*/

void SkeletonModifier::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
{
	// Get parameters from pblock
	float sparam = 0.0f; 
	Interval valid = FOREVER;
	pblock->GetValue(skpurem_simple_param, t, sparam, valid);

	float decay;

	// Get number of deformable points
	int modCount = os->obj->NumPoints();

	// Loop through, adding the simple parameter's value to each one
	// We support softselection - using the PointSelection call
	for(int i=0;i<modCount;i++)
	{
		Point3 original = os->obj->GetPoint(i);

		// Get softselection, if applicable
		decay = 1.0f;
		if(os->obj->GetSubselState()!=0) decay = os->obj->PointSelection(i);

		original.x += (sparam*decay);
		original.y += (sparam*decay);
		original.z += (sparam*decay);

		os->obj->SetPoint(i,original);
	}


	// Update all the caches etc
	os->obj->UpdateValidity(GEOM_CHAN_NUM,valid);
	os->obj->PointsWereChanged();
}



/*===========================================================================*\
 |	NotifyInputChanged is called each time the input object is changed in some way
 |	We can find out how it was changed by checking partID and message
\*===========================================================================*/

void SkeletonModifier::NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\PureModifier\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a full modifier
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 31-3-99
 | 
\*===========================================================================*/

#include "PureModifier.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonPureModDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\PureModifier\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PureModifier.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_LIBDESC                     4
#define IDS_SIMPLE                      5
#define IDD_SKELETON_PMOD               101
#define IDC_SIMPLE_EDIT                 1004
#define IDC_SIMPLE_SPIN                 1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\RenderEffect\RenderEffect.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	RenderEffect.cpp
 |			Skeleton project and code for a RenderEffect
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#include "RenderEffect.h"



/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonRFXClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()				{ return TRUE; }
	void *			Create( BOOL loading )	{ return new SkeletonEffect; }
	const TCHAR *	ClassName()				{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()			{ return RENDER_EFFECT_CLASS_ID; }
	Class_ID 		ClassID()				{ return RFX_CLASSID; }
	const TCHAR* 	Category()				{ return _T("");  }

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()			{ return _T("SkeletonEffect"); }
	HINSTANCE		HInstance()				{ return hInstance; }
};

static SkeletonRFXClassDesc SkeletonRFXCD;
ClassDesc* GetSkeletonRFXDesc() {return &SkeletonRFXCD;}



/*===========================================================================*\
 |	Basic implimentation of a dialog handler
\*===========================================================================*/

BOOL SkeletonEffectDlgProc::DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}

static SkeletonEffectDlgProc SkelEfDlgProc;



/*===========================================================================*\
 |	Paramblock2 Descriptor
\*===========================================================================*/

static ParamBlockDesc2 skeleton_param_blk ( skeleton_params, _T("SkeletonEffect parameters"),  0, &SkeletonRFXCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_SKELETON_EFFECT, IDS_PARAMETERS, 0, 0, &SkelEfDlgProc, 
	// params
	skeleton_simple_param,	_T("simpleParam"),	TYPE_BOOL,	P_ANIMATABLE,	IDS_SIMPLE,
		p_default,		FALSE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_SIMPLE, 
		end,
	end
	);



/*===========================================================================*\
 |	Constructor
 |  Ask the ClassDesc2 to make the AUTO_CONSTRUCT paramblocks and wire them in
\*===========================================================================*/

SkeletonEffect::SkeletonEffect()
	{
	SkeletonRFXCD.MakeAutoParamBlocks(this);
	assert(pblock);
	}


/*===========================================================================*\
 |	Standard Load
\*===========================================================================*/

IOResult SkeletonEffect::Load(ILoad *iload)
	{
	Effect::Load(iload);
	return IO_OK;
	}


/*===========================================================================*\
 |	Ask the ClassDesc2 to make the AUTO_UI SkeletonEffectDlgProc
\*===========================================================================*/

EffectParamDlg *SkeletonEffect::CreateParamDialog(IRendParams *ip)
	{	
	return SkeletonRFXCD.CreateParamDialogs(ip, this);
	}




/*===========================================================================*\
 |	Subanim & References support
\*===========================================================================*/

Animatable* SkeletonEffect::SubAnim(int i) 	{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
	}
TSTR SkeletonEffect::SubAnimName(int i) {
	switch (i) {
		case 0: return GetString(IDS_PARAMETERS);
		default: return _T("");
		}
	}

RefTargetHandle SkeletonEffect::GetReference(int i)
	{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
	}
void SkeletonEffect::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case 0: pblock = (IParamBlock2*)rtarg; break;
		}
	}
RefResult SkeletonEffect::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
	{
	switch (message) {
		case REFMSG_CHANGE:
			skeleton_param_blk.InvalidateUI();
			break;
		}
	return REF_SUCCEED;
	}


/*===========================================================================*\
 |	This method is called once per frame when the renderer begins.  
\*===========================================================================*/

void SkeletonEffect::Update(TimeValue t, Interval& valid)
	{
	}


/*===========================================================================*\
 |	Called to initialize or clear up before and after rendering  
 |	These will get called once each, not per frame
\*===========================================================================*/

int SkeletonEffect::RenderBegin(TimeValue t, ULONG flags)
	{
	return 0;
	}

int SkeletonEffect::RenderEnd(TimeValue t)
	{
	return 0;
	}


/*===========================================================================*\
 |	Apply the actual changes to the rendered bitmap at time 't'
 |	In this skeleton project, we simply darken every pixel on every other line
\*===========================================================================*/

void SkeletonEffect::Apply(TimeValue t, Bitmap *bm, RenderGlobalContext *gc,CheckAbortCallback *checkAbort) 
{
	int w = bm->Width();
	int h = bm->Height();
	Interval valid;	
	
	BOOL simple;

	// Get the simple value out of our paramblock2
	pblock->GetValue(skeleton_simple_param, t, simple, valid);

	PixelBuf l64(w);
	BMM_Color_64 *p=l64.Ptr();

	BOOL flipflop = FALSE;

	for (int y = 0; y<h; y++) {
	
		bm->GetPixels(0, y, w, p);

		for (int x=0; x<w; x++) {
			if(simple&&flipflop)
				{
				p[x].r /= 2.0;
				p[x].g /= 2.0;
				p[x].b /= 2.0;
				}
			}

		bm->PutPixels(0, y, w, p);
		flipflop=!flipflop;
		
		if (((y&3)==0)&&checkAbort&&checkAbort->Progress(y,h)) return;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\PureModifier\PureModifier.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	PureModifier.cpp
 |			Skeleton project and code for a full modifier
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 31-3-99
 | 
\*===========================================================================*/

#include "PureModifier.h"


IObjParam* SkeletonModifier::ip = NULL;


/*===========================================================================*\
 |	Class Descriptor OSM
\*===========================================================================*/

class SkeletonPModClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create( BOOL loading )		{ return new SkeletonModifier; }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return OSM_CLASS_ID; }
	Class_ID 		ClassID()					{ return PUREM_CLASSID; }
	const TCHAR* 	Category()					{ return _T("");  }

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()				{ return _T("SkeletonPureMod"); }
	HINSTANCE		HInstance()					{ return hInstance; }
};

static SkeletonPModClassDesc SkeletonPureModCD;
ClassDesc* GetSkeletonPureModDesc() {return &SkeletonPureModCD;}


/*===========================================================================*\
 |	Basic implimentation of a dialog handler
\*===========================================================================*/

BOOL SkeletonPureModDlgProc::DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}


/*===========================================================================*\
 |	Paramblock2 Descriptor
\*===========================================================================*/

static ParamBlockDesc2 skpurem_param_blk ( skpurem_params, _T("SkeletonPureModParams"),  0, &SkeletonPureModCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_SKELETON_PMOD, IDS_PARAMETERS, 0, 0, NULL, 
	// params
	skpurem_simple_param,	_T("skpurem_simple_param"),	TYPE_FLOAT,	P_ANIMATABLE,	IDS_SIMPLE,
		p_default,		0.0f,
		p_range, 		0.0f, 10.0f, 
		p_ui,			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SIMPLE_EDIT, IDC_SIMPLE_SPIN, 0.1f,
		end,
	end
	);



/*===========================================================================*\
 |	Constructor
 |  Ask the ClassDesc2 to make the AUTO_CONSTRUCT paramblocks and wire them in
\*===========================================================================*/

SkeletonModifier::SkeletonModifier()
	{
	SkeletonPureModCD.MakeAutoParamBlocks(this);
	assert(pblock);
	}



/*===========================================================================*\
 |	Invalidate our UI (or the recently changed parameter)
\*===========================================================================*/

void SkeletonModifier::InvalidateUI()
{
	skpurem_param_blk.InvalidateUI(pblock->LastNotifyParamID());
}



/*===========================================================================*\
 |	Open and Close dialog UIs
 |	We ask the ClassDesc2 to handle Beginning and Ending EditParams for us
\*===========================================================================*/

void SkeletonModifier::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
{
	this->ip = ip;

	SkeletonPureModCD.BeginEditParams(ip, this, flags, prev);

	skpurem_param_blk.SetUserDlgProc(new SkeletonPureModDlgProc(this));
}
		
void SkeletonModifier::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
{
	SkeletonPureModCD.EndEditParams(ip, this, flags, next);

	this->ip = NULL;
}



/*===========================================================================*\
 |	Standard clone
\*===========================================================================*/


RefTargetHandle SkeletonModifier::Clone(RemapDir& remap) 
{	
	SkeletonModifier* newmod = new SkeletonModifier();	
	newmod->ReplaceReference(0,pblock->Clone(remap));
	return(newmod);
}




/*===========================================================================*\
 |	Subanim & References support
\*===========================================================================*/

Animatable* SkeletonModifier::SubAnim(int i) 	{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
	}
TSTR SkeletonModifier::SubAnimName(int i) {
	switch (i) {
		case 0: return GetString(IDS_PARAMETERS);
		default: return _T("");
		}
	}

RefTargetHandle SkeletonModifier::GetReference(int i)
	{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
	}
void SkeletonModifier::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case 0: pblock = (IParamBlock2*)rtarg; break;
		}
	}
RefResult SkeletonModifier::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
	{
	switch (message) {
		case REFMSG_CHANGE:
			skpurem_param_blk.InvalidateUI();
			break;
		}
	return REF_SUCCEED;
	}




/*===========================================================================*\
 |	The validity of our parameters
 |	Start at FOREVER, and intersect with the validity of each item
\*===========================================================================*/

Interval SkeletonModifier::GetValidity(TimeValue t)
{
	float f;	
	Interval valid = FOREVER;
	pblock->GetValue(skpurem_simple_param, t, f, valid);
	return valid;
}

Interval SkeletonModifier::LocalValidity(TimeValue t)
{
	return GetValidity(t);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\PureModifier\PureModifier.h ===
/*===========================================================================*\
 | 
 |  FILE:	PureModifier.h
 |			Skeleton project and code for a full modifier
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 31-3-99
 | 
\*===========================================================================*/


#ifndef __PMODSKEL__H
#define __PMODSKEL__H

#include "max.h"
#include "iparamm2.h"
#include "istdplug.h"
#include "meshadj.h"
#include "modstack.h"
#include "macrorec.h"
#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	PUREM_CLASSID		Class_ID(0x566e006d, 0x6cdc6974)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonPureModDesc();


// Paramblock2 name
enum { skpurem_params, }; 
// Paramblock2 parameter list
enum { skpurem_simple_param, };



/*===========================================================================*\
 |	SkeletonModifier class defn
\*===========================================================================*/

class SkeletonModifier : public Modifier{
	public:

		// Access to the interface
		static IObjParam *ip;

		// Global parameter block
		IParamBlock2	*pblock;



		//Constructor/Destructor
		SkeletonModifier();
		~SkeletonModifier() {}
		void DeleteThis() { delete this; }


		// Plugin identification
		void GetClassName(TSTR& s) { s= TSTR(GetString(IDS_CLASSNAME)); }  
		virtual Class_ID ClassID() { return PUREM_CLASSID;}		
		TCHAR *GetObjectName() { return GetString(IDS_CLASSNAME); }


		// Defines the behavior for this modifier
		// This is currently setup to be basic geometry 
		// modification of deformable objects
		ChannelMask ChannelsUsed()  { return PART_GEOM|PART_TOPO; }
		ChannelMask ChannelsChanged() { return PART_GEOM; }
		Class_ID InputType() { return defObjectClassID; }
		BOOL ChangeTopology() {return FALSE;}


		// Calculate the local validity from the parameters
		Interval LocalValidity(TimeValue t);
		Interval GetValidity(TimeValue t);


		// Object modification and notification of change
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		void NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc);


		// Reference support
		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		
		// SubAnim support
		int NumSubs() { return 1; }
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);


		// Direct paramblock access
		int	NumParamBlocks() { return 1; }	
		IParamBlock2* GetParamBlock(int i) { return pblock; }
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; }
		int GetParamBlockIndex(int id) {return id;}

		// Does not use createmouse callbacks
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}

		// Load and unload our UI
		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);
		void InvalidateUI();
};


/*===========================================================================*\
 |	Dialog Processor
\*===========================================================================*/

class SkeletonPureModDlgProc : public ParamMap2UserDlgProc 
{
	public:
		SkeletonModifier *spm;

		SkeletonPureModDlgProc() {}
		SkeletonPureModDlgProc(SkeletonModifier *spm_in) { spm = spm_in; }

		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { }

		void SetThing(ReferenceTarget *m) {
			spm = (SkeletonModifier*)m;
			}

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\RenderEffect\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a RenderEffect
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#include "RenderEffect.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonRFXDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\RenderEffect\RenderEffect.h ===
/*===========================================================================*\
 | 
 |  FILE:	RenderEffect.h
 |			Skeleton project and code for a RenderEffect
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#ifndef __RFXSKEL__H
#define __RFXSKEL__H

#include "max.h"
#include <bmmlib.h>
#include "iparamm2.h"
#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	RFX_CLASSID		Class_ID(0x213e3901, 0x385fc0)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonRFXDesc();


// Paramblock2 name
enum { skeleton_params, }; 
// Paramblock2 parameter list
enum { skeleton_simple_param, };



/*===========================================================================*\
 |	SkeletonEffect class defn
\*===========================================================================*/

class SkeletonEffect: public Effect 
{
	public:
		// Parameters
		IParamBlock2 *pblock;
		
		SkeletonEffect();
		~SkeletonEffect() { 	}
		void DeleteThis() { delete this; }

		// Animatable/Reference
		int NumSubs() {return 1;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);

		// References
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rTarget);

		// Direct paramblock access
		int	NumParamBlocks() { return 1; }	
		IParamBlock2* GetParamBlock(int i) { return pblock; }
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; }

		// ClassID/ClassName identifiers
		Class_ID ClassID() { return RFX_CLASSID; }
		void GetClassName(TSTR& s) { s=GetString(IDS_CLASSNAME); }

		// References have changed
		RefResult NotifyRefChanged(
					Interval changeInt, 
					RefTargetHandle hTarget, 
					PartID& partID,  
					RefMessage message	);

		// Standard load
		IOResult Load(ILoad *iload);

		// Effect class methods
		TSTR GetName() { return GetString(IDS_CLASSNAME); }
		EffectParamDlg *CreateParamDialog( IRendParams *pParams );
		int RenderBegin( TimeValue t, ULONG flags );
		int RenderEnd( TimeValue t );
		void Update( TimeValue t, Interval& valid );
		void Apply( TimeValue t, Bitmap *pBM, RenderGlobalContext *pGC, CheckAbortCallback *checkAbort);
};



/*===========================================================================*\
 |	Dialog Processor
\*===========================================================================*/

class SkeletonEffectDlgProc : public ParamMap2UserDlgProc 
{
	public:
		IParamMap *pmap;

		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { }
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\RenderEffect\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RenderEffect.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_SIMPLE                      3
#define IDS_LIBDESC                     4
#define IDD_SAMPLE_EFFECT               107
#define IDD_SKELETON_EFFECT             107
#define IDC_SAMP_COLOR                  1713
#define IDC_SLOW                        1722
#define IDC_SIMPLE                      1722
#define IDC_STRENGTH                    1723
#define IDC_STRENGTH_SPIN               1724

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Sampler\MtlSampler.h ===
/*===========================================================================*\
 | 
 |  FILE:	MtlSampler.h
 |			Skeleton project and code for a Material Sampler
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#ifndef __SAMPSKEL__H
#define __SAMPSKEL__H

#include "max.h"
#include "texutil.h"
#include "samplers.h"

#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	SAMP_CLASSID		Class_ID(0x5a081789, 0x358b0a20)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonSamplerDesc();



/*===========================================================================*\
 |	Parameter Block defines
\*===========================================================================*/

#define	PB_QUALITY			0
#define	PB_ENABLE			1
#define	PB_ADAPT_ENABLE		2
#define	PB_ADAPT_THRESHOLD	3

#define SKSPBLOCK_LENGTH	4
#define SKSCURRENT_VERSION	1



/*===========================================================================*\
 |	SkeletonSampler class defn
\*===========================================================================*/

class SkeletonSampler: public Sampler {

	// Temporary shadecontext pointer, used during DoSamples
	ShadeContext* pSC;

	public:
		IParamBlock *pblock;

		// fragment mask storage
		MASK	tmask;

		SkeletonSampler();
		void DeleteThis() { delete this; };
		TCHAR* GetDefaultComment();

		RefTargetHandle Clone( RemapDir &remap );


		// Animatable/Reference
		int NumSubs() {return 1;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);

		int NumRefs() { return 1;};
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
							         PartID& partID,  RefMessage message);


		// ClassID and Name
		Class_ID ClassID() {return SAMP_CLASSID;};
		TSTR GetName() { return GetString( IDS_CLASSNAME ); }
		void GetClassName(TSTR& s) { s = GetName(); }


		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);


		// This samples a sequence for the area
		void DoSamples( Color& cOut, Color&tOut, SamplingCallback* cb, ShadeContext* sc, MASK mask=NULL );
		// This is the function that is called to get the next sample 
		// returns FALSE when out of samples
		BOOL NextSample( Point2* pOutPt, float* pSampleSz, int n );
		// Integer number of samples for current quality setting
		int GetNSamples();	


		// Get/Set quality and enable status
		int SupportsQualityLevels();
		void SetQuality( float q );
		float GetQuality();

		void SetEnable( BOOL on );
		BOOL GetEnable();

		// Return that we support adaptive
		ULONG SupportsStdParams(){ return R3_ADAPTIVE; }

		void SetAdaptiveOn( BOOL on );
		BOOL IsAdaptiveOn();

		void SetAdaptiveThreshold( float val );
		float GetAdaptiveThreshold();
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Sampler\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Material Sampler
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#include "MtlSampler.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonSamplerDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SceneExport\ConfigMgr.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	ConfigMgr.cpp
 |			Skeleton project and code for a Scene Exporter 
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 26-3-99
 | 
\*===========================================================================*/

#include "SceneExport.h"


// change the name when using this skeleton
#define		CFG_FILENAME		"skeleton_export.cfg"
#define		CFG_VERSION			0x001


/*===========================================================================*\
 |  Get the config file's full name on the disk
\*===========================================================================*/

TSTR SkeletonExporter::GetConfigFilename()
{
	TSTR filename;
	
	filename += ip->GetDir(APP_PLUGCFG_DIR);
	filename += "\\";
	filename += CFG_FILENAME;

	return filename;
}

/*===========================================================================*\
 |  Load and save the values
\*===========================================================================*/

void SkeletonExporter::SaveExporterConfig()
{
	// Open the configuration file for writing
	TSTR filename = GetConfigFilename();
	FILE* cfgStream;

	cfgStream = fopen(filename, "wb");
	if (!cfgStream)
		return;

	// Write CFG version
	_putw(CFG_VERSION,				cfgStream);

	fputc(simpleParam,				cfgStream);

	fclose(cfgStream);
}


BOOL SkeletonExporter::LoadExporterConfig()
{
	// Open the configuration file for reading
	TSTR filename = GetConfigFilename();

	// If the file doesn't exist yet, write out the defaults
	if(!DoesFileExist(filename)) SaveExporterConfig();


	FILE* cfgStream;

	cfgStream = fopen(filename, "rb");
	if (!cfgStream)
		return FALSE;

	// First item is a file version
	int fileVersion = _getw(cfgStream);

	if (fileVersion > CFG_VERSION) {
		// Unknown version
		fclose(cfgStream);
		return FALSE;
	}

	simpleParam = fgetc(cfgStream);

	fclose(cfgStream);

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Sampler\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Sampler.rc
//
#define IDS_CLASSNAME                   1
#define IDS_QUALITY                     2
#define IDS_ENABLE                      3
#define IDS_AD_ENABLE                   4
#define IDS_AD_THRESH                   5
#define IDS_COMMENT                     6
#define IDS_LIBDESC                     7
#define IDS_PARAMETERS                  8

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Sampler\MtlSampler.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	MtlSampler.cpp
 |			Skeleton project and code for a Material Sampler
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#include "MtlSampler.h"



/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonSamplerClassDesc : public ClassDesc {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create(BOOL loading)		{ return new SkeletonSampler; }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return SAMPLER_CLASS_ID; }
	Class_ID 		ClassID()					{ return SAMP_CLASSID; }
	const TCHAR* 	Category()					{ return _T("");  }
};

static SkeletonSamplerClassDesc SkelSamplerCD;
ClassDesc* GetSkeletonSamplerDesc() { return &SkelSamplerCD; }



/*===========================================================================*\
 |	Parameter Block
\*===========================================================================*/

static ParamBlockDescID sksDesc[ SKSPBLOCK_LENGTH ] = {
	{ TYPE_FLOAT, NULL, FALSE, PB_QUALITY },			// Quality
	{ TYPE_BOOL,  NULL, FALSE, PB_ENABLE },				// Enable
	{ TYPE_BOOL,  NULL, FALSE, PB_ADAPT_ENABLE },		// AdaptiveEnable
	{ TYPE_FLOAT, NULL, FALSE, PB_ADAPT_THRESHOLD },	// Threshold
}; 	



/*===========================================================================*\
 |	Sampler Implimentation
\*===========================================================================*/


SkeletonSampler::SkeletonSampler()
{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(sksDesc, SKSPBLOCK_LENGTH, SKSCURRENT_VERSION));
	assert(pblock);
	pblock->SetValue(PB_ENABLE,				0,	FALSE );	
	pblock->SetValue(PB_ADAPT_ENABLE,		0,	TRUE );	
	pblock->SetValue(PB_QUALITY,			0,	0.5f );	
	pblock->SetValue(PB_ADAPT_THRESHOLD,	0,	0.020f );	
}


RefTargetHandle SkeletonSampler::Clone( RemapDir &remap )
{
	SkeletonSampler* sksNew = new SkeletonSampler();
	sksNew->ReplaceReference(0,remap.CloneRef(pblock));
	return (RefTargetHandle)sksNew;
}


IOResult SkeletonSampler::Load(ILoad *iload)
{
	Sampler::Load(iload);
	return IO_OK;
}


IOResult SkeletonSampler::Save(ISave *isave)
{
	Sampler::Save(isave);
	return IO_OK;
}

TCHAR* SkeletonSampler::GetDefaultComment()
{
	return GetString(IDS_COMMENT);
}



/*===========================================================================*\
 |	Subanim & References support
\*===========================================================================*/


Animatable* SkeletonSampler::SubAnim(int i)
{ 
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
}

TSTR SkeletonSampler::SubAnimName(int i)
{ 
	switch (i) {
		case 0: return GetString(IDS_PARAMETERS);
		default: return _T("");
		}
}

RefTargetHandle SkeletonSampler::GetReference(int i)
{ 
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
}

void SkeletonSampler::SetReference(int i, RefTargetHandle rtarg)
{ 
	switch (i) {
		case 0: pblock = (IParamBlock*)rtarg; break;
		}
}

RefResult SkeletonSampler::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	GetParamName * gpn;

	switch (message) {

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim * gpd = (GetParamDim*)partID;
				gpd->dim = defaultDim; break;
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_QUALITY:			gpn->name = _T( GetString(IDS_QUALITY) );	break;
				case PB_ENABLE:				gpn->name = _T( GetString(IDS_ENABLE) );	break;
				case PB_ADAPT_ENABLE:		gpn->name = _T( GetString(IDS_AD_ENABLE) ); break;
				case PB_ADAPT_THRESHOLD:	gpn->name = _T( GetString(IDS_AD_THRESH) ); break;
				default:		  gpn->name = _T(""); break;
			}
			return REF_STOP; 
		}
	}
	return REF_SUCCEED;
}



/*===========================================================================*\
 |	Mask management functions (from ShaderUtil.cpp)
\*===========================================================================*/

inline float bound( float v, float min=0.0f, float max=1.0f )
{ 
	return (v < min)? min : (v > max)? max : v; 
}

inline int bound( int v, int min=0, int max=1 )
{
	return (v < min)? min : (v > max)? max : v; 
}

inline void setMask( MASK m, ULONG v ) { m[0] = m[1] = v; }
inline void copyMask( MASK to, MASK from ) { to[0] = from[0]; to[1]=from[1];}

#define ALL_ONES	0xffffffffL

BOOL sampleInMask( Point2& sample,  MASK m )
{
	int x = int( sample.x * 8.0f );
	x = bound( x, 0, 7 );
	int y = int( sample.y * 8.0f );
	y = bound( y, 0, 7 );
	BYTE * pMask = (BYTE*)m;
	BYTE b = pMask[ y ];

	BYTE in = b & (0x80 >> x) ;
	return in > 0;
}


/*===========================================================================*\
 |  Perform the actual sampling of a point on the surface
 |
 |	We ask NextSample(...) to provide us with a point to use, check whether its
 |	within the current mask and if so, then sample the colour.
 |	
\*===========================================================================*/

#define N_SAMPLES	1

void SkeletonSampler::DoSamples( Color& cOut, Color &tOut, 
			 SamplingCallback* cb, ShadeContext* sc, MASK mask )
{
	int n = 0;
	pSC = sc;

	if ( mask ) 
		copyMask( tmask, mask );
	else
		setMask( tmask, ALL_ONES );

	float sampleScale;
	Point2	sample;
	NextSample( &sample, &sampleScale, n );

	cOut.r = cOut.g = cOut.b = tOut.r = tOut.g = tOut.b = 0;

	if ( sampleInMask( sample, tmask ) )
		cb->SampleAtOffset( cOut, tOut, sample, sampleScale );
}

/*===========================================================================*\
 |  Find next sample point
 |	We just choose the centre of the fragment
\*===========================================================================*/

BOOL SkeletonSampler::NextSample( Point2* pOut, float* pSampleSz, int n )
{
	*pOut = pSC->SurfacePtScreen(); 
	pOut->x = frac( pOut->x ); pOut->y = frac( pOut->y );

	// Sample size is the whole pixel
	*pSampleSz = 1.0f;

	++n;

	return TRUE;
}

// Number of samples
int SkeletonSampler::GetNSamples()
{
	return 1;
}




/*===========================================================================*\
 |	Quality and Enabling support
\*===========================================================================*/

void SkeletonSampler::SetQuality( float q )
{ 
	pblock->SetValue( PB_QUALITY, 0, q );
}

float SkeletonSampler::GetQuality()
{ 
	float q; Interval valid;
	pblock->GetValue( PB_QUALITY, 0, q, valid );
	return q;
}

int SkeletonSampler::SupportsQualityLevels() 
{
	return 1; 
}


void SkeletonSampler::SetEnable( BOOL on )
{ 
	pblock->SetValue( PB_ENABLE, 0, on );
}
BOOL SkeletonSampler::GetEnable()
{ 
	BOOL b; Interval valid;
	pblock->GetValue( PB_ENABLE, 0, b, valid );
	return b;
}



/*===========================================================================*\
 |	Adaptive Sampling support
\*===========================================================================*/


void SkeletonSampler::SetAdaptiveOn( BOOL on )
{ 
	pblock->SetValue( PB_ADAPT_ENABLE, 0, on ); 
}

BOOL SkeletonSampler::IsAdaptiveOn()
{ 
	BOOL b; Interval valid;
	pblock->GetValue( PB_ADAPT_ENABLE, 0, b, valid );
	return b;
}

void SkeletonSampler::SetAdaptiveThreshold( float val )
{ 
	pblock->SetValue( PB_ADAPT_THRESHOLD, 0, val ); 
}

float SkeletonSampler::GetAdaptiveThreshold() 
{ 
	float q; Interval valid;
	pblock->GetValue( PB_ADAPT_THRESHOLD, 0, q, valid );
	return q;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SceneExport\DoExport.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	DoExport.cpp
 |			Skeleton project and code for a Scene Exporter 
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 26-3-99
 | 
\*===========================================================================*/

#include "SceneExport.h"


/*===========================================================================*\
 |  Determine what options we support
\*===========================================================================*/

BOOL SkeletonExporter::SupportsOptions(int ext, DWORD options)
{
	switch(ext) {
		case 0:
			if(options & SCENE_EXPORT_SELECTED) return TRUE;
			else return FALSE;
			break;
		}
	return FALSE;
}



/*===========================================================================*\
 |  Preferences dialog handler
\*===========================================================================*/

static BOOL CALLBACK PrefsDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	SkeletonExporter *se = (SkeletonExporter*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!se && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG:	
			// Update class pointer
			se = (SkeletonExporter*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);

			// Setup preferences initial state
			SetCheckBox(hWnd,IDC_SIMPLE,se->simpleParam);
			break;

		case WM_DESTROY:
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CANCEL:
					EndDialog(hWnd,1);
					break;

				case IDC_OK:
					// Retrieve preferences
					se->simpleParam = GetCheckBox(hWnd,IDC_SIMPLE);

					EndDialog(hWnd,0);
				break;
			}
			break;

		default:
			return FALSE;
		}	
	return TRUE;
} 



/*===========================================================================*\
 |  For every node we get, just print out its name and object ref's classID
\*===========================================================================*/

BOOL SkeletonExporter::nodeEnum(INode* node,Interface *ip) 
{
	if(exportSelected && node->Selected() == FALSE)
		return TREE_CONTINUE;

	// Check for user cancel
	if (ip->GetCancel())
		return FALSE;


	if(!exportSelected || node->Selected()) 
	{
		Class_ID cid = node->GetObjectRef()->ClassID();
		fprintf(fileStream, "%s : Class_ID(%X,%X)\n",node->GetName(),cid.PartA(),cid.PartB());
	}


	// Recurse through this node's children, if any
	for (int c = 0; c < node->NumberOfChildren(); c++) {
		if (!nodeEnum(node->GetChildNode(c), ip))
			return FALSE;
	}


	return TRUE;
}



/*===========================================================================*\
 |  Do the export to the file
\*===========================================================================*/

int	SkeletonExporter::DoExport(const TCHAR *name,ExpInterface *ei,Interface *i, BOOL suppressPrompts, DWORD options)
{
	// Set local interface pointer
	ip = i;

	// load the configuration from disk
	// so that it can be used in our dialog box
	if(!LoadExporterConfig()) return 0;

	if(!suppressPrompts)
	{

		// Show preferences setup dialog
		int res = DialogBoxParam(
			hInstance,
			MAKEINTRESOURCE(IDD_SKELETON_SCEXP),
			i->GetMAXHWnd(),
			PrefsDlgProc,
			(LPARAM)this);

		// User clicked 'Cancel'
		if(res!=0) return 0;

	}

	exportSelected = (options & SCENE_EXPORT_SELECTED) ? TRUE : FALSE;


	// Open a filestream for writing out to
	fileStream = _tfopen(name,_T("wt"));
	if (!fileStream) {
		return 0;
	}


	// Print out a title for the file header
	fprintf(fileStream, "Skeleton File Format\nFrom 3D Studio MAX R3 Skeleton SDK Samples\n\n");

	// Print out the state of the simple parameter
	fprintf(fileStream, "Simple Parameter State: %s\n\n", simpleParam?"TRUE":"FALSE");


	// Simple root node -> children enumeration
	// This will get the root node, and then cycle through its children (ie, the basic scene nodes)
	// It will then recurse to search their children, and then their children, etc
	int numChildren = i->GetRootNode()->NumberOfChildren();

	for (int idx=0; idx<numChildren; idx++) {
		if (i->GetCancel())
			break;
		nodeEnum(i->GetRootNode()->GetChildNode(idx), i);
	}

	fclose(fileStream);


	// Save the current configuration back out to disk
	// for use next time the exporter is run
	SaveExporterConfig();


	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SceneExport\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Scene Exporter 
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 26-3-99
 | 
\*===========================================================================*/

#include "SceneExport.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonSceneExportDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SceneExport\SceneExport.h ===
/*===========================================================================*\
 | 
 |  FILE:	SceneExport.h
 |			Skeleton project and code for a Scene Exporter 
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 26-3-99
 | 
\*===========================================================================*/

#ifndef __SCEXPSKEL__H
#define __SCEXPSKEL__H

#include "max.h"
#include "resource.h"
#include "iparamm2.h"

// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	SCEXP_CLASSID		Class_ID(0x1e211639, 0x1eac4cd1)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonSceneExportDesc();

/*===========================================================================*\
 |	SkeletonExporter class defn
\*===========================================================================*/

class SkeletonExporter : public SceneExport {
public:
	SkeletonExporter();
	~SkeletonExporter();

	// Preferences values
	BOOL simpleParam;

	// Used in DoExport
	BOOL exportSelected;
	FILE *fileStream;
	Interface* ip;



	// Number of extensions we support
	int ExtCount();
	const TCHAR * Ext(int n);

	// The bookkeeping functions
	const TCHAR * LongDesc();
	const TCHAR * ShortDesc();
	const TCHAR * AuthorName();
	const TCHAR * CopyrightMessage();
	const TCHAR * OtherMessage1();
	const TCHAR * OtherMessage2();

	// Version number of this exporter
	unsigned int Version();

	// Show an about box
	void ShowAbout(HWND hWnd);

	// Do the actual export
	int DoExport(const TCHAR *name,ExpInterface *ei,Interface *i, BOOL suppressPrompts=FALSE, DWORD options=0);

	// Returns whether we support the extended exporter options
	BOOL SupportsOptions(int ext, DWORD options);

	// Scene enumeration
	BOOL nodeEnum(INode* node,Interface *ip);


	// Configuration file management
	BOOL LoadExporterConfig();
	void SaveExporterConfig();
	TSTR GetConfigFilename();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SceneExport\SceneExport.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	SceneExport.cpp
 |			Skeleton project and code for a Scene Exporter 
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 26-3-99
 | 
\*===========================================================================*/

#include "SceneExport.h"




/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonExportClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()				{ return TRUE; }
	void *			Create( BOOL loading )	{ return new SkeletonExporter; }
	const TCHAR *	ClassName()				{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()			{ return SCENE_EXPORT_CLASS_ID; }
	Class_ID 		ClassID()				{ return SCEXP_CLASSID; }
	const TCHAR* 	Category()				{ return _T("");  }

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()			{ return _T("SkeletonExporter"); }
	HINSTANCE		HInstance()				{ return hInstance; }
};

static SkeletonExportClassDesc SkeletonExportCD;
ClassDesc* GetSkeletonSceneExportDesc() {return &SkeletonExportCD;}



/*===========================================================================*\
 |	Basic implimentation of a dialog handler
\*===========================================================================*/

static BOOL CALLBACK CustomDialogHandler(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}



/*===========================================================================*\
 |  Constructor/Destructor - just initialize any variables or memory
\*===========================================================================*/

SkeletonExporter::SkeletonExporter()
{
	simpleParam = 1;
}

SkeletonExporter::~SkeletonExporter()
{
}

/*===========================================================================*\
 |  Return how many extensions we support, and what they are
\*===========================================================================*/

int SkeletonExporter::ExtCount() { return 1; }

const TCHAR * SkeletonExporter::Ext(int n)
{
	switch(n) {
		case 0:
			return GetString(IDS_EXT_01);
		}
	return _T("");

}


/*===========================================================================*\
 |  Return various information about our scene exporter
\*===========================================================================*/

const TCHAR * SkeletonExporter::LongDesc()
{
	return GetString(IDS_LONGDESC);
}

const TCHAR * SkeletonExporter::ShortDesc()
{
	return GetString(IDS_SHORTDESC);
}

const TCHAR * SkeletonExporter::AuthorName()
{
	return GetString(IDS_AUTHOR);
}

const TCHAR * SkeletonExporter::CopyrightMessage()
{
	return GetString(IDS_COPYRIGHT);
}

const TCHAR * SkeletonExporter::OtherMessage1() { return _T(""); }
const TCHAR * SkeletonExporter::OtherMessage2() { return _T(""); }

// Version number = (version * 100)
unsigned int SkeletonExporter::Version()
{
	return 100;
}



/*===========================================================================*\
 |  Show about box
\*===========================================================================*/

static BOOL CALLBACK AboutDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	SkeletonExporter *se = (SkeletonExporter*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!se && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG:	
			// Update class pointer
			se = (SkeletonExporter*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_DESTROY:
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_OK:
					EndDialog(hWnd,1);
				break;
			}
			break;

		default:
			return FALSE;
		}	
	return TRUE;
	}

void SkeletonExporter::ShowAbout(HWND hWnd)
{
	DialogBoxParam(
		hInstance,
		MAKEINTRESOURCE(IDD_ABOUT),
		hWnd,
		AboutDlgProc,
		(LPARAM)this);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SceneImport\ConfigMgr.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	ConfigMgr.cpp
 |			Skeleton project and code for a Scene Importer 
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 29-3-99
 | 
\*===========================================================================*/

#include "SceneImport.h"


// change the name when using this skeleton
#define		CFG_FILENAME		"skeleton_import.cfg"
#define		CFG_VERSION			0x001


/*===========================================================================*\
 |  Get the config file's full name on the disk
\*===========================================================================*/

TSTR SkeletonImporter::GetConfigFilename()
{
	TSTR filename;
	
	filename += ip->GetDir(APP_PLUGCFG_DIR);
	filename += "\\";
	filename += CFG_FILENAME;

	return filename;
}

/*===========================================================================*\
 |  Load and save the values
\*===========================================================================*/

void SkeletonImporter::SaveImporterConfig()
{
	// Open the configuration file for writing
	TSTR filename = GetConfigFilename();
	FILE* cfgStream;

	cfgStream = fopen(filename, "wb");
	if (!cfgStream)
		return;

	// Write CFG version
	_putw(CFG_VERSION,				cfgStream);

	fputc(simpleParam,				cfgStream);

	fclose(cfgStream);
}


BOOL SkeletonImporter::LoadImporterConfig()
{
	// Open the configuration file for reading
	TSTR filename = GetConfigFilename();

	// If the file doesn't exist yet, write out the defaults
	if(!DoesFileExist(filename)) SaveImporterConfig();


	FILE* cfgStream;

	cfgStream = fopen(filename, "rb");
	if (!cfgStream)
		return FALSE;

	// First item is a file version
	int fileVersion = _getw(cfgStream);

	if (fileVersion > CFG_VERSION) {
		// Unknown version
		fclose(cfgStream);
		return FALSE;
	}

	simpleParam = fgetc(cfgStream);

	fclose(cfgStream);

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SceneExport\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SceneExport.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_SIMPLE                      3
#define IDS_LIBDESC                     4
#define IDS_EXT_01                      5
#define IDS_SHORTDESC                   6
#define IDS_LONGDESC                    7
#define IDS_AUTHOR                      8
#define IDS_COPYRIGHT                   9
#define IDD_SKELETON_SCEXP              101
#define IDD_ABOUT                       102
#define IDC_SIMPLE                      1000
#define IDC_OK                          1001
#define IDC_CANCEL                      1002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SceneImport\DoImport.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	DoImport.cpp
 |			Skeleton project and code for a Scene Importer 
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 29-3-99
 | 
\*===========================================================================*/

#include "SceneImport.h"



/*===========================================================================*\
 |  Preferences dialog handler
\*===========================================================================*/

static BOOL CALLBACK PrefsDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	SkeletonImporter *si = (SkeletonImporter*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!si && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG:	
			// Update class pointer
			si = (SkeletonImporter*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);

			// Setup preferences initial state
			SetCheckBox(hWnd,IDC_SIMPLE,si->simpleParam);
			break;

		case WM_DESTROY:
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CANCEL:
					EndDialog(hWnd,1);
					break;

				case IDC_OK:
					// Retrieve preferences
					si->simpleParam = GetCheckBox(hWnd,IDC_SIMPLE);

					EndDialog(hWnd,0);
				break;
			}
			break;

		default:
			return FALSE;
		}	
	return TRUE;
} 



/*===========================================================================*\
 |  Mini file viewer
\*===========================================================================*/

static DWORD CALLBACK
stream_callback(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)
{
	if (ReadFile((HANDLE)dwCookie, pbBuff, (DWORD)cb, (DWORD*)pcb, NULL))
		return 0;
	else
		return GetLastError();
}
static DWORD CALLBACK
stream_out_callback(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG* pcb)
{
	if (WriteFile((HANDLE)dwCookie, pbBuff, cb, (DWORD*)pcb, NULL ))
		return 0;
	else
		return GetLastError();
}

static BOOL CALLBACK ViewerDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	SkeletonImporter *si = (SkeletonImporter*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!si && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG:	
			// Update class pointer
			si = (SkeletonImporter*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);

			// Open the imported file and read it into our richedit control
			HANDLE	   file;
			EDITSTREAM es;
			if ((file = CreateFile(si->filenameTemp, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE)
			{
				es.dwCookie = (DWORD)file;
				es.pfnCallback = stream_callback;
				es.dwError = 0;
 				int foo = SendMessage(GetDlgItem(hWnd,IDC_FILEVIEW), EM_STREAMIN, (WPARAM)SF_TEXT, (LPARAM)&es);
				CloseHandle(file);
			}	

			// Simple parameter state - put it to the window title
			char tmp[MAX_PATH];
			sprintf(tmp, "Importer's Simple Parameter State: %s", si->simpleParam?"TRUE":"FALSE");
			SetWindowText(hWnd,tmp);

			break;


		// resize the richedit control to fit the dialog
		case WM_SIZE:			
			MoveWindow(GetDlgItem(hWnd,IDC_FILEVIEW),0,0,LOWORD(lParam),HIWORD(lParam),TRUE);
			break;

		case WM_DESTROY:
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
				case IDCANCEL:
					EndDialog(hWnd,1);
					break;
			}
			break;

		default:
			return FALSE;
		}	
	return TRUE;
} 


/*===========================================================================*\
 |  Read in information from a file
 |  We will use a simple viewing dialog to see the text in the file
\*===========================================================================*/

int	SkeletonImporter::DoImport(const TCHAR *name, ImpInterface *ii,Interface *i, BOOL suppressPrompts)
{
	// Set local interface pointer
	ip = i;

	// load the configuration from disk
	// so that it can be used in our dialog box
	if(!LoadImporterConfig()) return 0;

	if(!suppressPrompts)
	{

		// Show preferences setup dialog
		int res = DialogBoxParam(
			hInstance,
			MAKEINTRESOURCE(IDD_SKELETON_SCIMP),
			i->GetMAXHWnd(),
			PrefsDlgProc,
			(LPARAM)this);

		// User clicked 'Cancel'
		if(res!=0) return 0;

	}


	// put the filename we're given into storage, and open the viewer dialog
	// the viewer will do all the reading of the file itself
	filenameTemp = name;

	DialogBoxParam(
		hInstance,
		MAKEINTRESOURCE(IDD_VIEW),
		i->GetMAXHWnd(),
		ViewerDlgProc,
		(LPARAM)this);


	// Save the current configuration back out to disk
	// for use next time the importer is run
	SaveImporterConfig();


	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SceneImport\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Scene Importer 
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 29-3-99
 | 
\*===========================================================================*/

#include "SceneImport.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonSceneImportDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Shader\Eval.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Eval.cpp
 |			Skeleton project and code for a Material Shader
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 26-1-99
 | 
\*===========================================================================*/


#include "Shader.h"



/*===========================================================================*\
 |	Actually shade the surface
\*===========================================================================*/

void SkeletonShader::GetIllumParams( ShadeContext &sc, IllumParams &ip )
{
	ip.stdParams = SupportStdParams();
	ip.channels[S_DI] = diffuse;
	ip.channels[S_BR].r = brightness;
}

void SkeletonShader::Illum(ShadeContext &sc, IllumParams &ip)
{
	LightDesc *l;
	Color lightCol;

	// Get our parameters our of the channels
	Color Cd		= ip.channels[ S_DI ];
	float bright	= ip.channels[ S_BR ].r;

	// Very similar to Blinn/Phong method here - just using 
	//	our brightness parameter to tie a couple of parameters together

	BOOL is_shiny	= (bright > 0.0f) ? 1:0; 
	double phExp	= pow(2.0, bright * 10.0) * 4.0; 

	for (int i=0; i<sc.nLights; i++) {
		l = sc.Light(i);
		register float NL, diffCoef;
		Point3 L;
		if (l->Illuminate(sc,ip.N,lightCol,L,NL,diffCoef)) {
			if (l->ambientOnly) {
				ip.ambIllumOut += lightCol;
				continue;
				}
			if (NL<=0.0f) 
				continue;

			if (l->affectDiffuse)
				ip.diffIllumOut += diffCoef * lightCol;

			if (is_shiny&&l->affectSpecular) {
				Point3 H = Normalize(L-ip.V);
				float c = DotProd(ip.N,H);	 
				if (c>0.0f) {
					c = (float)pow((double)c, phExp); 
					ip.specIllumOut += c * bright * lightCol;
					}
				}
 			}
		}



	// now we can multiply by the clrs
	ip.ambIllumOut *= Cd * 0.5f; 
	ip.diffIllumOut *= Cd;
}


void SkeletonShader::AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol) 
{ 
}

// Called to combine the various color and shading components
void SkeletonShader::CombineComponents( ShadeContext &sc, IllumParams& ip )
{ 
	ip.finalC = ip.finalOpac * (ip.ambIllumOut + ip.diffIllumOut  + ip.selfIllumOut)
			+ ip.specIllumOut + ip.reflIllumOut + ip.transIllumOut; 
}

// Display our hilite curve in the UI, at point 'x'
float SkeletonShader::EvalHiliteCurve(float x) 
{
	double phExp	= pow(2.0, brightness * 10.0) * 4.0; 
	return 1.0f*(float)pow((double)cos(x*PI), phExp );  
}


BOOL SkeletonShader::IsMetal() 
{ 
	return FALSE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SceneImport\SceneImport.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	SceneImport.cpp
 |			Skeleton project and code for a Scene Importer 
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 29-3-99
 | 
\*===========================================================================*/

#include "SceneImport.h"



/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonImportClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()				{ return TRUE; }
	void *			Create( BOOL loading )	{ return new SkeletonImporter; }
	const TCHAR *	ClassName()				{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()			{ return SCENE_IMPORT_CLASS_ID; }
	Class_ID 		ClassID()				{ return SCIMP_CLASSID; }
	const TCHAR* 	Category()				{ return _T("");  }

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()			{ return _T("SkeletonImporter"); }
	HINSTANCE		HInstance()				{ return hInstance; }
};

static SkeletonImportClassDesc SkeletonImportCD;
ClassDesc* GetSkeletonSceneImportDesc() {return &SkeletonImportCD;}



/*===========================================================================*\
 |	Basic implimentation of a dialog handler
\*===========================================================================*/

static BOOL CALLBACK CustomDialogHandler(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}



/*===========================================================================*\
 |  Constructor/Destructor - just initialize any variables or memory
\*===========================================================================*/

SkeletonImporter::SkeletonImporter()
{
	simpleParam = 1;
}

SkeletonImporter::~SkeletonImporter()
{
}

/*===========================================================================*\
 |  Return how many extensions we support, and what they are
\*===========================================================================*/

int SkeletonImporter::ExtCount() { return 1; }

const TCHAR * SkeletonImporter::Ext(int n)
{
	switch(n) {
		case 0:
			return GetString(IDS_EXT_01);
		}
	return _T("");

}


/*===========================================================================*\
 |  Return various information about our scene importer
\*===========================================================================*/

const TCHAR * SkeletonImporter::LongDesc()
{
	return GetString(IDS_LONGDESC);
}

const TCHAR * SkeletonImporter::ShortDesc()
{
	return GetString(IDS_SHORTDESC);
}

const TCHAR * SkeletonImporter::AuthorName()
{
	return GetString(IDS_AUTHOR);
}

const TCHAR * SkeletonImporter::CopyrightMessage()
{
	return GetString(IDS_COPYRIGHT);
}

const TCHAR * SkeletonImporter::OtherMessage1() { return _T(""); }
const TCHAR * SkeletonImporter::OtherMessage2() { return _T(""); }

// Version number = (version * 100)
unsigned int SkeletonImporter::Version()
{
	return 100;
}



/*===========================================================================*\
 |  Show about box
\*===========================================================================*/

static BOOL CALLBACK AboutDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	SkeletonImporter *si = (SkeletonImporter*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!si && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG:	
			// Update class pointer
			si = (SkeletonImporter*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_DESTROY:
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_OK:
					EndDialog(hWnd,1);
				break;
			}
			break;

		default:
			return FALSE;
		}	
	return TRUE;
	}

void SkeletonImporter::ShowAbout(HWND hWnd)
{
	DialogBoxParam(
		hInstance,
		MAKEINTRESOURCE(IDD_ABOUT),
		hWnd,
		AboutDlgProc,
		(LPARAM)this);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SceneImport\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SceneImport.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_SIMPLE                      3
#define IDS_LIBDESC                     4
#define IDS_EXT_01                      5
#define IDS_SHORTDESC                   6
#define IDS_LONGDESC                    7
#define IDS_AUTHOR                      8
#define IDS_COPYRIGHT                   9
#define IDD_SKELETON_SCIMP              101
#define IDD_ABOUT                       102
#define IDD_VIEW                        103
#define IDC_SIMPLE                      1000
#define IDC_FILEVIEW                    1000
#define IDC_OK                          1001
#define IDC_CANCEL                      1002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Shader\Dialog.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Dialog.cpp
 |			Skeleton project and code for a Material Shader
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 26-1-99
 | 
\*===========================================================================*/


#include "Shader.h"


#define SHADER_NCOLBOX 1


/*===========================================================================*\
 |	Complete dialog handler implimentation
\*===========================================================================*/

class SkeletonShaderDlg : public ShaderParamDlg {
public:
	
	SkeletonShader*	pShader;
	StdMat2*		pMtl;
	HPALETTE		hOldPal;
	HWND			hwmEdit;
	IMtlParams*		pMtlPar;
	HWND			hwHilite;
	HWND			hRollup;
	TimeValue		curTime;
	BOOL			valid;
	BOOL			isActive;


	IColorSwatch *cs[SHADER_NCOLBOX];
	ISpinnerControl *brSpin, *trSpin;
	ICustButton* texMBut[NMBUTS];
	TexDADMgr dadMgr;
	

	SkeletonShaderDlg( HWND hwMtlEdit, IMtlParams *pParams ); 
	~SkeletonShaderDlg(); 


	// DnD: Required for correctly operating map buttons
	int FindSubTexFromHWND(HWND hw) {
		for (long i=0; i<NMBUTS; i++) {
			if (hw == texMBut[i]->GetHwnd()) 
				return texmapFromMBut[i];
		}	
		return -1;
	}


	BOOL PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ); 
	Class_ID ClassID(){ return SKELSHADER_CLASSID; }
	void DeleteThis() { delete this; }


	// Set shader or material host from incoming values
	void SetThing(ReferenceTarget *m){ pMtl = (StdMat2*)m; }
	void SetThings( StdMat2* theMtl, Shader* theShader )
	{	pShader = (SkeletonShader*)theShader; 
		if (pShader)pShader->SetParamDlg(this); 
		pMtl = theMtl; 
	}

	// Get the shader and material host
	ReferenceTarget* GetThing(){ return (ReferenceTarget*)pMtl; }
	Shader* GetShader(){ return pShader; }
	
	void SetTime(TimeValue t) 
	{ 
		if (!pShader->ivalid.InInterval(t)) {
			Interval v;
			pShader->Update(t,v);
			LoadDialog(TRUE); 
		}
		curTime = t; 
	}		

	// Is there a keyframe at this time?
	BOOL KeyAtCurTime(int id) { return pShader->KeyAtTime(id,curTime); } 

	void ActivateDlg( BOOL dlgOn ){ isActive = dlgOn; }
	HWND GetHWnd(){ return hRollup; }

	// Get notified of changes, and update dialog controls
	void NotifyChanged(){ pShader->NotifyChanged(); }
	void LoadDialog(BOOL draw);
	void ReloadDialog(){ Interval v; pShader->Update(pMtlPar->GetTime(), v); LoadDialog(FALSE);}

	// Update the various components of the dialog
	void UpdateDialog( ParamID paramId ){ ReloadDialog(); }
	void UpdateMtlDisplay(){ pMtlPar->MtlChanged(); }
    void UpdateHilite( );
	void UpdateColSwatches();
	void UpdateMapButtons();
	void UpdateOpacity();

	// Start editing a color swatch
	void SelectEditColor(int i) { cs[ i ]->EditThis(FALSE); }
};

static BOOL CALLBACK  SkeletonShaderDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	SkeletonShaderDlg *theDlg;
	if (msg == WM_INITDIALOG) {
		theDlg = (SkeletonShaderDlg*)lParam;
		SetWindowLong(hwndDlg, GWL_USERDATA, lParam);
	} else {
	    if ( (theDlg = (SkeletonShaderDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
	}
	theDlg->isActive = 1;
	BOOL res = theDlg->PanelProc(hwndDlg, msg, wParam, lParam);
	theDlg->isActive = 0;
	return res;
}



/*===========================================================================*\
 |	Create the dialog panels themselves
\*===========================================================================*/

ShaderParamDlg* SkeletonShader::CreateParamDialog(HWND hOldRollup, HWND hwMtlEdit, IMtlParams *imp, StdMat2* theMtl, int rollupOpen ) 
{
	Interval v;
	Update(imp->GetTime(),v);
	
	SkeletonShaderDlg *pDlg = new SkeletonShaderDlg(hwMtlEdit, imp);
	pDlg->SetThings( theMtl, this  );

	// If it already exists, replace it
	if ( hOldRollup ) {
		pDlg->hRollup = imp->ReplaceRollupPage( 
			hOldRollup,
			hInstance,
			MAKEINTRESOURCE(IDD_SHADER_SKEL1),
			SkeletonShaderDlgProc, 
			GetString(IDS_SKELETON_DESC),
			(LPARAM)pDlg , 
			rollupOpen
			);
	} else
		// otherwise, add one
		pDlg->hRollup = imp->AddRollupPage( 
			hInstance,
			MAKEINTRESOURCE(IDD_SHADER_SKEL1),
			SkeletonShaderDlgProc, 
			GetString(IDS_SKELETON_DESC),	
			(LPARAM)pDlg , 
			rollupOpen
			);

	return (ShaderParamDlg*)pDlg;	
}



/*===========================================================================*\
 |	Update the UI
\*===========================================================================*/

RefResult SkeletonShader::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
									  PartID& partID, RefMessage message ) 
{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock){
				// update UI if paramblock changed, possibly from scripter
				ParamID changingParam = pblock->LastNotifyParamID();
				// reload the dialog if present
				if (paramDlg){
					paramDlg->UpdateDialog(changingParam);
				}
				// notify our dependents that we've changed
				NotifyChanged();
			}
			break;
	}
	return(REF_SUCCEED);
}




/*===========================================================================*\
 |	Methods to draw the graphical represenation of the shader's hilite
 |	Mainly this just calls EvalHiliteCurve in Eval.cpp and draws a line as 
 |		high as the value it gets returned (clamped)
\*===========================================================================*/

static void VertLine(HDC hdc,int x, int ystart, int yend) 
{
	MoveToEx(hdc, x, ystart, NULL); 
	if (ystart <= yend)
		LineTo(hdc, x, yend+1);
	else 
		LineTo(hdc, x, yend-1);
}

void DrawHilite(HDC hdc, Rect& rect, Shader* pShader )
{
int w,h,npts,xcen,ybot,ytop,ylast,i,iy;

	HPEN linePen = (HPEN)GetStockObject(WHITE_PEN);
	HPEN fgPen = CreatePen(PS_SOLID,0,GetSysColor(COLOR_BTNFACE));
	HPEN bgPen = CreatePen(PS_SOLID,0,GetSysColor(COLOR_BTNSHADOW));

	w = rect.w();
	h = rect.h()-3;
	npts = (w-2)/2;
	xcen = rect.left+npts;
	ybot = rect.top+h;
	ytop = rect.top+2;
	ylast = -1;
	for (i=0; i<npts; i++) {
		float v = pShader->EvalHiliteCurve( (float)i/((float)npts*2.0f) );
		if (v>2.0f) v = 2.0f; // keep iy from wrapping
		iy = ybot-(int)(v*((float)h-2.0f));

		if (iy<ytop) iy = ytop;

		SelectPen(hdc, fgPen);
		VertLine(hdc,xcen+i,ybot,iy);
		VertLine(hdc,xcen-i,ybot,iy);

		if (iy-1>ytop) {
			// Fill in above curve
			SelectPen(hdc,bgPen);
			VertLine(hdc,xcen+i, ytop, iy-1);
			VertLine(hdc,xcen-i, ytop, iy-1);
			}
		if (ylast>=0) {
			SelectPen(hdc,linePen);
			VertLine(hdc,xcen+i-1,iy-1,ylast);
			VertLine(hdc,xcen-i+1,iy-1,ylast);
			}

		ylast = iy;
	}

	SelectObject( hdc, linePen );
	DeleteObject(fgPen);
	DeleteObject(bgPen);
	WhiteRect3D(hdc, rect, 1);
}

LRESULT CALLBACK HiliteWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) 
{
	int id = GetWindowLong(hwnd,GWL_ID);
	HWND hwParent = GetParent(hwnd);
	ShaderParamDlg *theDlg = (ShaderParamDlg *)GetWindowLong(hwParent, GWL_USERDATA);
	if (theDlg==NULL) return FALSE;

    switch (msg) {
		case WM_COMMAND: 	
		case WM_MOUSEMOVE: 	
		case WM_LBUTTONUP: 
		case WM_CREATE:
		case WM_DESTROY: 
		break;

		case WM_PAINT: 	
		{
			PAINTSTRUCT ps;
			Rect rect;
			HDC hdc = BeginPaint( hwnd, &ps );
			if (!IsRectEmpty(&ps.rcPaint)) {
				GetClientRect( hwnd, &rect );
				Shader* pShader = (Shader*)(theDlg->GetShader());
				DrawHilite(hdc, rect, pShader );
			}
			EndPaint( hwnd, &ps );
		}													
		break;
	}
	return DefWindowProc(hwnd,msg,wParam,lParam);
} 



/*===========================================================================*\
 |	Constructor/Destructor
 |	Initialize and destroy all custom controls
\*===========================================================================*/

SkeletonShaderDlg::SkeletonShaderDlg( HWND hwMtlEdit, IMtlParams *pParams)
{
	pMtl = NULL;
	pShader = NULL;
	hwmEdit = hwMtlEdit;
	pMtlPar = pParams;
	dadMgr.Init(this);
	brSpin = trSpin = NULL;
	hRollup = hwHilite = NULL;
	curTime = 0;
	isActive = valid = FALSE;

	for( long i = 0; i < SHADER_NCOLBOX; ++i )
		cs[ i ] = NULL;

	for( i = 0; i < NMBUTS; ++i )
		texMBut[ i ] = NULL;
}

SkeletonShaderDlg::~SkeletonShaderDlg()
{
	HDC hdc = GetDC(hRollup);
	GetGPort()->RestorePalette(hdc, hOldPal);
	ReleaseDC(hRollup, hdc);

	if( pShader ) pShader->SetParamDlg(NULL);

	for (long i=0; i < NMBUTS; i++ ){
		ReleaseICustButton( texMBut[i] );
		texMBut[i] = NULL; 
	}
	
	ReleaseISpinner(brSpin);
	ReleaseISpinner(trSpin);

	SetWindowLong(hRollup, GWL_USERDATA, NULL);
	SetWindowLong(hwHilite, GWL_USERDATA, NULL);
	hwHilite = hRollup = NULL;
}


/*===========================================================================*\
 |	Called to set the custom controls with their current settings
\*===========================================================================*/

void SkeletonShaderDlg::LoadDialog(BOOL draw) 
{
	if (pShader && hRollup) {
		brSpin->SetValue( pShader->GetBrightness() ,FALSE);
		brSpin->SetKeyBrackets(KeyAtCurTime(sk_brightness));
		
		trSpin->SetValue(FracToPc(pMtl->GetOpacity(curTime)),FALSE);
		trSpin->SetKeyBrackets(pMtl->KeyAtTime(OPACITY_PARAM, curTime));

		UpdateColSwatches();
		UpdateHilite();
	}
}



/*===========================================================================*\
 |	Lots of functions that will update the various componenets of the UI
 |	such as the hilite curve, specific values, etc
\*===========================================================================*/

static TCHAR* mapStates[] = { _T(" "), _T("m"),  _T("M") };

void SkeletonShaderDlg::UpdateMapButtons() 
{

	for ( long i = 0; i < NMBUTS; ++i ) {
		int nMap = texmapFromMBut[ i ];
		int state = pMtl->GetMapState( nMap );
		texMBut[i]->SetText( mapStates[ state ] );

		TSTR nm = pMtl->GetMapName( nMap );
		texMBut[i]->SetTooltip(TRUE,nm);
	}
}


void SkeletonShaderDlg::UpdateOpacity() 
{
	trSpin->SetValue(FracToPc(pMtl->GetOpacity(curTime)),FALSE);
	trSpin->SetKeyBrackets(pMtl->KeyAtTime(OPACITY_PARAM, curTime));
}

void SkeletonShaderDlg::UpdateColSwatches() 
{
	cs[0]->SetKeyBrackets( pShader->KeyAtTime(sk_diffuse,curTime) );
	cs[0]->SetColor( pShader->GetDiffuseClr() );
}


void SkeletonShaderDlg::UpdateHilite()
{
	HDC hdc = GetDC(hwHilite);
	Rect r;
	GetClientRect(hwHilite,&r);
	DrawHilite(hdc, r, pShader );
	ReleaseDC(hwHilite,hdc);
}




/*===========================================================================*\
 |	Translate a color IDC (control ID) to a color index
\*===========================================================================*/

static int ColorIDCToIndex(int idc) {
	switch (idc) {
		case IDC_COLOR: return 0;
		default: return 0;
	}
}





/*===========================================================================*\
 |	The dialog message handler
\*===========================================================================*/

BOOL SkeletonShaderDlg::PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) 
{
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg) {
		case WM_INITDIALOG:
			{
			HDC theHDC = GetDC(hwndDlg);
			hOldPal = GetGPort()->PlugPalette(theHDC);
			ReleaseDC(hwndDlg,theHDC);

			HWND hwndCS = GetDlgItem(hwndDlg, IDC_COLOR);
			cs[0] = GetIColorSwatch( hwndCS, pShader->GetDiffuseClr(), GetString(IDS_COLOR) );

			hwHilite = GetDlgItem(hwndDlg, IDC_HIGHLIGHT);
			SetWindowLong( hwHilite, GWL_WNDPROC, (LONG)HiliteWndProc);

			brSpin = SetupFloatSpinner(hwndDlg, IDC_BR_SPIN, IDC_BR_EDIT, 0.0f,1.0f, 0);
			brSpin->SetScale(0.01f);

			trSpin = SetupIntSpinner(hwndDlg, IDC_TR_SPIN, IDC_TR_EDIT, 0,100, 0);

			for (int j=0; j<NMBUTS; j++) {
				texMBut[j] = GetICustButton(GetDlgItem(hwndDlg,texMButtonsIDC[j]));
				assert( texMBut[j] );
				texMBut[j]->SetRightClickNotify(TRUE);
				texMBut[j]->SetDADMgr(&dadMgr);
			}
			LoadDialog(TRUE);
		}
		break;

		case WM_COMMAND: 
			{
			for ( int i=0; i<NMBUTS; i++) {
				if (id == texMButtonsIDC[i]) {
					PostMessage(hwmEdit,WM_TEXMAP_BUTTON, texmapFromMBut[i],(LPARAM)pMtl );
					UpdateMapButtons();
					goto exit;
					}
				}
			}

			break;

		case CC_COLOR_SEL: {
			int id = LOWORD(wParam);
			SelectEditColor(ColorIDCToIndex(id));
		}			
		break;
		case CC_COLOR_DROP:	{
			int id = LOWORD(wParam);
			SelectEditColor(ColorIDCToIndex(id));
		}
		break;
		case CC_COLOR_BUTTONDOWN:
			theHold.Begin();
		 break;
		case CC_COLOR_BUTTONUP:
			if (HIWORD(wParam)) theHold.Accept(GetString(IDS_PARAMCHG));
			else theHold.Cancel();
			break;
		case CC_COLOR_CHANGE: {			
			int id = LOWORD(wParam);
			int buttonUp = HIWORD(wParam); 
			int n = ColorIDCToIndex(id);
			if (buttonUp) theHold.Begin();
			DWORD curRGB = cs[n]->GetColor();
			pShader->SetDiffuseClr(curRGB, curTime); 
			if (buttonUp) {
				theHold.Accept(GetString(IDS_PARAMCHG));
				UpdateMtlDisplay();				
				}
		} break;
		case WM_PAINT: 
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;
		case WM_CLOSE:
		case WM_DESTROY: 
			break;
		case CC_SPINNER_CHANGE: 
			if (!theHold.Holding()) theHold.Begin();
			switch (id) {
				case IDC_BR_SPIN: 
					pShader->SetBrightness( brSpin->GetFVal() , curTime); 
					UpdateHilite();
					break;
				case IDC_TR_SPIN: 
					pMtl->SetOpacity(PcToFrac( trSpin->GetIVal()),curTime); 
					break;
			}
			UpdateMtlDisplay();
		break;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				theHold.Accept(GetString(IDS_PARAMCHG));
			else 
				theHold.Cancel();
			UpdateMtlDisplay();
			break;

    }
	exit:
	return FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Shader\GetSet.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	GetSet.cpp
 |			Skeleton project and code for a Material Shader
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 26-1-99
 | 
\*===========================================================================*/


#include "Shader.h"



/*===========================================================================*\
 |	Shader specific transaction
\*===========================================================================*/

void SkeletonShader::SetBrightness(float v, TimeValue t)
{ 
	brightness= v; 
	pblock->SetValue( sk_brightness, t, v); 
}

float SkeletonShader::GetBrightness(int mtlNum, BOOL backFace)
{ 
	return brightness; 
}	

float SkeletonShader::GetBrightness( TimeValue t)
{
	return pblock->GetFloat(sk_brightness,t);  
}		

void SkeletonShader::SetGlossiness(float v, TimeValue t)
{ 
}

float SkeletonShader::GetGlossiness(int mtlNum, BOOL backFace)
{ 
	return 40.0f; 
}	

float SkeletonShader::GetGlossiness( TimeValue t)
{
	return 40.0f;  
}		


/*===========================================================================*\
 |	Diffuse Transactions
\*===========================================================================*/

void SkeletonShader::SetDiffuseClr(Color c, TimeValue t)		
{ 
	diffuse = c; pblock->SetValue( sk_diffuse, t, c); 
}

Color SkeletonShader::GetDiffuseClr(int mtlNum, BOOL backFace)
{ 
	return diffuse;
}

Color SkeletonShader::GetDiffuseClr(TimeValue t)
{ 
	return pblock->GetColor(sk_diffuse,t); 
}


/*===========================================================================*\
 |	Ambient Transactions
\*===========================================================================*/

void SkeletonShader::SetAmbientClr(Color c, TimeValue t)
{
}

Color SkeletonShader::GetAmbientClr(int mtlNum, BOOL backFace)
{ 
	return diffuse * 0.5f;
}

Color SkeletonShader::GetAmbientClr(TimeValue t)
{ 
	return diffuse * 0.5f; 
}


/*===========================================================================*\
 |	Specular Transactions
\*===========================================================================*/

void SkeletonShader::SetSpecularClr(Color c, TimeValue t)
{
}

void SkeletonShader::SetSpecularLevel(float v, TimeValue t)
{
}
		
Color SkeletonShader::GetSpecularClr(int mtlNum, BOOL backFace)
{ 
	return Color(0.9f,0.9f,0.9f); 
}

float SkeletonShader::GetSpecularLevel(int mtlNum, BOOL backFace)
{ 
	return 1.0f; 
}

Color SkeletonShader::GetSpecularClr(TimeValue t)
{ 
	return Color(0.9f,0.9f,0.9f);
}

float SkeletonShader::GetSpecularLevel(TimeValue t)
{ 
	return 1.0f; 
}


/*===========================================================================*\
 |	SelfIllum Transactions
\*===========================================================================*/

void SkeletonShader::SetSelfIllum(float v, TimeValue t)	
{
}

float SkeletonShader::GetSelfIllum(int mtlNum, BOOL backFace)
{ 
	return 0.0f; 
}

void SkeletonShader::SetSelfIllumClrOn( BOOL on )
{
}

BOOL SkeletonShader::IsSelfIllumClrOn()
{ 
	return FALSE; 
}

BOOL SkeletonShader::IsSelfIllumClrOn(int mtlNum, BOOL backFace)
{ 
	return FALSE; 
}

void SkeletonShader::SetSelfIllumClr(Color c, TimeValue t)
{
}

Color SkeletonShader::GetSelfIllumClr(int mtlNum, BOOL backFace)
{ 
	return Color(0,0,0); 
}

float SkeletonShader::GetSelfIllum(TimeValue t)
{ 
	return 0.0f;
}		

Color SkeletonShader::GetSelfIllumClr(TimeValue t)
{ 
	return Color(0,0,0);
}		


/*===========================================================================*\
 |	Soften Transactions
\*===========================================================================*/

void SkeletonShader::SetSoftenLevel(float v, TimeValue t)
{
}

float SkeletonShader::GetSoftenLevel(int mtlNum, BOOL backFace)
{ 
	return 0.0f; 
}

float SkeletonShader::GetSoftenLevel(TimeValue t)
{ 
	return  0.0f; 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SceneImport\SceneImport.h ===
/*===========================================================================*\
 | 
 |  FILE:	SceneImport.h
 |			Skeleton project and code for a Scene Importer 
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 29-3-99
 | 
\*===========================================================================*/

#ifndef __SCIMPSKEL__H
#define __SCIMPSKEL__H

#include "max.h"
#include "resource.h"
#include "iparamm2.h"

#include <commctrl.h>
#include <richedit.h>
#include <commdlg.h>
#include <dlgs.h>

// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	SCIMP_CLASSID		Class_ID(0x32b73314, 0x67114a4b)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonSceneImportDesc();

/*===========================================================================*\
 |	SkeletonExporter class defn
\*===========================================================================*/

class SkeletonImporter : public SceneImport {
public:
	SkeletonImporter();
	~SkeletonImporter();

	// Preferences values
	BOOL simpleParam;

	// Used in DoImport
	FILE *fileStream;
	Interface* ip;

	const TCHAR *filenameTemp;



	// Number of extensions we support
	int ExtCount();
	const TCHAR * Ext(int n);

	// The bookkeeping functions
	const TCHAR * LongDesc();
	const TCHAR * ShortDesc();
	const TCHAR * AuthorName();
	const TCHAR * CopyrightMessage();
	const TCHAR * OtherMessage1();
	const TCHAR * OtherMessage2();

	// Version number of this importer
	unsigned int Version();

	// Show an about box
	void ShowAbout(HWND hWnd);

	// Do the actual import
	int DoImport(const TCHAR *name, ImpInterface *ii,Interface *i, BOOL suppressPrompts=FALSE);

	// Configuration file management
	BOOL LoadImporterConfig();
	void SaveImporterConfig();
	TSTR GetConfigFilename();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Shader\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Shader.rc
//
#define IDS_LIBDESC                     1
#define IDS_MN_DIFFUSE                  2
#define IDS_MN_BRIGHTNESS               3
#define IDS_MN_OPACITY                  4
#define IDS_MN_NONE                     5
#define IDS_CLASSNAME                   6
#define IDS_PARAMETERS                  7
#define IDS_SKELETON_DESC               8
#define IDS_COLOR                       9
#define IDS_PARAMCHG                    10
#define IDS_MN_DIFFUSE_I                11
#define IDS_MN_BRIGHTNESS_I             12
#define IDS_MN_OPACITY_I                13
#define IDS_MN_FILTER_I                 15
#define IDD_SHADER_SKEL1                148
#define IDC_TR_EDIT                     220
#define IDC_TR_SPIN                     330
#define IDC_MAPON_TR                    1038
#define IDC_HIGHLIGHT                   1062
#define IDC_BR_EDIT                     1807
#define IDC_BR_SPIN                     1808
#define IDC_MAPON_BR                    1809
#define IDC_COLOR                       1813
#define IDC_MAPON_CLR                   1814

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Shader\Shader.h ===
/*===========================================================================*\
 | 
 |  FILE:	Shader.h
 |			Skeleton project and code for a Material Shader
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 26-1-99
 | 
\*===========================================================================*/

#ifndef __SAMPSKEL__H
#define __SAMPSKEL__H

#include "max.h"
#include "texutil.h"
#include "shaders.h"
#include "imtl.h"
#include "macrorec.h"
#include "gport.h"

#include "resource.h"
#include "shadertools.h"



// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	SKELSHADER_CLASSID		Class_ID(0x670a56d0, 0x23fc5c6e)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonShaderDesc();



// Paramblock2 name
enum { shader_params, };
// Paramblock2 parameter list
enum 
{ 
	sk_diffuse, sk_brightness,  
};



/*===========================================================================*\
 |	Definition of our UI and map parameters for the shader
 |  For this skeleton we support 3 minimal channels
\*===========================================================================*/

// Number of Map Buttons on our UI and number of texmaps
#define NMBUTS 3
#define SHADER_NTEXMAPS	3
// Channels used by this shader
#define S_DI	0
#define S_BR	1
#define S_TR	2


// Texture Channel number --> IDC resource ID
static int texMButtonsIDC[] = {
	IDC_MAPON_CLR, IDC_MAPON_BR, IDC_MAPON_TR,
};
		
// Map Button --> Texture Map number
static int texmapFromMBut[] = { 0, 1, 2 };


// Channel Name array
static int texNameIDS[STD2_NMAX_TEXMAPS] = {
	IDS_MN_DIFFUSE,		IDS_MN_BRIGHTNESS,	IDS_MN_OPACITY,		IDS_MN_NONE, 
	IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,
	IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,
	IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,
	IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,
	IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,
};	

// Channel Name array (INTERNAL NAMES)
static int intertexNameIDS[STD2_NMAX_TEXMAPS] = {
	IDS_MN_DIFFUSE_I,	IDS_MN_BRIGHTNESS_I,IDS_MN_OPACITY_I,		IDS_MN_NONE, 
	IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,
	IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,
	IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,
	IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,
	IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,		IDS_MN_NONE,
};	

// Internal channel names
static TCHAR* texInternalNames[STD2_NMAX_TEXMAPS] = {
	_T("diffuseMap"),_T("BrightnessMap"), _T("opacityMap"), _T(""), 	
	_T(""), _T(""), _T(""), _T(""), 
	_T(""), _T(""), _T(""), _T(""), 
	_T(""), _T(""), _T(""), _T(""),
	_T(""), _T(""), _T(""), _T(""), 
	_T(""), _T(""), _T(""), _T(""),
};	

// Type of map channels supported
static int chanType[STD2_NMAX_TEXMAPS] = {
	CLR_CHANNEL, MONO_CHANNEL, MONO_CHANNEL, UNSUPPORTED_CHANNEL, 
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, 
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, 
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, 
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, 
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, 
};	


// What channel in our shader maps to one of the StdMat channel IDs?
//
//
// The following are the StdMat channel IDs:
//
// 0   --	ambient
// 1   --	diffuse
// 2   --	specular
// 3   --	shininesNs
// 4   --	shininess strength
// 5   --	self-illumination
// 6   --	opacity
// 7   --	filter color
// 8   --	bump 
// 9   --	reflection
// 10  --	refraction 
// 11  --	displacement

static int stdIDToChannel[N_ID_CHANNELS] = { -1, 0, -1, -1, -1, -1, 2, 3, -1, -1, -1, -1 };



/*===========================================================================*\
 |	Class definition for the shader itself
\*===========================================================================*/

#define SHADER_PARAMS (STD_EXTRA)

class SkeletonShaderDlg;

class SkeletonShader : public Shader {
friend class SkeletonShaderDlg;
protected:

	// The parameter block
	IParamBlock2	*pblock; 
	Interval		ivalid;
	TimeValue		curTime;


	// Pointer to the dialog handler
	SkeletonShaderDlg*	paramDlg;


	// Storage for our parameters
	Color			diffuse;
	float			brightness;


public:

	SkeletonShader();

	// Main plugin identity support
	Class_ID ClassID() { return SKELSHADER_CLASSID; }
	SClass_ID SuperClassID() { return SHADER_CLASS_ID; }
	TSTR GetName() { return GetString( IDS_CLASSNAME ); }
	void GetClassName(TSTR& s) { s = GetName(); }  
	void DeleteThis(){ delete this; }		

	// Tell MAX what standard parameters that we support
    ULONG SupportStdParams(){ return SHADER_PARAMS; }

	// copy std params, for switching shaders
    void CopyStdParams( Shader* pFrom );
	void ConvertParamBlk( ParamBlockDescID *oldPBDesc, int oldCount, IParamBlock *oldPB ){};

	// Texture map channel support
	long nTexChannelsSupported(){ return SHADER_NTEXMAPS; }
	TSTR GetTexChannelName( long nTex ){ return GetString( texNameIDS[ nTex ] ); }
	TSTR GetTexChannelInternalName( long nTex ){ return GetString( intertexNameIDS[ nTex ] ); }
	long ChannelType( long nChan ) { return chanType[nChan]; }
	long StdIDToChannel( long stdID ){ return stdIDToChannel[stdID]; }

	// Find out if we have a key at time value t
	BOOL KeyAtTime(int id,TimeValue t) { return pblock->KeyFrameAtTime(id,t); }

	// Get the requirements for this material (supersampling, etc)
	ULONG GetRequirements( int subMtlNum ){ return MTLREQ_PHONG; }

	// Support for the dialog UI
	ShaderParamDlg* CreateParamDialog(HWND hOldRollup, HWND hwMtlEdit, IMtlParams *imp, StdMat2* theMtl, int rollupOpen );
	ShaderParamDlg* GetParamDlg(){ return (ShaderParamDlg*)paramDlg; }
	void SetParamDlg( ShaderParamDlg* newDlg ){ paramDlg = (SkeletonShaderDlg*)newDlg; }


	// Animatables and References
	int NumSubs() { return 1; }  
	Animatable* SubAnim(int i){ return (i==0)? pblock : NULL; }
	TSTR SubAnimName(int i){ return TSTR(GetString( IDS_PARAMETERS)); };
	int SubNumToRefNum(int subNum) { return subNum;	}

	int NumRefs() { return 1; }
	RefTargetHandle GetReference(int i){ return (i==0)? pblock : NULL; }
	void SetReference(int i, RefTargetHandle rtarg) 
		{ if (i==0) pblock = (IParamBlock2*)rtarg; }
	void NotifyChanged(){ NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE); }
	RefTargetHandle Clone( RemapDir &remap=NoRemap() );
	RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
	                            PartID& partID, RefMessage message );


	// Direct ParamBlock2 access
	int	NumParamBlocks() { return 1; }
	IParamBlock2* GetParamBlock(int i) { return pblock; }
	IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } 


	// Shader state methods
	void Update(TimeValue t, Interval& valid);
	void Reset();


	// Standard load / save
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);



	// ----------------------------------------------------------
	// The following methods are implimented in Eval.cpp

	// Fill the IllumParams with our data
	void GetIllumParams( ShadeContext &sc, IllumParams &ip );

	// Shader specific implimentations
	void Illum(ShadeContext &sc, IllumParams &ip);
	void AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol);

	void CombineComponents( ShadeContext &sc, IllumParams& ip );

	float EvalHiliteCurve(float x);

	// Metal support
	BOOL IsMetal();



	// ----------------------------------------------------------
	// The following transactions are implimented in GetSet.cpp

	// Skeleton Shader specific
	void SetBrightness(float v, TimeValue t);
	float GetBrightness(int mtlNum=0, BOOL backFace=FALSE);
	float GetBrightness( TimeValue t);

	// DIFFUSE
	void SetDiffuseClr(Color c, TimeValue t);
    Color GetDiffuseClr(int mtlNum=0, BOOL backFace=FALSE);		
	Color GetDiffuseClr(TimeValue t);		

	// AMBIENT
	void SetAmbientClr(Color c, TimeValue t);
	Color GetAmbientClr(int mtlNum=0, BOOL backFace=FALSE);		
	Color GetAmbientClr(TimeValue t);		

	// SPECULAR
	void SetSpecularClr(Color c, TimeValue t);
	void SetSpecularLevel(float v, TimeValue t);		
	Color GetSpecularClr(int mtlNum=0, BOOL backFace=FALSE);
	float GetSpecularLevel(int mtlNum=0, BOOL backFace=FALSE);
	Color GetSpecularClr(TimeValue t);
	float GetSpecularLevel(TimeValue t);

	// SELFILLUM
	void SetSelfIllum(float v, TimeValue t);
	float GetSelfIllum(int mtlNum=0, BOOL backFace=FALSE);
	void SetSelfIllumClrOn( BOOL on );
	BOOL IsSelfIllumClrOn();
	BOOL IsSelfIllumClrOn(int mtlNum, BOOL backFace);
	void SetSelfIllumClr(Color c, TimeValue t);
	Color GetSelfIllumClr(int mtlNum=0, BOOL backFace=FALSE);
	float GetSelfIllum(TimeValue t);	
	Color GetSelfIllumClr(TimeValue t);		

	// SOFTEN
	void SetSoftenLevel(float v, TimeValue t);
	float GetSoftenLevel(int mtlNum=0, BOOL backFace=FALSE);
	float GetSoftenLevel(TimeValue t);


	void SetGlossiness(float v, TimeValue t);
	float GetGlossiness(int mtlNum, BOOL backFace);
	float GetGlossiness( TimeValue t);


	// Standard locks not supported (Diffuse+Specular)/(Ambient+Diffuse)
	void SetLockDS(BOOL lock){ }
	BOOL GetLockDS(){ return FALSE; }
	void SetLockAD(BOOL lock){ }
	BOOL GetLockAD(){ return FALSE; }
	void SetLockADTex(BOOL lock){ }
	BOOL GetLockADTex(){ return FALSE; }

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Shader\Shader.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Shader.cpp
 |			Skeleton project and code for a Material Shader
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 26-1-99
 | 
\*===========================================================================*/


#include "Shader.h"



/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonShaderClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create(BOOL loading)		{ return new SkeletonShader(); }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return SHADER_CLASS_ID; }
	Class_ID 		ClassID()					{ return SKELSHADER_CLASSID; }
	const TCHAR* 	Category()					{ return _T("");  }

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()				{ return _T("SkeletonShader"); }
	HINSTANCE		HInstance()					{ return hInstance; }
};

SkeletonShaderClassDesc SkelShaderCD;
ClassDesc * GetSkeletonShaderDesc(){ return &SkelShaderCD; }



/*===========================================================================*\
 |	Paramblock2 Descriptor
\*===========================================================================*/

static ParamBlockDesc2 shader_param_blk ( shader_params, _T("shaderParameters"),  0, &SkelShaderCD, P_AUTO_CONSTRUCT, 0, 
	// params
	sk_diffuse, _T("diffuse"), TYPE_RGBA, P_ANIMATABLE, IDS_MN_DIFFUSE, 
		p_default, Color(0.8f, 0.5f, 0.5f), 
		end,
	sk_brightness, _T("brightness"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_MN_BRIGHTNESS,
		p_default,		0.2f,
		p_range,		0.0f, 1.0f,
		end,
	end
);



/*===========================================================================*\
 |	Constructor
\*===========================================================================*/

SkeletonShader::SkeletonShader() 
{ 
	pblock = NULL; 
	paramDlg = NULL; 
	curTime = 0;
	ivalid.SetEmpty(); 
}



/*===========================================================================*\
 |	Cloning and coping standard parameters
\*===========================================================================*/

void SkeletonShader::CopyStdParams( Shader* pFrom )
{
	// We don't want to see this parameter copying in macrorecorder
	macroRecorder->Disable(); 

		SetAmbientClr( pFrom->GetAmbientClr(0,0), curTime );
		SetDiffuseClr( pFrom->GetDiffuseClr(0,0), curTime );

	macroRecorder->Enable();
	ivalid.SetEmpty();	
}


RefTargetHandle SkeletonShader::Clone( RemapDir &remap )
{
	SkeletonShader* mnew = new SkeletonShader();
	mnew->ReplaceReference(0, remap.CloneRef(pblock));
	mnew->ivalid.SetEmpty();	
	mnew->diffuse = diffuse;
	mnew->brightness = brightness;
	return (RefTargetHandle)mnew;
}



/*===========================================================================*\
 |	Shader state
\*===========================================================================*/

void SkeletonShader::Update(TimeValue t, Interval &valid) {
	Point3 p;
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();

		pblock->GetValue( sk_diffuse, t, p, ivalid );
		diffuse= Bound(Color(p.x,p.y,p.z));
		pblock->GetValue( sk_brightness, t, brightness, ivalid );
		brightness = Bound(brightness );
		curTime = t;
	}
	valid &= ivalid;
}

void SkeletonShader::Reset()
{
	SkelShaderCD.MakeAutoParamBlocks(this);	// Create and intialize paramblock2

	ivalid.SetEmpty();
	SetDiffuseClr( Color(0.8f,0.5f,0.5f), 0 );
	SetBrightness( 0.2f,0);   
}



/*===========================================================================*\
 |	Shader load/save
\*===========================================================================*/


#define SHADER_VERS_CHUNK 0x6500

IOResult SkeletonShader::Save(ISave *isave) 
{ 
ULONG nb;

	isave->BeginChunk(SHADER_VERS_CHUNK);
	int version = 1;
	isave->Write(&version,sizeof(version),&nb);			
	isave->EndChunk();

	return IO_OK;
}		



IOResult SkeletonShader::Load(ILoad *iload) { 
	ULONG nb;
	int id;
	int version = 0;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case SHADER_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}

	return IO_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Shader\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Material Shader
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 26-1-98
 | 
\*===========================================================================*/

#include "Shader.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonShaderDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\ShadowGen\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Shadow Generator
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 10-3-99
 | 
\*===========================================================================*/

#include "ShadowGen.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonShdwGenDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\ShadowGen\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ShadowGen.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_LIBDESC                     4
#define IDS_SIMPLE                      5
#define IDC_SIMPLE                      1000
#define IDD_SKELETON_SHADOW             1015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Shader\ShaderTools.h ===
/*===========================================================================*\
 | 
 |  FILE:	Shader.h
 |			Skeleton project and code for a Material Shader
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 26-1-99
 | 
\*===========================================================================*/
/*===========================================================================*\
 |	A couple of handy little functions, from ShaderUtil.cpp in SDK Samples
\*===========================================================================*/


// For binding values to a specific limit
inline float Bound( float x, float min = 0.0f, float max = 1.0f )
	{ return x < min? min:( x > max? max : x); }
inline Color Bound( Color& c )
	{ return Color( Bound(c.r), Bound(c.g), Bound(c.b) ); }

inline float UBound( float x, float max = 1.0f ){ return x > max ? max : x; }
inline float LBound( float x, float min = 0.0f ){ return x < min ? min : x; }

inline float Min( float a, float b ) { return (a < b) ? a : b; }
inline float Min( float a, float b, float c ) { return (a < b) ? Min(a,c) : Min(b,c); }
inline float Min( Color& c ){ return Min( c.r, c.g, c.b ); }
inline float Max( float a, float b ) { return (a < b) ? b : a; }
inline float Max( float a, float b, float c ) { return (a < b) ? Max( b, c ) : Max(a,c); }
inline float Max( Color& c ){ return Max( c.r, c.g, c.b ); }


// Conversion to fractions/viceversa
inline float PcToFrac(int pc) { return (float)pc/100.0f; }

inline int FracToPc(float f) {
	if (f<0.0) return (int)(100.0f*f - .5f);
	else return (int) (100.0f*f + .5f);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\ShadowGen\ShadowShader.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	ShadowShader.cpp
 |			Skeleton project and code for a Shadow Generator
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 10-3-99
 | 
\*===========================================================================*/

#include "ShadowGen.h"


/*===========================================================================*\
 |	The Update function is called each frame, for the shadow generator
 |	to update itself, generate a shadow buffer, etc
\*===========================================================================*/

int SkeletonGen::Update(TimeValue t,const RendContext& rendCntxt,RenderGlobalContext *rgc,
		Matrix3& ltToWorld,float aspect,float param,float clipDist)
{
	lightToWorld  = ltToWorld;
	worldToLight = Inverse(lightToWorld);

	return 1;
}




/*===========================================================================*\
 |	This shadow generator now must calculate whether or not the current
 |	surface point is in shadow (return 0.0f) or not
\*===========================================================================*/

float SkeletonGen::Sample(ShadeContext &sc, Point3 &norm, Color& color)
{ 
	Point3 ptSurf = sc.P();
	Point3 ptNorm = norm;
	Point3 plt = camToLight*ptSurf;

	return 1.0f;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\ShadowGen\ShadowGen.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	ShadowGen.cpp
 |			Skeleton project and code for a Shadow Generator
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 10-3-99
 | 
\*===========================================================================*/

#include "ShadowGen.h"



/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonShadowClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create(BOOL loading)		{ return new SkeletonShadow; }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return SHADOW_TYPE_CLASS_ID; }
	Class_ID 		ClassID()					{ return SHADOW_CLASSID; }
	const TCHAR* 	Category()					{ return _T("");  }

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()				{ return _T("SkeletonShadowGen"); }
	HINSTANCE		HInstance()					{ return hInstance; }
	};

static SkeletonShadowClassDesc SkelShadCD;

ClassDesc* GetSkeletonShdwGenDesc() { return &SkelShadCD; }




/*===========================================================================*\
 |	Paramblock2 Descriptor
\*===========================================================================*/

static ParamBlockDesc2 skshadow_param_blk ( shd_params, _T("SkeletonShadow parameters"),  0, &SkelShadCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_SKELETON_SHADOW, IDS_PARAMETERS, 0, 0, NULL, 
	// params
	shd_simple_param,	_T("shd_simple_param"),	TYPE_BOOL,	P_ANIMATABLE,	IDS_SIMPLE,
		p_default,		FALSE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_SIMPLE, 
		end,
	end
	);


/*===========================================================================*\
 |	Constructor
 |  Ask the ClassDesc2 to make the AUTO_CONSTRUCT paramblocks and wire them in
\*===========================================================================*/

SkeletonShadow::SkeletonShadow()
	{
	theParam = NULL;
	SkelShadCD.MakeAutoParamBlocks(this);
	assert(pblock);
	}


/*===========================================================================*\
 |	Subanim & References support
\*===========================================================================*/

Animatable* SkeletonShadow::SubAnim(int i) 	{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
	}
TSTR SkeletonShadow::SubAnimName(int i) {
	switch (i) {
		case 0: return GetString(IDS_PARAMETERS);
		default: return _T("");
		}
	}

RefTargetHandle SkeletonShadow::GetReference(int i)
	{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
	}
void SkeletonShadow::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case 0: pblock = (IParamBlock2*)rtarg; break;
		}
	}
RefResult SkeletonShadow::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
	{
	switch (message) {
		case REFMSG_CHANGE:
			skshadow_param_blk.InvalidateUI();
			break;
		}
	return REF_SUCCEED;
	}


/*===========================================================================*\
 |	Support the Parammap UI
\*===========================================================================*/

SkeletonParam::SkeletonParam(SkeletonShadow *shad, Interface *intface) {
	theShad = shad;
	ip = intface;

	pmap = CreateCPParamMap2(
		theShad->pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_SKELETON_SHADOW),
		GetString(IDS_PARAMETERS),
		0);
	}

SkeletonParam::~SkeletonParam(){
	if(theShad) theShad->theParam = NULL;
	DestroyCPParamMap2(pmap);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\ShadowGen\ShadowGen.h ===
/*===========================================================================*\
 | 
 |  FILE:	ShadowGen.h
 |			Skeleton project and code for a Shadow Generator
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 10-3-99
 | 
\*===========================================================================*/

#ifndef __SHADOWSKEL__H
#define __SHADOWSKEL__H

#include "max.h"
#include "render.h"
#include "shadgen.h"
#include "genlight.h"
#include "iparamm2.h"
#include "notify.h"
#include <bmmlib.h>
#include "resource.h"
#include "shadbuf.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	SHADOW_CLASSID		Class_ID(0x4f02540e, 0x4c000797)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonShdwGenDesc();


// Paramblock2 name
enum { shd_params, }; 
// Paramblock2 parameter list
enum { shd_simple_param, };


class SkeletonShadow;
/*===========================================================================*\
 |	SkeletonGen class defn.
\*===========================================================================*/

class SkeletonGen: public ShadowGenerator 
{ 
public:
	SkeletonShadow *theShad;

	// Various transforms
	Matrix3 lightToWorld;
	Matrix3 worldToLight;
	Matrix3 camToLight;

	LightObject *light;
	ObjLightDesc *ltDesc;



	SkeletonGen(SkeletonShadow *shad, LightObject *l,  ObjLightDesc *ld, ULONG flags) { 
		theShad = shad;
		light = l;
		ltDesc = ld;
		} 

	
	SkeletonGen() { } 
	~SkeletonGen() { FreeBuffer();  }


	// Update the shadow generator per frame
	int Update(TimeValue t,const RendContext& rendCntxt,RenderGlobalContext *rgc,
		Matrix3& lightToWorld,float aspect,float param,float clipDist);

	int UpdateViewDepParams(const Matrix3& worldToCam) { 
		Matrix3 camToWorld = Inverse(worldToCam);
		camToLight = camToWorld*worldToLight;
		return 1;
		}


	// Clean up methods
	void FreeBuffer() {}
	void DeleteThis() {delete this; }


	// Perform the shadow sampling
	float Sample(ShadeContext &sc, Point3 &norm, Color& color);
};

class SkeletonParam: public ShadowParamDlg 
{
public:
	SkeletonShadow *theShad;
	Interface *ip;
	IParamMap2 *pmap;

	// Constructor
	SkeletonParam(SkeletonShadow *shad, Interface *iface);
	~SkeletonParam();

	void DeleteThis() { delete this; }
};


class SkeletonShadow: public ShadowType 
{
	public:
		IParamBlock2 *pblock;
		SkeletonParam *theParam;

		SkeletonShadow();
		~SkeletonShadow() {
			if (theParam) theParam->theShad = NULL;
			}


		// Create the shadow system's UI
		ShadowParamDlg *CreateShadowParamDlg(Interface *ip) { 
			theParam = new SkeletonParam(this, ip); return theParam;
			}

		// Create a shadow generator instance - only exists during a render
		ShadowGenerator* CreateShadowGenerator(LightObject *l,  ObjLightDesc *ld, ULONG flags) {
			return new SkeletonGen(this,l,ld,flags);
			}

		BOOL SupportStdMapInterface() { return FALSE; }
		
		SClass_ID SuperClassID() { return SHADOW_TYPE_CLASS_ID;}
		Class_ID ClassID() { return SHADOW_CLASSID;}

		int NumSubs() {return 1;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);

		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message);

		void DeleteThis() { delete this; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleModifier\SimpleDeform.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	SimpDeform.cpp
 |			Skeleton project and code for a Simple Modifier
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#include "SimpleMod.h"



/*===========================================================================*\
 |	Deformer class that does most of the work in a simple Modifier
\*===========================================================================*/

SkeletonDeformer::SkeletonDeformer() 
	{ 
	tm.IdentityMatrix();
	time = 0;	
	}


void SkeletonDeformer::SetAxis(Matrix3 &tmAxis)
	{
	Matrix3 itm = Inverse(tmAxis);
	tm    = tm*tmAxis;
	invtm =	itm*invtm;
	}


/*===========================================================================*\
 |	Map is called for every deformable point in the object
\*===========================================================================*/

Point3 SkeletonDeformer::Map(int i, Point3 p)
	{
	p = p * tm;

		p.x+= (bpt.x+def_sparam);
		p.y+= (bpt.y+def_sparam);
		p.z+= (bpt.z+def_sparam);

	p = p * invtm;
	return p;
	}


/*===========================================================================*\
 |	Constructor - copy params into this local class for Map-ing
\*===========================================================================*/

SkeletonDeformer::SkeletonDeformer(
		TimeValue t, ModContext &mc,
		Matrix3& modmat, Matrix3& modinv,
		float sparam) 
	{	
	this->def_sparam	= sparam;
	this->time			= t;

	Matrix3 mat;
	Interval valid;	

	tm = modmat;
	invtm = modinv;
	mat.IdentityMatrix();
	
	assert(mc.box);
	bbox = *mc.box;
	bpt = bbox.Center();

	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleModifier\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SimpleMod.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_LIBDESC                     4
#define IDS_SIMPLE                      5
#define IDD_SKELETON_SMOD               101
#define IDC_SIMPLE_EDIT                 1004
#define IDC_SIMPLE_SPIN                 1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleModifier\SimpleMod.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	SimpMod.cpp
 |			Skeleton project and code for a Simple Modifier
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#include "SimpleMod.h"


IObjParam* SkeletonSimpMod::ip = NULL;


/*===========================================================================*\
 |	Class Descriptor OSM
\*===========================================================================*/

class SkeletonSModClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create( BOOL loading )		{ return new SkeletonSimpMod; }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return OSM_CLASS_ID; }
	Class_ID 		ClassID()					{ return SIMPM_CLASSID; }
	const TCHAR* 	Category()					{ return _T("");  }

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()				{ return _T("SkeletonSimpleMod"); }
	HINSTANCE		HInstance()					{ return hInstance; }
};

static SkeletonSModClassDesc SkeletonSMCD;
ClassDesc* GetSimpleModDesc() {return &SkeletonSMCD;}


/*===========================================================================*\
 |	Class Descriptor WSM
\*===========================================================================*/

class SkeletonSWSMClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create( BOOL loading )
	{
		if (loading) return new SkeletonSimpWSM; 
		else return new SkeletonSimpWSM(new SkeletonSimpMod);
	}

	const TCHAR *	ClassName() { return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID 		ClassID() { return SMWSM_CLASSID; }
	const TCHAR* 	Category() { return _T("");  }

	const TCHAR*	InternalName() { return _T("SkeletonSimpleModWSM"); }
	HINSTANCE		HInstance() { return hInstance; }
};

static SkeletonSWSMClassDesc SkeletonSWSMCD;
ClassDesc* GetSimpleWSMDesc() {return &SkeletonSWSMCD;}



/*===========================================================================*\
 |	Basic implimentation of a dialog handler
\*===========================================================================*/

BOOL SkeletonModDlgProc::DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}


/*===========================================================================*\
 |	Paramblock2 Descriptor
\*===========================================================================*/

static ParamBlockDesc2 skeleton_param_blk ( simpm_params, _T("SkeletonSimpleModParams"),  0, &SkeletonSMCD, P_AUTO_CONSTRUCT + P_AUTO_UI, SIMPMOD_PBLOCKREF, 
	//rollout
	IDD_SKELETON_SMOD, IDS_PARAMETERS, 0, 0, NULL, 
	// params
	simpm_simple_param,	_T("simpmParam1"),	TYPE_FLOAT,	P_ANIMATABLE,	IDS_SIMPLE,
		p_default,		0.0f,
		p_range, 		0.0f, 10.0f, 
		p_ui,			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SIMPLE_EDIT, IDC_SIMPLE_SPIN, 0.1f,
		end,
	end
	);



/*===========================================================================*\
 |	Constructor
 |  Ask the ClassDesc2 to make the AUTO_CONSTRUCT paramblocks and wire them in
\*===========================================================================*/

SkeletonSimpMod::SkeletonSimpMod()
	{
	SkeletonSMCD.MakeAutoParamBlocks(this);
	assert(pblock2);
	}



/*===========================================================================*\
 |	Invalidate our UI (or the recently changed parameter)
\*===========================================================================*/

void SkeletonSimpMod::InvalidateUI()
{
	skeleton_param_blk.InvalidateUI(pblock2->LastNotifyParamID());
}



/*===========================================================================*\
 |	Open and Close dialog UIs
 |	We ask the ClassDesc2 to handle Beginning and Ending EditParams for us
\*===========================================================================*/

void SkeletonSimpMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	this->ip = ip;

	SimpleMod::BeginEditParams(ip,flags,prev);
	SkeletonSMCD.BeginEditParams(ip, this, flags, prev);

	skeleton_param_blk.SetUserDlgProc(new SkeletonModDlgProc(this));

	}
		
void SkeletonSimpMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleMod::EndEditParams(ip,flags,next);
	SkeletonSMCD.EndEditParams(ip, this, flags, next);

	this->ip = NULL;
	}



/*===========================================================================*\
 |	Standard Load and clone
\*===========================================================================*/

IOResult SkeletonSimpMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	return IO_OK;
	}

RefTargetHandle SkeletonSimpMod::Clone(RemapDir& remap) {	
	SkeletonSimpMod* newmod = new SkeletonSimpMod();	
	newmod->ReplaceReference(SIMPMOD_PBLOCKREF,pblock2->Clone(remap));
	newmod->SimpleModClone(this);
	return(newmod);
	}



/*===========================================================================*\
 |	The validity of our parameters
 |	Start at FOREVER, and intersect with the validity of each item
\*===========================================================================*/

Interval SkeletonSimpMod::GetValidity(TimeValue t)
	{
	float f;	
	Interval valid = FOREVER;
	pblock2->GetValue(simpm_simple_param, t, f, valid);
	return valid;
	}



/*===========================================================================*\
 |	Get the actual deformer to modify the object
\*===========================================================================*/

Deformer& SkeletonSimpMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	float sparam = 0.0f; Interval valid = FOREVER;
	pblock2->GetValue(simpm_simple_param, t, sparam, valid);

	static SkeletonDeformer deformer;
	deformer = SkeletonDeformer(t,mc,mat,invmat,sparam);
	return deformer;
	}



/*===========================================================================*\
 |	SimpleMod2 overloads
\*===========================================================================*/

RefTargetHandle SimpleMod2::GetReference(int i) 
	{ 
	switch (i) {
		case 0: return tmControl;
		case 1: return posControl;
		case 2: return pblock2;
		default: return NULL;
		}
	}

void SimpleMod2::SetReference(int i, RefTargetHandle rtarg) 
	{ 
	switch (i) {
		case 0: tmControl = (Control*)rtarg; break;
		case 1: posControl = (Control*)rtarg; break;
		case 2: pblock2 = (IParamBlock2*)rtarg; break;
		}
	}

Animatable* SimpleMod2::SubAnim(int i) 
	{ 
	switch (i) {
		case 0: return posControl;
		case 1: return tmControl;
		case 2: return pblock2;		
		default: return NULL;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleModifier\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Simple Modifier
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/

#include "SimpleMod.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 2;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSimpleModDesc();
		case 1: return GetSimpleWSMDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleObject\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Simple Object
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 8-3-99
 | 
\*===========================================================================*/

#include "SimpleObj.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSimpleObjDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleModifier\SimpleMod.h ===
/*===========================================================================*\
 | 
 |  FILE:	SimpMod.h
 |			Skeleton project and code for a Simple Modifier
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 21-1-99
 | 
\*===========================================================================*/


#ifndef __SMPSKEL__H
#define __SMPSKEL__H

#include "max.h"
#include "simpmod.h"
#include "simpobj.h"
#include "iparamm2.h"
#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	SIMPM_CLASSID		Class_ID(0x2d587cd4, 0x38b4754e)
#define	SMWSM_CLASSID		Class_ID(0x5cd4456f, 0x2939563a)


TCHAR *GetString(int id);
extern ClassDesc* GetSimpleModDesc();
extern ClassDesc* GetSimpleWSMDesc();


// Paramblock2 name
enum { simpm_params, }; 
// Paramblock2 parameter list
enum { simpm_simple_param, };




/*===========================================================================*\
 |	SkeletonSimpMod class defn
\*===========================================================================*/

class SkeletonSimpMod : public SimpleMod2 {	
	public:
		static IObjParam *ip;

		SkeletonSimpMod();

		// Plugin identification
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_CLASSNAME); }  
		virtual Class_ID ClassID() { return SIMPM_CLASSID;}		
		TCHAR *GetObjectName() { return GetString(IDS_CLASSNAME);}

		// Open/Close our UI
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);

		// Direct paramblock access
		int	NumParamBlocks() { return 1; }	
		IParamBlock2* GetParamBlock(int i) { return pblock2; }
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock2->ID() == id) ? pblock2 : NULL; }

		// Load and clone methods
		IOResult Load(ILoad *iload);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());

		// Deformer
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
		Interval GetValidity(TimeValue t);

		void InvalidateUI();
	};



/*===========================================================================*\
 |	SkeletonDeformer class defn
 |  This is the system that gets applied to each deformable point
 |
 |  Implimented in simpleDeform.cpp
\*===========================================================================*/

class SkeletonDeformer: public Deformer {
	public:
		Matrix3 tm,invtm, tmAbove, tmBelow;
		Box3 bbox;
		TimeValue time;
		float def_sparam; 
		
		// Bounding box center
		Point3 bpt;

		SkeletonDeformer();
		SkeletonDeformer(TimeValue t, ModContext &mc,
			Matrix3& modmat, Matrix3& modinv,
			float sparam);

		void SetAxis(Matrix3 &tmAxis);

		Point3 Map(int i, Point3 p); 
	};



/*===========================================================================*\
 |	SkeletonSimpWSM class defn
 |  Automatically support this plugin as a WSM
\*===========================================================================*/

class SkeletonSimpWSM : public SimpleOSMToWSMObject {
	public:
		SkeletonSimpWSM() {}
		SkeletonSimpWSM(SkeletonSimpMod *m) : SimpleOSMToWSMObject(m) {}

		void DeleteThis() { delete this; }
		SClass_ID SuperClassID() {return WSM_OBJECT_CLASS_ID;}
		Class_ID ClassID() {return SMWSM_CLASSID;} 

		RefTargetHandle Clone(RemapDir& remap)
		{
				return (new SkeletonSimpWSM((SkeletonSimpMod*)mod->Clone(remap)))->SimpleOSMToWSMClone(this,remap);
		}

		TCHAR *GetObjectName() {return GetString(IDS_CLASSNAME);}
	};


/*===========================================================================*\
 |	Dialog Processor
\*===========================================================================*/

class SkeletonModDlgProc : public ParamMap2UserDlgProc 
{
	public:
		SkeletonSimpMod *ssm;

		SkeletonModDlgProc() {}
		SkeletonModDlgProc(SkeletonSimpMod *ssm_in) { ssm = ssm_in; }

		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { }

		void SetThing(ReferenceTarget *m) {
			ssm = (SkeletonSimpMod*)m;
			}

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleObject\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SimpleObject.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_LIBDESC                     4
#define IDS_SIMPLE                      5
#define IDS_MAPPING                     6
#define IDD_SKELETON_SOBJ               180
#define IDC_MAPPING                     1000
#define IDC_SIMPLE_EDIT                 1004
#define IDC_SIMPLE_SPIN                 1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleObject\SimpleMesh.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Simple Object
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 8-3-99
 | 
\*===========================================================================*/

#include "SimpleObj.h"



/*===========================================================================*\
 |	Basic collapse types
 |  We just pass this onto SimpleObject, as we are nothing special here..
\*===========================================================================*/


Object* SkeletonSimpObj::ConvertToType(TimeValue t, Class_ID obtype)
{
		return SimpleObject::ConvertToType(t, obtype);
}

int SkeletonSimpObj::CanConvertToType(Class_ID obtype)
{
		return SimpleObject::CanConvertToType(obtype);
}


void SkeletonSimpObj::GetCollapseTypes(Tab<Class_ID> &clist, Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);
}




/*===========================================================================*\
 |	Mouse creation - mearly measure a length between two points
 |  and pass it into our pblock2
\*===========================================================================*/

int SkeletonObjCreateCallBack::proc(ViewExp *vpt, int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;
	Point3 p1, center;

	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m, m, NULL, SNAP_IN_3D);
	}


	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {

		// point one - where we measure from
		case 0:
			sso->suspendSnap = TRUE;				
			sp0 = m;
			p0 = vpt->SnapPoint(m, m, NULL, SNAP_IN_3D);
			mat.SetTrans(p0);
			break;

		// point two - where we measure to in worldspace
		case 1:
			mat.IdentityMatrix();
			
			p1 = vpt->SnapPoint(m, m, NULL, SNAP_IN_3D);
			r = Length(p1-p0);
			mat.SetTrans(p0);

			sso->pblock2->SetValue(simpo_simple_param, 0, r);

			if (msg==MOUSE_POINT) {
				sso->suspendSnap = FALSE;
				return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
			}
			break;					   
		}
	} else {
		if (msg == MOUSE_ABORT) return CREATE_ABORT;
	}

	return TRUE;
}

static SkeletonObjCreateCallBack soCreateCB;

CreateMouseCallBack* SkeletonSimpObj::GetCreateMouseCallBack() 
{
	soCreateCB.SetObj(this);
	return(&soCreateCB);
}




/*===========================================================================*\
 |	Mesh creation - create the actual object
 |	Just a flat panel of 2 faces, with texture mapping if required
\*===========================================================================*/

void SkeletonSimpObj::BuildMesh(TimeValue t)
{
	float sz; BOOL genUVs;
	ivalid = FOREVER;	
	pblock2->GetValue(simpo_simple_param,t,sz,ivalid);
	pblock2->GetValue(simpo_genuv, 0, genUVs, ivalid);

	mesh.setNumVerts(4);
	mesh.setNumFaces(2);
	mesh.InvalidateTopologyCache();


	mesh.setVert(0, Point3((float)sz,(float)sz,0.0f));
	mesh.setVert(1, Point3((float)-sz,(float)sz,0.0f));
	mesh.setVert(2, Point3((float)sz,(float)-sz,0.0f));
	mesh.setVert(3, Point3((float)-sz,(float)-sz,0.0f));


	if(genUVs)
	{
		mesh.setNumTVerts(4) ;
		mesh.setNumTVFaces(2);		

		mesh.setTVert(0, Point3(1.0f,1.0f,0.0f));
		mesh.setTVert(1, Point3(0.0f,1.0f,0.0f));
		mesh.setTVert(2, Point3(1.0f,0.0f,0.0f));
		mesh.setTVert(3, Point3(0.0f,0.0f,0.0f));

		mesh.tvFace[0].setTVerts(0,1,2);
		mesh.tvFace[1].setTVerts(1,3,2);
	}


	mesh.faces[0].setVerts(0,1,2);
	mesh.faces[0].setEdgeVisFlags(1,0,1);
	mesh.faces[1].setVerts(1,3,2);
	mesh.faces[1].setEdgeVisFlags(1,1,0);


	// Invalidate caches, so the object knows it must update
	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
}



/*===========================================================================*\
 |	Turn on/off UVW Mapping automatically
\*===========================================================================*/

BOOL SkeletonSimpObj::HasUVW() { 
	BOOL genUVs;
	pblock2->GetValue(simpo_genuv, 0, genUVs, FOREVER);
	return genUVs; 
	}

void SkeletonSimpObj::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock2->SetValue(simpo_genuv, 0, sw);				
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleObject\SimpleObj.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Simple Object
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 8-3-99
 | 
\*===========================================================================*/

#include "SimpleObj.h"


IObjParam* SkeletonSimpObj::ip = NULL;


/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonSObjClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create( BOOL loading )		{ return new SkeletonSimpObj; }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return GEOMOBJECT_CLASS_ID; }
	Class_ID 		ClassID()					{ return SIMPO_CLASSID; }
	const TCHAR* 	Category()					{ return _T("");  }

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()				{ return _T("SkeletonSimpleObj"); }
	HINSTANCE		HInstance()					{ return hInstance; }
};

static SkeletonSObjClassDesc SkeletonSOCD;
ClassDesc* GetSimpleObjDesc() {return &SkeletonSOCD;}




/*===========================================================================*\
 |	Basic implimentation of a dialog handler
\*===========================================================================*/

BOOL SkeletonObjDlgProc::DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}


/*===========================================================================*\
 |	Paramblock2 Descriptor
\*===========================================================================*/

static ParamBlockDesc2 skeleton_param_blk ( simpo_params, _T("SkeletonSimpleObjParams"),  0, &SkeletonSOCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_SKELETON_SOBJ, IDS_PARAMETERS, 0, 0, NULL, 
	// params
	simpo_simple_param,	_T("simpoParam1"),	TYPE_FLOAT,	P_ANIMATABLE,	IDS_SIMPLE,
		p_default,		0.0f,
		p_range, 		0.0f, 65535.0f, 
		p_ui,			TYPE_SPINNER, EDITTYPE_UNIVERSE, IDC_SIMPLE_EDIT, IDC_SIMPLE_SPIN, 0.1f,
		end,
	simpo_genuv,	 	_T("GenUV"), 	TYPE_BOOL, 		0,		IDS_MAPPING,
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_MAPPING, 
		end, 
	end
	);




/*===========================================================================*\
 |	Constructor
 |  Ask the ClassDesc2 to make the AUTO_CONSTRUCT paramblocks and wire them in
\*===========================================================================*/

SkeletonSimpObj::SkeletonSimpObj()
	{
	SkeletonSOCD.MakeAutoParamBlocks(this);
	assert(pblock2);
	}



/*===========================================================================*\
 |	Invalidate our UI (or the recently changed parameter)
\*===========================================================================*/

void SkeletonSimpObj::InvalidateUI()
{
	skeleton_param_blk.InvalidateUI(pblock2->LastNotifyParamID());
}



/*===========================================================================*\
 |	Open and Close dialog UIs
 |	We ask the ClassDesc2 to handle Beginning and Ending EditParams for us
\*===========================================================================*/

void SkeletonSimpObj::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	this->ip = ip;

	SimpleObject::BeginEditParams(ip,flags,prev);
	SkeletonSOCD.BeginEditParams(ip, this, flags, prev);

	skeleton_param_blk.SetUserDlgProc(new SkeletonObjDlgProc(this));

	}
		
void SkeletonSimpObj::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleObject::EndEditParams(ip,flags,next);
	SkeletonSOCD.EndEditParams(ip, this, flags, next);

	this->ip = NULL;
	}




/*===========================================================================*\
 |	Standard Load and clone
\*===========================================================================*/

IOResult SkeletonSimpObj::Load(ILoad *iload)
	{
	Object::Load(iload);
	return IO_OK;
	}

RefTargetHandle SkeletonSimpObj::Clone(RemapDir& remap) 
{
	SkeletonSimpObj* newob = new SkeletonSimpObj();	
	newob->ReplaceReference(0, pblock2->Clone(remap));
	newob->ivalid.SetEmpty();	
	return(newob);
}



/*===========================================================================*\
 |	Standard object implimentations
\*===========================================================================*/

BOOL SkeletonSimpObj::OKtoDisplay(TimeValue t) 
{
		float size;
		pblock2->GetValue(simpo_simple_param, t, size, FOREVER);
		if (size==0.0f) return FALSE;
		else return TRUE;
}


int SkeletonSimpObj::IntersectRay(
		TimeValue t, Ray& ray, float& at, Point3& norm)
{
	// pass to SimpleObject to do this
	return SimpleObject::IntersectRay(t, ray, at, norm);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleObject\SimpleObj.h ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Simple Object
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 8-3-99
 | 
\*===========================================================================*/


#ifndef __SMPOBJSKEL__H
#define __SMPOBJSKEL__H

#include "max.h"
#include "simpobj.h"
#include "iparamm2.h"
#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	SIMPO_CLASSID		Class_ID(0x4fa6059, 0x288649d1)


TCHAR *GetString(int id);
extern ClassDesc* GetSimpleObjDesc();


// Paramblock2 name
enum { simpo_params, }; 
// Paramblock2 parameter list
enum { simpo_simple_param, simpo_genuv, };



/*===========================================================================*\
 |	SkeletonSimpObj class defn
\*===========================================================================*/

class SkeletonSimpObj : public SimpleObject2
{
	public:	
		static IObjParam *ip;

		SkeletonSimpObj();
		
		// Plugin identification
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return SIMPO_CLASSID; } 
		TCHAR *GetObjectName() { return GetString(IDS_CLASSNAME); }
		
		// Open/Close our UI
		void BeginEditParams( IObjParam  *ip, ULONG flags, Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags, Animatable *next);

		// Automatic UVW Generation
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
		
		// Conversion to other objects?
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		void GetCollapseTypes(Tab<Class_ID> &clist, Tab<TSTR*> &nlist);

		// From GeomObject
		int IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm);
		
		// Direct paramblock access
		int	NumParamBlocks() { return 1; }
		IParamBlock2* GetParamBlock(int i) { return pblock2; }
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock2->ID() == id) ? pblock2 : NULL; }

		IOResult Load(ILoad *iload);
		
		// Create the object itself
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		CreateMouseCallBack* GetCreateMouseCallBack();


		void InvalidateUI();
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
};

class SkeletonObjCreateCallBack : public CreateMouseCallBack {
	SkeletonSimpObj *sso;
	IPoint2 sp0;
	Point3 p0;

	public:
	
	int proc( ViewExp *vpt, int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	void SetObj(SkeletonSimpObj *obj) {sso = obj;}
};


/*===========================================================================*\
 |	Dialog Processor
\*===========================================================================*/

class SkeletonObjDlgProc : public ParamMap2UserDlgProc 
{
	public:
		SkeletonSimpObj *sso;

		SkeletonObjDlgProc() {}
		SkeletonObjDlgProc(SkeletonSimpObj *sso_in) { sso = sso_in; }

		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { }

		void SetThing(ReferenceTarget *m) {
			sso = (SkeletonSimpObj*)m;
			}

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleWSM\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SimpleWSM.rc
//
#define IDS_CLASSNAME                   1
#define IDS_BINDING                     2
#define IDS_LIBDESC                     4
#define IDS_SIMPLE                      5
#define IDS_SIMPLEOBJ                   6
#define IDS_RADIUS                      7
#define IDS_PARAMETERS                  8
#define IDD_SKELETON_SWSM               101
#define IDD_SKELETON_SWSMOBJ            102
#define IDC_SIMPLEOBJ_EDIT              1000
#define IDC_SIMPLEOBJ_SPIN              1001
#define IDC_RADIUS_EDIT                 1002
#define IDC_RADIUS_SPIN                 1003
#define IDC_SIMPLE_EDIT                 1004
#define IDC_SIMPLE_SPIN                 1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleWSM\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Simple WSM modifier
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 17-3-99
 | 
\*===========================================================================*/

#include "SimpleWSM.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 2;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonSimpleWSMDesc();
		case 1: return GetSkeletonWSMObjectDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleWSM\SimpleDeform.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Simple WSM modifier
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 17-3-99
 | 
\*===========================================================================*/

#include "SimpleWSM.h"



Point3 SkeletonWSMDeformer::Map(int i, Point3 p)
	{
	Point3 pt = p * tm;

		pt.x += (sparam_obj * sparam_wsm);
		pt.y += (sparam_obj * sparam_wsm);
		pt.z += (sparam_obj * sparam_wsm);

	return pt * itm;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleWSM\SimpleMesh.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Simple WSM modifier
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 17-3-99
 | 
\*===========================================================================*/

#include "SimpleWSM.h"




/*===========================================================================*\
 |	Mouse creation - mearly measure a length between two points
 |  and pass it into our pblock2
\*===========================================================================*/

int SkeletonWSMObjCreateCallBack::proc(ViewExp *vpt, int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;
	Point3 p1, center;

	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m, m, NULL, SNAP_IN_3D);
	}


	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {

		case 0:
			sp0 = m;
			p0 = vpt->SnapPoint(m, m, NULL, SNAP_IN_3D);
			mat.SetTrans(p0);
			break;


		case 1:
			mat.IdentityMatrix();
			
			p1 = vpt->SnapPoint(m, m, NULL, SNAP_IN_3D);
			r = Length(p1-p0);
			mat.SetTrans(p0);

			swo->pblock2->SetValue(simpwsmobj_radius_param, 0, r);

			if (msg==MOUSE_POINT) {
				return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
			}
			break;					   
		}
	} else {
		if (msg == MOUSE_ABORT) return CREATE_ABORT;
	}

	return TRUE;
}

static SkeletonWSMObjCreateCallBack WSMCreateCB;

CreateMouseCallBack* SkeletonWSMObject::GetCreateMouseCallBack() 
{
	WSMCreateCB.SetObj(this);
	return(&WSMCreateCB);
}




/*===========================================================================*\
 |	Mesh creation - create the actual object
\*===========================================================================*/

void SkeletonWSMObject::BuildMesh(TimeValue t)
{
	float sz; 
	ivalid = FOREVER;	
	pblock2->GetValue(simpwsmobj_radius_param,t,sz,ivalid);

	mesh.setNumVerts(4);
	mesh.setNumFaces(2);
	mesh.InvalidateTopologyCache();


	mesh.setVert(0, Point3((float)sz,(float)sz,0.0f));
	mesh.setVert(1, Point3((float)-sz,(float)sz,0.0f));
	mesh.setVert(2, Point3((float)sz,(float)-sz,0.0f));
	mesh.setVert(3, Point3((float)-sz,(float)-sz,0.0f));


	mesh.faces[0].setVerts(0,1,2);
	mesh.faces[0].setEdgeVisFlags(1,0,1);
	mesh.faces[1].setVerts(1,3,2);
	mesh.faces[1].setEdgeVisFlags(1,1,0);

	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleWSM\SimpleWSM.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Simple WSM modifier
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 17-3-99
 | 
\*===========================================================================*/

#include "SimpleWSM.h"


IObjParam* SkeletonWSMMod::ip = NULL;


/*===========================================================================*\
 |	Class Descriptor OSM
\*===========================================================================*/

class SkeletonWSMClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()							{ return FALSE; }
	void *			Create(BOOL loading = FALSE)		{ return new SkeletonWSMMod; }
	const TCHAR *	ClassName()							{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()						{ return WSM_CLASS_ID; }
	Class_ID		ClassID()							{ return WSMMOD_CLASSID; }
	const TCHAR* 	Category()							{ return _T("");}

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()						{ return _T("SkeletonSimpleWSM"); }
	HINSTANCE		HInstance()							{ return hInstance; }
};

static SkeletonWSMClassDesc SkeletonWSMCD;
ClassDesc* GetSkeletonSimpleWSMDesc() { return &SkeletonWSMCD; }



/*===========================================================================*\
 |	Basic implimentation of a dialog handler
\*===========================================================================*/

BOOL SkeletonWSMModDlgProc::DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}


/*===========================================================================*\
 |	Paramblock2 Descriptor
\*===========================================================================*/

static ParamBlockDesc2 skeleton_param_blk ( simpwsm_params, _T("SkeletonSimpleWSMParams"),  0, &SkeletonWSMCD, P_AUTO_CONSTRUCT + P_AUTO_UI, SIMPWSMMOD_PBLOCKREF, 
	//rollout
	IDD_SKELETON_SWSM, IDS_PARAMETERS, 0, 0, NULL, 
	// params
	simpwsm_simple_param,	_T("simpwsm_simple_param"),	TYPE_FLOAT,	P_ANIMATABLE,	IDS_SIMPLE,
		p_default,		1.0f,
		p_range, 		-10.0f, 10.0f, 
		p_ui,			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SIMPLE_EDIT, IDC_SIMPLE_SPIN, 0.1f,
		end,
	end
	);




/*===========================================================================*\
 |	Constructor
 |  Ask the ClassDesc2 to make the AUTO_CONSTRUCT paramblocks and wire them in
\*===========================================================================*/

SkeletonWSMMod::SkeletonWSMMod(INode *node,SkeletonWSMObject *obj)
{	
	SkeletonWSMCD.MakeAutoParamBlocks(this);
	assert(pblock2);

	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);
	
	obRef = NULL;
}


/*===========================================================================*\
 |	Open and Close dialog UIs
 |	We ask the ClassDesc2 to handle Beginning and Ending EditParams for us
\*===========================================================================*/

void SkeletonWSMMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
{
	this->ip = ip;

	SimpleWSMMod::BeginEditParams(ip,flags,prev);
	SkeletonWSMCD.BeginEditParams(ip, this, flags, prev);

	skeleton_param_blk.SetUserDlgProc(new SkeletonWSMModDlgProc(this));
}
		
void SkeletonWSMMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
{
	SimpleWSMMod::EndEditParams(ip,flags,next);
	SkeletonWSMCD.EndEditParams(ip, this, flags, next);

	this->ip = NULL;	
}



/*===========================================================================*\
 |	Invalidate our UI (or the recently changed parameter)
\*===========================================================================*/

void SkeletonWSMMod::InvalidateUI()
{
	skeleton_param_blk.InvalidateUI(pblock2->LastNotifyParamID());
}



/*===========================================================================*\
 |	Standard Load and clone
\*===========================================================================*/

IOResult SkeletonWSMMod::Load(ILoad *iload)
{
	Modifier::Load(iload);
	return IO_OK;
}

RefTargetHandle SkeletonWSMMod::Clone(RemapDir& remap) 
{
	SkeletonWSMMod *newob = new SkeletonWSMMod(nodeRef,(SkeletonWSMObject*)obRef);
	newob->ReplaceReference(SIMPWSMMOD_PBLOCKREF,pblock2->Clone(remap));
	newob->ReplaceReference(SIMPWSMMOD_OBREF,this->obRef);
	newob->ReplaceReference(SIMPWSMMOD_NODEREF,this->nodeRef);
	return newob;
}



/*===========================================================================*\
 |	The validity of our parameters
 |	Start at FOREVER, and intersect with the validity of each item
\*===========================================================================*/

Interval SkeletonWSMMod::GetValidity(TimeValue t) 
{
	if (nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;

		SkeletonWSMObject *obj = (SkeletonWSMObject*)GetWSMObject(t);
		pblock2->GetValue(simpwsm_simple_param, t, f, valid);
		obj->pblock2->GetValue(simpwsmobj_simple_param, t, f, valid);

		tm = nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {
		return FOREVER;
		}
}




/*===========================================================================*\
 |	Get the actual deformer to modify the object
\*===========================================================================*/

Deformer& SkeletonWSMMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
{
	Interval valid;
	static SkeletonWSMDeformer wsmd;

	pblock2->GetValue(simpwsm_simple_param, t, wsmd.sparam_wsm, valid);

	SkeletonWSMObject *obj = (SkeletonWSMObject*)GetWSMObject(t);
	obj->pblock2->GetValue(simpwsmobj_simple_param, t, wsmd.sparam_obj, valid);

	wsmd.time = t;
	wsmd.itm  = nodeRef->GetObjectTM(t,&valid);
	wsmd.tm   = Inverse( wsmd.itm );
	return wsmd;
}



/*===========================================================================*\
 |	SimpleWSMMod2 overloads
\*===========================================================================*/

RefTargetHandle SimpleWSMMod2::GetReference(int i) 
{ 
	switch (i) {
		case SIMPWSMMOD_OBREF: return obRef;
		case SIMPWSMMOD_NODEREF: return nodeRef;
		case SIMPWSMMOD_PBLOCKREF: return pblock;
		default: return NULL;
		}
}

void SimpleWSMMod2::SetReference(int i, RefTargetHandle rtarg) 
{ 
	switch (i) {
		case SIMPWSMMOD_OBREF: obRef = (WSMObject*)rtarg; break;
		case SIMPWSMMOD_NODEREF: nodeRef = (INode*)rtarg; break;
		case SIMPWSMMOD_PBLOCKREF: pblock2 = (IParamBlock2*)rtarg; SimpleWSMMod::SetReference(i, rtarg);break;
		}
}

Animatable* SimpleWSMMod2::SubAnim(int i) 
{ 
	switch (i) {
		case 0: return pblock2;		
		default: return NULL;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Texmap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Texmap.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_SIMPLE                      3
#define IDS_LIBDESC                     4
#define IDS_MAP1                        5
#define IDS_MAP1ON                      6
#define IDC_SIMPLE_EDIT                 1032
#define IDD_SKELETON_TEXMAP             1043
#define IDC_SIMPLE_SPIN                 1052
#define IDC_MAP1                        1061
#define IDC_MAPON1                      1640

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleWSM\WSMObject.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Simple WSM modifier
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 17-3-99
 | 
\*===========================================================================*/

#include "SimpleWSM.h"



/*===========================================================================*\
 |	Class Descriptor OSM
\*===========================================================================*/

class SkeletonWSMObjClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()							{ return TRUE; }
	void *			Create(BOOL loading = FALSE)		{ return new SkeletonWSMObject; }
	const TCHAR *	ClassName()							{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()						{ return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID()							{ return WSMOBJ_CLASSID; }
	const TCHAR* 	Category()							{ return _T("");}

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()						{ return _T("SkeletonSimpleWSMObject"); }
	HINSTANCE		HInstance()							{ return hInstance; }
};

static SkeletonWSMObjClassDesc SkeletonWSMObjCD;
ClassDesc* GetSkeletonWSMObjectDesc() { return &SkeletonWSMObjCD; }



/*===========================================================================*\
 |	Basic implimentation of a dialog handler
\*===========================================================================*/

BOOL SkeletonWSMObjDlgProc::DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}


/*===========================================================================*\
 |	Paramblock2 Descriptor
\*===========================================================================*/

static ParamBlockDesc2 skeletonobj_param_blk ( simpwsmobj_params, _T("SkeletonSimpleWSMObjParams"),  0, &SkeletonWSMObjCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_SKELETON_SWSMOBJ, IDS_PARAMETERS, 0, 0, NULL, 
	// params
	simpwsmobj_simple_param,	_T("simpwsmobj_simple_param"),	TYPE_FLOAT,	P_ANIMATABLE,	IDS_SIMPLEOBJ,
		p_default,		0.0f,
		p_range, 		0.0f, 10.0f, 
		p_ui,			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SIMPLEOBJ_EDIT, IDC_SIMPLEOBJ_SPIN, 0.1f,
		end,
	simpwsmobj_radius_param,	_T("simpwsmobj_radius_param"),	TYPE_FLOAT,	P_ANIMATABLE,	IDS_RADIUS,
		p_default,		0.0f,
		p_range, 		0.0f, 65535.0f, 
		p_ui,			TYPE_SPINNER, EDITTYPE_UNIVERSE, IDC_RADIUS_EDIT, IDC_RADIUS_SPIN, 0.1f,
		end,
	end
	);


/*===========================================================================*\
 |	Constructor
 |  Ask the ClassDesc2 to make the AUTO_CONSTRUCT paramblocks and wire them in
\*===========================================================================*/

SkeletonWSMObject::SkeletonWSMObject()
	{
	SkeletonWSMObjCD.MakeAutoParamBlocks(this);
	assert(pblock2);
	}



/*===========================================================================*\
 |	Invalidate our UI (or the recently changed parameter)
\*===========================================================================*/

void SkeletonWSMObject::InvalidateUI()
{
	skeletonobj_param_blk.InvalidateUI(pblock2->LastNotifyParamID());
}




/*===========================================================================*\
 |	Open and Close dialog UIs
 |	We ask the ClassDesc2 to handle Beginning and Ending EditParams for us
\*===========================================================================*/

void SkeletonWSMObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	this->ip = ip;

	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	SkeletonWSMObjCD.BeginEditParams(ip, this, flags, prev);

	skeletonobj_param_blk.SetUserDlgProc(new SkeletonWSMObjDlgProc(this));

	}
		
void SkeletonWSMObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleWSMObject::EndEditParams(ip,flags,next);
	SkeletonWSMObjCD.EndEditParams(ip, this, flags, next);

	this->ip = NULL;
	}




/*===========================================================================*\
 |	Standard Load and clone
\*===========================================================================*/

IOResult SkeletonWSMObject::Load(ILoad *iload)
	{
	SimpleWSMObject::Load(iload);
	return IO_OK;
	}

RefTargetHandle SkeletonWSMObject::Clone(RemapDir& remap) {	
	SkeletonWSMObject* newob = new SkeletonWSMObject();	
	newob->ReplaceReference(0,pblock2->Clone(remap));
	return(newob);
	}



/*===========================================================================*\
 |	Create the WSM modifier
\*===========================================================================*/

Modifier *SkeletonWSMObject::CreateWSMMod(INode *node)
	{
	return new SkeletonWSMMod(node,this);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\SimpleWSM\SimpleWSM.h ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Simple WSM modifier
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 17-3-99
 | 
\*===========================================================================*/

#ifndef __WSMSKEL__H
#define __WSMSKEL__H

#include "max.h"
#include "simpmod.h"
#include "simpobj.h"
#include "iparamm2.h"
#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	WSMMOD_CLASSID		Class_ID(0x38d202c, 0xda726e0)
#define	WSMOBJ_CLASSID		Class_ID(0x67924340, 0x57870f5)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonSimpleWSMDesc();
extern ClassDesc* GetSkeletonWSMObjectDesc();


// WSM Object Paramblock2 Support
// Paramblock2 name
enum { simpwsmobj_params, }; 
// Paramblock2 parameter list
enum { simpwsmobj_simple_param, simpwsmobj_radius_param, };

// WSM Modifier Paramblock2 Support
// Paramblock2 name
enum { simpwsm_params, }; 
// Paramblock2 parameter list
enum { simpwsm_simple_param, };



/*===========================================================================*\
 |	SimpleWSMObject2 and SkeletonWSMObject class defn
\*===========================================================================*/

class SimpleWSMObject2 : public SimpleWSMObject 
{
	public:
		IParamBlock2* pblock2;
		// From ref
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) { pblock2 = (IParamBlock2*)rtarg; SimpleWSMObject::SetReference(i, rtarg);}		
};

class SkeletonWSMObject : public SimpleWSMObject2
{	
	public:		
		IObjParam *ip;
		HWND hSot;
					
		SkeletonWSMObject();		

		void DeleteThis() {delete this;}		
		Class_ID ClassID() {return WSMOBJ_CLASSID;}		
		TCHAR *GetObjectName() {return GetString(IDS_CLASSNAME);}		

		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		
		void InvalidateUI();

		int DoOwnSelectHilite() {return TRUE;}
		CreateMouseCallBack* GetCreateMouseCallBack();

		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		IOResult Load(ILoad *iload);

		Modifier *CreateWSMMod(INode *node);
		void BuildMesh(TimeValue t);
		
		// Direct paramblock access
		int	NumParamBlocks() { return 1; }
		IParamBlock2* GetParamBlock(int i) { return pblock2; }
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock2->ID() == id) ? pblock2 : NULL; }
};

class SkeletonWSMObjCreateCallBack : public CreateMouseCallBack 
{
	SkeletonWSMObject *swo;
	IPoint2 sp0;
	Point3 p0;

	public:
	
	int proc( ViewExp *vpt, int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	void SetObj(SkeletonWSMObject *obj) {swo = obj;}
};


/*===========================================================================*\
 |	Dialog Processor (WSM Object)
\*===========================================================================*/

class SkeletonWSMObjDlgProc : public ParamMap2UserDlgProc 
{
	public:
		SkeletonWSMObject *swo;

		SkeletonWSMObjDlgProc() {}
		SkeletonWSMObjDlgProc(SkeletonWSMObject *swo_in) { swo = swo_in; }

		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { }

		void SetThing(ReferenceTarget *m) {
			swo = (SkeletonWSMObject*)m;
			}

};



/*===========================================================================*\
 |	SkeletonWSMMod class defn
\*===========================================================================*/

class SimpleWSMMod2 : public SimpleWSMMod 
{
	public:
		IParamBlock2* pblock2;

		// From ref
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);		
		Animatable* SubAnim(int i);
};

class SkeletonWSMMod : public SimpleWSMMod2 
{
	public:		

		static IObjParam *ip;

		SkeletonWSMMod() {}
		SkeletonWSMMod(INode *node,SkeletonWSMObject *obj);		

		SClass_ID SuperClassID() { return WSM_CLASS_ID; }
		Class_ID ClassID() { return WSMMOD_CLASSID; } 
		TCHAR *GetObjectName() {return GetString(IDS_BINDING);}
		void GetClassName(TSTR& s) { s= GetString(IDS_CLASSNAME); }
		void DeleteThis() {delete this;}
		
		IOResult Load(ILoad *iload);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());

		void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);

		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		

		Interval GetValidity(TimeValue t);
		void InvalidateUI();

		// Direct paramblock access
		int	NumParamBlocks() { return 1; }
		IParamBlock2* GetParamBlock(int i) { return pblock2; }
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock2->ID() == id) ? pblock2 : NULL; }
};



/*===========================================================================*\
 |	Dialog Processor (WSM Modifier)
\*===========================================================================*/

class SkeletonWSMModDlgProc : public ParamMap2UserDlgProc 
{
	public:
		SkeletonWSMMod *swmo;

		SkeletonWSMModDlgProc() {}
		SkeletonWSMModDlgProc(SkeletonWSMMod *swmo_in) { swmo = swmo_in; }

		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { }

		void SetThing(ReferenceTarget *m) {
			swmo = (SkeletonWSMMod*)m;
			}

};



/*===========================================================================*\
 |	SkeletonWSMDeformer class defn
 |  This is the system that gets applied to each deformable point
 |
 |  Implimented in simpleDeform.cpp
\*===========================================================================*/

class SkeletonWSMDeformer: public Deformer 
{
	public:
		Matrix3 tm,itm;
		TimeValue time;
		float sparam_wsm; 
		float sparam_obj;
		
		SkeletonWSMDeformer() {}

		Point3 Map(int i, Point3 p); 
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Texmap\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Texture Map
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 11-3-99
 | 
\*===========================================================================*/

#include "Texmap.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonTexmapDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Texmap\TexShade.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	TexShade.cpp
 |			Skeleton project and code for a Texture Map
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 11-3-99
 | 
\*===========================================================================*/

#include "Texmap.h"


static AColor white(1.0f,1.0f,1.0f,1.0f);


/*===========================================================================*\
 |	Actual shading takes place
\*===========================================================================*/


AColor SkeletonTexmap::EvalColor(ShadeContext& sc) 
{
	if (gbufID) sc.SetGBufferID(gbufID);
	AColor c0 = subTex[0]&&mapOn[0]? subTex[0]->EvalColor(sc): white;

	return c0*=simple;
}

float SkeletonTexmap::EvalMono(ShadeContext& sc) 
{
	if (gbufID) sc.SetGBufferID(gbufID);
	float c0 = subTex[0]&&mapOn[0]? subTex[0]->EvalMono(sc): 1.0f;

	return c0*=simple;
}

Point3 SkeletonTexmap::EvalNormalPerturb(ShadeContext& sc) 
{
	if (gbufID) sc.SetGBufferID(gbufID);
	Point3 p0  = subTex[0]&&mapOn[0]? subTex[0]->EvalNormalPerturb(sc): Point3(0.0f,0.0f,0.0f);

	return p0*=simple;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Texmap\Texmap.h ===
/*===========================================================================*\
 | 
 |  FILE:	Texmap.h
 |			Skeleton project and code for a Texture Map
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 11-3-99
 | 
\*===========================================================================*/

#ifndef __TEXSKEL__H
#define __TEXSKEL__H

#include "max.h"
#include "imtl.h"
#include "texutil.h"
#include "iparamm2.h"
#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	TEX_CLASSID		Class_ID(0x7dd18ef, 0x400e305f)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonTexmapDesc();


// Paramblock2 name
enum { tex_params, }; 
// Paramblock2 parameter list
enum { tex_simple_param, tex_map1, tex_map1_on };


// How many subtex's we support
#define NSUBTEX		1


/*===========================================================================*\
 |	SkeletonTexmap class defn
\*===========================================================================*/

class SkeletonTexmap: public Texmap 
{ 
	public:
		Interval ivalid;
		Texmap* subTex[NSUBTEX];

		// various variables
		float simple;
		BOOL mapOn[NSUBTEX];


		SkeletonTexmap();

		// Parameter and UI management
		IParamBlock2 *pblock;
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		void NotifyChanged();

		// Evaluate the color of map for the context.
		AColor EvalColor(ShadeContext& sc);
		float EvalMono(ShadeContext& sc);
		AColor EvalFunction(ShadeContext& sc, float u, float v, float du, float dv);

		// For Bump mapping, need a perturbation to apply to a normal.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// Methods to access texture maps of material
		int NumSubTexmaps() { return NSUBTEX; }
		Texmap* GetSubTexmap(int i) { return subTex[i]; }
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		Class_ID ClassID() {	return TEX_CLASSID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_CLASSNAME); }  
		void DeleteThis() { delete this; }	

		int NumSubs() { return NSUBTEX+1; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return NSUBTEX+1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		int	NumParamBlocks() { return 1; }				
		IParamBlock2* GetParamBlock(int i) { return pblock; }
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } 
};


/*===========================================================================*\
 |	Dialog Processor
\*===========================================================================*/

class SkelTexDlgProc : public ParamMap2UserDlgProc 
{
	public:
		IParamMap *pmap;
		SkeletonTexmap *st;

		SkelTexDlgProc(SkeletonTexmap *m) {st = m;}		
		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { }
		void SetThing(ReferenceTarget *m) {
			st = (SkeletonTexmap*)m;
			}
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Utility\Plugin.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Plugin.cpp
 |			Skeleton project and code for a Utility
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 9-2-99
 | 
\*===========================================================================*/

#include "Utility.h"



HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}



__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() 
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetSkeletonUtilDesc();
		default: return 0;
	}
}


__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }



TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Texmap\Texmap.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Texmap.cpp
 |			Skeleton project and code for a Texture Map
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 11-3-99
 | 
\*===========================================================================*/

#include "Texmap.h"



/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonTexmapClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create( BOOL loading )		{ return new SkeletonTexmap; }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID()					{ return TEX_CLASSID; }
	const TCHAR* 	Category()					{ return _T("");  }

	// Hardwired name, used by MAX Script as unique identifier
	const TCHAR*	InternalName()				{ return _T("SkeletonTexmap"); }
	HINSTANCE		HInstance()					{ return hInstance; }
};

static SkeletonTexmapClassDesc SkelTexmapCD;
ClassDesc* GetSkeletonTexmapDesc() {return &SkelTexmapCD;}



/*===========================================================================*\
 |	Basic implimentation of a dialog handler
\*===========================================================================*/

BOOL SkelTexDlgProc::DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}



/*===========================================================================*\
 |	Paramblock2 Descriptor
\*===========================================================================*/

static ParamBlockDesc2 stex_param_blk ( tex_params, _T("SkeletonTexmap parameters"),  0, &SkelTexmapCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 1, 
	//rollout
	IDD_SKELETON_TEXMAP, IDS_PARAMETERS, 0, 0, NULL, 
	// params
	tex_map1,			_T("tex_map1"),			TYPE_TEXMAP,	P_OWNERS_REF,	IDS_MAP1,
		p_refno,		0,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_MAP1,
		end,
	tex_map1_on,		_T("tex_map1_on"),		TYPE_BOOL,		0,				IDS_MAP1ON,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	tex_simple_param,	_T("tex_simple_param"),	TYPE_FLOAT,		P_ANIMATABLE,	IDS_SIMPLE,
		p_default,		1.0f,
		p_range,		0.0f, 1.0f,
		p_ui,			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SIMPLE_EDIT, IDC_SIMPLE_SPIN, 0.1f,
		end,

	end
	);



/*===========================================================================*\
 |	Constructor and Reset systems
 |  Ask the ClassDesc2 to make the AUTO_CONSTRUCT paramblocks and wire them in
\*===========================================================================*/

void SkeletonTexmap::Reset() 
{
	ivalid.SetEmpty();
	for (int i=0; i<NSUBTEX; i++) {
		DeleteReference(i);
		mapOn[i] = 1;
		}

	SkelTexmapCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
}

SkeletonTexmap::SkeletonTexmap() 
{
	for (int i=0; i<NSUBTEX; i++) subTex[i] = NULL;
	pblock = NULL;
	Reset();
}

ParamDlg* SkeletonTexmap::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) 
{
	IAutoMParamDlg* masterDlg = SkelTexmapCD.CreateParamDlgs(hwMtlEdit, imp, this);
	stex_param_blk.SetUserDlgProc(new SkelTexDlgProc(this));

	return masterDlg;
}



/*===========================================================================*\
 |	Subanim & References support
\*===========================================================================*/

RefTargetHandle SkeletonTexmap::GetReference(int i) 
{
	if (i <NSUBTEX )
		return subTex[i];
	else return pblock;
}

void SkeletonTexmap::SetReference(int i, RefTargetHandle rtarg) 
{
	if (i < NSUBTEX)
		subTex[i] = (Texmap *)rtarg; 
	else pblock = (IParamBlock2 *)rtarg; 
}

TSTR SkeletonTexmap::SubAnimName(int i) 
{
	if (i< NSUBTEX)
		return GetSubTexmapTVName(i);
	else return TSTR(_T(""));
}

Animatable* SkeletonTexmap::SubAnim(int i) {
	if (i < NSUBTEX)
		return subTex[i]; 
	else return pblock;
	}

RefResult SkeletonTexmap::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) 
{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
				ParamID changing_param = pblock->LastNotifyParamID();
				stex_param_blk.InvalidateUI(changing_param);
				}
			break;

		}
	return(REF_SUCCEED);
}



/*===========================================================================*\
 |	Texmap get and set
\*===========================================================================*/

void SkeletonTexmap::SetSubTexmap(int i, Texmap *m) 
{
	ReplaceReference(i,m);
	if (i==0)
	{
		stex_param_blk.InvalidateUI(tex_map1);
		ivalid.SetEmpty();
	}	
}

TSTR SkeletonTexmap::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return TSTR(GetString(IDS_MAP1)); 
		default: return TSTR(_T(""));
		}
	}
	 

/*===========================================================================*\
 |	Standard IO
\*===========================================================================*/

#define MTL_HDR_CHUNK 0x4000

IOResult SkeletonTexmap::Save(ISave *isave) { 
	IOResult res;
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	return IO_OK;
	}	

IOResult SkeletonTexmap::Load(ILoad *iload) { 
	IOResult res;
	int id;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}


	return IO_OK;
	}





/*===========================================================================*\
 |	Updating and cloning
\*===========================================================================*/


RefTargetHandle SkeletonTexmap::Clone(RemapDir &remap) {
	SkeletonTexmap *mnew = new SkeletonTexmap();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(NSUBTEX,remap.CloneRef(pblock));

	mnew->ivalid.SetEmpty();	
	for (int i = 0; i<NSUBTEX; i++) {
		mnew->subTex[i] = NULL;
		if (subTex[i])
			mnew->ReplaceReference(i,remap.CloneRef(subTex[i]));
		mnew->mapOn[i] = mapOn[i];
		}
	return (RefTargetHandle)mnew;
	}

void SkeletonTexmap::NotifyChanged() 
{
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

void SkeletonTexmap::Update(TimeValue t, Interval& valid) 
{		
	if (!ivalid.InInterval(t)) {

		ivalid.SetInfinite();
		pblock->GetValue( tex_map1_on, t, mapOn[0], ivalid);
		pblock->GetValue( tex_simple_param, t, simple, ivalid);

		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}
		}
	valid &= ivalid;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Utility\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Utility.rc
//
#define IDS_CLASSNAME                   1
#define IDS_PARAMETERS                  2
#define IDS_LIBDESC                     4
#define IDS_CATEGORY                    5
#define IDD_SKELUTIL                    102
#define IDC_BTN1                        1000
#define IDC_CLOSE                       1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Utility\Utility.h ===
/*===========================================================================*\
 | 
 |  FILE:	Utility.h
 |			Skeleton project and code for a Utility
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 9-2-99
 | 
\*===========================================================================*/

#ifndef __RFXUTIL__H
#define __RFXUTIL__H

#include "max.h"
#include "iparamm2.h"
#include "utilapi.h"

#include "resource.h"


// IMPORTANT:
// The ClassID must be changed whenever a new project
// is created using this skeleton
#define	SKUTIL_CLASSID		Class_ID(0x6eb31258, 0x362b6298)


TCHAR *GetString(int id);
extern ClassDesc* GetSkeletonUtilDesc();



/*===========================================================================*\
 |	SkeletonUtility class defn
\*===========================================================================*/

class SkeletonUtility : public UtilityObj {
	public:

		IUtil *iu;
		Interface *ip;

		// Windows handle of our UI
		HWND hPanel;
		
		//Constructor/Destructor
		SkeletonUtility();
		~SkeletonUtility();

		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);
};

static SkeletonUtility theSkeletonUtility;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\RefCheck\RESOURCE.H ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RefCheck.rc
//
#define IDD_MAIN                        102
#define IDC_REFME_LIST                  1000
#define IDC_TVPICK                      1001
#define IDC_MSG_LIST                    1002
#define IDC_CLASSNAME                   1003
#define IDC_CLEAR                       1004
#define IDC_CLIENTNAME                  1005
#define IDC_IREF_LIST                   1006
#define IDC_ITEM_NAME                   1007
#define IDC_IREF_TREE                   1012
#define IDC_PARTID                      1013
#define IDC_FULLTREE                    1014
#define IDC_ADDRESS                     1015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\R3_Skeletons\Utility\Utility.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Utility.cpp
 |			Skeleton project and code for a Utility
 |			3D Studio MAX R3.0
 | 
 |  AUTH:   Harry Denholm
 |			Developer Consulting Group
 |			Copyright(c) Discreet 1999
 |
 |  HIST:	Started 9-2-99
 | 
\*===========================================================================*/

#include "Utility.h"


/*===========================================================================*\
 |	Class Descriptor
\*===========================================================================*/

class SkeletonUtilClassDesc:public ClassDesc {
	public:
	int 			IsPublic()					{ return TRUE; }
	void *			Create( BOOL loading )		{ return &theSkeletonUtility; }
	const TCHAR *	ClassName()					{ return GetString(IDS_CLASSNAME); }
	SClass_ID		SuperClassID()				{ return UTILITY_CLASS_ID; }
	Class_ID 		ClassID()					{ return SKUTIL_CLASSID; }
	const TCHAR* 	Category()					{ return GetString(IDS_CATEGORY);  }
	void ResetClassParams (BOOL fileReset);
};

static SkeletonUtilClassDesc SkeletonUtilCD;
ClassDesc* GetSkeletonUtilDesc() {return &SkeletonUtilCD;}

// Reset all the utility values on File/Reset
void SkeletonUtilClassDesc::ResetClassParams (BOOL fileReset) 
{
}



/*===========================================================================*\
 |	Dialog Handler for Utility
\*===========================================================================*/

static BOOL CALLBACK DefaultDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg) {
		case WM_INITDIALOG:
			theSkeletonUtility.Init(hWnd);
			break;

		case WM_DESTROY:
			theSkeletonUtility.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CLOSE:
					theSkeletonUtility.iu->CloseUtility();
					break;

				case IDC_BTN1:
					MessageBeep(MB_OK);
					break;
			}
			break;


		default:
			return FALSE;
	}
	return TRUE;
}



/*===========================================================================*\
 |  Utility implimentations
\*===========================================================================*/

SkeletonUtility::SkeletonUtility()
{
	iu = NULL;
	ip = NULL;	
	hPanel = NULL;
}

SkeletonUtility::~SkeletonUtility()
{

}


void SkeletonUtility::BeginEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = iu;
	this->ip = ip;

	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_SKELUTIL),
		DefaultDlgProc,
		GetString(IDS_PARAMETERS),
		0);
}
	
void SkeletonUtility::EndEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
}


void SkeletonUtility::Init(HWND hWnd)
{

}

void SkeletonUtility::Destroy(HWND hWnd)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\RefCheck\REFCHECK.CPP ===
/*===========================================================================*\
 |    File: RefCheck.cpp
 |
 | Purpose: To allow the user to select an item and review the items which
 |          reference it, those that it references, and the messages
 |          generated.
 |
 | History: Mark Meier, Began 06/07/97.
 |          MM, 4/98, Incorporated some of the improvements made by StewS.
\*===========================================================================*/
/*===========================================================================*\
 | Include Files
\*===========================================================================*/
#include "MAX.H"
#include "resource.h"
#include "utilapi.h"

/*===========================================================================*\
 | Misc defines, typedefs, enums, etc.
\*===========================================================================*/
#define MY_CLASS_ID Class_ID(0x7a0d3c9b, 0x4e841ffd)
#define MY_CLASSNAME _T("Reference Watcher")
#define MY_CATEGORY _T("How To")
#define MY_LIBDESCRIPTION _T("Reference Watcher by Mark Meier")
#define IP GetCOREInterface()

HINSTANCE hInstance;
void FormatObjectDisplay(int i, ReferenceMaker* rm, bool showaddress, TSTR& buf);
/*===========================================================================*\
 | Class RefWatch
\*===========================================================================*/
class RefWatch : public UtilityObj {
	public:
		HWND hMain;
		// This is the reference target we are investigating
		ReferenceTarget *watchMe;

		// --- Inherited Virtual Methods From UtilityObj ---
		void BeginEditParams(Interface *ip, IUtil *iu);
		void EndEditParams(Interface *ip, IUtil *iu) {}
		void DeleteThis() {}

		// --- Methods From RefWatch ---
		RefWatch() {hMain = NULL; watchMe = NULL;}
		TCHAR *GetName();
};
// This is the static instance of the Utility plug-in.
static RefWatch refWatch;

/*===========================================================================*\
 | Class RefCheckDepEnumProc
\*===========================================================================*/
class RefCheckDepEnumProc : public DependentEnumProc {
	HWND hWnd;
	ReferenceTarget* rtarg;
	int *count;
	bool showaddress;
public:
	RefCheckDepEnumProc(HWND hW, ReferenceTarget* rt, int *c, bool addr)
		: hWnd(hW), rtarg(rt), count(c), showaddress(addr)
		{}
	int proc(ReferenceMaker *rmaker);
};

RefCheckDepEnumProc::proc(ReferenceMaker *rmaker) {
	if (rmaker != rtarg)
	{
		TSTR buf;
		FormatObjectDisplay(*count, rmaker, showaddress, buf);
		SendMessage(hWnd, LB_ADDSTRING, 0, (LPARAM)buf.data());
		*count += 1;
	}
	return 0;
}

/*===========================================================================*\
 | Class NotifyMgr -- this class was developed by Christer Janson.
\*===========================================================================*/
class NotifyMgr : public ReferenceTarget {
	private:
		int nNumRefs;
		RefResult (*pNotifyFunc)(Interval changeInt,
			RefTargetHandle hTarget, PartID& partID,
				RefMessage message, DWORD pData);
		RefTargetHandle ref0;
		DWORD pPrivateData;
	public:
		// --- Inherited Virtual Methods From Animatable ---
		void GetClassName(TSTR &s) { s = _T("(This Reference Watcher)"); }

		// --- Inherited Virtual Methods From ReferenceMaker ---
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget,
			PartID& partID,RefMessage message);
		int NumRefs();
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		// --- Methods From NotifyMgr ---
		NotifyMgr::NotifyMgr();
		NotifyMgr::~NotifyMgr();
		BOOL CreateReference(RefTargetHandle hTarget);
		BOOL RemoveReference();

		void SetNotifyFunc(RefResult (*func)(Interval changeInt,
		RefTargetHandle hTarget, PartID& partID,RefMessage message, 
			DWORD pData), DWORD pData);
		void ResetNotifyFunc();
};
NotifyMgr notifyObject;

// Constructor
NotifyMgr::NotifyMgr() {
	nNumRefs = 1;
	pNotifyFunc = NULL;
	ref0 = NULL;
}

// Destructor. Remove any references we have made.
NotifyMgr::~NotifyMgr() {
	DeleteAllRefsFromMe();
}

// Notification function.
// When we get a callback we check to see if we have a registered notify
// function. If we do, we forward the notification to the notify function,
RefResult NotifyMgr::NotifyRefChanged(Interval changeInt,
	RefTargetHandle hTarget, PartID& partID,RefMessage message) {
	RefResult res = REF_SUCCEED;

	if (pNotifyFunc) {
		res = pNotifyFunc(changeInt, hTarget, partID, message, pPrivateData);
	}
	return res;
}

// Number of references we have made. Currently we allow one single
// reference only.
int NotifyMgr::NumRefs() {
	return nNumRefs;
}

// Return the n'th reference
RefTargetHandle NotifyMgr::GetReference(int i) {
	switch (i) {
	case 0: return ref0; break;
	default: return NULL; break;
	}

	return NULL;
}

// Set the n'th reference.
void NotifyMgr::SetReference(int i, RefTargetHandle rtarg) {
	switch (i) {
	case 0: ref0 = rtarg; break;
	}
}

// Exported function that let someone make a reference from
// outside of this class.
BOOL NotifyMgr::CreateReference(RefTargetHandle hTarget) {
   	theHold.Begin();
	MakeRefByID(FOREVER, 0, hTarget);
    theHold.Accept(_T("Create Reference"));	 
	return TRUE;
}

// Exported function that let someone remove a reference.
BOOL NotifyMgr::RemoveReference() {
	if (ref0) {
		DeleteReference(0);
		ref0 = NULL;
	}
	return TRUE;
}

// Exported function to set the function that will be used as a
// notification callback.
void NotifyMgr::SetNotifyFunc(RefResult (*func)(Interval changeInt,
	RefTargetHandle hTarget, PartID& partID,RefMessage message, 
		DWORD pData), DWORD pData) {
	pPrivateData = pData;
	pNotifyFunc = func;
}

// Exported function to clear the notification callback.
void NotifyMgr::ResetNotifyFunc() {
	RemoveReference();
	pNotifyFunc = NULL;
}

void DisplayRefInfo(RefWatch *rc, HWND hWnd, Tab<TSTR *> *pMessages);
Tab<TSTR *> *GetRefName(RefMessage message, PartID& partID, BOOL bShowpartIDs = TRUE);

/*===========================================================================*\
 | ProcessRefMessage
\*===========================================================================*/
// This is the heart of the reference tracker.  It gets called by the 
// NotifyMgr when it recieves a message via NotifyRefChanged().  It passes
// all the parameter here (plus the additional pData).
RefResult ProcessRefMessage(Interval changeInt, RefTargetHandle hTarget,
	PartID& partID, RefMessage message, DWORD pData) {

	RefWatch* rc = (RefWatch *)pData;
	if (message == REFMSG_TARGET_DELETED) {
		// The item we monitor has been deleted -- we're done...
		DestroyWindow(rc->hMain);
	}
	else {
		LRESULT checkstate = SendMessage(GetDlgItem(rc->hMain, IDC_PARTID),BM_GETCHECK,0,0);
		DisplayRefInfo(rc, rc->hMain, GetRefName(message, partID, (BST_CHECKED==checkstate)));
	}
	return REF_SUCCEED;
}

/*===========================================================================*\
 | Dialog Procs and related functions
\*===========================================================================*/
void FormatObjectDisplay(int i, ReferenceMaker* rm, bool showaddress, TSTR& buf) {
	TSTR str;
	if (rm) {
		rm->GetClassName(str);
		buf.printf(_T("%d: %s"), i, str.data());
		if (str == TSTR("Animatable")) {
			str = buf;
			buf.printf(_T("%s (0x%08x, 0x%08x)"), str.data(),
				rm->ClassID().PartA(), rm->ClassID().PartB());
		}
		if (showaddress) {
			str = buf;
			buf.printf(_T("%s at 0x%08x"), str.data(), rm);
		}
	}
	else
		buf.printf(_T("%d: NULL"), i);
}

void DisplayRefInfo(RefWatch *rc, HWND hWnd, Tab<TSTR *> *pMessages) {
	TSTR buf, str;
	HWND hIRefList = GetDlgItem(hWnd, IDC_IREF_LIST);
	HWND hRefMeList = GetDlgItem(hWnd, IDC_REFME_LIST);
	bool showaddress = IsDlgButtonChecked(hWnd, IDC_ADDRESS) ? true : false;
	bool fulltree = IsDlgButtonChecked(hWnd, IDC_FULLTREE) ? true : false;

	// Add this message to the ref message list
	for (int i = 0 ; i < pMessages->Count() ; i++) {
		SendMessage(GetDlgItem(hWnd, IDC_MSG_LIST), LB_ADDSTRING, 0, (LPARAM)(*pMessages)[i]->data());
	}

	// Display the references of this item
	SendMessage(hIRefList, LB_RESETCONTENT, 0, 0L);
	int numRefs = rc->watchMe->NumRefs();
	for (i = 0; i < numRefs; i++) {
		ReferenceTarget *rt = rc->watchMe->GetReference(i);
		FormatObjectDisplay(i, rt, showaddress, buf);
		SendMessage(hIRefList, LB_ADDSTRING, 0, (LPARAM)buf.data());
	}

	// Display the items which reference this target
	int count = 0;
	SendMessage(hRefMeList, LB_RESETCONTENT, 0, 0L);
	if (fulltree) {
		// Enumerate all the dependents
		RefCheckDepEnumProc rfep(hRefMeList, rc->watchMe, &count, showaddress);
		rc->watchMe->EnumDependents(&rfep);
	}
	else {
		// We only want first-level dependents.
		RefList& rl = rc->watchMe->GetRefList();
		RefListItem* ptr = rl.first;
		while (ptr) {
			if (ptr->maker != NULL) {
				FormatObjectDisplay(count, ptr->maker, showaddress, buf);
				SendMessage(hRefMeList, LB_ADDSTRING, 0, (LPARAM)buf.data());
			}
			ptr = ptr->next;
			++count;
		}
	}
}

Tab<TSTR *> *GetRefName(RefMessage message,PartID& partID,BOOL bShowpartIDs) {
	static TSTR *pMsgStr, MsgStr;
	static Tab <TSTR *> pMessages;
	pMsgStr = &MsgStr;
	pMessages.ZeroCount();
	switch (message) {
		case 0x00000010:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new TSTR(_T("   REFMSG_LOOPTEST"));
			break;
		case 0x00000020:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR(_T("   REFMSG_TARGET_DELETED"));		
			break;
		case 0x00000021:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR(_T("   REFMSG_MODAPP_DELETING"));		
			break;
		case 0x00000030:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("   REFMSG_EVAL"));			
			break;
		case 0x00000040:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("   REFMSG_RESET_ORIGIN"));
			break;
		case 0x00000050:
			{
				pMessages.SetCount(pMessages.Count() +1);
				pMessages[pMessages.Count() -1] = new  TSTR(_T("REFMSG_CHANGE  "));
				if(bShowpartIDs)
				{
					if(partID&PART_TOPO)	
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new  TSTR(_T("   PART_TOPO"));
					}
					if(partID&PART_GEOM)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new  TSTR(_T("   PART_GEOM"));
					}
					if(partID&PART_TEXMAP)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new TSTR(_T("   PART_TEXMAP"));
					}
					if(partID&PART_MTL)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new  TSTR(_T("   PART_MTL"));
					}
					if(partID&PART_SELECT)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new TSTR(_T("   PART_SELECT"));
					}
					if(partID&PART_SUBSEL_TYPE)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new  TSTR(_T("   PART_SUBSEL_TYPE"));
					}
					if(partID&PART_DISPLAY)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new  TSTR(_T("   PART_DISPLAY"));
					}
					if(partID&PART_VERTCOLOR)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new TSTR(_T("   PART_VERTCOLOR"));
					}
					if(partID&PART_GFX_DATA)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new  TSTR(_T("   PART_GFX_DATA"));
					}			
					if(partID&PART_TM_CHAN)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new TSTR(_T("   PART_TM_CHAN"));
					}
					if(partID&PART_MTL_CHAN)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new  TSTR(_T("   PART_MTL_CHAN"));
					}				
					if(partID&PART_OBJECT_TYPE)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new TSTR(_T("   PART_OBJECT_TYPE"));
					}
					if(partID&PART_HIDESTATE)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new  TSTR(_T("   PART_HIDESTATE"));
					}	
				}
			}
		case 0x00000070:
			{
			
				pMessages.SetCount(pMessages.Count() +1);
				pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_FLAGDEPENDENTS"));
				if(bShowpartIDs)
				{
					if(partID&PART_PUT_IN_FG)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new  TSTR(_T("   PART_PUT_IN_FG"));
					}				
					if(partID&PART_SHOW_DEPENDENCIES)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new TSTR(_T("   PART_SHOW_DEPENDENCIES"));
					}
					if(partID&PART_HIDESTATE)
					{
						pMessages.SetCount(pMessages.Count() +1);
						pMessages[pMessages.Count() -1] = new  TSTR(_T("   PART_SHOWDEP_ON"));
					}	
				}
			}
			break;
		case 0x00000080:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_TARGET_SELECTIONCHANGE"));
			break;
		case 0x00000090:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_BEGIN_EDIT"));				
			break;
		case 0x000000A0:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_END_EDIT"));
			break;
		case 0x000000B0:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_DISABLE"));				
			break;
		case 0x000000C0:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_ENABLE"));				
			break;
		case 0x000000D0:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_TURNON"));				
			break;
		case 0x000000E0:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_TURNOFF"));	
			break;
		case 0x000000F0:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_LOOKAT_TARGET_DELETED"));
			break;
		case 0x000000F1:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_INVALIDATE_IF_BG"));		
			break;
		case 0x000000F2:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_MOD_DISPLAY_ON"));		
			break;
		case 0x000000F3:
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_MOD_DISPLAY_OFF"));
			pMessages.SetCount(pMessages.Count() +1);
			break;
		case 0x000000F4:
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_MOD_EVAL"));
			pMessages.SetCount(pMessages.Count() +1);
			break;
		case 0x000000F5:
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_IS_OK_TO_CHANGE_TOPOLOGY"));
			pMessages.SetCount(pMessages.Count() +1);
			break;
		case 0x000000F6:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_NODE_LINK"));		
			break;
		case 0x000000F7:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_NODE_NAMECHANGE"));			
			break;
		case 0x000000F8:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_OBREF_CHANGE"));		
			break;
		case 0x000000F9:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_MODIFIER_ADDED"));		
			break;
		case 0x000000FA:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_CONTROLREF_CHANGE"));		
			break;
		case 0x000000FB:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_GET_PARAM_NAME"));			
			break;
		case 0x000000FC:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_GET_PARAM_DIM"));		
			break;
		case 0x000000FD:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_GET_CONTROL_DIM"));
			break;
		case 0x000000FE:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_TM_CHANGE"));			
			break;
		case 0x000000FF:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_RANGE_CHANGE"));		
			break;
		case 0x00000100:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_LINEHEIGHT_CHANGE"));		
			break;
		case 0x00000101:
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_BECOMING_ANIMATED"));
			pMessages.SetCount(pMessages.Count() +1);
			break;
		case 0x00000102:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_SUBANIM_STRUCTURE_CHANGED"));
			break;
		case 0x00000103:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_REF_DELETED"));
			break;
		case 0x00000104:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_REF_ADDED"));
			break;
		case 0x00000105:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_BRANCHED_HISTORY_CHANGED"));
			break;
		case 0x00000106:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_NODEINSELSET_CHANGED"));
			break;
		case 0x00000107:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_TEST_DEPENDENCY"));
			break;
		case 0x00000108:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_WANT_SHOWPARAMLEVEL"));
			break;
		case 0x00000109:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_BEFORE_PASTE"));	
			break;
		case 0x0000010A:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_NOTIFY_PASTE"));	
			break;
		case 0x0000010B:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_UV_SYM_CHANGE")); 
			break;
		case 0x0000010C:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_GET_NODE_NAME"));		
			break;
		case 0x0000010D:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_SEL_NODES_DELETED"));		
			break;
		case 0x0000010E:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_PRENOTIFY_PASTE"));
			break;
		case 0x0000010F:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_SHAPE_START_CHANGE"));	
			break;
		case 0x00000110:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_SHAPE_END_CHANGE"));	
			break;
		case 0x00000111:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_TEXMAP_REMOVED"));
			break;
		case 0x00000112:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_FLAG_NODES_WITH_SEL_DEPENDENTS"));
			break;
		case 0x00000120:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_CONTAINED_SHAPE_POS_CHANGE"));
			break;
		case 0x00000121:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_CONTAINED_SHAPE_SEL_CHANGE"));
			break;
		case 0x00000122:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_CONTAINED_SHAPE_GENERAL_CHANGE"));
			break;
		case 0x00000130:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_SELECT_BRANCH"));
			break;
		case 0x00000140:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_MOUSE_CYCLE_STARTED"));
			break;
		case 0x00000150:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_MOUSE_CYCLE_COMPLETED"));
			break;

		case 0x00000161:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_CHECK_FOR_INVALID_BIND"));
			break;

		case 0x00000162:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_OBJECT_CACHE_DUMPED"));
			break;

		case 0x00000170:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_SFX_CHANGE"));
			break;

		case 0x00000180:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_OBJXREF_UPDATEMAT"));
			break;

		case 0x00000190:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_OBJXREF_GETNODES"));
			break;

		case 0x00000200:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_OBJECT_REPLACED"));
			break;

		case 0x00000210:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T("REFMSG_NODE_WIRECOLOR_CHANGED"));
			break;

		default:
			pMessages.SetCount(pMessages.Count() +1);
			pMessages[pMessages.Count() -1] = new  TSTR( _T(""));
			break;
	};
	MsgStr = TSTR( _T(""));
	return &pMessages;
}

BOOL CALLBACK MainDlgProc(
	HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {

	TSTR buf;
	RefWatch *rc = (RefWatch *)GetWindowLong(hWnd, GWL_USERDATA);
	if (!rc && msg != WM_INITDIALOG ) return FALSE;

	switch (msg) {
		case WM_INITDIALOG:
			rc = (RefWatch *)lParam;
			SetWindowLong(hWnd, GWL_USERDATA, (LONG)rc);
			CenterWindow(hWnd, IP->GetMAXHWnd());
			SetWindowText(GetDlgItem(hWnd, IDC_CLASSNAME), _T(""));
			SetWindowText(GetDlgItem(hWnd, IDC_CLIENTNAME), _T(""));
			SetWindowText(GetDlgItem(hWnd, IDC_ITEM_NAME), _T(""));
			SendMessage(GetDlgItem(hWnd, IDC_MSG_LIST), LB_RESETCONTENT, 0, 0L);
			return TRUE;
		case WM_DESTROY:
			rc->hMain = NULL;
			break;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
				case IDCANCEL:
					rc->hMain = NULL;
					EndDialog(hWnd, FALSE);
					break;
				case IDC_CLEAR:
					SendMessage(GetDlgItem(hWnd, IDC_MSG_LIST), LB_RESETCONTENT, 0, 0L);
					break;
				case IDC_TVPICK: {
					TSTR str;
					HWND hIRefList = GetDlgItem(hWnd, IDC_IREF_LIST);
					HWND hRefMeList = GetDlgItem(hWnd, IDC_REFME_LIST);
					TrackViewPick tvp;
					tvp.anim = tvp.client = NULL;
					BOOL ok = IP->TrackViewPickDlg(hWnd, &tvp);
					SetWindowText(GetDlgItem(hWnd, IDC_CLASSNAME), _T(""));
					SetWindowText(GetDlgItem(hWnd, IDC_CLIENTNAME), _T(""));
					if (ok) {
						if (tvp.anim && tvp.client) {
							rc->watchMe = tvp.anim;
							buf.printf(_T("Item Name: %s"), rc->GetName());
							SetWindowText(GetDlgItem(hWnd, IDC_ITEM_NAME), buf.data());
							notifyObject.RemoveReference();
							notifyObject.CreateReference(rc->watchMe);
							tvp.anim->GetClassName(str);
							buf.printf(_T("This Target ClassName: %s"), str);
							SetWindowText(GetDlgItem(hWnd, IDC_CLASSNAME), buf.data());

							tvp.client->GetClassName(str);
							buf.printf(_T("Client ClassName: %s"), str);
							SetWindowText(GetDlgItem(hWnd, IDC_CLIENTNAME), buf.data());
							Tab<TSTR *> ptStr;
							TSTR *pTstr, Str("");
							pTstr = &Str;
							ptStr.Append(1, &pTstr);
							DisplayRefInfo(rc, hWnd, &ptStr);
							SendMessage(GetDlgItem(hWnd, IDC_MSG_LIST), LB_RESETCONTENT, 0, 0L);
						}
						else 
							ok = FALSE;
					}
					if (!ok) {
						rc->watchMe = NULL;
						notifyObject.RemoveReference();
						SendMessage(hIRefList, LB_RESETCONTENT, 0, 0L);
						SendMessage(hRefMeList, LB_RESETCONTENT, 0, 0L);
						SendMessage(GetDlgItem(hWnd, IDC_MSG_LIST), LB_RESETCONTENT, 0, 0L);
						SetWindowText(GetDlgItem(hWnd, IDC_CLASSNAME), _T(""));
						SetWindowText(GetDlgItem(hWnd, IDC_CLIENTNAME), _T(""));
						SetWindowText(GetDlgItem(hWnd, IDC_ITEM_NAME), _T(""));
					}
					break;
				};
				return TRUE;
			};
			break;

		default:
			return FALSE;
	};
	return TRUE;
}

// --- Inherited Virtual Methods From UtilityObj ---
void RefWatch::BeginEditParams(Interface *ip, IUtil *iu) {
	if (!hMain) {
		notifyObject.SetNotifyFunc(ProcessRefMessage, (DWORD)this);
		hMain = CreateDialogParam(hInstance, MAKEINTRESOURCE(IDD_MAIN),
			IP->GetMAXHWnd(), MainDlgProc, (LPARAM)this);
		CheckDlgButton(hMain, IDC_FULLTREE, BST_CHECKED); 
	}
}
	
TCHAR *RefWatch::GetName() {
	SClass_ID sID = watchMe->SuperClassID();
	if ((sID == MATERIAL_CLASS_ID) || (sID == TEXMAP_CLASS_ID))
		return ((MtlBase *)watchMe)->GetName();
	else if (sID == BASENODE_CLASS_ID)
		return ((INode *)watchMe)->GetName();
	else if (sID == ATMOSPHERIC_CLASS_ID)
		return ((Atmospheric *)watchMe)->GetName();
	else if ((sID == OSM_CLASS_ID) || (sID == WSM_CLASS_ID) ||
		(sID == GEOMOBJECT_CLASS_ID) || (sID == WSM_OBJECT_CLASS_ID))
		return ((BaseObject *)watchMe)->GetObjectName();
	return _T("(Unknown)");
}

/*===========================================================================*\
 | Class Descriptor
\*===========================================================================*/
class RefCheckCDesc : public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &refWatch;}
	const TCHAR *	ClassName() {return MY_CLASSNAME;}
	SClass_ID		SuperClassID() {return SClass_ID(UTILITY_CLASS_ID);}
	Class_ID		ClassID() {return MY_CLASS_ID;}
	const TCHAR * 	Category() {return MY_CATEGORY;}
};
static RefCheckCDesc refCheckCDesc;

/*===========================================================================*\
 | DLL/Lib Functions
\*===========================================================================*/
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {	
	hInstance = hinstDLL;
	if (! controlsInit) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}
	return(TRUE);
}

__declspec(dllexport) const TCHAR *LibDescription() {
	return MY_LIBDESCRIPTION;
}

__declspec(dllexport) int LibNumberClasses() { 
	return 1; 
}

__declspec(dllexport) ClassDesc* LibClassDesc(int i) { 
	return &refCheckCDesc; 
}

__declspec(dllexport) ULONG LibVersion() { 
	return VERSION_3DSMAX; 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Ringarry\RESOURCE.H ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RingArry.rc
//
#define IDS_DS_RINGARRAYPAR             1
#define IDS_DB_RING_ARRAY_CLASS         2
#define IDS_DS_RADIUS                   3
#define IDS_DS_CYCLES                   4
#define IDS_DS_AMPLITUDE                5
#define IDS_DS_PHASE                    6
#define IDS_DS_PARAMCHG                 7
#define IDS_RB_PARAMETERS               8
#define IDS_DB_SLAVECONTROL_CLASS       9
#define IDS_DB_SLAVE_CONTROL            10
#define IDS_DS_CREATE                   11
#define IDS_LIB_DESC                    12
#define IDD_SAMPLEPARAM                 122
#define IDC_RADIUS                      1000
#define IDC_AMPLITUDE                   1001
#define IDC_CYCLES                      1002
#define IDC_PHASE                       1003
#define IDC_NUMNODES                    1004
#define IDC_RADSPINNER                  1005
#define IDC_AMPSPINNER                  1006
#define IDC_CYCSPINNER                  1007
#define IDC_PHSSPINNER                  1008
#define IDC_NUMSPINNER                  1009

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Ringarry\RINGARRY.CPP ===
/*===========================================================================*\
  How To Create a System Plug-In

  FILE: RingArry.cpp
 
  DESCRIPTION: Ring Array System Plug-in sample code.

  HISTORY: created November 11 1994

  Copyright (c) 1994, All Rights Reserved.
\*===========================================================================*/
#include "max.h"
#include "resource.h"
#include "props.h"
#include "dummy.h"
#include "Simpobj.h"

// This is the DLL instance handle passed in when the plug-in is 
// loaded at startup.
HINSTANCE hInstance;

// This function returns a pointer to a string in the string table of
// the resource library.  Note that this function maintains the buffer
// and that only one string is loaded at a time.  Therefore if you intend
// to use this string, you must copy to another buffer since it will 
// be overwritten on the next GetString() call.
TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

// Unique Class ID.  It is specified as two 32-bit quantities.
// These must be unique.  Use the Class_ID generator program to create
// these values.  This program is available from the main menu of the
// help file.
#define RINGARRAY_CLASS_ID Class_ID(0x7f934bfa, 0x44a104c6)
#define SLAVE_CONTROL_CLASS_ID Class_ID(0x3e2c2cce, 0x2fd431f)

// Parameter block indices
#define PB_RAD	0
#define PB_CYC	1
#define PB_AMP	2
#define PB_PHS	3

//----------------------------------------------------------------------

class RingMaster: public ReferenceTarget {
	public:
		// Object parameters
		IParamBlock *pblock;
		// Table of nodes in the ring array.
		Tab<INode*> nodeTab;
		// The number of nodes in the ring array
		int numNodes;
		RingMaster();

		// This method returns the ith slave node.
		INode* GetSlaveNode(int i) { return nodeTab[i]; }
		// This method stores the ith slave node.
		void SetSlaveNode(int i, INode * node);

		// The following methods set and get values from the parameter block
		void SetNum(TimeValue t, int n); 
		void SetRad(TimeValue t, float r); 
		void SetCyc(TimeValue t, float r); 
		void SetAmp(TimeValue t, float r); 
		void SetPhs(TimeValue t, float r); 
		int GetNum(TimeValue t, Interval& valid = Interval(0,0) ); 	
		float GetRad(TimeValue t, Interval& valid = Interval(0,0) ); 	
		float GetCyc(TimeValue t, Interval& valid = Interval(0,0) ); 	
		float GetAmp(TimeValue t, Interval& valid = Interval(0,0) ); 	
		float GetPhs(TimeValue t, Interval& valid = Interval(0,0) ); 	

		// The slave controllers call this method to retireve their
		// value.  This allows the master object to control the entire
		// system.
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method, int id);
		// This makes sure that the spinner controls track when animating 
		// and in Motion Panel.
		void UpdateUI(TimeValue t);

		// Class variables
		static HWND hMasterParams;
		static IObjParam *iObjParams;
		static int dlgNum;
		static float dlgRadius;
		static float dlgAmplitude;
		static float dlgCycles;
		static float dlgPhase;
		static ISpinnerControl *numSpin;
		static ISpinnerControl *radSpin;
		static ISpinnerControl *ampSpin;
		static ISpinnerControl *cycSpin;
		static ISpinnerControl *phsSpin;

		// From Animatable

		// --- Inherited virtual methods from Animatable ---
		int NumSubs()  { return 1; }
		Animatable* SubAnim(int i) { return pblock; }
		TSTR SubAnimName(int i) { return GetString(IDS_DS_RINGARRAYPAR);}		
		Class_ID ClassID() { return RINGARRAY_CLASS_ID; }  
		SClass_ID SuperClassID() { return SYSTEM_CLASS_ID; }  
		void GetClassName(TSTR& s) { s = GetString(IDS_DB_RING_ARRAY_CLASS); }
		void DeleteThis() { delete this; }		
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next );
		void GetSystemNodes(INodeTab &nodes);

		// --- Inherited virtual methods from from ReferenceMaker/Target ---
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		int NumRefs() { return 1;	};
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage);
	};

// This method returns a new instance of the slave controller.
Control* GetNewSlaveControl(RingMaster *master, int i);

//------------------------------------------------------

// Initialize the class variables...
HWND RingMaster::hMasterParams = NULL;
IObjParam *RingMaster::iObjParams;

int RingMaster::dlgNum = 	4;
float RingMaster::dlgRadius = 	100.0f;
float RingMaster::dlgAmplitude = 20.0f;
float RingMaster::dlgCycles = 	3.0f;
float RingMaster::dlgPhase = 	1.0f;

ISpinnerControl *RingMaster::numSpin;
ISpinnerControl *RingMaster::radSpin;
ISpinnerControl *RingMaster::ampSpin;
ISpinnerControl *RingMaster::cycSpin;
ISpinnerControl *RingMaster::phsSpin;


RingMaster::RingMaster() {
	// The parameter block descriptor defines the type of value represented
	// by the parameter (int, float, Color...) and if it is animated or not.

	// This class requires these values to be initialized:
	// { - ParameterType, 
	//   - Not Used, must be set to NULL, 
	//   - Flag which indicates if the parameter is animatable,
	//  }
	ParamBlockDesc desc[] = {
		{ TYPE_FLOAT, NULL, TRUE },
		{ TYPE_FLOAT, NULL, TRUE },
		{ TYPE_FLOAT, NULL, TRUE },
		{ TYPE_FLOAT, NULL, TRUE }
		};
	// Create a parameter block and make a reference to it.
	MakeRefByID( FOREVER, 0, CreateParameterBlock( desc, 4 ) );	
	// Set the initial values at time 0.
	SetRad( TimeValue(0), dlgRadius );
	SetCyc( TimeValue(0), dlgCycles );
	SetAmp( TimeValue(0), dlgAmplitude );
	SetPhs( TimeValue(0), dlgPhase );
	numNodes = dlgNum;
	}

// This method is called to return a copy of the ring master.
RefTargetHandle RingMaster::Clone(RemapDir& remap) {
	int i;
    RingMaster* newm = new RingMaster();	
	newm->ReplaceReference(0,pblock->Clone(remap));
	newm->numNodes = numNodes;
	newm->nodeTab.SetCount(numNodes);
	for (i=0; i<numNodes; i++) newm->nodeTab[i] = NULL;			
	for (i=0; i<numNodes; i++) {
		remap.PatchPointer((RefTargetHandle*)&newm->nodeTab[i],(RefTargetHandle)nodeTab[i]);
		}
	return(newm);
	}

// This method is called to update the UI parameters to reflect the
// correct values at the time passed.  Note that FALSE is passed as
// the notify parameter.  This ensure that notification message are
// not sent when the values are updated.
void RingMaster::UpdateUI(TimeValue t)
	{
	if ( hMasterParams ) {
		radSpin->SetValue( GetRad(t), FALSE );
		ampSpin->SetValue( GetAmp(t), FALSE );
		cycSpin->SetValue( GetCyc(t), FALSE );
		phsSpin->SetValue( GetPhs(t), FALSE );
		numSpin->SetValue( GetNum(t), FALSE );
		}
	}

// This method is called to set the ith slave node for the ring master.
// If additional space is required in the node table it is allocated.
void RingMaster::SetSlaveNode(int i, INode * node) {
	if (i>=nodeTab.Count()) {
		int nold = nodeTab.Count();
		nodeTab.SetCount(i+1);
		if (i+1>numNodes) 
			numNodes = i+1;
		for (int j = nold; j<i+1; j++) nodeTab[j] = NULL;
		}		
	nodeTab[i] = node;
	}

// The master controller of a system plug-in should implement this 
// method to give MAX a list of nodes that are part of the system.   
// The master controller should fill in the given table with the 
// INode pointers of the nodes that are part of the system. This 
// will ensure that operations like cloning and deleting affect 
// the whole system.  MAX will use GetInterface() in the 
// tmController of each selected node to retrieve the master 
// controller and then call GetSystemNodes() on the master 
// controller to get the list of nodes.
void RingMaster::GetSystemNodes(INodeTab &nodes)
	{
	for (int i=0; i<nodeTab.Count(); i++) {
		nodes.Append(1,&nodeTab[i]);
		}
	}

// This methods returns the ith reference - there is only one, the 
// parameter block.
RefTargetHandle RingMaster::GetReference(int i)  { 
	if (i==0) return pblock;
	return NULL;
	}

// This methods sets the ith reference - there is only one, the 
// parameter block.
void RingMaster::SetReference(int i, RefTargetHandle rtarg) {
	if (i==0)
		pblock = (IParamBlock *)rtarg; 
	}		

#define TWO_PI 6.283185307f

// ======= This method is the crux of the system plug-in ==========
// It takes an input (parent) matrix and modifies it according to the id
// passed in.  This id represents the position in the ring array system
// of the node that is having it's position set by this method.
// 
// The slave controllers that set the position and orientation of the 
// ring array nodes call this method in their implementation of the
// method Control::GetValue().
void RingMaster::GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method, int id) {
	float radius,amplitude,cycles, phase;

	// Retrieve the values of the UI parameters at the time passed in.
	radius = GetRad(t,valid);
	amplitude = GetAmp(t,valid);
	cycles = GetCyc(t,valid);
	phase = GetPhs(t,valid);
	Matrix3 tmat, *mat = (Matrix3*)val;
	tmat.IdentityMatrix();

	// Calculate the Z angle rotation for the nodes based on the number
	// of nodes in the ring array and the id of the node passed in.
	float ang = float(id)*TWO_PI/(float)numNodes;

	// Calculate the translation of the node based on the id and the UI
	// parameters.
	tmat.Translate(Point3(radius,0.0f,amplitude*(float)cos(cycles*ang + TWO_PI*phase)));
	tmat.RotateZ(ang);
	
	// There are two ways of updating a value; relative or absolute.
	// If the value is relative the calculated position is applied to
	// the input value using matrix multiplication.  If the method
	// is absolute then the value is simply set to the calculated value.
	(*mat) = (method==CTRL_RELATIVE) ? tmat*(*mat) : tmat;

	// Make sure spinners track when animating and in Motion Panel
	UpdateUI(t);
	}

// This is the method that recieves change notification messages
RefResult RingMaster::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
     PartID& partID, RefMessage message ) 
    {
	switch (message) {
		case REFMSG_GET_PARAM_DIM: { 
			// The ParamBlock needs info to display in the track view.
			// This message is sent to retrieve the dimension of the 
			// parameter block value.  The dimension represnets the 
			// type and order of magnitude of the parameter.
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_RAD:	gpd->dim = stdWorldDim; break;	  
				case PB_CYC:	gpd->dim = stdWorldDim; break;	  
				case PB_AMP:	gpd->dim = stdWorldDim; break;	  
				case PB_PHS:	gpd->dim = stdWorldDim; break;	  
					break;									
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			// The ParamBlock needs info to display in the track view
			// This message is sent to retrieve the name of the parameter
			// whose index is passed.
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_RAD: gpn->name = GetString(IDS_DS_RADIUS);	break;
				case PB_CYC: gpn->name = GetString(IDS_DS_CYCLES);	break;
				case PB_AMP: gpn->name = GetString(IDS_DS_AMPLITUDE);	break;
				case PB_PHS: gpn->name = GetString(IDS_DS_PHASE);	break;
				}
			return REF_STOP; 
			}
		case REFMSG_TARGET_DELETED:{
			// This message is sent if one of the nodes in the ring array
			// is deleted.
			for (int i=0; i<nodeTab.Count(); i++) {
				if (hTarget==nodeTab[i]) {
					nodeTab[i] = NULL;				
					break;
					}					
				}
			}
			return REF_STOP;
		}
	return(REF_SUCCEED);
	}

//--------------------------------------------------
// This is the restore object used when the user executes an undo or redo
class RingNumRestore: public RestoreObj {
	RingMaster *rng;
	int num;
	int redNum;
	public:
		RingNumRestore(RingMaster *ringm, int n) { rng = ringm; num = n; }
		~RingNumRestore() {}
		void Restore(int isUndo);
		void Redo();
		TSTR Description() { return TSTR("RingNumRestore"); }
	};

// This method restores the MAX data base to the state it was when theHold.Put()
// was called.
void RingNumRestore::Restore(int isUndo) {
	redNum = rng->nodeTab.Count();
	rng->nodeTab.SetCount(num);
	if (num>redNum) {
		for (int i=redNum; i<num; i++)
			rng->nodeTab[i] = NULL;
		}
	rng->numNodes = num;
	if (rng->hMasterParams) 
		RingMaster::numSpin->SetValue(rng->numNodes, FALSE );
	rng->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

// This method is called when the user selects the Redo command.  The developer 
// should restore the database to the state prior to the last Undo command.
void RingNumRestore::Redo() {	
	rng->nodeTab.SetCount(redNum);
	if (redNum>rng->numNodes) {
		for (int i=num; i<redNum; i++)
			rng->nodeTab[i] = NULL;
		}
	rng->numNodes = redNum;
	if (rng->hMasterParams) 
	    RingMaster::numSpin->SetValue(rng->numNodes, FALSE );
	rng->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

//--------------------------------------------------
// This method is called to set the number of nodes in the ring array.
// It handles the allocation or deallocation of nodes in the node table.
void RingMaster::SetNum(TimeValue t, int n) { 
	if (n==numNodes) return;
	if (n<1) return;
	int oldNumNodes = numNodes;
	if (nodeTab.Count()>0) {
		if (n<numNodes) {
			// remove nodes;
			for (int i=numNodes-1; i>=n; i--) {
				INode* node = nodeTab[i];
				if (node) {
					if (node->Selected()) {
						// Dont want to delete selected nodes
						n = i+1;
						numSpin->SetValue( n, TRUE );
						break;
						}
					node->Delete(t,TRUE);
					nodeTab[i] = NULL;
					}
				numNodes = i;
				}
			nodeTab.SetCount(n);
			}
		else {
			nodeTab.SetCount(n);
			for (int i=numNodes; i<n; i++)
				nodeTab[i] = NULL;
			// add nodes;
			if (nodeTab[0]==NULL) {
				n++;
				numSpin->SetValue( n, TRUE );
				}
			else for (i=numNodes; i<n; i++) {
				Object * obj = nodeTab[0]->GetObjectRef();
				assert(obj);
				INode *newNode = iObjParams->CreateObjectNode(obj);
				Control* slave = GetNewSlaveControl(this,i);
				newNode->SetTMController(slave);
				newNode->FlagForeground(t,FALSE);
				INode *par = nodeTab[0]->GetParentNode();
				assert(par);
			    par->AttachChild(newNode);
				SetSlaveNode(i,newNode);
				}
			}
		}
	if (theHold.Holding())
		theHold.Put(new RingNumRestore(this, oldNumNodes));
	numNodes = n;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

// This method retireves the number of nodes in the ring array.
int RingMaster::GetNum(TimeValue t, Interval& valid ) { 	
	return numNodes;
	}


//--------------------------------------------------
// The following methods set and get the radius value in the parameter block.
void RingMaster::SetRad(TimeValue t, float r) { 
	pblock->SetValue( PB_RAD, t, r );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float RingMaster::GetRad(TimeValue t, Interval& valid ) { 	
	float f;
	pblock->GetValue( PB_RAD, t, f, valid );
	return f;
	}

//--------------------------------------------------
// The following methods set and get the cycles value in the parameter block.
void RingMaster::SetCyc(TimeValue t, float r) { 
	pblock->SetValue( PB_CYC, t, r );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float RingMaster::GetCyc(TimeValue t, Interval& valid ) { 	
	float f;
	pblock->GetValue( PB_CYC, t, f, valid );
	return f;
	}

//--------------------------------------------------
// The following methods set and get the amplitude value in the 
// parameter block.
void RingMaster::SetAmp(TimeValue t, float r) { 
	pblock->SetValue( PB_AMP, t, r );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float RingMaster::GetAmp(TimeValue t, Interval& valid ) { 	
	float f;
	pblock->GetValue( PB_AMP, t, f, valid );
	return f;
	}

//--------------------------------------------------
// The following methods set and get the phase value in the 
// parameter block.
void RingMaster::SetPhs(TimeValue t, float r) { 
	pblock->SetValue( PB_PHS, t, r );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float RingMaster::GetPhs(TimeValue t, Interval& valid ) { 	
	float f;
	pblock->GetValue( PB_PHS, t, f, valid );
	return f;
	}

//--------------------------------------------------
// This is the dialog proc used to manage the user interaction with the
// custom controls in the user interface.  For more details on the 
// stucture and messages of a dialog proc see the Advanced Topics 
// section on Custom Controls.
BOOL CALLBACK MasterParamDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	RingMaster *mc = (RingMaster *)GetWindowLong( hDlg, GWL_USERDATA );
	if ( !mc && message != WM_INITDIALOG ) return FALSE;
	
	assert(mc->iObjParams);
	switch ( message ) {
		case WM_INITDIALOG:
			mc = (RingMaster *)lParam;
			SetWindowLong( hDlg, GWL_USERDATA, (LONG)mc );
			SetDlgFont( hDlg, mc->iObjParams->GetAppHFont() );
			
			mc->radSpin  = GetISpinner(GetDlgItem(hDlg,IDC_RADSPINNER));
			mc->cycSpin  = GetISpinner(GetDlgItem(hDlg,IDC_CYCSPINNER));
			mc->ampSpin  = GetISpinner(GetDlgItem(hDlg,IDC_AMPSPINNER));
			mc->phsSpin  = GetISpinner(GetDlgItem(hDlg,IDC_PHSSPINNER));
			mc->numSpin  = GetISpinner(GetDlgItem(hDlg,IDC_NUMSPINNER));

			mc->radSpin->SetLimits( 0.0f, 500.0f, FALSE );
			mc->cycSpin->SetLimits( 0.0f, 10.0f, FALSE );
			mc->ampSpin->SetLimits( 0.0f, 500.0f, FALSE );
			mc->phsSpin->SetLimits( -1000.0f, 1000.0f, FALSE );
			mc->numSpin->SetLimits( 1, 200, FALSE );

			mc->radSpin->SetScale(float(0.1) );
			mc->ampSpin->SetScale(float(0.1) );
			mc->phsSpin->SetScale(float(0.1) );
			mc->numSpin->SetScale(float(0.1) );

			mc->radSpin->SetValue( mc->GetRad(mc->iObjParams->GetTime()), FALSE );
			mc->cycSpin->SetValue( mc->GetCyc(mc->iObjParams->GetTime()), FALSE );
			mc->ampSpin->SetValue( mc->GetAmp(mc->iObjParams->GetTime()), FALSE );
			mc->phsSpin->SetValue( mc->GetPhs(mc->iObjParams->GetTime()), FALSE );
			mc->numSpin->SetValue( mc->GetNum(mc->iObjParams->GetTime()), FALSE );

			mc->radSpin->LinkToEdit( GetDlgItem(hDlg,IDC_RADIUS), EDITTYPE_POS_UNIVERSE );			
			mc->cycSpin->LinkToEdit( GetDlgItem(hDlg,IDC_CYCLES), EDITTYPE_FLOAT );			
			mc->ampSpin->LinkToEdit( GetDlgItem(hDlg,IDC_AMPLITUDE), EDITTYPE_FLOAT );			
			mc->phsSpin->LinkToEdit( GetDlgItem(hDlg,IDC_PHASE), EDITTYPE_FLOAT );			
			mc->numSpin->LinkToEdit( GetDlgItem(hDlg,IDC_NUMNODES), EDITTYPE_INT );			
			
			return FALSE;	// DB 2/27

		case WM_DESTROY:
			ReleaseISpinner( mc->radSpin );
			ReleaseISpinner( mc->cycSpin );
			ReleaseISpinner( mc->ampSpin );
			ReleaseISpinner( mc->phsSpin );
			ReleaseISpinner( mc->numSpin );
			mc->radSpin = NULL;
			mc->cycSpin = NULL;
			mc->ampSpin = NULL;
			mc->phsSpin = NULL;
			mc->numSpin = NULL;
			return FALSE;

		case CC_SPINNER_CHANGE:
			if (!theHold.Holding()) theHold.Begin();
			switch ( LOWORD(wParam) ) {
				case IDC_RADSPINNER: mc->SetRad(mc->iObjParams->GetTime(),  mc->radSpin->GetFVal() );  break;
				case IDC_CYCSPINNER: mc->SetCyc(mc->iObjParams->GetTime(),  mc->cycSpin->GetFVal() );  break;
				case IDC_AMPSPINNER: mc->SetAmp(mc->iObjParams->GetTime(),  mc->ampSpin->GetFVal() );  break;
				case IDC_PHSSPINNER: mc->SetPhs(mc->iObjParams->GetTime(),  mc->phsSpin->GetFVal() );  break;
				case IDC_NUMSPINNER: mc->SetNum(mc->iObjParams->GetTime(),  mc->numSpin->GetIVal() );  break;
				}
			assert(mc->iObjParams);
			mc->iObjParams->RedrawViews(mc->iObjParams->GetTime(), REDRAW_INTERACTIVE, mc);
			return TRUE;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			return TRUE;

		case CC_SPINNER_BUTTONUP:
			if (HIWORD(wParam) || message==WM_CUSTEDIT_ENTER) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			mc->iObjParams->RedrawViews(mc->iObjParams->GetTime(), REDRAW_END, mc);
			return TRUE;

		case WM_MOUSEACTIVATE:
			mc->iObjParams->RealizeParamPanel();
			return FALSE;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			mc->iObjParams->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;

		case WM_COMMAND:			
			return FALSE;

		default:
			return FALSE;
		}
	}

// This method is called when the ring masters parameters may be edited
// in the motion branch of the command panel.  
void RingMaster::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	iObjParams = ip;
	
	if ( !hMasterParams ) {
		hMasterParams = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_SAMPLEPARAM),
				MasterParamDialogProc,
				GetString(IDS_RB_PARAMETERS), 
				(LPARAM)this );		
		ip->RegisterDlgWnd(hMasterParams);
		
	} else {
		SetWindowLong( hMasterParams, GWL_USERDATA, (LONG)this );		

		// Init the dialog to our values.
		radSpin->SetValue(GetRad(ip->GetTime()),FALSE);
		cycSpin->SetValue(GetCyc(ip->GetTime()),FALSE);
		ampSpin->SetValue(GetAmp(ip->GetTime()),FALSE);
		phsSpin->SetValue(GetPhs(ip->GetTime()),FALSE);
		numSpin->SetValue(GetNum(ip->GetTime()),FALSE);
		}
	}
		
// This method is called when the user is finished editing the ring masters
// parameters in the command panel.		
void RingMaster::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	if (hMasterParams==NULL) 
		return;
	dlgRadius   = radSpin->GetFVal();
	dlgAmplitude   = ampSpin->GetFVal();
	dlgCycles   = cycSpin->GetFVal();
	dlgPhase   = phsSpin->GetFVal();
	dlgNum   = numSpin->GetIVal();
	
	if ( flags&END_EDIT_REMOVEUI ) {		
		ip->UnRegisterDlgWnd(hMasterParams);
		ip->DeleteRollupPage(hMasterParams);
		hMasterParams = NULL;
		}
	else {		
		SetWindowLong( hMasterParams, GWL_USERDATA, 0 );
		}
	
	iObjParams = NULL;
	}

#define NUMNODES_CHUNK 0x100
#define NODE_ID_CHUNK 0x110

// This method is called to allow the plug-in to save any data it needs
// to the MAX file.  Here we store the number of nodes and the node ids.
// See the Advanced Topics on Loading and Saving for more details.
IOResult RingMaster::Save(ISave *isave) {
	ULONG nb;
	isave->BeginChunk(NUMNODES_CHUNK);
	isave->Write(&numNodes,sizeof(numNodes), &nb);
	isave->EndChunk();
	if (numNodes>0) {
		isave->BeginChunk(NODE_ID_CHUNK);
		for (int i=0; i<numNodes; i++) {
			ULONG id = isave->GetRefID(nodeTab[i]);
			isave->Write(&id,sizeof(ULONG), &nb);
			}
		isave->EndChunk();
		}
	return IO_OK;
	}

// This method is called to allow the plug-in to load it's data from the 
// MAX file. 
IOResult RingMaster::Load(ILoad *iload) {
	ULONG nb;
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case NUMNODES_CHUNK: {
				res = iload->Read(&numNodes,sizeof(numNodes), &nb);
				nodeTab.SetCount(numNodes);
				for (int i=0; i<numNodes; i++) nodeTab[i] = NULL;
				}
				break;
			case NODE_ID_CHUNK:
				for (int i=0; i<numNodes; i++) {
					ULONG id;
					iload->Read(&id,sizeof(ULONG), &nb);
					if (id!=0xffffffff)
						iload->RecordBackpatch(id,(void**)&nodeTab[i]);
					}
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

//-------------------------------------------------------------
class SlaveControl : public Control {
	public:		
		// This controller maintains a reference to the ring master.  The
		// reference pointer is maintained here.
		RingMaster *master;
		// This is the id of the slave controller.  This is a number from
		// 0 to numNodes-1 that represents which dummy object in the ring
		// array the controller is assigned to.
		ULONG id;

		// Constructors, destructor, assignment operator.
		SlaveControl(BOOL loading=FALSE) { master = NULL; id = 0; }
		SlaveControl(const SlaveControl& ctrl);
		SlaveControl(const RingMaster* m, int i);
		void SetID( ULONG i) { id = i;}
		virtual ~SlaveControl() {}	
		SlaveControl& operator=(const SlaveControl& ctrl);

		// --- Inherited virtual methods from Control ---
		void Copy(Control *from) {}
		void CommitValue(TimeValue t) {}
		void RestoreValue(TimeValue t) {}
		virtual BOOL IsLeaf() {return FALSE;}
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValue(TimeValue t, void *val, int commit=1, GetSetMethod method=CTRL_ABSOLUTE);
		BOOL IsReplaceable() {return FALSE;}
		BOOL CanCopyAnim() {return FALSE;}

		// From Animatable
		void* GetInterface(ULONG id);
		int NumSubs()  { return master->NumSubs(); }
		Animatable* SubAnim(int i) { return master->SubAnim(i); }
		TSTR SubAnimName(int i) { return master->SubAnimName(i); }
		Class_ID ClassID() { return SLAVE_CONTROL_CLASS_ID; }  
		SClass_ID SuperClassID() { return CTRL_MATRIX3_CLASS_ID; }  
		void GetClassName(TSTR& s) { s = GetString(IDS_DB_SLAVECONTROL_CLASS); }
		void DeleteThis() { delete this; }		
		// These controllers don't create keyframes - their position 
		// is set by the ring master at all times.  Thus this controller
		// returns 0 for IsKeyable().
		int IsKeyable(){ return 0;}
		// When the system needs to allow the user to edit the controllers
		// parameters in the motion branch this method is called.  This 
		// implementation simply calls the same method of the RingMaster
		// object.  This is done because the UI controls managed by
		// the ring master control the entire system.
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev) { assert(master); master->BeginEditParams(ip,flags,prev); } 
		// This is called to end the parameter editing.  Again, the 
		// ring master method is called.
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next) { assert(master); master->EndEditParams(ip,flags,next); } 
		// --- Inherited virtual methods from ReferenceMaker and Target ---
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		// The slave controller has a single reference to the ring master.
		int NumRefs() { return 1; };	
		RefTargetHandle GetReference(int i)  { assert(i==0); return master; }
		void SetReference(int i, RefTargetHandle rtarg) { assert(i==0); master = (RingMaster *)rtarg; }		
		// This method is called when the something the slave controller 
		// depends on changes.  For example if the RingMaster that the 
		// controller references is deleted this method is called.  Because
		// the slave controller do not have any data cached they don't need
		// to invalidate anything in their implementation of this method.
		// Consequently the implementation simply returns REF_SUCCEED.
		// They only make a referrence to the RingMaster so the _system_ 
		// knows that the slaves are dependent on the RingMaster.
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage) {return REF_SUCCEED;}
		// These methods load and save the controller data from/to the MAX file
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};
 
// This method returns a new instance of the slave controller.
Control* GetNewSlaveControl(RingMaster *master, int i) {
	return new SlaveControl(master,i);
	}

SlaveControl::SlaveControl(const SlaveControl& ctrl) {
	master = ctrl.master;
	id = ctrl.id;
	}

// This constructor creates a reference from the slave controller to 
// the ring master object.
SlaveControl::SlaveControl(const RingMaster* m, int i) {
	id = i;
    MakeRefByID( FOREVER, 0, (ReferenceTarget *)m);
	}

// This method is called to create a copy of the slave controller.
RefTargetHandle SlaveControl::Clone(RemapDir& remap) {
	SlaveControl *sl = new SlaveControl;
	sl->id = id;
	sl->ReplaceReference(0, remap.CloneRef(master));
	return sl;
	}

SlaveControl& SlaveControl::operator=(const SlaveControl& ctrl) {
	master = ctrl.master;
	id = ctrl.id;
	return (*this);
	}

// ========= This method is used to retrieve the value of the 
// controller at the specified time. =========

// This is a important aspect of the system plug-in - this method 
// calls the master object to get the value.
void SlaveControl::GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method) {
	assert(master);
	master->GetValue(t,val,valid,method,id);	
	}

void SlaveControl::SetValue(TimeValue t, void *val, int commit, GetSetMethod method) { }

void* SlaveControl::GetInterface(ULONG id) {
	if (id==I_MASTER) 
		return (void *)master;
	else 
		return NULL;
	}

// IO
#define SLAVE_ID_CHUNK 0x200
IOResult SlaveControl::Save(ISave *isave) {
	ULONG nb;
	isave->BeginChunk(SLAVE_ID_CHUNK);
	isave->Write(&id,sizeof(id), &nb);
	isave->EndChunk();
	return IO_OK;
	}

IOResult SlaveControl::Load(ILoad *iload) {
	ULONG nb;
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SLAVE_ID_CHUNK:
				res = iload->Read(&id,sizeof(id), &nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

//----------------------------------------------------------------------


class RingMasterCreationManager : public MouseCallBack, ReferenceMaker {
	public:
		CreateMouseCallBack *createCB;	
		INode *node0;
		RingMaster *theMaster;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		IPoint2 pt0;
		Point3 center;
		BOOL attachedToNode;
		int lastPutCount;

		void CreateNewMaster();
			
		int ignoreSelectionChange;

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);

		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		RingMasterCreationManager()
			{
			ignoreSelectionChange = FALSE;
			}
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};

#define CID_BONECREATE	CID_USER + 1

class RingMasterCreateMode : public CommandMode {
		RingMasterCreationManager proc;
	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }
		int Class() { return CREATE_COMMAND; }
		int ID() { return CID_BONECREATE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints = 100000; return &proc; }
		ChangeForegroundCallback *ChangeFGProc() { return CHANGE_FG_SELECTED; }
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		void EnterMode() {}
		void ExitMode() {}
		BOOL IsSticky() { return FALSE; }
	};

static RingMasterCreateMode theRingMasterCreateMode;

//RingMasterCreationManager::RingMasterCreationManager( IObjCreate *ioc, ClassDesc *desc )
void RingMasterCreationManager::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	createInterface = ioc;
	cDesc           = desc;
	createCB        = NULL;
	node0			= NULL;
	theMaster 		= NULL;
	attachedToNode = FALSE;
	CreateNewMaster();
	}

void RingMasterCreationManager::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case 0: node0 = (INode *)rtarg; break;
		default: assert(0); 
		}
	}

RefTargetHandle RingMasterCreationManager::GetReference(int i) { 
	switch(i) {
		case 0: return (RefTargetHandle)node0;
		default: assert(0); 
		}
	return NULL;
	}

//RingMasterCreationManager::~RingMasterCreationManager
void RingMasterCreationManager::End()
	{
	if (theMaster) {
		theMaster->EndEditParams( (IObjParam*)createInterface, 
	                    	          TRUE/*destroy*/, NULL );
		if ( !attachedToNode ) {
			delete theMaster;
			theMaster = NULL;
			// DS 8/21/97: If something has been put on the undo stack since this object was created, we have to flush the undo stack.
			if (theHold.GetGlobalPutCount()!=lastPutCount) {
				GetSystemSetting(SYSSET_CLEAR_UNDO);
				}
		} else if ( node0 ) {
			 // Get rid of the references.
			DeleteAllRefsFromMe();
			}
		}	
	}

RefResult RingMasterCreationManager::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if (theMaster) {
				// this will set node0 ==NULL;
				DeleteAllRefsFromMe();
				goto endEdit;
				}
			// fall through

		case REFMSG_TARGET_DELETED:
			if (theMaster) {
				endEdit:
				theMaster->EndEditParams( (IObjParam*)createInterface, FALSE/*destroy*/,NULL );
				theMaster = NULL;
				node0 = NULL;
				CreateNewMaster();	
				attachedToNode = FALSE;
				}
			break;		
		}
	return REF_SUCCEED;
	}

void RingMasterCreationManager::CreateNewMaster()
	{
	theMaster = new RingMaster();
	
	// Start the edit params process
	theMaster->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE,NULL );
	lastPutCount = theHold.GetGlobalPutCount();
	}

#define DUMSZ 20.0f
#define BOXSZ 20.0f

int RingMasterCreationManager::proc( 
				HWND hwnd,
				int msg,
				int point,
				int flag,
				IPoint2 m )
	{	
	int res;
	INode *newNode,*dummyNode;	
	float r;
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );


	switch ( msg ) {
		case MOUSE_POINT:
				{
				if (point==0) {
					pt0 = m;	

					assert(theMaster);

					mat.IdentityMatrix();
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}
					if (createInterface->IsCPEdgeOnInView()) { 
						return FALSE;
						}
					if ( attachedToNode ) {
				   		// send this one on its way
				   		theMaster->EndEditParams( (IObjParam*)createInterface,0,NULL );
						
						// Get rid of the references.
						DeleteAllRefsFromMe();

						// new object
						CreateNewMaster();   // creates theMaster
						}


				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();
					center = vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
					mat.SetTrans(center);

					// Create a dummy object & node
					DummyObject *dumObj = (DummyObject *)createInterface->
						CreateInstance(HELPER_CLASS_ID,Class_ID(DUMMY_CLASS_ID,0)); 			
					assert(dumObj);					
					dummyNode = createInterface->CreateObjectNode(dumObj);
					dumObj->SetBox(Box3(Point3(-DUMSZ,-DUMSZ,-DUMSZ),Point3(DUMSZ,DUMSZ,DUMSZ)));

					// make a box object
					GenBoxObject *ob = (GenBoxObject *)createInterface->
						CreateInstance(GEOMOBJECT_CLASS_ID,Class_ID(BOXOBJ_CLASS_ID,0));
					ob->SetParams(BOXSZ,BOXSZ,BOXSZ,1,1,1,FALSE); 

					// Make a bunch of nodes, hook the box object to and a
					// slave controller of the master control to each
					for (int i=0; i<theMaster->numNodes; i++) {
						newNode = createInterface->CreateObjectNode(ob);
						SlaveControl* slave = new SlaveControl(theMaster,i);
						newNode->SetTMController(slave);
						dummyNode->AttachChild(newNode);
						theMaster->SetSlaveNode(i,newNode);
						}

					// select the dummy node.
					attachedToNode = TRUE;

					// Reference the node so we'll get notifications.
				    MakeRefByID( FOREVER, 0, theMaster->GetSlaveNode(0) );
					theMaster->SetRad(TimeValue(0),0.0f);
					mat.SetTrans(vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
					createInterface->SetNodeTMRelConstPlane(dummyNode, mat);
					res = TRUE;
					}
				else {
					// select a node so if go into modify branch, see params 
					ignoreSelectionChange = TRUE;
				   	createInterface->SelectNode( theMaster->GetSlaveNode(0) );
					ignoreSelectionChange = FALSE;
					theHold.Accept(IDS_DS_CREATE);
					res = FALSE;
					}
 				createInterface->RedrawViews(createInterface->GetTime(),REDRAW_NORMAL,theMaster);  
				}
				break;
		case MOUSE_MOVE:
			if (node0) {
				r = (float)fabs(vpx->SnapLength(vpx->GetCPDisp(center,Point3(0,1,0),pt0,m)));
				theMaster->SetRad(0,r);
				theMaster->radSpin->SetValue(r, FALSE );
				createInterface->RedrawViews(createInterface->GetTime(),REDRAW_NORMAL,theMaster);
				}
			res = TRUE;
			break;

		case MOUSE_ABORT:
			assert(theMaster);
			theMaster->EndEditParams( (IObjParam*)createInterface, 0,NULL );
			theHold.Cancel();  // undo the changes
			DeleteAllRefsFromMe();
			// DS 8/21/97: If something has been put on the undo stack since this object was created, we have to flush the undo stack.
			if (theHold.GetGlobalPutCount()!=lastPutCount) {
				GetSystemSetting(SYSSET_CLEAR_UNDO);
				}
			CreateNewMaster();	
			createInterface->RedrawViews(createInterface->GetTime(),REDRAW_END,theMaster); 
			attachedToNode = FALSE;
			res = FALSE;						
			break;
		}
	
	createInterface->ReleaseViewport(vpx); 
	return res;
	}

class RingMasterClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new RingMaster(); }
	const TCHAR *	ClassName() { return GetString(IDS_DB_RING_ARRAY_CLASS); }
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	SClass_ID		SuperClassID() { return SYSTEM_CLASS_ID; }
	Class_ID		ClassID() { return RINGARRAY_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
	};
static RingMasterClassDesc mcDesc;

ClassDesc* GetRingMasterDesc() { return &mcDesc; }


int RingMasterClassDesc::BeginCreate(Interface *i)
	{
	IObjCreate *iob = i->GetIObjCreate();
	
	theRingMasterCreateMode.Begin( iob, this );
	iob->PushCommandMode( &theRingMasterCreateMode );
	
	return TRUE;
	}

int RingMasterClassDesc::EndCreate(Interface *i)
	{
	theRingMasterCreateMode.End();
	i->RemoveMode( &theRingMasterCreateMode );
	return TRUE;
	}

class SlaveControlClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) { return new SlaveControl(); }
	const TCHAR *	ClassName() { return GetString(IDS_DB_SLAVE_CONTROL); }
	SClass_ID		SuperClassID() { return CTRL_MATRIX3_CLASS_ID; }
	Class_ID		ClassID() { return SLAVE_CONTROL_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
	};

static SlaveControlClassDesc slvDesc;

ClassDesc* GetSlaveControlDesc() { return &slvDesc; }

// The following five functions are used by every plug-in DLL.
/*===========================================================================*\
 | The DLL and Library Functions
\*===========================================================================*/
// This function is called by Windows when the DLL is loaded.  This 
// function may also be called many times during time critical operations
// like rendering.  Therefore developers need to be careful what they
// do inside this function.  In the code below, note how after the DLL is
// loaded the first time only a few statements are executed.
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

	if (! controlsInit) {
		controlsInit = TRUE;
		
		// Initialize MAX's custom controls
		InitCustomControls(hInstance);
		
		// Initialize Win95 controls
		InitCommonControls();
	}
	
	return(TRUE);
	}

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int LibNumberClasses() {return 2;}

// This function return the ith class descriptor
__declspec( dllexport ) ClassDesc *LibClassDesc(int i) {
	switch(i) {
		case 0: return GetSlaveControlDesc();		
		case 1: return GetRingMasterDesc();		
		default: return 0;
		}
	}

// This function returns a string that describes the DLL.  This string appears in 
// the File / Summary Info / Plug-In Info dialog box.
__declspec( dllexport ) const TCHAR *LibDescription() { 
	return GetString(IDS_LIB_DESC);
	}

// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Ripple\RESOURCE.H ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Ripple.rc
//
#define IDS_STRING1                     1
#define IDS_RB_RIPPLE                   1
#define IDS_RB_WAVE                     2
#define IDS_RB_RIPPLE_CLASS             3
#define IDS_RB_SOT                      4
#define IDS_RB_PARAMETERS               5
#define IDS_RB_AMPLITUDE1               6
#define IDS_RB_AMPLITUDE2               7
#define IDS_RB_WAVELEN                  8
#define IDS_RB_PHASE                    9
#define IDS_RB_DECAY                    10
#define IDS_RB_FLEXIBILITY              11
#define IDS_RB_WAVE_CLASS               12
#define IDS_RB_WAVEMOD                  13
#define IDS_RB_RIPPLE_BINDING           14
#define IDS_RB_WAVEBINDING              15
#define IDS_RB_DEFDEFORMATIONS          16
#define IDD_DIALOG1                     101
#define IDD_SINWAVEPARAM1               103
#define IDD_SINWAVEMODPARAM             105
#define IDD_SINWAVEOMODPARAM            131
#define IDD_LINWAVEPARAM1               132
#define IDD_LINWAVEOMODPARAM            133
#define IDD_SINWAVE_SOT                 146
#define IDC_PHASE                       1001
#define IDC_PHASESPINNER                1007
#define IDC_DECAYSPINNER                1008
#define IDC_DECAY                       1009
#define IDC_AMPLITUDE                   1011
#define IDC_AMPSPINNER                  1012
#define IDC_WAVELEN                     1013
#define IDC_WAVELENSPINNER              1014
#define IDC_CIRCLES                     1015
#define IDC_CIRCLESSPINNER              1016
#define IDC_SEGS                        1017
#define IDC_SEGSPINNER                  1018
#define IDC_DIVISIONS                   1019
#define IDC_DIVSPINNER                  1020
#define IDC_AMPSPINNER2                 1021
#define IDC_FLEX                        1021
#define IDC_AMPLITUDE2                  1022
#define IDC_FLEXSPINNER                 1022

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Ripple\RIPPLE.CPP ===
/**********************************************************************
 *<
	FILE: sinwave.cpp

	DESCRIPTION:  Simple WSM

	CREATED BY: Rolf Berteig

	HISTORY: created 9 February, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
 /*
  Note: There are six plug-ins in this file:
  	- The Ripple Space Warp Object
	- The Ripple Space Warp Modifier
	  The two above are used to create the ripple space warp.

	- The Ripple Object Space Modifier
	
	- The Wave Space Warp Object
	- The Wave Space Warp Modifier
	  The two above are used to create the wave space warp.

	- The Wave Object Space Modifier
  */
// Standard MAX include file
#include "max.h"
#include "resource.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"


HINSTANCE hInstance;

TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

// Class IDs
#define SINEWAVE_OBJECT_CID Class_ID(0x67e85eb8, 0x7c91125d)
#define LINWAVE_OBJECT_CID Class_ID(0x537901c7, 0x28cd395b)

#define SINEWAVE_CID Class_ID(0x288b4629, 0x86c6d7b)
#define LINWAVE_CID Class_ID(0x6de925d3, 0x5a8122e7) 
				
#define SINEWAVE_OMOD_CID Class_ID(0x5fbc7724, 0x7d7153ae)
#define LINWAVE_OMOD_CID Class_ID(0x340b5ca6, 0x77f602a)

// The default value for the flexability parameter.
#define DEF_FLEX		float(1.0)

// This is the function we're usin'
float WaveFunc( float radius, TimeValue t, float amp, 
				float waveLen, float phase, float decay )
	{
	if (waveLen == float(0)) {
		waveLen = float(0.0000001);
		}
	return float( amp * sin( TWOPI * ( radius/waveLen + phase ) ) 
		* exp(-decay * (float)fabs(radius) ) );
	}

BOOL CALLBACK DefaultSOTProc(
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	IObjParam *ip = (IObjParam*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			if (ip) ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			return FALSE;

		default:
			return FALSE;
		}
	return TRUE;
	}

// This is the base class used by the ripple and wave space warp objects.
class WaveObject : public SimpleWSMObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
					
		WaveObject();		

		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
				
		// from object		
		int DoOwnSelectHilite() {return TRUE;}
		CreateMouseCallBack* GetCreateMouseCallBack();
		//int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);		

		// From SimpleObject		
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		// WaveObject stuff		
		virtual int DialogID()=0;
		virtual int Circles()=0;
	};

// This is the ripple space warp object.
class SinWaveObject : public WaveObject {	
	public:				
		SinWaveObject();

		TCHAR *GetObjectName() {return GetString(IDS_RB_RIPPLE);}		
		Class_ID ClassID() {return SINEWAVE_OBJECT_CID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		IOResult Load(ILoad *iload);

		// From WSMObject
		Modifier *CreateWSMMod(INode *node);
		
		// From SimpleObject
		void MakeCircle(TimeValue t, Mesh &mesh, int startVert, int& face, float radius,float a1,float a2,float w,float s, float d, int numCircleSegs);
		void BuildMesh(TimeValue t);

		// WaveObject stuff
		int DialogID() {return IDD_SINWAVEPARAM1;}
		int Circles() {return 10;}
	};

// This is the wave space warp object.
class LinWaveObject : public WaveObject {	
	public:		
		LinWaveObject();

		TCHAR *GetObjectName() { return GetString(IDS_RB_WAVE); }
		Class_ID ClassID() { return LINWAVE_OBJECT_CID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);
		
		// From SimpleObject		
		void BuildMesh(TimeValue t);

		// WaveObject stuff
		int DialogID() {return IDD_LINWAVEPARAM1;}
		int Circles() {return 4;}
	};

//--- ClassDescriptor and class vars ---------------------------------


IObjParam *SinWaveObject::ip        = NULL;
IParamMap *SinWaveObject::pmapParam = NULL;
HWND       SinWaveObject::hSot      = NULL;

class SinWaveClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SinWaveObject; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_RIPPLE_CLASS); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return SINEWAVE_OBJECT_CID; }
	const TCHAR* 	Category() { return GetSpaceWarpCatString(SPACEWARP_CAT_GEOMDEF);}
	};

static SinWaveClassDesc swDesc;
ClassDesc* GetSinWaveObjDesc() { return &swDesc; }

class LinWaveClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new LinWaveObject; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_WAVE_CLASS); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return LINWAVE_OBJECT_CID; }
	const TCHAR* 	Category() { return GetSpaceWarpCatString(SPACEWARP_CAT_GEOMDEF);}
	};

static LinWaveClassDesc lwDesc;
ClassDesc* GetLinWaveObjDesc() { return &lwDesc; }

//--- SineWaveMod -----------------------------------------------------
// This is the base class used for the ripple and wave space warp modifiers.
class WaveMod : public SimpleWSMMod {
	public:		
		static IParamMap *pmapParam;

		WaveMod() {}
		WaveMod(INode *node,WaveObject *obj);		

		// From Animatable
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_WAVEMOD); }
		SClass_ID SuperClassID() { return WSM_CLASS_ID; }		
		void DeleteThis() {delete this;}
		void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void InvalidateUI() {if (pmapParam) pmapParam->Invalidate();}
	};

// This is the ripple space warp modifier.
class SinWaveMod : public WaveMod {
	public:		
		
		SinWaveMod() {}
		SinWaveMod(INode *node,SinWaveObject *obj) : WaveMod(node,obj) {}

		// From Animatable		
		SClass_ID SuperClassID() { return WSM_CLASS_ID; }
		Class_ID ClassID() { return SINEWAVE_CID; } 		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_RIPPLE_BINDING);}

		// From SimpleWSMMod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
	};

// This is the wave space warp modifier.
class LinWaveMod : public WaveMod {
	public:		
		
		LinWaveMod() {}
		LinWaveMod(INode *node,LinWaveObject *obj) : WaveMod(node,obj) {}

		// From Animatable		
		SClass_ID SuperClassID() { return WSM_CLASS_ID; }
		Class_ID ClassID() { return LINWAVE_CID; } 		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_WAVEBINDING);}

		// From SimpleWSMMod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
	};

//--- ClassDescriptor and class vars ---------------------------------

class SinWaveModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) { return new SinWaveMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_RIPPLE_CLASS); }
	SClass_ID		SuperClassID() { return WSM_CLASS_ID; }
	Class_ID		ClassID() { return SINEWAVE_CID; }
	const TCHAR* 	Category() { return _T("");}
	};

static SinWaveModClassDesc swModDesc;
ClassDesc* GetSinWaveModDesc() { return &swModDesc; }

class LinWaveModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) { return new LinWaveMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_WAVE_CLASS); }
	SClass_ID		SuperClassID() { return WSM_CLASS_ID; }
	Class_ID		ClassID() { return LINWAVE_CID; }
	const TCHAR* 	Category() { return _T("");}
	};

static LinWaveModClassDesc lwModDesc;
ClassDesc* GetLinWaveModDesc() { return &lwModDesc; }

IParamMap *WaveMod::pmapParam = NULL;


//--- Object Space Modifier versions -----------------------------------------
// This is the base class for the ripple and wave object space modifiers.
class WaveOMod : public SimpleMod {
	public:		
		static IParamMap *pmapParam;

		WaveOMod();

		// From Animatable
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_WAVEMOD); }		
		void DeleteThis() {delete this;}
		void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);		
		
		// From SimpleMod		
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void InvalidateUI() {if (pmapParam) pmapParam->Invalidate();}

		virtual int DialogID()=0;
	};

// This is the wave object space modifier.
class SinWaveOMod : public WaveOMod {
	public:
		// From Animatable		
		Class_ID ClassID() { return SINEWAVE_OMOD_CID; } 		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_RIPPLE);}

		// From SimpleMod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
		int DialogID() {return IDD_SINWAVEOMODPARAM;}
	};


// This is the wave object space modifier.
class LinWaveOMod : public WaveOMod {
	public:		
		// From Animatable		
		Class_ID ClassID() { return LINWAVE_OMOD_CID; } 
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_WAVE);}

		// From SimpleMod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
		int DialogID() {return IDD_LINWAVEOMODPARAM;}
	};

//--- ClassDescriptor and class vars ---------------------------------

IParamMap *WaveOMod::pmapParam = NULL;


class SinWaveOModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SinWaveOMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_RIPPLE_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return SINEWAVE_OMOD_CID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static SinWaveOModClassDesc swOModDesc;
ClassDesc* GetSinWaveOModDesc() { return &swOModDesc; }

class LinWaveOModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) {return new LinWaveOMod;}
	const TCHAR *	ClassName() { return GetString(IDS_RB_WAVE_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return LINWAVE_OMOD_CID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static LinWaveOModClassDesc lwOModDesc;
ClassDesc* GetLinWaveOModDesc() { return &lwOModDesc; }

//--- SineWaveObject Parameter map/block descriptors ------------------
// The parameter map descriptors define the properties of a parameter
// such as the type (spinner, radio button, check box, etc.), which
// resource ID they refer to, and which index into the virtual array
// they use.
#define PB_AMPLITUDE	0
#define PB_AMPLITUDE2	1
#define PB_WAVELEN		2
#define PB_PHASE		3
#define PB_DECAY		4

#define PB_CIRCLES		5
#define PB_SEGMENTS		6
#define PB_DIVISIONS	7

// This one is the older version.
static ParamUIDesc descParamObj[] = {
	
	// Amplitude 1
	ParamUIDesc(
		PB_AMPLITUDE,
		EDITTYPE_UNIVERSE,
		IDC_AMPLITUDE,IDC_AMPSPINNER,
		-9999999.0f, 9999999.0f,
		SPIN_AUTOSCALE),	

	// Amplitude 2
	ParamUIDesc(
		PB_AMPLITUDE2,
		EDITTYPE_UNIVERSE,
		IDC_AMPLITUDE2,IDC_AMPSPINNER2,
		-9999999.0f, 9999999.0f,
		SPIN_AUTOSCALE),	

	// Wave Length
	ParamUIDesc(
		PB_WAVELEN,
		EDITTYPE_UNIVERSE,
		IDC_WAVELEN,IDC_WAVELENSPINNER,
		-9999999.0f, 9999999.0f,
		SPIN_AUTOSCALE),	

	// Phase
	ParamUIDesc(
		PB_PHASE,
		EDITTYPE_FLOAT,
		IDC_PHASE,IDC_PHASESPINNER,
		-9999999.0f, 9999999.0f,
		0.1f),
		
	// Decay
	ParamUIDesc(
		PB_DECAY,
		EDITTYPE_FLOAT,
		IDC_DECAY,IDC_DECAYSPINNER,
		0.0f, 9999999.0f,
		0.001f),
		
	// Circles
	ParamUIDesc(
		PB_CIRCLES,
		EDITTYPE_INT,
		IDC_CIRCLES,IDC_CIRCLESSPINNER,
		3.0f, 200.0f,
		0.1f),

	// Segments
	ParamUIDesc(
		PB_SEGMENTS,
		EDITTYPE_INT,
		IDC_SEGS,IDC_SEGSPINNER,
		3.0f, 200.0f,
		0.1f),
	
	// Divisions
	ParamUIDesc(
		PB_DIVISIONS,
		EDITTYPE_INT,
		IDC_DIVISIONS,IDC_DIVSPINNER,
		1.0f, 200.0f,
		0.1f)
	};
#define OBJPARAMDESC_LENGH 8


// The parameter block descriptor defines the type of value represented
// by the parameter (int, float, Color...) and if it is animated or not.

// This class requires these values to be initialized:
// { - ParameterType, 
//   - Not Used, must be set to NULL, 
//   - Flag which indicates if the parameter is animatable,
//   - ID of the parameter used to match a corresponding ID in the 
//     other version of the parameter
//  }
ParamBlockDescID descObjVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 } };

// This is the current version.
ParamBlockDescID descObjVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 } };

#define OBJPBLOCK_LENGTH	8


// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descObjVer0,7,0)
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_OBJVERSION	1
static ParamVersionDesc curVersion(descObjVer1,OBJPBLOCK_LENGTH,CURRENT_OBJVERSION);



//--- SineWaveObject methods ------------------------------------------


WaveObject::WaveObject()
	{
	// Create a reference to the parameter block.
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descObjVer1, OBJPBLOCK_LENGTH, CURRENT_OBJVERSION));
	assert(pblock);	
	}

// This method is called by the system when the user needs 
// to edit the items parameters in the command panel.  
void WaveObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	// Since we subclass off SimpleWSMObject we call it's version first.
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapParam) {
		
		// Left over from last SinWave ceated
		pmapParam->SetParamBlock(pblock);
	} else {
		hSot = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_SINWAVE_SOT),
				DefaultSOTProc,
				GetString(IDS_RB_SOT), 
				(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		// Here we create each new rollup page in the command panel
		// using our descriptors.
		pmapParam = CreateCPParamMap(
			descParamObj,OBJPARAMDESC_LENGH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(DialogID()),
			GetString(IDS_RB_PARAMETERS),
			0);		
		}
	}

// This is called by the system to terminate the editing of the
// parameters in the command panel.  
void WaveObject::EndEditParams(IObjParam *ip, ULONG flags,Animatable *next)
	{		
	// Since we subclass off SimpleWSMObject we call it's version first.
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {				
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	}

// Declare a class derived from CreateMouseCallBack to handle
// the user input during the creation phase of the item.
class SinWaveObjCreateCallBack: public CreateMouseCallBack {	
	WaveObject *ob;	
	Point3 p0, p1;
	IPoint2 sp0, sp1;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		void SetObj(WaveObject *obj) { ob = obj; }
	};

// This is the method that actually handles the user input
// during the item's creation phase.
int SinWaveObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float w;	

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:  // only happens with MOUSE_POINT msg
				sp0    = m;
				p0     = vpt->GetPointOnCP(m);
				mat.SetTrans(p0);
				break;
			case 1:								
				sp1 = m;		
				p1  = vpt->GetPointOnCP(m);
				w   = float(4)*Length(p0-p1)/ob->Circles();
				ob->pblock->SetValue(PB_WAVELEN,0,w);
				ob->pmapParam->Invalidate();
				break;
			case 2:	
				if ( Length(sp1-sp0)<3 ) return CREATE_ABORT;			
				w = vpt->GetCPDisp(p1,Point3(0,0,1),sp1,m);				
				ob->pblock->SetValue(PB_AMPLITUDE,0,w);
				ob->pblock->SetValue(PB_AMPLITUDE2,0,w);
				ob->pmapParam->Invalidate();				
				if (msg==MOUSE_POINT) 
					return CREATE_STOP;
				break;					   
			}
		}
	else
	if (msg == MOUSE_ABORT)
		return CREATE_ABORT;

	return TRUE;
	}

// A single instance of the callback object.
static SinWaveObjCreateCallBack sinwaveCreateCB;

// This method allows MAX to access and call our proc method to 
// handle the user input.
CreateMouseCallBack* WaveObject::GetCreateMouseCallBack()
	{
	sinwaveCreateCB.SetObj(this);
	return &sinwaveCreateCB;
	}

// Called when the UI controls need to be updated to reflect a new time.
void WaveObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

// The dimension of each parameter.
ParamDimension *WaveObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_AMPLITUDE:	return stdWorldDim;		
		case PB_AMPLITUDE2:	return stdWorldDim;	
		case PB_WAVELEN: 	return stdWorldDim;		
		case PB_PHASE:		return stdNormalizedDim;		
		case PB_DECAY:		return stdNormalizedDim;			
		default:			return defaultDim;
		}
	}

// The name of each parameter.
TSTR WaveObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_AMPLITUDE:	return GetString(IDS_RB_AMPLITUDE1);
		case PB_AMPLITUDE2:	return GetString(IDS_RB_AMPLITUDE2);
		case PB_WAVELEN:	return GetString(IDS_RB_WAVELEN);
		case PB_PHASE:		return GetString(IDS_RB_PHASE);
		case PB_DECAY:		return GetString(IDS_RB_DECAY);
		default:			return TSTR(_T(""));
		}
	}



//--- Circular sine wave ---------------------------------------------

SinWaveObject::SinWaveObject()
	{
	pblock->SetValue(PB_CIRCLES, TimeValue(0), 10);
	pblock->SetValue(PB_SEGMENTS, TimeValue(0), 16);
	pblock->SetValue(PB_DIVISIONS, TimeValue(0), 4);
	}

IOResult SinWaveObject::Load(ILoad *iload)
	{
	// This is the callback that corrects for any older versions
	// of the parameter block structure found in the MAX file 
	// being loaded.
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}

// When the user binds an object to a space warp, a new modifier
// must be created which is added to the nodes WSM derived object.
// This is the method called by the system when it needs this
// new modifier.
Modifier *SinWaveObject::CreateWSMMod(INode *node)
	{
	return new SinWaveMod(node,this);
	}

// Make a copy of the object and the parameter block.
RefTargetHandle SinWaveObject::Clone(RemapDir& remap) 
	{
	SinWaveObject* newob = new SinWaveObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	return(newob);
	}

static void MakeQuad(Face *f, int a,  int b , int c , int d, int sg, int dv = 0) {
	f[0].setVerts( a+dv, b+dv, c+dv);
	f[0].setSmGroup(sg);
	f[0].setEdgeVisFlags(1,1,0);
	f[1].setVerts( c+dv, d+dv, a+dv);
	f[1].setSmGroup(sg);
	f[1].setEdgeVisFlags(1,1,0);
	}

void SinWaveObject::MakeCircle(TimeValue t, Mesh &mesh, 
		int startVert, int& face, float radius,
		float a1,float a2,float w,float s, float d, int numCircleSegs)
	{
	float x, y, z, u, u2;			

	for ( int i = startVert; i < startVert+numCircleSegs; i++ ) {
		u = float(i-startVert) / float(numCircleSegs);
		x = radius * (float)cos( u * TWOPI );
		y = radius * (float)sin( u * TWOPI );		
		
		u2 = (u > 0.5f) ? (u-0.5f) : u;
		u2 = (u2 > 0.25f) ? (0.5f-u2) : u2;
		u2 = u2 * 4.0f;
		u2 = u2*u2;
		z = WaveFunc(radius, t, a1*(1.0f-u2) + a2*u2, w, s, d);

		if ( startVert == 0 ) {
			mesh.setVert( i+1, Point3(x, y, z) );
		} else {
			mesh.setVert( numCircleSegs + i, Point3(x, y, z) );
		
			if ( i < startVert+numCircleSegs-1 ) {
				MakeQuad(&(mesh.faces[face]), 
					i+numCircleSegs,i+numCircleSegs+1,i+1,i,1);
				face += 2;
			} else {
				MakeQuad(&(mesh.faces[face]), 
					i+numCircleSegs,startVert+numCircleSegs,startVert,i,1);
				face += 2;
				}
			}
		}
	}

// Builds the mesh representation for the ripple based on the
// state of it's parameters at the time requested.
void SinWaveObject::BuildMesh(TimeValue t)
	{		
	int startVert = 1, face = 0, nverts, nfaces, numCircles, numCircleSegs, divs;
	float radius = float(0);
	float dr;
	float a, a2, w, s, d;	

	ivalid = FOREVER;
	pblock->GetValue(PB_AMPLITUDE,t,a,ivalid);
	pblock->GetValue(PB_AMPLITUDE2,t,a2,ivalid);
	pblock->GetValue(PB_WAVELEN,t,w,ivalid);
	pblock->GetValue(PB_PHASE,t,s,ivalid);
	pblock->GetValue(PB_DECAY,t,d,ivalid);
	pblock->GetValue(PB_SEGMENTS,t,numCircleSegs,ivalid);
	pblock->GetValue(PB_CIRCLES,t,numCircles,ivalid);
	pblock->GetValue(PB_DIVISIONS,t,divs,ivalid);
	LimitValue(d,0.0f,float(1.0E30));

	dr     = w/float(divs);
	nverts = numCircles * numCircleSegs + 1;
	nfaces = (numCircles-1) * numCircleSegs * 2;
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);

	mesh.setVert( 0, Point3(0,0,0) );
	MakeCircle(t,mesh,0,face,radius, a, a2, w, s, d, numCircleSegs);

	for ( int i = 1; i < numCircles; i++ ) {
		MakeCircle(t,mesh,startVert,face,radius, a, a2, w, s, d, numCircleSegs);
		startVert += numCircleSegs;
		radius += dr;
		}
	
	mesh.InvalidateGeomCache();
	}


//--- Linear sine wave ---------------------------------------------

LinWaveObject::LinWaveObject()
	{
	pblock->SetValue(PB_CIRCLES, TimeValue(0), 4);
	pblock->SetValue(PB_SEGMENTS, TimeValue(0), 20);
	pblock->SetValue(PB_DIVISIONS, TimeValue(0), 10);
	}

// When the user binds an object to a space warp, a new modifier
// must be created which is added to the nodes WSM derived object.
// This is the method called by the system when it needs this
// new modifier.
Modifier *LinWaveObject::CreateWSMMod(INode *node)
	{
	return new LinWaveMod(node,this);
	}

// Make a copy of the object and the parameter block.
RefTargetHandle LinWaveObject::Clone(RemapDir& remap) 
	{
	LinWaveObject* newob = new LinWaveObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	return(newob);
	}

// Builds the mesh representation for the wave based on the
// state of it's parameters at the time requested.
void LinWaveObject::BuildMesh(TimeValue t)
	{		
	int startVert = 1, face = 0, nverts, nfaces, numSides, numSegs, divs;
	float radius = float(0);
	float dx, dy, starty, startx;
	float a, a2, w, s, d, x, y, z, u;	
	int nv=0, nf=0, ix, den;

	ivalid = FOREVER;
	pblock->GetValue(PB_AMPLITUDE,t,a,ivalid);
	pblock->GetValue(PB_AMPLITUDE2,t,a2,ivalid);
	pblock->GetValue(PB_WAVELEN,t,w,ivalid);
	pblock->GetValue(PB_PHASE,t,s,ivalid);
	pblock->GetValue(PB_DECAY,t,d,ivalid);
	pblock->GetValue(PB_SEGMENTS,t,numSegs,ivalid);
	pblock->GetValue(PB_CIRCLES,t,numSides,ivalid);
	pblock->GetValue(PB_DIVISIONS,t,divs,ivalid);	
	LimitValue(d,0.0f,float(1.0E30));
	
	dy     = w/float(divs);
	dx     = dy * 4;
	starty = -float(numSegs)/2.0f * dy;
	startx = -float(numSides)/2.0f * dx;
	nverts = (numSides+1) * (numSegs+1);
	nfaces = (numSides) * numSegs * 2;
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);

	
	for (int i=0; i<=numSides; i++) {
		x   = startx + dx * float(i);		
		den = (int)(dx*numSides*0.5f);
		u   = (float)fabs(x/(den?den:0.00001f));		
		u   = u*u;
		//u = smoothstep(0.0f,1.0f,u);
		for (int j=0; j<=numSegs; j++) {
			y = starty + float(j) * dy;
			z = WaveFunc(y, t, a*(1.0f-u)+a2*u, w, s, d);
			mesh.setVert(nv++,Point3(x, y, z));			
			}
		}
		
	for (i=0; i<numSides; i++) {
		ix = i * (numSegs+1);
		for (int j=0; j<numSegs; j++) {
			MakeQuad(&(mesh.faces[nf]), 
				ix+numSegs+1+j, ix+numSegs+2+j, ix+1+j, ix+j, 1);				
			nf += 2;
			}
		}
	
	assert(nv==mesh.numVerts);
	assert(nf==mesh.numFaces);
	mesh.InvalidateGeomCache();
	}



/*----------------------------------------------------------------*/
// Sine Wave modifier


//--- Parameter map/block descriptors -----------------------------

#define PB_FLEX			0

//
//
// Parameters

static ParamUIDesc descParamMod[] = {
	// Angle
	ParamUIDesc(
		PB_FLEX,
		EDITTYPE_FLOAT,
		IDC_FLEX,IDC_FLEXSPINNER,
		-10.0f,10.0f,
		0.01f)
	};
#define MODPARAMDESC_LENGH 1

ParamBlockDescID descModVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 } };

#define MODPBLOCK_LENGTH	1

#define CURRENT_MODVERSION	0

//--- SinWaveDeformer  --------------------------------------

// This the the class whose Map method is called to deforms each point.
class SinWaveDeformer : public Deformer {
	public:
		float amp, amp2, wave, phase, decay, flex;
		TimeValue time;
		Matrix3 tm, itm;		
		Point3 Map(int i, Point3 p); 
	};

// This is the deformers callback method which gets called for each point. 
Point3 SinWaveDeformer::Map(int i, Point3 p)
	{
	Point3 pt = p * tm;
	float r, oldZ, u, a, len;
		
	if (amp!=amp2) {
		len  = Length(pt);
		if (len==0.0f) {
			a = amp;
		} else {
			u = (float)acos(pt.x/len)/PI;
	 		u = (u > 0.5) ? (1.0f-u) : u;
			u *= 2.0f;
	 		//u = u*u;
	 		u = smoothstep(0.0f,1.0f,u);
	 		a = amp*(1.0f-u) + amp2*u;
			}
	} else {
		a = amp;
		}	
	
	oldZ = pt.z;
	pt.z = float(0);	
	r    = Length(pt);
	pt.z = oldZ + flex * WaveFunc(r, time, a, wave, phase, decay);
	return pt * itm;
	}

// This the the class whose Map method is called to deforms each point.
class LinWaveDeformer : public Deformer {
	public:
		float amp, amp2, wave, phase, decay, flex, dist;
		TimeValue time;
		Matrix3 tm, itm;		
		Point3 Map(int i, Point3 p); 
	};

// This is the deformers callback method which gets called for each point. 
Point3 LinWaveDeformer::Map(int i, Point3 p)
	{
	Point3 pt = p * tm;	
	float u = (float)fabs(2.0f*pt.x/dist);
	u = u*u;
	pt.z += flex * WaveFunc(pt.y, time, amp*(1.0f-u)+amp2*u, wave, phase, decay);
	return pt * itm;
	}

//--- WaveMod methods -----------------------------------------


WaveMod::WaveMod(INode *node,WaveObject *obj)
	{	
	// Make the reference to the space warp node.
	// Note that the reference index (SIMPWSMMOD_NODEREF) and the 
	// reference target handle (node) are both part of the SimpleWSMMod
	// base class.
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
		// Make the reference to the parameter block.
	// Note that the reference index (SIMPWSMMOD_PBLOCKREF) and the 
	// reference target handle (pblock) are both part of the SimpleWSMMod
	// base class.
	MakeRefByID(FOREVER, SIMPWSMMOD_PBLOCKREF, 
		CreateParameterBlock(descModVer0, MODPBLOCK_LENGTH, CURRENT_MODVERSION));
	obRef = NULL;
	pblock->SetValue(PB_FLEX, TimeValue(0), DEF_FLEX);
	}

// This method is called by the system when the user needs 
// to edit the item's parameters in the command panel.  
void WaveMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	// Call the base class method first.
	SimpleWSMMod::BeginEditParams(ip,flags,prev);
		
	// Create the parameter map and rollup page.
	pmapParam = CreateCPParamMap(
		descParamMod,MODPARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_SINWAVEMODPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);		
	}
		
// This is called by the system to terminate the editing of the
// parameters in the command panel.  
void WaveMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleWSMMod::EndEditParams(ip,flags,next);
	DestroyCPParamMap(pmapParam);
	}

Interval WaveMod::GetValidity(TimeValue t) 
	{
	if (nodeRef) {
		// Start the interval at FOREVER.
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;
		pblock->GetValue(PB_FLEX,t,f,valid);
		SinWaveObject *obj = (SinWaveObject*)GetWSMObject(t);
		// Whittle the interval down using each of the animated parameters
		// of the modifier.
		obj->pblock->GetValue(PB_AMPLITUDE,t,f,valid);
		obj->pblock->GetValue(PB_AMPLITUDE2,t,f,valid);
		obj->pblock->GetValue(PB_WAVELEN,t,f,valid);
		obj->pblock->GetValue(PB_PHASE,t,f,valid);
		obj->pblock->GetValue(PB_DECAY,t,f,valid);
		tm = nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {
		return FOREVER;
		}
	}

ParamDimension *WaveMod::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_FLEX: 	return stdNormalizedDim;
		default:		return defaultDim;
		}	
	}

TSTR WaveMod::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_FLEX: 	return GetString(IDS_RB_FLEXIBILITY);
		default:		return GetString(IDS_RB_PARAMETERS);
		}
	}


// --- SinWaveMod -------
// Returns a reference to the callback object to handle the deformation.
Deformer& SinWaveMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	Interval valid;
	static SinWaveDeformer sd;
	pblock->GetValue(PB_FLEX,t,sd.flex,FOREVER);
	SinWaveObject *obj = (SinWaveObject*)GetWSMObject(t);
	obj->pblock->GetValue(PB_AMPLITUDE,t,sd.amp,FOREVER);
	obj->pblock->GetValue(PB_AMPLITUDE2,t,sd.amp2,FOREVER);
	obj->pblock->GetValue(PB_WAVELEN,t,sd.wave,FOREVER);
	obj->pblock->GetValue(PB_PHASE,t,sd.phase,FOREVER);
	obj->pblock->GetValue(PB_DECAY,t,sd.decay,FOREVER);
	LimitValue(sd.decay,0.0f,float(1.0E30));

	sd.time = t;
	//sd.itm  = nodeRef->GetNodeTM(t,&valid);
	sd.itm  = nodeRef->GetObjectTM(t,&valid);
	sd.tm   = Inverse( sd.itm );
	return sd;
	}

// This method makes a new modifier and copies the state of this modifier
// to the new modifier.  This is called when the user makes a copy of
// an object in the scene or when they press the make unique
// button in the modfier stack rollup page.
RefTargetHandle SinWaveMod::Clone(RemapDir& remap) 
	{
	SinWaveMod *newob = new SinWaveMod(nodeRef,(SinWaveObject*)obRef);
	newob->SimpleWSMModClone(this);
	return newob;
	}

// --- LinWaveMod -------
// Returns a reference to the callback object to handle the deformation.
Deformer& LinWaveMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	Interval valid;
	static LinWaveDeformer ld;
	pblock->GetValue(PB_FLEX,t,ld.flex,FOREVER);
	LinWaveObject *obj = (LinWaveObject*)GetWSMObject(t);
	obj->pblock->GetValue(PB_AMPLITUDE,t,ld.amp,FOREVER);
	obj->pblock->GetValue(PB_AMPLITUDE2,t,ld.amp2,FOREVER);
	obj->pblock->GetValue(PB_WAVELEN,t,ld.wave,FOREVER);
	obj->pblock->GetValue(PB_PHASE,t,ld.phase,FOREVER);
	obj->pblock->GetValue(PB_DECAY,t,ld.decay,FOREVER);
	LimitValue(ld.decay,0.0f,float(1.0E30));

	ld.time = t;
	//ld.itm  = nodeRef->GetNodeTM(t,&valid);
	ld.itm  = nodeRef->GetObjectTM(t,&valid);
	ld.tm   = Inverse(ld.itm);
	//ld.dist = mc.box ? mc.box->Width().x : (4.0f*ld.wave);
	//ld.dist = (2.0f*ld.wave); // Use wave length for the WSM version
		
	int numSides, divs;
	obj->pblock->GetValue(PB_CIRCLES,t,numSides,FOREVER);
	obj->pblock->GetValue(PB_DIVISIONS,t,divs,FOREVER);	
	ld.dist = (ld.wave/float(divs)) * 4.0f * float(numSides);

	if (ld.dist == 0.0f) ld.dist = 1.0f;
	return ld;
	}

// This method makes a new modifier and copies the state of this modifier
// to the new modifier.  This is called when the user makes a copy of
// an object in the scene or when they press the make unique
// button in the modfier stack rollup page.
RefTargetHandle LinWaveMod::Clone(RemapDir& remap) 
	{
	LinWaveMod *newob = new LinWaveMod(nodeRef,(LinWaveObject*)obRef);
	newob->SimpleWSMModClone(this);
	return newob;
	}



//--- Parameter map/block descriptors -----------------------------

//
//
// Parameters

static ParamUIDesc descParamOMod[] = {
	
	// Amplitude 1
	ParamUIDesc(
		PB_AMPLITUDE,
		EDITTYPE_UNIVERSE,
		IDC_AMPLITUDE,IDC_AMPSPINNER,
		-9999999.0f, 9999999.0f,
		SPIN_AUTOSCALE),	

	// Amplitude 2
	ParamUIDesc(
		PB_AMPLITUDE2,
		EDITTYPE_UNIVERSE,
		IDC_AMPLITUDE2,IDC_AMPSPINNER2,
		-9999999.0f, 9999999.0f,
		SPIN_AUTOSCALE),	

	// Wave Length
	ParamUIDesc(
		PB_WAVELEN,
		EDITTYPE_UNIVERSE,
		IDC_WAVELEN,IDC_WAVELENSPINNER,
		-9999999.0f, 9999999.0f,
		SPIN_AUTOSCALE),	

	// Phase
	ParamUIDesc(
		PB_PHASE,
		EDITTYPE_FLOAT,
		IDC_PHASE,IDC_PHASESPINNER,
		-9999999.0f, 9999999.0f,
		0.1f),
		
	// Decay
	ParamUIDesc(
		PB_DECAY,
		EDITTYPE_FLOAT,
		IDC_DECAY,IDC_DECAYSPINNER,
		0.0f, 9999999.0f,
		0.001f),
	};
#define OMODPARAMDESC_LENGH 5

// The parameter block descriptor defines the type of value represented
// by the parameter (int, float, Color...) and if it is animated or not.

// This class requires these values to be initialized:
// { - ParameterType, 
//   - Not Used, must be set to NULL, 
//   - Flag which indicates if the parameter is animatable,
//   - ID of the parameter used to match a corresponding ID in the 
//     other version of the parameter block.
//  }
ParamBlockDescID descOModVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 } };
#define OMODPBLOCK_LENGTH	5

#define CURRENT_OMODVERSION	0


//--- WaveOMod methods -----------------------------------------


WaveOMod::WaveOMod()
	{		
	// Create a reference to the parameter block.
	// SimpleMod maintains the parameter block pointer.
	// Note that SimpleMod uses two references itself.  It provides us
	// with a #define that specifies the reference index of the parameter
	// block.  This is SIMPMOD_PBLOCKREF.
	MakeRefByID(FOREVER, SIMPMOD_PBLOCKREF, 
		CreateParameterBlock(descOModVer0, OMODPBLOCK_LENGTH, CURRENT_OMODVERSION));
	
	pblock->SetValue(PB_WAVELEN,0,50.0f);
	}


// This method is called by the system when the user needs 
// to edit the modifiers parameters in the command panel.  
void WaveOMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	// Call the SimpleMod method first to take care of its processing.
	SimpleMod::BeginEditParams(ip,flags,prev);
		
	// Create the rollup page in the command panel using our descriptors.
	pmapParam = CreateCPParamMap(
		descParamOMod,OMODPARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(DialogID()),
		GetString(IDS_RB_PARAMETERS),
		0);		
	}
		
// This is called by the system to terminate the editing of the
// parameters in the command panel.  
void WaveOMod::EndEditParams(IObjParam *ip, ULONG flags,Animatable *next)
	{
	SimpleMod::EndEditParams(ip,flags,next);
	DestroyCPParamMap(pmapParam);
	}

// This returns the vality interval of the modifier. The SimpleMod
// class calls this method and combines the result with the 
// validity interval of the controllers controlling the gizmo and center
// to form the total validity interval.
Interval WaveOMod::GetValidity(TimeValue t) 
	{	
	Interval valid = FOREVER;	
	float f;	
	pblock->GetValue(PB_AMPLITUDE,t,f,valid);
	pblock->GetValue(PB_AMPLITUDE2,t,f,valid);
	pblock->GetValue(PB_WAVELEN,t,f,valid);
	pblock->GetValue(PB_PHASE,t,f,valid);
	pblock->GetValue(PB_DECAY,t,f,valid);	
	return valid;	
	}

ParamDimension *WaveOMod::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_AMPLITUDE:	return stdWorldDim;			
		case PB_AMPLITUDE2:	return stdWorldDim;	
		case PB_WAVELEN: 	return stdWorldDim;		
		case PB_PHASE:		return stdNormalizedDim;		
		case PB_DECAY:		return stdNormalizedDim;			
		default:			return defaultDim;
		}
	}

TSTR WaveOMod::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_AMPLITUDE:	return GetString(IDS_RB_AMPLITUDE1);
		case PB_AMPLITUDE2:	return GetString(IDS_RB_AMPLITUDE2);
		case PB_WAVELEN:	return GetString(IDS_RB_WAVELEN);
		case PB_PHASE:		return GetString(IDS_RB_PHASE);
		case PB_DECAY:		return GetString(IDS_RB_DECAY);
		default:			return TSTR(_T(""));
		}
	}


//--- SinWaveOMod methods -----------------------------------------

// Returns a reference to the callback object to handle the deformation.
Deformer& SinWaveOMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	Interval valid;
	static SinWaveDeformer sd;	
	pblock->GetValue(PB_AMPLITUDE,t,sd.amp,FOREVER);
	pblock->GetValue(PB_AMPLITUDE2,t,sd.amp2,FOREVER);
	pblock->GetValue(PB_WAVELEN,t,sd.wave,FOREVER);
	pblock->GetValue(PB_PHASE,t,sd.phase,FOREVER);
	pblock->GetValue(PB_DECAY,t,sd.decay,FOREVER);
	LimitValue(sd.decay,0.0f,float(1.0E30));
	sd.time = t;
	sd.itm  = invmat;
	sd.tm   = mat;
	sd.flex = 1.0f;
	return sd;
	}

// This method makes a new modifier and copies the state of this modifier
// to the new modifier.  This is called when the user makes a copy of
// an object in the scene or when they press the make unique
// button in the modfier stack rollup page.
RefTargetHandle SinWaveOMod::Clone(RemapDir& remap) 
	{
	SinWaveOMod *newob = new SinWaveOMod();
	newob->ReplaceReference(SIMPMOD_PBLOCKREF,pblock->Clone(remap));
	newob->SimpleModClone(this);
	return newob;
	}


//--- LinWaveOMod methods -----------------------------------------

// Returns a reference to the callback object to handle the deformation.
Deformer& LinWaveOMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	Interval valid;
	static LinWaveDeformer ld;	
	pblock->GetValue(PB_AMPLITUDE,t,ld.amp,FOREVER);
	pblock->GetValue(PB_AMPLITUDE2,t,ld.amp2,FOREVER);
	pblock->GetValue(PB_WAVELEN,t,ld.wave,FOREVER);
	pblock->GetValue(PB_PHASE,t,ld.phase,FOREVER);
	pblock->GetValue(PB_DECAY,t,ld.decay,FOREVER);
	LimitValue(ld.decay,0.0f,float(1.0E30));
	ld.time = t;
	ld.itm  = invmat;
	ld.tm   = mat;
	ld.flex = 1.0f;
	ld.dist = mc.box ? mc.box->Width().x : (4.0f*ld.wave);
	return ld;
	}

// This method makes a new modifier and copies the state of this modifier
// to the new modifier.  This is called when the user makes a copy of
// an object in the scene or when they press the make unique
// button in the modfier stack rollup page.
RefTargetHandle LinWaveOMod::Clone(RemapDir& remap) 
	{
	LinWaveOMod *newob = new LinWaveOMod();
	newob->ReplaceReference(SIMPMOD_PBLOCKREF,pblock->Clone(remap));
	newob->SimpleModClone(this);
	return newob;
	}

// See the Advanced Topics section on DLL Functions and Class Descriptors
// for more information.
/*===========================================================================*\
 | The Class Descriptors
\*===========================================================================*/
// ***

// The following five functions are used by every plug-in DLL.
// See the Advanced Topics section on DLL Functions and Class Descriptors
// for more information.
/*===========================================================================*\
 | The DLL Functions
\*===========================================================================*/
// This function is called by Windows when the DLL is loaded for the first time
// or an executable links to the DLL. Since only one instance of MAX can be
// run at one time, this function will only get called once when MAX starts up.
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

	// Initialize MAX's custom controls
	InitCustomControls(hInstance);
		
	// Initialize Win95 controls
	InitCommonControls();
	
	return(TRUE);
	}

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int LibNumberClasses() {return 6;}

// This function return the ith class descriptor
__declspec( dllexport ) ClassDesc *LibClassDesc(int i) {
	switch(i) {
		case 0: return GetSinWaveObjDesc();
		case 1: return GetSinWaveModDesc();
		case 2: return GetSinWaveOModDesc();

		case 3: return GetLinWaveObjDesc();
		case 4: return GetLinWaveModDesc();
		case 5: return GetLinWaveOModDesc();
		default: return 0;
		}
	}

// This function returns a string that describes the DLL.
// could purchase the DLL if they don't have it.
__declspec( dllexport ) const TCHAR *LibDescription() { return _T("Ripple-Wave"); }

// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG LibVersion() {  return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Sphere_c\RESOURCE.H ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Sphere_c.rc
//
#define IDS_RB_SPHERE                   1
#define IDS_RB_SPHERE_CLASS             2
#define IDS_RB_HOWTO                    3
#define IDS_RB_CREATIONMETHOD           4
#define IDS_RB_KEYBOARDENTRY            5
#define IDS_RB_PARAMETERS               6
#define IDS_CT_SURF                     7
#define IDS_CT_CAP                      8
#define IDS_SM_NURBS_SURFACE            9
#define IDS_RB_RADIUS                   10
#define IDS_RB_HEMISPHERE               11
#define IDS_RB_SEGS                     12
#define IDS_RB_SMOOTH                   13
#define IDS_LIB_DESC                    14
#define IDD_SPHEREPARAM2                101
#define IDD_SPHEREPARAM1                113
#define IDD_SPHEREPARAM3                139
#define IDC_RADIUS                      1000
#define IDC_SEGMENTS                    1001
#define IDC_CREATEDIAMETER              1002
#define IDC_HEMISPHERE                  1002
#define IDC_CREATERADIUS                1003
#define IDC_SEGSPINNER                  1004
#define IDC_RADSPINNER                  1005
#define IDC_OBSMOOTH                    1006
#define IDC_HEMISPHERESPINNER           1007
#define IDC_HEMI_RECENTER               1020
#define IDC_HEMI_SQUASH                 1023
#define IDC_HEMI_CHOP                   1024
#define IDC_GENTEXTURE                  1028
#define IDC_TI_POSX                     3019
#define IDC_TI_POSXSPIN                 3020
#define IDC_TI_POSY                     3021
#define IDC_TI_POSYSPIN                 3022
#define IDC_TI_CREATE                   3023
#define IDC_TI_POSZ                     3024
#define IDC_TI_POSZSPIN                 3025

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\TMatTest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tmattest.rc
//
#define IDD_MAIN                        103
#define IDD_ROT                         106
#define IDD_TRANS                       107
#define IDD_SCALE                       110
#define IDD_VIEW                        111
#define IDD_VIEW_TM                     113
#define IDD_VIEW_FLOAT                  114
#define IDC_VIEW_CURRENT                1000
#define IDC_CHECK_USE_Z                 1001
#define IDC_OBJECTTM                    1001
#define IDC_CHECK_USE_Y                 1002
#define IDC_OBJTMBEFORE                 1002
#define IDC_CHECK_USE_X                 1003
#define IDC_OBJTMAFTER                  1003
#define IDC_CHECK_USE_TR                1004
#define IDC_PARENTTM                    1004
#define IDC_CHECK_USE_SC                1005
#define IDC_TARGETTM                    1005
#define IDC_NODE_TM                     1006
#define IDC_SEDIT_ROT                   1006
#define IDC_OBJECTSTATE                 1006
#define IDC_RESET                       1007
#define IDC_SPIN_ROT                    1007
#define IDC_TM                          1007
#define IDC_CHECK_AUTO                  1008
#define IDC_OBJ_OFFSET                  1008
#define IDC_BUTTON_VIEW                 1010
#define IDC_SEDIT_XTR                   1011
#define IDC_SPIN_XTR                    1012
#define IDC_SPIN_YTR                    1013
#define IDC_SEDIT_YTR                   1014
#define IDC_SPIN_ZTR                    1015
#define IDC_SEDIT_ZTR                   1016
#define IDC_BUTTON_EDITTR               1017
#define IDC_M00                         1018
#define IDC_SEDIT_XSC                   1019
#define IDC_M10                         1019
#define IDC_SPIN_XSC                    1020
#define IDC_M20                         1020
#define IDC_SEDIT_YSC                   1021
#define IDC_M30                         1021
#define IDC_SPIN_YSC                    1022
#define IDC_M01                         1022
#define IDC_SEDIT_ZSC                   1023
#define IDC_M11                         1023
#define IDC_SPIN_ZSC                    1024
#define IDC_M21                         1024
#define IDC_M31                         1025
#define IDC_M02                         1026
#define IDC_BUTTON_EDITSC               1026
#define IDC_M12                         1027
#define IDC_M22                         1028
#define IDC_M32                         1029
#define IDC_C                           1029
#define IDC_S                           1030
#define IDC_VIEW_TITLE                  1034
#define IDC_RADIOX                      1035
#define IDC_VIEW_TITLE2                 1035
#define IDC_RADIOY                      1036
#define IDC_VIEW_TITLE3                 1036
#define IDC_RADIOZ                      1037
#define IDC_VIEW_TITLE4                 1037
#define IDC_MATLINE1                    1038
#define IDC_MATLINE2                    1039
#define IDC_MATLINE3                    1040
#define IDC_BORDER                      1041
#define IDC_MATLINE4                    1042
#define IDC_NODETM                      1046

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1047
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\Sphere_c\SPHERE_C.CPP ===
/*===========================================================================*\
  How To Create a Procedural Object Plug-In

  FILE: sphere_c.cpp
 
  DESCRIPTION:  Sphere object, Revised implementation

  CREATED BY: Rolf Berteig

  HISTORY: created 10/10/95

  Copyright (c) 1994, All Rights Reserved.
\*===========================================================================*/
#include "resource.h"
#include "max.h"
#include "iparamm.h"
#include "simpobj.h"
#include "surf_api.h"

// This is the DLL instance handle passed in when the plug-in is 
// loaded at startup.
HINSTANCE hInstance;

// This function returns a pointer to a string in the string table of
// the resource library.  Note that this function maintains the buffer
// and that only one string is loaded at a time.  Therefore if you intend
// to use this string, you must copy to another buffer since it will 
// be overwritten on the next GetString() call.
TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

// Unique Class ID.  It is specified as two 32-bit quantities.
// These must be unique.  Use the Class_ID generator program to create
// these values.  This program is available from the main menu of the
// help file.
#define SPHERE_C_CLASS_ID Class_ID(0x3d7f05b6, 0x63657b8)

// The sphere object class definition.  It is derived from SimpleObject and
// IParamArray.  SimpleObject is the class to derive objects from which have 
// geometry are renderable, and represent themselves using a mesh.  
// IParamArray is used as part of the Parameter Map scheme used to manage
// the user interface parameters.
class SphereObject : public GenSphere, public IParamArray {
	public:			
		// Class variables
		// There is only one set of these variables shared by all instances
		// of this class.  This is OK because there is only one sphere
		// being edited at a time.
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static int dlgSegments;
		static int dlgCreateMeth;
		static int dlgSmooth;
		static Point3 crtPos;		
		static float crtRadius;
		// This is the Interface pointer into MAX.  It is used to call
		// functions implemented in MAX itself.  
		static IObjParam *ip;

		// --- Inherited virtual methods of Animatable ---
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return SPHERE_C_CLASS_ID; } 
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);

		// --- Inherited virtual methods of ReferenceMaker ---
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);

		// --- Inherited virtual methods of ReferenceTarget ---
		RefTargetHandle Clone(RemapDir& remap = NoRemap());

		// --- Inherited virtual methods of BaseObject ---
		CreateMouseCallBack* GetCreateMouseCallBack();
		TCHAR *GetObjectName() { return GetString(IDS_RB_SPHERE); }

		// --- Inherited virtual methods of Object ---
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
		BOOL IsParamSurface() {return TRUE;}
		Point3 GetSurfacePoint(TimeValue t, float u, float v,Interval &iv);
		int IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm);

		// --- Inherited virtual methods of SimpleObject ---
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		

		// --- Inherited virtual methods of GenSphere ---
		void SetParams(float rad, int segs, BOOL smooth=TRUE, BOOL genUV=TRUE,
			 float hemi=0.0f, BOOL squash=FALSE, BOOL recenter=FALSE);

		// --- Inherited virtual methods of IParamArray ---
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// --- Methods of SphereObject ---
		SphereObject();		
	};

// Misc stuff
#define MAX_SEGMENTS	200
#define MIN_SEGMENTS	4

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float(1.0E30)

#define MIN_SMOOTH		0
#define MAX_SMOOTH		1

#define DEF_SEGMENTS	16
#define DEF_RADIUS		float(0.0)

#define SMOOTH_ON	1
#define SMOOTH_OFF	0


//--- Class vars ---------------------------------
// Initialize the class vars
int SphereObject::dlgSegments       = DEF_SEGMENTS;
int SphereObject::dlgCreateMeth     = 1; // create_radius
int SphereObject::dlgSmooth         = SMOOTH_ON;
IParamMap *SphereObject::pmapCreate = NULL;
IParamMap *SphereObject::pmapParam  = NULL;
IParamMap *SphereObject::pmapTypeIn = NULL;
IObjParam *SphereObject::ip         = NULL;
Point3 SphereObject::crtPos         = Point3(0,0,0);
float SphereObject::crtRadius       = 0.0f;

//--- Parameter map/block descriptors -------------------------------
// The parameter map descriptors define the properties of a parameter
// such as the type (spinner, radio button, check box, etc.), which
// resource ID they refer to, and which index into the virtual array
// they use.

// Parameter block indices
#define PB_RADIUS	0
#define PB_SEGS		1
#define PB_SMOOTH	2
#define PB_HEMI		3
#define PB_SQUASH	4
#define PB_RECENTER	5
#define PB_GENUVS	6

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS		2


//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEDIAMETER,IDC_CREATERADIUS};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGH 1


//
//
// Type in

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Radius
	ParamUIDesc(
		PB_TI_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE)	
	};
#define TYPEINDESC_LENGH 2


//
//
// Parameters

static int squashIDs[] = {IDC_HEMI_CHOP,IDC_HEMI_SQUASH};

static ParamUIDesc descParam[] = {
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	
	
	// Segments
	ParamUIDesc(
		PB_SEGS,
		EDITTYPE_INT,
		IDC_SEGMENTS,IDC_SEGSPINNER,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Smooth
	ParamUIDesc(PB_SMOOTH,TYPE_SINGLECHEKBOX,IDC_OBSMOOTH),

	// Hemisphere
	ParamUIDesc(
		PB_HEMI,
		EDITTYPE_FLOAT,
		IDC_HEMISPHERE,IDC_HEMISPHERESPINNER,
		0.0f,1.0f,
		0.005f),

	// Chop/squash
	ParamUIDesc(PB_SQUASH,TYPE_RADIO,squashIDs,2),

	// Recenter
	ParamUIDesc(PB_RECENTER,TYPE_SINGLECHEKBOX,IDC_HEMI_RECENTER),

	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),
	};
#define PARAMDESC_LENGH 7


// The parameter block descriptor defines the type of value represented
// by the parameter (int, float, Color...) and if it is animated or not.

// This class requires these values to be initialized:
// { - ParameterType, 
//   - Not Used, must be set to NULL, 
//   - Flag which indicates if the parameter is animatable,
//   - ID of the parameter used to match a corresponding ID in the 
//     other version of the parameter.  This is used to automatically
//     convert between and older version of the parameter block
//     structure and a newer one.
//  }

// This one is the older version.
static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 } };

static ParamBlockDescID descVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_BOOL, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 } };

#define PBLOCK_LENGTH	7

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,3,0),
	ParamVersionDesc(descVer1,6,1)
	};
#define NUM_OLDVERSIONS	2

// Current version
static ParamVersionDesc curVersion(descVer2,PBLOCK_LENGTH,2);
#define CURRENT_VERSION	2

//--- TypeInDlgProc --------------------------------

// This is the method called when the user clicks on the Create button
// in the Keyboard Entry rollup.  It was registered as the dialog proc
// for this button by the SetUserDlgProc() method called from 
// BeginEditParams().
class SphereTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		SphereObject *so;

		SphereTypeInDlgProc(SphereObject *s) {so=s;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL SphereTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (so->crtRadius==0.0) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (so->TestAFlag(A_OBJ_CREATING)) {
						so->pblock->SetValue(PB_RADIUS,0,so->crtRadius);
						}

					Matrix3 tm(1);
					tm.SetTrans(so->crtPos);
					so->suspendSnap = FALSE;
					so->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}

// Class SphereObjCreateCallBack
// Declare a class derived from CreateMouseCallBack to handle
// the user input during the creation phase of the sphere.
class SphereObjCreateCallBack : public CreateMouseCallBack {
	IPoint2 sp0;
	SphereObject *ob;
	Point3 p0;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		void SetObj(SphereObject *obj) {ob = obj;}
	};

// --- Inherited virtual methods of CreateMouseCallBack ---
// This is the method that actually handles the user input
// during the sphere creation.
int SphereObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;
	Point3 p1,center;

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:  // only happens with MOUSE_POINT msg
				ob->pblock->SetValue(PB_RADIUS,0,0.0f);
				ob->suspendSnap = TRUE;				
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p0);
				break;
			case 1:
				mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				if (ob->dlgCreateMeth) {
					r = Length(p1-p0);
					mat.SetTrans(p0);
					}
				else {
					center = (p0+p1)/float(2);
					mat.SetTrans(center);
					r = Length(center-p0);
					} 
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pmapParam->Invalidate();

				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);					
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}

				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					return (Length(m-sp0)<3 || Length(p1-p0)<0.1f)?CREATE_ABORT:CREATE_STOP;
					}
				break;					   
			}
		}
	else
	if (msg == MOUSE_ABORT) {		
		return CREATE_ABORT;
		}

	return TRUE;
	}

// A single instance of the callback object.
static SphereObjCreateCallBack sphereCreateCB;

// --- Global Functions ---
// Triangular patch layout:
//
//   A---> ac ----- ca <---C
//   |                    / 
//   |                  /
//   v    i1    i3    /
//   ab            cb
//
//   |           /
//   |    i2   /
// 
//   ba     bc
//   ^     /
//   |   /
//   | /
//   B
//
// vertices ( a b c d ) are in counter clockwise order when viewed from 
// outside the surface

// Vector length for unit circle
#define CIRCLE_VECTOR_LENGTH 0.5517861843f

// Build a Patch rep of the sphere for use with ConvertToType().
static void BuildSpherePatch(PatchMesh& amesh, float radius, int smooth, BOOL textured)
	{
	Point3 p;	
	int np=0,nv=0;
	
	int nverts = 6;
	int nvecs = 48;
	int npatches = 8;
	amesh.setNumVerts(nverts);
	amesh.setNumTVerts(textured ? 13 : 0);
	amesh.setNumVecs(nvecs);
	amesh.setNumPatches(npatches);
	amesh.setNumTVPatches(textured ? npatches : 0);

	Point3 v0(0.0f, 0.0f, radius);		// Top
	Point3 v1(0.0f, 0.0f, -radius);		// Bottom
	Point3 v2(0.0f, -radius, 0.0f);		// Front
	Point3 v3(radius, 0.0f, 0.0f);		// Right
	Point3 v4(0.0f, radius, 0.0f);		// Back
	Point3 v5(-radius, 0.0f, 0.0f);		// Left

	// Create the vertices.
	amesh.verts[0].flags = PVERT_COPLANAR;
	amesh.verts[1].flags = PVERT_COPLANAR;
	amesh.verts[2].flags = PVERT_COPLANAR;
	amesh.verts[3].flags = PVERT_COPLANAR;
	amesh.verts[4].flags = PVERT_COPLANAR;
	amesh.verts[5].flags = PVERT_COPLANAR;
	amesh.setVert(0, v0);
	amesh.setVert(1, v1);
	amesh.setVert(2, v2);
	amesh.setVert(3, v3);
	amesh.setVert(4, v4);
	amesh.setVert(5, v5);

	if(textured) {
		amesh.setTVert(0, UVVert(0.125f,1.0f,0.0f));
		amesh.setTVert(1, UVVert(0.375f,1.0f,0.0f));
		amesh.setTVert(2, UVVert(0.625f,1.0f,0.0f));
		amesh.setTVert(3, UVVert(0.875f,1.0f,0.0f));
		amesh.setTVert(4, UVVert(0.0f,0.5f,0.0f));
		amesh.setTVert(5, UVVert(0.25f,0.5f,0.0f));
		amesh.setTVert(6, UVVert(0.5f,0.5f,0.0f));
		amesh.setTVert(7, UVVert(0.75f,0.5f,0.0f));
		amesh.setTVert(8, UVVert(1.0f,0.5f,0.0f));
		amesh.setTVert(9, UVVert(0.125f,0.0f,0.0f));
		amesh.setTVert(10, UVVert(0.375f,0.0f,0.0f));
		amesh.setTVert(11, UVVert(0.625f,0.0f,0.0f));
		amesh.setTVert(12, UVVert(0.875f,0.0f,0.0f));

		amesh.getTVPatch(0).setTVerts(3,7,8);
		amesh.getTVPatch(1).setTVerts(0,4,5);
		amesh.getTVPatch(2).setTVerts(1,5,6);
		amesh.getTVPatch(3).setTVerts(2,6,7);
		amesh.getTVPatch(4).setTVerts(12,8,7);
		amesh.getTVPatch(5).setTVerts(9,5,4);
		amesh.getTVPatch(6).setTVerts(10,6,5);
		amesh.getTVPatch(7).setTVerts(11,7,6);
		}

	// Create the edge vectors
	float vecLen = CIRCLE_VECTOR_LENGTH * radius;
	Point3 xVec(vecLen, 0.0f, 0.0f);
	Point3 yVec(0.0f, vecLen, 0.0f);
	Point3 zVec(0.0f, 0.0f, vecLen);
	amesh.setVec(0, v0 - yVec);
	amesh.setVec(2, v0 + xVec);
	amesh.setVec(4, v0 + yVec);
	amesh.setVec(6, v0 - xVec);
	amesh.setVec(8, v1 - yVec);
	amesh.setVec(10, v1 + xVec);
	amesh.setVec(12, v1 + yVec);
	amesh.setVec(14, v1 - xVec);
	amesh.setVec(9, v2 - zVec);
	amesh.setVec(16, v2 + xVec);
	amesh.setVec(1, v2 + zVec);
	amesh.setVec(23, v2 - xVec);
	amesh.setVec(11, v3 - zVec);
	amesh.setVec(18, v3 + yVec);
	amesh.setVec(3, v3 + zVec);
	amesh.setVec(17, v3 - yVec);
	amesh.setVec(13, v4 - zVec);
	amesh.setVec(20, v4 - xVec);
	amesh.setVec(5, v4 + zVec);
	amesh.setVec(19, v4 + xVec);
	amesh.setVec(15, v5 - zVec);
	amesh.setVec(22, v5 - yVec);
	amesh.setVec(7, v5 + zVec);
	amesh.setVec(21, v5 + yVec);
	
	// Create the patches
	amesh.MakeTriPatch(np++, 0, 0, 1, 2, 16, 17, 3, 3, 2, 24, 25, 26, smooth);
	amesh.MakeTriPatch(np++, 0, 2, 3, 3, 18, 19, 4, 5, 4, 27, 28, 29, smooth);
	amesh.MakeTriPatch(np++, 0, 4, 5, 4, 20, 21, 5, 7, 6, 30, 31, 32, smooth);
	amesh.MakeTriPatch(np++, 0, 6, 7, 5, 22, 23, 2, 1, 0, 33, 34, 35, smooth);
	amesh.MakeTriPatch(np++, 1, 10, 11, 3, 17, 16, 2, 9, 8, 36, 37, 38, smooth);
	amesh.MakeTriPatch(np++, 1, 12, 13, 4, 19, 18, 3, 11, 10, 39, 40, 41, smooth);
	amesh.MakeTriPatch(np++, 1, 14, 15, 5, 21, 20, 4, 13, 12, 42, 43, 44, smooth);
	amesh.MakeTriPatch(np++, 1, 8, 9, 2, 23, 22, 5, 15, 14, 45, 46, 47, smooth);

	// Create all the interior vertices and make them non-automatic
	float chi = 0.5893534f * radius;

	int interior = 24;
	amesh.setVec(interior++, Point3(chi, -chi, radius)); 
	amesh.setVec(interior++, Point3(chi, -radius, chi)); 
	amesh.setVec(interior++, Point3(radius, -chi, chi)); 

	amesh.setVec(interior++, Point3(chi, chi, radius)); 
	amesh.setVec(interior++, Point3(radius, chi, chi)); 
	amesh.setVec(interior++, Point3(chi, radius, chi)); 

	amesh.setVec(interior++, Point3(-chi, chi, radius)); 
	amesh.setVec(interior++, Point3(-chi, radius, chi)); 
	amesh.setVec(interior++, Point3(-radius, chi, chi)); 

	amesh.setVec(interior++, Point3(-chi, -chi, radius)); 
	amesh.setVec(interior++, Point3(-radius, -chi, chi)); 
	amesh.setVec(interior++, Point3(-chi, -radius, chi)); 

	amesh.setVec(interior++, Point3(chi, -chi, -radius)); 
	amesh.setVec(interior++, Point3(radius, -chi, -chi)); 
	amesh.setVec(interior++, Point3(chi, -radius, -chi)); 

	amesh.setVec(interior++, Point3(chi, chi, -radius)); 
	amesh.setVec(interior++, Point3(chi, radius, -chi)); 
	amesh.setVec(interior++, Point3(radius, chi, -chi)); 

	amesh.setVec(interior++, Point3(-chi, chi, -radius)); 
	amesh.setVec(interior++, Point3(-radius, chi, -chi)); 
	amesh.setVec(interior++, Point3(-chi, radius, -chi)); 

	amesh.setVec(interior++, Point3(-chi, -chi, -radius)); 
	amesh.setVec(interior++, Point3(-chi, -radius, -chi)); 
	amesh.setVec(interior++, Point3(-radius, -chi, -chi)); 

	for(int i = 0; i < 8; ++i)
		amesh.patches[i].SetAuto(FALSE);

	// Finish up patch internal linkages (and bail out if it fails!)
	assert(amesh.buildLinkages());

	// Calculate the interior bezier points on the PatchMesh's patches
	amesh.computeInteriors();
	amesh.InvalidateGeomCache();
	}

// Build a NURBS rep of the sphere for use with ConvertToType().
Object *
BuildNURBSSphere(float radius, float hemi, BOOL recenter, BOOL genUVs)
{
	NURBSSet nset;

	Point3 center(0,0,0);
	Point3 northAxis(0,0,1);
	Point3 refAxis(0,-1,0);

	float startAngleU = -PI;
	float endAngleU = PI;
	float startAngleV = -HALFPI + (hemi * PI);
	float endAngleV = HALFPI;
	if (recenter)
		center = Point3(0.0, 0.0, -cos((1.0f-hemi) * PI) * radius);

	NURBSCVSurface *surf = new NURBSCVSurface();
	nset.AppendObject(surf);
	surf->SetGenerateUVs(genUVs);

	surf->SetTextureUVs(0, 0, Point2(0.0f, hemi));
	surf->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
	surf->SetTextureUVs(0, 2, Point2(1.0f, hemi));
	surf->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));

	surf->FlipNormals(TRUE);
	surf->Renderable(TRUE);
	char bname[80];
	char sname[80];
	strcpy(bname, GetString(IDS_RB_SPHERE));
	sprintf(sname, "%s%s", bname, GetString(IDS_CT_SURF));
	surf->SetName(sname);
	GenNURBSSphereSurface(radius, center, northAxis, refAxis,
					startAngleU, endAngleU, startAngleV, endAngleV, FALSE, *surf);


#define F(s1, s2, s1r, s1c, s2r, s2c) \
	fuse.mSurf1 = (s1); \
	fuse.mSurf2 = (s2); \
	fuse.mRow1 = (s1r); \
	fuse.mCol1 = (s1c); \
	fuse.mRow2 = (s2r); \
	fuse.mCol2 = (s2c); \
	nset.mSurfFuse.Append(1, &fuse);

	NURBSFuseSurfaceCV fuse;

	// poles
	for (int f = 1; f < surf->GetNumVCVs(); f++) {
		if (hemi <= 0.0f) {
			// south pole
			F(0, 0, 0, 0, 0, f);
		}
		//north pole
		F(0, 0, surf->GetNumUCVs()-1, 0, surf->GetNumUCVs()-1, f);
	}
	// seam
	for (f = 0; f < surf->GetNumUCVs()-1; f++) {
		F(0, 0, f, 0, f, surf->GetNumVCVs()-1);
	}

	if (hemi > 0.0f) {
		// Cap
		// we need to make a cap that is a NURBS surface one edge of which matches
		// the south polar edge and the rest is degenerate...
		Point3 bot;
		if (recenter)
			bot = Point3(0,0,0);
		else
			bot = Point3(0.0, 0.0, cos((1.0-hemi) * PI)*radius);

		NURBSCVSurface *s0 = (NURBSCVSurface*)nset.GetNURBSObject(0);
		NURBSCVSurface *s = new NURBSCVSurface();
		nset.AppendObject(s);

		// we'll be cubic in on direction and match the sphere in the other
		s->SetUOrder(4);
		s->SetNumUKnots(8);
		for (int i = 0; i < 4; i++) {
			s->SetUKnot(i, 0.0);
			s->SetUKnot(i+4, 1.0);
		}

		s->SetVOrder(s0->GetVOrder());
		s->SetNumVKnots(s0->GetNumVKnots());
		for (i = 0; i < s->GetNumVKnots(); i++)
			s->SetVKnot(i, s0->GetVKnot(i));

		int numU, numV;
		s0->GetNumCVs(numU, numV);
		s->SetNumCVs(4, numV);

		for (int v = 0; v < numV; v++) {
			Point3 edge = s0->GetCV(0, v)->GetPosition(0);
			double w = s0->GetCV(0, v)->GetWeight(0);
			for (int u = 0; u < 4; u++) {
				NURBSControlVertex ncv;
				ncv.SetPosition(0, bot + ((edge - bot)*((float)u/3.0f)));
				ncv.SetWeight(0, w);
				s->SetCV(u, v, ncv);
			}
			// fuse the cap to the hemi
			F(1, 0, 3, v, 0, v);

			// fuse the center degeneracy
			if (v > 0) {
				F(1, 1, 0, 0, 0, v);
			}
		}

		// fuse the remaining two end sections
		F(1, 1, 1, 0, 1, numV-1);
		F(1, 1, 2, 0, 2, numV-1);

		s->SetGenerateUVs(genUVs);

		s->SetTextureUVs(0, 0, Point2(1.0f, 1.0f));
		s->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
		s->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
		s->SetTextureUVs(0, 3, Point2(0.0f, 0.0f));

		s->FlipNormals(TRUE);
		s->Renderable(TRUE);
		sprintf(sname, "%s%s%01", bname, GetString(IDS_CT_CAP));
		s->SetName(sname);
	}

	Matrix3 mat;
	mat.IdentityMatrix();
	Object *ob = CreateNURBSObject(NULL, &nset, mat);
	return ob;
}

// --- Inherited virtual methods of Animatable ---
// This method is called by the system when the user needs 
// to edit the objects parameters in the command panel.  
void SphereObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	// We subclass off SimpleObject so we must call its
	// BeginEditParams() method first.
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last sphere ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			// Here we create each new rollup page in the command panel
			// using our descriptors.
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_SPHEREPARAM1),
				GetString(IDS_RB_CREATIONMETHOD),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_SPHEREPARAM3),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SPHEREPARAM2),
			GetString(IDS_RB_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		// This handles processing the Create button in the 
		// Keyboard Entry rollup page.
		pmapTypeIn->SetUserDlgProc(new SphereTypeInDlgProc(this));
		}
	}
		
// This is called by the system to terminate the editing of the
// parameters in the command panel.  
void SphereObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		// Remove the rollup pages from the command panel.
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created 
	// will inherit them.
	pblock->GetValue(PB_SEGS,ip->GetTime(),dlgSegments,FOREVER);
	pblock->GetValue(PB_SMOOTH,ip->GetTime(),dlgSmooth,FOREVER);	
	}

// --- Inherited virtual methods of ReferenceMaker ---
#define NEWMAP_CHUNKID	0x0100

// Called by MAX when the sphere object is loaded from disk.
IOResult SphereObject::Load(ILoad *iload) 
	{
	ClearAFlag(A_PLUGIN1);

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {	
			case NEWMAP_CHUNKID:
				SetAFlag(A_PLUGIN1);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	// This is the callback that corrects for any older versions
	// of the parameter block structure found in the MAX file 
	// being loaded.
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}

IOResult SphereObject::Save(ISave *isave)
	{
	if (TestAFlag(A_PLUGIN1)) {
		isave->BeginChunk(NEWMAP_CHUNKID);
		isave->EndChunk();
		}
 	return IO_OK;
	}


// --- Inherited virtual methods of ReferenceTarget ---
RefTargetHandle SphereObject::Clone(RemapDir& remap) 
	{
	SphereObject* newob = new SphereObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	newob->ivalid.SetEmpty();	
	return(newob);
	}

// --- Inherited virtual methods of BaseObject ---
CreateMouseCallBack* SphereObject::GetCreateMouseCallBack() 
	{
	sphereCreateCB.SetObj(this);
	return(&sphereCreateCB);
	}

// --- Inherited virtual methods of Object ---
Object* SphereObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
	if (obtype == patchObjectClassID) {
		Interval valid = FOREVER;
		float radius;
		int smooth, genUVs;
		pblock->GetValue(PB_RADIUS,t,radius,valid);
		pblock->GetValue(PB_SMOOTH,t,smooth,valid);	
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		PatchObject *ob = new PatchObject();
		BuildSpherePatch(ob->patch,radius,smooth,genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
	} else  if (obtype == EDITABLE_SURF_CLASS_ID) {
		Interval valid = FOREVER;
		float radius, hemi;
		int recenter, genUVs;
		pblock->GetValue(PB_RADIUS,t,radius,valid);
		pblock->GetValue(PB_HEMI,t,hemi,valid);	
		pblock->GetValue(PB_RECENTER,t,recenter,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		Object *ob = BuildNURBSSphere(radius, hemi, recenter,genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
		
	} else{
		return SimpleObject::ConvertToType(t,obtype);
		}
	}

int SphereObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==patchObjectClassID || obtype==defObjectClassID ||
		obtype==triObjectClassID || obtype==EDITABLE_SURF_CLASS_ID) {
		return 1;
	} else {
		return SimpleObject::CanConvertToType(obtype);
		}
	}

void SphereObject::GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);
    Class_ID id = EDITABLE_SURF_CLASS_ID;
    TSTR *name = new TSTR(GetString(IDS_SM_NURBS_SURFACE));
    clist.Append(1,&id);
    nlist.Append(1,&name);
}

Point3 SphereObject::GetSurfacePoint(
		TimeValue t, float u, float v,Interval &iv)
	{
	float rad;
	pblock->GetValue(PB_RADIUS, t, rad, iv);
	Point3 pos;	
	v -= 0.5f;
	float ar = (float)cos(v*PI);
	pos.x = rad * float(cos(u*TWOPI)) * ar;
	pos.y = rad * float(sin(u*TWOPI)) * ar;
	pos.z = rad * float(sin(v*PI));
	return pos;
	}

BOOL SphereObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void SphereObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}

int SphereObject::IntersectRay(
		TimeValue t, Ray& ray, float& at, Point3& norm)
	{
	int smooth, recenter;
	pblock->GetValue(PB_SMOOTH,t,smooth,FOREVER);
	pblock->GetValue(PB_RECENTER,t,recenter,FOREVER);	
	float hemi;
	pblock->GetValue(PB_HEMI,t,hemi,FOREVER);
	if (!smooth || hemi!=0.0f || recenter) {
		return SimpleObject::IntersectRay(t,ray,at,norm);
		}	
	
	float r;
	float a, b, c, ac4, b2, at1, at2;
	float root;
	BOOL neg1, neg2;

	pblock->GetValue(PB_RADIUS,t,r,FOREVER);

	a = DotProd(ray.dir,ray.dir);
	b = DotProd(ray.dir,ray.p) * 2.0f;
	c = DotProd(ray.p,ray.p) - r*r;
	
	ac4 = 4.0f * a * c;
	b2 = b*b;

	if (ac4 > b2) return 0;

	// We want the smallest positive root
	root = float(sqrt(b2-ac4));
	at1 = (-b + root) / (2.0f * a);
	at2 = (-b - root) / (2.0f * a);
	neg1 = at1<0.0f;
	neg2 = at2<0.0f;
	if (neg1 && neg2) return 0;
	else
	if (neg1 && !neg2) at = at2;
	else 
	if (!neg1 && neg2) at = at1;
	else
	if (at1<at2) at = at1;
	else at = at2;
	
	norm = Normalize(ray.p + at*ray.dir);

	return 1;
	}

// --- Inherited virtual methods of SimpleObject ---
// Return TRUE if it is OK to display the mesh at the time requested,
// return FALSE otherwise.
BOOL SphereObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}

// This method is called when the user interface controls need to be
// updated to reflect new values because of the user moving the time
// slider.  Here we simply call a method of the parameter map to 
// handle this for us.
void SphereObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

// This method returns the dimension of the parameter requested.
// This dimension describes the type and magnitude of the value
// stored by the parameter.
ParamDimension *SphereObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:
			return stdWorldDim;			
		case PB_HEMI:
			return stdNormalizedDim;
		case PB_SEGS:
			return stdSegmentsDim;			
		case PB_SMOOTH:
			return stdNormalizedDim;			
		default:
			return defaultDim;
		}
	}

// This method returns the name of the parameter requested.
TSTR SphereObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:
			return TSTR(GetString(IDS_RB_RADIUS));			
		case PB_HEMI:
			return GetString(IDS_RB_HEMISPHERE);
		case PB_SEGS:
			return TSTR(GetString(IDS_RB_SEGS));			
		case PB_SMOOTH:
			return TSTR(GetString(IDS_RB_SMOOTH));			
		default:
			return TSTR(_T(""));
		}
	}

// Builds the mesh representation for the sphere based on the
// state of it's parameters at the time requested.
void SphereObject::BuildMesh(TimeValue t)
	{
	Point3 p;	
	int ix,na,nb,nc,nd,jx,kx;
	int nf=0,nv=0;
	float delta, delta2;
	float a,alt,secrad,secang,b,c;
	int segs, smooth;
	float radius;
	float hemi;
	BOOL noHemi = FALSE;	
	int squash;
	int recenter;
	BOOL genUVs = TRUE;
	float startAng = 0.0f;
	if (TestAFlag(A_PLUGIN1)) startAng = HALFPI;

	// Start the validity interval at forever and whittle it down.
	ivalid = FOREVER;
	pblock->GetValue(PB_RADIUS, t, radius, ivalid);
	pblock->GetValue(PB_SEGS, t, segs, ivalid);
	pblock->GetValue(PB_SMOOTH, t, smooth, ivalid);
	pblock->GetValue(PB_HEMI, t, hemi, ivalid);
	pblock->GetValue(PB_SQUASH, t, squash, ivalid);
	pblock->GetValue(PB_RECENTER, t, recenter, ivalid);
	pblock->GetValue(PB_GENUVS, t, genUVs, ivalid);
	LimitValue(segs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(smooth, MIN_SMOOTH, MAX_SMOOTH);
	LimitValue(radius, MIN_RADIUS, MAX_RADIUS);
	LimitValue(hemi, 0.0f, 1.0f);

	if (hemi<0.00001f) noHemi = TRUE;
	if (hemi>=1.0f) hemi = 0.9999f;
	hemi = (1.0f-hemi) * PI;

	if (!noHemi && squash) {
		delta  = 2.0f*hemi/float(segs-2);
		delta2 = 2.0f*PI/(float)segs;
	} else {
		delta  = 2.0f*PI/(float)segs;
		delta2 = delta;
		}

	int rows;
	if (noHemi || squash) {
		rows = (segs/2-1);
	} else {
		rows = int(hemi/delta) + 1;
		}
	int nverts = rows * segs + 2;
	int nfaces = rows * segs * 2;
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	mesh.setSmoothFlags(smooth != 0);

	// Top vertex 
	mesh.setVert(nv, 0.0f, 0.0f, radius);
	nv++;

	// Middle vertices 
	alt=delta;
	for(ix=1; ix<=rows; ix++) {		
		if (!noHemi && ix==rows) alt = hemi;
		a = (float)cos(alt)*radius;		
		secrad = (float)sin(alt)*radius;
		secang = startAng; //0.0f
		for(jx=0; jx<segs; ++jx) {
			b = (float)cos(secang)*secrad;
			c = (float)sin(secang)*secrad;
			mesh.setVert(nv++,b,c,a);
			secang+=delta2;
			}
				
		alt+=delta;		
		}

	/* Bottom vertex */
	if (noHemi) {
		mesh.setVert(nv++, 0.0f, 0.0f,-radius);
		}
	else {
		a = (float)cos(hemi)*radius;
		mesh.setVert(nv++, 0.0f, 0.0f, a);
		}

	// Now make faces 
	
	// Make top conic cap
	for(ix=1; ix<=segs; ++ix) {
		nc=(ix==segs)?1:ix+1;
		mesh.faces[nf].setEdgeVisFlags(1,1,1);
		mesh.faces[nf].setSmGroup(smooth?1:0);
		mesh.faces[nf].setVerts(0, ix, nc);
		mesh.faces[nf].setMatID(1);
		nf++;
		}

	/* Make midsection */
	for(ix=1; ix<rows; ++ix) {
		jx=(ix-1)*segs+1;
		for(kx=0; kx<segs; ++kx) {
			na = jx+kx;
			nb = na+segs;
			nc = (kx==(segs-1))? jx+segs: nb+1;
			nd = (kx==(segs-1))? jx : na+1;
			
			mesh.faces[nf].setEdgeVisFlags(1,1,0);
			mesh.faces[nf].setSmGroup(smooth?1:0);
			mesh.faces[nf].setVerts(na,nb,nc);
			mesh.faces[nf].setMatID(1);
			nf++;

			mesh.faces[nf].setEdgeVisFlags(0,1,1);
			mesh.faces[nf].setSmGroup(smooth?1:0);
			mesh.faces[nf].setVerts(na,nc,nd);
			mesh.faces[nf].setMatID(1);
			nf++;
			}
	 	}

	// Make bottom conic cap
	na = mesh.getNumVerts()-1;
	jx = (rows-1)*segs+1;
	for(ix=0; ix<segs; ++ix) {
		nc = ix + jx;
		nb = (ix==segs-1)?jx:nc+1;
		mesh.faces[nf].setEdgeVisFlags(1,1,1);
		mesh.faces[nf].setSmGroup(smooth?1:0);
		mesh.faces[nf].setVerts(na, nb, nc);
		if (smooth) {
			mesh.faces[nf].setSmGroup(noHemi?1:2);
		} else {
			mesh.faces[nf].setSmGroup(0);
			}
		mesh.faces[nf].setMatID(noHemi?1:0);
		nf++;
		}

	// Put the flat part of the hemisphere at z=0
	if (recenter) {
		float shift = (float)cos(hemi) * radius;
		for (ix=0; ix<mesh.getNumVerts(); ix++) {
			mesh.verts[ix].z -= shift;
			}
		}

	if (genUVs) {
		int ntverts = (rows+2)*(segs+1);
		mesh.setNumTVerts(ntverts);
		mesh.setNumTVFaces(nfaces);
		nv = 0;
		delta  = 2.0f*PI/(float)segs;  // make the texture squash too
		alt = 0.0f; // = delta;

		for(ix=0; ix < rows+2; ix++) {		
		//	if (!noHemi && ix==rows) alt = hemi;		
			secang = 0.0f; //angle;
			for(jx=0; jx <= segs; ++jx) {
				mesh.setTVert(nv++, secang/TWOPI, 1.0f-alt/PI, 0.0f);
				secang += delta2;
				}
			alt += delta;		
			}

		nf = 0;
		// Make top conic cap
		for(ix=0; ix<segs; ++ix) {
			mesh.tvFace[nf++].setTVerts(ix,ix+segs+1,ix+segs+2);
			}

		/* Make midsection */
		for(ix=1; ix<rows; ++ix) {
			jx = ix*(segs+1);
			for(kx=0; kx<segs; ++kx) {
				na = jx+kx;
				nb = na+segs+1;
				nc = nb+1;
				nd = na+1;
				assert(nc<ntverts);
				assert(nd<ntverts);
				mesh.tvFace[nf++].setTVerts(na,nb,nc);
				mesh.tvFace[nf++].setTVerts(na,nc,nd);
				}
			}
		// Make bottom conic cap
		jx = rows*(segs+1);
		for(ix=0; ix<segs; ++ix) {
			nc = ix + jx;
			na = ix + jx + segs+1;
			nb = nc + 1;
			assert(na<ntverts);
			assert(nb<ntverts);
			assert(nc<ntverts);
			mesh.tvFace[nf++].setTVerts(na,nb,nc);
			}
		assert(nf==nfaces);
		}
	else {
		mesh.setNumTVerts(0);
		mesh.setNumTVFaces(0);
		}

	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
	}

// --- Inherited virtual methods of GenSphere ---
void SphereObject::SetParams(float rad, int segs, BOOL smooth, BOOL genUV,
	 float hemi, BOOL squash, BOOL recenter) {
	pblock->SetValue(PB_RADIUS,0, rad);				
	pblock->SetValue(PB_HEMI,0, hemi);				
	pblock->SetValue(PB_SEGS,0, segs);				
	pblock->SetValue(PB_SQUASH,0, squash);				
	pblock->SetValue(PB_SMOOTH,0, smooth);				
	pblock->SetValue(PB_RECENTER,0, recenter);				
	pblock->SetValue(PB_GENUVS,0, genUV);				
	}			   

// --- Inherited virtual methods of IParamArray ---
// These methods allow the parameter map to access our class variables.
// Based on the virtual array index passed in we set or get the 
// variable requested.
BOOL SphereObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL SphereObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS: crtRadius = v; break;
		}	
	return TRUE;
	}

BOOL SphereObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL SphereObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL SphereObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS: v = crtRadius; break;
		}
	return TRUE;
	}

BOOL SphereObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}

// --- Methods of SphereObject ---
SphereObject::SphereObject()
	{
	// Create the parameter block and make a reference to it.
	SetAFlag(A_PLUGIN1);
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer2, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);

	// Initialize the default values.
	pblock->SetValue(PB_RADIUS,0,crtRadius);
	pblock->SetValue(PB_SMOOTH,0,dlgSmooth);
	pblock->SetValue(PB_SEGS,0,dlgSegments);	
	pblock->SetValue(PB_SQUASH,0,0);
	}

// See the Advanced Topics section on DLL Functions and Class Descriptors
// for more information.
/*===========================================================================*\
 | The Class Descriptor
\*===========================================================================*/
class SphereClassDesc:public ClassDesc {
	public:
	// This method should return TRUE if the plug-in can be picked
	// and assigned by the user. Some plug-ins may be used privately by other
	// plug-ins implemented in the same DLL and should not appear in lists for
	// user to choose from (such plug-ins would return FALSE).
	int 			IsPublic() { return 1; }
	// This is the method that actually creates a new instance of
	// the plug-in class.  The system calls the correspoding 
	// Animatable::DeleteThis() method of the plug-in to free the memory.
	// This implementations use 'new' and 'delete'.
	void			*Create(BOOL loading = FALSE) { return new SphereObject; }
	// This is the name that appears on the button in the MAX user interface.
	const TCHAR		*ClassName() { return GetString(IDS_RB_SPHERE_CLASS); }
	// The system calls this method at startup to determine the type of plug-in
	// this is. The possible options are defined in PLUGAPI.H
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	// The system calls this method to retrieve the unique Class ID 
	// for this object.
	Class_ID		ClassID() { return SPHERE_C_CLASS_ID; }
	// The category is selected in the bottom most drop down list in the 
	// reate branch. If this is set to be an exiting category for example 
	// "Standard Primitives" then the plug-in will appear in that category. 
	// If the category doesn't exists then it is created.
	const TCHAR		*Category() { return GetString(IDS_RB_HOWTO); }
	// When the user executes File / Reset this method is called.  The plug-in
	// can respond by resetting itself to use its default values.
	void			ResetClassParams(BOOL fileReset);
	};

// Declare a single static instance of the class descriptor.
static SphereClassDesc sphereDesc;

// This function returns the address of the descriptor.  We call it from 
// the LibClassDesc() function, which is called by the system when loading
// the DLLs at startup.
ClassDesc* GetSphereDesc() { return &sphereDesc; }

void SphereClassDesc::ResetClassParams(BOOL fileReset)
	{
	SphereObject::dlgSegments    = DEF_SEGMENTS;
	SphereObject::dlgCreateMeth  = 1; // create_radius
	SphereObject::dlgSmooth      = SMOOTH_ON;
	SphereObject::crtPos         = Point3(0,0,0);
	SphereObject::crtRadius      = 0.0f;
	}

// The following five functions are used by every plug-in DLL.
/*===========================================================================*\
 | The DLL and Library Functions
\*===========================================================================*/
// This function is called by Windows when the DLL is loaded.  This 
// function may also be called many times during time critical operations
// like rendering.  Therefore developers need to be careful what they
// do inside this function.  In the code below, note how after the DLL is
// loaded the first time only a few statements are executed.
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

	if (! controlsInit) {
		controlsInit = TRUE;
		
		// Initialize MAX's custom controls
		InitCustomControls(hInstance);
		
		// Initialize Win95 controls
		InitCommonControls();
	}
	
	return(TRUE);
	}

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int LibNumberClasses() {return 1;}

// This function return the ith class descriptor
__declspec( dllexport ) ClassDesc *LibClassDesc(int i) {
	switch(i) {
		case 0: return GetSphereDesc();		
		default: return 0;
		}
	}

// This function returns a string that describes the DLL.  This string appears in 
// the File / Summary Info / Plug-In Info dialog box.
__declspec( dllexport ) const TCHAR *LibDescription() { 
	return GetString(IDS_LIB_DESC);
	}

// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\3dsexp.h ===
/**********************************************************************
 *<
	FILE: 3dsexp.h

	DESCRIPTION:  .3DS file export module header file

	CREATED BY: Tom Hudson

	HISTORY: created 26 December 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#pragma pack(1)

/* 3DS Shape point structure */

struct shppt
{
float x;	/* Control point */
float y;
float z;
float inx;	/* Incoming vector */
float iny;
float inz;
float outx;	/* Outgoing vector */
float outy;
float outz;
unsigned short flags;
};
typedef struct shppt Shppt;

#include "ofile.h"		// 3DS Object file header
#include "3dsshape.h"	// 3DS shape file header
#include "kfio.h"		// 3DS KF header
#pragma pack()


// Some 3DS structures

#pragma pack(1)
typedef struct {
	unsigned short tag;
	long size;
	} Chunk_hdr;

typedef struct {
	float x;
	float y;
	float z;
	unsigned short flags;
	} Verts;

typedef struct {
	float u;
	float v;
	} Texverts;

typedef struct {
	unsigned short a;
	unsigned short b;
	unsigned short c;
	unsigned char material;
	unsigned char filler;
	unsigned long sm_group;
	unsigned short flags;
	} Faces;
#pragma pack()

// 3DS face edge vis flags
#define ABLINE (1<<2)
#define BCLINE (1<<1)
#define CALINE 1

#define VWRAP (1<<11)		/* Texture coord V wraps on this face */
#define UWRAP (1<<3)		/* Texture coord U wraps on this face */

// Node list structure

//struct WkObjList;
typedef struct {
	TriObject *object;
	TCHAR name[11];
	int used;
	void *next;
	} WkObjList;

//struct WkNodeList;
typedef struct {
	ImpNode *node;
	short id;
	TCHAR name[11];
	Mesh *mesh;
	ImpNode *parent;
	Matrix3 tm;
	void *next;
	} WkNodeList;

// 3DS Key structures

#pragma pack(1)

struct fc_wrt
{
unsigned short a;
unsigned short b;
unsigned short c;
unsigned short flags;
} Fc_wrt;

struct color_24
{
uchar r;
uchar g;
uchar b;
};
typedef struct color_24 Color_24;

struct color_f
{
float r;
float g;
float b;
};
typedef struct color_f Color_f;

// key types
#define KEY_FLOAT	0
#define KEY_POS		1
#define KEY_ROT		2
#define KEY_SCL		3
#define KEY_COLOR	4

#define KEYHDR  \
	TimeValue time;  \
	float tens,cont,bias; \
	float easeTo,easeFrom;

typedef struct { float p,ds,dd; } PosElem;
typedef struct {
	KEYHDR
	PosElem e[8]; /* enough to be bigger than the biggest key,
					including RotKey */
	} Key;

typedef struct {
	KEYHDR
	PosElem e[1];
	} ScalarKey;

typedef struct {
	KEYHDR
	PosElem e[3];
	} PosKey;	

typedef struct {
	KEYHDR
	float angle;	/* angle of rotation in radians (always >0) */
	float axis[3]; /* axis of rotation (unit vector) */
	float q[4];  	/* quaternion describing orientation */
	float b[4];		/* incoming tangent term */
	float a[4];		/* outgoing tangent term */
	} RotKey;

#ifdef LATER
typedef struct {
	KEYHDR
	Namedobj *object;  
	} MorphKey;	

typedef struct {
	KEYHDR
	} HideKey;

typedef struct {
	KEYHDR
	FLOAT c[3];
	} ColorKey;
#endif // LATER
#pragma pack()

typedef struct {
	union {
		Key key;
		PosKey pos;
		RotKey rot;
		} key;
	void *next;
	} KeyList;

class SceneEntry {
	public:
		TSTR name;
		INode *node,*tnode;
		Object *obj;
		int type;		// See above
		int id;
		SceneEntry *next;
		SceneEntry(INode *n, Object *o, int t);
		void SetID(int id) { this->id = id; }
};

// We need to maintain a list of the unique objects in the scene
class ObjectEntry {
	public:
		TriObject *tri;
		SceneEntry *entry;
		ObjectEntry *next;
		ObjectEntry(SceneEntry *e) { entry = e; next = NULL;  tri = NULL; }
};

#define ERROR_MSG_MAX_LEN   128
#define NeedsKeys(nkeys)    ((nkeys) > 0 || (nkeys) == NOT_KEYFRAMEABLE)
#define KEYS_POS	        (1<<1)
#define KEYS_ROT	        (1<<2)
#define KEYS_SCL	        (1<<3)

static Tab<TSTR*> msgList;

//gdf TRUE if generating extra 3DS verts for mismatched UV coords
static BOOL MaxUVs;

struct Vert3ds {
    Point3 pt;
    UVVert tv;
};

struct Face3ds {
    int vNum[3];
    int flags;
};

void   ConvertTo3DSFaces(ObjectEntry* oe, Tab<Vert3ds>& verts, Tab<Face3ds>& faces);
static BOOL WriteController(INode* node);
static Point3 GetPivotOffset(INode* node);
inline BOOL ApproxEqual(float a, float b);
static BOOL IsTCBControl(Control *cont);
static BOOL UndoParentsOffset(INode* node, Point3& pt, Quat& rOff);
static Matrix3 GetLocalNodeTM(INode* node, TimeValue t);
void WriteChunkBegin(unsigned short cTag, long& cPtr, long& cBegin);
void WriteChunkEnd(long& cPtr, long& cBegin);
static BOOL WriteTCBKeysChunk(INode* node, Control* cont, int type);
static BOOL WriteLinearKeysChunk(INode* node, int type);
void ConvertTo3DSTVerts(ObjectEntry* oe, Tab<UVVert>& tv);
BOOL CALLBACK MsgListDlgProc(HWND hDlg, UINT iMsg, UINT wParam, LONG lParam);
void AddToMsgList(Tab<TSTR*>& mList, TCHAR* msg);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\3dsires.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by 3dsimp.rc
//
#define IDS_MATCHANIMLENGTH             1
#define IDS_3DSIMP                      2
#define IDS_DB_MISSING_SHAPE            3
#define IDS_DB_LIGHT_ERROR              4
#define IDS_DB_CAMERA_ERROR             5
#define IDS_DB_NO_OBJECT                6
#define IDS_DB_HAS_VERTS                7
#define IDS_DB_NUMVERTS_FAIL            8
#define IDS_DB_HAS_TVERTS               9
#define IDS_DB_HAS_FACES                10
#define IDS_DB_NUMFACES_FAIL            11
#define IDS_DB_NUMTVFACES_FAIL          12
#define IDS_DB_PUT_NO_VERTS             13
#define IDS_DB_3DSIMP                   14
#define IDS_DB_VERTS_OR                 15
#define IDS_DB_PUT_NO_TVERTS            16
#define IDS_DB_TVERTS_OR                17
#define IDS_DB_PUT_NO_FACES             18
#define IDS_DB_FACES_OR                 19
#define IDS_DB_SMOOTH_NO_FACES          20
#define IDS_DB_SMFACE_OR                21
#define IDS_DB_SHAPE_NUM                22
#define IDS_DB_NOT_LINKED               23
#define IDS_PRS_TVERT_OR                24
#define IDS_PRS_VERT_OR                 25
#define IDD_SHAPEIMPORTOPTIONS          101
#define IDD_MERGEORREPL                 102
#define IDC_SINGLEOBJECT                1000
#define IDC_MULTIPLEOBJECTS             1001
#define IDC_3DS_MERGE                   1002
#define IDC_3DS_REPLACE                 1003
#define IDC_IMPORT_SHAPES               1005
#define IDC_3DS_CONVERT					1006
#define IDS_TH_3DSTUDIO                 40216
#define IDS_TH_SCENEIMPORT              40217
#define IDS_TH_3DSTUDIOSHAPE            40218
#define IDS_TH_3DSIMPORTDLL             40219
#define IDS_TH_3DSSCENEFILE             40220
#define IDS_TH_3DSMESH                  40221
#define IDS_TH_TOM_HUDSON               40222
#define IDS_TH_COPYRIGHT_YOST_GROUP     40223
#define IDS_TH_3DSSHAPEFILE             40224
#define IDS_TH_ERR_OPENING_FILE         40225
#define IDS_TH_3DSIMP                   40226
#define IDS_TH_3DSREADERROR             40227
#define IDS_TH_INVALIDFILE              40228
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\3dseres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by 3dsexp.rc
//
#define IDS_DXFEXP                      1
#define IDD_EXPORTOPTIONS               101
#define IDD_ERROR_MSGS                  181
#define IDC_BYOBJECT                    1016
#define IDC_BYMATERIAL                  1017
#define IDC_1LAYER                      1018
#define IDC_MAX_UVS                     1019
#define IDC_ERROR_MSG_LIST              1168
#define IDS_TH_3DSTUDIO                 40216
#define IDS_TH_3DSSCENEFILE             40220
#define IDS_TH_3DSMESH                  40221
#define IDS_TH_3DSFILE                  40221
#define IDS_TH_TOM_HUDSON               40222
#define IDS_TH_COPYRIGHT_YOST_GROUP     40223
#define IDS_TH_3DSEXP                   40229
#define IDS_TH_SCENEEXPORT              40231
#define IDS_TH_3DSEXPORTDLL             40232
#define IDS_TH_NODATATOEXPORT           40233
#define IDS_TH_CANTCREATE               40234
#define IDS_TH_WRITEERROR               40235
#define IDS_OBJ_TOO_LARGE               40236
#define IDS_EXPORT_ERROR                40237
#define IDS_OBJ_TOO_MANY_FACES          40238
#define IDS_OBJ_TOO_MANY_VERTS          40239
#define IDS_UVVERT_MISMATCH             40240
#define IDS_UVVERT_TOO_MANY_PER_VERT    40241
#define IDS_OBJ_WITH_MULTI_MTL          40242
#define IDS_START                       40243
#define IDS_END                         40244
#define IDS_DIR_LIGHT                   40245
#define IDS_FSPOT_LIGHT                 40246
#define IDS_MATERIAL_LIMIT              40247
#define IDS_EIGHT_DOT_THREE             40248
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1020
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\3dsimp.h ===
/**********************************************************************
 *<
	FILE: 3dsimp.h

	DESCRIPTION:  .3DS file import module header file

	CREATED BY: Tom Hudson

	HISTORY: created 26 December 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#pragma pack(1)


/* 3DS Shape point structure */

struct shppt
{
float x;	/* Control point */
float y;
float z;
float inx;	/* Incoming vector */
float iny;
float inz;
float outx;	/* Outgoing vector */
float outy;
float outz;
unsigned short flags;
};
typedef struct shppt Shppt;

#include "ofile.h"		// 3DS Object file header
#include "cfile.h"		// 3DS Project file header
#include "3dsshape.h"	// 3DS shape file header
#include "kfio.h"		// 3DS KF header
#pragma pack()

struct Bkgrad {
	float midpct;
	Color botcolor;
	Color midcolor;
	Color topcolor;
	};

struct Fogdata {
	float nearplane;
	float neardens;
	float farplane;
	float fardens;
	Color color;
	};

struct LFogData {
	float zmin,zmax;
	float density;
	short type;
	short fog_bg;
	Color color;
	};

struct Distcue {
	float nearplane;
	float neardim;
	float farplane;
	float fardim;
	};

#define ENV_DISTCUE 1
#define ENV_FOG 2
#define ENV_LAYFOG 3

#define BG_SOLID 1
#define BG_GRADIENT 2
#define BG_BITMAP 3

struct BGdata {
	int bgType;
	int envType;
	Color bkgd_solid;
	Color amb_light;
	Bkgrad bkgd_gradient;
	Fogdata fog_data;
	Distcue distance_cue;
	int fog_bg,dim_bg;
	char bkgd_map[81];
	LFogData lfog_data;
	};

class StudioImport : public SceneImport {
public:
					StudioImport();
					~StudioImport();
	int				ExtCount();					// Number of extensions supported
	const TCHAR *	Ext(int n);					// Extension #n (i.e. "3DS")
	const TCHAR *	LongDesc();					// Long ASCII description (i.e. "Autodesk 3D Studio File")
	const TCHAR *	ShortDesc();				// Short ASCII description (i.e. "3D Studio")
	const TCHAR *	AuthorName();				// ASCII Author name
	const TCHAR *	CopyrightMessage();			// ASCII Copyright message
	const TCHAR *	OtherMessage1();			// Other message #1
	const TCHAR *	OtherMessage2();			// Other message #2
	unsigned int	Version();					// Version number * 100 (i.e. v3.01 = 301)
	void			ShowAbout(HWND hWnd);		// Show DLL's "About..." box
	int				DoImport(const TCHAR *name,ImpInterface *i,Interface *gi, BOOL suppressPrompts=FALSE);	// Import file
	};

#define SINGLE_SHAPE 0
#define MULTIPLE_SHAPES 1

class StudioShapeImport : public SceneImport {
	friend BOOL CALLBACK ShapeImportOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

public:
	static int		importType;
	int				shapeNumber;
					StudioShapeImport();
					~StudioShapeImport();
	int				ExtCount();					// Number of extensions supported
	const TCHAR *	Ext(int n);					// Extension #n (i.e. "3DS")
	const TCHAR *	LongDesc();					// Long ASCII description (i.e. "Autodesk 3D Studio File")
	const TCHAR *	ShortDesc();				// Short ASCII description (i.e. "3D Studio")
	const TCHAR *	AuthorName();				// ASCII Author name
	const TCHAR *	CopyrightMessage();			// ASCII Copyright message
	const TCHAR *	OtherMessage1();			// Other message #1
	const TCHAR *	OtherMessage2();			// Other message #2
	unsigned int	Version();					// Version number * 100 (i.e. v3.01 = 301)
	void			ShowAbout(HWND hWnd);		// Show DLL's "About..." box
	int				DoImport(const TCHAR *name,ImpInterface *i,Interface *gi, BOOL suppressPrompts=FALSE);	// Import file
	};

// Handy file class

class WorkFile {
private:
	FILE *stream;
public:
					WorkFile(const TCHAR *filename,const TCHAR *mode) { stream = _tfopen(filename,mode); };
					~WorkFile() { if(stream) fclose(stream); stream = NULL; };
	FILE *			Stream() { return stream; };
	};

// Some 3DS structures

#pragma pack(1)
typedef struct {
	float r,g,b;
	} Color_f;

typedef struct {
	unsigned char r,g,b;
	} Color_24;

typedef struct {
	unsigned short tag;
	long size;
	} Chunk_hdr;

typedef struct {
	float x;
	float y;
	float z;
	unsigned short flags;
	} Verts;

typedef struct {
	float u;
	float v;
	} Texverts;

typedef struct {
	unsigned short a;
	unsigned short b;
	unsigned short c;
	unsigned char material;
	unsigned char filler;
	unsigned long sm_group;
	unsigned short flags;
	} Faces;

typedef struct {
	float x;
	float y;
	float z;
	float tx;
	float ty;
	float tz;
	float bank;
	float focal;
	unsigned short flags;
	float nearplane;
	float farplane;
	void *appdata;
	} Camera3DS;

typedef struct dirlight{
	float x;
	float y;
	float z;
	float tx;
	float ty;
	float tz;
	unsigned short flags;
	Color color;
	float hotsize;
	float fallsize;
	float lo_bias;
//	Object_list *exclude;
	int shadsize;
	float in_range,out_range;		/* Attenuation range */
	float shadfilter;	/* size of filter box*/
	char imgfile[13];
	float ray_bias;
	float bank,aspect;	/* Spotlight bank angle, aspect ratio */
	float mult;			/* Light multiplier */
	void *appdata;
	NameTab excList;
	} Dirlight;

typedef struct
	{
	float lo_bias,hi_bias;
	short shadsize,shadsamp,shadrange;
	} Locshad;

typedef struct {
	float bias,shadfilter;
	short shadsize;
	} LocShad2;

#pragma pack()

// 3DS face edge vis flags
#define ABLINE (1<<2)
#define BCLINE (1<<1)
#define CALINE 1

#define VWRAP (1<<11)		/* Texture coord V wraps on this face */
#define UWRAP (1<<3)		/* Texture coord U wraps on this face */

// Node list structure

#define OBJ_MESH 0
#define OBJ_OMNILIGHT 1
#define OBJ_SPOTLIGHT 2
#define OBJ_CAMERA 3
#define OBJ_DUMMY 4
#define OBJ_TARGET 5
#define OBJ_OTHER  6 // generated from app data

// 3DS Key structures

#pragma pack(1)
#define KEYHDR  \
	TimeValue time;  \
	float tens,cont,bias; \
	float easeTo,easeFrom;

typedef struct { float p,ds,dd; } PosElem;
typedef struct {
	KEYHDR
	PosElem e[8]; /* enough to be bigger than the biggest key,
					including RotKey */
	} Key;

typedef struct {
	KEYHDR
	PosElem e[1];
	} ScalarKey;

typedef struct {
	KEYHDR
	PosElem e[3];
	} PosKey;	

typedef struct {
	KEYHDR
	float angle;	/* angle of rotation in radians (always >0) */
	float axis[3]; /* axis of rotation (unit vector) */
	float q[4];  	/* quaternion describing orientation */
	float b[4];		/* incoming tangent term */
	float a[4];		/* outgoing tangent term */
	} RotKey;

#ifdef LATER
typedef struct {
	KEYHDR
	Namedobj *object;  
	} MorphKey;	

typedef struct {
	KEYHDR
	} HideKey;
#endif // LATER

typedef struct {
	KEYHDR
	FLOAT c[3];
	} ColorKey;
#pragma pack()

// key types
#define KEY_FLOAT	0
#define KEY_POS		1
#define KEY_ROT		2
#define KEY_SCL		3
#define KEY_COLOR	4

#define NUMTRACKS 8

#define POS_TRACK_INDEX 0
#define ROT_TRACK_INDEX 1
#define SCL_TRACK_INDEX 2
#define FOV_TRACK_INDEX 3
#define ROLL_TRACK_INDEX 4
#define COL_TRACK_INDEX 5
#define HOT_TRACK_INDEX 6
#define FALL_TRACK_INDEX 7


typedef struct {
	union {
		Key key;
		PosKey pos;
		RotKey rot;
		ColorKey col;
		ScalarKey sc;
		} key;
	void *next;
	} KeyList;

// A list of 3DS objects with their names and types
typedef struct {
	void *object;
	Point3 srcPos;
	Point3 targPos;
	TSTR name;
	int type;
	int used;
	int cstShad;
	int rcvShad;
	int mtln;
	Matrix3 tm;
	void *next;
	} WkObjList;

// A list of the nodes and their various keys
typedef struct {
	ImpNode *node;
	short id;
	int type;
	int mnum;
	TSTR name;
	TSTR owner;
	Mesh *mesh;
	ImpNode *parent;
	Matrix3 tm;
	KeyList *posList;
	KeyList *rotList;
	KeyList *scList;
	KeyList *colList;
	KeyList *hotList;
	KeyList *fallList;
	KeyList *fovList;
	KeyList *rollList;
	SHORT trackFlags[NUMTRACKS];
	void *next;
	} WkNodeList;

/* Camera flag bit meanings */

#define NO_CAM_CONE	0x0001
#define NO_CAM_TEMP_APPDATA 0x0002 /* Free appdata after rendering complete  */	

#define NO_CAM_CONE_OFF	(~NO_CAM_CONE)

/* Light flag bit meanings */

#define NO_LT_ON	0x0001
#define NO_LT_SHAD	0x0002
#define NO_LT_LOCAL	0x0004
#define NO_LT_CONE	0x0008
#define NO_LT_RECT	0x0010
#define NO_LT_PROJ	0x0020
#define NO_LT_OVER	0x0040
#define NO_LT_ATTEN	0x0080
#define NO_LT_RAYTR	0x0100
#define NO_LT_TEMP_APPDATA 0x0200 /* Free appdata after rendering complete  */	

#define NO_LT_OFF	(~NO_LT_ON)
#define NO_LT_SHAD_OFF	(~NO_LT_SHAD)
#define NO_LT_LOCAL_OFF	(~NO_LT_LOCAL)
#define NO_LT_CONE_OFF	(~NO_LT_CONE)
#define NO_LT_RECT_OFF	(~NO_LT_RECT)
#define NO_LT_PROJ_OFF	(~NO_LT_PROJ)
#define NO_LT_OVER_OFF	(~NO_LT_OVER)
#define NO_LT_ATTEN_OFF	(~NO_LT_ATTEN)

/*--------- Track flags bits------------ */

/*-- This bit causes the spline to be cyclic */
#define ANIM_CYCLIC 1
/*-- This bit causes a track to continue "modulo" its duration */
#define ANIM_LOOP  (1<<1)
/*-- This bit is used by anim.c, but clients need not worry about it*/
#define ANIM_NEGWRAP (1<<2)

#define X_LOCKED (1<<3)
#define Y_LOCKED (1<<4)
#define Z_LOCKED (1<<5)
#define ALL_LOCKED (X_LOCKED|Y_LOCKED|Z_LOCKED)
#define TRACK_ATKEY (1<<6)

/* these flags specify which coords are NOT inherited from parent */ 
#define LNKSHFT 7
#define NO_LNK_X (1<<LNKSHFT)
#define NO_LNK_Y (1<<(LNKSHFT+1))
#define NO_LNK_Z (1<<(LNKSHFT+2))
#define LASTAXIS_SHFT 10
#define LASTAXIS_MASK (3<<LASTAXIS_SHFT)

// A worker object for dealing with creating the objects.
// Useful in the chunk-oriented 3DS file format

// Worker types

#define WORKER_IDLE		0
#define WORKER_MESH		1
#define WORKER_KF		2
#define WORKER_SHAPE	3
#define WORKER_LIGHT	4
#define WORKER_CAMERA	5

struct SMtl;

struct MtlName{
	char s[20];
	};

class ObjWorker {
public:
	int okay;
	ImpInterface *i;
	Interface *ip;
	TSTR name;
	int mode;
	int gotverts;
	int verts;
	int tverts;
	int gottverts;
	int gotfaces;
	int faces;
	int cstShad;
	int rcvShad;
	BOOL gotM3DMAGIC;
	Mtl  *sceneMtls[256];
	MtlName mtlNames[256];
	TriObject *object;
	GenLight *light;
	Dirlight studioLt;
	GenCamera *camera;
	Camera3DS studioCam;
	SplineShape *splShape;
	BezierShape *shape;
	Spline3D *spline;
	Mesh *mesh;
	ImpNode *thisNode;
	ImpNode *parentNode;
	short id;
	WkObjList *objects;
	WkNodeList *nodes;
	WkNodeList *workNode;
	Matrix3 tm;
	Point3 pivot;
	DummyObject *dummy;
	int isDummy;
	int lightType;
	TSTR nodename;
	// Time stuff:
	BOOL lengthSet;
	TimeValue length;
	BOOL segmentSet;
	Interval segment;	
	SHORT trackFlags[NUMTRACKS];
	MtlList loadMtls;
	Tab<Mesh *> loadMtlMesh;
	void *appdata;
	DWORD appdataLen;
	Tab<UVVert>newTV;

	float hook_x, hook_y;
					ObjWorker(ImpInterface *iptr,Interface *ip);
					~ObjWorker() { FinishUp(); FreeObjList(); FreeNodeList(); i->RedrawViews(); }
	int				StartMesh(const char *name);
	int				StartLight(const char *name);
	int				CreateLight(int type);
	int				StartCamera(const char *name);
	int				CreateCamera(int type);
	int				StartKF(ImpNode *node);
	int				StartShape();
	int				StartSpline();
	int				AddShapePoint(Shppt *p);
	int				CloseSpline();
	int				FinishShape();
	int				FinishUp();
	void			SetTm(Matrix3 *transform) { tm = *transform; }
	int				SetVerts(int count);
	int				SetTVerts(int count);
	int				GetVerts() { return verts; }
	int				SetFaces(int count);
	int				GetFaces() { return faces; }
	int				PutVertex(int index,Verts *v);
	int				PutTVertex(int index,UVVert *v);
	int				PutFace(int index,Faces *f);
	int				PutSmooth(int index,unsigned long smooth);
	int 			PutFaceMtl(int index, int imtl);
	void 			SetTVerts(int nf, Faces *f);
	DWORD 			AddNewTVert(UVVert p);
	void			Reset();
	void			Abandon();
	int				AddObject(Object *obj,int type,const TCHAR *name, Matrix3* tm, int mtlNum=-1);
	int				AddNode(ImpNode *node,const TCHAR *name,int type,Mesh *mesh,char *owner,int mtlNum=-1);
	int				SetNodeId(ImpNode *node,short id);
	int				SetNodesParent(ImpNode *node,ImpNode *parent);
	void *			FindObject(char *name, int &type, int &cstShad, int &rcvShad, int &mtlNum);
	int				UseObject(char *name);
	int				CompleteScene();
	int 			SetupEnvironment();
	ImpNode *		FindNode(char *name);
	ImpNode *		FindNodeFromId(short id);
	WkNodeList *	FindEntry(char *name);
	WkNodeList *	FindEntryFromId(short id);
	WkNodeList *	FindNodeListEntry(ImpNode *node);
	WkObjList *		FindObjListEntry(TSTR &name);
	void *			FindObjFromNode(ImpNode *node);
	int				FindTypeFromNode(ImpNode *node, Mesh **mesh);
	TCHAR *			NodeName(ImpNode *node);
	void			FreeObjList();
	void			FreeNodeList();
	ImpNode *		ThisNode() { return thisNode; }
	ImpNode *		ParentNode() { return parentNode; }
	void			SetParentNode(ImpNode *node) { parentNode = node; }
	void			SetPivot(Point3 p) { pivot = p; }
	int				AddPositionKey(PosKey *key) { return AddKey(&workNode->posList,(Key *)key); }
	int				AddRotationKey(RotKey *key) { return AddKey(&workNode->rotList,(Key *)key); }
	int				AddScaleKey(PosKey *key) { return AddKey(&workNode->scList,(Key *)key); }
	int				AddColorKey(ColorKey *key) { return AddKey(&workNode->colList,(Key *)key); }
	int				AddHotKey(ScalarKey *key) { return AddKey(&workNode->hotList,(Key *)key); }
	int				AddFallKey(ScalarKey *key) { return AddKey(&workNode->fallList,(Key *)key); }
	int				AddFOVKey(ScalarKey *key) { return AddKey(&workNode->fovList,(Key *)key); }
	int				AddRollKey(ScalarKey *key) { return AddKey(&workNode->rollList,(Key *)key); }
	int				AddKey(KeyList **list,Key *data);
	void			FreeKeyList(KeyList **list);
	int				SetTransform(ImpNode *node,Matrix3& m);
	Matrix3			GetTransform(ImpNode *node);
	int				ReadyDummy();
	ImpNode *		MakeDummy(const TCHAR *name);
	ImpNode *		MakeANode(const TCHAR *name, BOOL target,char *owner);
	void			SetDummy(int x) { isDummy = x; }
	int				IsDummy() { return isDummy; }
	int				SetDummyBounds(Point3& min,Point3& max);
	void			SetNodeName(const TCHAR *name) { nodename = name; }
	void			SetInstanceName(ImpNode *node, const TCHAR *iname);
	void			SetAnimLength(TimeValue l) { length = l; lengthSet = TRUE; }
	void			SetSegment(Interval seg) { segment = seg; segmentSet = TRUE; }
	void			SetControllerKeys(Control *cont,KeyList *keys,int type,float f=1.0f,float aspect=-1.0f);
	void            MakeControlsTCB(Control *tmCont,SHORT *tflags);
	Mtl*			GetMaxMtl(int i);
	void 			AssignMtl(INode *theINode, Mesh *mesh);
	void 			AssignMtl(WkNodeList* wkNode);
	int 			GetMatNum(char *name);
	void 			AddMeshMtl(SMtl *mtl);
	void 			FreeUnusedMtls();
	int				LoadAppData(FILE *stream,DWORD chunkSize);
	void			ParseIKData(INode *node);
	};


int skip_chunk(FILE *stream);
int get_next_chunk(FILE *stream,Chunk_hdr *hdr);
int SkipRead(FILE *stream,long bytes);
int read_string(char *string,FILE *stream,int maxsize);
int load_app_data(FILE *stream,void **pdata, int size);

#define RDERR(ptr,count) { if(!fread(ptr,count,1,stream)) return 0; }
#define RD3FLOAT(p) RDERR(p,3*sizeof(FLOAT))
#define RDFLOAT(p) 	RDERR(p,sizeof(FLOAT))
#define RDLONG(p) RDERR(p,sizeof(LONG))
#define RDSHORT(p) RDERR(p,sizeof(SHORT))
#define DUMNUM 0x7fff
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\HowTo\TMatTest\tmattest.cpp ===
/*===========================================================================*\
 |    File: tmattest.cpp
 |
 | Purpose: To allow the user to visualize the way transformation matrices
 |          are constructed in 3D Studio MAX.
 |
 | History: Mark Meier, Began 11/96.
 |          MM, 03/97, Modified for use with R2.
 |          MM, 04/97, Bug fixes, added viewing Object Offset Transformation.
\*===========================================================================*/
/*===========================================================================*\
 | Include Files
\*===========================================================================*/
#include "MAX.H"		// Main MAX include file
#include "utilapi.h"	// Utility Plug-in include file
#include "iparamm.h"	// Parameter Map include file
#include "resource.h"	// Resource editor include file

/*===========================================================================*\
 | Misc Defines
\*===========================================================================*/
#define MYUTIL_CLASS_ID Class_ID(0x6f5d6227, 0x47dd46ab)
#define CLASSNAME _T("Transform Test")
#define CATEGORY _T("How To")
#define LIBDESCRIPTION _T("Transformation Matrix Tester by Mark Meier")
#define UTIL_MSG_TITLE _T("Transform Tester")
#define UNDO_STRING TSTR(_T("Modify Node TM"))

// Parameter Map indices
#define PM_DO_TRANS 0
#define PM_DO_SCALE 1
#define PM_DO_X_ROTATE 2
#define PM_DO_Y_ROTATE 3
#define PM_DO_Z_ROTATE 4

#define PM_X_TRANS 5
#define PM_Y_TRANS 6
#define PM_Z_TRANS 7

#define PM_X_SCALE 8
#define PM_Y_SCALE 9
#define PM_Z_SCALE 10

#define PM_ROTATE 11
#define PM_AXIS_CHOICE 12

#define PM_DO_AUTO 13

// This is the DLL instance handle
HINSTANCE hInstance;

/*===========================================================================*\
 | Class definitions
\*===========================================================================*/
class Utility : public UtilityObj, public IParamArray {
	public:
	IUtil *iu;
	Interface *ip;

	// Variables for display of matrix values in a dialog
	float m00, m01, m02, m10, m11, m12, m20, m21, m22, m30, m31, m32;
	TCHAR viewTitle[128];

	// Custom controls used in rotation dialog
	ISpinnerControl *rotSpin;
	ICustEdit *rotEdit;

	// Parameter maps
	IParamMap *pmapMain;
	IParamMap *pmapScale;
	IParamMap *pmapTrans;
	IParamMap *pmapRot;

	HWND hViewTM;

	// Variables set by the parameter map
	int do_trans, do_scale, do_x_rotate, do_y_rotate, do_z_rotate, do_auto;
	int axis_choice;
	float x_trans, y_trans, z_trans;
	float x_scale, y_scale, z_scale;
	float angle;
		
	float x_rotate,y_rotate,z_rotate; // 'angle' gets assigned to one of these

	// Node in the scene we update by settings its Node TM.
	INode *node;

	// Methods from UtilityObj
	void BeginEditParams(Interface *ip, IUtil *iu);
	void EndEditParams(Interface *ip, IUtil *iu);
	void SelectionSetChanged(Interface *ip, IUtil *iu);
	void DeleteThis() {}  // Null since we use a single static instance

	// Methods from IParamArray
	BOOL SetValue(int i, TimeValue t, int v);
	BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
	BOOL SetValue(int i, TimeValue t, float v);
	BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);

	// Local methods...
	Utility();
	void Init(HWND hWnd);
	void Destroy(HWND hWnd);
	void ViewTrans();
	void ViewScale();
	void ViewXRotate();
	void ViewYRotate();
	void ViewZRotate();
	void ViewComposite();

	void ViewWorldRotation();
	void ViewLocalRotation();

	void UpdateNodeTM();
	void UpdateTM(Matrix3 &tmat);
	void LoadViewMatVars(Matrix3 mat);
	void ResetDefaultValues();
	void UpdateSinCosDisplay();
	void RedrawRollups();

	void ViewNodeTM();
	void ViewObjectTM();
	void ViewObjectOffset();
	void ViewObjTMBeforeWSM();
	void ViewObjTMAfterWSM();
	void ViewParentTM();
	void ViewTargetTM();
	void ViewObjectStateTM();
 	void ViewTMController();
	void SetMatrixTitleString(TCHAR *s, Interval v, INode *n);
};

// This is the static instance of the Utility plug-in.
static Utility theUtility;

// This is the restore object that contains the information allowing us
// to Undo or Redo the operation of setting the node TM.
class NodeTMRestore : public RestoreObj {
	public:
	Utility *uo;
	INode *undoNode, *redoNode;
	Matrix3 undoTM, redoTM;
	TimeValue undoTime, redoTime;

	// Constructor
	NodeTMRestore(Utility *u, INode *n, Matrix3 m, TimeValue t) { 
		uo = u; undoNode = n; undoTM = m; undoTime = t;
	}

	// Called when Undo is selected
	void Restore(int isUndo) {
		if (!isUndo)
			// This is NOT an undo operation ... we shouldn't get any of these
			// (but if we do, I'd like to know about it <g>)
			assert(0);
		// Make sure this is the same node...
		if (theUtility.node == undoNode) {
			//	1) Save the current node for a redo
			//	2) Save the current TM
			//	3) Save the current time
			redoTM = uo->node->GetNodeTM(undoTime);
			redoNode = uo->node;
			redoTime = undoTime;

			// Undo the operation
			undoNode->SetNodeTM(undoTime, undoTM);
			// Update the rollups and the viewports
			uo->RedrawRollups();
			uo->ip->RedrawViews(uo->ip->GetTime());
		}									
	}

	// Called when Redo is selected
	void Redo() {
		// Make sure this is the same node...
		if (uo->node == redoNode) {
			//	1) Save the current node
			//	2) Save the current TM
			//	3) Save the current time
			undoTM = uo->node->GetNodeTM(undoTime);
			undoNode = uo->node;
			undoTime = uo->ip->GetTime();

			// Redo the operation
			redoNode->SetNodeTM(redoTime, redoTM);
			// Update the rollups and the viewports
			uo->RedrawRollups();
			uo->ip->RedrawViews(uo->ip->GetTime());
		}
	}

	// Called to return the size in bytes of this RestoreObj
	int Size() {
		return sizeof(NodeTMRestore);
	}
};

/*===========================================================================*\
 | Parameter Map User Interface Descriptors and Dialog Procs
\*===========================================================================*/
// The following are arrays used by the Parameter Map mechanism to 
// describe the user interface controls.
static ParamUIDesc descMainParam[] = {
	// Check boxes
	ParamUIDesc(PM_DO_X_ROTATE, TYPE_SINGLECHEKBOX, IDC_CHECK_USE_X),
	ParamUIDesc(PM_DO_Y_ROTATE, TYPE_SINGLECHEKBOX, IDC_CHECK_USE_Y),
	ParamUIDesc(PM_DO_Z_ROTATE, TYPE_SINGLECHEKBOX, IDC_CHECK_USE_Z),
	ParamUIDesc(PM_DO_TRANS, TYPE_SINGLECHEKBOX, IDC_CHECK_USE_TR),
	ParamUIDesc(PM_DO_SCALE, TYPE_SINGLECHEKBOX, IDC_CHECK_USE_SC),
	ParamUIDesc(PM_DO_AUTO, TYPE_SINGLECHEKBOX, IDC_CHECK_AUTO),
};
#define MAIN_DESC_LENGTH 6

static ParamUIDesc descTransParam[] = {
	// Float spinners
	ParamUIDesc(PM_X_TRANS, EDITTYPE_UNIVERSE, IDC_SEDIT_XTR, IDC_SPIN_XTR,
		-1000000.0f, 1000000.0f, 1.0f),
	ParamUIDesc(PM_Y_TRANS, EDITTYPE_UNIVERSE, IDC_SEDIT_YTR, IDC_SPIN_YTR,
		-1000000.0f, 1000000.0f, 1.0f),
	ParamUIDesc(PM_Z_TRANS, EDITTYPE_UNIVERSE, IDC_SEDIT_ZTR, IDC_SPIN_ZTR,
		-1000000.0f, 1000000.0f, 1.0f),
};
#define TRANS_DESC_LENGTH 3

static ParamUIDesc descScaleParam[] = {
	// Float spinners
	ParamUIDesc(PM_X_SCALE, EDITTYPE_FLOAT, IDC_SEDIT_XSC, IDC_SPIN_XSC,
		0.001f, 100.0f, 1.0f),
	ParamUIDesc(PM_Y_SCALE, EDITTYPE_FLOAT, IDC_SEDIT_YSC, IDC_SPIN_YSC,
		0.001f, 100.0f, 1.0f),
	ParamUIDesc(PM_Z_SCALE, EDITTYPE_FLOAT, IDC_SEDIT_ZSC, IDC_SPIN_ZSC,
		0.001f, 100.0f, 1.0f),
};
#define SCALE_DESC_LENGTH 3

static int axisIDs[] = { IDC_RADIOX, IDC_RADIOY, IDC_RADIOZ };

static ParamUIDesc descRotateParam[] = {
	ParamUIDesc(PM_AXIS_CHOICE, TYPE_RADIO, axisIDs, 3)
};
#define ROT_DESC_LENGTH 1

// The following are Dialog Proc used to process the user interface
// controls not handled directly by the parameter maps
// This is the dialog proc for the matrix viewer
static BOOL CALLBACK ViewDlgProc(
	HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	TCHAR s[32];
	switch (msg) {
		case WM_INITDIALOG:
			CenterWindow(hWnd, GetParent(hWnd));
			SetWindowText(GetDlgItem(hWnd, IDC_VIEW_TITLE), 
				theUtility.viewTitle);

			_stprintf(s, _T("%.3f"), theUtility.m00);
			SetWindowText(GetDlgItem(hWnd, IDC_M00), s);
			_stprintf(s, _T("%.3f"), theUtility.m10);
			SetWindowText(GetDlgItem(hWnd, IDC_M10), s);
			_stprintf(s, _T("%.3f"), theUtility.m20);
			SetWindowText(GetDlgItem(hWnd, IDC_M20), s);
			_stprintf(s, _T("%.3f"), theUtility.m30);
			SetWindowText(GetDlgItem(hWnd, IDC_M30), s);
			_stprintf(s, _T("%.3f"), theUtility.m01);
			SetWindowText(GetDlgItem(hWnd, IDC_M01), s);
			_stprintf(s, _T("%.3f"), theUtility.m11);
			SetWindowText(GetDlgItem(hWnd, IDC_M11), s);
			_stprintf(s, _T("%.3f"), theUtility.m21);
			SetWindowText(GetDlgItem(hWnd, IDC_M21), s);
			_stprintf(s, _T("%.3f"), theUtility.m31);
			SetWindowText(GetDlgItem(hWnd, IDC_M31), s);
			_stprintf(s, _T("%.3f"), theUtility.m02);
			SetWindowText(GetDlgItem(hWnd, IDC_M02), s);
			_stprintf(s, _T("%.3f"), theUtility.m12);
			SetWindowText(GetDlgItem(hWnd, IDC_M12), s);
			_stprintf(s, _T("%.3f"), theUtility.m22);
			SetWindowText(GetDlgItem(hWnd, IDC_M22), s);
			_stprintf(s, _T("%.3f"), theUtility.m32);
			SetWindowText(GetDlgItem(hWnd, IDC_M32), s);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					EndDialog(hWnd,1);
					break;
				}
			break;
		
		default:
			return FALSE;
		}
	return TRUE;
}

class MainUserDlgProc : public ParamMapUserDlgProc {
	public:
		Utility *uo;
		MainUserDlgProc(Utility *u) {uo = u;}
		BOOL DlgProc(TimeValue t,IParamMap *map,
			HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() { delete this; }
};

BOOL MainUserDlgProc::DlgProc(TimeValue t, IParamMap *map,
	HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	switch (msg) {
		case WM_INITDIALOG:
			uo->Init(hWnd);			
			return FALSE;
		
		case WM_DESTROY:
			uo->Destroy(hWnd);
			return TRUE;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_VIEW_CURRENT:
					// Initialize and put up the matrix viewer dialog box
					uo->ViewComposite();
					DialogBox(hInstance, MAKEINTRESOURCE(IDD_VIEW),
						hWnd, ViewDlgProc);
					return TRUE;

				case IDC_NODE_TM:
					uo->UpdateNodeTM();
					return TRUE;

				case IDC_RESET: {
					// Verify..
					TSTR buf;
					buf.printf(_T("Really reset ALL transformation and dialog values?"));
					int res = MessageBox(uo->ip->GetMAXHWnd(), buf, 
						UTIL_MSG_TITLE, MB_YESNO|MB_ICONQUESTION);
					if (res == IDNO) break;

					// Hold the previous value of do_auto so we know
					// if we need to redraw after the values are reset
					int hold_do_auto = uo->do_auto;
					// Reset all values to their defaults...
					uo->ResetDefaultValues();
					// Make sure all the controls get redrawn
					uo->RedrawRollups();
					// If Auto is on, update the node TM to reflect this change
					if (hold_do_auto) {
						uo->UpdateNodeTM();
					}
					return TRUE;
				}
			}	
			break;

		default:
			return FALSE;
		}
	return FALSE; 
}

static BOOL CALLBACK ViewTMDlgProc(HWND hWnd, UINT msg, 
	WPARAM wParam, LPARAM lParam) {
 	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
			case IDC_NODETM: {
					theUtility.ViewNodeTM();
					DialogBox(hInstance, MAKEINTRESOURCE(IDD_VIEW),
						GetCOREInterface()->GetMAXHWnd(), ViewDlgProc);
							 }
					return TRUE;

				case IDC_OBJECTTM:
					theUtility.ViewObjectTM();
					DialogBox(hInstance, MAKEINTRESOURCE(IDD_VIEW),
						GetCOREInterface()->GetMAXHWnd(), ViewDlgProc);
					return TRUE;

				case IDC_OBJ_OFFSET:
					theUtility.ViewObjectOffset();
					return TRUE;

				case IDC_OBJTMBEFORE:
					theUtility.ViewObjTMBeforeWSM();
					DialogBox(hInstance, MAKEINTRESOURCE(IDD_VIEW),
						GetCOREInterface()->GetMAXHWnd(), ViewDlgProc);
					return TRUE;

				case IDC_OBJTMAFTER:
					theUtility.ViewObjTMAfterWSM();
					DialogBox(hInstance, MAKEINTRESOURCE(IDD_VIEW),
						GetCOREInterface()->GetMAXHWnd(), ViewDlgProc);
					return TRUE;

				case IDC_PARENTTM:
					theUtility.ViewParentTM();
					DialogBox(hInstance, MAKEINTRESOURCE(IDD_VIEW),
						GetCOREInterface()->GetMAXHWnd(), ViewDlgProc);
					return TRUE;

				case IDC_TARGETTM:
					theUtility.ViewTargetTM();
					DialogBox(hInstance, MAKEINTRESOURCE(IDD_VIEW),
						GetCOREInterface()->GetMAXHWnd(), ViewDlgProc);
					return TRUE;

				case IDC_OBJECTSTATE:
					theUtility.ViewObjectStateTM();
					DialogBox(hInstance, MAKEINTRESOURCE(IDD_VIEW),
						GetCOREInterface()->GetMAXHWnd(), ViewDlgProc);
					return TRUE;

				case IDC_TM:
					theUtility.ViewTMController();
					DialogBox(hInstance, MAKEINTRESOURCE(IDD_VIEW),
						GetCOREInterface()->GetMAXHWnd(), ViewDlgProc);
					return TRUE;
			}	
			break;

		default:
			return FALSE;
		}
	return FALSE; 
}

class TransUserDlgProc : public ParamMapUserDlgProc {
	public:
		Utility *uo;
		TransUserDlgProc(Utility *u) {uo = u;}
		BOOL DlgProc(TimeValue t,IParamMap *map,
			HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() { delete this; }
};

BOOL TransUserDlgProc::DlgProc(TimeValue t, IParamMap *map,
	HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_BUTTON_EDITTR:
					// Initialize and put up the matrix viewer dialog box
					uo->ViewTrans();
					DialogBox(hInstance, MAKEINTRESOURCE(IDD_VIEW),
						hWnd, ViewDlgProc);
				break;				
			}	
			break;
		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
			// If Auto is on, update the node TM to reflect this change
			if (uo->do_auto) {
				uo->UpdateNodeTM();
			}
		default:
			return FALSE;
	}
	return FALSE; 
}

class ScaleUserDlgProc : public ParamMapUserDlgProc {
	public:
		Utility *uo;
		ScaleUserDlgProc(Utility *u) {uo = u;}
		BOOL DlgProc(TimeValue t,IParamMap *map,
			HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() { delete this; }
};

BOOL ScaleUserDlgProc::DlgProc(TimeValue t, IParamMap *map,
	HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_BUTTON_EDITSC:
					// Initialize and put up the matrix viewer dialog box
					uo->ViewScale();
					DialogBox(hInstance, MAKEINTRESOURCE(IDD_VIEW),
						hWnd, ViewDlgProc);
				break;				
			}	
			break;
		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
			// If Auto is on, update the node TM to reflect this change
			if (uo->do_auto) {
				uo->UpdateNodeTM();
			}
		default:
			return FALSE;
	}
	return FALSE;
}

class RotateUserDlgProc : public ParamMapUserDlgProc {
	public:
		Utility *uo;
		RotateUserDlgProc(Utility *u) {uo = u;}
		BOOL DlgProc(TimeValue t,IParamMap *map,
			HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() { delete this; }
};

BOOL RotateUserDlgProc::DlgProc(TimeValue t, IParamMap *map,
	HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_BUTTON_VIEW:
					// Initialize and put up the matrix viewer dialog box
					switch (uo->axis_choice) {
						case 0: // X
							uo->ViewXRotate();
							break;
						case 1: // Y
							uo->ViewYRotate();
							break;
						case 2: // Z
							uo->ViewZRotate();
							break;
					}
					DialogBox(hInstance, MAKEINTRESOURCE(IDD_VIEW),
						hWnd, ViewDlgProc);
					break;
				case IDC_RADIOX:
					// Update matrix display for X
					SetWindowText(GetDlgItem(uo->pmapRot->GetHWnd(), 
						IDC_MATLINE1), _T("|  1  0  0  |"));
					SetWindowText(GetDlgItem(uo->pmapRot->GetHWnd(), 
						IDC_MATLINE2), _T("|  0  c  s  |"));
					SetWindowText(GetDlgItem(uo->pmapRot->GetHWnd(), 
						IDC_MATLINE3), _T("|  0 -s  c  |"));
					SetWindowText(GetDlgItem(uo->pmapRot->GetHWnd(), 
						IDC_BORDER), _T("X Rotation Matrix Layout"));
					uo->rotSpin->SetValue(uo->x_rotate, FALSE);
					SetWindowText(GetDlgItem(uo->pmapRot->GetHWnd(), 
						IDC_BORDER), _T("X Rotation Matrix Layout"));
					uo->UpdateSinCosDisplay();
					break;
				case IDC_RADIOY:
					// Update matrix display for Y
					SetWindowText(GetDlgItem(uo->pmapRot->GetHWnd(), 
						IDC_MATLINE1), _T("|  c  0 -s  |"));
					SetWindowText(GetDlgItem(uo->pmapRot->GetHWnd(), 
						IDC_MATLINE2), _T("|  0  1  0  |"));
					SetWindowText(GetDlgItem(uo->pmapRot->GetHWnd(), 
						IDC_MATLINE3), _T("|  s  0  c  |"));
					uo->rotSpin->SetValue(uo->y_rotate, FALSE);
					SetWindowText(GetDlgItem(uo->pmapRot->GetHWnd(), 
						IDC_BORDER), _T("Y Rotation Matrix Layout"));
					uo->UpdateSinCosDisplay();
					break;
				case IDC_RADIOZ:
					// Update matrix display for Z
					SetWindowText(GetDlgItem(uo->pmapRot->GetHWnd(), 
						IDC_MATLINE1), _T("|  c  s  0  |"));
					SetWindowText(GetDlgItem(uo->pmapRot->GetHWnd(), 
						IDC_MATLINE2), _T("| -s  c  0  |"));
					SetWindowText(GetDlgItem(uo->pmapRot->GetHWnd(), 
						IDC_MATLINE3), _T("|  0  0  1  |"));
					uo->rotSpin->SetValue(uo->z_rotate, FALSE);
					SetWindowText(GetDlgItem(uo->pmapRot->GetHWnd(), 
						IDC_BORDER), _T("Z Rotation Matrix Layout"));
					uo->UpdateSinCosDisplay();
					break;
			}
		break;
		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
			// There is only one spinner/edit control -- the angle 
			switch(uo->axis_choice) {
			case 0: // X
				uo->x_rotate = uo->rotSpin->GetFVal(); 
				break;
			case 1: // Y
				uo->y_rotate = uo->rotSpin->GetFVal(); 
				break;
			case 2: // Z
				uo->z_rotate = uo->rotSpin->GetFVal(); 
				break;
			}
			uo->pmapRot->Invalidate();
			uo->UpdateSinCosDisplay();
			// If Auto is on, update the node TM to reflect this change
			if (uo->do_auto) {
				uo->UpdateNodeTM();
			}
			break;
		default:
			return FALSE;
	}
	return FALSE; 
}

/*===========================================================================*\
 | Utility Plug-In Methods
\*===========================================================================*/
// From UtilityObj
void Utility::BeginEditParams(Interface *ip, IUtil *iu) {
	this->iu = iu;
	this->ip = ip;
	// Create the rollups in the command panel...
	hViewTM = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(IDD_VIEW_TM),
		ViewTMDlgProc, _T("View Various TMs"), (LPARAM)0, 0);		

	pmapMain = CreateCPParamMap(descMainParam, MAIN_DESC_LENGTH,
		this, ip, hInstance, MAKEINTRESOURCE(IDD_MAIN), _T("Transformations"),
		0);

	pmapTrans = CreateCPParamMap(descTransParam, TRANS_DESC_LENGTH,
		this, ip, hInstance, MAKEINTRESOURCE(IDD_TRANS), _T("Translate"),
		APPENDROLL_CLOSED);

	pmapScale = CreateCPParamMap(descScaleParam, SCALE_DESC_LENGTH,
		this, ip, hInstance, MAKEINTRESOURCE(IDD_SCALE), _T("Scale"),
		APPENDROLL_CLOSED);

	pmapRot = CreateCPParamMap(descRotateParam, ROT_DESC_LENGTH,
		this, ip, hInstance, MAKEINTRESOURCE(IDD_ROT), _T("Rotate"),
		APPENDROLL_CLOSED);

	// Indicate we'll use our own dialog procs to handle 
	// some of the buttons...
	pmapMain->SetUserDlgProc(new MainUserDlgProc(this));
	pmapTrans->SetUserDlgProc(new TransUserDlgProc(this));
	pmapScale->SetUserDlgProc(new ScaleUserDlgProc(this));
	pmapRot->SetUserDlgProc(new RotateUserDlgProc(this));

	// Verify that at least one node is selected...if not the 'Update Node TM'
	// button will not be enabled.
	SelectionSetChanged(ip, iu);
}
	
// This method is called when we are done using the Utility plug-in
void Utility::EndEditParams(Interface *ip, IUtil *iu) {
	// Delete the parameter maps
	if (pmapMain) { DestroyCPParamMap(pmapMain); pmapMain = NULL; }
	if (pmapTrans) { DestroyCPParamMap(pmapTrans); pmapTrans = NULL; }
	if (pmapScale) { DestroyCPParamMap(pmapScale); pmapScale = NULL; }
	if (pmapRot) { DestroyCPParamMap(pmapRot); pmapRot = NULL; }

	// Delete the rollup pages
	ip->DeleteRollupPage(hViewTM);

	// Set all our pointers to null since they are no longer valid
	// outside the BeginEditParams/EndEditParams interval
	this->iu = NULL;
	this->ip = NULL;
}

// Verify that at least one node is still selected...
void Utility::SelectionSetChanged(Interface *ip, IUtil *iu) {
	BOOL onOff;
	if (onOff = !(ip->GetSelNodeCount() < 1)) {
		// The user is behaving, enable the update node button
		node = ip->GetSelNode(0);
		EnableWindow(GetDlgItem(pmapMain->GetHWnd(), IDC_NODE_TM), 1);
	}
	else {
		// Not even one node ... Disable the button to update the node TM.
		node = NULL;
	}
	EnableWindow(GetDlgItem(pmapMain->GetHWnd(), IDC_NODE_TM), onOff);
	EnableWindow(GetDlgItem(hViewTM, IDC_TM), onOff);
	EnableWindow(GetDlgItem(hViewTM, IDC_NODETM), onOff);
	EnableWindow(GetDlgItem(hViewTM, IDC_OBJECTTM), onOff);
	EnableWindow(GetDlgItem(hViewTM, IDC_OBJ_OFFSET), onOff);
	EnableWindow(GetDlgItem(hViewTM, IDC_OBJTMBEFORE), onOff);
	EnableWindow(GetDlgItem(hViewTM, IDC_OBJTMAFTER), onOff);
	EnableWindow(GetDlgItem(hViewTM, IDC_PARENTTM), onOff);
	EnableWindow(GetDlgItem(hViewTM, IDC_TARGETTM), onOff);
	EnableWindow(GetDlgItem(hViewTM, IDC_OBJECTSTATE), onOff);
}

// From IParamArray
// These methods allow the parameter map to get and set the variables
// in our class.  Based on the index passed, retrieve or set the 
// corresponding variable.
BOOL Utility::SetValue(int i, TimeValue t, int v) {
	switch (i) {
		case PM_DO_TRANS: do_trans = v; break;
		case PM_DO_SCALE: do_scale = v; break;
		case PM_DO_X_ROTATE: do_x_rotate = v; break;
		case PM_DO_Y_ROTATE: do_y_rotate = v; break;
		case PM_DO_Z_ROTATE: do_z_rotate = v; break;
		case PM_DO_AUTO: do_auto = v; break;
		case PM_AXIS_CHOICE: axis_choice = v; break;
	}
	return TRUE;
}

BOOL Utility::GetValue(int i, TimeValue t, int &v, Interval &ivalid) {
	switch (i) {
		case PM_DO_TRANS: v = do_trans; break;
		case PM_DO_SCALE: v = do_scale; break;
		case PM_DO_X_ROTATE: v = do_x_rotate; break;
		case PM_DO_Y_ROTATE: v = do_y_rotate; break;
		case PM_DO_Z_ROTATE: v = do_z_rotate; break;
		case PM_DO_AUTO: v = do_auto; break;
		case PM_AXIS_CHOICE: v = axis_choice; break;
	}
	return TRUE;
}

BOOL Utility::SetValue(int i, TimeValue t, float v) {
	switch (i) {
		case PM_X_TRANS: x_trans = v; break;
		case PM_Y_TRANS: y_trans = v; break;
		case PM_Z_TRANS: z_trans = v; break;
		case PM_X_SCALE: x_scale = v; break;
		case PM_Y_SCALE: y_scale = v; break;
		case PM_Z_SCALE: z_scale = v; break;
	}
	return TRUE;
}

BOOL Utility::GetValue(int i, TimeValue t, float &v, Interval &ivalid) {
	switch (i) {
		case PM_X_TRANS: v = x_trans; break;
		case PM_Y_TRANS: v = y_trans; break;
		case PM_Z_TRANS: v = z_trans; break;
		case PM_X_SCALE: v = x_scale; break;
		case PM_Y_SCALE: v = y_scale; break;
		case PM_Z_SCALE: v = z_scale; break;
	}
	return TRUE;
}

/*===========================================================================*\
 | The Guts...Local methods of Utility
\*===========================================================================*/
// Constructor
Utility::Utility() {
	iu = NULL;
	ip = NULL;	

	ResetDefaultValues();
}

void Utility::Init(HWND hWnd) {
	rotEdit = GetICustEdit(GetDlgItem(pmapRot->GetHWnd(), IDC_SEDIT_ROT));
 	rotSpin = GetISpinner(GetDlgItem(pmapRot->GetHWnd(), IDC_SPIN_ROT));
	rotSpin->SetLimits(-360.0f, 360.0f, FALSE);
	rotSpin->SetScale(1.0f);
	rotSpin->SetResetValue(0.0f); // Right click reset value
	rotSpin->SetValue(0.0f, FALSE); // FALSE = don't send notify yet.
	rotSpin->LinkToEdit(GetDlgItem(pmapRot->GetHWnd(), IDC_SEDIT_ROT), 
		EDITTYPE_FLOAT);
}

void Utility::Destroy(HWND hWnd) {
	ReleaseISpinner(rotSpin);
	ReleaseICustEdit(rotEdit);
}

// Make sure all the user interface controls get redrawn
void Utility::RedrawRollups() {
	pmapMain->Invalidate();
	pmapScale->Invalidate();
	pmapTrans->Invalidate();
	pmapRot->Invalidate();
	UpdateSinCosDisplay();
}

// This updates the sine and cosine values displayed in the rotation
// rollup pages to reflect their current values.
void Utility::UpdateSinCosDisplay() {
	TCHAR s[32];
	switch (axis_choice) {
		case 0: // X
			_stprintf(s, _T("c=%.3f"), cos(DegToRad(x_rotate)));
			SetWindowText(GetDlgItem(pmapRot->GetHWnd(), IDC_C),s);
			_stprintf(s, _T("s=%.3f"), sin(DegToRad(x_rotate)));
			SetWindowText(GetDlgItem(pmapRot->GetHWnd(), IDC_S),s);
		break;
		case 1: // Y
			_stprintf(s, _T("c=%.3f"), cos(DegToRad(y_rotate)));
			SetWindowText(GetDlgItem(pmapRot->GetHWnd(), IDC_C),s);
			_stprintf(s, _T("s=%.3f"), sin(DegToRad(y_rotate)));
			SetWindowText(GetDlgItem(pmapRot->GetHWnd(), IDC_S),s);
		break;
		case 2: // Z
			_stprintf(s, _T("c=%.3f"), cos(DegToRad(z_rotate)));
			SetWindowText(GetDlgItem(pmapRot->GetHWnd(), IDC_C),s);
			_stprintf(s, _T("s=%.3f"), sin(DegToRad(z_rotate)));
			SetWindowText(GetDlgItem(pmapRot->GetHWnd(), IDC_S),s);
		break;
	};
}

// This method loads up some variables in the class in preparation
// for displaying them in the view matrix dialog box.
void Utility::LoadViewMatVars(Matrix3 mat) {
	MRow* m = mat.GetAddr();
	m00 = m[0][0];
	m01 = m[0][1];
	m02 = m[0][2];
	m10 = m[1][0];
	m11 = m[1][1];
	m12 = m[1][2];
	m20 = m[2][0];
	m21 = m[2][1];
	m22 = m[2][2];
	m30 = m[3][0];
	m31 = m[3][1];
	m32 = m[3][2];
}

void Utility::ResetDefaultValues() {
	// Init values used by the parameter maps...
	do_trans = do_scale = do_x_rotate = do_y_rotate = do_z_rotate = 1;
	do_auto = 0;
	axis_choice = 0; // X
	x_trans = y_trans = z_trans = 0.0f;
	x_scale = y_scale = z_scale = 1.0f;
	x_rotate = y_rotate = z_rotate = 0.0f;
	_tcscpy(viewTitle, _T("4x3 Transformation Matrix Values"));
}

void Utility::ViewTrans() {
	Point3 p(x_trans, y_trans, z_trans);
	Matrix3 tmat = TransMatrix(p);
	_tcscpy(viewTitle, _T("Translation Matrix Values"));
	LoadViewMatVars(tmat);
}

void Utility::ViewScale() {
	Point3 p(x_scale, y_scale, z_scale);
	Matrix3 tmat = ScaleMatrix(p);
	/*
	MRow* m = tmat.GetAddr();
	m[0][0] = x_scale;
	m[1][1] = y_scale;
	m[2][2] = z_scale;
	*/
	_tcscpy(viewTitle, _T("Scale Matrix Values"));
	LoadViewMatVars(tmat);
}

void Utility::ViewXRotate() {
	Matrix3 tmat = RotateXMatrix(DegToRad(x_rotate));
	_tcscpy(viewTitle, _T("X Rotation Matrix Values"));
	LoadViewMatVars(tmat);
}

void Utility::ViewYRotate() {
	Matrix3 tmat = RotateYMatrix(DegToRad(y_rotate));
	_tcscpy(viewTitle, _T("Y Rotation Matrix Values"));
	LoadViewMatVars(tmat);
}

void Utility::ViewZRotate() {
	Matrix3 tmat = RotateZMatrix(DegToRad(z_rotate));
	_tcscpy(viewTitle, _T("Z Rotation Matrix Values"));
	LoadViewMatVars(tmat);
}

void Utility::ViewComposite() {
	Matrix3 tmat(1); // Identity matrix
	UpdateTM(tmat);
	_tcscpy(viewTitle, _T("4x3 Transformation Matrix Values"));
	LoadViewMatVars(tmat);
}

// This method modifies the matrix passed based on the user's settings
void Utility::UpdateTM(Matrix3 &tmat) {
	Point3 p;
	// If there is a selected node start with its world space transformation
	if (node) {
		tmat = node->GetNodeTM(ip->GetTime());
	}
	// Based on the check boxes update the Matrix3
	if (do_x_rotate) {
		tmat.NoRot();
		Point3 p1;
		p1 = tmat.GetTrans();
		Point3 p2(-p1.x, -p1.y, -p1.z);
		tmat.SetTrans(p2);
		tmat.RotateX(DegToRad(x_rotate));
		tmat.SetTrans(p1);
		tmat.SetIdentFlags(tmat.GetIdentFlags() & ~ROT_IDENT);
	}
	if (do_y_rotate) {
		if (! do_x_rotate) tmat.NoRot();
		Point3 p1;
		p1 = tmat.GetTrans();
		Point3 p2(-p1.x, -p1.y, -p1.z);
		tmat.SetTrans(p2);
		tmat.RotateY(DegToRad(y_rotate));
		tmat.SetTrans(p1);
		tmat.SetIdentFlags(tmat.GetIdentFlags() & ~ROT_IDENT);
	}
	if (do_z_rotate) {
		if (! (do_x_rotate || do_y_rotate)) tmat.NoRot();
		Point3 p1;
		p1 = tmat.GetTrans();
		Point3 p2(-p1.x, -p1.y, -p1.z);
		tmat.SetTrans(p2);
		tmat.RotateZ(DegToRad(z_rotate));
		tmat.SetTrans(p1);
		tmat.SetIdentFlags(tmat.GetIdentFlags() & ~ROT_IDENT);
	}
	if (do_trans) {
		p.x = x_trans;
		p.y = y_trans;
		p.z = z_trans;
		tmat.SetTrans(p);
		tmat.SetIdentFlags(tmat.GetIdentFlags() & ~POS_IDENT);
	}
	if (do_scale) {
		//p.x = x_scale;
		//p.y = y_scale;
		//p.z = z_scale;
		//tmat.SetScale(p);
		MRow* m = tmat.GetAddr();
		m[0][0] = x_scale;
		m[1][1] = y_scale;
		m[2][2] = z_scale;
		tmat.SetIdentFlags(tmat.GetIdentFlags() & ~SCL_IDENT);
	}
}

void Utility::UpdateNodeTM() {
	Matrix3 tmat(1); // Identity matrix

	// Prepare for a potential Undo by putting a Restore Object 
	// onto the undo system stack
	theHold.Begin();
	theHold.Put(new NodeTMRestore(
		this, node, node->GetNodeTM(ip->GetTime()), ip->GetTime()));
	theHold.Accept(UNDO_STRING);

	// Update the NodeTM (make sure we are not in amimate mode)
	UpdateTM(tmat);
	SuspendAnimate();
	AnimateOff();
	node->SetNodeTM(ip->GetTime(), tmat);
	ResumeAnimate();

	ip->RedrawViews(ip->GetTime());
}

void Utility::ViewNodeTM() {
	Interval valid = FOREVER;
	INode *n = ip->GetSelNode(0); 
	Matrix3 tmat(1);
	tmat = n->GetNodeTM(ip->GetTime(), &valid);
	LoadViewMatVars(tmat);
	SetMatrixTitleString(_T("GetNodeTM()"), valid, n);
}

void Utility::ViewObjectTM() {
	Interval valid = FOREVER;
	INode *n = ip->GetSelNode(0); 
	Matrix3 tmat(1);
	tmat = n->GetObjectTM(ip->GetTime(), &valid);
	LoadViewMatVars(tmat);
	SetMatrixTitleString(_T("GetObjectTM()"), valid, n);
}

void Utility::ViewObjectOffset() {
	TSTR buf;
	Interval valid = FOREVER;
	INode *n = ip->GetSelNode(0); 

	Point3 p = n->GetObjOffsetPos();
	buf.printf("(%.2f, %.2f, %.2f)", p.x, p.y, p.z);
	MessageBox(NULL, buf.data(), _T("Object Offset Position"), MB_OK);

	ScaleValue s = n->GetObjOffsetScale();
	buf.printf("(%.2f, %.2f, %.2f)", s.s.x, s.s.y, s.s.z);
	MessageBox(NULL, buf.data(), _T("Object Offset Scale"), MB_OK);

	float ang[3];
	Quat q = n->GetObjOffsetRot();
	QuatToEuler(q, ang);
	buf.printf("(%.2f, %.2f, %.2f)", 
		RadToDeg(ang[0]), RadToDeg(ang[1]), RadToDeg(ang[2]));
	MessageBox(NULL, buf.data(), _T("Object Offset Rotation"), MB_OK);
}

void Utility::ViewObjTMBeforeWSM() {
	Interval valid = FOREVER;
	INode *n = ip->GetSelNode(0); 
	Matrix3 tmat(1);
	tmat = n->GetObjTMBeforeWSM(ip->GetTime(), &valid);
	LoadViewMatVars(tmat);
	SetMatrixTitleString(_T("GetObjTMBeforeWSM()"), valid, n);
}

void Utility::ViewObjTMAfterWSM() {
	Interval valid = FOREVER;
	INode *n = ip->GetSelNode(0); 
	Matrix3 tmat(1);
	tmat = n->GetObjTMAfterWSM(ip->GetTime(), &valid);
	LoadViewMatVars(tmat);
	SetMatrixTitleString(_T("GetObjTMAfterWSM()"), valid, n);
}

void Utility::ViewParentTM() {
	Interval valid = FOREVER;
	INode *n = ip->GetSelNode(0); 
	Matrix3 tmat(1);
	tmat = n->GetParentTM(ip->GetTime());
	LoadViewMatVars(tmat);
	SetMatrixTitleString(_T("GetParentTM()"), NEVER, n);
}

void Utility::ViewTargetTM() {
	int haveIt;
	Matrix3 tmat(1);
	Interval valid = FOREVER;
	INode *n = ip->GetSelNode(0); 

	haveIt = n->GetTargetTM(ip->GetTime(), tmat);
	if (haveIt) {
		LoadViewMatVars(tmat);
		SetMatrixTitleString(_T("GetTargetTM()"), NEVER, n); // *** never
	}
	else {
		LoadViewMatVars(tmat);
		SetMatrixTitleString(_T("***Node has no Target***"), NEVER, n);
	}
}

void Utility::ViewObjectStateTM() {
	Interval tmValid = FOREVER;
	INode *n = ip->GetSelNode(0); 
	Matrix3 tmat(1);

	ObjectState os = n->EvalWorldState(ip->GetTime());
	Matrix3 *mat = os.GetTM();
	tmValid = os.tmValid();

	if (mat) {
		tmat = *mat;
		SetMatrixTitleString(_T("ObjectState.GetTM()"), tmValid, n);
	}
	else {
		SetMatrixTitleString(_T("GetTM() returned NULL"), tmValid, n);
	}

	LoadViewMatVars(tmat);
}

void Utility::ViewTMController() {
	Interval valid = FOREVER;
	INode *n = ip->GetSelNode(0); 
	Matrix3 tmat(1);
	Control *pos, *rot, *scl;
	Point3 p;
	Quat q;

	ViewLocalRotation();
	ViewWorldRotation();

	// Pre-multiply in position, rotation, scale order
	TimeValue t = ip->GetTime();
	pos = node->GetTMController()->GetPositionController();
	pos->GetValue(t, &tmat, valid, CTRL_RELATIVE);
	rot = node->GetTMController()->GetRotationController();
	rot->GetValue(t, &tmat, valid, CTRL_RELATIVE);
	scl = node->GetTMController()->GetScaleController();
	scl->GetValue(t, &tmat, valid, CTRL_RELATIVE);

	LoadViewMatVars(tmat);
	SetMatrixTitleString(_T("Show TM Controller"), valid, n);
}

void Utility::ViewWorldRotation() {
	Interval valid = FOREVER;
	INode *n = ip->GetSelNode(0); 
	Matrix3 tmat;

	Control *c = node->GetTMController();
	tmat = n->GetParentTM(ip->GetTime());
	c->GetValue(ip->GetTime(), &tmat, valid, CTRL_RELATIVE);

	Quat q(tmat);
	float ang[3];
	QuatToEuler(q, ang);

	TSTR buf;
	buf.printf(_T("XRot=%.1f, YRot=%.1f, ZRot=%.1f"), 
		RadToDeg(ang[0]), RadToDeg(ang[1]), RadToDeg(ang[2]));

	MessageBox(NULL, buf.data(), _T("World Rotation"), MB_OK);
}

void Utility::ViewLocalRotation() {
	Interval valid = FOREVER;
	INode *n = ip->GetSelNode(0); 
	Matrix3 tmat;
	
	Control *c = node->GetTMController();
	tmat.IdentityMatrix();
	c->GetValue(ip->GetTime(), &tmat, valid, CTRL_RELATIVE);

	Quat q(tmat);
	float ang[3];
	QuatToEuler(q, ang);

	TSTR buf;
	buf.printf(_T("XRot=%.1f, YRot=%.1f, ZRot=%.1f"), 
		RadToDeg(ang[0]), RadToDeg(ang[1]), RadToDeg(ang[2]));

	MessageBox(NULL, buf.data(), _T("Local Rotation"), MB_OK);
}

void Utility::SetMatrixTitleString(TCHAR *s, Interval v, INode *n) {
	TSTR start, end;

	// Save symbolic TimeValue names, not integers if we can...
	if (v.Start() == TIME_NegInfinity) {
		start = _T("TIME_NegInfinity");
	}
	else if (v.Start() == TIME_PosInfinity) {
		start = _T("TIME_PosInfinity");
	}
	else  {
		TimeToString(v.Start(), start);
	}

	if (v.End() == TIME_NegInfinity) {
		end = _T("TIME_NegInfinity");
	}
	else if (v.End() == TIME_PosInfinity) {
		end = _T("TIME_PosInfinity");
	}
	else {
		TimeToString(v.End(), end);
	}

	_stprintf(viewTitle, _T("%s->%s: s=%s, e=%s"), n->GetName(), 
		s, start.data(), end.data());
}

/*===========================================================================*\
 | Class Descriptor
\*===========================================================================*/
class UtilityClassDesc : public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theUtility;}
	const TCHAR *	ClassName() {return CLASSNAME;}
	SClass_ID		SuperClassID() {return SClass_ID(UTILITY_CLASS_ID);}
	Class_ID		ClassID() {return MYUTIL_CLASS_ID;}
	const TCHAR* 	Category() {return CATEGORY;}
};
// A single static instance of our class descriptor.
static UtilityClassDesc utilityDesc;

/*===========================================================================*\
 | DLL/Lib Functions
\*===========================================================================*/
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {	
	hInstance = hinstDLL;
	if (! controlsInit) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}
	return(TRUE);
}

__declspec(dllexport) const TCHAR *LibDescription() {
	return LIBDESCRIPTION;
}

__declspec(dllexport) int LibNumberClasses() { 
	return 1; 
}

__declspec(dllexport) ClassDesc* LibClassDesc(int i) { 
	return &utilityDesc; 
}

__declspec(dllexport) ULONG LibVersion() { 
	return VERSION_3DSMAX; 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\3dsmtl.cpp ===
/*******************************************************************
 *
 *    DESCRIPTION: 3DSMTL.CPP: 3dsr4 material utilities
 *
 *    AUTHOR:
 *
 *    HISTORY:    
 *
 *******************************************************************/
#include "Max.h"
#include <stdio.h>
#include <direct.h>
#include <commdlg.h>
#include "splshape.h"
#include "3dsires.h"
#include "imtl.h"
#include "dummy.h"
#include "3dsimp.h"
#include "mtldef.h"
#include "gamma.h"


void XMFree(void *p) { if (p) free(p); }

void XMFreeAndZero(void **p) {
	if (p) {
		if (*p) {
			free(*p);
			*p = NULL;
			}
		}
	}

void *XMAlloc(int size) { return malloc(size); }

void *XMAllocZero(int size) { 
	void *p = malloc(size);
	memset(p,0,size);
	return p;
	}


static Color_24 blackcol = {0,0,0};
static Color_24 whitecol = {255,255,255};

int TexBlurToPct(float tb) {
	return((int)(tb*100.0+.5));	
	}

float PctToTexBlur(int p) {
	return((float)p/100.0f);	
	}

void ResetMapData(MapData *md, int n, int ismask) {
	memset(md,0,sizeof(MapData));
	if ((!ismask)&&(n==Nrefl)) {
		md->kind = 1;
		md->p.ref.acb.shade = REND_METAL;
		md->p.ref.acb.aalevel = 0;
		md->p.ref.acb.flags = 0;
		md->p.ref.acb.size = 100;
		md->p.ref.acb.nth = 1;
		}
	else {
		md->p.tex.texblur = PctToTexBlur(10 /*P.texture_blur_default*/);
		md->p.tex.uscale = 1.0f;
		md->p.tex.vscale = 1.0f;
		md->p.tex.uoffset = 0.0f;
		md->p.tex.voffset = 0.0f;
		md->p.tex.ang_sin = 0.0f;
		md->p.tex.ang_cos = 1.0f;
		md->p.tex.col1 = blackcol;
		md->p.tex.col2 = whitecol;
		md->p.tex.rcol = 	md->p.tex.gcol = 	md->p.tex.bcol = blackcol;
		md->p.tex.rcol.r = 255;
		md->p.tex.gcol.g = 255;
		md->p.tex.bcol.b = 255;
		}
	}

void InitMappingValues(Mapping *m, int n, int isRmtl) {
	if (isRmtl) m->amt.f = 1.0f;
	else m->amt.pct = 100;
	ResetMapData(&m->map,n,0);
	ResetMapData(&m->mask,n,1);
	}


void FreeMapDataRefs(MapData *md) {
//	Cubmap *cm,*nextcm;
	switch(md->kind) {
		case 0:
			XMFreeAndZero(&md->p.tex.sxp_data);
			break;
		case 1:
#if 0
			if (md->p.ref.acb.flags&AC_ON) {
				for (cm =(Cubmap *)md->p.ref.bm; cm!=NULL; cm=nextcm) {
					nextcm = cm->next;
					XMFree(cm);
					}
				}
			else{
				char ext[5];
				split_fext(md->name,NULL,ext);
				if(stricmp(ext,".CUB")==0) {
					if (md->p.ref .bm!=NULL)
						XMFree(md->p.ref.bm);
					}
				}
#endif
			break;
		}	
	}

void FreeMatRefs(SMtl *m) {
	int k;
	if (m->appdata) XMFreeAndZero(&m->appdata);
	for (k=0; k<NMAPTYPES; k++) {
		if (m->map[k]) {
			FreeMapDataRefs(&m->map[k]->map);
			FreeMapDataRefs(&m->map[k]->mask);
			XMFreeAndZero((void **)&m->map[k]);
			}
		}
	}


void ResetMapping(Mapping *m, int n, int isRmtl) {
	FreeMapDataRefs(&m->map);
	FreeMapDataRefs(&m->mask);
	memset(m,0,sizeof(Mapping));
	InitMappingValues(m,n,isRmtl);
	}

Mapping *NewMapping(int n,int isRmtl) {
	Mapping *m;
	m = (Mapping*)XMAllocZero(sizeof(Mapping));
	if (m==NULL) return(NULL);
	InitMappingValues(m,n,isRmtl);
	return(m);
	}


void init_mtl_struct(SMtl *mtl) {
	memset(mtl,0,sizeof(SMtl));
	mtl->shininess=50;
	mtl->shin2pct = 255; /* undefined */
	mtl->transparency=0;
	mtl->shading=3;
	mtl->wiresize = 1.0f;
	}

void set_mtl_decal(SMtl *mtl) {
	int i;
	Mapping *m;
	for (i=0; i<NMAPTYPES; i++) {
		if ((m=mtl->map[i])!=NULL) {
			if (m->map.kind==0)
				m->map.p.tex.texflags |= TEX_DECAL|TEX_NOWRAP;
			if (m->mask.kind==0)
				m->mask.p.tex.texflags |= TEX_DECAL|TEX_NOWRAP;
			}
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\3dsimp.cpp ===
/**********************************************************************
 *<
	FILE: 3dsimp.cpp

	DESCRIPTION:  .3DS/.SHP file import module

	CREATED BY: Tom Hudson

	HISTORY: created 26 December 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "Max.h"
#include <stdio.h>
#include <direct.h>
#include <commdlg.h>
#include "splshape.h"
#include "3dsires.h"
#include "imtl.h"
#include "dummy.h"
#include "3dsimp.h"
#include "mtldef.h"
#include "istdplug.h"
#include "stdmat.h"
#include "gamma.h"
#include "helpsys.h"

//#define PRINTCHUNKID

HINSTANCE hInstance;

static BOOL showPrompts;

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}


static int MessageBox(int s1, int s2, int option = MB_OK) {
	TSTR str1(GetString(s1));
	TSTR str2(GetString(s2));
	return MessageBox(GetActiveWindow(), str1, str2, option);
	}

static int MessageBox2(int s1, int s2, int option = MB_OK) {
	TSTR str1(GetString(s1));
	TSTR str2(GetString(s2));
	return MessageBox(GetActiveWindow(), str1, str2, option);
	}

static int MessageBox(TCHAR *s, int s2, int option = MB_OK) {
	TSTR str1(s);
	TSTR str2(GetString(s2));
	return MessageBox(GetActiveWindow(), str1, str2, option);
	}


// 3DS-to-MAX time constant multiplier
#define TIME_CONSTANT GetTicksPerFrame()

//#define DBGPRINT


// The file stream

static FILE *stream;

// The debugging dump stream

static FILE *dStream;

// Some stuff we're defining (for now)

static int merging = 0;
static int lastchunk;
#define OBJ_NAME_LEN 10
static char obname[32];
static int nodeLoadNumber = -1;
static short cur_node_id,nodeflags,nodeflags2;
static int nodetag;
static int skipNode = 0;
static ImpNode *obnode;
static short readVers;
static int skipped_nodes = 0;
static int got_mat_chunk;
static BGdata BG;
static BOOL replaceScene =0;
static BOOL autoConv = 1;
static BOOL importShapes = TRUE;
static BOOL needShapeImportOptions = FALSE;
static BOOL shapeImportAbort = FALSE;

// Some handy macros
static float msc_wk;

void
split_fn(char *path,char *file,char *pf)
	{
	int ix,jx,bs_loc,fn_loc;
	if(strlen(pf)==0) {
		if(path) *path=0;
		if(file) *file=0;
		return;
		}
	bs_loc=strlen(pf);
	for(ix=bs_loc-1; ix>=0; --ix) {
		if(pf[ix]=='\\')  {
			bs_loc=ix;
			fn_loc=ix+1;
			goto do_split;
			}
		if(pf[ix]==':') {
			bs_loc=ix+1;
			fn_loc=ix+1;
			goto do_split;
			}
		}
	bs_loc= -1;
	fn_loc=0;

	do_split:
	if(file)
		strcpy(file,&pf[fn_loc]);
	if(path) {
		if(bs_loc>0)  {
			for(jx=0; jx<bs_loc; ++jx)
				path[jx]=pf[jx];
			path[jx]=0;
			}
		else  path[0]=0;
		}
	}


void fin_degammify(Color *col, Color *gamcol) {
	if (gammaMgr.enable) {
		col->r = deGammaCorrect(gamcol->r, gammaMgr.fileInGamma);
		col->g = deGammaCorrect(gamcol->g, gammaMgr.fileInGamma);
		col->b = deGammaCorrect(gamcol->b, gammaMgr.fileInGamma);
		}
	else *col = *gamcol;
	}

static Color ColorFrom24(Color_24 c) {
	Color a;
	a.r = (float)c.r/255.0f;
	a.g = (float)c.g/255.0f;
	a.b = (float)c.b/255.0f;
	return a;
	}

//==========================================================================
// Setup Environment
//==========================================================================
int ObjWorker::SetupEnvironment() {
	if (!replaceScene) 
		return 1;
	i->SetAmbient(0,BG.amb_light);	
	i->SetBackGround(0,BG.bkgd_solid);	
	i->SetUseMap(FALSE);
	switch(BG.bgType) {
		case BG_SOLID: 
			break;
		case BG_GRADIENT: 
			{
			GradTex *gt = NewDefaultGradTex();
			gt->SetColor(0, BG.bkgd_gradient.topcolor);
			gt->SetColor(1, BG.bkgd_gradient.midcolor);
			gt->SetColor(2, BG.bkgd_gradient.botcolor);
			gt->SetMidPoint(1.0f-BG.bkgd_gradient.midpct);
			gt->GetUVGen()->SetCoordMapping(UVMAP_SCREEN_ENV);
			i->SetEnvironmentMap(gt);
			i->SetUseMap(TRUE);
			}
			break;
		case BG_BITMAP: 
			if (strlen(BG.bkgd_map)>0) {
				BitmapTex *bmt = NewDefaultBitmapTex();
				bmt->SetMapName(TSTR(BG.bkgd_map));
				bmt->GetUVGen()->SetCoordMapping(UVMAP_SCREEN_ENV);
				i->SetEnvironmentMap(bmt);
				i->SetUseMap(TRUE);
				}
			break;
		}	
	switch(BG.envType) {
		case ENV_DISTCUE:
			//	BG.distance_cue.nearplane; ??
			//	BG.distance_cue.farplane;  ??
			{
			StdFog *fog = NewDefaultStdFog();
			fog->SetType(0);  
			fog->SetColor(Color(0.0f,0.0f,0.0f),0);  
			fog->SetNear(BG.distance_cue.neardim/100.0f,0);  
			fog->SetFar(BG.distance_cue.fardim/100.0f,0);  
			fog->SetFogBackground(BG.dim_bg);
			i->AddAtmosphere(fog);			
			}				
			break;
		case ENV_FOG:{
			StdFog *fog = NewDefaultStdFog();
			fog->SetType(0);  
			fog->SetColor(BG.fog_data.color,0);  
			fog->SetNear(BG.fog_data.neardens/100.0f,0);  
			fog->SetFar(BG.fog_data.fardens/100.0f,0);  
			fog->SetFogBackground(BG.fog_bg);
			i->AddAtmosphere(fog);			
			}
			break;
		case ENV_LAYFOG:{
			StdFog *fog = NewDefaultStdFog();
			fog->SetType(1);  
			int ftype;
			switch(BG.lfog_data.type) {
				case 1:  ftype = FALLOFF_BOTTOM; break;
				case 2:  ftype = FALLOFF_TOP; break;
				default: ftype = FALLOFF_NONE; break;
				}
			fog->SetFalloffType(ftype);  
			fog->SetColor(BG.lfog_data.color,0);  
			fog->SetDensity(BG.lfog_data.density*100.0f,0);  
			fog->SetTop(BG.lfog_data.zmax,0);  
			fog->SetBottom(BG.lfog_data.zmin,0);  
			fog->SetFogBackground(BG.lfog_data.fog_bg);
			i->AddAtmosphere(fog);			
			}
			break;
		}
	i->SetAmbient(0,BG.amb_light);
	return 1;
	}

static int MAXMapIndex(int i) {
	switch(i) {
		case Ntex:  return ID_DI;
		case Ntex2: return ID_DI;
		case Nopac: return ID_OP;
		case Nbump: return ID_BU;
		case Nspec: return ID_SP;
		case Nshin: return ID_SS;
		case Nselfi:return ID_SI; 
		case Nrefl: return ID_RL;
		default:    return ID_DI;
		}
	}

//=========================================================
// Match 3DStudio's "Default" material
static StdMat *New3DSDefaultMtl() {
	StdMat *m = NewDefaultStdMat();
	m->SetName(_T("Default"));
	m->SetAmbient(Color(.7f,.7f,.7f),0);
	m->SetDiffuse(Color(.7f,.7f,.7f),0);
	m->SetSpecular(Color(1.0f,1.0f,1.0f),0);
	m->SetShininess(0.5f,0);
	m->SetShinStr(.707f,0);
	return m;
	}

static BOOL IsSXPName(char *name) {
	char fname[30];
	char ext[5];
	_splitpath(name, NULL, NULL, fname, ext );
	return stricmp(ext,".sxp")==0?1:0;
	}

static Texmap* MakeTex(MapData& map, SMtl *smtl, BOOL &wasSXP) {
	Texmap *txm; 
	wasSXP = FALSE;
	if (map.kind==0) { 
		// Texture Map
//		if (IsSXPName(map.name)&&(map.p.tex.sxp_data!=NULL)) {
		if (IsSXPName(map.name)) {	 // DS - 6/11/96
			Tex3D *t3d = GetSXPReaderClass(map.name);
			if (t3d) {
				if (map.p.tex.sxp_data) {
					ULONG *p = (ULONG *)map.p.tex.sxp_data;
					t3d->ReadSXPData(map.name, (void *)(p+1));
					wasSXP = TRUE;
					}
				}
			txm = t3d;							
			}
		else {
			BitmapTex *bmt = NewDefaultBitmapTex();
			bmt->SetMapName(TSTR(map.name));
			MapParams &par = map.p.tex;
			bmt->SetAlphaAsMono((par.texflags&TEX_ALPHA_SOURCE)?1:0);
			bmt->SetAlphaSource((par.texflags&TEX_DONT_USE_ALPHA)?ALPHA_NONE:ALPHA_FILE);
			bmt->SetFilterType((par.texflags&TEX_SAT)?FILTER_SAT:FILTER_PYR);
			StdUVGen *uv = bmt->GetUVGen();
			uv->SetUOffs(par.uoffset,0);
			uv->SetVOffs(-par.voffset,0);
			uv->SetUScl(par.uscale,0);
			uv->SetVScl(par.vscale,0);
			uv->SetAng(-((float)atan2(par.ang_sin, par.ang_cos)),0);
			uv->SetBlur(par.texblur+1.0f,0);
			int tile=0;
			if (par.texflags&TEX_MIRROR) tile|= U_MIRROR|V_MIRROR;
			else {
				if (0==(par.texflags&TEX_NOWRAP)) tile|= U_WRAP|V_WRAP;
				}
			uv->SetTextureTiling(tile);
			TextureOutput *txout = bmt->GetTexout();
			txout->SetInvert(par.texflags&TEX_INVERT?1:0);
			txm = bmt;
			}
		if (map.p.tex.texflags&TEX_TINT) {
			// map.p.tex.col1, col2	: stuff into Mix	
			MultiTex* mix = NewDefaultMixTex();
			mix->SetColor(0,ColorFrom24(map.p.tex.col1));
			mix->SetColor(1,ColorFrom24(map.p.tex.col2));
			mix->SetSubTexmap(2, txm);
			txm = mix;			
			}
		else if (map.p.tex.texflags&TEX_RGB_TINT) {
			// map.p.tex.rcol,gcol,bcol : stuf into tint
			MultiTex* mix = NewDefaultTintTex();
			mix->SetColor(0,ColorFrom24(map.p.tex.rcol));
			mix->SetColor(1,ColorFrom24(map.p.tex.gcol));
			mix->SetColor(2,ColorFrom24(map.p.tex.bcol));
			mix->SetSubTexmap(0, txm);
			txm = mix;			
			}
		}
	else {  
		// kind == 1 :  Reflection Map
		BitmapTex *bmt = NewDefaultBitmapTex();
		bmt->SetMapName(TSTR(map.name));
		StdUVGen *uv = bmt->GetUVGen();

		// TBD: REFLECTION BLUR SETTING:
		uv->SetBlurOffs((float)smtl->refblur/400.0f+.001f,0);
		bmt->InitSlotType(MAPSLOT_ENVIRON);
		txm = bmt;
		}


	return txm;
	}

//==========================================================================
// Convert mesh mtl to max standard matl.
//==========================================================================
void ObjWorker::AddMeshMtl(SMtl *smtl) {
	StdMat *m;
	Mesh *mesh = NULL;
	if (smtl==NULL) {
		m = New3DSDefaultMtl();
		loadMtls.AddMtl(m);			
		loadMtlMesh.Append(1,&mesh,10);
		return;
		}
	m = NewDefaultStdMat();
	m->SetName(TSTR(smtl->name));
	int shade;
	switch(smtl->shading) {
		case REND_FLAT:  shade = SHADE_CONST; break;
		case REND_METAL: shade = SHADE_METAL; break;
		default:		 shade = SHADE_PHONG; break;
		}
	m->SetShading(shade);
	m->SetAmbient(ColorFrom24(smtl->amb),0);
	m->SetDiffuse(ColorFrom24(smtl->diff),0);
	m->SetFilter(ColorFrom24(smtl->diff),0);
	m->SetSpecular(ColorFrom24(smtl->spec),0);
	m->SetShininess((float)smtl->shininess/100.0f,0);
	m->SetShinStr((float)smtl->shin2pct/100.0f,0);
	m->SetOpacity(1.0f-(float)smtl->transparency/100.0f,0);
	m->SetOpacFalloff((float)smtl->xpfall/100.0f, 0);		
	m->SetFalloffOut(smtl->flags&MF_XPFALLIN?0:1);  
	m->SetSelfIllum((float)smtl->selfipct/100.0f,0);
	m->SetWireSize(smtl->wiresize,0);
	m->SetFaceMap(smtl->flags&MF_FACEMAP?1:0);
	m->SetSoften(smtl->flags&MF_PHONGSOFT?1:0);
	m->SetWire(smtl->flags&MF_WIRE?1:0);
	m->SetTwoSided(smtl->flags&MF_TWOSIDE?1:0);
	m->SetTransparencyType(smtl->flags&MF_ADDITIVE ? TRANSP_ADDITIVE : TRANSP_FILTER);
	m->SetWireUnits(smtl->flags&MF_WIREABS?1:0);


	if (smtl->map) {
		Texmap *txm;
		float amt,amt0;
		BOOL gotTex=0;
		BOOL dum;
		for (int i=0; i<8; i++) {
			if (smtl->map[i]==NULL) 
				continue;
			Mapping &mp = *(smtl->map[i]);
			int n = MAXMapIndex(i);
			if (i==Nrefl) {
				amt = (float)mp.amt.pct/100.0f;
				RMapParams &par = mp.map.p.ref;
				if (par.acb.flags&AC_ON) {	
					// Mirror or Auto-cubic
					if (par.acb.flags&AC_MIRROR) {
						StdMirror *mir = NewDefaultStdMirror();
						txm = (Texmap *)mir;
						mir->SetDoNth(par.acb.flags&AC_FIRSTONLY?0:1);
						mir->SetNth(par.acb.nth);
						}
					else {
						StdCubic *cub = NewDefaultStdCubic();
						txm = (Texmap *)cub;
						cub->SetSize(par.acb.size,0);
						cub->SetDoNth(par.acb.flags&AC_FIRSTONLY?0:1);
						cub->SetNth(par.acb.nth);
						}
					}
				else {	
					// Environment map
					txm = MakeTex(mp.map,smtl,dum);
					}

				if (strlen(mp.mask.name)>0) {
					// make a Mask texmap.
					Texmap *masktex = (Texmap *)CreateInstance(TEXMAP_CLASS_ID, Class_ID(MASK_CLASS_ID,0));
					masktex->SetSubTexmap(1,MakeTex(mp.mask,smtl,dum));
					masktex->SetSubTexmap(0,txm);
					txm = masktex;
					}

				m->SetSubTexmap(n,txm);
				amt = (float)mp.amt.pct/100.0f;
				m->SetTexmapAmt(n, amt, 0);
				}
			else {
					
				// non-reflection maps
				amt = (float)mp.amt.pct/100.0f;

				// DS: 4/30/97 correct for new interpretation of the
				// amount sliders.
				switch(i) {
					case Nopac:	 
						if (amt<1.0f) 
							m->SetOpacity(0.0f,0); 
						break;
					case Nselfi: 
						if (amt<1.0f) 
							m->SetSelfIllum(0.0f,0); 
						break;
					case Nshin:  
						// Shininess mapping in 3DS was really shininess strength mapping
						amt*= (float)smtl->shin2pct/100.0f;
						m->SetShinStr(0.0f,0);
						break;
					}

				BOOL wasSXP;
				txm = MakeTex(mp.map,smtl,wasSXP);
				if (n==ID_BU&&!wasSXP) amt *= 10.0f;
				m->SetTexmapAmt(n, amt, 0);
				if (strlen(mp.mask.name)>0) {
					// make a Mask texmap.
					Texmap *masktex = (Texmap *)CreateInstance(TEXMAP_CLASS_ID, Class_ID(MASK_CLASS_ID,0));
					masktex->SetSubTexmap(1,MakeTex(mp.mask,smtl,dum));
					masktex->SetSubTexmap(0,txm);
					txm = masktex;
					}
				if (i==Ntex2) {
					if (gotTex) {
						// Make a Composite texmap
						MultiTex *comp = NewDefaultCompositeTex();
						comp->SetNumSubTexmaps(2);
						Texmap *tm0 = m->GetSubTexmap(ID_DI);
						comp->SetSubTexmap(0,tm0);
						comp->SetSubTexmap(1,txm);
						m->SetSubTexmap(ID_DI,comp);						
						if (tm0) 
							tm0->SetOutputLevel(0,amt0);
						if (txm)
							txm->SetOutputLevel(0,amt);
						m->SetTexmapAmt(ID_DI,1.0f,0);
						}
					else {
						m->SetSubTexmap(ID_DI,txm);						
						m->SetTexmapAmt(n,amt,0);
						}
					} 
				else 
					m->SetSubTexmap(n,txm);
				if (i==Ntex&&txm) {
					gotTex=1;
					amt0 = amt;
					}
				}
			m->EnableMap(n,mp.use);
			}
		}
	loadMtls.AddMtl(m);			
	loadMtlMesh.Append(1,&mesh,10);
	}

Mtl *ObjWorker::GetMaxMtl(int i) {
	if (i<0) return NULL;
	if (i>=loadMtls.Count()) return NULL;
	return loadMtls[i];
	}

int ObjWorker::GetMatNum(char *name) {
	TSTR s(name);
	for (int i=0; i<loadMtls.Count(); i++) {
		if (_tcscmp(s,loadMtls[i]->GetName())==0)
			return i;
		}
	assert(0);
	return 0;
	}

void ObjWorker::AssignMtl(INode *theINode, Mesh *mesh) {
	short used[256],cused[256],remap[256];
	int i;

	// First check if another instance of this mesh has already
	// had a material assigned to it.
	for (i=0; i<loadMtlMesh.Count(); i++) {
		if (loadMtlMesh[i]==mesh) {
			theINode->SetMtl(loadMtls[i]);
			return ;
			}
		}
	for (i=0; i<256; i++) used[i] = 0;
	// See if a multi-mtl is required.
	int nmtl,numMtls=0;
	for (i =0; i<mesh->numFaces; i++) {
		nmtl = mesh->faces[i].getMatID();
		assert(nmtl<256);
		if (!used[nmtl]) {
			used[nmtl] = 1;
			remap[nmtl] = numMtls;
			cused[numMtls++] = nmtl;
			}
		}
	if (numMtls>1) { 
		// Need a Multi-mtl
		// scrunch the numbers down to be local to this multi-mtl
		for (i =0; i<mesh->numFaces; i++) 	{
			Face &f = mesh->faces[i];
			int id = f.getMatID();
			f.setMatID(remap[id]);
			}
		// create a new multi with numMtls, and set them
		// to GetMaxMtl(cused[i]), i==0..numMtls-1
		MultiMtl *newmat = NewDefaultMultiMtl();
		newmat->SetNumSubMtls(numMtls);
		for (i=0; i<numMtls; i++) 
			newmat->SetSubMtl(i,GetMaxMtl(cused[i]));
		theINode->SetMtl(newmat);
		loadMtls.AddMtl(newmat);			
		loadMtlMesh.Append(1,&mesh,10);
		}
	else {
		if (mesh->getNumFaces()) {
			nmtl = mesh->faces[0].getMatID();
			for (i =0; i<mesh->numFaces; i++) 
				mesh->faces[i].setMatID(0);
			theINode->SetMtl(GetMaxMtl(nmtl));
			loadMtlMesh[nmtl] = mesh;
			}
		}
	}


int CountRefs(ReferenceTarget *rt) {
	DependentIterator di(rt);
	int nrefs = 0;
	RefMakerHandle rm;
	while (NULL!=(rm=di.Next())) 
		nrefs++;
	return nrefs;			
	}

void ObjWorker::FreeUnusedMtls() {
	for (int i=0; i<loadMtls.Count(); i++) {
		if (CountRefs(loadMtls[i])==0) {
			loadMtls[i]->DeleteThis();
			}			
		}
	loadMtls.SetCount(0);
	}



//===========================================================


// Handy pointers to importers
StudioShapeImport *theShapeImport = NULL;
StudioImport *theImport = NULL;

// ObjWorker class

ObjWorker::ObjWorker(ImpInterface *iptr,Interface *ip) {
	okay=1;
	i=iptr;
	shape=NULL;
	objects=NULL;
	nodes=NULL;
	dummy=NULL;
	isDummy=0;
	Reset();
	lengthSet = FALSE;
	segmentSet = FALSE;
	appdata = NULL;
	appdataLen = 0;
	gotM3DMAGIC=FALSE;
	this->ip = ip;
	for (int i=0;i<256;i++) {
		sceneMtls[i] = NULL;
		mtlNames[i].s[0] = 0;
		}
	hook_x = hook_y = 0.0f;
	}

void
ObjWorker::Reset() {
	mode=WORKER_IDLE;
	tm.IdentityMatrix();
	gotverts=gottverts=gotfaces=verts=faces=0;
	id = -1;
	object=NULL;
	light=NULL;
	camera=NULL;
	dummy = NULL;
	isDummy = 0;
	mesh=NULL;
	shape=NULL;
	spline=NULL;
	splShape = NULL;
	parentNode = thisNode = NULL;
	// NEW INITS
	workNode = NULL;	
	pivot = Point3(0,0,0);
	cstShad = 1;
	rcvShad = 1;
	newTV.SetCount(0);
	}

int
ObjWorker::StartMesh(const char *iname) {
	if(!FinishUp())
		return 0;
//DebugPrint("Starting mesh %s\n",iname);
	if(dStream) {
		fprintf(dStream,"Starting mesh:%s\n",iname);
		fflush(dStream);
		}
	tm.IdentityMatrix();
	name = TSTR(iname);
	object = CreateNewTriObject();
	if(!object)
		return 0;
	mesh = &object->GetMesh();
	mode = WORKER_MESH;
	newTV.SetCount(0);
	return 1;
	}

int
ObjWorker::StartLight(const char *iname) {
	if(!FinishUp())
		return 0;
	if(dStream) {
		fprintf(dStream,"Starting mesh:%s\n",iname);
		fflush(dStream);
		}
	tm.IdentityMatrix();
	name = TSTR(iname);
	light = NULL;
	mode = WORKER_LIGHT;	
	return 1;
	}

int
ObjWorker::CreateLight(int type) {
	assert(mode==WORKER_LIGHT);
	light = i->CreateLightObject(type);
	if(!light) {
		DebugPrint("Light type %d create failure\n",type);
		return 0;
		}
//DebugPrint("Created light obj %d/%p\n",type,light);
	lightType = (type == OMNI_LIGHT) ? OBJ_OMNILIGHT : OBJ_SPOTLIGHT;

	SuspendAnimate();
	AnimateOff();

	Point3 col;
	col[0] = studioLt.color[0];
	col[1] = studioLt.color[1];
	col[2] = studioLt.color[2];
	light->SetRGBColor(0,col);
	light->SetUseLight(studioLt.flags&NO_LT_ON);
	light->SetSpotShape(studioLt.flags&NO_LT_RECT ? RECT_LIGHT : CIRCLE_LIGHT);
	light->SetConeDisplay(studioLt.flags&NO_LT_CONE ? 1 : 0, FALSE);
	light->SetUseAtten(studioLt.flags&NO_LT_ATTEN ? 1 : 0);
	light->SetAttenDisplay(0);
	light->SetUseGlobal(studioLt.flags&NO_LT_LOCAL ? 0 : 1);
	light->SetShadow(studioLt.flags&NO_LT_SHAD ? 1 : 0);
	light->SetOvershoot(studioLt.flags&NO_LT_OVER ? 1 : 0);
	light->SetShadowType(studioLt.flags&NO_LT_RAYTR ? 1 : 0);
	light->SetAtten(0, ATTEN_START, studioLt.in_range);
	light->SetAtten(0, ATTEN_END, studioLt.out_range);
	light->SetIntensity(0, studioLt.mult);
	float aspect = 1.0f/studioLt.aspect;	
	light->SetAspect(0, aspect);	
	light->SetMapBias(0, studioLt.lo_bias);
	light->SetMapRange(0, studioLt.shadfilter);
	light->SetMapSize(0, studioLt.shadsize);
	light->SetRayBias(0, studioLt.ray_bias);
	// ? light->SetAbsMapBias(int a);	
	light->SetExclusionList(studioLt.excList);
	light->SetHotspot(0,studioLt.hotsize);
	light->SetFallsize(0,studioLt.fallsize);
	studioLt.excList.SetSize(0);

	ResumeAnimate();
	return 1;
	}

int
ObjWorker::StartCamera(const char *iname) {
	if(!FinishUp())
		return 0;
	if(dStream) {
		fprintf(dStream,"Starting mesh:%s\n",iname);
		fflush(dStream);
		}
	tm.IdentityMatrix();
	name = TSTR(iname);
	camera = NULL;
	mode = WORKER_CAMERA;
	return 1;
	}

int
ObjWorker::CreateCamera(int type) {
	assert(mode==WORKER_CAMERA);
	camera = i->CreateCameraObject(type);
	camera->SetEnvRange(0, 0, studioCam.nearplane);
	camera->SetEnvRange(0, 1, studioCam.farplane);
	camera->SetFOV(0, DegToRad(2400.0/studioCam.focal));

	if(!camera) {
		DebugPrint("Camera type %d create failure\n",type);
		return 0;
		}
//DebugPrint("Created camera obj %d/%p\n",type,camera);
	return 1;
	}

int
ObjWorker::StartKF(ImpNode *node) {
	if(!FinishUp())
		return 0;
	if(dStream) {
		fprintf(dStream,"Starting KF node\n");
		fflush(dStream);
		}
	thisNode = node;
	parentNode = NULL;
	mode = WORKER_KF;
	pivot = Point3(0,0,0);	// Default pivot
	return 1;
	}

int
ObjWorker::StartShape() {
	if(!FinishUp())
		return 0;
	if(dStream) {
		fprintf(dStream,"Starting shape\n");
		fflush(dStream);
		}
	if(!object) {
		tm.IdentityMatrix();
		splShape = new SplineShape;
		if(!splShape)
			return 0;
		shape = &splShape->GetShape();
		shape->NewShape();
		}
	mode = WORKER_SHAPE;
	return 1;
	}

int
ObjWorker::StartSpline() {
	// If there's a shape already, and we're outputting multiple shapes, output it!
	if(shape && theShapeImport && theShapeImport->importType == MULTIPLE_SHAPES) {
		FinishShape();
		FinishUp();
		}

	// If no shape yet, start one!
	if(!shape) {
		if(!StartShape())
			return 0;
		}
	spline = shape->NewSpline();
	if(!spline)
		return 0;
	return 1;
	}

int
ObjWorker::AddShapePoint(Shppt *p) {
	if(!spline)
		return 0;
	int type = KTYPE_BEZIER_CORNER;	// Default to corner
	// See if this is a smooth bezier
	Point3 invec(p->inx,p->iny,p->inz);
	float inlen = Length(invec);
	Point3 outvec(p->outx,p->outy,p->outz);
	float outlen = Length(outvec);
	if(inlen != 0.0f && outlen != 0.0f) {
		Point3 normin = Normalize(invec);
		Point3 normout = Normalize(outvec);
		Point3 lowtest = -normin * 0.98f;
		Point3 hightest = -normin * 1.02f;
		if(((normout.x >= lowtest.x && normout.x <= hightest.x) || (normout.x <= lowtest.x && normout.x >= hightest.x)) && 
		   ((normout.y >= lowtest.y && normout.y <= hightest.y) || (normout.y <= lowtest.y && normout.y >= hightest.y)) && 
		   ((normout.z >= lowtest.z && normout.z <= hightest.z) || (normout.z <= lowtest.z && normout.z >= hightest.z)))
		   	type = KTYPE_BEZIER;
		}	
	spline->AddKnot(SplineKnot(type,LTYPE_CURVE,Point3(p->x,p->y,p->z),
		Point3(p->x+p->inx,p->y+p->iny,p->z+p->inz),Point3(p->x+p->outx,p->y+p->outy,p->z+p->outz)));
	return 1;
	}

int
ObjWorker::CloseSpline() {
	if(!spline)
		return 0;
	spline->SetClosed();
	return 1;
	}

int
ObjWorker::FinishShape() {
	if(!shape)
		return 0;
	shape->UpdateSels();	// Make sure it readies the selection set info
	shape->InvalidateGeomCache();
	return 1;
	}



#define NextChunk(hdr)  ((Chunk_hdr *)(((char  *)hdr)+hdr->size))
#define SubChunk(hdr)  ((Chunk_hdr *)(((char  *)hdr)+6))

typedef unsigned short ushort;

typedef struct {
	ushort id;
	ulong length;
	char data[100];
	} ChunkHdr;

void whoa(){}

static Object *CreateObjectFromAppData(
		TriObject *tobj, void *data, DWORD len)
	{
	Chunk_hdr *sub, *hdr = (Chunk_hdr*)data;
	Object *obj;
	char idstring[100];
	int noff, nbytes = (int)len;	

	noff = 0;

	// DS 6/7/96: put in check for hdr->size<0 to catch bad appdata
	// chunks.
	while (noff<nbytes) {
		if (hdr->tag != XDATA_ENTRY) goto next; // if it aint XDATA_ENTRY we don't want it
		sub = SubChunk(hdr);
		if (sub->tag!= XDATA_APPNAME) goto next;
		
		// Try to convert it to an object
		GetIDStr((char*)hdr,idstring);
		obj = ObjectFromAppData(tobj, idstring, (void*)sub, hdr->size-6);
		if (obj) return obj;
		
	  next:
		if (hdr->size<0) break; 
		noff += hdr->size;
		hdr = NextChunk(hdr);
		}

	return NULL;
	}


int
ObjWorker::FinishUp() {
	switch(mode) {
		case WORKER_IDLE:
			return 1;	// Nothing to do, return success!
		case WORKER_MESH: {
			
			// Must have defined verts!
			if(gotverts) {

				// Make this an inverse of the mesh matrix.  This sets up a transform which will
				// be used to transform the mesh from the 3DS Editor-space to the neutral space
				// used by the keyframer.
#ifdef DBGPRINT
DebugPrint("WORKER_MESH TM:\n");
for(int i = 0; i < 4; ++i) {
	Point3 p = tm.GetRow(i);
	DebugPrint("%.4f %.4f %.4f\n",p.x,p.y,p.z);
	}
#endif	
				Matrix3 itm = Inverse(tm);
#ifdef DBGPRINT
DebugPrint("WORKER_MESH inverse TM:\n");
for(i = 0; i < 4; ++i) {
	Point3 p = tm.GetRow(i);
	DebugPrint("%.4f %.4f %.4f\n",p.x,p.y,p.z);
	}
#endif	
				int ix;	
		
				// Transform verts through the inverted mesh transform
				for(ix=0; ix<verts; ++ix) {
					Point3 &p = mesh->getVert(ix);
					p = p * itm;
					mesh->setVert(ix,p);
					}

				/* Check for objects that have been flipped: their 3D
					"parity" will be off */    
				Point3 cp = CrossProd(tm.GetRow(0),tm.GetRow(1));
				if (DotProd(cp,tm.GetRow(2))<0) {
					Matrix3 tmFlipX(1);
					Point3 row0 = tmFlipX.GetRow(0);
					row0.x = -1.0f;
					tmFlipX.SetRow(0,row0);
					// Transform verts through the mirror transform
					for(ix=0; ix<verts; ++ix) {
						Point3 &p = mesh->getVert(ix);
						p = p * tmFlipX;
						mesh->setVert(ix,p);
						}
					}

				mesh->buildNormals();
				mesh->EnableEdgeList(1);				
				}

			if(gottverts) {
				int ntv;
				if ((ntv=newTV.Count())>0) {
					int oldn = mesh->numTVerts;
					mesh->setNumTVerts(oldn+ntv, TRUE); 
					for (int i=0; i<ntv; i++)
						mesh->tVerts[oldn+i] = newTV[i];
					}
				}

			if (appdata) {
				// See if we can create an object from the appdata
				Object *obj = 
					CreateObjectFromAppData(object,appdata,appdataLen);
				if (obj) {
					obj->AddAppDataChunk(
						triObjectClassID, 
						GEOMOBJECT_CLASS_ID, 
						0, appdataLen, appdata);
					// first need to save away its mtl num
					int mnum = -1;
					if (mesh&&mesh->numFaces)
						mnum = mesh->faces[0].getMatID();
					// Then can toss it
					object->DeleteThis(); // don't need tri object
					object = NULL;
					AddObject(obj,OBJ_OTHER,name,NULL,mnum);
					appdata = NULL;  //DS 3/27/96
					Reset();
					return 1;
					}

				// Stick app data in the object
				object->AddAppDataChunk(
					triObjectClassID, 
					GEOMOBJECT_CLASS_ID, 
					0, appdataLen, appdata);
				appdata = NULL;
				}

			AddObject(object,OBJ_MESH,name,&tm);
			if(dStream) {
				fprintf(dStream,"Adding object %s\n",CStr(name));
				fflush(dStream);
				}
			Reset();
			return 1;
			}

		case WORKER_KF: {
			
			if (appdata) {				
				// Stick app data in the node
				thisNode->GetINode()->AddAppDataChunk(
					thisNode->GetINode()->ClassID(), 
					thisNode->GetINode()->SuperClassID(), 
					0, appdataLen, appdata);
				appdata = NULL;
				}

			if(dStream) {
				fprintf(dStream,"Finalizing %s\n",CStr(NodeName(thisNode)));
				fflush(dStream);
				}

			int type = FindTypeFromNode(thisNode, &mesh);

			if(parentNode) {
				if(dStream)
					{
					fprintf(dStream,"Attaching %s to %s\n",CStr(NodeName(thisNode)),CStr(NodeName(parentNode)));
					fflush(dStream);
					}
				parentNode->GetINode()->AttachChild(thisNode->GetINode());
				}

 			switch(type) {
				case OBJ_MESH:
				case OBJ_DUMMY:
				case OBJ_TARGET:
				case OBJ_OTHER:
					thisNode->SetPivot(-pivot);
					break;
				}
			Reset();
			return 1;
			}
		case WORKER_SHAPE:

			// Must have defined shape object!
			if(splShape) {
				ImpNode *node = i->CreateNode();
				if(!node) {
					Reset();
					return 0;
					}
				node->Reference(splShape);
				tm.IdentityMatrix();		// Reset initial matrix to identity
				tm.SetTrans(Point3(hook_x, hook_y, 0.0f));	// TH 3/30/96
				node->SetTransform(0,tm);
				i->AddNodeToScene(node);
				TSTR name;
				name.printf(GetString(IDS_DB_SHAPE_NUM),theShapeImport->shapeNumber++);
				node->SetName(name);
				Reset();
				return 1;
				}

			if(!shape && showPrompts)
				MessageBox(name,IDS_DB_MISSING_SHAPE);

			shape = NULL;
			Reset();
			return 1; 
		case WORKER_LIGHT: {
			if(dStream) {
				fprintf(dStream,"Finalizing light %s\n",CStr(NodeName(thisNode)));
				fflush(dStream);
				}

			// Must have a light
			if(light) {
//DebugPrint("Light calling AddObject %p (%d) %s\n",light,lightType,name);
				AddObject(light, lightType, name, &tm);				
				objects->targPos = 
					Point3(studioLt.tx,studioLt.ty,studioLt.tz);
				objects->srcPos = 
					Point3(studioLt.x,studioLt.y,studioLt.z);
				Reset();
				return 1;
				}

			if(showPrompts)
				MessageBox(name,IDS_DB_LIGHT_ERROR);
			
			delete light;
			Reset();
			return 1;
			}
		case WORKER_CAMERA:
			if(dStream) {
				fprintf(dStream,"Finalizing camera %s\n",CStr(NodeName(thisNode)));
				fflush(dStream);
				}

			// Must have a camera
			if(camera) {
				AddObject(camera, OBJ_CAMERA, name, &tm);
				objects->targPos = 
					Point3(studioCam.tx,studioCam.ty,studioCam.tz);
				objects->srcPos = 
					Point3(studioCam.x,studioCam.y,studioCam.z);
				Reset();
				return 1;
				}

			if(showPrompts)
				MessageBox(name,IDS_DB_CAMERA_ERROR);
			
			delete camera;
			Reset();
			return 1;
		}

	// Undefined state!!!
	return 0;
	}


int ObjWorker::LoadAppData(FILE *stream,DWORD chunkSize)
	{
	appdata = malloc(chunkSize);
	if (!appdata) return 0;
	appdataLen = chunkSize;
	RDERR(appdata,appdataLen);
	return 1;
	}



int
ObjWorker::SetDummyBounds(Point3& dMin,Point3& dMax) {
   	if(!isDummy)
		return 0;

	dummy->SetBox(Box3(dMin,dMax));	

#if 0
   	float dummyVertX[] =
		{(float)dMin.x,(float)dMax.x,(float)dMax.x,(float)dMin.x,(float)dMin.x,(float)dMax.x,(float)dMax.x,(float)dMin.x};
	float dummyVertY[] =
		{(float)dMin.y,(float)dMin.y,(float)dMax.y,(float)dMax.y,(float)dMin.y,(float)dMin.y,(float)dMax.y,(float)dMax.y};
	float dummyVertZ[] =
		{(float)dMin.z,(float)dMin.z,(float)dMin.z,(float)dMin.z,(float)dMax.z,(float)dMax.z,(float)dMax.z,(float)dMax.z};

	int ix;

	Mesh *mesh = &dummy->Mesh();

	// Stuff verts
	for(ix=0; ix<8; ++ix)
		mesh->setVert(ix,Point3(dummyVertX[ix],dummyVertY[ix],dummyVertZ[ix]));

	mesh->buildNormals();
#endif
	return 1;
	}

void
ObjWorker::SetInstanceName(ImpNode *node, const TCHAR *iname) {
	TSTR instancename(iname);
	if(!nodename.Length() && instancename.Length())
		node->SetName(iname);
	else
	if(!instancename.Length() && nodename.Length())
		node->SetName(nodename);
	else {
		TSTR fullname = nodename + TSTR(_T(".")) + iname;
		node->SetName(fullname);
		}
	}

int
ObjWorker::ReadyDummy() {
	if(dummy)
		return 1;		// Already exists!

	dummy = new DummyObject();
	dummy->SetBox(Box3(
		-Point3(0.5f,0.5f,0.5f),
		 Point3(0.5f,0.5f,0.5f)));

#if 0
	static int dummyFaceA[] =
		{0,2,0,5,1,6,2,7,3,4,4,6};
	static int dummyFaceB[] =
		{3,1,1,4,2,5,3,6,0,7,5,7};
	static int dummyFaceC[] =
		{2,0,5,0,6,1,7,2,4,3,6,4};

	// Create a triobj (for now)
	TriObject *object = CreateNewTriObject();
	if(!object)
		return 0;
	mesh = &object->Mesh();

	if(!mesh->setNumVerts(8)) {
		delete object;
		return 0;
		}
	if(!mesh->setNumFaces(12)) {
		delete object;
		return 0;
		}

	dummy = object;

	int ix;

	// Stuff faces
	for(ix=0; ix<12; ++ix) {
		Face *fp = &mesh->faces[ix];
		fp->setVerts(dummyFaceA[ix],dummyFaceB[ix],dummyFaceC[ix]);
		fp->setEdgeVisFlags(1,1,0);
		fp->setSmGroup(1 << (ix/2));
		}

	// Stuff verts
	SetDummyBounds(Point3((float)-0.5,(float)-0.5,(float)-0.5),Point3((float)0.5,(float)0.5,(float)0.5));

 	mesh->EnableEdgeList(1);
#endif
	return 1;
	}

ImpNode *
ObjWorker::MakeDummy(const TCHAR *name) {
	if(!ReadyDummy())
		return NULL;
	ImpNode *node = i->CreateNode();
	if(!node || !dummy) {
		return NULL;
		}
	node->Reference(dummy);
	tm.IdentityMatrix();		// Reset initial matrix to identity
	node->SetTransform(0,tm);
	i->AddNodeToScene(node);
	node->SetName(name);
	AddNode(node,name,OBJ_DUMMY,mesh,"");
	return node;
	}

ImpNode *
ObjWorker::MakeANode(const TCHAR *name, BOOL target, char *owner) {
	int type, cstShad, rcvShad, mtlNum;
	Object *obj;
	// For now, it MUST have an object unless it's a target!
	if(!target) {
		// RB: changed cou
		if(!(obj = (Object *)FindObject((TCHAR*)name, type, cstShad, rcvShad, mtlNum))) {
			if(showPrompts)
				MessageBox((TCHAR *)name,IDS_DB_NO_OBJECT);
			return NULL;
			}
		UseObject((TCHAR*)name);
		}
	else {
		type = OBJ_TARGET;
		obj = i->CreateTargetObject();
		}
	if(type==OBJ_MESH)
		mesh = &(((TriObject *)obj)->GetMesh());
	else
		mesh = NULL;
	ImpNode *node = i->CreateNode();
	if(!node)
		return NULL;
	node->Reference((ObjectHandle)obj);
	tm.IdentityMatrix();		// Reset initial matrix to identity
	node->SetTransform(0,tm);
	node->GetINode()->SetCastShadows(cstShad);
	node->GetINode()->SetRcvShadows(rcvShad);
	i->AddNodeToScene(node);
	node->SetName(name);
	AddNode(node,name,type,mesh,owner,mtlNum);
	return node;
	}

int
ObjWorker::SetVerts(int count) {
	if(gotverts) {
		if(showPrompts)
			MessageBox(name,IDS_DB_HAS_VERTS);
		return 0;
		}
	if(!mesh->setNumVerts(count)) {
		if(showPrompts)
			MessageBox(name,IDS_DB_NUMVERTS_FAIL);
		return 0;
		}
	verts = count;
	gotverts = 1;
	return 1;
	}

int
ObjWorker::SetTVerts(int count) {
	if(gottverts) {
		if(showPrompts)
			MessageBox(name,IDS_DB_HAS_TVERTS);
		return 0;
		}
	if(!mesh->setNumTVerts(count)) {
		if(showPrompts)
			MessageBox(name,IDS_DB_NUMVERTS_FAIL);
		return 0;
		}
//DebugPrint("Set %d tverts\n",count);
	tverts = count;
	gottverts = 1;
	return 1;
	}

int
ObjWorker::SetFaces(int count) {
	if(gotfaces) {
		if(showPrompts)
			MessageBox(name,IDS_DB_HAS_FACES);
		return 0;
		}
	if(!mesh->setNumFaces(count)) {
		if(showPrompts)
			MessageBox(name,IDS_DB_NUMFACES_FAIL);
		return 0;
		}
	// If got texture vertices, set up an equal number of texture faces
	if(gottverts) {
		if(!mesh->setNumTVFaces(count)) {
			if(showPrompts)
				MessageBox(name,IDS_DB_NUMTVFACES_FAIL);
			return 0;
			}
		}
	faces = count;
	gotfaces = 1;
	return 1;
	}

int
ObjWorker::PutVertex(int index,Verts *v) {
	if(!gotverts) {
		if(showPrompts)
			MessageBox(IDS_DB_PUT_NO_VERTS,IDS_DB_3DSIMP);
		return 0;
		}
	if(index<0 || index>=verts) {
		if(showPrompts)
			MessageBox(IDS_DB_VERTS_OR,IDS_DB_3DSIMP);
		return 0;
		}
	mesh->setVert(index,v->x,v->y,v->z);
	return 1;
	}

int
ObjWorker::PutTVertex(int index,UVVert *v) {
	if(!gottverts) {
		if(showPrompts)
			MessageBox(IDS_DB_PUT_NO_TVERTS,IDS_DB_3DSIMP);
		return 0;
		}
	if(index<0 || index>=tverts) {
		if(showPrompts)
			MessageBox(IDS_DB_TVERTS_OR,IDS_DB_3DSIMP);
		return 0;
		}
	mesh->setTVert(index,*v);
	return 1;
	}

static void check_for_wrap(UVVert *tv, int flags) {
	float d;
	if (flags&UWRAP) {
		float maxu,minu;
		maxu = minu = tv[0].x;
		if (tv[1].x>maxu) maxu = tv[1].x;
		else if (tv[1].x<minu) minu = tv[1].x;
		if (tv[2].x>maxu) maxu = tv[2].x;
		else if (tv[2].x<minu) minu = tv[2].x;
		if ((maxu-minu)>0.8f) {
			d = (float)ceil(maxu-minu);
			if (tv[0].x<.5f)  tv[0].x += d; 
			if (tv[1].x<.5f)  tv[1].x += d; 
			if (tv[2].x<.5f)  tv[2].x += d; 
			}
		}
	if (flags&VWRAP) {
		float maxv,minv;
		maxv = minv = tv[0].y;
		if (tv[1].y>maxv) maxv = tv[1].y;
		else if (tv[1].y<minv) minv = tv[1].y;
		if (tv[2].y>maxv) maxv = tv[2].y;
		else if (tv[2].y<minv) minv = tv[2].y;
		if ((maxv-minv)>0.8f) {
			d = (float)ceil(maxv-minv);
			if (tv[0].y<.5f)  tv[0].y += d; 
			if (tv[1].y<.5f)  tv[1].y += d; 
			if (tv[2].y<.5f)  tv[2].y += d; 
			}
		}
	}

DWORD ObjWorker::AddNewTVert(UVVert p) {
	// see if already have it in the new verts.
	int ntv = newTV.Count();
	for (int i=0; i<ntv; i++)
		if (p == newTV[i]) return i + mesh->numVerts;
	// otherwise, add it.
	return 	(DWORD)newTV.Append(1,&p,10) + mesh->numVerts;
	}


void 
ObjWorker::SetTVerts(int nf, Faces *f) {
	UVVert uv[3], uvnew[3]; 
	DWORD ntv[3];
	uvnew[0] = uv[0] = mesh->tVerts[f->a];
	uvnew[1] = uv[1] = mesh->tVerts[f->b];
	uvnew[2] = uv[2] = mesh->tVerts[f->c];
	check_for_wrap(uvnew, f->flags);
	ntv[0] = (uvnew[0]==uv[0]) ? f->a: AddNewTVert(uvnew[0]);
	ntv[1] = (uvnew[1]==uv[1]) ? f->b: AddNewTVert(uvnew[1]);
	ntv[2] = (uvnew[2]==uv[2]) ? f->c: AddNewTVert(uvnew[2]);
	TVFace *tf = &mesh->tvFace[nf];
	tf->setTVerts(ntv[0], ntv[1], ntv[2]);
	}

int
ObjWorker::PutFace(int index,Faces *f) {
	Face *fp = &mesh->faces[index];
	if(!gotfaces) {
		if(showPrompts)
			MessageBox(IDS_DB_PUT_NO_FACES,IDS_DB_3DSIMP);
		return 0;
		}
	if(index<0 || index>=faces)	{
		if(showPrompts)
			MessageBox(IDS_DB_FACES_OR,IDS_DB_3DSIMP);
		return 0;
		}
	// If we've got texture vertices, also put out a texture face
	if(gottverts) {
		// DS 6/6/96
		// check for wrap.
// fix 990920  --prs.
        int q = mesh->getNumTVerts();
        if (f->a < 0 || f->a >= q || f->b < 0 || f->b >= q ||
            f->c < 0 || f->c >= q) {
            if(showPrompts)
                MessageBox(IDS_PRS_TVERT_OR,IDS_DB_3DSIMP);
            return 0;
	        }
//        
		SetTVerts(index,f);
//		TVFace *tf = &mesh->tvFace[index];
//		tf->setTVerts((DWORD)f->a, (DWORD)f->b, (DWORD)f->c);
		}
// fix 990920  --prs.
    int qq = mesh->getNumVerts();
    if (f->a < 0 || f->a >= qq || f->b < 0 || f->b >= qq ||
        f->c < 0 || f->c >= qq) {
        if(showPrompts)
            MessageBox(IDS_PRS_VERT_OR,IDS_DB_3DSIMP);
        return 0;
	    }
//
	fp->setVerts((int)f->a,(int)f->b,(int)f->c);
	fp->setEdgeVisFlags(f->flags & ABLINE,f->flags & BCLINE,f->flags & CALINE);
	fp->setSmGroup(f->sm_group);
	return 1;
	}


int ObjWorker::PutFaceMtl(int index, int imtl) {
	if (index<mesh->numFaces) {
		mesh->faces[index].setMatID(imtl);
		return 1;
		}
	else 
		return 0;
	}

int
ObjWorker::PutSmooth(int index,unsigned long smooth) {
	Face *fp = &mesh->faces[index];
	if(!gotfaces) {
		if(showPrompts)
			MessageBox(IDS_DB_SMOOTH_NO_FACES,IDS_DB_3DSIMP);
		return 0;
		}
	if(index<0 || index>=faces)	{
		if(showPrompts)
			MessageBox(IDS_DB_SMFACE_OR,IDS_DB_3DSIMP);
		return 0;
		}
	fp->setSmGroup(smooth);
	return 1;
	}

void
ObjWorker::Abandon() {
	okay = 0;
	switch(mode) {
		case WORKER_MESH:
			delete object;
			break;
		case WORKER_KF:
			break;
		case WORKER_SHAPE:
			delete splShape;
			break;
		}
	Reset();
	}

void
ObjWorker::FreeObjList() {
	WkObjList *ptr = objects;
	while(ptr) {
		WkObjList *next = (WkObjList *)ptr->next;
		free(ptr);
		ptr = next;
		}
	objects = NULL;
	}

void
ObjWorker::FreeNodeList() {
	WkNodeList *ptr = nodes;
	while(ptr) {
		WkNodeList *next = (WkNodeList *)ptr->next;
		FreeKeyList(&ptr->posList);
		FreeKeyList(&ptr->rotList);
		FreeKeyList(&ptr->scList);
		FreeKeyList(&ptr->colList);
		FreeKeyList(&ptr->hotList);
		FreeKeyList(&ptr->fallList);
		FreeKeyList(&ptr->fovList);
		FreeKeyList(&ptr->rollList);
		free(ptr);
		ptr = next;
		}
	}

int
ObjWorker::AddObject(Object *obj, int type, const TCHAR *name, Matrix3 *tm, int mtlNum) {
	WkObjList *ptr = new WkObjList;
	if(!ptr)
		return 0;
	ptr->object = obj;
	ptr->name = name;
	ptr->type = type;
	ptr->used = 0;
	ptr->cstShad = cstShad;
	ptr->rcvShad = rcvShad;
	ptr->next = objects;
	ptr->mtln = mtlNum;
	if (tm) ptr->tm = *tm;
	else ptr->tm.IdentityMatrix();
	objects = ptr;
	return 1;
	}

int
ObjWorker::AddNode(ImpNode *node,const TCHAR *name,int type,Mesh *msh,char *owner, int mtlNum) {
//DebugPrint("Adding node %s, type %d, mesh:%p\n",name,type,msh);
	WkNodeList *ptr = new WkNodeList;
	if(!ptr)
		return 0;
	ptr->node = node;
	ptr->id = -1;
	ptr->type = type;
	ptr->name = name;
	ptr->mesh = msh;
	ptr->mnum = mtlNum;
	ptr->next = nodes;
	ptr->parent = NULL;
	ptr->posList = ptr->rotList = ptr->scList = ptr->colList = ptr->hotList = ptr->fallList = ptr->fovList = ptr->rollList = NULL;
	if(type==OBJ_TARGET)
		ptr->owner = TSTR(owner);
	workNode = nodes = ptr;
	thisNode = node;
	return 1;
	}

/*TriObject*/ void *
ObjWorker::FindObject(char *name, int &type, int &cstShad, int &rcvShad, int &mtlNum) {
	TSTR wname(name);
	WkObjList *ptr = objects;
	while(ptr) {
		if(_tcscmp(ptr->name,wname)==0) {
			type = ptr->type;
			cstShad = ptr->cstShad;
			rcvShad = ptr->rcvShad;
			mtlNum = ptr->mtln;
			return ptr->object;
			}
		ptr = (WkObjList *)ptr->next;
		}
	return NULL;
	}

int
ObjWorker::UseObject(char *name) {
	TSTR wname(name);
	WkObjList *ptr = objects;
	while(ptr) {
		if(_tcscmp(ptr->name,wname)==0) {
			ptr->used = 1;
			return 1;
			}
		ptr = (WkObjList *)ptr->next;
		}
	return 0;
	}

void ObjWorker::MakeControlsTCB(Control *tmCont,SHORT *tflags)
	{
	Control *c;
	DWORD flags=INHERIT_ALL;

	// Setup inheritance flags.
	if (tflags[POS_TRACK_INDEX] & NO_LNK_X) flags &= ~INHERIT_POS_X;
	if (tflags[POS_TRACK_INDEX] & NO_LNK_Y) flags &= ~INHERIT_POS_Y;
	if (tflags[POS_TRACK_INDEX] & NO_LNK_Z) flags &= ~INHERIT_POS_Z;

	if (tflags[ROT_TRACK_INDEX] & NO_LNK_X) flags &= ~INHERIT_ROT_X;
	if (tflags[ROT_TRACK_INDEX] & NO_LNK_Y) flags &= ~INHERIT_ROT_Y;
	if (tflags[ROT_TRACK_INDEX] & NO_LNK_Z) flags &= ~INHERIT_ROT_Z;

	if (tflags[SCL_TRACK_INDEX] & NO_LNK_X) flags &= ~INHERIT_SCL_X;
	if (tflags[SCL_TRACK_INDEX] & NO_LNK_Y) flags &= ~INHERIT_SCL_Y;
	if (tflags[SCL_TRACK_INDEX] & NO_LNK_Z) flags &= ~INHERIT_SCL_Z;

	tmCont->SetInheritanceFlags(flags,FALSE);

	c = tmCont->GetPositionController();
	if (c && c->ClassID()!=Class_ID(TCBINTERP_POSITION_CLASS_ID,0)) {
		Control *tcb = (Control*)ip->CreateInstance(
			CTRL_POSITION_CLASS_ID,
			Class_ID(TCBINTERP_POSITION_CLASS_ID,0));
		if (!tmCont->SetPositionController(tcb)) {
			tcb->DeleteThis();
			}
		}

	c = tmCont->GetRotationController();
	if (c && c->ClassID()!=Class_ID(TCBINTERP_ROTATION_CLASS_ID,0)) {
		Control *tcb = (Control*)ip->CreateInstance(
			CTRL_ROTATION_CLASS_ID,
			Class_ID(TCBINTERP_ROTATION_CLASS_ID,0));
		if (!tmCont->SetRotationController(tcb)) {
			tcb->DeleteThis();
			}
		}

	c = tmCont->GetRollController();
	if (c && c->ClassID()!=Class_ID(TCBINTERP_FLOAT_CLASS_ID,0)) {
		Control *tcb = (Control*)ip->CreateInstance(
			CTRL_FLOAT_CLASS_ID,
			Class_ID(TCBINTERP_FLOAT_CLASS_ID,0));
		if (!tmCont->SetRollController(tcb)) {
			tcb->DeleteThis();
			}
		}

	c = tmCont->GetScaleController();
	if (c && c->ClassID()!=Class_ID(TCBINTERP_SCALE_CLASS_ID,0)) {
		Control *tcb = (Control*)ip->CreateInstance(
			CTRL_SCALE_CLASS_ID,
			Class_ID(TCBINTERP_SCALE_CLASS_ID,0));
		if (!tmCont->SetScaleController(tcb)) {
			tcb->DeleteThis();
			}
		}
	}


// Note about aspect ratios for rectangular spotlights:
// MAX handles these differently than 3DS.
// Fs = FOV/2 for 3DS
// Fm = FOV/2 for MAX
// As = aspect ratio for 3DS
// Am = aspect ratio for MAX
//
// For 3DS:
//
// w = tan(Fs)
// h = tan(Fs) * As
//
// For MAX:
//
// w = tan(Fm) * sqrt(Am)
// h = tan(Fm) / sqrt(Am)
//
// so solving for stuff gives:
//
// Am = 1 / As
// Fm = atan( tan(Fs) / sqrt(Am) )
//
// Note that FOV is really refering to hotspot or falloff
// So when importing, the hotspot and falloff tracks need
// to be modified by the above formulas.
//
// If the 'aspect' parameter to this function is >0 then
// we assume the float track is either a falloff or hotspot
// track and perform the conversion.

void ObjWorker::SetControllerKeys(
		Control *cont,KeyList *keys,int type,float f,float aspect)
	{
	KeyList *ptr = keys;
	int ct=0;
	ITCBFloatKey fkey;
	ITCBPoint3Key pkey;
	ITCBRotKey rkey;
	ITCBScaleKey skey;
	ITCBKey *k;

	// Set up 'k' to point at the right derived class
	switch (type) {
		case KEY_FLOAT: k = &fkey; break;
		case KEY_POS: k = &pkey; break;
		case KEY_ROT: k = &rkey; break;
		case KEY_SCL: k = &skey; break;
		case KEY_COLOR: k = &pkey; break;
		default: return;
		}

	// Count how many keys we got.
	while (ptr) {
		ct++;
		ptr = (KeyList*)ptr->next;
		}

	// Special case where there is only one key at frame 0.
	// Just set the controller's value
	if (ct==1 && keys->key.key.time==0) {
		switch (type) {
			case KEY_FLOAT: {
				float flt;
				if (aspect>0) {
					float tn = (float)tan(DegToRad(keys->key.sc.e[0].p/2.0f));
					flt = (float)RadToDeg(atan(tn/sqrt(aspect)))*2.0f;
				} else {
					flt = keys->key.sc.e[0].p * f;
					}
				cont->SetValue(0,&flt);
				break;
				}

			case KEY_COLOR: {
				Point3 p(
					keys->key.col.c[0],
					keys->key.col.c[1],
					keys->key.col.c[2]);
				cont->SetValue(0,&p);
				break;
				}

			case KEY_POS: {
				Point3 p(
					keys->key.pos.e[0].p,
					keys->key.pos.e[1].p,
					keys->key.pos.e[2].p);
				cont->SetValue(0,&p);
				break;
				}
			case KEY_ROT: {
				Point3 axis(
					keys->key.rot.axis[0],
					keys->key.rot.axis[1],
					keys->key.rot.axis[2]);
				Quat q = QFromAngAxis(keys->key.rot.angle, axis);
				cont->SetValue(0,&q);
				break;
				}
			case KEY_SCL: {
				ScaleValue s(
					Point3(
					keys->key.pos.e[0].p,
					keys->key.pos.e[1].p,
					keys->key.pos.e[2].p));
				cont->SetValue(0,&s);
				break;
				}
			}
		return;
		}

	// Make sure we can get the interface and have some keys
	IKeyControl *ikeys = GetKeyControlInterface(cont);
	if (!ct || !ikeys) return;
	
	// Allocate the keys in the table
	ikeys->SetNumKeys(ct);

	ptr = keys;
	ct  = 0;
	while (ptr) {
		// Set the common values
		k->time    = ptr->key.key.time * GetTicksPerFrame();
		k->tens    = ptr->key.key.tens;
		k->cont    = ptr->key.key.cont;
		k->bias    = ptr->key.key.bias;
		k->easeIn  = ptr->key.key.easeTo;
		k->easeOut = ptr->key.key.easeFrom;
		
		// Set the key type specific values
		switch (type) {
			case KEY_FLOAT:
				if (aspect>0) {
					float tn = (float)tan(DegToRad(ptr->key.sc.e[0].p/2.0f));
					fkey.val = (float)RadToDeg(atan(tn/sqrt(aspect)))*2.0f;
				} else {
					fkey.val = ptr->key.sc.e[0].p * f;
					}
				break;

			case KEY_POS:	
				pkey.val[0] = ptr->key.pos.e[0].p; 
				pkey.val[1] = ptr->key.pos.e[1].p; 
				pkey.val[2] = ptr->key.pos.e[2].p; 
				break;

			case KEY_ROT:	
				rkey.val.angle   = ptr->key.rot.angle; 
				rkey.val.axis[0] = ptr->key.rot.axis[0];
				rkey.val.axis[1] = ptr->key.rot.axis[1];
				rkey.val.axis[2] = ptr->key.rot.axis[2];
				break;

			case KEY_SCL:	
				skey.val.s[0] = ptr->key.pos.e[0].p; 
				skey.val.s[1] = ptr->key.pos.e[1].p; 
				skey.val.s[2] = ptr->key.pos.e[2].p;
				break;

			case KEY_COLOR:	
				pkey.val[0] = ptr->key.col.c[0]; 
				pkey.val[1] = ptr->key.col.c[1]; 
				pkey.val[2] = ptr->key.col.c[2]; 
				break;
			}
		
		// Set the key in the table
		ikeys->SetKey(ct++,k);		
		ptr = (KeyList*)ptr->next;
		}
	
	// This will ensure that the keys are sorted by time at the
	// track is invalidated so the tangents will be recomputed.
	ikeys->SortKeys();
	}



// 3DS R4 IK joint data
typedef struct {
	int		freeJoints[6];
	float	jointMins[6];
	float	jointMaxs[6];
	float	precedence[6];
	float	damping[6];
	int		limited[6];
	int		ease[6];
	int		lastModified;
} JointData3DSR4;

void ObjWorker::ParseIKData(INode *node)
	{
	AppDataChunk *ad = 
		node->GetAppDataChunk(node->ClassID(),node->SuperClassID(),0);
    if (!ad) return;
	
	// Get the IK data chunk
	Chunk_hdr *hdr = (Chunk_hdr*)
		GetAppDataChunk(ad->data,ad->length,"IK KXPv1 62094j39dlj3i3h42");
	if (!hdr) return;

	// Get the joint data sub chunk
	Chunk_hdr *nhdr = hdr+1;
	DWORD len = hdr->size - nhdr->size - 6;
	void *ikdata = (void*)(((char*)nhdr)+nhdr->size);
	hdr = (Chunk_hdr*)GetAppDataChunk(ikdata,len,"JOINTDATA");
	if (!hdr) return;

	// The first 4 bytes is the version number
	nhdr = hdr+1;
	int *version = (int*)(((char*)nhdr)+nhdr->size);
	if (*version!=3) return; // gotta be version 3

	// Then the joint data
	JointData3DSR4 *jd = (JointData3DSR4*)(version+1);
	
	// Copy it into our data structures
	InitJointData posData, rotData;
	for (int i=0; i<3; i++) {
		posData.active[i]  = jd->freeJoints[i+3];
		posData.limit[i]   = jd->limited[i+3];
		posData.ease[i]    = jd->ease[i+3];
		posData.min[i]     = jd->jointMins[i+3];
		posData.max[i]     = jd->jointMaxs[i+3];
		posData.damping[i] = jd->damping[i+3];

		rotData.active[i]  = jd->freeJoints[i];
		rotData.limit[i]   = jd->limited[i];
		rotData.ease[i]    = jd->ease[i];
		rotData.min[i]     = jd->jointMins[i];
		rotData.max[i]     = jd->jointMaxs[i];
		rotData.damping[i] = jd->damping[i];
		}

	// Give the data to the TM controller
	node->GetTMController()->InitIKJoints(&posData,&rotData);
	}
	
int
ObjWorker::CompleteScene() {
	FinishUp();
	// If we need to expand time, ask the user!
	if(lengthSet) {
		Interval cur = i->GetAnimRange();
		Interval nrange = Interval(0,length * TIME_CONSTANT);
		if (!(cur==nrange)) {
			if (replaceScene||(!showPrompts)||MessageBox2(IDS_MATCHANIMLENGTH, IDS_3DSIMP, MB_YESNO)==IDYES) {
				i->SetAnimRange(nrange);
				}
			SetCursor(LoadCursor(NULL, IDC_WAIT));
			}
		
		/*		
		if((length * TIME_CONSTANT) > cur.End()) {
			if(MessageBox( IDS_TH_EXPANDANIMLENGTH, IDS_RB_3DSIMP, MB_YESNO) == IDYES) {
				cur.SetEnd(length * TIME_CONSTANT);
				i->SetAnimRange(cur);
				}
			}
		*/
		}
	WkNodeList *nptr = nodes;
	while(nptr) {
		if(nptr->type==OBJ_TARGET && nptr->node) {
			WkNodeList *nptr2 = nodes;
			while(nptr2) {
				if((nptr2->type==OBJ_CAMERA || nptr2->type==OBJ_SPOTLIGHT) && nptr->owner==nptr2->name && nptr2->node) {
					i->BindToTarget(nptr2->node,nptr->node);
					goto next_target;			
					}
				nptr2 = (WkNodeList *)nptr2->next;
				}
			}
		next_target:
		nptr = (WkNodeList *)nptr->next;
		}
	nptr = nodes;
	while(nptr) {
		Control *control;
		if(nptr->node) {
			ImpNode *theNode = nptr->node;
			INode *theINode = theNode->GetINode();
			switch(nptr->type) {
				case OBJ_MESH:
					// Do materials
					AssignMtl(theINode, nptr->mesh);

				case OBJ_DUMMY:
					// Unload all key info into the Jaguar node
					control = theINode->GetTMController();
					MakeControlsTCB(control,nptr->trackFlags);
					if(control) {
						SuspendAnimate();
						AnimateOn();
						if(nptr->posList) {
							Control *posControl = control->GetPositionController();
							if(posControl) {								
								SetControllerKeys(
									posControl,
									nptr->posList,
									KEY_POS);
								/*
								KeyList *k = nptr->posList;
								while(k) {
									PosKey *p = &k->key.pos;
									Point3 trans(p->e[0].p,p->e[1].p,p->e[2].p);
									posControl->SetValue(p->time * GetTicksPerFrame(), &trans);							
									k = (KeyList *)(k->next);
									}
								*/
								}
							}
						if(nptr->rotList) {
							Control *rotControl = control->GetRotationController();
							if(rotControl) {
								SetControllerKeys(
									rotControl,
									nptr->rotList,
									KEY_ROT);
								/*
								KeyList *k = nptr->rotList;
								BOOL firstkey = TRUE;
								Quat accum;
								while(k) {
//									RotKey *r = &k->key.rot;
//									Point3 axis = Point3(r->axis[0], r->axis[1], r->axis[2]);
//									float angle = r->angle;
//									Quat q = QFromAngAxis(angle, axis);
//									AngAxis aa(axis, angle);
//									if(firstkey) {
//										rotControl->SetValue(r->time * TIME_CONSTANT, &q);
//										firstkey = FALSE;
//										}
//									else
//										rotControl->SetValue(r->time * TIME_CONSTANT, &aa, 1, CTRL_RELATIVE);
//									k = (KeyList *)(k->next);
									RotKey *r = &k->key.rot;
									Point3 axis = Point3(r->axis[0], r->axis[1], r->axis[2]);
									float angle = r->angle;
									Quat q = QFromAngAxis(angle, axis);
									if(firstkey)
										accum = q;
									else
										accum *= q;
									rotControl->SetValue(r->time * TIME_CONSTANT, &accum);
									firstkey = FALSE;
									k = (KeyList *)(k->next);
									}
								*/
								}
							}
						if(nptr->scList) {
							Control *scControl = control->GetScaleController();
							if(scControl) {
								SetControllerKeys(
									scControl,
									nptr->scList,
									KEY_SCL);
								/*
								KeyList *k = nptr->scList;
								while(k) {
									PosKey *s = &k->key.pos;
									Point3 scale(s->e[0].p,s->e[1].p,s->e[2].p);
									scControl->SetValue(s->time * TIME_CONSTANT, &scale);							
									k = (KeyList *)(k->next);
									}
								*/
								}
							}
						ResumeAnimate();
						}
					break;
				case OBJ_OMNILIGHT: {
					GenLight *lt = (GenLight *)FindObjFromNode(theNode);
					if(!lt) {
						assert(0);
						break;
						}
					// Unload all key info into the Jaguar node
					SuspendAnimate();
					AnimateOn();
					control = theINode->GetTMController();
					MakeControlsTCB(control,nptr->trackFlags);
					if(control) {
						if(nptr->posList) {
							Control *posControl = control->GetPositionController();
							if(posControl) {
								SetControllerKeys(
									posControl,
									nptr->posList,
									KEY_POS);
								/*
								KeyList *k = nptr->posList;
								while(k) {
									PosKey *p = &k->key.pos;
									Point3 trans(p->e[0].p,p->e[1].p,p->e[2].p);
									posControl->SetValue(p->time * TIME_CONSTANT, &trans);							
									k = (KeyList *)(k->next);
									}
								*/
								}
							}
						}
					if(nptr->colList) {
						Control *cont = (Control*)ip->CreateInstance(
							CTRL_POINT3_CLASS_ID,
							Class_ID(TCBINTERP_POINT3_CLASS_ID,0));
						lt->SetColorControl(cont);
						SetControllerKeys(
							cont,
							nptr->colList,
							KEY_COLOR);
						/*
						KeyList *k = nptr->colList;
						while(k) {
							ColorKey *c = &k->key.col;
							lt->SetRGBColor(c->time * TIME_CONSTANT,Point3(c->c[0],c->c[1],c->c[2]));
							k = (KeyList *)(k->next);
							}
						*/
						}
					lt->Enable(TRUE);
					ResumeAnimate();
					}
					break;
				case OBJ_SPOTLIGHT: {
					GenLight *lt = (GenLight *)FindObjFromNode(theNode);
					float aspect = lt->GetAspect(0);
					if(!lt) {
						assert(0);
						break;
						}
					// Unload all key info into the Jaguar node
					SuspendAnimate();
					AnimateOn();
					control = theINode->GetTMController();
					MakeControlsTCB(control,nptr->trackFlags);
					if(control) {
						if(nptr->posList) {
							Control *posControl = control->GetPositionController();
							if(posControl) {
								SetControllerKeys(
									posControl,
									nptr->posList,
									KEY_POS);
								/*
								KeyList *k = nptr->posList;
								while(k) {
									PosKey *p = &k->key.pos;
									Point3 trans(p->e[0].p,p->e[1].p,p->e[2].p);
									posControl->SetValue(p->time * TIME_CONSTANT, &trans);							
									k = (KeyList *)(k->next);
									}
								*/
								}
							}
						}
					if(nptr->colList) {
						Control *cont = (Control*)ip->CreateInstance(
							CTRL_POINT3_CLASS_ID,
							Class_ID(TCBINTERP_POINT3_CLASS_ID,0));
						lt->SetColorControl(cont);
						SetControllerKeys(
							cont,
							nptr->colList,
							KEY_COLOR);
						/*
						KeyList *k = nptr->colList;
						while(k) {
							ColorKey *c = &k->key.col;
							lt->SetRGBColor(c->time * TIME_CONSTANT,Point3(c->c[0],c->c[1],c->c[2]));
							k = (KeyList *)(k->next);
							}
						*/
						}
					if(nptr->hotList) {
						Control *cont = (Control*)ip->CreateInstance(
							CTRL_FLOAT_CLASS_ID,
							Class_ID(TCBINTERP_FLOAT_CLASS_ID,0));
						lt->SetHotSpotControl(cont);
						SetControllerKeys(
							cont,
							nptr->hotList,
							KEY_FLOAT,1.0f,aspect);
						/*
						KeyList *k = nptr->hotList;
						while(k) {
							ScalarKey *h = &k->key.sc;
							lt->SetHotspot(h->time * TIME_CONSTANT, h->e[0].p);
							k = (KeyList *)(k->next);
							}
						*/
						}
					if(nptr->fallList) {
						Control *cont = (Control*)ip->CreateInstance(
							CTRL_FLOAT_CLASS_ID,
							Class_ID(TCBINTERP_FLOAT_CLASS_ID,0));
						lt->SetFalloffControl(cont);
						SetControllerKeys(
							cont,
							nptr->fallList,
							KEY_FLOAT,1.0f,aspect);
						/*
						KeyList *k = nptr->fallList;
						while(k) {
							ScalarKey *f = &k->key.sc;
							lt->SetFallsize(f->time * TIME_CONSTANT, f->e[0].p);
							k = (KeyList *)(k->next);
							}
						*/
						}
					control = theINode->GetTMController();
					if(control) {
						if(nptr->rollList) {
							Control *rollControl = control->GetRollController();
							if(rollControl) {
								SetControllerKeys(
									rollControl,
									nptr->rollList,
									KEY_FLOAT,-DEG_TO_RAD);
								/*
								KeyList *k = nptr->rollList;
								while(k) {
									ScalarKey *r = &k->key.sc;
									float roll = r->e[0].p * DEG_TO_RAD;
									rollControl->SetValue(r->time * TIME_CONSTANT, &roll);							
									k = (KeyList *)(k->next);
									}
								*/
								}
							}
						}
					lt->Enable(TRUE);
					ResumeAnimate();
					}
					break;
				case OBJ_CAMERA: {
					GenCamera *cam = (GenCamera *)FindObjFromNode(theNode);
					if(!cam) {
						assert(0);
						break;
						}
					// Unload all key info into the Jaguar node
					SuspendAnimate();
					AnimateOn();
					control = theINode->GetTMController();
					MakeControlsTCB(control,nptr->trackFlags);
					if(control) {
						if(nptr->posList) {
							Control *posControl = control->GetPositionController();
							if(posControl) {
								SetControllerKeys(
									posControl,
									nptr->posList,
									KEY_POS);
								/*
								KeyList *k = nptr->posList;
								while(k) {
									PosKey *p = &k->key.pos;
									Point3 trans(p->e[0].p,p->e[1].p,p->e[2].p);
									posControl->SetValue(p->time * TIME_CONSTANT, &trans);							
									k = (KeyList *)(k->next);
									}
								*/
								}
							}
						}
					if(nptr->fovList) {
						Control *cont = (Control*)ip->CreateInstance(
							CTRL_FLOAT_CLASS_ID,
							Class_ID(TCBINTERP_FLOAT_CLASS_ID,0));
						cam->SetFOVControl(cont);
						SetControllerKeys(
							cont,
							nptr->fovList,
							KEY_FLOAT,DEG_TO_RAD);
						/*
						KeyList *k = nptr->fovList;
						while(k) {
							ScalarKey *f = &k->key.sc;
							cam->SetFOV(f->time * TIME_CONSTANT, f->e[0].p * DEG_TO_RAD);
							k = (KeyList *)(k->next);
							}
						*/
						}
					control = theINode->GetTMController();
					if(control) {
						if(nptr->rollList) {
							Control *rollControl = control->GetRollController();
							if(rollControl) {
								SetControllerKeys(
									rollControl,
									nptr->rollList,
									KEY_FLOAT,-DEG_TO_RAD);
								/*
								KeyList *k = nptr->rollList;
								while(k) {
									ScalarKey *r = &k->key.sc;
									float roll = r->e[0].p * DEG_TO_RAD;
									rollControl->SetValue(r->time * TIME_CONSTANT, &roll);							
									k = (KeyList *)(k->next);
									}
								*/
								}
							}
						}
					cam->Enable(TRUE);
					ResumeAnimate();
					}
					break;
				case OBJ_OTHER:
					theINode->SetMtl(GetMaxMtl(nptr->mnum));
					
				case OBJ_TARGET:

					// Unload all key info into the Jaguar node
					control = theINode->GetTMController();
					MakeControlsTCB(control,nptr->trackFlags);
					if(control) {
						SuspendAnimate();
						AnimateOn();
						if(nptr->posList) {
							Control *posControl = control->GetPositionController();
							if(posControl) {
								SetControllerKeys(
									posControl,
									nptr->posList,
									KEY_POS);
								/*
								KeyList *k = nptr->posList;
								while(k) {
									PosKey *p = &k->key.pos;
									Point3 trans(p->e[0].p,p->e[1].p,p->e[2].p);
									posControl->SetValue(k->key.key.time * TIME_CONSTANT, &trans);							
									k = (KeyList *)(k->next);
									}
								*/
								}
							}
						ResumeAnimate();
						}
					break;
				default:
					assert(0);
					break;
				}

			ParseIKData(theINode);
			}
		nptr = (WkNodeList *)nptr->next;
		}
	WkObjList *ptr = objects;
	while(ptr) {
		if(dStream) {
			fprintf(dStream,"Found object %s, used:%d\n",CStr(ptr->name),ptr->used);
			fflush(dStream);
			}
		if(!ptr->used) {
			ImpNode *node1, *node2;
			node1 = MakeANode(ptr->name, FALSE, "");

			// DS: 4/30/97
			// This fixes import of files created in 3DS-DOS with the
			// Save Selected command, which don't have keyframe data.
			if (!gotM3DMAGIC) 
				node1->SetTransform(0,ptr->tm);

			if (ptr->type==OBJ_MESH) {
				INode *inode = node1->GetINode();
				Mesh *mesh = &(((TriObject *)inode->GetObjectRef())->GetMesh());
				AssignMtl(inode, mesh);
				}

			if (ptr->type==OBJ_SPOTLIGHT || ptr->type==OBJ_CAMERA) {
				Matrix3 tm(1);
				
				if (ptr->type==OBJ_SPOTLIGHT) {
					GenLight *lt = 
						(GenLight *)FindObjFromNode(node1);
					lt->Enable(TRUE);
				} else {
					GenCamera *cam = 
						(GenCamera *)FindObjFromNode(node1);
					cam->Enable(TRUE);
					}

				// Create a target
				TSTR name = ptr->name + TSTR(_T(".Target"));
				node2 = MakeANode(name, TRUE, "");								
				tm.SetTrans(ptr->targPos);
				node2->SetTransform(0,tm);
				i->BindToTarget(node1,node2);

				// Set the position of the light or camera.
				tm.SetTrans(ptr->srcPos);
				node1->SetTransform(0,tm);
				}
			if (ptr->type==OBJ_OMNILIGHT) {
				GenLight *lt = 
					(GenLight *)FindObjFromNode(node1);
				lt->Enable(TRUE);
				}
			}

		ptr = (WkObjList *)ptr->next;
		}
	return 1;
	}

ImpNode *
ObjWorker::FindNode(char *name) {
	TSTR wname(name);
	WkNodeList *ptr = nodes;
	while(ptr) {
		if(_tcscmp(ptr->name,wname)==0)
			return ptr->node;
		ptr = (WkNodeList *)ptr->next;
		}
	return NULL;
	}

TCHAR *
ObjWorker::NodeName(ImpNode *node) {
	WkNodeList *ptr = nodes;
	while(ptr) {
		if(node == ptr->node)
			return ptr->name;
		ptr = (WkNodeList *)ptr->next;
		}
	return NULL;
	}

int
ObjWorker::SetNodesParent(ImpNode *node,ImpNode *parent) {
	WkNodeList *ptr = nodes;
	while(ptr) {
		if(node == ptr->node) {
			ptr->parent = parent;
			return 1;
			}
		ptr = (WkNodeList *)ptr->next;
		}
	return 0;
	}

ImpNode *
ObjWorker::FindNodeFromId(short id) {
	WkNodeList *ptr = nodes;
	while(ptr) {
		if(ptr->id == id)
			return ptr->node;
		ptr = (WkNodeList *)ptr->next;
		}
	return NULL;
	}

WkNodeList *
ObjWorker::FindEntry(char *name) {
	TSTR wname(name);
	WkNodeList *ptr = nodes;
	while(ptr) {
		if(_tcscmp(ptr->name,wname)==0)
			return ptr;
		ptr = (WkNodeList *)ptr->next;
		}
	return NULL;
	}

WkNodeList *
ObjWorker::FindEntryFromId(short id) {
	WkNodeList *ptr = nodes;
	while(ptr) {
		if(ptr->id == id)
			return ptr;
		ptr = (WkNodeList *)ptr->next;
		}
	return NULL;
	}

WkNodeList *
ObjWorker::FindNodeListEntry(ImpNode *node) {
	WkNodeList *ptr = nodes;
	while(ptr) {
		if(ptr->node == node)
			return ptr;
		ptr = (WkNodeList *)ptr->next;
		}
	return NULL;
	}

WkObjList *	
ObjWorker::FindObjListEntry(TSTR &name) {
	WkObjList *ptr = objects;
	while(ptr) {
		if(ptr->name == name)
			return ptr;
		ptr = (WkObjList *)ptr->next;
		}
	return NULL;
	}

int
ObjWorker::FindTypeFromNode(ImpNode *node, Mesh **mesh) {
	WkNodeList *ptr = nodes;
	while(ptr) {
		if(ptr->node == node) {
			*mesh =  ptr->mesh;
			return ptr->type;
			}
		ptr = (WkNodeList *)ptr->next;
		}
	return -1;
	}

void *
ObjWorker::FindObjFromNode(ImpNode *node) {
	WkNodeList *ptr = nodes;
	while(ptr) {
		if(ptr->node == node) {
			WkObjList *optr = objects;
			while(optr) {
				if(optr->name == ptr->name)
					return optr->object;
				optr = (WkObjList *)optr->next;
				}
			assert(0);
			return NULL;
			}
		ptr = (WkNodeList *)ptr->next;
		}
	return NULL;
	}

int
ObjWorker::SetNodeId(ImpNode *node,short id) {
	WkNodeList *ptr = nodes;
	while(ptr) {
		if(ptr->node == node) {
			ptr->id = id;
			if(dStream) {
				fprintf(dStream,"Setting node ID to %d\n",id);
				fflush(dStream);
				}
			return 1;
			}
		ptr = (WkNodeList *)ptr->next;
		}
	this->id = id;
	return 0;	
	}

int
ObjWorker::AddKey(KeyList **list,Key *key) {
	if(mode != WORKER_KF) {
//		MessageBox(NULL,_T("Key add: Not in KF Worker mode"),_T("3DSIMP"),MB_OK);
		return 1;	// Keep it from bailing out -- Will need to return 0 eventually
		}
	KeyList *ptr = new KeyList;
	if(!ptr)
		return 0;
	KeyList *work = *list,*last = NULL;
	while(work) {
		last = work;
		work = (KeyList *)work->next;
		}
	if(last)
		last->next = ptr;
	else
		*list = ptr;
	ptr->key.key = *key;
	ptr->next = NULL;
	return 1;
	}

void
ObjWorker::FreeKeyList(KeyList **list) {
	KeyList *ptr = *list;
	while(ptr) {
		KeyList *next = (KeyList *)ptr->next;
		free(ptr);
		ptr = next;
		}
	*list = NULL;
	}

int
ObjWorker::SetTransform(ImpNode *node,Matrix3& m) {
	WkNodeList *ptr = nodes;
	while(ptr) {
		if(ptr->node == node) {
			ptr->tm = m;
			return 1;
			}
		ptr = (WkNodeList *)ptr->next;
		}
	return 0;
	}

Matrix3
ObjWorker::GetTransform(ImpNode *node) {
	WkNodeList *ptr = nodes;
	while(ptr) {
		if(ptr->node == node)
			return ptr->tm;
		ptr = (WkNodeList *)ptr->next;
		}
	Matrix3 dummy;
	dummy.IdentityMatrix();
	return dummy;
	}

// Pointer to the ObjWorker object

ObjWorker *theWorker;

// Jaguar interface code

int controlsInit = FALSE;

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();
		}
	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			//MessageBox(NULL,_T("3DSIMP.DLL: DllMain"),_T("3DSIMP"),MB_OK);
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------

class StudioClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new StudioImport; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_3DSTUDIO); }
	SClass_ID		SuperClassID() { return SCENE_IMPORT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(2,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SCENEIMPORT);  }
	};

static StudioClassDesc StudioDesc;

class StudioShapeClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new StudioShapeImport; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_3DSTUDIOSHAPE); }
	SClass_ID		SuperClassID() { return SCENE_IMPORT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(2,1); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SCENEIMPORT); }
	};

static StudioShapeClassDesc StudioShapeDesc;

// Statics

int	StudioShapeImport::importType = SINGLE_SHAPE;

//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_TH_3DSIMPORTDLL); }

__declspec( dllexport ) int
LibNumberClasses() { return 2; }

__declspec( dllexport ) ClassDesc *
LibClassDesc(int i) {
	switch(i) {
		case 0: return &StudioDesc; break;
		case 1: return &StudioShapeDesc; break;
		default: return 0; break;
		}

	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

//
// .3DS import module functions follow:
//

StudioImport::StudioImport() {
	}

StudioImport::~StudioImport() {
	}

int
StudioImport::ExtCount() {
	return 2;
	}

const TCHAR *
StudioImport::Ext(int n) {		// Extensions supported for import/export modules
	switch(n) {
		case 0:
			return _T("3DS");
		case 1:
			return _T("PRJ");
		}
	return _T("");
	}

const TCHAR *
StudioImport::LongDesc() {			// Long ASCII description (i.e. "Targa 2.0 Image File")
	return GetString(IDS_TH_3DSSCENEFILE);
	}
	
const TCHAR *
StudioImport::ShortDesc() {			// Short ASCII description (i.e. "Targa")
	return GetString(IDS_TH_3DSMESH);
	}

const TCHAR *
StudioImport::AuthorName() {			// ASCII Author name
	return GetString(IDS_TH_TOM_HUDSON);
	}

const TCHAR *
StudioImport::CopyrightMessage() {	// ASCII Copyright message
	return GetString(IDS_TH_COPYRIGHT_YOST_GROUP);
	}

const TCHAR *
StudioImport::OtherMessage1() {		// Other message #1
	return _T("");
	}

const TCHAR *
StudioImport::OtherMessage2() {		// Other message #2
	return _T("");
	}

unsigned int
StudioImport::Version() {				// Version number * 100 (i.e. v3.01 = 301)
	return 100;
	}

void
StudioImport::ShowAbout(HWND hWnd) {			// Optional
 	}
//
// .SHP import module functions follow:
//

StudioShapeImport::StudioShapeImport() {
	shapeNumber = 1;		// For name index
 	}

StudioShapeImport::~StudioShapeImport() {
	}

int
StudioShapeImport::ExtCount() {
	return 1;
	}

const TCHAR *
StudioShapeImport::Ext(int n) {		// Extensions supported for import/export modules
	switch(n) {
		case 0:
			return _T("SHP");
		}
	return _T("");
	}

const TCHAR *
StudioShapeImport::LongDesc() {			// Long ASCII description (i.e. "Targa 2.0 Image File")
	return GetString(IDS_TH_3DSSHAPEFILE);
	}
	
const TCHAR *
StudioShapeImport::ShortDesc() {			// Short ASCII description (i.e. "Targa")
	return GetString(IDS_TH_3DSTUDIOSHAPE);
	}

const TCHAR *
StudioShapeImport::AuthorName() {			// ASCII Author name
	return GetString(IDS_TH_TOM_HUDSON);
	}

const TCHAR *
StudioShapeImport::CopyrightMessage() {	// ASCII Copyright message
	return GetString(IDS_TH_COPYRIGHT_YOST_GROUP);
	}

const TCHAR *
StudioShapeImport::OtherMessage1() {		// Other message #1
	return _T("");
	}

const TCHAR *
StudioShapeImport::OtherMessage2() {		// Other message #2
	return _T("");
	}

unsigned int
StudioShapeImport::Version() {				// Version number * 100 (i.e. v3.01 = 301)
	return 100;
	}

void
StudioShapeImport::ShowAbout(HWND hWnd) {			// Optional
 	}

/* Bypass an unknown chunk type */

int
skip_chunk(FILE *stream)
{
Chunk_hdr chunk;

RDERR(&chunk,sizeof(Chunk_hdr));

chunk.size-=6L;
return(1-fseek(stream,chunk.size,SEEK_CUR));
}

/* Skip the next n bytes in the file */

int
SkipRead(FILE *stream,long bytes)
{
return fseek(stream,bytes,SEEK_CUR);
}

/* Get next chunk ID and return it, repositioning file to old pos */

int
get_next_chunk(FILE *stream,Chunk_hdr *hdr)
{
long curpos;

curpos=ftell(stream);
RDERR(hdr,sizeof(Chunk_hdr));
fseek(stream,curpos,SEEK_SET);

#ifdef DUMPING
{
TCHAR buf[256];
_stprintf(buf,_T("Next chunk: %X, size:%d"),hdr->tag,hdr->size);
MessageBox(NULL,buf,_T("3DSIMP"),MB_OK);
}
#endif // DUMPING

return(1);
}

/* Get a null-terminated string from the file */

int
read_string(char *string,FILE *stream,int maxsize)
{
while(maxsize--)
 {
 RDERR(string,1);
 if(*(string++)==0)
  return(1);
 }
return(0);	/* Too long */
}

// The main 3DS reader!
int
get_mchunk(void *data) {
	int ix,skipping;
	float fdum;
	Verts v;
	UVVert tv;
	Faces f;
	Dirlight *d;
	Camera3DS *c;
	Bkgrad *gd;
	Chunk_hdr chunk;
	Chunk_hdr next;
	int obnbr;
	unsigned short wk_count;
	struct fc_wrt
	{
	unsigned short a;
	unsigned short b;
	unsigned short c;
	unsigned short flags;
	} Fc_wrt;

	RDERR(&chunk,6);

	/* Update chunk size to account for header */

	chunk.size-=6L;

	/* Find chunk type and go process it */

	lastchunk=chunk.tag;

#ifdef PRINTCHUNKID
DebugPrint("Chunk:%X\n",chunk.tag);
#endif

#ifdef DUMPING
{
TCHAR buf[256];
_stprintf(buf,_T("Chunk: %X, size:%d"),chunk.tag,chunk.size);
MessageBox(NULL,buf,_T("3DSIMP"),MB_OK);
}
#endif // DUMPING

	/* printf("get_mchunk: chunk.tag:%X\n",lastchunk); */

	switch(chunk.tag)
		{
		case CMAGIC:
			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)
					return(0);
				switch(next.tag)
					{
					case SMAGIC:
//						if(merging) goto skipit;
//						inst_shape(&Infoshp);
//						shapeok=1;
						msc_wk=1.0f;
						if(get_mchunk(NULL)==0)
							return(0);
//						uninst_shape(&Infoshp);
						break;
//					case LMAGIC:
//						if(merging) goto skipit;
//						path_only=0;
//						msc_wk=1.0;
//						if(get_lchunk(stream,NULL)==0)
//							return(0);
//						calc_pathpts();
//						shp_poffsets();
//						break;
//#ifdef LOADING_MLI
//					case MLIBMAGIC:
//						if(merging) goto skipit;
//						new_mlib();
//						just_name=0;
//						if (get_mtlchunk(stream,NULL)==0)
//							return(0);
//						break;
//#endif
					case MMAGIC:
//						hiddens=0;
//						if(!merging)
							msc_wk=1.0f;
//						mesh_version=0;
						if(get_mchunk(NULL)==0)
							return(0);
						break;
					case KFDATA:
//						if(merging==2)
//							goto skipit;
//						if(merging &&(mg_keys==0))
//							goto skipit;
						/*merging = 0;*/
						if(get_mchunk(NULL)==0)
							return(0);
						break;

					default:
//						skipit:
						if(skip_chunk(stream)==0)
							return(0);
						break;
					}
				chunk.size-=next.size;
				}
			break;
		case KFDATA:
			while(chunk.size) {
				if(!get_next_chunk(stream,&next))
					return(0);
				switch(next.tag)   	{
					case OBJECT_NODE_TAG:
					case CAMERA_NODE_TAG: 
					case TARGET_NODE_TAG: 	
					case L_TARGET_NODE_TAG: 	
					case LIGHT_NODE_TAG:
					case SPOTLIGHT_NODE_TAG:
						nodeLoadNumber++;
						if(dStream) {
							fprintf(dStream,"nodeLoadNumber:%d\n",nodeLoadNumber);
							fflush(dStream);
							}

					case KFHDR:
					case KFSEG:
//						nodetag = next.tag;
						if(!get_mchunk(NULL))	return(0);
						break;
					case AMBIENT_NODE_TAG:
					default:
						if(!skip_chunk(stream))	return(0);
						break;
					}
				chunk.size -= next.size;
				}
			break;
		case KFHDR: {	 /* version, mesh name anim length ... */
			char dumstr[10];
			LONG length;
			RDSHORT(&readVers);
			if (!read_string(dumstr,stream,9)) return(0);
			RDLONG(&length); 
			theWorker->SetAnimLength((TimeValue)length);
			chunk.size = 0;
			}
			break;
		case KFSEG: {
			long segStart,segEnd;
			RDLONG(&segStart);
			RDLONG(&segEnd);
			theWorker->SetSegment(Interval((TimeValue)segStart,(TimeValue)segEnd));
			chunk.size = 0;
			}
			break;
		case OBJECT_NODE_TAG:
			theWorker->FinishUp();	// Finish anything that we started earlier 
			skipNode = 0;
			cur_node_id = -32000;	
			while(chunk.size) {
				if(!get_next_chunk(stream,&next)) return(0);
				switch (next.tag) {
					case NODE_ID:
					case NODE_HDR:
					case APP_DATA:
					case BOUNDBOX: 
					case PIVOT:
					case INSTANCE_NAME:
					case POS_TRACK_TAG: 
					case ROT_TRACK_TAG: 
					case SCL_TRACK_TAG:
						if(!get_mchunk(NULL)) return(0);
						break;
//					case MORPH_SMOOTH:
//						if(!get_mchunk(onode)) return(0);
//						break;
#ifdef LATER
					case MORPH_TRACK_TAG:
						if(!get_mchunk(&onode->mtrack)) return(0);
						break;
					case HIDE_TRACK_TAG:
						if(!get_mchunk(&onode->htrack)) return(0);
						break;
#endif
					default:
						if(!skip_chunk(stream))	return(0);
						break;
					}
				chunk.size -= next.size;
				}
			break;
		case CAMERA_NODE_TAG: 
			theWorker->FinishUp();	// Finish anything that we started earlier 
			skipNode = 0;
			cur_node_id = -32000;	
			while(chunk.size) {
				if(!get_next_chunk(stream,&next)) return(0);
				if (skipNode) {
					if(!skip_chunk(stream)) return(0);
					}
				else switch (next.tag) {
					case NODE_HDR:	case NODE_ID:
					case APP_DATA:
					case POS_TRACK_TAG: 
					case ROLL_TRACK_TAG: 
					case FOV_TRACK_TAG: 
						if(!get_mchunk(NULL)) return(0);
						break;
					default:
						if(!skip_chunk(stream))	return(0);
						break;
					}
				chunk.size -= next.size;
				}
			break;
		case L_TARGET_NODE_TAG: 
		case TARGET_NODE_TAG: 
			theWorker->FinishUp();	// Finish anything that we started earlier 
			skipNode = 0;
			cur_node_id = -32000;	
			while(chunk.size) {
				if(!get_next_chunk(stream,&next)) return(0);
				if (skipNode) { 
					if(!skip_chunk(stream)) return(0);
					}
				else switch (next.tag) {
					case NODE_ID: case NODE_HDR:
						if(!get_mchunk(".target")) return(0);
						break;
					case APP_DATA:
					case POS_TRACK_TAG: 
						if(!get_mchunk(NULL)) return(0);
						break;
					default:
						if(!skip_chunk(stream))	return(0);
						break;
					}
				chunk.size -= next.size;
				}
			break;
		case LIGHT_NODE_TAG: 
			theWorker->FinishUp();	// Finish anything that we started earlier 
			skipNode = 0;
			cur_node_id = -32000;	
			while(chunk.size) {
				if(!get_next_chunk(stream,&next)) return(0);
				if (skipNode) {
					if(!skip_chunk(stream)) return(0);
					}
				else switch (next.tag) {
					case NODE_ID: case NODE_HDR:
					case APP_DATA:
					case POS_TRACK_TAG: 
					case COL_TRACK_TAG: 
						if(!get_mchunk(NULL)) return(0);
						break;
					default:
						if(!skip_chunk(stream))	return(0);
						break;
					}
				chunk.size -= next.size;
				}
			break;
		case SPOTLIGHT_NODE_TAG: 
			theWorker->FinishUp();	// Finish anything that we started earlier 
			skipNode = 0;
			cur_node_id = -32000;	
			while(chunk.size) {
				if(!get_next_chunk(stream,&next)) return(0);
				if (skipNode) {if(!skip_chunk(stream)) return(0);}
				else switch (next.tag) {
					case NODE_ID: case NODE_HDR:
					case APP_DATA:
					case POS_TRACK_TAG: 
					case COL_TRACK_TAG: 
					case HOT_TRACK_TAG: 
					case FALL_TRACK_TAG: 
					case ROLL_TRACK_TAG: 
						if(!get_mchunk(NULL)) return(0);
						break;
					default:
						if(!skip_chunk(stream))	return(0);
						break;
					}
				chunk.size -= next.size;
				}
			break;
		case NODE_ID:
//			MessageBox(NULL,_T("Reading node id"),_T("3dsimp"),MB_OK); 
			RDSHORT(&cur_node_id);	
			if(dStream) {
				fprintf(dStream,"Got Node ID:%d\n",cur_node_id);
				fflush(dStream);
				}
			break;
		case NODE_HDR: {
//			MessageBox(NULL,_T("Reading node hdr"),_T("3dsimp"),MB_OK); 
			USHORT npar;
			ImpNode *pnode;
			// If we have a suffix, this is a target object
			char *suffix = (char *)data;
						
			if (!read_string(obname,stream,20)) return(0);
			chunk.size -= (long)(strlen(obname)+1);
			obname[10] = 0;
			char prefix[32];
			if(suffix) {
				strcpy(prefix,obname);				
				strcat(obname,suffix);
				}
			else
				prefix[0] = 0;

//DebugPrint("Got node %s\n",obname);

			TSTR Wname(obname);

			if (strcmp(obname,"$_$_$_$")==0) {
//				MessageBox(NULL,_T("Skipping $_$_$_$ object"),_T("3DSIMP"),MB_OK);
				goto skip_node;
				}

			theWorker->SetDummy(0);

			// Check for dummies -- If it is a dummy, we create a node now because
			// none was created for it in the mesh section
			if (strcmp(obname,"DUMMY")==0||strcmp(obname,"$$$DUMMY")==0) {
				if(!(obnode = theWorker->MakeDummy(_T(""))))
					return 0;
				theWorker->SetDummy(1);
				theWorker->SetNodeName(_T(""));
				}
			else {
				TSTR wname(obname);
				if(!(obnode = theWorker->MakeANode(wname,suffix ? TRUE : FALSE, prefix)))
					return 0;
				theWorker->SetNodeName(wname);
				}

			theWorker->StartKF(obnode);	// Start creating a KF node
							
			if (cur_node_id!=-32000)
				theWorker->SetNodeId(obnode,cur_node_id);
			else 
				theWorker->SetNodeId(obnode,nodeLoadNumber);

			if (!theWorker->IsDummy()) { 
#ifdef LATER
				if (merging) {
					if (!merge_this(objname)) goto skip_node;
					MaybeRemapName(objname);
					}
#endif
				}

			RDSHORT(&nodeflags);	chunk.size -= 2;

			if (readVers<4) nodeflags &= 7;
			/* read second flag word */
			RDSHORT(&nodeflags2);	chunk.size -= 2;
			/* get parent node if any */
			RDSHORT(&npar);	chunk.size -= 2;
			
			pnode = NULL;
			if(npar != NO_PARENT) {
				if(dStream) {
					fprintf(dStream,"Parent's node id:%d\n",npar);
					fflush(dStream);
					}
				WkNodeList *ptr = theWorker->FindEntryFromId(npar);
				if(!ptr) {
					if(showPrompts)
						MessageBox(Wname.data(),IDS_DB_NOT_LINKED);
					}
				else {
					pnode = ptr->node;
					theWorker->SetNodesParent(obnode,pnode);
					}
				}

			theWorker->SetParentNode(pnode);
				
//			InsertNodeById(node, pnode);
			break;
			}

	      skip_node:
			skipped_nodes = 1;
//		  	FreeNode(node);
			if (SkipRead(stream, chunk.size)) return(0);
			chunk.size = 0;
			skipNode = 1;
			break;

		case PIVOT:	{
				float pivot[3];
				RD3FLOAT(pivot);
				if(msc_wk!=1.0)
					{
					pivot[0]*=msc_wk;
					pivot[1]*=msc_wk;
					pivot[2]*=msc_wk;
					}
				theWorker->SetPivot(Point3(pivot[0],pivot[1],pivot[2]));
				chunk.size = 0;
				}
			break;
		case BOUNDBOX:	{
				Point3 min,max;
				RD3FLOAT(&min.x);
				RD3FLOAT(&max.x);
				theWorker->SetDummyBounds(min,max);
				if(dStream) {
					fprintf(dStream,"Got dummy bounds\n");
					fflush(dStream);
					}
				chunk.size = 0;
				}
			break;
		case INSTANCE_NAME:	{
				char iname[20];
				if (!read_string(iname,stream,20)) return(0);
				iname[10] = 0;
				theWorker->SetInstanceName(obnode, TSTR(iname));
				chunk.size = 0;
				}
			break;
		case POS_TRACK_TAG:
		case ROT_TRACK_TAG:
		case SCL_TRACK_TAG:
		case FOV_TRACK_TAG:
		case ROLL_TRACK_TAG:
		case COL_TRACK_TAG:
		case HOT_TRACK_TAG:
		case FALL_TRACK_TAG:
#ifdef LATER
		case MORPH_TRACK_TAG:
		case HIDE_TRACK_TAG:
#endif
			LONG nkeys;
			SHORT rflags;
			Key key;
			short trflags;
			long trtmin,trtmax;
			RDSHORT(&trflags);
			RDLONG(&trtmin);
			RDLONG(&trtmax);
			RDLONG(&nkeys);
//			if (!InitKeyTab(tr)) return(0);
			for (ix=0; ix<nkeys; ix++) {  
				memset(&key,0,sizeof(Key));
				RDLONG(&key.time); 
				RDSHORT(&rflags);
 				if (rflags&W_TENS) RDFLOAT(&key.tens);
 				if (rflags&W_CONT) RDFLOAT(&key.cont);
 				if (rflags&W_BIAS) RDFLOAT(&key.bias);
 				if (rflags&W_EASETO) RDFLOAT(&key.easeTo);
 				if (rflags&W_EASEFROM)RDFLOAT(&key.easeFrom);
				switch (chunk.tag) {
					case POS_TRACK_TAG:	
						{
						PosKey pkey;
						memset(&pkey,0,sizeof(PosKey));
						memcpy(&pkey,&key,sizeof(PosKey));
						RDFLOAT(&pkey.e[0].p);
						RDFLOAT(&pkey.e[1].p);
						RDFLOAT(&pkey.e[2].p);

						/* Tom's scale fix 2/12/92 */
						if(msc_wk!=1.0)
							{
							pkey.e[0].p *= msc_wk;
							pkey.e[1].p *= msc_wk;
							pkey.e[2].p *= msc_wk;
							}
						//theWorker->trackFlags[POS_TRACK_INDEX] = trflags;
						theWorker->workNode->trackFlags[POS_TRACK_INDEX] = trflags;

						if(!theWorker->AddPositionKey(&pkey))
							return 0;
						}
						break;
					case SCL_TRACK_TAG:
						{
						PosKey skey;
						memset(&skey,0,sizeof(PosKey));
						memcpy(&skey,&key,sizeof(PosKey));
						RDFLOAT(&skey.e[0].p);
						RDFLOAT(&skey.e[1].p);
						RDFLOAT(&skey.e[2].p);
						//theWorker->trackFlags[SCL_TRACK_INDEX] = trflags;
						theWorker->workNode->trackFlags[SCL_TRACK_INDEX] = trflags;						

						if(!theWorker->AddScaleKey(&skey))
							return 0;
						}
						break;
					case COL_TRACK_TAG:
						{
						ColorKey ckey;
						memset(&ckey,0,sizeof(ColorKey));
						memcpy(&ckey,&key,sizeof(ColorKey));
						RDFLOAT(&ckey.c[0]);
						RDFLOAT(&ckey.c[1]);
						RDFLOAT(&ckey.c[2]);
						//theWorker->trackFlags[COL_TRACK_INDEX] = trflags;
						theWorker->workNode->trackFlags[COL_TRACK_INDEX] = trflags;						

						if(!theWorker->AddColorKey(&ckey))
							return 0;
						}
						break;
					case ROT_TRACK_TAG: {
						RotKey rkey;
						memset(&rkey,0,sizeof(RotKey));
						memcpy(&rkey,&key,sizeof(RotKey));
						RDFLOAT(&rkey.angle);
						RD3FLOAT(rkey.axis);
						//theWorker->trackFlags[ROT_TRACK_INDEX] = trflags;
						theWorker->workNode->trackFlags[ROT_TRACK_INDEX] = trflags;
						
						if(!theWorker->AddRotationKey(&rkey))
							return 0;
						}
						break;
					case HOT_TRACK_TAG:
						{
						ScalarKey sckey;
						memset(&sckey,0,sizeof(ScalarKey));
						memcpy(&sckey,&key,sizeof(ScalarKey));
						RDFLOAT(&sckey.e[0].p);
#ifdef DBGKFB
						if(dbgio) 
						   printf("  scalar = (%.3f)\n", sckey.e[0].p);
#endif
						//theWorker->trackFlags[HOT_TRACK_INDEX] = trflags;
						theWorker->workNode->trackFlags[HOT_TRACK_INDEX] = trflags;
						
						if(!theWorker->AddHotKey(&sckey))
							return 0;
						}
						break;
					case FALL_TRACK_TAG:
						{
						ScalarKey sckey;
						memset(&sckey,0,sizeof(ScalarKey));
						memcpy(&sckey,&key,sizeof(ScalarKey));
						RDFLOAT(&sckey.e[0].p);
#ifdef DBGKFB
						if(dbgio) 
						   printf("  scalar = (%.3f)\n", sckey.e[0].p);
#endif
						//theWorker->trackFlags[FALL_TRACK_INDEX] = trflags;
						theWorker->workNode->trackFlags[FALL_TRACK_INDEX] = trflags;
						
						if(!theWorker->AddFallKey(&sckey))
							return 0;
						}
						break;
					case FOV_TRACK_TAG:
						{
						ScalarKey sckey;
						memset(&sckey,0,sizeof(ScalarKey));
						memcpy(&sckey,&key,sizeof(ScalarKey));
						RDFLOAT(&sckey.e[0].p);
#ifdef DBGKFB
						if(dbgio) 
						   printf("  scalar = (%.3f)\n", sckey.e[0].p);
#endif
						//theWorker->trackFlags[FOV_TRACK_INDEX] = trflags;
						theWorker->workNode->trackFlags[FOV_TRACK_INDEX] = trflags;
						
						if(!theWorker->AddFOVKey(&sckey))
							return 0;
						}
						break;
					case ROLL_TRACK_TAG:
						{
						ScalarKey sckey;
						memset(&sckey,0,sizeof(ScalarKey));
						memcpy(&sckey,&key,sizeof(ScalarKey));
						RDFLOAT(&sckey.e[0].p);
#ifdef DBGKFB
						if(dbgio) 
						   printf("  scalar = (%.3f)\n", sckey.e[0].p);
#endif
						//theWorker->trackFlags[ROLL_TRACK_INDEX] = trflags;
						theWorker->workNode->trackFlags[ROLL_TRACK_INDEX] = trflags;
						
						if(!theWorker->AddRollKey(&sckey))
							return 0;
						}
						break;
#ifdef LATER
					case MORPH_TRACK_TAG: {
							MorphKey mkey;
							char mobname[12];
							int num;
							memset(&mkey,0,sizeof(MorphKey));
							memcpy(&mkey,&key,sizeof(MorphKey));
							if (!getstring(rstream,mobname,11)) return(0);
							if (merging) MaybeRemapName(mobname);
							num = nobj_number(mobname);
							if (num>=0) {
								mkey.object = get_named_ptr(num);
								APPEND_ELEMENT(&mkey,&tr->keytab);
								}
							}
						break;
					case HIDE_TRACK_TAG: {
							HideKey hkey;
							int num;
							memset(&hkey,0,sizeof(HideKey));
							memcpy(&hkey,&key,sizeof(key));
							APPEND_ELEMENT(&hkey,&tr->keytab);
							}
						break;
#endif
					}  /*switch */
				}  /* for */	
			chunk.size = 0;
			break;
		case M3DMAGIC:
			theWorker->gotM3DMAGIC = TRUE;
		case MMAGIC:
			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)
					return(0);

				switch(next.tag)
					{
					case MMAGIC:
					case NAMED_OBJECT:
					case KFDATA:
						if(get_mchunk(NULL)==0)
							return(0);
						break;
					case MASTER_SCALE:
						if(get_mchunk(NULL)==0)
							return(0);
						break;
#ifdef LATER
					case VIEWPORT_LAYOUT:
						if(merging)
							goto no_merge;
						if(get_vuechunk(stream,(void *)MODEEDT)==0)
							return(0);
						break;
					case MESH_VERSION:
					case O_CONSTS:
					case RAY_BIAS:
					case LO_SHADOW_BIAS:
					case SHADOW_MAP_SIZE:
					case SHADOW_FILTER:
					case SHADOW_RANGE:
					case RAY_SHADOWS:
#endif

					case AMBIENT_LIGHT:
					case BIT_MAP:
					case USE_BIT_MAP:
					case SOLID_BGND:
					case USE_SOLID_BGND:
					case USE_V_GRADIENT:
					case FOG:
					case USE_FOG:
					case LAYER_FOG:
					case USE_LAYER_FOG:
					case DISTANCE_CUE:
					case USE_DISTANCE_CUE:
					case V_GRADIENT:
						if(merging)
							goto no_merge;
						if(get_mchunk(&BG.bkgd_gradient)==0)
							return(0);
						break;
#ifdef LATER
					case APP_DATA:
						if(merging)
							goto no_merge;
						if(get_mchunk(&MSHappdata)==0)
							return(0);
						break;					
#endif
					case MAT_ENTRY:
						got_mat_chunk=1;
						loadmtl = &inmtl;
						/* Zero out data structure first */
						init_mtl_struct(loadmtl);
						if(get_mtlchunk(stream,NULL)==0)
							return(0);
						if(merging==0||(merging==1 /*&& mg_meshes*/ ))
							theWorker->AddMeshMtl(loadmtl);
						FreeMatRefs(loadmtl);
						break;     
					default:
						no_merge:
						if(skip_chunk(stream)==0)
							return(0);
						break;
					}
				chunk.size-=next.size;
				}
			break;
		case SMAGIC:
			while(chunk.size) {
				if(get_next_chunk(stream,&next)==0)
			    	return(0);

				switch(next.tag) {
					case POLY_2D:
						if(needShapeImportOptions) {
							needShapeImportOptions = FALSE;
							// Put up the options dialog!
							int result = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_SHAPEIMPORTOPTIONS), theWorker->ip->GetMAXHWnd(), ShapeImportOptionsDlgProc, (LPARAM)theShapeImport);
							if(result <= 0) {
								shapeImportAbort = TRUE;
								return 0;
								}
							}
						if(!importShapes)
							goto skipit2;
						// Intentional fall-thru
				    case SHAPE_HOOK:
//					case SHAPE_OK:
//					case SHAPE_NOT_OK:
				    case MASTER_SCALE:
						if(get_mchunk(NULL)==0)
							return(0);
						break;
					default:
						skipit2:
						if(skip_chunk(stream)==0)
							return(0);
						break;
					}
			   chunk.size-=next.size;
			   }
			theWorker->FinishShape();
			break;
		 
		case SHAPE_HOOK:
			RDERR(&theWorker->hook_x,4);
			theWorker->hook_x*=msc_wk;
			RDERR(&theWorker->hook_y,4);
			theWorker->hook_y*=msc_wk;
			chunk.size-=8L;
			goto skiprest;

		case POLY_2D:
			if(!theWorker->StartSpline())
				return 0;

			RDERR(&wk_count,2);
			chunk.size-=2L;

			for(ix=0; ix<wk_count; ++ix)
				{
				Shppt point;
				Shppt *p= &point;
				RDERR(&point,sizeof(Shppt));

				if(msc_wk!=1.0) {
					p->x=p->x*msc_wk;	/* Adjust all pts to appropriate scale */
					p->y=p->y*msc_wk;
					p->z=0.0f;
					p->inx*=msc_wk;
					p->iny*=msc_wk;
					p->inz*=msc_wk;
					p->outx*=msc_wk;
					p->outy*=msc_wk;
					p->outz*=msc_wk;
					}
				p->x=p->x - theWorker->hook_x;	/* Adjust all pts to appropriate hook */
				p->y=p->y - theWorker->hook_y;
				p->z=0.0f;	// DB 2/29

				if(!theWorker->AddShapePoint(p))
					return 0;
				if(point.flags&POLYEND) {
					if(point.flags&POLYCLOSED)
						theWorker->CloseSpline();
					}
				chunk.size-=(long)sizeof(Shppt);
				}
			goto skiprest;

	#ifdef LATER
		case MESH_VERSION:
			RDERR(&mesh_version,4);
			chunk.size-=4L;
			goto skiprest;
	#endif
		case LIN_COLOR_F:
		case COLOR_F: {
			Color_f *cf=(Color_f *)data;
			RDERR(cf,12);
			chunk.size-=12L;
			goto skiprest;
			}
		case COLOR_24: {
			Color_24 c24;
			Color_f *cf=(Color_f *)data;
			RDERR(&c24,3);
			cf->r=(float)c24.r/255.0f;
			cf->g=(float)c24.g/255.0f;
			cf->b=(float)c24.b/255.0f;
			chunk.size-=3L;
			goto skiprest;
			}
		case MASTER_SCALE: {
			RDERR(&msc_wk,4);
			chunk.size-=4L;
			int type;
			float scale;

			GetMasterUnitInfo(&type, &scale);
			float msc_factor = (float)GetMasterScale(autoConv ? UNITS_INCHES : type);
			msc_wk = (float)((double)msc_wk / msc_factor);		/* Turn into a mult factor */
			goto skiprest;
			}
//	#ifdef LATER
		case SOLID_BGND:
			{
			int got_gam=0,got_lin=0;
			Color gamcol,lincol;
			while (chunk.size)
				{
				if (get_next_chunk(stream,&next)==0) return(0);
				switch(next.tag) {
					case COLOR_F:	case COLOR_24:
						got_gam = 1;
						if (get_mchunk(&gamcol)==0) return(0);
						break;
					case LIN_COLOR_F:
						got_lin = 1;
						if (get_mchunk(&lincol)==0) return(0);
						break;
					default:
						if (skip_chunk(stream)==0)
							return(0);
						break;
					}
				chunk.size-=next.size;
				}
			if (gammaMgr.enable) {
				if (got_lin) 
					BG.bkgd_solid = lincol;
				else {
					if (!got_gam) return(0);
					fin_degammify(&BG.bkgd_solid, &gamcol);
					}
				}
			else { 
				if (!got_gam) return(0);
				BG.bkgd_solid = gamcol;
				}
			}
			break;
		case USE_SOLID_BGND:
			BG.bgType = BG_SOLID;
			goto skiprest;
		case BIT_MAP: {
			char buf[82];
			if(read_string(buf,stream,81)==0)
				return(0);
			chunk.size-=(long)(strlen(buf)+1);
			split_fn(NULL,BG.bkgd_map,buf);
			if(stricmp(BG.bkgd_map,"none")==0)
				BG.bkgd_map[0]=0;
			}
	/*	DebugPrint(BG.bkgd_map,"%s\\%s",P.mapdrawer,gp_buffer);*/
			goto skiprest;
		case USE_BIT_MAP:
			BG.bgType = BG_BITMAP;
			goto skiprest;
		case V_GRADIENT:
			{
			Color cols[3],lcols[3];
			int lcolors,colors;
			gd=(Bkgrad *)data;
			RDERR(&gd->midpct,sizeof(float));
			chunk.size-=(long)sizeof(float);

		/* Make defaults black */
			gd->botcolor.r = gd->botcolor.g = gd->botcolor.b = 0.0f;
			gd->midcolor = gd->topcolor = gd->botcolor;

		/* Now read up to 3 colors */

			lcolors = colors = 0;
			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)	return(0);
				switch(next.tag)
					{
					case COLOR_F:
					case COLOR_24:
						if(get_mchunk(&cols[colors])==0) return(0);
						colors++;
						break;
					case LIN_COLOR_F:
						if(get_mchunk(&lcols[lcolors])==0) return(0);
						lcolors++;
						break;
					default:
						if(skip_chunk(stream)==0)	return(0);
						break;
					}
				chunk.size-=next.size;
				}
			if (gammaMgr.enable) {
				if (lcolors) {
					if (lcolors>0) gd->botcolor = lcols[0];
					if (lcolors>1) gd->midcolor = lcols[1];
					if (lcolors>2) gd->topcolor = lcols[2];
					}
				else {
					if (colors>0) fin_degammify(&gd->botcolor, &cols[0]);
					if (colors>1) fin_degammify(&gd->midcolor, &cols[1]);
					if (colors>2) fin_degammify(&gd->topcolor, &cols[2]);
					}
				}
			else {
				if (colors>0) gd->botcolor = cols[0];
				if (colors>1) gd->midcolor = cols[1];
				if (colors>2) gd->topcolor = cols[2];
				}
			}
			break;
		case USE_V_GRADIENT:
			BG.bgType = BG_GRADIENT;
			goto skiprest;
		case AMBIENT_LIGHT:
			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)
					return(0);
				switch(next.tag)
					{
					case COLOR_F:
					case COLOR_24:
						if(get_mchunk(&BG.amb_light)==0)
							return(0);
//						load_ambient_light();
						break;
					default:
						if(skip_chunk(stream)==0)
							return(0);
						break;
					}
				chunk.size-=next.size;
				}
			break;
		case FOG:
			RDERR(&BG.fog_data,sizeof(float)*4);
			BG.fog_data.nearplane *= msc_wk;
			BG.fog_data.farplane *= msc_wk;
			BG.distance_cue.nearplane=BG.fog_data.nearplane;
			BG.distance_cue.farplane=BG.fog_data.farplane;
			chunk.size-=(long)(4*sizeof(float));
			BG.fog_bg=0;
			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)
					return(0);
				switch(next.tag)
					{
					case FOG_BGND:
						if(get_mchunk(NULL)==0)
							return(0);
						break;
					case COLOR_F:
					case COLOR_24:
						if(get_mchunk(&BG.fog_data.color)==0)
							return(0);
						break;
					default:
						if(skip_chunk(stream)==0)
							return(0);
						break;
					}
				chunk.size-=next.size;
				}
			break;
		case LAYER_FOG:
			RDERR(&BG.lfog_data,sizeof(float)*3);
			RDERR(&BG.lfog_data.type,sizeof(int));
			BG.lfog_data.zmin *= msc_wk;
			BG.lfog_data.zmax *= msc_wk;
			chunk.size-=(long)(4*sizeof(float));
			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)
					return(0);
				switch(next.tag)
					{
					case COLOR_F:
					case COLOR_24:
						if(get_mchunk(&BG.lfog_data.color)==0)
							return(0);
						break;
					default:
						if(skip_chunk(stream)==0)
							return(0);
						break;
					}
				chunk.size-=next.size;
				}
			break;
		case USE_FOG:
			BG.envType = ENV_FOG;
			goto skiprest;
		case FOG_BGND:
			BG.fog_bg=1;
			goto skiprest;
		case DISTANCE_CUE:
			RDERR(&BG.distance_cue,sizeof(float)*4);
			BG.distance_cue.nearplane *= msc_wk;
			BG.distance_cue.farplane *= msc_wk;
			BG.fog_data.nearplane=BG.distance_cue.nearplane;
			BG.fog_data.farplane=BG.distance_cue.farplane;
			chunk.size-=(long)(4*sizeof(float));
			BG.dim_bg=0;
			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)
					return(0);
				switch(next.tag)
					{
					case DCUE_BGND:
						if(get_mchunk(NULL)==0)
							return(0);
						break;
					default:
						if(skip_chunk(stream)==0)
							return(0);
						break;
					}
				chunk.size-=next.size;
				}
			break;
		case USE_LAYER_FOG:
			BG.envType = ENV_LAYFOG;
			goto skiprest;
		case USE_DISTANCE_CUE:
			BG.envType = ENV_DISTCUE;
			goto skiprest;
		case DCUE_BGND:
			BG.dim_bg=1;
			goto skiprest;
#ifdef LATER
		case O_CONSTS:
			RDERR(&const_x,sizeof(float)*3);
			chunk.size-=(long)(sizeof(float)*3);
			goto skiprest;
		case RAY_SHADOWS:
			P.ray_shadows = 1;
			goto skiprest;
		case SHADOW_MAP_SIZE:
			RDERR(&wk_count,2);
			P.shadsize=wk_count;
			chunk.size-=2L;
			goto skiprest;
		case RAY_BIAS:
			RDERR(&P.ray_bias,sizeof(float));
			chunk.size-=sizeof(float);
			goto skiprest;
		case LO_SHADOW_BIAS:
			RDERR(&P.lo_bias,sizeof(float));
			chunk.size-=sizeof(float);
			goto skiprest;
		case SHADOW_RANGE:
			RDERR(&wk_count,2);
			P.shadfilter=(float)wk_count;
			chunk.size-=2L;
			goto skiprest;
		case SHADOW_FILTER:
			RDERR(&P.shadfilter,sizeof(float));
			chunk.size-=sizeof(float);
			goto skiprest;
#endif
		case DL_RANGE:
		case DL_OUTER_RANGE:
		case DL_INNER_RANGE: {
			float *fptr=(float *)data;
			RDERR(fptr,sizeof(float));
			*fptr *= msc_wk;
			chunk.size-=sizeof(float);
			goto skiprest;
			}
		case DL_MULTIPLIER:
			d=(Dirlight *)data;
			RDERR(&d->mult,sizeof(float));
			chunk.size-=sizeof(float);
			goto skiprest;
		case NAMED_OBJECT:
			if(read_string(obname,stream,OBJ_NAME_LEN+1)==0)
				return(0);
			chunk.size-=(long)(strlen(obname)+1);

	#ifdef LATER
			if(merging==1 && merge_this(obname)==0)
				skipping=1;
			else
				skipping=0;
	#else
			skipping = 0;
	#endif // LATER
			obnbr= -1;
			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)
					return(0);
				if(skipping) {
					if(skip_chunk(stream)==0) // skip obj
						return(0);
                }
				switch(next.tag)
					{
					case N_TRI_OBJECT:
						if(!theWorker->StartMesh(obname))
							return 0;
						if(get_mchunk(theWorker)==0)
							return 0;
						break;
					case N_D_L_OLD:
					case N_DIRECT_LIGHT: {
						Dirlight &d = theWorker->studioLt;
						// Init the direct light to an omni
						d.x=d.y=d.z=d.tx=d.ty=d.tz=0.0f;
						d.flags=NO_LT_ON;
						d.color.r=d.color.g=d.color.b=1.0f;
						d.hotsize=d.fallsize=360.0f;
						d.lo_bias=3.0f;	// TO DO: USE GLOBAL?
//						d.exclude=NULL;
						d.shadsize=256;	// TO DO: USE GLOBAL?
						d.in_range=10.0f;
						d.out_range=100.0f;
						d.shadfilter=5.0f;	// TO DO: USE GLOBAL?
						strcpy(d.imgfile,"");
						d.ray_bias = 0.2f;	// TO DO: USE GLOBAL?
						d.bank=0.0f;
						d.aspect=1.0f;
						d.mult=1.0f;
						d.appdata = NULL;
						if(!theWorker->StartLight(obname))
							return 0;
						if(get_mchunk(&d)==0)
							return 0;
						int type = d.hotsize==360.0f ? OMNI_LIGHT : TSPOT_LIGHT;
						if(!theWorker->CreateLight(type))
							return 0;
						}
						break;
					case N_CAM_OLD:
					case N_CAMERA: {
						Camera3DS &c = theWorker->studioCam;
						// Init the camera struct
						c.x=c.y=c.z=c.tx=c.ty=c.tz=c.bank=0.0f;
						c.focal=50.0f;
						c.flags=0;
						c.nearplane=10.0f;
						c.farplane=1000.0f;
						c.appdata = NULL;
						if(!theWorker->StartCamera(obname))
							return 0;
						if(get_mchunk(&c)==0)
							return 0;
						if(!theWorker->CreateCamera(TARGETED_CAMERA))
							return 0;
						}
						break;

	#ifdef FIXTHIS
						/*----  Keyframer code */
						int dupres=0;
						Namedobj *dupob;
						char origobname[OBJ_NAME_LEN+1];
						strcpy(origobname,obname);
						if (do_replace_msh) {
							if (obj_unique(obname,-1)) {
								skipping = 1;
								if(skip_chunk(stream)==0)  // skip obj
									return(0);
							}
							else {
								/*replace the object with the same name */
								dupob = get_named_ptr(nobj_number(obname));
								if (dupob->type!=ObTypeFromTag(next.tag)) {
									if(skip_chunk(stream)==0)  // skip obj
										return(0);
                                }
								dont_del_ob_refs = 1;
								kill_named(obname,0);
								dont_del_ob_refs = 0;
								dupres = 2;
								}
							}
						else {
							if (merging)
								while(obj_unique(obname,-1)==0)	{
									dupob = get_named_ptr(nobj_number(obname));
									check_dup_type = 1;
									merge_nob_type = next.tag;
									dupres = dup_name(obname,progstr(STR0057),progstr(STR0546));
									check_dup_type = 0;
									if (dupres==0)  {  /* SKIPPING  object */
										if (dupob->type!=N_TRI_OBJECT)  
											RegisterObNameChg(origobname,"$_$_$_$");
										else {
											/* turn off '*' for this name in the merge list */
											dont_merge_this(origobname);
											}
										skipping=1;
										if(skip_chunk(stream)==0)  // skip obj
											return(0);
									}
									if (dupres==2) {
										break; 
										}
									}
							}
						if((obnbr=create_named_obj(obname,next.tag,&n)<0))	{
							bad_reason=PARTIAL_READ;
							return(0);
							}
						if (merging) {
							if (dupres==2) /* Delete OLD */
								RemapNodeObRefs(dupob,n);
							else if (dupres==1)  /* Rename NEW object */
								RegisterObNameChg(origobname,obname);								
							}
						if (do_replace_msh) 
							RemapNodeObRefs(dupob,n);
				   	}  /* end of merge_it block */
						n->flags |= NO_NEED_DRAW;
						if(get_mchunk(stream,n->dstruct)==0)
							{
							kill_object(obnbr);
							return(0);
							}
						if(P.detail==0)
							set_ob_sels(OBJECTS-1,OBJECTS);
#else
						if(get_mchunk(NULL)==0)
							return 0;
#endif
						break;
					
					case OBJ_DOESNT_CAST:
					case OBJ_DONT_RCVSHADOW:
						if (get_mchunk(NULL)==0)
							return(0);
						break;
#ifdef LATER
					case OBJ_HIDDEN:
					case OBJ_VIS_LOFTER:
					case OBJ_FAST:
					case OBJ_FROZEN:
					case OBJ_DOESNT_CAST:
					case OBJ_MATTE:
					case OBJ_DONT_RCVSHADOW:
					case OBJ_PROCEDURAL:
						if(merging && mg_meshes==0) {
							if(skip_chunk(stream)==0)  // skip obj
								return(0);
                        }
						if(obnbr<0)
							return(0);
						/* n = get_named_ptr(obnbr); */
						if (get_mchunk(stream,n)==0)
							return(0);
						break;
	#endif
					default:
						if(skip_chunk(stream)==0) // skip obj
							return(0);
						break;
					}
				chunk.size-=next.size;
				}
			break;
				
		case OBJ_DOESNT_CAST:
			theWorker->cstShad = 0;
			break;

		case OBJ_DONT_RCVSHADOW:			
			theWorker->rcvShad = 0;
			break;

	#ifdef LATER
		case OBJ_HIDDEN:
			hiddens=1;
			n=(Namedobj *)data;
			n->flags |= NO_HIDDEN;
			goto skiprest;
		case OBJ_DOESNT_CAST:
			n=(Namedobj *)data;
			n->flags |= NO_DOESNT_CAST;
			goto skiprest;
		case OBJ_MATTE:
			n=(Namedobj *)data;
			n->flags |= NO_MATTE;
			goto skiprest;
	   case OBJ_DONT_RCVSHADOW:
			n=(Namedobj *)data;
			n->flags |= NO_DONT_RCVSHADOW;
			goto skiprest;
		case OBJ_PROCEDURAL:
			n=(Namedobj *)data;
			n->flags |= NO_PROCEDURAL;
			goto skiprest;
		case OBJ_FAST:										 
			n=(Namedobj *)data;
			n->flags |= NO_FAST;
			goto skiprest;
		case OBJ_FROZEN:
			n=(Namedobj *)data;
			n->flags |= NO_FROZEN;
			goto skiprest;
		case OBJ_VIS_LOFTER:
			n=(Namedobj *)data;
			n->flags |= NO_SEE_LOFT;
			goto skiprest;
#endif
		case APP_DATA:			
			theWorker->LoadAppData(stream,chunk.size);
			break;
// TO DO: Actually load & store appdata
//			if (!load_app_data(stream, data, chunk.size))
//				return(0);
//			chunk.size = 0;
//			goto skiprest;
		

		case N_TRI_OBJECT:
	#ifdef FIXTHIS
			t=(Tri_obj *)data;
			t->color=0;	/* Default to good ol' white */
	#endif
			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)
					return(0);
				switch(next.tag)
					{
					case POINT_ARRAY:
					case FACE_ARRAY:
					case MESH_MATRIX:
					case TEX_VERTS:
						if(get_mchunk(data)==0)
							return(0);
						break;

					case APP_DATA:
						if(get_mchunk(data)==0)
							return(0);
						break;
	#ifdef LATER
					case POINT_FLAG_ARRAY:
					case MESH_TEXTURE_INFO:
					case PROC_NAME:
					case PROC_DATA:
					case MESH_COLOR:
						if(get_mchunk(stream,data)==0)
							return(0);
						break;
					case APP_DATA:
						if(get_mchunk(stream,&t->appdata)==0)
							return(0);
						break;
	#endif
					default:
						if(skip_chunk(stream)==0)
							return(0);
						break;
					}
				chunk.size-=next.size;
				}
	#ifdef LATER
			updt_ob_box(data); 
	#endif
			break;
		case POINT_ARRAY:
			RDERR(&wk_count,2);
			chunk.size-=2L;
			if(!theWorker->SetVerts((int)wk_count))
				return 0;
			for(ix=0; ix<wk_count; ++ix)
				{
				RDERR(&v,sizeof(float)*3);
				if(msc_wk!=1.0)
					{
					v.x*=msc_wk;
					v.y*=msc_wk;
					v.z*=msc_wk;
					}
				v.flags=0;
				if(!theWorker->PutVertex(ix,&v))
					return 0;
				chunk.size-=(long)(sizeof(float)*3);
				}
			goto skiprest;
		case TEX_VERTS:
			RDERR(&wk_count,2);
			chunk.size-=2L;
			if(!theWorker->SetTVerts((int)wk_count))
				return 0;
			tv.z = 0.0f;
			for(ix=0; ix<wk_count; ++ix)
				{
				RDERR(&tv,sizeof(float)*2);
				// filter out bogus texture coord values: old versions of 
				// 3ds could have 0xfefefefe as the value.
				// This should catch those and other bad values 
				// derived from them.  --DS 3/16/96
				if (tv.x>1.0e10) tv.x = 0.0f;
				if (tv.x<-1.0e10) tv.x = 0.0f;
				if (tv.y>1.0e10) tv.y = 0.0f;
				if (tv.y<-1.0e10) tv.y = 0.0f;
				if(!theWorker->PutTVertex(ix,&tv))
					return 0;
				chunk.size-=(long)(sizeof(float)*2);
				}
			goto skiprest;
	#ifdef LATER
		case PROC_NAME:
			t=(Tri_obj *)data;
			if(read_string(t->proc_name,stream,9)==0)
				return(0);
			chunk.size-=(long)(strlen(t->proc_name)+1);
			goto skiprest;
		case PROC_DATA: 
			{
			ULONG *plong;
			t=(Tri_obj *)data;
			if (t->flags&TRI_HAS_PROCDATA) {
				XMFreeAndZero(&t->proc_data);
				t->flags &= ~TRI_HAS_PROCDATA;
				}
			t->proc_data = (void *)XMAlloc(chunk.size+4);
			if (t->proc_data==NULL) 
				return(0);			
			plong = (ULONG *)t->proc_data;
			plong[0] = chunk.size;
			RDERR(&plong[1],chunk.size);
			t->flags |= TRI_HAS_PROCDATA;
			chunk.size = 0;
			goto skiprest;
			}
		case MESH_TEXTURE_INFO:
			t=(Tri_obj *)data;
			RDERR(&Mapinfo,sizeof(Mapinfo));
			chunk.size-=sizeof(Mapinfo);
			t->maptype=Mapinfo.maptype;
			t->tile_x=Mapinfo.tile_x;
			t->tile_y=Mapinfo.tile_y;
			t->map_x=Mapinfo.map_x;
			t->map_y=Mapinfo.map_y;
			t->map_z=Mapinfo.map_z;
			t->map_scale=Mapinfo.map_scale;
			memcpy(t->map_matrix,Mapinfo.map_matrix,sizeof(float)*12);
			t->map_pw=Mapinfo.map_pw;
			t->map_ph=Mapinfo.map_ph;
			t->map_ch=Mapinfo.map_ch;
			goto skiprest;
	#endif
		case POINT_FLAG_ARRAY:
	#ifdef FIXTHIS
			t=(Tri_obj *)data;
			RDERR(&wk_count,2);
			chunk.size-=2L;
			for(ix=0; ix<t->verts; ++ix)
				{
				get_vert(t,ix,&v);
				RDERR(&v.flags,sizeof(short));
				put_vert(t,ix,&v);
				chunk.size-=(long)sizeof(short);
				}
	#endif
			goto skiprest;
		case FACE_ARRAY:
			RDERR(&wk_count,2);
			chunk.size-=2L;
			if(!theWorker->SetFaces((int)wk_count))
				return 0;
			for(ix=0; ix<wk_count; ++ix)
				{
				RDERR(&Fc_wrt,8);
/*
				if (mesh_version<2)
					Fc_wrt.flags &= ~VWRAP;
*/
				f.a=Fc_wrt.a;
				f.b=Fc_wrt.b;
				f.c=Fc_wrt.c;
				f.material = 0;		/* None! */
				f.sm_group = 0;		/* None! */
				f.flags=Fc_wrt.flags;
				if(!theWorker->PutFace(ix,&f))
					return 0;
				chunk.size-=8L;
				}

			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)
					return(0);
				switch(next.tag)
					{
					case MSH_MAT_GROUP:
	#ifdef LATER
					case OLD_MAT_GROUP:
					case MSH_BOXMAP:
	#endif
					case SMOOTH_GROUP:
						if(get_mchunk(NULL)==0)
							return(0);     
						break;
					default:
						if(skip_chunk(stream)==0)
							return(0);
						break;
					}
				chunk.size-=next.size;
				}
			break;
		case MESH_MATRIX:
			{
			Matrix3 tm;
			RDERR(tm.GetAddr(),sizeof(float)*12);
			tm.SetNotIdent();
			if(msc_wk!=1.0)
				{
				tm.SetTrans(tm.GetTrans()*msc_wk);
				}
			theWorker->SetTm(&tm);
			chunk.size-=48L;
			goto skiprest;
			}
		case MESH_COLOR:
	#ifdef FIXTHIS
			t=(Tri_obj *)data;
			RDERR(&t->color,sizeof(uchar));
			if(t->color>=OBJ_COLOR_MAX)
				t->color=0;
	#else
	fseek(stream,1,SEEK_CUR);
	#endif
			chunk.size-=1;
			goto skiprest;

		case MSH_MAT_GROUP:	{
			char mtlname[40];
			int mtlnum;
			unsigned short wkface;
//			if(got_mat_chunk==0)
//			 	antiquated=1;
			if(read_string(mtlname,stream,17)==0)
				return(0);
			chunk.size-=(long)(strlen(mtlname)+1);

			mtlnum = theWorker->GetMatNum(mtlname);
			
			RDERR(&wk_count,2);
			chunk.size-=2L;
			for(ix=0; ix<wk_count; ++ix)
				{
				RDERR(&wkface,2);
				chunk.size -= 2L;   				
				if(!theWorker->PutFaceMtl(wkface, mtlnum))
					return 0;				
				}
			}
			goto skiprest;

	#ifdef LATER
		case OLD_MAT_GROUP:
			antiquated=1;
		case MSH_BOXMAP:
			t=(Tri_obj *)data;
			t->flags |= TRI_BOX_MAP;
			for(ix=0; ix<6; ++ix) {
				if(read_string(mtlname,stream,17)==0)
					return(0);
	 			chunk.size-=(long)(strlen(mtlname)+1);
				if (strcmp(mtlname,"DEFAULT")==0) 
					t->boxmtl[ix]=255;
				else
					t->boxmtl[ix]=inst_material(mtlname,0);
	#ifdef STAND_ALONE
				printf(" Box material %s , # %d \n",mtlname,t->boxmtl[ix]);
	#endif
				}
			goto skiprest;
	#endif
		case SMOOTH_GROUP:
			{
			int faces = theWorker->GetFaces();
			unsigned long smgroup;
			for(ix=0; ix<faces; ++ix)
				{
				RDERR(&smgroup,sizeof(unsigned long));
				chunk.size-=sizeof(unsigned long);
				if(!theWorker->PutSmooth(ix,smgroup))
					return 0;
				}
			goto skiprest;
			}
		case N_D_L_OLD: {
			d = (Dirlight *)data;
			RDERR(&d->x,sizeof(float));
			RDERR(&d->y,sizeof(float));
			RDERR(&d->z,sizeof(float));
			if(msc_wk != 1.0)
				{
				d->x *= msc_wk;
				d->y *= msc_wk;
				d->z *= msc_wk;
				}
			RDERR(&fdum,sizeof(float));
			RDERR(&fdum,sizeof(float));
			RDERR(&d->hotsize,sizeof(float));
			d->fallsize=d->hotsize;
			RDERR(&d->flags,2);
		
			chunk.size-=26L;
			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)
					return(0);
				switch(next.tag)
					{
					case COLOR_F:
					case COLOR_24:
						if(get_mchunk(&d->color)==0)
							return(0);
						break;
					default:
						if(skip_chunk(stream)==0)
							return(0);
						break;
					}
				chunk.size-=next.size;
				}
			}
			break;
		case N_CAM_OLD: {
			Camera3DS *c = (Camera3DS *)data;
			RDERR(&c->x,sizeof(float));
			RDERR(&c->y,sizeof(float));
			RDERR(&c->z,sizeof(float));
			if(msc_wk != 1.0)
				{
				c->x *= msc_wk;
				c->y *= msc_wk;
				c->z *= msc_wk;
				}
			RDERR(&fdum,sizeof(float));
			RDERR(&fdum,sizeof(float));
			RDERR(&fdum,sizeof(float));
			chunk.size-=24L;
			goto skiprest;
			}
		case N_DIRECT_LIGHT: {
			d = (Dirlight *)data;
			RDERR(&d->x,sizeof(float));
			RDERR(&d->y,sizeof(float));
			RDERR(&d->z,sizeof(float));
			if(msc_wk != 1.0)
				{
				d->x *= msc_wk;
				d->y *= msc_wk;
				d->z *= msc_wk;
				}
				
			chunk.size-=12L;
			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)
					return(0);
				switch(next.tag)
					{
					case COLOR_F:
					case COLOR_24:
						if(get_mchunk(&d->color)==0)
							return(0);
						break;
					case DL_RANGE:	/* Old style chunk */
						if(get_mchunk(&d->out_range)==0)
							return(0);
						d->in_range=d->out_range/10.0f;
						if(d->out_range==d->in_range)
							d->out_range+=1.0f;
						break;
					case DL_INNER_RANGE:
						if(get_mchunk(&d->in_range)==0)
							return(0);
						break;
					case DL_OUTER_RANGE:
						if(get_mchunk(&d->out_range)==0)
							return(0);
						break;
					case DL_EXCLUDE:
					case DL_SPOTLIGHT:
					case DL_OFF:
					case DL_ATTENUATE:
					case DL_MULTIPLIER:
						if(get_mchunk(d)==0)
							return(0);
						break;
					case APP_DATA:
						if(get_mchunk(&d->appdata)==0)
							return(0);
						break;
					default:
						if(skip_chunk(stream)==0)
							return(0);
						break;
					}
				chunk.size-=next.size;
				}
			}
			break;
		case DL_SPOTLIGHT: {
			d = (Dirlight *)data;
			RDERR(&d->tx,sizeof(float));
			RDERR(&d->ty,sizeof(float));
			RDERR(&d->tz,sizeof(float));
			if(msc_wk != 1.0)
				{
				d->tx *= msc_wk;
				d->ty *= msc_wk;
				d->tz *= msc_wk;
				}
			RDERR(&d->hotsize,sizeof(float));
			RDERR(&d->fallsize,sizeof(float));

			/* Enforce keep .5 degree gap for antialiasing */
			if (d->hotsize>d->fallsize-.5&&d->fallsize>=.5f) 
				d->hotsize = d->fallsize-.5f;
			
			chunk.size-=20L;
			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)
					return(0);
				switch(next.tag)
					{
					case DL_SHADOWED:
					case DL_LOCAL_SHADOW:
					case DL_LOCAL_SHADOW2:
					case DL_SEE_CONE:
					case DL_SPOT_RECTANGULAR:
					case DL_SPOT_OVERSHOOT:
					case DL_SPOT_PROJECTOR:
					case DL_SPOT_ROLL:
					case DL_SPOT_ASPECT:
					case DL_RAY_BIAS:
					case DL_RAYSHAD:
						if(get_mchunk(d)==0)
							return(0);
						break;
					default:
						if(skip_chunk(stream)==0)
							return(0);
						break;
					}
				chunk.size-=next.size;
				}
			}
			break;
//#ifdef LATER
		case DL_EXCLUDE: {
			d=(Dirlight *)data;
			TCHAR oname[12];
			if(read_string(oname,stream,11)==0)
				return(0);
			chunk.size-=(long)(strlen(oname)+1);
			//if(add_exclude_list(oname,d)<=0)
			//	return(0);
			d->excList.AddName(oname);
			goto skiprest;
			}

//#endif // LATER
		case DL_SPOT_ROLL:
			d=(Dirlight *)data;
			RDERR(&d->bank,sizeof(float));
			chunk.size-=(long)(sizeof(float));
			goto skiprest;
		case DL_SPOT_ASPECT:
			d=(Dirlight *)data;
			RDERR(&d->aspect,sizeof(float));
			chunk.size-=(long)(sizeof(float));
			goto skiprest;
		case DL_RAY_BIAS:
			d=(Dirlight *)data;
			RDERR(&d->ray_bias,sizeof(float));
			chunk.size-=(long)(sizeof(float));
			goto skiprest;
		case DL_OFF:
			d=(Dirlight *)data;
			d->flags &= NO_LT_OFF;
			goto skiprest;
		case DL_ATTENUATE:
			d=(Dirlight *)data;
			d->flags |= NO_LT_ATTEN;
			goto skiprest;
		case DL_RAYSHAD:
			d=(Dirlight *)data;
			d->flags |= NO_LT_RAYTR;
			goto skiprest;
		case DL_SHADOWED:
			d=(Dirlight *)data;
			d->flags |= NO_LT_SHAD;
			goto skiprest;
		case DL_SEE_CONE:
			d=(Dirlight *)data;
			d->flags |= NO_LT_CONE;
			goto skiprest;
		case DL_SPOT_RECTANGULAR:
			d=(Dirlight *)data;
			d->flags |= NO_LT_RECT;
			goto skiprest;
		case DL_SPOT_OVERSHOOT:
			d=(Dirlight *)data;
			d->flags |= NO_LT_OVER;
			goto skiprest;
		case DL_SPOT_PROJECTOR:
			d=(Dirlight *)data;
			d->flags |= NO_LT_PROJ;
			RDERR(d->imgfile,13);
			chunk.size-=13;
			goto skiprest;
		case DL_LOCAL_SHADOW: {
			Locshad Loc_shadwrt;
			d=(Dirlight *)data;
			d->flags |= NO_LT_LOCAL;
			RDERR(&Loc_shadwrt,sizeof(Locshad));
			chunk.size-=sizeof(Locshad);
			d->lo_bias=Loc_shadwrt.lo_bias;
			d->shadsize=Loc_shadwrt.shadsize;
			d->shadfilter=(float)Loc_shadwrt.shadrange;
			goto skiprest;
			}
		case DL_LOCAL_SHADOW2:
			{
			LocShad2 locShad2;
			d=(Dirlight *)data;
			d->flags |= NO_LT_LOCAL;
			RDERR(&locShad2,sizeof(LocShad2));
			chunk.size-=sizeof(LocShad2);
			d->lo_bias=locShad2.bias;
			d->shadsize=locShad2.shadsize;
			d->shadfilter=locShad2.shadfilter;
			}
			goto skiprest;
		case N_CAMERA: {
			Camera3DS *c = (Camera3DS *)data;
			RDERR(c,32);
			if(msc_wk != 1.0)
				{
				c->x *= msc_wk;
				c->y *= msc_wk;
				c->z *= msc_wk;
				c->tx *= msc_wk;
				c->ty *= msc_wk;
				c->tz *= msc_wk;
				}
			chunk.size-=32L;
			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)
					return(0);
				switch(next.tag)
					{
					case APP_DATA:
						if(get_mchunk(&c->appdata)==0)
							return(0);
						break;
					case CAM_SEE_CONE:
					case CAM_RANGES:
						if(get_mchunk(c)==0)
							return(0);
						break;
					default:
						if(skip_chunk(stream)==0)
							return(0);
						break;
					}
				chunk.size-=next.size;
				}
			}
			break;
		case CAM_SEE_CONE:
			c=(Camera3DS *)data;
			c->flags |= NO_CAM_CONE;
			goto skiprest;
		case CAM_RANGES:
			c=(Camera3DS *)data;
			RDERR(&c->nearplane,sizeof(float));
			RDERR(&c->farplane,sizeof(float));
			c->nearplane *= msc_wk;
			c->farplane *= msc_wk;
			chunk.size-=(sizeof(float)*2);
			goto skiprest;

	/* The following routine is used to dump any sub-chunks	*/
	/* in the current chunk.				*/

			skiprest:
			while(chunk.size)
				{
				if(get_next_chunk(stream,&next)==0)
					return(0);
				if(skip_chunk(stream)==0)
					return(0);
				chunk.size-=next.size;
				}  
			break;
		default:
			assert(0);
			break;
		}
	return(1);
	}


static BOOL CALLBACK
ImportDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
	switch(message) {
		case WM_INITDIALOG:
			SetWindowContextHelpId(hDlg, idh_3dsimp_import);
			CheckRadioButton( hDlg, IDC_3DS_MERGE, IDC_3DS_REPLACE, replaceScene?IDC_3DS_REPLACE:IDC_3DS_MERGE );
			CheckDlgButton( hDlg, IDC_3DS_CONVERT, autoConv );
			CenterWindow(hDlg,GetParent(hDlg));
			SetFocus(hDlg); // For some reason this was necessary.  DS-3/4/96
			return FALSE;
		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDOK: {
	            	replaceScene = IsDlgButtonChecked(hDlg,IDC_3DS_REPLACE);
					autoConv = IsDlgButtonChecked(hDlg, IDC_3DS_CONVERT);
					EndDialog(hDlg, 1);
					}
					return TRUE;
				case IDCANCEL:
					EndDialog(hDlg, 0);
					return TRUE;
			}
		case WM_SYSCOMMAND:
			if ((wParam & 0xfff0) == SC_CONTEXTHELP) {
				Help(HELP_CONTEXT, idh_3dsexp_export);
				return FALSE;
			}
		}
	return FALSE;
	}

int
StudioImport::DoImport(const TCHAR *filename,ImpInterface *i,Interface *gi, BOOL suppressPrompts) {
	// Set a global prompt display switch
	showPrompts = suppressPrompts ? FALSE : TRUE;

	WorkFile theFile(filename,_T("rb"));
	ObjWorker W(i,gi);
	theWorker = &W;

	if(suppressPrompts) {
		}
	else {
		if (!DialogBox(hInstance, MAKEINTRESOURCE(IDD_MERGEORREPL), gi->GetMAXHWnd(), ImportDlgProc))
			return IMPEXP_CANCEL;
		}

	dStream = i->DumpFile();

	if(!(stream = theFile.Stream())) {
		if(showPrompts)
			MessageBox(IDS_TH_ERR_OPENING_FILE, IDS_TH_3DSIMP);
		return IMPEXP_FAIL;						// Didn't open!
		}

	// Find out what kind of file it is...
	unsigned short header;
	if(!(fread(&header,2,1,stream))) {
		if(showPrompts)
			MessageBox(IDS_TH_3DSREADERROR, IDS_TH_3DSIMP);
		return IMPEXP_FAIL;						// No data!
		}
	if(header != MMAGIC && header != M3DMAGIC && header != CMAGIC) {
		if(showPrompts)
			MessageBox(IDS_TH_INVALIDFILE, IDS_TH_3DSIMP);
		return IMPEXP_FAIL;						// Wrong header!
		}
	fseek(stream,0L,SEEK_SET);			// Seek back to the beginning

	BOOL project = (header == CMAGIC) ? TRUE : FALSE;	
	StudioShapeImport shapeImport;
	theShapeImport = &shapeImport;

	// If it's a project file, give 'em shape options
	if(project)
		needShapeImportOptions = TRUE;
	else
		needShapeImportOptions = FALSE;
	shapeImportAbort = FALSE;

	if (replaceScene) {
		if (!i->NewScene())
			return IMPEXP_CANCEL;
		}

	SetCursor(LoadCursor(NULL, IDC_WAIT));
	theImport = this;

	// Init misc items (for now)
	memset(&BG,0,sizeof(BG));
	msc_wk = (float)1.0;
	nodeLoadNumber=-1;
	theWorker->AddMeshMtl(NULL); // Create "Default" mtl
	got_mat_chunk = 0;

	if(!get_mchunk(NULL)) {
		theWorker->Abandon();		// Abandon any pending object construction
		SetCursor(LoadCursor(NULL, IDC_ARROW));
		if(shapeImportAbort)		// If aborted by shape dialog, fake an OK return
			return IMPEXP_CANCEL;
		return IMPEXP_FAIL;
		}
	SetCursor(LoadCursor(NULL, IDC_ARROW));

	// Make sure any objects without nodes are used!
	if(!theWorker->CompleteScene())
		return IMPEXP_FAIL;

	if(!theWorker->SetupEnvironment()) {
		return IMPEXP_FAIL;
		}

	return IMPEXP_SUCCESS;
	}

static int shapeButtons[] = { IDC_SINGLEOBJECT, IDC_MULTIPLEOBJECTS };
#define NUM_SHAPEBUTTONS 2

static void MaybeEnableOptions(HWND hDlg) {
	EnableWindow(GetDlgItem(hDlg, IDC_SINGLEOBJECT), importShapes);
	EnableWindow(GetDlgItem(hDlg, IDC_MULTIPLEOBJECTS), importShapes);
	}

static BOOL CALLBACK
ShapeImportOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
	static StudioShapeImport *imp;

	switch(message) {
		case WM_INITDIALOG:
			imp = (StudioShapeImport *)lParam;
			CheckDlgButton( hDlg, IDC_IMPORT_SHAPES, importShapes);
			CheckDlgButton( hDlg, shapeButtons[imp->importType], TRUE);
			MaybeEnableOptions(hDlg);
			CenterWindow(hDlg,GetParent(hDlg));
			return TRUE;
		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDC_IMPORT_SHAPES:
					if(HIWORD(wParam) == BN_CLICKED) {
						importShapes = IsDlgButtonChecked(hDlg, IDC_IMPORT_SHAPES);
						MaybeEnableOptions(hDlg);
						}
					break;
				case IDOK: {
					// Unload values into StudioShapeImport statics
					for(int i = 0; i < NUM_SHAPEBUTTONS; ++i) {
						if(IsDlgButtonChecked(hDlg, shapeButtons[i])) {
							imp->importType = i;
							break;
							}
						}
					EndDialog(hDlg, 1);
					}
					return TRUE;
				case IDCANCEL:
					EndDialog(hDlg, 0);
					return TRUE;
			}
		}
	return FALSE;
	}

int
StudioShapeImport::DoImport(const TCHAR *filename,ImpInterface *i,Interface *gi, BOOL suppressPrompts) {
	// Set a global prompt display switch
	showPrompts = suppressPrompts ? FALSE : TRUE;

	WorkFile theFile(filename,_T("rb"));
	ObjWorker W(i,gi);
	theWorker = &W;

	if(suppressPrompts) {
		}
	else {
		if (!DialogBox(hInstance, MAKEINTRESOURCE(IDD_MERGEORREPL),  gi->GetMAXHWnd(), ImportDlgProc))
			return IMPEXP_CANCEL;
		}

	dStream = i->DumpFile();

	if(!(stream = theFile.Stream())) {
		if(showPrompts)
			MessageBox(IDS_TH_ERR_OPENING_FILE, IDS_TH_3DSIMP);
		return 0;						// Didn't open!
		}

	// Got the file -- Now put up the options dialog!
	if(suppressPrompts) { // Set default parameters here
		importShapes = TRUE;
		importType = MULTIPLE_SHAPES;
		}
	else {
		int result = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_SHAPEIMPORTOPTIONS), gi->GetMAXHWnd(), ShapeImportOptionsDlgProc, (LPARAM)this);
		if(result <= 0)
			return IMPEXP_CANCEL;
		}

	if (replaceScene) {
		if (!i->NewScene())
			return IMPEXP_CANCEL;
		}

	theShapeImport = this;

	unsigned short header;
	if(!(fread(&header,2,1,stream))) {
		if(showPrompts)
			MessageBox(IDS_TH_3DSREADERROR, IDS_TH_3DSIMP);
		return 0;						// No data!
		}
	if(header != MMAGIC && header != SMAGIC) {
		if(showPrompts)
			MessageBox(IDS_TH_INVALIDFILE, IDS_TH_3DSIMP);
		return 0;						// Wrong header!
		}
	fseek(stream,0L,SEEK_SET);			// Seek back to the beginning
	
	// Init misc items (for now)
	msc_wk = (float)1.0;
	nodeLoadNumber=-1;
	theWorker->AddMeshMtl(NULL); // Create "Default" mtl
	got_mat_chunk = 0;
	
	int res = 0;

	// Load the file contents --
	if(get_mchunk(NULL)) {
		res = 1; 
		}
	else 
		theWorker->Abandon();		// Abandon any pending object construction

	theWorker->FreeUnusedMtls();
	return res;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\3dsexp.cpp ===
/**********************************************************************
 *<
	FILE: 3dsexp.cpp

	DESCRIPTION:  .3DS file export module

	CREATED BY: Tom Hudson

	HISTORY: created 1 December 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "Max.h"
#include "3dseres.h"
#include "3dsexp.h"
#include "istdplug.h"
#include "mtldef.h"
#include "stdmat.h"
#include "decomp.h"
#include "helpsys.h"

// following adjusts for historical artifact
#define VERTICES_FLIP_X

static FILE *wstream;

static BOOL showPrompts;
static BOOL exportSelected;

BOOL operator==(const Matrix3 &m1, const Matrix3 &m2) 
	{
	for (int i=0; i<4; i++) {
		if (m1.GetRow(i) != m2.GetRow(i)) return FALSE;
		}
	return TRUE;
	}

static Point3 colorVal;
static float floatVal;
short Get3DSTVerts(Mesh& mesh, Point2 *tv);

#define EXPORT_MTLS

#pragma pack(1)

struct LocShad2 {
	float bias,shadfilter;
	short shadsize;
	};

struct Camera3DS {
	float x;
	float y;
	float z;
	float tx;
	float ty;
	float tz;
	float bank;
	float focal;
	WORD flags;
	float nearplane;
	float farplane;
	void *appdata;
	};
#pragma pack()

#define PRIMARY_NODE	(1<<14)

#define RDERR(ptr,sz) if (fread((void *)ptr,1,sz,stream)!=(sz)) return(0)
#define WRTERR(ptr,sz) if (fwrite((void *)ptr,1,sz,stream)!=(sz)) return(0)
#define GREAD(ptr,sz) ((fread((void *)ptr,1,sz,stream)!=(sz)) ? 0:1)
#define GWRITE(ptr,sz) ((fwrite((void *)ptr,1,sz,stream)!=(sz)) ? 0:1)

#include <stdarg.h>

#if 0 
void DebugPrint(const TCHAR *format, ...) {
	TCHAR buf[512];
	va_list args;
	va_start(args,format);
	_vsntprintf(buf,512,format,args);
	va_end(args);
	OutputDebugString(buf);
	}
#endif

HINSTANCE hInstance;

TCHAR* GetString(int id)
{
    static TCHAR stBuf[ERROR_MSG_MAX_LEN];
	if (hInstance)
		return LoadString(hInstance, id, stBuf, ERROR_MSG_MAX_LEN) ? stBuf : NULL;
	return NULL;
}


static void MessageBox(int s1, int s2) {
	TSTR str1(GetString(s1));
	TSTR str2(GetString(s2));
	MessageBox(GetActiveWindow(), str1.data(), str2.data(), MB_OK);
	}

static int MessageBox(int s1, int s2, int option = MB_OK) {
	TSTR str1(GetString(s1));
	TSTR str2(GetString(s2));
	return MessageBox(GetActiveWindow(), str1, str2, option);
	}

static int Alert(int s1, int s2 = IDS_TH_3DSEXP, int option = MB_OK) {
	return MessageBox(s1, s2, option);
	}

#define LAYERS_BY_OBJECT 0
#define LAYERS_BY_MATERIAL 1
#define LAYERS_ONE_LAYER 2

#define NUM_SOURCES 3 		// # of sources in dialog

class _3DSExport : public SceneExport {
	friend BOOL CALLBACK ExportOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

public:
					_3DSExport();
					~_3DSExport();
	int				ExtCount();					// Number of extensions supported
    BOOL            MaxUVs;                     // TRUE if generating extra verts for mismatched UV coords
	const TCHAR *	Ext(int n);					// Extension #n (i.e. "3DS")
	const TCHAR *	LongDesc();					// Long ASCII description (i.e. "Autodesk 3D Studio File")
	const TCHAR *	ShortDesc();				// Short ASCII description (i.e. "3D Studio")
	const TCHAR *	AuthorName();				// ASCII Author name
	const TCHAR *	CopyrightMessage();			// ASCII Copyright message
	const TCHAR *	OtherMessage1();			// Other message #1
	const TCHAR *	OtherMessage2();			// Other message #2
	unsigned int	Version();					// Version number * 100 (i.e. v3.01 = 301)
	void			ShowAbout(HWND hWnd);		// Show DLL's "About..." box
	int				DoExport(const TCHAR *name,ExpInterface *ei,Interface *i, BOOL suppressPrompts, DWORD options);	// Export file
	BOOL			SupportsOptions(int ext, DWORD options);
	};

// Statics

// Handy file class

class WorkFile {
private:
	FILE *stream;
	
public:
					WorkFile(const TCHAR *filename,const TCHAR *mode) { stream = NULL; Open(filename, mode); };
					~WorkFile() { Close(); };
	FILE *			Stream() { return stream; };
	int				Close() { int result=0; if(stream) result=fclose(stream); stream = NULL; return result; }
	void			Open(const TCHAR *filename,const TCHAR *mode) { Close(); stream = _tfopen(filename,mode); }
	};

// Handy memory worker

class Memory {
	void *ptr;
public:
					Memory() { ptr = NULL; }
					Memory(int amount, BOOL zero = FALSE) { ptr = NULL; Alloc(amount, zero); }
					~Memory() { Free(); }
	void *			Ptr() { return ptr; }
	void *			Realloc(int amount);
	void *			Alloc(int amount, BOOL zero = FALSE);
	void			Free() { if(ptr) free(ptr); ptr = NULL; }
	};

void *Memory::Realloc(int amount) {
	if(ptr)
		ptr = realloc(ptr, amount);
	else
		ptr = malloc(amount);
	return ptr;
	}

void *Memory::Alloc(int amount, BOOL zero) {
	Free();
	ptr = malloc(amount);
	if(ptr && zero) {
		char *p = (char *)ptr;
		for(int i = 0; i < amount; ++i)
			*p++ = 0;
		}
	return ptr;
	}

// Jaguar interface code

int controlsInit = FALSE;

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();
		}
	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			//MessageBox(NULL,_T("3DSIMP.DLL: DllMain"),_T("3DSIMP"),MB_OK);
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------

class _3DSClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new _3DSExport; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_3DSTUDIO); }
	SClass_ID		SuperClassID() { return SCENE_EXPORT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(0xd1d,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SCENEEXPORT);  }
	};

static _3DSClassDesc _3DSDesc;

//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_TH_3DSEXPORTDLL); }

__declspec( dllexport ) int
LibNumberClasses() { return 1; }

__declspec( dllexport ) ClassDesc *
LibClassDesc(int i) {
	switch(i) {
		case 0: return &_3DSDesc; break;
		default: return 0; break;
		}
	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

//
// ._3DS export module functions follow:
//

_3DSExport::_3DSExport() {
	}

_3DSExport::~_3DSExport() {
	}

int
_3DSExport::ExtCount() {
	return 1;
	}

const TCHAR *
_3DSExport::Ext(int n) {		// Extensions supported for import/export modules
	switch(n) {
		case 0:
			return _T("3DS");
		}
	return _T("");
	}

const TCHAR *
_3DSExport::LongDesc() {			// Long ASCII description (i.e. "Targa 2.0 Image File")
	return GetString(IDS_TH_3DSSCENEFILE);
	}
	
const TCHAR *
_3DSExport::ShortDesc() {			// Short ASCII description (i.e. "Targa")
	return GetString(IDS_TH_3DSFILE);
	}

const TCHAR *
_3DSExport::AuthorName() {			// ASCII Author name
	return GetString(IDS_TH_TOM_HUDSON);
	}

const TCHAR *
_3DSExport::CopyrightMessage() {	// ASCII Copyright message
	return GetString(IDS_TH_COPYRIGHT_YOST_GROUP);
	}

const TCHAR *
_3DSExport::OtherMessage1() {		// Other message #1
	return _T("");
	}

const TCHAR *
_3DSExport::OtherMessage2() {		// Other message #2
	return _T("");
	}

unsigned int
_3DSExport::Version() {				// Version number * 100 (i.e. v3.01 = 301)
	return 200;
	}

void
_3DSExport::ShowAbout(HWND hWnd) {			// Optional
 	}

static BOOL CALLBACK
ExportOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
	static _3DSExport* exp;

	switch(message) {
		case WM_INITDIALOG:
			SetWindowContextHelpId(hDlg, idh_3dsexp_export);
            exp = (_3DSExport*) lParam;
			CenterWindow(hDlg,GetParent(hDlg));
			SetFocus(hDlg); // For some reason this was necessary.  DS-3/4/96
            CheckDlgButton(hDlg, IDC_MAX_UVS, TRUE);
			return FALSE;
		case WM_DESTROY:
			return FALSE;
		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDOK:
                    MaxUVs = IsDlgButtonChecked(hDlg, IDC_MAX_UVS);
					EndDialog(hDlg, 1);
					return TRUE;
				case IDCANCEL:
					EndDialog(hDlg, 0);
					return TRUE;
			}
		case WM_SYSCOMMAND:
			if ((wParam & 0xfff0) == SC_CONTEXTHELP) {
				Help(HELP_CONTEXT, idh_3dsexp_export);
				return FALSE;
			}
		}
	return FALSE;
}

#define OBTYPE_MESH 0
#define OBTYPE_CAMERA 1
#define OBTYPE_OMNILIGHT 2
#define OBTYPE_SPOTLIGHT 3
#define OBTYPE_DUMMY 5
#define OBTYPE_CTARGET 6
#define OBTYPE_LTARGET 7

SceneEntry::SceneEntry(INode *n, Object *o, int t) { 
	node = n; obj = o; type = t; next = NULL; 
	tnode = n->GetTarget();
	}


//- Material Export -------------------------------------------------------------

struct MEntry { SMtl *sm; Mtl *m; };

class MeshMtlList: public Tab<MEntry> {
	public:
	void AddMtl(Mtl *m);
	void ReallyAddMtl(Mtl *m);
	int FindMtl(Mtl *m);
	int FindSName(char *nam);
	~MeshMtlList() {
		for (int i=0; i<Count(); i++) {
			FreeMatRefs((*this)[i].sm);
			delete (*this)[i].sm;
			}
		}
	};

int MeshMtlList::FindMtl(Mtl *m) {
	for (int i=0; i<Count(); i++) 
		if  ( (*this)[i].m == m ) return i;
	return -1;
	}

static int IsStdMulti(Mtl *m) {
	return (m->ClassID()==Class_ID(MULTI_CLASS_ID,0))?1:0; 
	}

int  MeshMtlList::FindSName(char *name) {
	for (int i=0; i<Count(); i++) 
		if  ( strcmp(name,(*this)[i].sm->name)==0) return i;
	return -1;
	}

void MeshMtlList::AddMtl(Mtl *m) {
	if (m==NULL) return;
	Interval v;
	m->Update(0,v);
	if (IsStdMulti(m)) {
		for (int i=0; i<m->NumSubMtls(); i++) {
			Mtl *sub = m->GetSubMtl(i);
			if (sub&&FindMtl(sub)<0) 
				ReallyAddMtl(sub);
			}
		}
	else {
		if (FindMtl(m)<0) 
			ReallyAddMtl(m);
		}
	}

inline Color_24 C24(Color c) {
	Color_24 a;
	a.r = (int)(255.0f*c.r);
	a.g = (int)(255.0f*c.g);
	a.b = (int)(255.0f*c.b);
	return a;
	}

static int MAXMapIndex(int i) {
	switch(i) {
		case Ntex:  return ID_DI;
		case Ntex2: return ID_DI;
		case Nopac: return ID_OP;
		case Nbump: return ID_BU;
		case Nspec: return ID_SP;
		case Nshin: return ID_SH;
		case Nselfi:return ID_SI; 
		case Nrefl: return ID_RL;
		default:    return ID_DI;
		}
	}

int Pcnt(float f) { return (int)(f*100.0f+.5f); }

//gdf convert to 8.3 filename
#define OFFSET(e) ((e < 8 && e != -1) ? e : 8)
static void
EightDotThreeName(CStr& name) {
    CStr fExt;
    CStr fName;
    int  oExt;
    if (name.Length() > 12) {
        oExt = name.last('.');
        fName.Resize(OFFSET(oExt));
        strncpy(fName.data(), name.data(), OFFSET(oExt));
        if (oExt != -1) {
            fExt.Resize(4);
            strncpy(fExt.data(), name.data() + oExt, 4);
        }
        fName.Append(fExt);
	    TCHAR buf[ERROR_MSG_MAX_LEN];
        sprintf(buf, GetString(IDS_EIGHT_DOT_THREE), name.data(), fName.data());
		AddToMsgList(msgList, buf);
        name.Resize(fName.Length() > 12 ? 12 : fName.Length());
        strcpy(name.data(), fName.data());
    }
}
                    

static void ConvertMaxMtlToSMtl(SMtl *s, Mtl *m) {
	Mapping *mp;
	Interval v;
	m->Update(0,v);
	s->amb = C24(m->GetAmbient());
	s->diff = C24(m->GetDiffuse());
	s->spec = C24(m->GetSpecular());
	s->shading = 3;
	s->shininess = Pcnt(m->GetShininess());
	s->shin2pct = Pcnt(m->GetShinStr());
	s->shin3pct = 0;
	s->transparency = Pcnt(m->GetXParency());
	s->wiresize = m->WireSize();
	if (m->ClassID()==Class_ID(DMTL_CLASS_ID,0)) {
		StdMat* std = (StdMat *)m;
		switch(std->GetShading()) {
			case SHADE_CONST: s->shading = 1; break;
			case SHADE_PHONG: s->shading = 3; break;
			case SHADE_METAL: s->shading = 4; break;
			}	
		s->xpfall = Pcnt(std->GetOpacFalloff(0));		
		s->selfipct = Pcnt(std->GetSelfIllum(0));		
		if (std->GetTwoSided()) s->flags |= MF_TWOSIDE;
		if (std->GetWire()) s->flags |= MF_WIRE;
		if (!std->GetFalloffOut()) s->flags |= MF_XPFALLIN;
		if (std->GetFaceMap()) s->flags |= MF_FACEMAP;
		if (std->GetSoften()) s->flags |= MF_PHONGSOFT;
		if (std->GetWireUnits()) s->flags |= MF_WIREABS;
		switch (std->GetTransparencyType()) {
			case TRANSP_FILTER:
			case TRANSP_SUBTRACTIVE: break;
			case TRANSP_ADDITIVE: s->flags |= MF_ADDITIVE;
			}

		for (int i=0; i<8; i++) {
			if (i==Ntex2) continue;
			int n = MAXMapIndex(i);
			Texmap *tx;
			if ((tx=std->GetSubTexmap(n))==NULL) 
				continue;
			if (i==Nrefl) {
				if (tx->ClassID()==Class_ID(ACUBIC_CLASS_ID,0)) {
					StdCubic *stdcub = (StdCubic*)tx;
					s->map[i] = mp = NewMapping(i,0);
					mp->amt.pct = Pcnt(std->GetTexmapAmt(n,0));			
					mp->use = std->MapEnabled(n);
					AutoCubicParams &ac = mp->map.p.ref.acb;
					ac.flags=AC_ON;
					if (!stdcub->GetDoNth()) ac.flags |= AC_FIRSTONLY;
					ac.nth = stdcub->GetNth();
					ac.size = stdcub->GetSize(0);
					continue;
					}
				else 
				if (tx->ClassID()==Class_ID(MIRROR_CLASS_ID,0)) {
					StdMirror *stdmir = (StdMirror*)tx;
					s->map[i] = mp = NewMapping(i,0);
					mp->amt.pct = Pcnt(std->GetTexmapAmt(n,0));			
					mp->use = std->MapEnabled(n);
					AutoCubicParams &ac = mp->map.p.ref.acb;
					if (!stdmir->GetDoNth()) ac.flags |= AC_FIRSTONLY;
					ac.nth = stdmir->GetNth();
					ac.flags= AC_MIRROR|AC_ON;
					continue;
					}
				}
			// just do bitmap textures for now
			if (tx->ClassID()!=Class_ID(BMTEX_CLASS_ID,0))
				continue;					
			BitmapTex *bmt = (BitmapTex*)tx;
			s->map[i] = mp = NewMapping(i,0);
			mp->amt.pct = Pcnt(std->GetTexmapAmt(n,0));			
			if (i==Nbump) 
				mp->amt.pct = abs(mp->amt.pct)/100;
			mp->use = std->MapEnabled(n);
			TSTR filename;
			SplitPathFile(TSTR(bmt->GetMapName()),NULL,&filename);
			CStr name(filename);
            
         // gdf convert bitmap filename to 8.3
            EightDotThreeName(name);

         // gdf convert to Uppercase
            name.toUpper();

			strncpy(mp->map.name,name.data(),12);
			if (i==Nrefl) {

				}
			else {
				StdUVGen *uv = bmt->GetUVGen();
				MapParams &par = mp->map.p.tex;
				par.type = MAP_TYPE_UV;
				par.uoffset = uv->GetUOffs(0); 
				par.voffset = -uv->GetVOffs(0); 
				par.uscale = uv->GetUScl(0); 
				par.vscale = uv->GetVScl(0); 
				float ang = uv->GetAng(0);
				par.ang_sin = -(float)sin(ang);
				par.ang_cos = (float)cos(ang);
				par.texblur	 = uv->GetBlur(0)-1.0f;
				int tile = uv->GetTextureTiling();
				if (tile&(U_MIRROR|V_MIRROR))
					par.texflags|= TEX_MIRROR;
				if (tile&(U_WRAP|V_WRAP))
					par.texflags &= ~TEX_NOWRAP;
				else
					par.texflags |= TEX_NOWRAP;
				TextureOutput* texout = bmt->GetTexout();
				if (texout->GetInvert()) 
					par.texflags |= TEX_INVERT;
				if (bmt->GetFilterType()==FILTER_SAT)
					par.texflags |= TEX_SAT;
				}
			}
		}

	}

static void IncrName(char *name, char *inm, int n) {
	char buf[20];
	strncpy(buf,name,13);
	buf[13] = 0;
	sprintf(inm,"%s%d\0",buf,n);
	}

void MeshMtlList::ReallyAddMtl(Mtl *m) {
	MEntry me;
	me.sm = NULL;
	me.m = m;
	SMtl *s = new SMtl;
	memset(s,0,sizeof(SMtl));
	me.sm = s;
	char buf[20];
	strncpy(buf,me.m->GetName(),16);
	if (strlen(buf)==0) strcpy(buf, "Matl");
	buf[16] = 0;
	strcpy(s->name,buf);
	int n=0;
	while (FindSName(s->name)>=0) 
		IncrName(buf,s->name,++n); 
	buf[16] = 0;
	ConvertMaxMtlToSMtl(s,m);
	Append(1,&me,20);
	}								

//--------------------------------------------------------------

class SceneEnumProc : public ITreeEnumProc {
	public:
		Interface	*i;
		SceneEntry *head;
		SceneEntry *tail;
		IScene		*theScene;
		int			count;
		MeshMtlList *mtlList;
		TimeValue	time;
					SceneEnumProc(IScene *scene, TimeValue t, Interface *i, MeshMtlList *ml);
					~SceneEnumProc();
		int			Count() { return count; }
		void		Append(INode *node, Object *obj, int type);
		int			callback( INode *node );
		Box3		Bound();
		SceneEntry *Find(INode *node);
//		SceneEntry *operator[](int index);
		void BuildNames();
	};

SceneEnumProc::SceneEnumProc(IScene *scene, TimeValue t, Interface *i, MeshMtlList *ml) {
	time = t;
	theScene = scene;
	count = 0;
	head = tail = NULL;
	this->i = i;
	mtlList = ml;
	theScene->EnumTree(this);
	}

SceneEnumProc::~SceneEnumProc() {
	while(head) {
		SceneEntry *next = head->next;
		delete head;
		head = next;
		}
	head = tail = NULL;
	count = 0;	
	}

int SceneEnumProc::callback(INode *node) {
	if(exportSelected && node->Selected() == FALSE)
		return TREE_CONTINUE;
	Object *obj = node->EvalWorldState(time).obj;
	if (obj->CanConvertToType(triObjectClassID)) {
		Append(node, obj, OBTYPE_MESH);
		mtlList->AddMtl(node->GetMtl());
		return TREE_CONTINUE;
		}
	if (node->IsTarget()) {
		INode* ln = node->GetLookatNode();
		if (ln) {
			Object *lobj = ln->EvalWorldState(time).obj;
			switch(lobj->SuperClassID()) {
				case LIGHT_CLASS_ID:  Append(node, obj, OBTYPE_LTARGET); break;
				case CAMERA_CLASS_ID: Append(node, obj, OBTYPE_CTARGET); break;
				}
			}
		return TREE_CONTINUE;
		}
	switch (obj->SuperClassID()) { 
		case HELPER_CLASS_ID:
			if ( obj->ClassID()==Class_ID(DUMMY_CLASS_ID,0)) 
				Append(node, obj, OBTYPE_DUMMY);
			break;
		case LIGHT_CLASS_ID: {
            TCHAR buf[ERROR_MSG_MAX_LEN];
			if (obj->ClassID()==Class_ID(OMNI_LIGHT_CLASS_ID,0))
				Append(node, obj, OBTYPE_OMNILIGHT);
			if (obj->ClassID()==Class_ID(SPOT_LIGHT_CLASS_ID,0)) 
				Append(node, obj, OBTYPE_SPOTLIGHT);
            if (obj->ClassID()==Class_ID(DIR_LIGHT_CLASS_ID,0)) {
                sprintf(buf, GetString(IDS_DIR_LIGHT), node->GetName());
		        AddToMsgList(msgList, buf);
				//Append(node, obj, OBTYPE_SPOTLIGHT);
            }
            if (obj->ClassID()==Class_ID(FSPOT_LIGHT_CLASS_ID,0)) {
                sprintf(buf, GetString(IDS_FSPOT_LIGHT), node->GetName());
		        AddToMsgList(msgList, buf);
				//Append(node, obj, OBTYPE_SPOTLIGHT);
            }
            break;
        }
		case CAMERA_CLASS_ID:
			if (obj->ClassID()==Class_ID(LOOKAT_CAM_CLASS_ID,0))
				Append(node, obj, OBTYPE_CAMERA);
			break;
		}
	return TREE_CONTINUE;	// Keep on enumeratin'!
	}


void SceneEnumProc::Append(INode *node, Object *obj, int type) {
	SceneEntry *entry = new SceneEntry(node, obj, type);

	if(tail)
		tail->next = entry;
	tail = entry;
	if(!head)
		head = entry;
	count++;	
	}

Box3 SceneEnumProc::Bound() {
	Box3 bound;
	bound.Init();
	SceneEntry *e = head;
	ViewExp *vpt = i->GetViewport(NULL);
	while(e) {
		Box3 bb;
		e->obj->GetWorldBoundBox(time, e->node, vpt, bb);
		bound += bb;
		e = e->next;
		}
	return bound;
	}

SceneEntry *SceneEnumProc::Find(INode *node) {
	SceneEntry *e = head;
	while(e) {
		if(e->node == node)
			return e;
		e = e->next;
		}
	return NULL;
	}



SceneEnumProc *theSceneEnum = NULL;
MeshMtlList *theMtls = NULL;

class ObjectList {
	public:
		ObjectEntry *head;
		ObjectEntry *tail;
		int			count;
					ObjectList(SceneEnumProc &scene);
					~ObjectList();
		int			Count() { return count; }
		void		Append(SceneEntry *e);
		ObjectEntry *Contains(Object *obj);
		ObjectEntry *Contains(INode *node);
		ObjectEntry *FindLookatNode(INode *node);
	};

ObjectList::ObjectList(SceneEnumProc &scene) {
	head = tail = NULL;
	count = 0;
	// Zip thru the object list and record all unique objects (Some may be used by more than one node)
	int scount = scene.Count();
	for(SceneEntry *se = scene.head; se!=NULL; se = se->next) {
		// can't multiple instance lights and cameras in 3DS  
		// so make them all unique--DS 4/6/96
		if ( (se->type!=OBTYPE_MESH)|| !Contains(se->obj))
			Append(se);
		}
	}

ObjectList::~ObjectList() {
	while(head) {
		ObjectEntry *next = head->next;
		delete head;
		head = next;
		}
	head = tail = NULL;
	count = 0;	
	}

ObjectEntry *ObjectList::Contains(Object *obj) {
	ObjectEntry *e;
	for (e=head; e!=NULL; e = e->next) {
		if(e->entry->obj == obj)
			return e;
		}
	return NULL;
	}

class FindDepNodeEnum: public DependentEnumProc {
	public:
		ReferenceTarget *targ;
		INode *depNode;
		FindDepNodeEnum() { targ = NULL; depNode = NULL; }
		// proc should return 1 when it wants enumeration to halt.
		virtual	int proc(ReferenceMaker *rmaker);
	};

int FindDepNodeEnum::proc(ReferenceMaker *rmaker) {
	if (rmaker->SuperClassID()!=BASENODE_CLASS_ID) return 0;
	INode* node = (INode *)rmaker;
	if (node->GetTarget()==targ) {
		depNode = node;
		return 1;
		}
	return 0;
	}
	
ObjectEntry *ObjectList::FindLookatNode(INode *node) {
	FindDepNodeEnum	 finder;
	ObjectEntry *e;
	for (e=head; e!=NULL; e = e->next) {
		finder.targ = node;
		e->entry->node->EnumDependents(&finder);
		if (finder.depNode) return e;
		}
	return NULL;
	}


ObjectEntry *ObjectList::Contains(INode *node) {
	ObjectEntry *e;
	for (e=head; e!=NULL; e = e->next) {
		if(e->entry->node == node)
			return e;
		}
	return NULL;
	}

void ObjectList::Append(SceneEntry *e) {
	ObjectEntry *entry = new ObjectEntry(e);
	if(tail)
		tail->next = entry;
	tail = entry;
	if(!head)
		head = entry;
	count++;	
	}

ObjectList *theObjects = NULL;

class ObjName {
	public:
		TSTR name;
		ObjName *next;
		ObjName(TSTR n) { name = n; next = NULL; }
	};

class ObjNameList {
	public:
		ObjName *head;
		ObjName *tail;
		int			count;
					ObjNameList() { head = tail = NULL; count = 0; }
					~ObjNameList();
		int			Count() { return count; }
		int			Contains(TSTR &n);
		void		Append(TSTR &n);
		void		MakeUnique(TSTR &n);
	};

ObjNameList::~ObjNameList() {
	while(head) {
		ObjName *next = head->next;
		delete head;
		head = next;
		}
	head = tail = NULL;
	count = 0;	
	}

int ObjNameList::Contains(TSTR &n) {
	ObjName *e = head;
	int index = 0;
	while(e) {
		if(e->name == n)
			return index;
		e = e->next;
		index++;
		}
	return -1;
	}

void ObjNameList::Append(TSTR &n) {
	ObjName *entry = new ObjName(n);
	if(tail)
		tail->next = entry;
	tail = entry;
	if(!head)
		head = entry;
	count++;	
	}

void ObjNameList::MakeUnique(TSTR &n) {
	// First make it less than 10 chars.
	if (n.Length()>10) n.Resize(10);
	
	if(Contains(n) < 0) {
		Append(n);
		return;
		}
	// Make it unique and keep it 10 chars or less
	for(int i = 0; i < 100000; ++i) {
		char buf[12];
		sprintf(buf,"%d",i);
		TSTR num(buf);
		TSTR work = n;
		int totlen = num.Length() + work.Length();
		if(totlen > 10)
			work.Resize(10 - (totlen - 10));
		work = work + num;
		if(Contains(work) < 0) {
			Append(work);
			n = work;
			return;
			}
		}
	// Forget it!
	}

ObjNameList theObjNames;
Tab<int> mtlNumMap;
int mtlnum;
BOOL multiMtl;


// RB:
// Here's what I've done to handle names. After the scene has been
// traversed but before it is actually written to disk, I make
// a unique <10 character name for evey node name. This name is
// then used in place of the node name.
void SceneEnumProc::BuildNames()
	{
	ObjNameList nameList;
	SceneEntry *ptr = head;

	while (ptr) {
//		if (ptr->node->IsTarget()) {
//			ptr->name = _T("");
//			}
//		else {
			ptr->name = ptr->node->GetName();
			nameList.MakeUnique(ptr->name);		
//			}
		ptr = ptr->next;
		}
	}



typedef struct {
	Matrix3 *tm;
	Mesh *mesh;
	INode *node;
	} MeshAndTMAndNode;

static short wrapFlags;

/* Main routine for writing a mesh file!		*/
/* Recursive chunk writer -- keeps track of each chunk	*/
int
dump_mchunk(USHORT tag,FILE *stream,void *data) {
	USHORT count,temp;
	int ox,ix;
	int *intptr;
	long chunkptr,chunkbase,curpos,chunksize,lval;
	SceneEntry *se = (SceneEntry *)data;
	Interval valid;
	Color_f *cf;
	ObjectEntry *oe;
	INode *node;
	Object *obj;
	Mesh *m;

//	DebugPrint(_T("dump_mchunk: tag = %X\n"),tag); 

	chunkbase=ftell(stream);
	WRTERR(&tag,2);
	chunkptr=ftell(stream);		/* Save file ptr for chunk size */
	WRTERR(&chunkptr,4);
	switch(tag)
		{
		case MMAGIC:	/* Mesh editor */
			if(dump_mchunk(MESH_VERSION,stream,NULL)==0)
				return(0);

#ifdef EXPORT_MTLS
			// Save out the Materials...
            for (ix=0; ix<(*theMtls).Count(); ix++)  {
                if (ix == 256) {
                    TCHAR buf[ERROR_MSG_MAX_LEN];
                    sprintf(buf, GetString(IDS_MATERIAL_LIMIT));
		            AddToMsgList(msgList, buf);
                    (*theMtls).SetCount(256);
                    break;
                }
				savemtl= (*theMtls)[ix].sm;
				if(dump_mtlchunk(MAT_ENTRY,stream,NULL)==0)
					return 0;
			}
#endif
			if(dump_mchunk(MASTER_SCALE,stream,NULL)==0)
				return(0);

//			if(dump_mchunk(O_CONSTS,stream,&const_x)==0)
//				return(0);
//			if(dump_mchunk(AMBIENT_LIGHT,stream,NULL)==0)
//				return(0);
//			if(dump_mchunk(DISTANCE_CUE,stream,NULL)==0)
//				return(0);
//			if(ENVFLAG==FOG) {
//				if(dump_mchunk(USE_FOG,stream,NULL)==0)
//				return(0);
//				}
//			else
//			if(ENVFLAG==DISTANCE_CUE) {
//				if(dump_mchunk(USE_DISTANCE_CUE,stream,NULL)==0)
//					return(0);
//				}
//			else
//			if(ENVFLAG==LAYER_FOG) {
//				if(dump_mchunk(USE_LAYER_FOG,stream,NULL)==0)
//					return(0);
//				}
//			if(default_view!=CAMERA && default_view!=SPOTLIGHT) {
//				if(dump_mchunk(DEFAULT_VIEW,stream,NULL)==0)
//					return(0);
//				}
			for (ox = 0,oe = theObjects->head; oe != NULL; oe = oe->next,ox++) {
				int type = oe->entry->type;
				if (type!=OBTYPE_DUMMY&&type!=OBTYPE_LTARGET&&type!=OBTYPE_CTARGET) {
					if (type==OBTYPE_MESH) {
						obj = oe->entry->obj;
						oe->tri = (TriObject *)obj->ConvertToType(theSceneEnum->i->GetTime(), triObjectClassID);
						Mesh &mesh = oe->tri->GetMesh();
                        if (mesh.numFaces > 65530) {
							TCHAR buf[ERROR_MSG_MAX_LEN];
                            sprintf(buf, GetString(IDS_OBJ_TOO_MANY_FACES), oe->entry->name);
							AddToMsgList(msgList, buf);
							continue;
						}
						if (mesh.numVerts > 65530) {
							TCHAR buf[ERROR_MSG_MAX_LEN];
                            sprintf(buf,GetString(IDS_OBJ_TOO_MANY_VERTS), oe->entry->name);
							AddToMsgList(msgList, buf);
							continue;
						}
                    }
					int status = dump_mchunk(NAMED_OBJECT,stream,oe);
					if (!status) return 0;
				}
			}
//			if (MSHappdata!=NULL) 
//				if(dump_mchunk(APP_DATA,stream,MSHappdata)==0)
//					return(0);
			break;
		case MESH_VERSION:
			lval=0x00000003; /* Current version Number */
			WRTERR(&lval,4);
			break;
		case LIN_COLOR_F:
		case COLOR_F:
			cf=(Color_f *)data;
			WRTERR(cf,12);
			break;
		case MASTER_SCALE: {
			int type;
			float scale;
			GetMasterUnitInfo(&type, &scale);
			float msc_factor = (float)GetMasterScale(type);
			WRTERR(&msc_factor,sizeof(float));
			}
			break;
//		case SOLID_BGND:
//			if (P.gamma_correct) {
//				Color gamcol;
//				disp_gammify(&gamcol, &BG.bkgd_solid);
//				if(dump_mchunk(COLOR_F,stream,&gamcol)==0) return(0);
//				if(dump_mchunk(LIN_COLOR_F,stream,&BG.bkgd_solid)==0) return(0);
//				}
//	  		else 
//			if(dump_mchunk(COLOR_F,stream,&BG.bkgd_solid)==0) return(0);
//	 		break;
		case RAY_BIAS:	/* Simple floats */
		case LO_SHADOW_BIAS:	/* Simple floats */
		case SHADOW_FILTER:
		case DL_OUTER_RANGE:
		case DL_INNER_RANGE:
		case DL_MULTIPLIER:
			WRTERR(data,sizeof(float));
			break;
	 	case SHADOW_SAMPLES:	/* Simple ints, written as shorts */
	 	case SHADOW_RANGE:
	 	case SHADOW_MAP_SIZE:
			intptr=(int *)data;
			temp=(USHORT) *intptr;
			WRTERR(&temp,2);
			break;
//		case BIT_MAP:
//			string=(char *)data;
//			split_fn(NULL,gp_buffer,string);
//			WRTERR(gp_buffer,strlen(gp_buffer)+1);
//			break;

		/* Simple strings */

//		case DL_EXCLUDE:
//		case VIEW_CAMERA:
//			string=(char *)data;
//			WRTERR(string,strlen(string)+1);
//			break;
//		case O_CONSTS:
//			WRTERR(data,sizeof(float)*3);
//			break;
//		case AMBIENT_LIGHT:
//			unload_ambient_light(0);
//			if(dump_mchunk(COLOR_F,stream,&BG.amb_light)==0)
//				return(0);
//			break;
		case NAMED_OBJECT: {
			oe=(ObjectEntry *)data;
			node = oe->entry->node;			
			//CStr name(node->GetName());
			CStr name(oe->entry->name); // RB
			if(name.Length()>10)
				name.Resize(10);
			WRTERR(name.data(),(size_t)(name.Length()+1));
			switch(oe->entry->type) {
				case OBTYPE_MESH:
					if(dump_mchunk(N_TRI_OBJECT,stream,oe)==0)
						return(0);
					break;
				case OBTYPE_CAMERA:
					if(dump_mchunk(N_CAMERA,stream,oe)==0)
						return(0);
					break;
				case OBTYPE_OMNILIGHT:
					if(dump_mchunk(N_DIRECT_LIGHT,stream,oe)==0)
						return(0);
					break;
				case OBTYPE_SPOTLIGHT:
					if(dump_mchunk(N_DIRECT_LIGHT,stream,oe)==0)
						return(0);
					break;
				default:
					assert(0);
					break;
				}
//			if(n->flags & NO_HIDDEN) {
//				if(dump_mchunk(OBJ_HIDDEN,stream,n)==0)
//					return(0);
//				}     
//			if(n->flags & NO_DOESNT_CAST) {
//				if(dump_mchunk(OBJ_DOESNT_CAST,stream,n)==0)
//					return(0);
//				}     
//	 		if(n->flags & NO_MATTE) {
//				if(dump_mchunk(OBJ_MATTE,stream,n)==0)
//					return(0);
//				}     
//			if(n->flags & NO_DONT_RCVSHADOW) {
//				if(dump_mchunk(OBJ_DONT_RCVSHADOW,stream,n)==0)
//					return(0);
//				}     
//			if(n->flags & NO_FAST) {
//				if(dump_mchunk(OBJ_FAST,stream,n)==0)
//					return(0);
//				}
//			if(n->flags & NO_FROZEN) {
//				if(dump_mchunk(OBJ_FROZEN,stream,n)==0)
//					return(0);
//				}
			}
			break;
		case OBJ_HIDDEN:	/* Special null chunk */
//		case OBJ_VIS_LOFTER:	/* Special null chunk */
		case OBJ_DOESNT_CAST:	/* Special null chunk */
		case OBJ_DONT_RCVSHADOW: /* Special null chunk */
		case OBJ_MATTE:	/* Special null chunk */
//		case OBJ_PROCEDURAL:	/* Special null chunk */
		case OBJ_FAST:		/* Special null chunk */
		case OBJ_FROZEN:		/* Special null chunk */
			break;
		case APP_DATA: {
			ULONG *plong = (ULONG *)data;
			WRTERR(&plong[1],plong[0]);
			}
	  		break;
		case N_TRI_OBJECT: {
			oe = (ObjectEntry *)data;
			node = oe->entry->node;
			Matrix3 ident(TRUE);
            Matrix3 mat = node->GetNodeTM(theSceneEnum->time);
            
			// RB: For some reason this fixes a problem where
			// the pivot gets screwed up if the object is at 
			// the origin. ???!!!			
			Point3 pos = mat.GetRow(3);
			if (pos.x==0.0f && pos.y==0.0f && pos.z==0.0f) {
				pos.x = 0.001f;
				pos.y = 0.001f;
				pos.z = 0.001f;
				mat.SetTrans(pos);
				}
			
			obj = oe->entry->obj;
			Mesh &mesh = oe->tri->GetMesh();
			MeshAndTMAndNode mt;
			mt.tm = &mat;
			mt.mesh = &mesh;
			mt.node = node;

			// RB 6/11/96: This is kindof a hack, but if the node has
			// WSMs applied then it will already be transformed into
			// world space and so it doesn't need to be transformed again.
			if (node->GetProperty(PROPID_HAS_WSM)) {
				mt.tm = &ident;
				}

         //	if( (t->flags & TRI_HAS_PROCDATA) && t->proc_data!=NULL) {
         //     if(dump_mchunk(PROC_DATA,stream,t)==0)
         //		    return(0);
         //	}
         //	if(strlen(t->proc_name)>0) {
         //	    if(dump_mchunk(PROC_NAME,stream,t)==0)
         //		    return(0);
         //	}



         // gdf hack for people who want the additional texture coord data
            if (MaxUVs && (mesh.numTVerts > 0)) {
                Tab<Vert3ds> verts;
                Tab<Face3ds> faces;
                long    cPtr;
                long    cBegin;
                unsigned short cTag;
                Point3  pt;
                UWORD   cnt;

                ConvertTo3DSFaces(oe, verts, faces);

                if(mesh.getNumVerts()) {
					float xxform = 1.0f;
#ifdef VERTICES_FLIP_X
					Point3 cp = CrossProd(mat.GetRow(0),mat.GetRow(1));
					if (DotProd(cp,mat.GetRow(2))<0)
						xxform = -1.0f;
#endif			
                    cTag = POINT_ARRAY;
                    WriteChunkBegin(cTag, cPtr, cBegin);
                    cnt  = (UWORD) verts.Count();
                    fwrite(&cnt, 1, sizeof(UWORD), wstream);
                    for (int i = 0; i < cnt; i++) {
                        pt = verts[i].pt;
						pt[0] *= xxform;
						pt = pt * mat;
                        fwrite(&pt, sizeof(float), 3, wstream);
                    }
                    WriteChunkEnd(cPtr, cBegin);

                    if (mesh.numTVerts > 0 && mesh.tvFace && mesh.tVerts) {
                        cTag = TEX_VERTS;
                        WriteChunkBegin(cTag, cPtr, cBegin);
                        fwrite(&cnt, 1, sizeof(UWORD), wstream);
                        for (int i = 0; i < cnt; i++) {
                            fwrite(&verts[i].tv.x, sizeof(float), 1, wstream);
                            fwrite(&verts[i].tv.y, sizeof(float), 1, wstream);
                        }
                        WriteChunkEnd(cPtr, cBegin);
					}

                    cTag = MESH_MATRIX;
                    WriteChunkBegin(cTag, cPtr, cBegin);
                    fwrite(mat.GetAddr(), sizeof(float), 12, wstream);
                    WriteChunkEnd(cPtr, cBegin);
				}

                if(mesh.getNumFaces()) {
                    BOOL smoothed = FALSE;
                    cnt = mesh.getNumFaces();
                    cTag = FACE_ARRAY;
                    WriteChunkBegin(cTag, cPtr, cBegin);
                    cnt  = (UWORD) faces.Count();
                    fwrite(&cnt, sizeof(UWORD), 1, wstream);
                    for (int i = 0; i < cnt; i++) {
                        Face face = mesh.faces[i];
                        if (face.smGroup)
                            smoothed = TRUE;
                        fwrite(&faces[i].vNum[0], sizeof(UWORD), 1, wstream);
                        fwrite(&faces[i].vNum[1], sizeof(UWORD), 1, wstream);
                        fwrite(&faces[i].vNum[2], sizeof(UWORD), 1, wstream);
						UWORD wrtFlags = 0;
						if(faces[i].flags & EDGE_A) wrtFlags |= ABLINE;
						if(faces[i].flags & EDGE_B) wrtFlags |= BCLINE;
						if(faces[i].flags & EDGE_C) wrtFlags |= CALINE;
                        fwrite(&wrtFlags, sizeof(UWORD), 1, wstream);
                    }
                    Mtl* mtl;
			        if ((mtl = mt.node->GetMtl()) != NULL) {
				        if (IsStdMulti(mtl)) {
					        multiMtl = TRUE;
                    		mtlNumMap.SetCount(mtl->NumSubMtls());
					        for (int i = 0; i < mtl->NumSubMtls(); i++) {
						        Mtl* sub  = mtl->GetSubMtl(i);
						        if (sub)
                                    mtlNumMap[i] = theMtls->FindMtl(sub);
						        else
                                    mtlNumMap[i] = 0;
						    }
					        for (i = 0; i < mtl->NumSubMtls(); i++) {
						        Mtl* sub  = mtl->GetSubMtl(i);
						        if (sub) {
							        mtlnum = mtlNumMap[i];
							        if (!dump_mchunk(MSH_MAT_GROUP, stream, &mt))
								        return 0;
							    }
						    }
					    } else {
					        mtlnum = theMtls->FindMtl(mtl);
					        multiMtl = FALSE;
					        if (!dump_mchunk(MSH_MAT_GROUP, stream, &mt))
						    return 0;
					    }
				    }

					if(smoothed) {
			        	if(!dump_mchunk(SMOOTH_GROUP, stream, &mesh))
					        return 0;
				    }
                    WriteChunkEnd(cPtr, cBegin);
				}
            } else {
			    if(mesh.getNumVerts()) {
				    if(dump_mchunk(POINT_ARRAY,stream,&mt)==0) {
					    error:
					 // Delete the working object, if necessary
					    if(obj != (Object *)(oe->tri)) {
						    oe->tri->DeleteThis();
						    oe->tri = NULL;
					    }
    					return(0);
					}
	    			if (mesh.numTVerts>0 && mesh.tvFace && mesh.tVerts) {
		    			if(dump_mchunk(TEX_VERTS,stream, oe)==0)
			    			goto error;
                     // if(dump_mchunk(MESH_TEXTURE_INFO,stream,t)==0)
                     //     goto error;
					}
                 // if(dump_mchunk(POINT_FLAG_ARRAY,stream,t)==0)
                 //     return(0);
												
				    if(dump_mchunk(MESH_MATRIX,stream,mat.GetAddr())==0)
    					goto error;
                 // if(dump_mchunk(MESH_COLOR,stream,t)==0)
                 //     return(0);
				}
	    		if(mesh.getNumFaces()) {
                 // objNamePtr = oe->entry->name;
			    	if(dump_mchunk(FACE_ARRAY,stream,&mt)==0)
				    	goto error;
				}
             // if(t->appdata!=NULL) {
             //     if(dump_mchunk(APP_DATA,stream,t->appdata)==0)
             //         return(0);
             //	}     
            }

         // Delete the working object, if necessary
			if(obj != (Object *)(oe->tri)) {
				oe->tri->DeleteThis();
				oe->tri = NULL;
				}
			}
			break;

		case POINT_ARRAY: {
            MeshAndTMAndNode *mt = (MeshAndTMAndNode *)data;
			count=mt->mesh->getNumVerts();
			WRTERR(&count,2);

			float xxform = 1.0f;
#ifdef VERTICES_FLIP_X
			Point3 cp = CrossProd(mt->tm->GetRow(0),mt->tm->GetRow(1));
			if (DotProd(cp,mt->tm->GetRow(2))<0)
				xxform = -1.0f;
#endif			
			for(ix=0; ix<count; ++ix) {
				Point3 v = mt->mesh->verts[ix];
				v[0] *= xxform;
				v = v * *mt->tm;
                WRTERR(&v[0],sizeof(float));
				WRTERR(&v[1],sizeof(float));
				WRTERR(&v[2],sizeof(float));
				}
			}
			break;

		case TEX_VERTS: {
            Tab<UVVert> tverts;
			oe = (ObjectEntry *) data;
			Mesh &mesh = oe->tri->GetMesh();
			int nverts = mesh.getNumVerts();
			if (nverts>65535) nverts = 65535;
         // gdf 
            UWORD nv = (UWORD) nverts;
            WRTERR(&nv,2);
            ConvertTo3DSTVerts(oe, tverts);
            for (int i = 0; i < tverts.Count(); i++) {
                UVVert pt = tverts[i];
                WRTERR(&pt,sizeof(float)*2);
            }

            /*
			Point2 *tv = new Point2[nverts];
			wrapFlags = Get3DSTVerts(mesh,tv);
			UWORD nv = (UWORD)nverts;
			WRTERR(&nv,2);
			for(ix=0; ix<nv; ++ix) {
				WRTERR(&tv[ix],sizeof(float)*2);
				}
			delete [] tv;
            */
			}
			break;

//		case MESH_TEXTURE_INFO:
//			t=(Tri_obj *)data;
//			Mapinfo.maptype=t->maptype;
//			Mapinfo.tile_x=t->tile_x;
//			Mapinfo.tile_y=t->tile_y;
//			Mapinfo.map_x=t->map_x;
//			Mapinfo.map_y=t->map_y;
//			Mapinfo.map_z=t->map_z;
//			Mapinfo.map_scale=t->map_scale;
//			memcpy(Mapinfo.map_matrix,t->map_matrix,sizeof(float)*12);
//			Mapinfo.map_pw=t->map_pw;
//			Mapinfo.map_ph=t->map_ph;
//			Mapinfo.map_ch=t->map_ch;
//			WRTERR(&Mapinfo,sizeof(Mapinfo));
//			break;
//		case POINT_FLAG_ARRAY:
//			t=(Tri_obj *)data;
//			count=t->verts;
//			WRTERR(&count,2);
//			for(ix=0; ix<t->verts; ++ix) {
//				get_vert(t,ix,&v);
//				WRTERR(&v.flags,sizeof(short));
//				}
//			break;
		case MESH_MATRIX:
			WRTERR(data,sizeof(float)*12);
			break;
//		case MESH_COLOR:
//			t=(Tri_obj *)data;
//			WRTERR(&t->color,sizeof(uchar));
//			break;
		case FACE_ARRAY: {
			MeshAndTMAndNode *mt = (MeshAndTMAndNode*)data;
			m = mt->mesh;
			count=m->getNumFaces();
			WRTERR(&count,2);
			BOOL anySmooth = FALSE;
			for(ix=0; ix<count; ++ix) {
				Face f = m->faces[ix];
				if(f.smGroup)
					anySmooth = TRUE;
				Fc_wrt.a=(unsigned short)f.v[0];
				Fc_wrt.b=(unsigned short)f.v[1];
				Fc_wrt.c=(unsigned short)f.v[2];
				Fc_wrt.flags = wrapFlags;	 // TEX_VERTS
				if(f.flags & EDGE_A) Fc_wrt.flags |= ABLINE;
				if(f.flags & EDGE_B) Fc_wrt.flags |= BCLINE;
				if(f.flags & EDGE_C) Fc_wrt.flags |= CALINE;
				WRTERR(&Fc_wrt,8);
				}
#ifdef EXPORT_MTLS
			Mtl *mtl;
			if (NULL!=(mtl=mt->node->GetMtl())) {
				if (IsStdMulti(mtl)) {
					multiMtl = TRUE;
				 // make a table that maps sub-mtl number to the proper index
				 // into theMtls.
					mtlNumMap.SetCount(mtl->NumSubMtls());
					for (int i=0; i<mtl->NumSubMtls(); i++) {
						Mtl *sub  = mtl->GetSubMtl(i);
						if (sub) mtlNumMap[i] = theMtls->FindMtl(sub);
						else mtlNumMap[i] = 0;
						}
					for (i=0; i<mtl->NumSubMtls(); i++) {
						Mtl *sub  = mtl->GetSubMtl(i);
						if (sub) {
							mtlnum = mtlNumMap[i];
							if (dump_mchunk(MSH_MAT_GROUP,stream,mt)==0)
								return 0;
							}
						}
					}
				else {
					mtlnum = theMtls->FindMtl(mtl);
					multiMtl = FALSE;
					if (dump_mchunk(MSH_MAT_GROUP,stream,mt)==0)
						return 0;
					}
				}
#endif

			/* Save smoothing groups if any */

			if(anySmooth) {
				if(dump_mchunk(SMOOTH_GROUP,stream,m)==0)
					return(0);
				}
//			if (t->flags&TRI_BOX_MAP) 
//				if(dump_mchunk(MSH_BOXMAP,stream,t)==0)
//					return(0);
			}
			break;
//		case MSH_BOXMAP: {
//			int i;
//			for (i=0; i<6; i++) {
//				if (t->boxmtl[i]==255)
//					WRTERR(sdefault,8);
//				else {
//					if (!mtl_pointer(t->boxmtl[i],&mtl))
//						return(0);
//		   			WRTERR(mtl->name,strlen(mtl->name)+1);
//					}
//				}
//			}
//			break;
#ifdef EXPORT_MTLS
		case MSH_MAT_GROUP:
			{
			MeshAndTMAndNode *mt = (MeshAndTMAndNode*)data;
			m = mt->mesh;
			SMtl *mtl;
			short temp;
			assert(mtlnum>=0 && mtlnum<theMtls->Count());
			mtl = (*theMtls)[mtlnum].sm;
			assert(mtl);

			if (multiMtl) {
                count = 0;
				for (ix=0; ix<m->numFaces; ix++) {
                 // gdf
                    int faceIndex = m->getFaceMtlIndex(ix);

                    int mtlCnt = mtlNumMap.Count(); // this is to prevent compilier warnings
                    faceIndex = (faceIndex % mtlCnt);

                    int mtlIndex = mtlNumMap[faceIndex];
					if (mtlIndex==mtlnum)
							count++;
					}
				}
			else
				count = m->numFaces;

			WRTERR(mtl->name,strlen(mtl->name)+1);
			temp = (short)count;
			WRTERR(&temp,2);

			if (multiMtl) {
				for(ix=0; ix<m->numFaces; ++ix) {
                 // gdf
                    int faceIndex = m->getFaceMtlIndex(ix);

                    int mtlCnt = mtlNumMap.Count(); // this is to prevent compilier warnings
                    faceIndex = (faceIndex % mtlCnt);

					int mtlIndex = mtlNumMap[faceIndex];
					if (mtlIndex==mtlnum) {
						temp = (short)ix;
						WRTERR(&temp,2);
						if(--count==0)
							break;
						}
					}
				}
			else {
				for(ix=0; ix<m->numFaces; ++ix) {
					temp = (short)ix;
					WRTERR(&temp,2);
					}
				}
			}
			break;
#endif
		case SMOOTH_GROUP:
			m=(Mesh *)data;

			/* Now dump all object faces' smoothing group flags */
			count = m->getNumFaces();
			for(ix=0; ix<count; ++ix) {
				Face f = m->faces[ix];
				WRTERR(&f.smGroup,4);
				}
			break;
		case N_DIRECT_LIGHT:{
            oe = (ObjectEntry *)data;
			node = oe->entry->node;
			obj = oe->entry->obj;
			LightObject *lt= (LightObject *)obj;
			GenLight *gl = (GenLight *)obj;
			LightState ls;
			lt->EvalLightState(theSceneEnum->time, valid, &ls);
			Matrix3 mat = node->GetNodeTM(theSceneEnum->time);			
			Point3 pos = mat.GetRow(3);
			WRTERR(&pos.x,sizeof(float));
			WRTERR(&pos.y,sizeof(float));
			WRTERR(&pos.z,sizeof(float));
			if(dump_mchunk(COLOR_F,stream,&ls.color)==0)
				return(0);
			if(dump_mchunk(DL_OUTER_RANGE,stream,&ls.attenEnd)==0)
				return(0);
			if(dump_mchunk(DL_INNER_RANGE,stream,&ls.attenStart)==0)
				return(0);
			if(dump_mchunk(DL_MULTIPLIER,stream,&ls.intens)==0)
				return(0);
#if 0
			if(d->exclude) {
				Object_list *o=d->exclude;
				while(o) {
					if(dump_mchunk(DL_EXCLUDE,stream,o->name)==0)
						return(0);
					o=o->next;
					}
				}
#endif
			if (oe->entry->type==OBTYPE_SPOTLIGHT) {
				if(dump_mchunk(DL_SPOTLIGHT,stream,data)==0)
				return(0);
				}
			if (!ls.on) {
				if(dump_mchunk(DL_OFF,stream,data)==0)
					return(0);   
				}
			if(ls.useAtten) {
				if(dump_mchunk(DL_ATTENUATE,stream,data)==0)
					return(0);   
				}
//			if(d->appdata!=NULL) {
//				if(dump_mchunk(APP_DATA,stream,d->appdata)==0)
//					return(0);
//				} 
			}    
			break;
		case DL_SPOTLIGHT: {
            oe = (ObjectEntry *)data;
			INode *tnode = oe->entry->tnode;
			obj = oe->entry->obj;

            if (obj->ClassID()==Class_ID(DIR_LIGHT_CLASS_ID,0)) {
                TCHAR buf[ERROR_MSG_MAX_LEN];
                sprintf(buf, GetString(IDS_DIR_LIGHT), oe->entry->name);
		        AddToMsgList(msgList, buf);
                break;
            }

            if (obj->ClassID()==Class_ID(FSPOT_LIGHT_CLASS_ID,0)) {
                TCHAR buf[ERROR_MSG_MAX_LEN];
                sprintf(buf, GetString(IDS_FSPOT_LIGHT), oe->entry->name);
		        AddToMsgList(msgList, buf);
                break;
            }
			LightObject *lt= (LightObject *)obj;
			GenLight *gl = (GenLight *)obj;
			LightState ls;
			lt->EvalLightState(theSceneEnum->time, valid, &ls);
			Matrix3 mat = tnode->GetNodeTM(theSceneEnum->time);			
			Point3 pos = mat.GetRow(3);
			WRTERR(&pos.x,sizeof(float));
			WRTERR(&pos.y,sizeof(float));
			WRTERR(&pos.z,sizeof(float));
			WRTERR(&ls.hotsize,sizeof(float));
			WRTERR(&ls.fallsize,sizeof(float));
			if(dump_mchunk(DL_SPOT_ROLL,stream,data)==0)
				return(0);
			if(ls.shadow) {
				if(dump_mchunk(DL_SHADOWED,stream,NULL)==0)
				return(0);
				}
			if(!gl->GetUseGlobal()) {
				if(dump_mchunk(DL_LOCAL_SHADOW2,stream,gl)==0)
					return(0);
				}
			if(gl->GetConeDisplay()) {
				if(dump_mchunk(DL_SEE_CONE,stream,NULL)==0)
				return(0);
				}
//			if(d->flags & NO_LT_PROJ) {
//				if(dump_mchunk(DL_SPOT_PROJECTOR,stream,d)==0)
//				return(0);
//				}
			if(gl->GetSpotShape()==RECT_LIGHT) {
				if(dump_mchunk(DL_SPOT_RECTANGULAR,stream,NULL)==0)
					return(0);
				if(dump_mchunk(DL_SPOT_ASPECT,stream,gl)==0)
				return(0);
				}
			if(ls.overshoot) {
				if(dump_mchunk(DL_SPOT_OVERSHOOT,stream,NULL)==0)
				return(0);
				}
			if (dump_mchunk(DL_RAY_BIAS,stream,gl)==0)
				return(0);
			if (gl->GetShadowType())  {
				if(dump_mchunk(DL_RAYSHAD,stream,data)==0)
				return(0);   
				}
			}
			break;
		case DL_OFF:		/* Special null chunk */
		case DL_ATTENUATE:	/* Special null chunk */
		case DL_SHADOWED:	/* Special null chunk */

			break;

		case DL_SPOT_ROLL:{
			oe = (ObjectEntry *)data;
			INode *node = oe->entry->node;
			Control *tmCont = node->GetTMController();
			Control *rollCont = tmCont->GetRollController();
			float v;
			rollCont->GetValue(0,&v,valid);	
			WRTERR(&v,sizeof(float));
			break;
			}

		case DL_SPOT_ASPECT: {
			GenLight *gl = (GenLight *)data;
			float f = gl->GetAspect(0);
			WRTERR(&f,sizeof(float));
			break;
			}
		case DL_RAY_BIAS:{
			GenLight *gl = (GenLight *)data;
			float f = gl->GetRayBias(0);
			WRTERR(&f,sizeof(float));
			break;
			}
		case PROC_NAME:	/* external procedure name */
//			t=(Tri_obj *)data;
//			WRTERR(t->proc_name,strlen(t->proc_name)+1);
			break;
		case PROC_DATA:	/* external procedure data chunk */
//			t=(Tri_obj *)data;
//			{
//			ULONG *plong = (ULONG *)t->proc_data;
//			WRTERR(&plong[1],plong[0]);
//			}
			break;
		case DL_LOCAL_SHADOW2:
			{
			GenLight *gl = (GenLight *)data;
			LocShad2 locshad;
			locshad.bias = gl->GetMapBias(0);
			locshad.shadsize = gl->GetMapSize(0);
			locshad.shadfilter = gl->GetMapRange(0);
			WRTERR(&locshad,sizeof(LocShad2));
			}
			break;
		case N_CAMERA: {
			oe = (ObjectEntry *)data;
			node = oe->entry->node;
			CameraObject* camobj = (CameraObject *)oe->entry->obj;
			GenCamera *gc = (GenCamera*)oe->entry->obj;
			CameraState cs;
			camobj->EvalCameraState(theSceneEnum->time, valid, &cs);
			Camera3DS c;
			Matrix3 mat = node->GetNodeTM(theSceneEnum->time);			
			Point3 pos = mat.GetRow(3);
			c.x = pos.x;
			c.y = pos.y;
			c.z = pos.z;
			if (oe->entry->tnode) {
				mat = oe->entry->tnode->GetNodeTM(theSceneEnum->time);			
				pos = mat.GetRow(3);
				}
			c.tx = pos.x;
			c.ty = pos.y;
			c.tz = pos.z;
			c.bank = 0.0f;
			c.focal = 2400.0f/RadToDeg(cs.fov);
			c.flags = 0;
			c.nearplane = gc->GetClipDist(0,0);
			c.farplane = gc->GetClipDist(0,1);
			WRTERR(&c,32);
//			if(c->flags & NO_CAM_CONE) {
//				if(dump_mchunk(CAM_SEE_CONE,stream,NULL)==0)
//				return(0);
//				}
			if(dump_mchunk(CAM_RANGES,stream,gc)==0)
				return(0);
//			if(c->appdata!=NULL) {
//				if(dump_mchunk(APP_DATA,stream,c->appdata)==0)
//				return(0);
//				}     
			}
			break;
		case CAM_RANGES:{
			GenCamera *gc = (GenCamera *)data;
			float cnear = gc->GetEnvRange(0,0);
			float cfar = gc->GetEnvRange(0,1);
			WRTERR(&cnear,sizeof(float));
			WRTERR(&cfar,sizeof(float));
			}
			break;
//		case DL_SPOT_PROJECTOR:
//			d=(Dirlight *)data;
//			WRTERR(d->imgfile,13);
//			break;

		/* Dummy chunks -- no data, just their tag */

		case RAY_SHADOWS:
		case USE_BIT_MAP:
		case USE_SOLID_BGND:
		case USE_V_GRADIENT:
		case USE_FOG:
		case USE_DISTANCE_CUE:
		case USE_LAYER_FOG:
		case FOG_BGND:
		case DCUE_BGND:
		case CAM_SEE_CONE:
		case DL_SEE_CONE:
		case DL_SPOT_OVERSHOOT:
		case DL_SPOT_RECTANGULAR:
		case DL_RAYSHAD:
		case DUMMY:
			break;
		default:		// Unknown chunk!
			assert(0);
			break;
		}

	/* Save file ptr */

	curpos=ftell(stream);

	/* Point back to chunk size location */

	fseek(stream,chunkptr,SEEK_SET);

	/* Calc & write chunk size */

	chunksize=curpos-chunkbase;
	WRTERR(&chunksize,4);

	/* Point back to file end */

	fseek(stream,curpos,SEEK_SET);
	return(1);
	}


#define WRITEF(ptr,size) fwrite((char *)ptr,1,size,wstream)
#define WERR(ptr,sz) {if (WRITEF(ptr,(sz))!=(sz)) return(0);}
#define WRFLOAT(ptr) WERR(ptr,sizeof(FLOAT))
#define WR3FLOAT(ptr) WERR(ptr,3*sizeof(FLOAT))
#define WRLONG(ptr) WERR(ptr,sizeof(LONG))
#define WRSHORT(ptr) WERR(ptr,sizeof(SHORT))
#define WRSTRING(ptr) WERR(ptr,strlen(ptr)+1)

#define EPS (1.0e-7)
#define NotZero(f) (f<-EPS || f>EPS)

int WriteStd1KeyHdr() {
	short trackflags = 0;
	WRSHORT(&trackflags);
	long lwork = 0;
	WRLONG(&lwork);		// Track min
	WRLONG(&lwork);		// Track max
	long nkeys = 1;
	WRLONG(&nkeys);
	long keytime = 0;
	WRLONG(&keytime);
	short wflags = 0;		// Ignoring tension, continuity, bias, eases
	WRSHORT(&wflags);
	return 1;
	}

static
BOOL IsTCBContol(Control *cont) {
	return (
		cont->ClassID()==Class_ID(TCBINTERP_FLOAT_CLASS_ID,0) ||
		cont->ClassID()==Class_ID(TCBINTERP_POSITION_CLASS_ID,0) ||
		cont->ClassID()==Class_ID(TCBINTERP_ROTATION_CLASS_ID,0) ||
		cont->ClassID()==Class_ID(TCBINTERP_POINT3_CLASS_ID,0) ||
		cont->ClassID()==Class_ID(TCBINTERP_SCALE_CLASS_ID,0));
}

static BOOL WriteControllerChunk(Control *cont,int type, float scale=1.0f)
	{
	ITCBFloatKey fkey;
	ITCBPoint3Key pkey;
	ITCBRotKey rkey;
	ITCBScaleKey skey;
	ITCBKey *k;	
	int num = cont->NumKeys();
	float fval;
	Point3 pval;
	Quat q, qLast = IdentQuat();
	AngAxis rval;
	ScaleValue sval;
	Interval valid;
	TimeValue t;

	// Set up 'k' to point at the right derived class
	switch (type) {
		case KEY_FLOAT: k = &fkey; break;
		case KEY_POS:   k = &pkey; break;
		case KEY_ROT:   k = &rkey; break;
		case KEY_SCL:   k = &skey; break;
		case KEY_COLOR: k = &pkey; break;
		default: return FALSE;
		}

	// Get the keyframe interface
	IKeyControl *ikeys = GetKeyControlInterface(cont);
	
	// Gotta have some keys
	if (num==NOT_KEYFRAMEABLE || num==0) {
		return FALSE;
		}
	
	// Write track some stuff
	short trackflags = 0;
	WRSHORT(&trackflags);
	long lwork = cont->GetKeyTime(0)/GetTicksPerFrame();
	WRLONG(&lwork);		// Track min
	lwork = cont->GetKeyTime(num-1)/GetTicksPerFrame();
	WRLONG(&lwork);		// Track max
	long nkeys = num;
	WRLONG(&nkeys);

	for (int i=0; i<num; i++) {
		if (IsTCBContol(cont) && ikeys) {
			ikeys->GetKey(i,k);


			// Write key time
			long keytime = k->time/GetTicksPerFrame();
			WRLONG(&keytime);
			
			// Write flags
			short wflags = 0;
			if (k->tens   != 0.0f) wflags |= W_TENS;
			if (k->cont   != 0.0f) wflags |= W_CONT;
			if (k->bias   != 0.0f) wflags |= W_BIAS;
			if (k->easeIn != 0.0f) wflags |= W_EASETO;
			if (k->easeOut!= 0.0f) wflags |= W_EASEFROM;			
			WRSHORT(&wflags);
			
			// Write TCB and ease
			if (k->tens   != 0.0f) WRFLOAT(&k->tens);
			if (k->cont   != 0.0f) WRFLOAT(&k->cont);
			if (k->bias   != 0.0f) WRFLOAT(&k->bias);
			if (k->easeIn != 0.0f) WRFLOAT(&k->easeIn);
			if (k->easeOut!= 0.0f) WRFLOAT(&k->easeOut);
			
			// Write values
			switch (type) {
				case KEY_FLOAT: 
					fkey.val*=scale;
					WRFLOAT(&fkey.val);
					break;
				
				case KEY_SCL:
					WRFLOAT(&skey.val.s.x);
					WRFLOAT(&skey.val.s.y);
					WRFLOAT(&skey.val.s.z);
					break;

				case KEY_COLOR:
				case KEY_POS:
					WRFLOAT(&pkey.val.x);
					WRFLOAT(&pkey.val.y);
					WRFLOAT(&pkey.val.z);
					break;

				case KEY_ROT:
					WRFLOAT(&rkey.val.angle);
					WRFLOAT(&rkey.val.axis.x);
					WRFLOAT(&rkey.val.axis.y);
					WRFLOAT(&rkey.val.axis.z);
					break;
				}

		} else {
			// Sample the control at each key time
			t = cont->GetKeyTime(i);

			// Write key time
			long keytime = t/GetTicksPerFrame();
			WRLONG(&keytime);
			
			// Write flags
			short wflags = 0;			
			WRSHORT(&wflags);
			
			// Write values
			switch (type) {
				case KEY_FLOAT: 
					cont->GetValue(t,&fval,valid);
					fval*=scale;
					WRFLOAT(&fval);
					break;
				
				case KEY_SCL:
					cont->GetValue(t,&sval,valid);
					WRFLOAT(&sval.s.x);
					WRFLOAT(&sval.s.y);
					WRFLOAT(&sval.s.z);
					break;

				case KEY_COLOR:
				case KEY_POS:
					cont->GetValue(t,&pval,valid);
					WRFLOAT(&pval.x);
					WRFLOAT(&pval.y);
					WRFLOAT(&pval.z);
					break;

				case KEY_ROT:
					cont->GetValue(t,&q,valid);
					rval = AngAxis(q/qLast);
                    qLast = q;
					WRFLOAT(&rval.angle);
					WRFLOAT(&rval.axis.x);
					WRFLOAT(&rval.axis.y);
					WRFLOAT(&rval.axis.z);
					break;
				}
			}
		}
	return TRUE;
	}



static int WriteFloatTrack(Control *c, float scale) {
	Interval valid;
	if (!WriteControllerChunk(c,KEY_FLOAT,scale)) {
		float v;
		c->GetValue(0,&v,valid);
		v *= scale;
		if (!WriteStd1KeyHdr()) return 0;
		WRFLOAT(&v);      
		}
	return 1;
	}

static int WriteFloatTrackOrStd1KeyHdr(Control *c, float scale) {
	if (c) {
		if (!WriteFloatTrack(c, scale)) return 0;
		}
	else {
		if (!WriteStd1KeyHdr()) return 0;
		WRFLOAT(&floatVal);
		}
	return 1;
	}

int	KFWriteChunk(unsigned short tag, void *data);

int dump_kchunk(unsigned short tag, FILE *stream, void *data) {
	wstream = stream;
	return(KFWriteChunk(tag,data));
	}

// RB 4-4-96: see comment by OBJECT_NODE_TAG
static BOOL savingLiteralData = FALSE;

int	KFWriteChunk(unsigned short tag, void *data)	{
	long chunkptr,chunkbase,curpos,chunksize;
	Interval valid;
	INode *node;
	SHORT version = KFVERSION;
	Object *ob;
		
	chunkbase = ftell(wstream);
#ifdef DBGKFB
	if(dbgio) {
		printf("\n------>Writing chunk type: ");
		kfprint_ID(tag);
		printf("   Chunkbase = %lx, tag =  %5x.\n",chunkbase,tag);
		}
#endif

	WRSHORT(&tag);
	chunkptr = ftell(wstream);

	WRLONG(&chunkptr);

	switch(tag)	{
		case KFDATA: 
			{
			/* Keyframe main chunk */
			int nodeid;
			if (!KFWriteChunk(KFHDR,data)) return(0); 
			if (!KFWriteChunk(KFSEG,data)) return(0); 
			if (!KFWriteChunk(KFCURTIME,data)) return(0); 

			nodeid=0;
			for (SceneEntry *se = theSceneEnum->head; se!=NULL; se = se->next) {
				switch (se->type)  {
					case OBTYPE_DUMMY:
					case OBTYPE_MESH: 
						se->id = nodeid++;
						if (!KFWriteChunk(OBJECT_NODE_TAG,se)) return(0);
						break;
					case OBTYPE_OMNILIGHT: 
						se->id = nodeid++;
						if (!KFWriteChunk(LIGHT_NODE_TAG,se))return(0);
						break;	  
					case OBTYPE_SPOTLIGHT: 
						se->id = nodeid++;
						if (!KFWriteChunk(SPOTLIGHT_NODE_TAG,se)) return(0);
						break;	  
					case OBTYPE_LTARGET: 
						se->id = nodeid++;
						if (!KFWriteChunk(L_TARGET_NODE_TAG,se)) return(0);
						break;
					case OBTYPE_CTARGET: 
						se->id = nodeid++;
						if (!KFWriteChunk(TARGET_NODE_TAG,se)) return(0);
						break;
					case OBTYPE_CAMERA: 
						se->id = nodeid++;
						if (!KFWriteChunk(CAMERA_NODE_TAG,se))return(0); 
						break;
//					case TARGET_NODE: 
//						{
//						Namedobj *ob = node->object;
//						node->id = nodeid++;
//						switch(ob->type) {
//							case N_CAMERA:
//								if (!KFWriteChunk(TARGET_NODE_TAG,node))
//									return(0);
//								break;
//							case N_DIRECT_LIGHT:
//								if (!KFWriteChunk(L_TARGET_NODE_TAG,node))
//									return(0);
//								break;
//							}
//						}
//						break;
//					case OBTYPE_SPOTLIGHT: 
//						node->id = nodeid++;
//						if (!KFWriteChunk(LIGHT_NODE_TAG,node))return(0);
//						break;	  
//					case SPOTLIGHT_NODE: 
//						node->id = nodeid++;
//						if (!KFWriteChunk(SPOTLIGHT_NODE_TAG,node))return(0);
//						break;
					}
				}
//			/* Do new kinds of nodes later, so 3DS2.0 doesn't get screwed up*/
//			for (i=0; i<nodeCount; i++) {
//				node = nodeList[i];
//				switch (node->type)  {
//					case AMBIENT_NODE: 
//						node->id = -1;
//						if (!KFWriteChunk(AMBIENT_NODE_TAG,node))return(0);
//						break;
//					}
//				}
//			if (KFappdata!=NULL) 
//				if (!KFWriteChunk(APP_DATA,KFappdata))  return(0);
			}
			break;
		case KFHDR: {
			WRSHORT(&version);
			WRSTRING("MAXSCENE");
			long animLength = theSceneEnum->i->GetAnimRange().End()/GetTicksPerFrame();
			WRLONG(&animLength);
#ifdef DBGKFB
			if (dbgio) 
				printf("version = %d, mshName = %s, P.animLength = %d	\n",
					version, mshName, P.animLength);
#endif
			}
			break;
		case KFSEG: {
			Interval i = theSceneEnum->i->GetAnimRange();
			long s = i.Start()/GetTicksPerFrame();
			long e = i.End()/GetTicksPerFrame();
			WRLONG(&s);
			WRLONG(&e);
			}
			break;
		case KFCURTIME: {
			long t = theSceneEnum->i->GetTime();
			WRLONG(&t);
			}
			break;
		case PIVOT:	 {
         // gdf make a 3ds pivot out of a max pivot.
            Point3 pivot = GetPivotOffset(((SceneEntry *)data)->node);
			WR3FLOAT(&pivot[0]);
			}
			break;
		case BOUNDBOX:	 {
			Box3 bb;
			ViewExp *vpt = theSceneEnum->i->GetViewport(NULL);
			SceneEntry *se = (SceneEntry *)data;
			se->obj->GetLocalBoundBox(theSceneEnum->i->GetTime(), se->node, vpt, bb);
			WR3FLOAT(&bb.pmin[0]);
			WR3FLOAT(&bb.pmax[0]);
			}
			break;
		case INSTANCE_NAME:	 {
			CStr *name = (CStr *)data;
			if(name->Length()>10)
				name->Resize(10);
			WERR(name->data(),(size_t)(name->Length()+1));
			}
			break;
//		case MORPH_SMOOTH: {
//			ObjectNode *onode = (ObjectNode *)data;
//			WRFLOAT(&onode->smooth_ang);
//			}
//			break;
		case NODE_ID: {	
			SceneEntry *se = (SceneEntry *)data;
#ifdef DBGKFB
			if (dbgio)
				printf(" writing NODE_ID =%d \n", nd->id);
#endif
			WRSHORT(&se->id);
			}
			break;
		case NODE_HDR: {
			SceneEntry *se = (SceneEntry *)data;
			BOOL isInstance = FALSE;
			node = se->node;
			ob = se->obj;
			// Write out the primary name -- It's the name of the first node using the object.
			// We do this to work with 3DS's system where a primary node uses an object and
			// shares its name, and all other instances use this name as a primary name with
			// a dot (.) followed by the instance name.
			if (se->type == OBTYPE_DUMMY) {
				WRSTRING("$$$DUMMY");
				}
			else if (se->type == OBTYPE_CTARGET||se->type == OBTYPE_LTARGET) {
				// The object name written should be the same as that of the associated
				// light or camera.
				//INode *lan = se->node->GetLookatNode();
				//ObjectEntry *oe = theObjects->Contains(lan);
				ObjectEntry *oe = theObjects->FindLookatNode(se->node);
				assert(oe);
				CStr name(oe->entry->name); 
				if(name.Length()>10)
					name.Resize(10);
				WERR(name.data(),(size_t)(name.Length()+1));
				}
			else {
				TSTR name; 
				
				// for cameras, lights, which can't be multiple instanced in 3DS
				// just get name from  scene entry  -- DS 4/6/96
				if (se->type != OBTYPE_MESH) {
					name = se->name;
					}
				else {
					// search for the object entry 
					ObjectEntry *oe = theObjects->Contains(ob);
					assert(oe);
					name = oe->entry->name; // RB
					// If the name is not equal to the master name then
					// it is an instance.
					if (!(oe->entry->name==se->name)) 
						isInstance = TRUE;
					}
				
				if(name.Length()>10)
					name.Resize(10);
//DebugPrint("Making %s unique\n",CStr(name));
//				theObjNames.MakeUnique(name);
//DebugPrint("Got %s\n",CStr(name));
				CStr cname(name);		// Make it char*
				WERR(cname.data(),(size_t)(cname.Length()+1));
				}
			short zero = 0;
			short fl = isInstance ? 0 : (short)PRIMARY_NODE;
			WRSHORT(&fl);		// Node flags
			WRSHORT(&zero);		// flags 2
			INode *parentNode = node->GetParentNode();
			SceneEntry *pse = theSceneEnum->Find(parentNode);
#ifdef DBGKFB
			if (dbgio)
				printf("nparent = %X \n", nparent);
#endif
			if(pse) {
				WRSHORT(&pse->id);
				}
			else{
				short none = (short)NO_PARENT; 
				WRSHORT(&none);
				}
			}
			break;
//		case APP_DATA:
//		   {
//			ULONG *plong = (ULONG *)data;
//			WERR(&plong[1],plong[0]);
//			}
//			break;
		case OBJECT_NODE_TAG: {
			SceneEntry *se = (SceneEntry *)data;
			ob = se->obj;
			if (!KFWriteChunk(NODE_ID,se)) return(0);
			if (!KFWriteChunk(NODE_HDR,se)) return(0);
//			if (on->appdata) if (!KFWriteChunk(APP_DATA,on->appdata)) return(0);
			if (!KFWriteChunk(PIVOT,se)) return(0);
			//TSTR name(se->node->GetName());
			TSTR name(se->name); // RB
			// MAX doesn't have the notion of instance names, but 3DS does -- we must use the name
			// of the original object as the node name, and this node's name as the instance name.
			// We don't write an instance name if the instance name is the same as the master object's
			// name.
			ObjectEntry *oe = theObjects->Contains(ob);
			assert(oe);
			//TSTR mname(oe->entry->node->GetName());		// Master name
			TSTR mname(oe->entry->name);		// Master name
			if (se->type!=OBTYPE_CTARGET&&se->type!=OBTYPE_LTARGET) {
				if (se->type==OBTYPE_DUMMY || !(mname == name)) { 
					CStr wname(name);
					if (!KFWriteChunk(INSTANCE_NAME,&wname)) return(0); 
					}
				}

            WriteController(se->node);

//			if (on->mtrack.keytab)
//				if (!KFWriteChunk(MORPH_TRACK_TAG, &on->mtrack)) return(0);
//			if (on->htrack.keytab)
//				if (!KFWriteChunk(HIDE_TRACK_TAG, &on->htrack)) return(0);
			if (se->type==OBTYPE_DUMMY) {  /* dummy Node */
				if (!KFWriteChunk(BOUNDBOX, data)) return(0);
				}
//			if (!KFWriteChunk(MORPH_SMOOTH, data)) return(0);
			}
			break;
		case CAMERA_NODE_TAG: {
			SceneEntry *se = (SceneEntry *)data;
			GenCamera *ob = (GenCamera *)se->obj;
			if (!KFWriteChunk(NODE_ID,se)) return(0);
			if (!KFWriteChunk(NODE_HDR,se)) return(0);
//			if (cn->appdata) if (!KFWriteChunk(APP_DATA,cn->appdata)) return(0);
			Control *c;
			
			c = se->node->GetTMController()->GetPositionController();
			if (c) if (!KFWriteChunk(POS_TRACK_TAG, c)) return(0);
			
			floatVal = RadToDeg(ob->GetFOV(0));
			c = ob->GetFOVControl();
			if (!KFWriteChunk(FOV_TRACK_TAG, c)) return(0);

			Control* tmc = se->node->GetTMController();
			c = tmc->GetRollController();
			if (c) if (!KFWriteChunk(ROLL_TRACK_TAG, c)) return(0);
			}
			break;
		case L_TARGET_NODE_TAG:
		case TARGET_NODE_TAG:{
			SceneEntry *se = (SceneEntry *)data;
			if (!KFWriteChunk(NODE_ID,se)) return(0);
			if (!KFWriteChunk(NODE_HDR,se)) return(0);
//			if (tn->appdata) if (!KFWriteChunk(APP_DATA,tn->appdata)) return(0);
			Control *c;
			c = se->node->GetTMController()->GetPositionController();
			if (c) if (!KFWriteChunk(POS_TRACK_TAG, c)) return(0);
			}
			break;
		case LIGHT_NODE_TAG: {
			SceneEntry *se = (SceneEntry *)data;
			GenLight* ob = (GenLight *)se->obj;
			if (!KFWriteChunk(NODE_ID,se)) return(0);
			if (!KFWriteChunk(NODE_HDR,se)) return(0);
//			if (ln->appdata) if (!KFWriteChunk(APP_DATA,ln->appdata)) return(0);
			Control *c;
			
			colorVal = ob->GetRGBColor(0);
			c = ob->GetColorControl();
			if (!KFWriteChunk(COL_TRACK_TAG, c)) return(0);
			
			c = se->node->GetTMController()->GetPositionController();
			if (c) if (!KFWriteChunk(POS_TRACK_TAG, c)) return(0);
			}
			break;

		case SPOTLIGHT_NODE_TAG: {
			SceneEntry *se = (SceneEntry *)data;
			GenLight* ob = (GenLight *)se->obj;
			if (!KFWriteChunk(NODE_ID,se)) return(0);
			if (!KFWriteChunk(NODE_HDR,se)) return(0);
			Control *c;
			c = se->node->GetTMController()->GetPositionController();
			if (c) if (!KFWriteChunk(POS_TRACK_TAG, c)) return(0);

//			if (sln->appdata) if (!KFWriteChunk(APP_DATA,sln->appdata)) return(0);
			
			colorVal = ob->GetRGBColor(0);
			c = ob->GetColorControl();
			if (!KFWriteChunk(COL_TRACK_TAG, c)) return(0);
			
			floatVal = ob->GetHotspot(0);
			c = ob->GetHotSpotControl();
			if (!KFWriteChunk(HOT_TRACK_TAG, c)) return(0);

			floatVal = ob->GetFallsize(0);
			c = ob->GetFalloffControl();
			if (!KFWriteChunk(FALL_TRACK_TAG, c)) return(0);

			Control* tmc = se->node->GetTMController();
			c = tmc->GetRollController();
			if (!KFWriteChunk(ROLL_TRACK_TAG, c)) return(0);
			}
			break;
//		case AMBIENT_NODE_TAG:
//			AmbientNode *an = (AmbientNode *)data;
//			if (!KFWriteChunk(NODE_ID,an)) return(0);
//			if (!KFWriteChunk(NODE_HDR,an)) return(0);
//			if (an->appdata) if (!KFWriteChunk(APP_DATA,an->appdata)) return(0);
//			if (!KFWriteChunk(COL_TRACK_TAG, &an->coltrack)) return(0);
//			break;
        /*
		case SCL_TRACK_TAG: {
			if (!savingLiteralData) {
				Control *c = (Control*)data;
				if (!WriteControllerChunk(c,KEY_SCL)) {
					ScaleValue pos;
					c->GetValue(0,&pos,valid);
					if (!WriteStd1KeyHdr()) return 0;
					WRFLOAT(&pos.s.x);
					WRFLOAT(&pos.s.y);
					WRFLOAT(&pos.s.z);
					}
			} else {
				Point3 *p = (Point3*)data;
				if (!WriteStd1KeyHdr()) return 0;
				WRFLOAT(&p->x);
				WRFLOAT(&p->y);
				WRFLOAT(&p->z);
				}
			}
			break;
		*/		
		case POS_TRACK_TAG: {
			if (!savingLiteralData) {
				Control *c = (Control*)data;
				if (!WriteControllerChunk(c,KEY_POS)) {
					Point3 pos;
					c->GetValue(0,&pos,valid);					
					if (!WriteStd1KeyHdr()) return 0;
					WRFLOAT(&pos.x);
					WRFLOAT(&pos.y);
					WRFLOAT(&pos.z);
					}
			} else {
				Point3 *p = (Point3*)data;
				if (!WriteStd1KeyHdr()) return 0;
				WRFLOAT(&p->x);
				WRFLOAT(&p->y);
				WRFLOAT(&p->z);
				}
			}
			break;

        /*
		case ROT_TRACK_TAG: {
			if (!savingLiteralData) {
				Control *c = (Control*)data;
				if (!WriteControllerChunk(c,KEY_ROT)) {
					Quat rot;
					c->GetValue(0,&rot,valid);
					float angle;
					Point3 axis;
					AngAxisFromQ(rot,&angle,axis);
					if (!WriteStd1KeyHdr()) return 0;
					WRFLOAT(&angle);
					WRFLOAT(&axis.x);
					WRFLOAT(&axis.y);
					WRFLOAT(&axis.z);
					}
			} else {
				Quat *q = (Quat*)data;
				float angle;
				Point3 axis;
				AngAxisFromQ(*q,&angle,axis);
				if (!WriteStd1KeyHdr()) return 0;
				WRFLOAT(&angle);
				WRFLOAT(&axis.x);
				WRFLOAT(&axis.y);
				WRFLOAT(&axis.z);
				}
			}
			break;
        */
		case FOV_TRACK_TAG:
			if (!WriteFloatTrackOrStd1KeyHdr((Control *)data, RAD_TO_DEG))
				return 0;
			break;
		case FALL_TRACK_TAG:
		case HOT_TRACK_TAG: 
			if (!WriteFloatTrackOrStd1KeyHdr((Control *)data,1.0f))
				return 0;
			break;
		case ROLL_TRACK_TAG: 	
			if (!WriteFloatTrackOrStd1KeyHdr((Control *)data, -RAD_TO_DEG))
				return 0;
			break;
		case COL_TRACK_TAG: {
			Control *c = (Control*)data;
			if (!c||!WriteControllerChunk(c,KEY_COLOR)) {
				Point3 pos;
				if (c) c->GetValue(0,&pos,valid);					
				else pos = colorVal;
				if (!WriteStd1KeyHdr()) return 0;
				WRFLOAT(&pos.x);
				WRFLOAT(&pos.y);
				WRFLOAT(&pos.z);
				}
			}
			break;
		case HIDE_TRACK_TAG:
		case MORPH_TRACK_TAG:	
			if (!WriteFloatTrackOrStd1KeyHdr((Control *)data, 1.0f))
				return 0;
			break;
		default:
			assert(0);
			break;
		}   			

	/* Save file ptr */
	curpos=ftell(wstream);

	/* Point back to chunk size location */
	fseek(wstream,chunkptr,SEEK_SET);
	
	/* Calc & write chunk size */
	chunksize=curpos-chunkbase;
#ifdef DBGKFB
	if (dbgio) {
		printf("writing chunkptr = %lx, chunkSize = %ld \n",chunkptr,chunksize);
		}
#endif

	WERR(&chunksize,4);
	
	/* Point back to file end */
	
	fseek(wstream,curpos,SEEK_SET);
	return(1);
	}

/* Main routine for writing MSH+KFB! 	*/
/* Recursive chunk writer -- keeps track of each chunk	*/

int	dump_3dchunk(USHORT tag,FILE *stream,void *data)	{
	long chunkptr,chunkbase,curpos,chunksize,lval;
	chunkbase=ftell(stream);
	WRTERR(&tag,2);
	chunkptr=ftell(stream);		/* Save file ptr for chunk size */
	WRTERR(&chunkptr,4);
  	wstream = stream;
	switch(tag)	{
		case M3DMAGIC:	/* Mesh editor */
			if(dump_3dchunk(M3D_VERSION,stream,NULL)==0)
				return(0);
			if (dump_mchunk(MMAGIC,stream,NULL)==0)
				return(0);
			if(dump_kchunk(KFDATA,stream,NULL)==0)
				return(0);
			break;
		case M3D_VERSION:
			lval= 3;
			WRTERR(&lval,4);
			break;
		}
	/* Save file ptr */
	curpos=ftell(stream);
	
	/* Point back to chunk size location */
	fseek(stream,chunkptr,SEEK_SET);
	
	/* Calc & write chunk size */
	
	chunksize=curpos-chunkbase;
	WRTERR(&chunksize,4);

	/* Point back to file end */
	fseek(stream,curpos,SEEK_SET);
	return(1);
	}

int
_3ds_save(const TCHAR *filename, ExpInterface *ei, Interface *gi, _3DSExport* exp) {
	// Put up the options dialog to find out how they want the file written!

	if(showPrompts) {
		int result = DialogBoxParam(hInstance,
									MAKEINTRESOURCE(IDD_EXPORTOPTIONS),
//									GetActiveWindow(),
									gi->GetMAXHWnd(),
									ExportOptionsDlgProc,
									(LPARAM) exp);
		if (result <= 0) 
		    return 0;
		}
    else {	// Set default parameters here
		MaxUVs = TRUE;
		}

    MeshMtlList myMtls;

	// Make sure there are nodes we're interested in!
	// Ask the scene to enumerate all its nodes so we can determine if there are any we can use
	SceneEnumProc myScene(ei->theScene, gi->GetTime(), gi, &myMtls);

	// Any useful nodes?
	if(!myScene.Count()) {
		if(showPrompts)
			Alert(IDS_TH_NODATATOEXPORT);
		return 1;
		}

	// Construct unique names < 10 chars.
	myScene.BuildNames();

	ObjectList myObjects(myScene);

	theSceneEnum = &myScene;
	theObjects = &myObjects;
	theMtls = &myMtls;


	WorkFile theFile(filename,"wb");
	FILE *stream = theFile.Stream();

		
	if(!stream) {
		if(showPrompts)
			Alert(IDS_TH_CANTCREATE);
		return(0);
		}
	
	int error=0;
	
	if(dump_3dchunk(M3DMAGIC,stream,NULL)==0)
		error=1;
	
	if(theFile.Close())
		error=1;
	
	if(error) {
		if(showPrompts)
			Alert(IDS_TH_WRITEERROR);
		remove(filename);
		return(0);
		}
	
	return 1;	
	}

int
_3DSExport::DoExport(const TCHAR *filename,ExpInterface *ei,Interface *gi, BOOL suppressPrompts, DWORD options) {
	// Set a global prompt display switch
	showPrompts = suppressPrompts ? FALSE : TRUE;
	exportSelected = (options & SCENE_EXPORT_SELECTED) ? TRUE : FALSE;

	int status;

    msgList.SetCount(0);

	status = _3ds_save(filename, ei, gi, this);

 // gdf output errors
    if (msgList.Count()) {
		if(showPrompts)
			CreateDialog(hInstance, MAKEINTRESOURCE(IDD_ERROR_MSGS), GetActiveWindow(), MsgListDlgProc);
        for (int i = 0; i < msgList.Count(); i++) {
            delete msgList[i];
            msgList[i] = NULL;
        }
        msgList.Delete(0, msgList.Count());
    }

	if(status == 0)
		return 1;		// Dialog cancelled
	if(status < 0)
		return 0;		// Real, honest-to-goodness error
	return(status);
	}

BOOL _3DSExport::SupportsOptions(int ext, DWORD options) {
	assert(ext == 0);	// We only support one extension
	return(options == SCENE_EXPORT_SELECTED) ? TRUE : FALSE;
	}

#ifdef HOLDING

	for(ox=0; ox<myScene.Count(); ++ox)
		{
		INode *n = myScene[ox]->node;
		Object *obj = myScene[ox]->obj;
		TriObject *tri = (TriObject *)obj->ConvertToType(gi->GetTime(), triObjectClassID);
		Mesh &mesh = tri->mesh;
		Matrix3 tm = n->GetObjectTM(gi->GetTime());

		int verts = mesh.getNumVerts();
		int faces = mesh.getNumFaces();

		Point3 vert;
		Face face;
		for(ix=0; ix<verts; ++ix) {
			vert = mesh.verts[ix] * tm;
			}
		for(ix=0; ix<faces; ++ix)
			{
			face = mesh.faces[ix];
			}

		// Delete the working object, if necessary
		if(obj != (Object *)tri)
			tri->DeleteThis();
		}
#endif

short Get3DSTVerts(Mesh& mesh, Point2 *tv) {
	int nv = mesh.getNumVerts();
 	int nf = mesh.getNumFaces();
	short wrap = 0;
	BitArray done(nv);
	for (int j=0; j<nf; j++) {
		Face& face = mesh.faces[j];
		TVFace& tvface = mesh.tvFace[j];
		for (int k=0; k<3; k++)  {
			// get the texture vertex.
			Point3 uvw = mesh.tVerts[tvface.t[k]];
			Point2 v(uvw.x,uvw.y);
			// stuff it into the 3DSr4 vertex
			int vert = face.v[k];
			if (vert>65535) continue;
			if (!done[vert]) {
				tv[vert] = v;
				done.Set(vert,1);
				}
			else {
				if (v.x!=tv[vert].x) {
					wrap |= UWRAP;
					if (v.x<tv[vert].x) tv[vert].x = v.x;
					}
				if (v.y!=tv[vert].y) {
					wrap |= VWRAP;
					if (v.y<tv[vert].y) tv[vert].y = v.y;
					}
				}
			}
		}
	return wrap;
	}

// gdf
void
AddToMsgList(Tab<TSTR*>& mList, TCHAR* msg)
{
    TCHAR buf[ERROR_MSG_MAX_LEN];
    strncpy(buf, msg, ERROR_MSG_MAX_LEN);
    buf[ERROR_MSG_MAX_LEN - 1] = '\0';
    TSTR* errStr = new TSTR(buf);
    mList.Insert(mList.Count(), 1, &errStr);
}

// gdf
void
AddLineToListDlg(HWND hDlg, const TCHAR* buf) {
    SendDlgItemMessage(hDlg, IDC_ERROR_MSG_LIST, LB_ADDSTRING, NULL, (LPARAM) buf);
}

// gdf output errors
void BuildMsgList(HWND hDlg)
{
    AddLineToListDlg(hDlg, GetString(IDS_START));
    for (int i = 0; i < msgList.Count(); i++) {
        AddLineToListDlg(hDlg, _T(msgList[i]->data()));
    }
    AddLineToListDlg(hDlg, GetString(IDS_END));
}

//gdf
BOOL
CALLBACK MsgListDlgProc(HWND hDlg, UINT iMsg, UINT wParam, LONG lParam)
{
    int tabs[3] = {24,24,24};
    switch (iMsg)
    {
	    case WM_INITDIALOG:
			CenterWindow(hDlg, GetWindow(hDlg, GW_OWNER));
            SendDlgItemMessage(hDlg, IDC_ERROR_MSG_LIST, LB_RESETCONTENT, 0, 0);
			SendDlgItemMessage(hDlg, IDC_ERROR_MSG_LIST, LB_SETTABSTOPS, (WPARAM) 3,(LPARAM) tabs);
			BuildMsgList(hDlg);
			return TRUE;

	    case WM_COMMAND:
			switch(LOWORD(wParam))
            {
				case IDOK:	
					EndDialog(hDlg, TRUE); 
					break;
			}
			break;
	}
    return FALSE;
}

// gdf check to see if two UVVerts are the same
BOOL 
UVVertEqual(UVVert tv0, UVVert tv1) {
    return (tv0.x == tv1.x &&
            tv0.y == tv1.y &&
            tv0.y == tv1.y);
}

// gdf convert MAX UVVert into 3ds UVVert this will fail if uvvert is not the
// same for a shared vert.  FIXME add wrapFlags
void
ConvertTo3DSTVerts(ObjectEntry* oe, Tab<UVVert>& tv)
{
    Mesh mesh = oe->tri->GetMesh();
	BitArray vWritten;
    vWritten.SetSize(mesh.getNumVerts());
    vWritten.ClearAll();
    BOOL wMsg = FALSE;

    tv.SetCount(mesh.getNumVerts());
    if (mesh.getNumVerts() != mesh.getNumTVerts()) {
        TCHAR buf[ERROR_MSG_MAX_LEN];
        sprintf(buf, GetString(IDS_UVVERT_MISMATCH), oe->entry->name);
		AddToMsgList(msgList, buf);
        wMsg = TRUE;
    }
	for (int i = 0; i < mesh.getNumFaces(); i++) {
        Face face     = mesh.faces[i];
        TVFace tvFace = mesh.tvFace[i];
        for (int j = 0; j < 3; j++) {
            UVVert tvert  = mesh.getTVert(tvFace.t[j]);
            if (vWritten[face.v[j]] && !UVVertEqual(tv[face.v[j]], tvert)) {
                if (!wMsg ) {
                    TCHAR buf[ERROR_MSG_MAX_LEN];
                    sprintf(buf, GetString(IDS_UVVERT_TOO_MANY_PER_VERT), oe->entry->name);
		            AddToMsgList(msgList, buf);
                    wMsg = TRUE;
                }
            }
            tv[face.v[j]] = tvert;
            vWritten.Set(face.v[j]);
        }
    }
}

// gdf remove the rotational and scale comonents from the max pivot
// to get the pivot offset for 3ds
static Point3
GetPivotOffset(INode* node)
{
 // get the pivot offset and remove the rotational/scale component
    Matrix3 mat(TRUE);
    Quat qRot = node->GetObjOffsetRot();
    qRot.MakeMatrix(mat);
 // max scales the object if the pivot is scaled so skip.
 // m.SetScale( ((SceneEntry *)data)->node->GetObjOffsetScale().s );
    Point3 pivot = -node->GetObjOffsetPos();
    mat = Inverse(mat);
    Point3 pOff = VectorTransform(mat, pivot);
    return pOff;
}

// gdf used for reducing keys
inline BOOL
ApproxEqual(float a, float b)
{
    float eps = float(1.0e-5);
    float d = (float) fabs(a-b);
    return d < eps;
}

// gdf see if we can write TCB keys instead of generating keys by
// sampling frames.
static BOOL
IsTCBControl(Control *cont)
{
	return (cont->ClassID()==Class_ID(TCBINTERP_POSITION_CLASS_ID,0) ||
		    cont->ClassID()==Class_ID(TCBINTERP_ROTATION_CLASS_ID,0) ||
    		cont->ClassID()==Class_ID(TCBINTERP_SCALE_CLASS_ID,0));
}

// gdf Get the tranform matrix that take a point from its local coordinate
// system to it's parent's coordinate system
static Matrix3
GetLocalNodeTM(INode* node, TimeValue t)
{
    Matrix3 tm(TRUE);
    if (node) {
        tm = node->GetNodeTM(t);
        if (!node->GetParentNode()->IsRootNode()) {
            Matrix3 ip = Inverse(node->GetParentNode()->GetNodeTM(t));
            tm = tm * ip;
        }
    }
    return tm;
}

// gdf remove the offset effects of the parent from the child.
static BOOL
UndoParentsOffset(INode* node, Point3& pt, Quat& rOff)
{
    INode* parent;
    Matrix3 mat(TRUE);
    Quat pOff;
    if (node && pt && rOff) {
        if (!node->GetParentNode()->IsRootNode()) {
            parent = node->GetParentNode();
            pOff   = parent->GetObjOffsetRot();
            if (pOff == IdentQuat()) return FALSE;
            pOff.MakeMatrix(mat);
            mat   = Inverse(mat);
            pt    = VectorTransform(mat, pt);
            rOff  = rOff/pOff;
            return TRUE;
        }
    }
    return FALSE;
}

// gdf get the file info before adding chunk
void
WriteChunkBegin(unsigned short cTag, long& cPtr, long& cBegin)
{
    cBegin = ftell(wstream);
    fwrite((char *) &cTag, 1, sizeof(SHORT), wstream);
    cPtr = ftell(wstream);
    fwrite((char *) &cPtr, 1, sizeof(LONG), wstream);
}
    
// gdf fixup the chunk header.
void
WriteChunkEnd(long& cPtr, long& cBegin)
{
    long cPos;
    long cSize;
    cPos = ftell(wstream);
    fseek(wstream, cPtr, SEEK_SET);
    cSize = cPos - cBegin;
    fwrite((char *) &cSize, 1, sizeof(LONG), wstream);
    fseek(wstream, cPos, SEEK_SET);
}

// gdf write a TCB PRS track
static BOOL
WriteTCBKeysChunk(INode* node, Control* cont, int type)
{
    IKeyControl*    ikeys;
	ITCBPoint3Key   pkey;
	ITCBRotKey      rkey;
	ITCBScaleKey    skey;
	ITCBKey*        k;
    Quat qLast = IdentQuat();
    int num = cont->NumKeys();
    Point3 firstpKey;
	
 // Get the keyframe interface to the TCB Controller
	ikeys = GetKeyControlInterface(cont);

 // Gotta have some keys
	if (num == NOT_KEYFRAMEABLE || num == 0 || !ikeys) {
	    return FALSE;
	}

 // Set up 'k' to point at the right derived class
	switch (type)
    {
		case KEY_POS:   k = &pkey; break;
		case KEY_ROT:   k = &rkey; break;
		case KEY_SCL:   k = &skey; break;
		default:        assert(FALSE);
	}

 // Write track some stuff
    short trackflags = 0;
    WRSHORT(&trackflags);
    long lwork = cont->GetKeyTime(0)/GetTicksPerFrame();
    WRLONG(&lwork);
    lwork = cont->GetKeyTime(num-1)/GetTicksPerFrame();
    WRLONG(&lwork);
    long nkeys = num;
    WRLONG(&nkeys);

    for (int i = 0; i < num; i++) {
        ikeys->GetKey(i,k);

     // Write key time
		long keytime = k->time/GetTicksPerFrame();
		WRLONG(&keytime);

	 // Write flags
		short wflags = 0;
		if (k->tens   != 0.0f) wflags |= W_TENS;
		if (k->cont   != 0.0f) wflags |= W_CONT;
		if (k->bias   != 0.0f) wflags |= W_BIAS;
		if (k->easeIn != 0.0f) wflags |= W_EASETO;
		if (k->easeOut!= 0.0f) wflags |= W_EASEFROM;			
		WRSHORT(&wflags);

     // Write TCB and ease
		if (k->tens   != 0.0f) WRFLOAT(&k->tens);
		if (k->cont   != 0.0f) WRFLOAT(&k->cont);
		if (k->bias   != 0.0f) WRFLOAT(&k->bias);
		if (k->easeIn != 0.0f) WRFLOAT(&k->easeIn);
		if (k->easeOut!= 0.0f) WRFLOAT(&k->easeOut);

	 // Write values
		switch (type)
        {
			case KEY_POS:
                {
                    if (!node->GetParentNode()->IsRootNode()) {
                        if (!(node->GetParentNode()->GetObjOffsetRot() == IdentQuat())) {
                            Quat q;
                            UndoParentsOffset(node, pkey.val, q);
                        }
                    }
                    WRFLOAT(&pkey.val.x);
			        WRFLOAT(&pkey.val.y);
			        WRFLOAT(&pkey.val.z);
                }
				break;

            case KEY_ROT:
                {
                    if (i) {
                        WRFLOAT(&rkey.val.angle);
			            WRFLOAT(&rkey.val.axis.x);
                        WRFLOAT(&rkey.val.axis.y);
                        WRFLOAT(&rkey.val.axis.z);
                    } else {
                        AngAxis aa;
                        Quat qkey = QFromAngAxis(rkey.val.angle, rkey.val.axis);
                     // remove the pivot's rotation
                        Quat qOff = qkey / Inverse(node->GetObjOffsetRot());
                     // remove the parents rotation
                        if (!node->GetParentNode()->IsRootNode()) {
                            if (!(node->GetParentNode()->GetObjOffsetRot() == IdentQuat())) {
                                Point3 p;
                                UndoParentsOffset(node, p, qOff);
                            }
                        }

                        AngAxisFromQ(qOff, &aa.angle, aa.axis);
                        WRFLOAT(&aa.angle);
			            WRFLOAT(&aa.axis.x);
                        WRFLOAT(&aa.axis.y);
                        WRFLOAT(&aa.axis.z);
                    }
                }
            	break;

            case KEY_SCL:
				WRFLOAT(&skey.val.s.x);
				WRFLOAT(&skey.val.s.y);
				WRFLOAT(&skey.val.s.z);
				break;
		}
    }
	return TRUE;
}

// gdf sample frame and write PRS track.  do some very trivial key reduction
static BOOL
WriteLinearKeysChunk(INode* node, int type)
{
    Point3 pval;
	AngAxis rval;
	ScaleValue sval;
	Interval valid;
	
    int i;
    Matrix3 tm;
    TimeValue t;
    AffineParts parts;
    Quat q, qLast;
    Point3 s, sLast, p;
    AngAxis a;

 // Tables of keyframe values
    Tab<Point3>     pKeys;
    Tab<TimeValue>  pFrames;
    Tab<AngAxis>    rKeys;
    Tab<TimeValue>  rFrames;
    Tab<Point3>     sKeys;
    Tab<TimeValue>  sFrames;
    
    TimeValue start = theSceneEnum->i->GetAnimRange().Start();
    TimeValue end   = theSceneEnum->i->GetAnimRange().End();
    TimeValue frames = (end - start)/GetTicksPerFrame();
    frames++;

    BOOL* used = new BOOL[frames];

    if (type && KEY_POS) {
        pKeys.SetCount(frames);
        pFrames.SetCount(frames);
    }
    if (type && KEY_ROT) {
        rKeys.SetCount(frames);
        rFrames.SetCount(frames);
    }
    if (type && KEY_SCL) {
        sKeys.SetCount(frames);
        sFrames.SetCount(frames);
    }

    qLast = IdentQuat();
 // Sample the control at every frame
    for (i = 0, t = start; i < frames; i++, t += GetTicksPerFrame()) {
        tm = GetLocalNodeTM(node, t);
        decomp_affine(tm, &parts);
        s = ScaleValue(parts.k, parts.u).s;
        if (parts.f < 0.0f) s = - s;
        p = parts.t;
        q = parts.q;
        a = AngAxis(q / qLast);
        qLast = q;

        switch (type)
        {
            case KEY_POS: 
                {
                    Point3 pkey = parts.t;
                    if (!node->GetParentNode()->IsRootNode()) {
                        if (!(node->GetParentNode()->GetObjOffsetRot() == IdentQuat())) {
                            Quat q;
                            UndoParentsOffset(node, pkey, q);
                        }
                    }
                    pKeys[i] = pkey;
                    pFrames[i] = i;
                }
               	break;

			case KEY_SCL:
                sKeys[i] = s;
                sFrames[i] = i;
    			break;

            case KEY_ROT:
                {
                    if (i) {
                        rKeys[i] = a;
                        rFrames[i] = i;
                    } else {
                        AngAxis aa;
                        Quat qkey = parts.q;
                     // remove the pivot's rotation
                        Quat qOff = qkey / Inverse(node->GetObjOffsetRot());
                     // remove the parents rotation
                        if (!node->GetParentNode()->IsRootNode()) {
                            if (!(node->GetParentNode()->GetObjOffsetRot() == IdentQuat())) {
                                Point3 p;
                                UndoParentsOffset(node, p, qOff);
                            }
                        }
                        AngAxisFromQ(qOff, &aa.angle, aa.axis);
                        rKeys[i] = aa;
                        rFrames[i] = i;
                    }
                }
                break;
		}
    }

 // reduce the keys
    if (frames >= 3) {
        for (i = 0; i < frames; i++) used[i];
        Point3 pPt0, qPt0;
        AngAxis pA0, qA0; 
        for (i = 1; i < frames; i++) {
            switch (type)
            {
                case KEY_POS:
                    pPt0 = pKeys[i];
                    qPt0 = pKeys[i - 1];
                    if (ApproxEqual(pPt0.x, qPt0.x) &&
                        ApproxEqual(pPt0.y, qPt0.y) &&
                        ApproxEqual(pPt0.z, qPt0.z))
                        used[i] = FALSE;
                    else {
                        used[i - 1] = TRUE;
                    }
               	    break;

			    case KEY_SCL:
                    pPt0 = sKeys[i];
                    qPt0 = sKeys[i - 1];
                    if (ApproxEqual(pPt0.x, qPt0.x) &&
                        ApproxEqual(pPt0.y, qPt0.y) &&
                        ApproxEqual(pPt0.z, qPt0.z))
                        used[i] = FALSE;
                    else {
                        used[i - 1] = TRUE;
                    }
                    break;

                case KEY_ROT:
                    pA0 = rKeys[i];
                    qA0 = rKeys[i - 1];
                    if (ApproxEqual(pA0.axis.x, qA0.axis.x) &&
                        ApproxEqual(pA0.axis.x, qA0.axis.x) &&
                        ApproxEqual(pA0.axis.x, qA0.axis.x) &&
                        ApproxEqual(pA0.angle,  qA0.angle))
                        used[i] = FALSE;
                    else {
                        used[i - 1] = TRUE;
                    }
                    break;
		    }
        }

        int j = 0;
        for (i = 0; i < frames; i++) {
            if (used[i]) j++;
        }

        j = 0;
        for (i = 0; i < frames; i++) {
            if (used[i]) {
                switch (type)
                {
                    case KEY_POS:
                        pKeys[j] = pKeys[i];
                        pFrames[j] = pFrames[i];
                        j++;
               	    break;

    			    case KEY_SCL:
                        sKeys[j] = sKeys[i];
                        sFrames[j] = sFrames[i];
                        j++;
           			break;

                    case KEY_ROT:
                        rKeys[j] = rKeys[i];
                        rFrames[j] = rFrames[i];
                        j++;
                    break;
		        }

            }
        }
        switch (type)
        {
            case KEY_POS:
                pKeys.SetCount(j);
                pFrames.SetCount(j);
                break;

    	    case KEY_SCL:
                sKeys.SetCount(j);
                sFrames.SetCount(j);
       			break;

            case KEY_ROT:
                rKeys.SetCount(j);
                rFrames.SetCount(j);
                break;
        }

        delete [] used;
    }

 // Write trackheader stuff
    short trackflags = 0;
    WRSHORT(&trackflags);
    long lwork = 0;
    WRLONG(&lwork);
    lwork = frames - 1;   //gdf FIXME "0"
    WRLONG(&lwork);

    switch (type) 
    {
        case KEY_POS:
            {
                long nkeys = pFrames.Count();
                WRLONG(&nkeys);
             // write the keys
                for (i = 0; i < pFrames.Count(); i++) {
                    WRLONG(&pFrames[i]);
                 // Write flags
		            short wflags = 0;			
		            WRSHORT(&wflags);
	             // Write values
                    WRFLOAT(&pKeys[i].x);
                    WRFLOAT(&pKeys[i].y);
                    WRFLOAT(&pKeys[i].z);
                }
            }
           	break;

        case KEY_SCL:
            {
                long nkeys = sFrames.Count();
                WRLONG(&nkeys);
             // write the keys
                for (i = 0; i < sFrames.Count(); i++) {
                    WRLONG(&sFrames[i]);
                 // Write flags
		            short wflags = 0;			
		            WRSHORT(&wflags);
	             // Write values
                    WRFLOAT(&sKeys[i].x);
                    WRFLOAT(&sKeys[i].y);
                    WRFLOAT(&sKeys[i].z);
                }
            }
            break;

        case KEY_ROT:
            {
                long nkeys = rFrames.Count();
                WRLONG(&nkeys);
             // write the keys
                for (i = 0; i < rFrames.Count(); i++) {
                    WRLONG(&rFrames[i]);
                 // Write flags
		            short wflags = 0;			
		            WRSHORT(&wflags);
	             // Write values
                    WRFLOAT(&rKeys[i].angle);
			        WRFLOAT(&rKeys[i].axis.x);
			        WRFLOAT(&rKeys[i].axis.y);
			        WRFLOAT(&rKeys[i].axis.z)
                }
            }
            break;
    }
	return TRUE;
}

// gdf write the tracks
static BOOL
WriteController(INode* node) {

    Interval valid;
    TimeValue start = theSceneEnum->i->GetAnimRange().Start();
    unsigned short cTag;
    long cPtr;
    long cBegin;

    int Track_Flags;
    int Force_Keys;

    Class_ID cid;
    
    Control* cpos = node->GetTMController()->GetPositionController();
	Control* crot = node->GetTMController()->GetRotationController();
	Control* cscl = node->GetTMController()->GetScaleController();

    cid = node->GetTMController()->ClassID();
    if (cid == Class_ID(PRS_CONTROL_CLASS_ID, 0)) {
        assert(cpos && crot && cscl);
        Track_Flags = 0;
        Force_Keys  = 0;
     // this is a special case (path controller) modifies both pos and rot
        Class_ID cID = cpos->ClassID();
        if (cID == Class_ID(HYBRIDINTERP_COLOR_CLASS_ID, 0)) Force_Keys |= KEYS_ROT;
    } else {
     // if it's not a PRS controller (transform controller) try to write PRS
        Track_Flags = KEYS_POS | KEYS_ROT | KEYS_SCL;
        Force_Keys  = 0;
    }

 // write POSITION Track keys
    cTag = POS_TRACK_TAG;
    WriteChunkBegin(cTag, cPtr, cBegin);
    if (!cpos || (Force_Keys & KEYS_POS)) {
     // this is a transform controller that doesn't support
     // support GetPositionController()
        if (WriteLinearKeysChunk(node, KEY_POS)) {
            Track_Flags &= ~KEYS_POS;
        }
	} else {
        if (NeedsKeys(cpos->NumKeys()) || (Track_Flags & KEYS_POS)) {
            if (IsTCBControl(cpos)) {
                if (WriteTCBKeysChunk(node, cpos, KEY_POS)) {
                    Track_Flags &= ~KEYS_POS;
                }
            } else {
                if (WriteLinearKeysChunk(node, KEY_POS)) {
                    Track_Flags &= ~KEYS_POS;
                }
            }
        } else {
            Point3 pkey;
            cpos->GetValue(start, &pkey, valid);
            if (!node->GetParentNode()->IsRootNode()) {
                if (!(node->GetParentNode()->GetObjOffsetRot() == IdentQuat())) {
                    Quat q;
                    UndoParentsOffset(node, pkey, q);
                }
            }
            
            if (!WriteStd1KeyHdr()) return 0;
            WRFLOAT(&pkey.x);
			WRFLOAT(&pkey.y);
			WRFLOAT(&pkey.z);
            Track_Flags &= ~KEYS_POS;
		}
     
    }
    WriteChunkEnd(cPtr, cBegin);

 // write ROTATION Track keys
    cTag = ROT_TRACK_TAG;
    WriteChunkBegin(cTag, cPtr, cBegin);
    if (!crot || (Force_Keys & KEYS_ROT)) {
     // this is a transform controller that doesn't support
	 // support GetRotationController()
        if (WriteLinearKeysChunk(node, KEY_ROT)) {
            Track_Flags &= ~KEYS_ROT;
        }
	} else {
        if (NeedsKeys(crot->NumKeys()) || (Track_Flags & KEYS_ROT)) {
            if (IsTCBControl(crot)) {
                if (WriteTCBKeysChunk(node, crot, KEY_ROT)) {
                    Track_Flags &= ~KEYS_ROT;
                }
            } else {
                if (WriteLinearKeysChunk(node, KEY_ROT)) {
                   Track_Flags &= ~KEYS_ROT;
                }
            }
        } else {
            Quat rkey;
            AngAxis aa;
            crot->GetValue(start, &rkey, valid);
         // remove the pivot's rotation
            Quat qOff = rkey / Inverse(node->GetObjOffsetRot());
         // remove the parents rotation
            if (!node->GetParentNode()->IsRootNode()) {
                if (!(node->GetParentNode()->GetObjOffsetRot() == IdentQuat())) {
                    Point3 p;
                    UndoParentsOffset(node, p, qOff);
                }
            }
            if (!WriteStd1KeyHdr()) return 0;
            AngAxisFromQ(qOff, &aa.angle, aa.axis);
            WRFLOAT(&aa.angle);
			WRFLOAT(&aa.axis.x);
            WRFLOAT(&aa.axis.y);
            WRFLOAT(&aa.axis.z);
			Track_Flags &= ~KEYS_ROT;
	    }
    }
    WriteChunkEnd(cPtr, cBegin);

 // write SCALE Track keys    
    cTag = SCL_TRACK_TAG;
    WriteChunkBegin(cTag, cPtr, cBegin);

    if (!cscl || (Force_Keys & KEYS_SCL)) {
     // this is a transform controller that doesn't support
	 // support GetScaleController()
        if (WriteLinearKeysChunk(node, KEY_SCL)) {
            Track_Flags &= ~KEYS_SCL;
        }
	} else {
        if (NeedsKeys(cscl->NumKeys()) || (Track_Flags & KEYS_SCL)) {
            if (IsTCBControl(cscl)) {
                if (WriteTCBKeysChunk(node, cscl, KEY_SCL)) {
                    Track_Flags &= ~KEYS_SCL;
                }
            } else {
                if (WriteLinearKeysChunk(node, KEY_SCL)) {
                    Track_Flags &= ~KEYS_SCL;
                }
            }
        } else {
            ScaleValue skey;
            cscl->GetValue(start, &skey, valid);
            if (!WriteStd1KeyHdr()) return 0;
            WRFLOAT(&skey.s.x);
		    WRFLOAT(&skey.s.y);
		    WRFLOAT(&skey.s.z);
            Track_Flags &= ~KEYS_SCL;
	    }
    }
    WriteChunkEnd(cPtr, cBegin);
    
    return TRUE;
}

// gdf convert MAX UVFaces into .3ds faces by adding extra 3ds verts
// this is just to get the data into .3ds
void
ConvertTo3DSFaces(ObjectEntry* oe, Tab<Vert3ds>& verts, Tab<Face3ds>& faces)
{
    Face3ds tmpFace;
    Vert3ds tmpVert;
    Mesh mesh = oe->tri->GetMesh();
    int numVerts = ((mesh.getNumVerts() < 65535) ? mesh.getNumVerts() : 65535);
 
	BitArray vWritten;
    vWritten.SetSize(mesh.getNumVerts());
    vWritten.ClearAll();

    verts.SetCount(mesh.getNumVerts());
    faces.SetCount(mesh.getNumFaces());

	for (int i = 0; i < mesh.getNumFaces(); i++) {
        Face   face   = mesh.faces[i];
        TVFace tvFace = mesh.tvFace[i];

        for (int k = 0; k < 3; k++) {
            tmpFace.vNum[k] = face.v[k];
        }
        tmpFace.flags = face.flags;

        for (int j = 0; j < 3; j++) {
            UVVert tVert = mesh.tVerts[tvFace.t[j]];
            Point3 vert  = mesh.verts[face.v[j]];
            tmpVert.pt    = vert;
            tmpVert.tv    = tVert;

            if (vWritten[face.v[j]]) {
                if (!UVVertEqual(verts[face.v[j]].tv, tmpVert.tv)) {
                    tmpFace.vNum[j] = verts.Count();
                    verts.Insert(verts.Count(), 1, &tmpVert);
                }
            } else {
                verts[face.v[j]] = tmpVert;
                vWritten.Set(face.v[j]);
            }
        }

        faces[i] = tmpFace;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\aieres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by aiexp.rc
//
#define IDS_TH_3DSTUDIO                 40216
#define IDS_TH_ADOBE                    40220
#define IDS_TH_AIFILE                   40221
#define IDS_TH_TOM_HUDSON               40222
#define IDS_TH_COPYRIGHT_YOST_GROUP     40223
#define IDS_TH_AIEXP                    40229
#define IDS_TH_SCENEEXPORT              40231
#define IDS_TH_AIEXPORTDLL              40232
#define IDS_TH_NODATATOEXPORT           40233
#define IDS_TH_CANTCREATE               40234
#define IDS_TH_WRITEERROR               40235
#define IDS_EIGHT_DOT_THREE             40248
#define IDS_ADOBE1                      40249
#define IDS_ADOBE2                      40250
#define IDS_ADOBE3                      40251
#define IDS_ADOBE4                      40252
#define IDS_ADOBE5                      40253
#define IDS_ADOBE6                      40254
#define IDS_ADOBE7                      40255
#define IDS_ADOBE8                      40256
#define IDS_ADOBE9                      40257
#define IDS_ADOBE10                     40258
#define IDS_ADOBE11                     40259
#define IDS_ADOBE12                     40260
#define IDS_ADOBE13                     40261
#define IDS_ADOBE14                     40262
#define IDS_ADOBE15                     40263
#define IDS_ADOBE16                     40264
#define IDS_ADOBE17                     40265
#define IDS_ADOBE18                     40266
#define IDS_ADOBE19                     40267
#define IDS_ADOBE20                     40268

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\3dsshape.h ===
/* Shape work stuff & defines */

#ifndef _SHAPE_H_DEFINED

/* Shape info flag bit meanings */

#define SHPTICKS 1	/* Shape displayed with ticks on control pts */
#define SHPMODI 2	/* Shape uses MODICOUNT for steps */

/* Define edge flag bit meanings */

#define BRIDGE 4
#define SPLICE 2
#define VISEDGE 1

/* Template flag bit meanings */

#define TMPEND 0x0001		/* Last vertex of template polygon */
#define TMPCLOSED 0x0002	/* Template polygon closed */
#define TMPCTL 0x0004		/* Vertex is spline control pt */
#define TMPSMOOTH 0x0008	/* Vertex is smoothed */
#define TMPLINEAR 0x0010	/* Linear vertex on span */
#define TMPCSPAN 0x0020		/* Closing span */

#define TMPENDOFF 0xFFFE	/* Last vertex of template polygon */
#define TMPCLSOFF 0xFFFD	/* Template polygon closed */
#define TMPCTLOFF 0xFFFB	/* Vertex is spline control pt */
#define TMPSMOFF 0xFFF7		/* Vertex is smoothed */
#define TMPLINOFF 0xFFEF	/* Linear vertex on span */
#define TMPCSPOFF 0xFFDF	/* Closing span */

#undef POLYBOOL
#undef POLYINSIDE
#undef POLYOUTSIDE

/* Shape flags bit meanings */

#define POLYEND	0x0001		/* Set for last point in shape */
#define POLYCLOSED 0x0002	/* Set in last point to indicate closed poly */
#define POLYSPAN 0x0004		/* Span draw required */
#define POLYFLAG 0x0008		/* Misc-use flag */
#define POLYA	0x0010		/* Group A select bit */
#define POLYB	0x0020		/* Group B select bit */
#define POLYC	0x0040		/* Group C select bit */
#define POLYALL	0x0080		/* Entire poly selected bit */
#define POLYSHP	0x0100		/* Poly is part of shape bit */
#define POLYSTART 0x0200	/* Set for 1st control pt in poly */
#define POLYBOOL 0x0400		/* Boolean-created vertex */
#define POLYINSIDE 0x0800	/* Boolean: Inside other poly */
#define POLYOUTSIDE 0x1000	/* Boolean: Outside other poly */
#define POLYFROZEN 0x2000	/* Polygon is frozen */

#define POLYENDOFF 0xFFFE	/* Bitmask to turn off end flag */
#define POLYCLSOFF 0xFFFD	/* Bitmask to turn off closed flag */
#define POLYSPANOFF 0xFFFB	/* Bitmask to turn off span flag */
#define POLYFLAGOFF 0xFFF7	/* Bitmask to turn off selected flag */
#define POLYAOFF 0xFFEF		/* Group A select bit off */
#define POLYBOFF 0xFFDF		/* Group B select bit off */
#define POLYCOFF 0xFFBF		/* Group C select bit off */
#define POLYALLOFF 0xFF7F	/* Entire poly selected bit off */
#define POLYSHPOFF 0xFEFF	/* Poly is part of shape bit off */
#define POLYSTARTOFF 0xFDFF	/* 1st control pt in poly off */
#define POLYBOOLOFF 0xFBFF	/* Boolean-created vertex off */
#define POLYINSIDEOFF 0xF7FF	/* Boolean: Inside other poly off */
#define POLYOUTSIDEOFF 0x7FFF	/* Boolean: Outside other poly off */
#define POLYFROZENOFF 0xDFFF	/* Polygon is frozen off */

/* Spline open/closed flags */

#define NULLSPLINE -1	/* Partial segment */
#define OPEN 0		/* Open spline */
#define CLOSED 1	/* Closed spline */

#endif

#define _SHAPE_H_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\aiimp.cpp ===
/**********************************************************************
 *<
	FILE: aiimp.cpp

	DESCRIPTION:  .AI file import module

	CREATED BY: Tom Hudson

	HISTORY: created 28 June 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "Max.h"
#include <stdio.h>
#include <direct.h>
#include <commdlg.h>
#include "splshape.h"
#include "aires.h"
#include "imtl.h"
#include "aiimp.h"
#include "istdplug.h"
#include "stdmat.h"

HINSTANCE hInstance;

static BOOL showPrompts;

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}


static int MessageBox(int s1, int s2, int option = MB_OK) {
	TSTR str1(GetString(s1));
	TSTR str2(GetString(s2));
	return MessageBox(GetActiveWindow(), str1, str2, option);
	}

static int MessageBox2(int s1, int s2, int option = MB_OK) {
	TSTR str1(GetString(s1));
	TSTR str2(GetString(s2));
	return MessageBox(GetActiveWindow(), str1, str2, option);
	}

static int MessageBox(TCHAR *s, int s2, int option = MB_OK) {
	TSTR str1(s);
	TSTR str2(GetString(s2));
	return MessageBox(GetActiveWindow(), str1, str2, option);
	}


//#define DBGPRINT


// The file stream

static FILE *stream;

// The debugging dump stream

static FILE *dStream;

// Some stuff we're defining (for now)

static BOOL replaceScene =0;

void
split_fn(char *path,char *file,char *pf)
	{
	int ix,jx,bs_loc,fn_loc;
	if(strlen(pf)==0) {
		if(path) *path=0;
		if(file) *file=0;
		return;
		}
	bs_loc=strlen(pf);
	for(ix=bs_loc-1; ix>=0; --ix) {
		if(pf[ix]=='\\')  {
			bs_loc=ix;
			fn_loc=ix+1;
			goto do_split;
			}
		if(pf[ix]==':') {
			bs_loc=ix+1;
			fn_loc=ix+1;
			goto do_split;
			}
		}
	bs_loc= -1;
	fn_loc=0;

	do_split:
	if(file)
		strcpy(file,&pf[fn_loc]);
	if(path) {
		if(bs_loc>0)  {
			for(jx=0; jx<bs_loc; ++jx)
				path[jx]=pf[jx];
			path[jx]=0;
			}
		else  path[0]=0;
		}
	}


//===========================================================


// Handy pointers to importers
AIShapeImport *theShapeImport = NULL;

// Jaguar interface code

int controlsInit = FALSE;

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();
		}
	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			//MessageBox(NULL,_T("AIIMP.DLL: DllMain"),_T("AIIMP"),MB_OK);
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------

class AIShapeClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new AIShapeImport; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_AISHAPE); }
	SClass_ID		SuperClassID() { return SCENE_IMPORT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(2,2); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SCENEIMPORT); }
	};

static AIShapeClassDesc AIShapeDesc;

// Statics

int	AIShapeImport::importType = SINGLE_SHAPE;

//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_TH_AIIMPORTDLL); }

__declspec( dllexport ) int
LibNumberClasses() { return 1; }

__declspec( dllexport ) ClassDesc *
LibClassDesc(int i) {
	switch(i) {
		case 0: return &AIShapeDesc; break;
		default: return 0; break;
		}

	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

//
// .3DS import module functions follow:
//

AIShapeImport::AIShapeImport() {
	splShape = NULL;
	shape = NULL;
	shapeNumber = 1;		// For name index
	}

AIShapeImport::~AIShapeImport() {
	}

int
AIShapeImport::ExtCount() {
	return 1;
	}

const TCHAR *
AIShapeImport::Ext(int n) {		// Extensions supported for import/export modules
	switch(n) {
		case 0:
			return _T("AI");
		}
	return _T("");
	}

const TCHAR *
AIShapeImport::LongDesc() {			// Long ASCII description (i.e. "Targa 2.0 Image File")
	return GetString(IDS_TH_AISHAPEFILE);
	}
	
const TCHAR *
AIShapeImport::ShortDesc() {			// Short ASCII description (i.e. "Targa")
	return GetString(IDS_TH_ADOBE_ILLUSTRATOR);
	}

const TCHAR *
AIShapeImport::AuthorName() {			// ASCII Author name
	return GetString(IDS_TH_TOM_HUDSON);
	}

const TCHAR *
AIShapeImport::CopyrightMessage() {	// ASCII Copyright message
	return GetString(IDS_TH_COPYRIGHT_YOST_GROUP);
	}

const TCHAR *
AIShapeImport::OtherMessage1() {		// Other message #1
	return _T("");
	}

const TCHAR *
AIShapeImport::OtherMessage2() {		// Other message #2
	return _T("");
	}

unsigned int
AIShapeImport::Version() {				// Version number * 100 (i.e. v3.01 = 301)
	return 100;
	}

void
AIShapeImport::ShowAbout(HWND hWnd) {			// Optional
 	}

/* Get a null-terminated string from the file */

int
read_string(char *string,FILE *stream,int maxsize)
{
while(maxsize--)
 {
 RDERR(string,1);
 if(*(string++)==0)
  return(1);
 }
return(0);	/* Too long */
}

static int shapeButtons[] = { IDC_SINGLEOBJECT, IDC_MULTIPLEOBJECTS };
#define NUM_SHAPEBUTTONS 2

static BOOL CALLBACK
ShapeImportOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
	static AIShapeImport *imp;

	switch(message) {
		case WM_INITDIALOG:
			imp = (AIShapeImport *)lParam;
			CheckDlgButton( hDlg, shapeButtons[imp->importType], TRUE);
			CenterWindow(hDlg,GetParent(hDlg));
			return TRUE;
		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDOK: {
					// Unload values into AIShapeImport statics
					for(int i = 0; i < NUM_SHAPEBUTTONS; ++i) {
						if(IsDlgButtonChecked(hDlg, shapeButtons[i])) {
							imp->importType = i;
							break;
							}
						}
					EndDialog(hDlg, 1);
					}
					return TRUE;
				case IDCANCEL:
					EndDialog(hDlg, 0);
					return TRUE;
			}
		}
	return FALSE;
	}

/* Get a line terminated with a CR/LF			*/
/* Returns 0 if EOF, 1 if OK, -1 if string too long	*/
/* Null-terminates the string at the CR			*/
/* Optionally squashes spaces out of non-quoted areas	*/

/*static*/ int
getaline(FILE *stream,char *string,int max,int squash)
{
char ch;
int count,gotquote;

count=gotquote=0;
while(1) {
	RDERR(&ch,1);
	if(ch==10) {
		*string = 0;
		return 1;
		}
	else {
		if(ch!=' ' || squash==0 || gotquote) {
			if(ch==34)	/* Quote */
				gotquote=1-gotquote;
		
			if((++count)>max) {
				*(string-1)=0;
				return(-1);
				}
			if(ch==13) {
				*string=0;
				return(1);
				}
			*string++=ch;
			}
		}
	}
}

BOOL AIShapeImport::StartWorkingShape() {
	spline = NULL;
	if(!splShape) {
		splShape = new SplineShape;
		if(!splShape)
			return FALSE;
		shape = &splShape->GetShape();
		shape->NewShape();	// Clean out the shape
		}
	if(!shape) {
		assert(0);
		return FALSE;
		}
	spline = shape->NewSpline();
	if(!spline)
		return FALSE;
	return TRUE;
	}

BOOL AIShapeImport::FinishWorkingShape(BOOL forceFinish, ImpInterface *i) {
	// If nothing going on, forget the whole thing and return success
	if(!splShape)
		return TRUE;
	if(!shape) {
		assert(0);
		return FALSE;
		}
	// Otherwise, see if the current spline is closed
	if(spline) {
		int knots = spline->KnotCount();
		// If not a valid spline, get rid of it!
		if(knots < 2) {
			singularity:
//			DebugPrint("WARN: spline w/%d points\n",knots);
			shape->UpdateSels();	// Make sure it readies the selection set info
			shape->DeleteSpline(shape->SplineCount() - 1);
			spline = NULL;
			}
		else {
			int lastKnot = knots-1;
			if(spline->GetKnotPoint(0) == spline->GetKnotPoint(lastKnot)) {
				spline->SetInVec(0, spline->GetInVec(lastKnot));
				spline->DeleteKnot(lastKnot);
				if(spline->KnotCount() < 2)
					goto singularity;
				spline->SetClosed();
				}
			// Check to be sure knot types are correct -- The default is for
			// smooth beziers, but they may be corners
			for(int k = 0; k < knots; ++k) {
				Point3 in = spline->GetInVec(k);
				Point3 out = spline->GetOutVec(k);
				Point3 knot = spline->GetKnotPoint(k);
				int type = spline->GetKnotType(k);
				if(type == KTYPE_BEZIER) {
					if(in == knot && out == knot)	// If both zero length vector, it's a corner
						spline->SetKnotType(k, KTYPE_CORNER);
					else	// If vectors not collinear, it's a corner!
					if(in == knot || out == knot)	// If zero length vector, it's a bez corner
						spline->SetKnotType(k, KTYPE_BEZIER_CORNER);
					else {	// If vectors not collinear, it's a corner!
						Point3 normIn = Normalize(knot - in);
						Point3 normOut = Normalize(out - knot);
						Point3 lowtest = normIn * 0.98f;
						Point3 hightest = normIn * 1.02f;
						if(!(((normOut.x >= lowtest.x && normOut.x <= hightest.x) || (normOut.x <= lowtest.x && normOut.x >= hightest.x)) && 
						   ((normOut.y >= lowtest.y && normOut.y <= hightest.y) || (normOut.y <= lowtest.y && normOut.y >= hightest.y)) && 
						   ((normOut.z >= lowtest.z && normOut.z <= hightest.z) || (normOut.z <= lowtest.z && normOut.z >= hightest.z))))
							spline->SetKnotType(k, KTYPE_BEZIER_CORNER);
						}
					}
				}
			spline->ComputeBezPoints();
			}
		}
	// If necessary, create the object
	if(importType == MULTIPLE_SHAPES || forceFinish) {
		if(shape->SplineCount()) {
			shape->UpdateSels();	// Make sure it readies the selection set info
			shape->InvalidateGeomCache();
			// create shape object
			ImpNode *node = i->CreateNode();
			if(!node)
				return FALSE;
			node->Reference(splShape);
			Matrix3 tm(1);
			Box3 bbox = shape->GetBoundingBox();
			Point3 center = Point3(bbox.Center().x, bbox.Center().y, 0.0f);
			tm.SetTrans(center);	// TH 7/5/96
			node->SetPivot(-center);	// TH 3/9/99
			node->SetTransform(0,tm);
			i->AddNodeToScene(node);
			TSTR name;
			name.printf(GetString(IDS_TH_SHAPE_NUM),theShapeImport->shapeNumber++);
			node->SetName(name);
			gotStuff = TRUE;
			}
		// Reset the shape stuff
		splShape = NULL;
		shape = NULL;
		spline = NULL;
		}
	return TRUE;
	}

static TCHAR decimalSymbol = _T('.');

static void GetDecSymbolFromRegistry() {
    HKEY hKey;
    DWORD dwType, numBytes;
	long status;
    unsigned char symbol[80];
	status = RegOpenKeyEx (HKEY_CURRENT_USER, 
		      "Control Panel\\International", 
		      0, KEY_READ, &hKey);
    if (status == ERROR_SUCCESS) {
		if (ERROR_SUCCESS==RegQueryValueEx (hKey, "sDecimal", 0, &dwType, 
			 symbol, &numBytes))
			decimalSymbol = symbol[0];
	    }
	}

TCHAR *FixDecimalSymbol(TCHAR *buf)
	{
	TCHAR *cp = buf;
	while(*cp) {
		if( *cp == _T('.'))
			*cp = decimalSymbol;
		cp++;
		}
	return buf;
	}

static BOOL CALLBACK
ImportDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
	switch(message) {
		case WM_INITDIALOG:
			CheckRadioButton( hDlg, IDC_AI_MERGE, IDC_AI_REPLACE, replaceScene?IDC_AI_REPLACE:IDC_AI_MERGE );
			CenterWindow(hDlg,GetParent(hDlg));
			SetFocus(hDlg); // For some reason this was necessary.  DS-3/4/96
			return FALSE;
		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDOK: {
	            	replaceScene = IsDlgButtonChecked(hDlg,IDC_3DS_REPLACE);
					EndDialog(hDlg, 1);
					}
					return TRUE;
				case IDCANCEL:
					EndDialog(hDlg, 0);
					return TRUE;
			}
		}
	return FALSE;
	}

int
AIShapeImport::DoImport(const TCHAR *filename,ImpInterface *i,Interface *gi, BOOL suppressPrompts) {
	// Get a scale factor from points (the file storage) to our units
	double mScale = GetMasterScale(UNITS_INCHES);
	float scaleFactor = float((1.0 / mScale) / 72.0);
	
	// Set a global prompt display switch
	showPrompts = suppressPrompts ? FALSE : TRUE;

	WorkFile theFile(filename,_T("rb"));

	if(suppressPrompts) {
		}
	else {
		if (!DialogBox(hInstance, MAKEINTRESOURCE(IDD_MERGEORREPL), gi->GetMAXHWnd(), ImportDlgProc))
			return IMPEXP_CANCEL;
		}

	dStream = i->DumpFile();

	if(!(stream = theFile.Stream())) {
		if(showPrompts)
			MessageBox(IDS_TH_ERR_OPENING_FILE, IDS_TH_3DSIMP);
		return 0;						// Didn't open!
		}

	// Got the file -- Now put up the options dialog!
	if(showPrompts) {
		int result = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_SHAPEIMPORTOPTIONS), gi->GetMAXHWnd(), ShapeImportOptionsDlgProc, (LPARAM)this);
		if(result <= 0)
			return IMPEXP_CANCEL;
		}
	else { // Set default parameters here
		importType = MULTIPLE_SHAPES;
		}

	if (replaceScene) {
		if (!i->NewScene())
			return IMPEXP_CANCEL;
		}

	theShapeImport = this;

	int line,count,status,phase,buflen, reason;
	float x1,y1,x2,y2,x3,y3;
	char buffer[256];

	phase=0;
	count=0;
	line=0;
	gotStuff = FALSE;

	GetDecSymbolFromRegistry();

	loop:
	line++;
	if((status=getaline(stream,buffer,255,0))<0)
		{
		reason = IDS_TH_LINE_TOO_LONG;

		corrupted:
		if(showPrompts)
			MessageBox(reason, IDS_TH_3DSIMP);
		FinishWorkingShape(TRUE, i);
		return gotStuff;
		}

	if(status==0) {
		FinishWorkingShape(TRUE, i);
		return gotStuff;	// EOF
		}

	/* Look for appropriate section of file */

	buflen=strlen(buffer);
	switch(phase)
		{
		case 0:	/* Looking for the path */
			buffer[10]=0;
			if(stricmp(buffer,"%%endsetup")==0)
				phase=1;
			break;
		case 1:	/* Loading the path data -- looking for initial 'm' */
			if(buflen<2)
				break;
			if(buffer[buflen-2]==' ' && buffer[buflen-1]=='m') {
				phase=2;
				goto phase2;
				}
			break;
		case 2:
			phase2:
			if(buflen<2)
				break;
			if(buffer[buflen-2]!=' ')
				break;
			switch(buffer[buflen-1]) {
				case 'm': {	/* Moveto */
					FixDecimalSymbol(buffer);
					if(sscanf(buffer,"%f %f",&x1,&y1)!=2) {
	#ifdef DBG1
	DebugPrint("Moveto buffer:%s\n",buffer);
	#endif
						bad_file:
						reason = IDS_TH_INVALIDFILE;
						goto corrupted;
						}
					// If had one working, wrap it up
					FinishWorkingShape(FALSE, i);
					// Start this new spline
					if(!StartWorkingShape()) {
						reason = IDS_TH_NO_RAM;
						goto corrupted;
						}
					Point3 p(x1 * scaleFactor, y1 * scaleFactor, 0.0f);
					SplineKnot k(KTYPE_BEZIER, LTYPE_CURVE, p, p, p);
					spline->AddKnot(k);
					}
					break;
				case 'l':	/* Lineto */
				case 'L': {	/* Lineto corner */
					FixDecimalSymbol(buffer);
					if(sscanf(buffer,"%f %f",&x1,&y1)!=2) {
	#ifdef DBG1
	DebugPrint("Lineto buffer:%s\n",buffer);
	#endif
						goto bad_file;
						}
					Point3 p(x1 * scaleFactor, y1 * scaleFactor, 0.0f);
					SplineKnot k(KTYPE_BEZIER, LTYPE_CURVE, p, p, p);
					spline->AddKnot(k);
					}
					break;
				case 'c':	/* Curveto */
				case 'C': {	/* Curveto corner */
					FixDecimalSymbol(buffer);
					if(sscanf(buffer,"%f %f %f %f %f %f",&x1,&y1,&x2,&y2,&x3,&y3)!=6) {
	#ifdef DBG1
	DebugPrint("Curveto buffer:%s\n",buffer);
	#endif
						goto bad_file;
						}
					int lastKnot = spline->KnotCount() - 1;
					spline->SetOutVec(lastKnot, Point3(x1 * scaleFactor, y1 * scaleFactor, 0.0f));
					Point3 p(x3 * scaleFactor, y3 * scaleFactor, 0.0f);
					Point3 in(x2 * scaleFactor, y2 * scaleFactor, 0.0f);
					SplineKnot k(KTYPE_BEZIER, LTYPE_CURVE, p, in, p);
					spline->AddKnot(k);
					}
					break;
				case 'v':	/* Current/vec */
				case 'V': {	/* Current/vec corner */
					FixDecimalSymbol(buffer);
					if(sscanf(buffer,"%f %f %f %f",&x2,&y2,&x3,&y3)!=4) {
	#ifdef DBG1
	DebugPrint("Current/vec buffer:%s\n",buffer);
	#endif
						goto bad_file;
						}
					Point3 p(x3 * scaleFactor, y3 * scaleFactor, 0.0f);
					Point3 in(x2 * scaleFactor, y2 * scaleFactor, 0.0f);
					SplineKnot k(KTYPE_BEZIER, LTYPE_CURVE, p, in, p);
					spline->AddKnot(k);
					}
					break;
				case 'y':	/* Vec/next */
				case 'Y': {	/* Vec/next corner */
					FixDecimalSymbol(buffer);
					if(sscanf(buffer,"%f %f %f %f",&x1,&y1,&x3,&y3)!=4) {
	#ifdef DBG1
	DebugPrint("vec/next buffer:%s\n",buffer);
	#endif
						goto bad_file;
						}
					int lastKnot = spline->KnotCount() - 1;
					spline->SetOutVec(lastKnot, Point3(x1 * scaleFactor, y1 * scaleFactor, 0.0f));
					Point3 p(x3 * scaleFactor, y3 * scaleFactor, 0.0f);
					SplineKnot k(KTYPE_BEZIER, LTYPE_CURVE, p, p, p);
					spline->AddKnot(k);
					}
					break;
				}
			break;
		}

	count++;
	goto loop;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\aiimp.h ===
/**********************************************************************
 *<
	FILE: aiimp.h

	DESCRIPTION:  .AI file import module header file

	CREATED BY: Tom Hudson

	HISTORY: created 28 June 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/


#define SINGLE_SHAPE 0
#define MULTIPLE_SHAPES 1

class AIShapeImport : public SceneImport {
	friend BOOL CALLBACK ShapeImportOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

public:
	static int		importType;
	BOOL			gotStuff;
	SplineShape *	splShape;
	BezierShape *	shape;
	Spline3D *		spline;
	int				shapeNumber;
					AIShapeImport();
					~AIShapeImport();
	int				ExtCount();					// Number of extensions supported
	const TCHAR *	Ext(int n);					// Extension #n (i.e. "3DS")
	const TCHAR *	LongDesc();					// Long ASCII description (i.e. "Autodesk 3D Studio File")
	const TCHAR *	ShortDesc();				// Short ASCII description (i.e. "3D Studio")
	const TCHAR *	AuthorName();				// ASCII Author name
	const TCHAR *	CopyrightMessage();			// ASCII Copyright message
	const TCHAR *	OtherMessage1();			// Other message #1
	const TCHAR *	OtherMessage2();			// Other message #2
	unsigned int	Version();					// Version number * 100 (i.e. v3.01 = 301)
	void			ShowAbout(HWND hWnd);		// Show DLL's "About..." box
	int				DoImport(const TCHAR *name,ImpInterface *i,Interface *gi, BOOL suppressPrompts=FALSE);	// Import file
	BOOL			StartWorkingShape();
	BOOL			FinishWorkingShape(BOOL forceFinish,ImpInterface *i);
	};

// Handy file class

class WorkFile {
private:
	FILE *stream;
public:
					WorkFile(const TCHAR *filename,const TCHAR *mode) { stream = _tfopen(filename,mode); };
					~WorkFile() { if(stream) fclose(stream); stream = NULL; };
	FILE *			Stream() { return stream; };
	};

#define RDERR(ptr,count) { if(!fread(ptr,count,1,stream)) return 0; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\aiexp.cpp ===
/**********************************************************************
 *<
	FILE: aiexp.cpp

	DESCRIPTION:  .AI file export module

	CREATED BY: Tom Hudson

	HISTORY: created 4 September 1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "Max.h"
#include "aieres.h"
#include "shape.h"

#include <stdarg.h>

static BOOL showPrompts;
static BOOL exportSelected;

static TCHAR decimalSymbol = _T('.');

static void GetDecSymbolFromRegistry() {
    HKEY hKey;
    DWORD dwType, numBytes;
	long status;
    unsigned char symbol[80];
	decimalSymbol = _T('.');
	status = RegOpenKeyEx (HKEY_CURRENT_USER, 
		      "Control Panel\\International", 
		      0, KEY_READ, &hKey);
    if (status == ERROR_SUCCESS) {
		if (ERROR_SUCCESS==RegQueryValueEx (hKey, "sDecimal", 0, &dwType, 
			 symbol, &numBytes))
			decimalSymbol = symbol[0];
	    }
	}

TCHAR *FixDecSymbol(TCHAR *buf)
	{
	TCHAR *cp = buf;
	while(*cp) {
		if( *cp == decimalSymbol)
			*cp = _T('.');
		cp++;
		}
	return buf;
	}

HINSTANCE hInstance;

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

static void MessageBox(int s1, int s2) {
	TSTR str1(GetString(s1));
	TSTR str2(GetString(s2));
	MessageBox(GetActiveWindow(), str1.data(), str2.data(), MB_OK);
	}

static int MessageBox(int s1, int s2, int option = MB_OK) {
	TSTR str1(GetString(s1));
	TSTR str2(GetString(s2));
	return MessageBox(GetActiveWindow(), str1, str2, option);
	}

static int Alert(int s1, int s2 = IDS_TH_AIEXP, int option = MB_OK) {
	return MessageBox(s1, s2, option);
	}


class AIExport : public SceneExport {
	friend BOOL CALLBACK ExportOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

public:
	static	int		layersFrom;					// Derive layers from...
					AIExport();
					~AIExport();
	int				ExtCount();					// Number of extensions supported
	const TCHAR *	Ext(int n);					// Extension #n (i.e. "3DS")
	const TCHAR *	LongDesc();					// Long ASCII description (i.e. "Autodesk 3D Studio File")
	const TCHAR *	ShortDesc();				// Short ASCII description (i.e. "3D Studio")
	const TCHAR *	AuthorName();				// ASCII Author name
	const TCHAR *	CopyrightMessage();			// ASCII Copyright message
	const TCHAR *	OtherMessage1();			// Other message #1
	const TCHAR *	OtherMessage2();			// Other message #2
	unsigned int	Version();					// Version number * 100 (i.e. v3.01 = 301)
	void			ShowAbout(HWND hWnd);		// Show DLL's "About..." box
	int				DoExport(const TCHAR *name,ExpInterface *ei,Interface *i, BOOL suppressPrompts=FALSE, DWORD options=0);	// Export file
	BOOL			SupportsOptions(int ext, DWORD options);
	};

// Statics

// Handy file class

class WorkFile {
private:
	FILE *stream;
	
public:
					WorkFile(const TCHAR *filename,const TCHAR *mode) { stream = NULL; Open(filename, mode); };
					~WorkFile() { Close(); };
	FILE *			Stream() { return stream; };
	int				Close() { int result=0; if(stream) result=fclose(stream); stream = NULL; return result; }
	void			Open(const TCHAR *filename,const TCHAR *mode) { Close(); stream = _tfopen(filename,mode); }
	};

// Handy memory worker

class Memory {
	void *ptr;
public:
					Memory() { ptr = NULL; }
					Memory(int amount, BOOL zero = FALSE) { ptr = NULL; Alloc(amount, zero); }
					~Memory() { Free(); }
	void *			Ptr() { return ptr; }
	void *			Realloc(int amount);
	void *			Alloc(int amount, BOOL zero = FALSE);
	void			Free() { if(ptr) free(ptr); ptr = NULL; }
	};

void *Memory::Realloc(int amount) {
	if(ptr)
		ptr = realloc(ptr, amount);
	else
		ptr = malloc(amount);
	return ptr;
	}

void *Memory::Alloc(int amount, BOOL zero) {
	Free();
	ptr = malloc(amount);
	if(ptr && zero) {
		char *p = (char *)ptr;
		for(int i = 0; i < amount; ++i)
			*p++ = 0;
		}
	return ptr;
	}

// Max interface code

int controlsInit = FALSE;

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();
		}
	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			//MessageBox(NULL,_T("AIEXP.DLL: DllMain"),_T("AIEXP"),MB_OK);
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------

class AIClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new AIExport; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_ADOBE); }
	SClass_ID		SuperClassID() { return SCENE_EXPORT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(0x3fe3,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SCENEEXPORT);  }
	};

static AIClassDesc AIDesc;

//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_TH_AIEXPORTDLL); }

__declspec( dllexport ) int
LibNumberClasses() { return 1; }

__declspec( dllexport ) ClassDesc *
LibClassDesc(int i) {
	switch(i) {
		case 0: return &AIDesc; break;
		default: return 0; break;
		}
	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

//
// .AI export module functions follow:
//

AIExport::AIExport() {
	}

AIExport::~AIExport() {
	}

int
AIExport::ExtCount() {
	return 1;
	}

const TCHAR *
AIExport::Ext(int n) {		// Extensions supported for import/export modules
	switch(n) {
		case 0:
			return _T("AI");
		}
	return _T("");
	}

const TCHAR *
AIExport::LongDesc() {			// Long ASCII description (i.e. "Targa 2.0 Image File")
	return GetString(IDS_TH_AIFILE);
	}
	
const TCHAR *
AIExport::ShortDesc() {			// Short ASCII description (i.e. "Targa")
	return GetString(IDS_TH_ADOBE);
	}

const TCHAR *
AIExport::AuthorName() {			// ASCII Author name
	return GetString(IDS_TH_TOM_HUDSON);
	}

const TCHAR *
AIExport::CopyrightMessage() {	// ASCII Copyright message
	return GetString(IDS_TH_COPYRIGHT_YOST_GROUP);
	}

const TCHAR *
AIExport::OtherMessage1() {		// Other message #1
	return _T("");
	}

const TCHAR *
AIExport::OtherMessage2() {		// Other message #2
	return _T("");
	}

unsigned int
AIExport::Version() {				// Version number * 100 (i.e. v3.01 = 301)
	return 100;
	}

void
AIExport::ShowAbout(HWND hWnd) {			// Optional
 	}

#ifdef MAYBE
static BOOL CALLBACK
ExportOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
	static AIExport *exp;

	switch(message) {
		case WM_INITDIALOG:
			exp = (AIExport *)lParam;
			CheckDlgButton( hDlg, deriveButtons[exp->layersFrom], TRUE);
			CenterWindow(hDlg,GetParent(hDlg));
			SetFocus(hDlg); // For some reason this was necessary.  DS-3/4/96
			return FALSE;
		case WM_DESTROY:
			return FALSE;
		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDOK: {
					// Unload values into AIExport statics
					for(int i = 0; i < NUM_SOURCES; ++i) {
						if(IsDlgButtonChecked(hDlg, deriveButtons[i])) {
							exp->layersFrom = i;
							break;
							}
						}
					EndDialog(hDlg, 1);
					}
					return TRUE;
				case IDCANCEL:
					EndDialog(hDlg, 0);
					return TRUE;
			}
		}
	return FALSE;
	}
#endif //MAYBE

class MySceneEntry {
	public:
		INode *node;
		Object *obj;
		ShapeObject *so;
		BezierShape shape;
		MySceneEntry *next;
		MySceneEntry(INode *n, Object *o, ShapeObject *s) { node = n; obj = o; so = s; next = NULL; }
		~MySceneEntry() { if (so != obj) so->DeleteThis(); }
	};

class MySceneEnumProc : public ITreeEnumProc {
	public:
		Interface	*i;
		MySceneEntry *head;
		MySceneEntry *tail;
		IScene		*theScene;
		int			count;
		TimeValue	time;
					MySceneEnumProc(IScene *scene, TimeValue t, Interface *i);
					~MySceneEnumProc();
		int			Count() { return count; }
		MySceneEntry *Append(INode *node, Object *o, ShapeObject *so);
		int			callback( INode *node );
		Box3		Bound();
		MySceneEntry *operator[](int index);
	};

MySceneEnumProc::MySceneEnumProc(IScene *scene, TimeValue t, Interface *i) {
	time = t;
	theScene = scene;
	count = 0;
	head = tail = NULL;
	this->i = i;
	theScene->EnumTree(this);
	}

MySceneEnumProc::~MySceneEnumProc() {
	while(head) {
		MySceneEntry *next = head->next;
		delete head;
		head = next;
		}
	head = tail = NULL;
	count = 0;	
	}

int MySceneEnumProc::callback(INode *node) {
	if(exportSelected && node->Selected() == FALSE)
		return TREE_CONTINUE;
	Object *obj = node->EvalWorldState(time).obj;
	// We only deal with shapes...
	if(obj->SuperClassID() == SHAPE_CLASS_ID) {
		// Must be able to convert to beziers for Adobe export
		ShapeObject *so = (ShapeObject *)obj;
		if(so->CanMakeBezier()) {
			MySceneEntry *entry = Append(node, obj, so);
			so->MakeBezier(time, entry->shape);
			}
		else {
			// Get rid of this work object!
			if(so != obj)
				so->DeleteThis();
			}
		}
	return TREE_CONTINUE;	// Keep on enumeratin'!
	}

MySceneEntry *MySceneEnumProc::Append(INode *node, Object *obj, ShapeObject *so) {
	MySceneEntry *entry = new MySceneEntry(node, obj, so);
	if(tail)
		tail->next = entry;
	tail = entry;
	if(!head)
		head = entry;
	count++;
	return entry;
	}

Box3 MySceneEnumProc::Bound() {
	Box3 bound;
	bound.Init();
	MySceneEntry *e = head;
	ViewExp *vpt = i->GetViewport(NULL);
	while(e) {
		bound += e->shape.GetBoundingBox();
		e = e->next;
		}
	return bound;
	}

MySceneEntry *MySceneEnumProc::operator[](int index) {
	MySceneEntry *e = head;
	while(index) {
		e = e->next;
		index--;
		}
	return e;
	}

#define AIWRITE(s) if(fprintf(stream,"%s",s)<0) goto wrterr;

int
ai_save(const TCHAR *filename, ExpInterface *ei, Interface *gi, AIExport *exp) {
	int ox;
	TimeValue t = gi->GetTime();

	// Get a scale factor from points (the file storage) to our units
	double mScale = GetMasterScale(UNITS_INCHES);
	float scaleFactor = float(mScale * 72.0);

	if(showPrompts) {
#ifdef MAYBE
		// Put up the options dialog to find out how they want the file written!
		int result = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_EXPORTOPTIONS), 
			gi->GetMAXHWnd(), ExportOptionsDlgProc, (LPARAM)exp);
		if(result <= 0)
			return 0;
#endif //MAYBE
		}
	else {	// Set default parameters here
		}

	// Make sure there are nodes we're interested in!
	// Ask the scene to enumerate all its nodes so we can determine if there are any we can use
	MySceneEnumProc myScene(ei->theScene, gi->GetTime(), gi);

	// Any useful nodes?
	if(!myScene.Count()) {
		if(showPrompts)
			Alert(IDS_TH_NODATATOEXPORT);
		return 1;
		}

	GetDecSymbolFromRegistry();

	// Output the file as text
	WorkFile theFile(filename,_T("w"));
	FILE *stream = theFile.Stream();
	if(!stream) {
		if(showPrompts)
			Alert(IDS_TH_CANTCREATE);
		return -1;						// Didn't open!
		}

	// Build a bounding box for the objects we're exporting
	Box3 bbox = myScene.Bound();
	bbox.Scale(scaleFactor);

	// Let's get busy!
	
	// First, write the prolog stuff...
//adobe_minmax(all,&minx,&miny,&maxx,&maxy);
	char gp_buffer[256];
	AIWRITE("%!PS-Adobe-3.0\n");
	AIWRITE("%%Creator: 3D Studio MAX(TM) .AI Export Version 1.0\n");
	AIWRITE("%%Title: (Shape Export)\n");
	_snprintf(gp_buffer,256,"%%%%BoundingBox:%d %d %d %d\n",(int)bbox.pmin.x,(int)bbox.pmin.y,(int)bbox.pmax.x,(int)bbox.pmax.y);
	AIWRITE(gp_buffer);
	AIWRITE("%%DocumentNeededResources: procset Adobe_packedarray 2.0 0\n");
	AIWRITE("%%+ procset Adobe_cshow 1.1 0\n");
	AIWRITE("%%+ procset Adobe_customcolor 1.0 0\n");
	AIWRITE("%%+ procset Adobe_Illustrator_AI3 1.0 1\n");
	AIWRITE("%%EndComments\n");
	AIWRITE("%%BeginProlog\n");
	AIWRITE("%%IncludeResource: procset Adobe_packedarray 2.0 0\n");
	AIWRITE("Adobe_packedarray /initialize get exec\n");
	AIWRITE("%%IncludeResource: procset Adobe_cshow 1.1 0\n");
	AIWRITE("%%IncludeResource: procset Adobe_customcolor 1.0 0\n");
	AIWRITE("%%IncludeResource: procset Adobe_Illustrator_AI3 1.0 1\n");
	AIWRITE("%%EndProlog\n");
	AIWRITE("%%BeginSetup\n");
	AIWRITE("Adobe_cshow /initialize get exec\n");
	AIWRITE("Adobe_customcolor /initialize get exec\n");
	AIWRITE("Adobe_IllustratorA_AI3 /initialize get exec\n");
	AIWRITE("%%EndSetup\n");
	AIWRITE("0.000 0.000 0.000 1.000 K\n");

	/* That takes care of the prolog garbage, now write our shapes */

	for(ox = 0; ox < myScene.Count(); ++ox) {
		BezierShape &shape = myScene[ox]->shape;
		// Write each spline
		int polys = shape.SplineCount();
		for(int poly = 0; poly < polys; ++poly) {
			Spline3D *spline = shape.GetSpline(poly);
			int knots = spline->KnotCount();
			for(int ix = 0; ix < knots; ++ix) {
				if(ix == 0) {
					Point3 p = spline->GetKnotPoint(ix) * scaleFactor;
					_snprintf(gp_buffer,256,"%.3f %.3f m\n",p.x,p.y);
					FixDecSymbol(gp_buffer);
					AIWRITE(gp_buffer);
					}
				else {
					Point3 lp = spline->GetKnotPoint(ix-1) * scaleFactor;
					Point3 lout = spline->GetOutVec(ix-1) * scaleFactor;
					Point3 p = spline->GetKnotPoint(ix) * scaleFactor;
					Point3 in = spline->GetInVec(ix) * scaleFactor;
					if(lout.x == lp.x && lout.y == lp.y && in.x == p.x && in.y == p.y) {
						_snprintf(gp_buffer,256,"%.3f %.3f L\n",p.x,p.y);
						FixDecSymbol(gp_buffer);
						AIWRITE(gp_buffer);
						}
					else {
						_snprintf(gp_buffer,256,"%.3f %.3f %.3f %.3f %.3f %.3f C\n",
							lout.x,lout.y, in.x, in.y, p.x, p.y);
						FixDecSymbol(gp_buffer);
						AIWRITE(gp_buffer);
						}
					}
				}
			if(spline->Closed()) {
				Point3 p0 = spline->GetKnotPoint(0) * scaleFactor;
				Point3 in0 = spline->GetInVec(0) * scaleFactor;
				Point3 pn = spline->GetKnotPoint(knots-1) * scaleFactor;
				Point3 outn = spline->GetOutVec(knots-1) * scaleFactor;
				if(in0.x == p0.x && in0.y == p0.y && outn.x == pn.x && outn.y == pn.y) {
					_snprintf(gp_buffer,256,"%.3f %.3f L\n",p0.x,p0.y);
					FixDecSymbol(gp_buffer);
					AIWRITE(gp_buffer);
					}
				else {
					_snprintf(gp_buffer,256,"%.3f %.3f %.3f %.3f %.3f %.3f C\n",
						outn.x, outn.y, in0.x, in0.y, p0.x, p0.y);
					FixDecSymbol(gp_buffer);
					AIWRITE(gp_buffer);
					}
				AIWRITE("s\n");
				}
			else
				AIWRITE("S\n");
			}
		}

	AIWRITE("%%Trailer\n");
	AIWRITE("Adobe_Illustrator_AI3 /terminate get exec\n");
	AIWRITE("Adobe_customcolor /terminate get exec\n");
	AIWRITE("Adobe_cshow /terminate get exec\n");
	AIWRITE("Adobe_packedarray /terminate get exec\n");
	AIWRITE("%%EOF\n");
	if(theFile.Close()) {
		wrterr:
		if(showPrompts)
			Alert(IDS_TH_WRITEERROR);
		theFile.Close();
		remove(filename);
		return 0;
		}

	if(theFile.Close())
		goto wrterr;

	return 1;	
	}

int
AIExport::DoExport(const TCHAR *filename,ExpInterface *ei,Interface *gi, BOOL suppressPrompts, DWORD options) {
	// Set a global prompt display switch
	showPrompts = suppressPrompts ? FALSE : TRUE;
	exportSelected = (options & SCENE_EXPORT_SELECTED) ? TRUE : FALSE;

	int status;
		
	status=ai_save(filename, ei, gi, this);

	if(status == 0)
		return 1;		// Dialog cancelled
	if(status > 0)	{
#ifdef DBGDXF
DebugPrint("AI status OK!\n");
#endif
		}
#ifdef DBGDXF
	else
	if(status < 0)
		DebugPrint("Error somewhere in AI!\n");
#endif

	return(status);
	}

BOOL AIExport::SupportsOptions(int ext, DWORD options) {
	assert(ext == 0);	// We only support one extension
	return(options == SCENE_EXPORT_SELECTED) ? TRUE : FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\cfile.h ===
/* Configuration file data chunks */

#define CMAGIC 0xC23D	/* Configuration magic */

#define C_MDRAWER 0xC010
#define C_TDRAWER 0xC020
#define C_SHPDRAWER 0xC030
#define C_MODDRAWER 0xC040
#define C_RIPDRAWER 0xC050
#define C_TXDRAWER 0xC060
#define C_PDRAWER 0xC062
#define C_MTLDRAWER 0xC064
#define C_FLIDRAWER 0xC066
#define C_CUBDRAWER 0xC067
#define C_MFILE 0xC070
#define C_SHPFILE 0xC080
#define C_MODFILE 0xC090
#define C_RIPFILE 0xC0A0
#define C_TXFILE 0xC0B0
#define C_PFILE 0xC0B2
#define C_MTLFILE 0xC0B4
#define C_FLIFILE 0xC0B6
#define C_PALFILE 0xC0B8
#define C_TX_STRING 0xC0C0
#define C_CONSTS 0xC0D0
#define C_SNAPS 0xC0E0
#define C_GRIDS 0xC0F0
#define C_ASNAPS 0xC100
#define C_GRID_RANGE 0xC110
#define C_RENDTYPE 0xC120
#define C_PROGMODE 0xC130
#define C_PREVMODE 0xC140
#define C_MODWMODE 0xC150
#define C_MODMODEL 0xC160
#define C_ALL_LINES 0xC170
#define C_BACK_TYPE 0xC180
#define C_MD_CS 0xC190
#define C_MD_CE 0xC1A0
#define C_MD_SML 0xC1B0
#define C_MD_SMW 0xC1C0
#define C_LOFT_WITH_TEXTURE 0xC1C3
#define C_LOFT_L_REPEAT 0xC1C4
#define C_LOFT_W_REPEAT 0xC1C5
#define C_LOFT_UV_NORMALIZE 0xC1C6
#define C_WELD_LOFT 0xC1C7
#define C_MD_PDET 0xC1D0
#define C_MD_SDET 0xC1E0
#define C_RGB_RMODE 0xC1F0
#define C_RGB_HIDE 0xC200
#define C_RGB_MAPSW 0xC202
#define C_RGB_TWOSIDE 0xC204
#define C_RGB_SHADOW 0xC208
#define C_RGB_AA 0xC210
#define C_RGB_OVW 0xC220
#define C_RGB_OVH 0xC230
#define C_RGB_PICTYPE 0xC240
#define C_RGB_OUTPUT 0xC250
#define C_RGB_TODISK 0xC253
#define C_RGB_COMPRESS 0xC254
#define C_JPEG_COMPRESSION 0xC255
#define C_RGB_DISPDEV 0xC256
#define C_RGB_HARDDEV 0xC259
#define C_RGB_PATH 0xC25A
#define C_BITMAP_DRAWER 0xC25B
#define C_RGB_FILE 0xC260
#define C_RGB_OVASPECT 0xC270

#define C_RGB_ANIMTYPE 0xC271
#define C_RENDER_ALL 0xC272
#define C_REND_FROM 0xC273
#define C_REND_TO 0xC274
#define C_REND_NTH 0xC275
#define C_PAL_TYPE 0xC276
#define C_RND_TURBO 0xC277
#define C_RND_MIP	0xC278
#define C_BGND_METHOD 0xC279
#define C_AUTO_REFLECT 0xC27A
#define C_VP_FROM 0xC27B
#define C_VP_TO 0xC27C
#define C_VP_NTH 0xC27D

#define C_SRDIAM 0xC280
#define C_SRDEG 0xC290
#define C_SRSEG 0xC2A0
#define C_SRDIR 0xC2B0
#define C_HETOP 0xC2C0
#define C_HEBOT 0xC2D0
#define C_HEHT 0xC2E0
#define C_HETURNS 0xC2F0
#define C_HEDEG 0xC300
#define C_HESEG 0xC310
#define C_HEDIR 0xC320
#define C_QUIKSTUFF 0xC330
#define C_SEE_LIGHTS 0xC340
#define C_SEE_CAMERAS 0xC350
#define C_SEE_3D 0xC360
#define C_MESHSEL 0xC370
#define C_MESHUNSEL 0xC380
#define C_POLYSEL 0xC390
#define C_POLYUNSEL 0xC3A0
#define C_SHPLOCAL 0xC3A2
#define C_MSHLOCAL 0xC3A4
#define C_NUM_FORMAT 0xC3B0
#define C_ARCH_DENOM 0xC3C0
#define C_IN_DEVICE 0xC3D0
#define C_MSCALE 0xC3E0
#define C_COMM_PORT 0xC3F0
#define C_TAB_BASES 0xC400
#define C_TAB_DIVS 0xC410
#define C_MASTER_SCALES 0xC420
#define C_SHOW_1STVERT 0xC430
#define C_SHAPER_OK 0xC440
#define C_LOFTER_OK 0xC450
#define C_EDITOR_OK 0xC460
#define C_KEYFRAMER_OK 0xC470
#define C_PICKSIZE 0xC480
#define C_MAPTYPE 0xC490
#define C_MAP_DISPLAY 0xC4A0
#define C_TILE_XY 0xC4B0
#define C_MAP_XYZ 0xC4C0
#define C_MAP_SCALE 0xC4D0
#define C_MAP_MATRIX_OLD 0xC4E0
#define C_MAP_MATRIX 0xC4E1
#define C_MAP_WID_HT 0xC4F0
#define C_OBNAME 0xC500
#define C_CAMNAME 0xC510
#define C_LTNAME 0xC520
#define C_CUR_MNAME 0xC525
#define C_CURMTL_FROM_MESH 0xC526
#define C_GET_SHAPE_MAKE_FACES 0xC527
#define C_DETAIL 0xC530
#define C_VERTMARK 0xC540
#define C_MSHAX 0xC550
#define C_MSHCP 0xC560
#define C_USERAX 0xC570
#define C_SHOOK 0xC580
#define C_RAX 0xC590
#define C_STAPE 0xC5A0
#define C_LTAPE 0xC5B0
#define C_ETAPE 0xC5C0
#define C_KTAPE 0xC5C8
#define C_SPHSEGS 0xC5D0
#define C_GEOSMOOTH 0xC5E0
#define C_HEMISEGS 0xC5F0
#define C_PRISMSEGS 0xC600
#define C_PRISMSIDES 0xC610
#define C_TUBESEGS 0xC620
#define C_TUBESIDES 0xC630
#define C_TORSEGS 0xC640
#define C_TORSIDES 0xC650
#define C_CONESIDES 0xC660
#define C_CONESEGS 0xC661
#define C_NGPARMS 0xC670
#define C_PTHLEVEL 0xC680
#define C_MSCSYM 0xC690
#define C_MFTSYM 0xC6A0
#define C_MTTSYM 0xC6B0
#define C_SMOOTHING 0xC6C0
#define C_MODICOUNT 0xC6D0
#define C_FONTSEL 0xC6E0
#define C_TESS_TYPE 0xC6f0
#define C_TESS_TENSION 0xC6f1

#define C_SEG_START 0xC700
#define C_SEG_END 0xC705
#define C_CURTIME 0xC710
#define C_ANIMLENGTH 0xC715
#define C_PV_FROM 0xC720
#define C_PV_TO 0xC725
#define C_PV_DOFNUM 0xC730
#define C_PV_RNG 0xC735
#define C_PV_NTH 0xC740
#define C_PV_TYPE 0xC745
#define C_PV_METHOD 0xC750
#define C_PV_FPS 0xC755
#define C_VTR_FRAMES 0xC765
#define C_VTR_HDTL 0xC770
#define C_VTR_HD 0xC771
#define C_VTR_TL 0xC772
#define C_VTR_IN 0xC775
#define C_VTR_PK 0xC780
#define C_VTR_SH 0xC785

/* Material chunks */

#define C_WORK_MTLS 0xC790	  /* Old-style -- now ignored */
#define C_WORK_MTLS_2 0xC792 /* Old-style -- now ignored */
#define C_WORK_MTLS_3 0xC793 /* Old-style -- now ignored */
#define C_WORK_MTLS_4 0xC794 /* Old-style -- now ignored */
#define C_WORK_MTLS_5 0xCB00 /* Old-style -- now ignored */
#define C_WORK_MTLS_6 0xCB01 /* Old-style -- now ignored */
#define C_WORK_MTLS_7 0xCB02 /* Old-style -- now ignored */
#define C_WORK_MTLS_8 0xCB03 /* Old-style -- now ignored */
#define C_WORKMTL 0xCB04
#define C_SXP_TEXT_DATA 0xCB10
#define C_SXP_TEXT2_DATA 0xCB20
#define C_SXP_OPAC_DATA 0xCB11
#define C_SXP_BUMP_DATA 0xCB12
#define C_SXP_SPEC_DATA 0xCB24
#define C_SXP_SHIN_DATA 0xCB13
#define C_SXP_SELFI_DATA 0xCB28
#define C_SXP_TEXT_MASKDATA 0xCB30
#define C_SXP_TEXT2_MASKDATA 0xCB32
#define C_SXP_OPAC_MASKDATA 0xCB34
#define C_SXP_BUMP_MASKDATA 0xCB36
#define C_SXP_SPEC_MASKDATA 0xCB38
#define C_SXP_SHIN_MASKDATA 0xCB3A
#define C_SXP_SELFI_MASKDATA 0xC3C
#define C_SXP_REFL_MASKDATA 0xCB3E

#define C_BGTYPE 0xC7A1
#define C_MEDTILE 0xC7B0

/* Contrast */

#define C_LO_CONTRAST 0xC7D0
#define C_HI_CONTRAST 0xC7D1

/* 3d frozen display */

#define C_FROZ_DISPLAY 0xC7E0

/* Booleans */
#define C_BOOLWELD 0xc7f0
#define C_BOOLTYPE 0xc7f1

#define C_ANG_THRESH 0xC900
#define C_SS_THRESH 0xC901
#define C_TEXTURE_BLUR_DEFAULT 0xC903

#define C_MAPDRAWER 0xCA00
#define C_MAPDRAWER1 0xCA01
#define C_MAPDRAWER2 0xCA02
#define C_MAPDRAWER3 0xCA03
#define C_MAPDRAWER4 0xCA04
#define C_MAPDRAWER5 0xCA05
#define C_MAPDRAWER6 0xCA06
#define C_MAPDRAWER7 0xCA07
#define C_MAPDRAWER8 0xCA08
#define C_MAPDRAWER9 0xCA09
#define C_MAPDRAWER_ENTRY 0xCA10

/* system options */
#define C_BACKUP_FILE 0xCA20
#define C_DITHER_256 0xCA21
#define C_SAVE_LAST 0xCA22
#define C_USE_ALPHA 0xCA23
#define C_TGA_DEPTH 0xCA24
#define C_REND_FIELDS 0xCA25
#define C_REFLIP 0xCA26
#define C_SEL_ITEMTOG 0xCA27
#define C_SEL_RESET 0xCA28
#define C_STICKY_KEYINF 0xCA29
#define C_WELD_THRESHOLD 0xCA2A
#define C_ZCLIP_POINT 0xCA2B
#define C_ALPHA_SPLIT 0xCA2C
#define C_KF_SHOW_BACKFACE 0xCA30
#define C_OPTIMIZE_LOFT 0xCA40
#define C_TENS_DEFAULT 0xCA42
#define C_CONT_DEFAULT 0xCA44
#define C_BIAS_DEFAULT 0xCA46

#define C_DXFNAME_SRC  0xCA50
#define C_AUTO_WELD  0xCA60
#define C_AUTO_UNIFY  0xCA70
#define C_AUTO_SMOOTH  0xCA80
#define C_DXF_SMOOTH_ANG  0xCA90
#define C_SMOOTH_ANG  0xCAA0

/* Special network-use chunks */

#define C_NET_USE_VPOST 0xCC00
#define C_NET_USE_GAMMA 0xCC10
#define C_NET_FIELD_ORDER 0xCC20

#define C_BLUR_FRAMES 0xCD00
#define C_BLUR_SAMPLES 0xCD10
#define C_BLUR_DUR 0xCD20
#define C_HOT_METHOD 0xCD30
#define C_HOT_CHECK 0xCD40
#define C_PIXEL_SIZE 0xCD50
#define C_DISP_GAMMA 0xCD60
#define C_FBUF_GAMMA 0xCD70
#define C_FILE_OUT_GAMMA 0xCD80
#define C_FILE_IN_GAMMA 0xCD82
#define C_GAMMA_CORRECT 0xCD84
#define C_APPLY_DISP_GAMMA 0xCD90  /* OBSOLETE */
#define C_APPLY_FBUF_GAMMA 0xCDA0  /* OBSOLETE */
#define C_APPLY_FILE_GAMMA 0xCDB0  /* OBSOLETE */
#define C_FORCE_WIRE 0xCDC0
#define C_RAY_SHADOWS 0xCDD0
#define C_MASTER_AMBIENT 0xCDE0
#define C_SUPER_SAMPLE 0xCDF0
#define C_OBJECT_MBLUR 0xCE00
#define C_MBLUR_DITHER 0xCE10
#define C_DITHER_24 0xCE20
#define C_SUPER_BLACK 0xCE30
#define C_SAFE_FRAME 0xCE40
#define C_VIEW_PRES_RATIO 0xCE50
#define C_BGND_PRES_RATIO 0xCE60
#define C_NTH_SERIAL_NUM 0xCE70
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\aires.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by aiimp.rc
//
#define IDS_MATCHANIMLENGTH             1
#define IDS_3DSIMP                      2
#define IDS_AIIMP                       2
#define IDS_DB_MISSING_SHAPE            3
#define IDS_TH_SHAPE_NUM                3
#define IDS_DB_LIGHT_ERROR              4
#define IDS_DB_CAMERA_ERROR             5
#define IDS_DB_NO_OBJECT                6
#define IDS_DB_HAS_VERTS                7
#define IDS_DB_NUMVERTS_FAIL            8
#define IDS_DB_HAS_TVERTS               9
#define IDS_DB_HAS_FACES                10
#define IDS_DB_NUMFACES_FAIL            11
#define IDS_DB_NUMTVFACES_FAIL          12
#define IDS_DB_PUT_NO_VERTS             13
#define IDS_DB_3DSIMP                   14
#define IDS_TH_AIIMP                    14
#define IDS_DB_VERTS_OR                 15
#define IDS_DB_PUT_NO_TVERTS            16
#define IDS_DB_TVERTS_OR                17
#define IDS_DB_PUT_NO_FACES             18
#define IDS_DB_FACES_OR                 19
#define IDS_DB_SMOOTH_NO_FACES          20
#define IDS_DB_SMFACE_OR                21
#define IDS_DB_SHAPE_NUM                22
#define IDS_DB_NOT_LINKED               23
#define IDD_SHAPEIMPORTOPTIONS          101
#define IDD_MERGEORREPL                 102
#define IDC_SINGLEOBJECT                1000
#define IDC_MULTIPLEOBJECTS             1001
#define IDC_3DS_MERGE                   1002
#define IDC_AI_MERGE                    1002
#define IDC_3DS_REPLACE                 1003
#define IDC_AI_REPLACE                  1003
#define IDS_TH_3DSTUDIO                 40216
#define IDS_TH_ADOBE_ILLUSTRATOR        40216
#define IDS_TH_SCENEIMPORT              40217
#define IDS_TH_3DSTUDIOSHAPE            40218
#define IDS_TH_AISHAPE                  40218
#define IDS_TH_3DSIMPORTDLL             40219
#define IDS_TH_AIIMPORTDLL              40219
#define IDS_TH_3DSSCENEFILE             40220
#define IDS_TH_AISHAPEFILE              40220
#define IDS_TH_3DSMESH                  40221
#define IDS_TH_TOM_HUDSON               40222
#define IDS_TH_COPYRIGHT_YOST_GROUP     40223
#define IDS_TH_3DSSHAPEFILE             40224
#define IDS_TH_ERR_OPENING_FILE         40225
#define IDS_TH_3DSIMP                   40226
#define IDS_TH_3DSREADERROR             40227
#define IDS_TH_READERROR                40227
#define IDS_TH_INVALIDFILE              40228
#define IDS_TH_NO_RAM                   40229
#define IDS_TH_LINE_TOO_LONG            40230
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\dxferes.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dxfexp.rc
//
#define IDS_DXFEXP                      1
#define IDS_NO_MATERIAL                 2
#define IDD_EXPORTOPTIONS               101
#define IDC_BYOBJECT                    1016
#define IDC_BYMATERIAL                  1017
#define IDC_1LAYER                      1018
#define IDS_TH_TOM_HUDSON               40222
#define IDS_TH_COPYRIGHT_YOST_GROUP     40223
#define IDS_TH_SCENEEXPORT              40231
#define IDS_TH_NODATATOEXPORT           40233
#define IDS_TH_CANTCREATE               40234
#define IDS_TH_WRITEERROR               40235
#define IDS_TH_AUTOCAD                  40236
#define IDS_TH_DXFEXPORTDLL             40237
#define IDS_TH_AUTOCADDXFFILE           40238
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1019
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\dxfimp.cpp ===
/**********************************************************************
 *<
	FILE: dxfimp.cpp

	DESCRIPTION:  .DXF file import module

	CREATED BY: Tom Hudson

	HISTORY: created 27 November 1995

 *>	Copyright (c) 1995, All Rights Reserved. 
 **********************************************************************/

#include "Max.h"
#include "splshape.h"
#include "resource.h"

#ifndef UNDEFINED
#define UNDEFINED	0xffffffff
#endif

#define MAXMID 50

// Release 13 fix
#define R13FIX

// Debugging switches:
//#define DBGDXF
//#define DBGDXF1
//#define DBGBULG
//#define DBGNO
//#define DBGCOL
//#define DBGFINAL

//#define IS_3DSDXF

static BOOL showPrompts;

// ARBAXIS.C stuff...
typedef double point[3];	   /* Three dimensional point */
typedef double vector[4];	   /* Homogeneous coordinate vector */
typedef double matrix[4][4];   /* Transformation matrix */
extern void geta4by4(point normaxis, matrix mat);
// End of ARBAXIS stuff

static void NormTrans(Point3& p, Point3 norm);
static void	RemoveDoubleFaces(Mesh *m);

// Here are the 256 ACI (Autodesk Color Index) colors:
struct ObjectColors {
	BYTE	r, g, b;
}; 

inline DWORD DWORD_FROM_OC(ObjectColors x) {
	return (x.r | (x.g << 8) | (x.b << 16));
	}

static ObjectColors aciColors[256] = {
    {0, 0, 0}, {250, 0, 0}, {250, 250, 0}, {0, 250, 0}, {0, 250, 250},
    {0, 0, 250}, {250, 0, 250}, {250, 250, 250}, {135, 135, 135},
    {203, 203, 203}, {255, 0, 0}, {255, 127, 127}, {165, 0, 0}, {165, 82, 82},
    {127, 0, 0}, {127, 63, 63}, {76, 0, 0}, {76, 38, 38}, {38, 0, 0},
    {38, 19, 19}, {255, 63, 0}, {255, 159, 127}, {165, 41, 0}, {165, 103, 82},
    {127, 31, 0}, {127, 79, 63}, {76, 19, 0}, {76, 47, 38}, {38, 9, 0},
    {38, 23, 19}, {255, 127, 0}, {255, 191, 127}, {165, 82, 0}, {165, 124, 82},
    {127, 63, 0}, {127, 95, 63}, {76, 38, 0}, {76, 57, 38}, {38, 19, 0},
    {38, 28, 19}, {255, 191, 0}, {255, 223, 127}, {165, 124, 0},
    {165, 145, 82}, {127, 95, 0}, {127, 111, 63}, {76, 57, 0}, {76, 66, 38},
    {38, 28, 0}, {38, 33, 19}, {255, 255, 0}, {255, 255, 127}, {165, 165, 0},
    {165, 165, 82}, {127, 127, 0}, {127, 127, 63}, {76, 76, 0}, {76, 76, 38},
    {38, 38, 0}, {38, 38, 19}, {191, 255, 0}, {223, 255, 127},
    {124, 165, 0}, {145, 165, 82}, {95, 127, 0}, {111, 127, 63}, {57, 76, 0},
    {66, 76, 38}, {28, 38, 0}, {33, 38, 19}, {127, 255, 0}, {191, 255, 127},
    {82, 165, 0}, {124, 165, 82}, {63, 127, 0}, {95, 127, 63}, {38, 76, 0},
    {57, 76, 38}, {19, 38, 0}, {28, 38, 19}, {63, 255, 0}, {159, 255, 127},
    {41, 165, 0}, {103, 165, 82}, {31, 127, 0}, {79, 127, 63}, {19, 76, 0},
    {47, 76, 38}, {9, 38, 0}, {23, 38, 19}, {0, 255, 0}, {127, 255, 127},
    {0, 165, 0}, {82, 165, 82}, {0, 127, 0}, {63, 127, 63}, {0, 76, 0},
    {38, 76, 38}, {0, 38, 0}, {19, 38, 19}, {0, 255, 63}, {127, 255, 159},
    {0, 165, 41}, {82, 165, 103}, {0, 127, 31}, {63, 127, 79}, {0, 76, 19},
    {38, 76, 47}, {0, 38, 9}, {19, 38, 23}, {0, 255, 127}, {127, 255, 191},
    {0, 165, 82}, {82, 165, 124}, {0, 127, 63}, {63, 127, 95}, {0, 76, 38},
    {38, 76, 57}, {0, 38, 19}, {19, 38, 28}, {0, 255, 191}, {127, 255, 223},
    {0, 165, 124}, {82, 165, 145}, {0, 127, 95}, {63, 127, 111}, {0, 76, 57},
    {38, 76, 66}, {0, 38, 28}, {19, 38, 33}, {0, 255, 255}, {127, 255, 255},
    {0, 165, 165}, {82, 165, 165}, {0, 127, 127}, {63, 127, 127}, {0, 76, 76},
    {38, 76, 76}, {0, 38, 38}, {19, 38, 38}, {0, 191, 255}, {127, 223, 255},
    {0, 124, 165}, {82, 145, 165}, {0, 95, 127}, {63, 111, 127}, {0, 57, 76},
    {38, 66, 76}, {0, 28, 38}, {19, 33, 38}, {0, 127, 255}, {127, 191, 255},
    {0, 82, 165}, {82, 124, 165}, {0, 63, 127}, {63, 95, 127}, {0, 38, 76},
    {38, 57, 76}, {0, 19, 38}, {19, 28, 38}, {0, 63, 255}, {127, 159, 255},
    {0, 41, 165}, {82, 103, 165}, {0, 31, 127}, {63, 79, 127}, {0, 19, 76},
    {38, 47, 76}, {0, 9, 38}, {19, 23, 38}, {0, 0, 255}, {127, 127, 255},
    {0, 0, 165}, {82, 82, 165}, {0, 0, 127}, {63, 63, 127}, {0, 0, 76},
    {38, 38, 76}, {0, 0, 38}, {19, 19, 38}, {63, 0, 255}, {159, 127, 255},
    {41, 0, 165}, {103, 82, 165}, {31, 0, 127}, {79, 63, 127}, {19, 0, 76},
    {47, 38, 76}, {9, 0, 38}, {23, 19, 38}, {127, 0, 255}, {191, 127, 255},
    {82, 0, 165}, {124, 82, 165}, {63, 0, 127}, {95, 63, 127}, {38, 0, 76},
    {57, 38, 76}, {19, 0, 38}, {28, 19, 38}, {191, 0, 255}, {223, 127, 255},
    {124, 0, 165}, {145, 82, 165}, {95, 0, 127}, {111, 63, 127}, {57, 0, 76},
    {66, 38, 76}, {28, 0, 38}, {33, 19, 38}, {255, 0, 255}, {255, 127, 255},
    {165, 0, 165}, {165, 82, 165}, {127, 0, 127}, {127, 63, 127}, {76, 0, 76},
    {76, 38, 76}, {38, 0, 38}, {38, 19, 38}, {255, 0, 191}, {255, 127, 223},
    {165, 0, 124}, {165, 82, 145}, {127, 0, 95}, {127, 63, 111}, {76, 0, 57},
    {76, 38, 66}, {38, 0, 28}, {38, 19, 33}, {255, 0, 127}, {255, 127, 191},
    {165, 0, 82}, {165, 82, 124}, {127, 0, 63}, {127, 63, 95}, {76, 0, 38},
    {76, 38, 57}, {38, 0, 19}, {38, 19, 28}, {255, 0, 63}, {255, 127, 159},
    {165, 0, 41}, {165, 82, 103}, {127, 0, 31}, {127, 63, 79},  {76, 0, 19},
    {76, 38, 47}, {38, 0, 9}, {38, 19, 23}, {84, 84, 84}, {118, 118, 118},
    {152, 152, 152}, {186, 186, 186}, {220, 220, 220}, {255, 255, 255}
};

static char gp_buffer[256];

HINSTANCE hInstance;

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

static void MessageBox(int s1, int s2) {
	TSTR str1(GetString(s1));
	TSTR str2(GetString(s2));
	MessageBox(GetActiveWindow(), str1.data(), str2.data(), MB_OK);
	}

static int MessageBox(int s1, int s2, int option = MB_OK) {
	TSTR str1(GetString(s1));
	TSTR str2(GetString(s2));
	return MessageBox(GetActiveWindow(), str1, str2, option);
	}

static int Alert(int s1, int s2 = IDS_TH_DXFIMP, int option = MB_OK) {
	return MessageBox(s1, s2, option);
	}

#define no_RAM() Alert(IDS_TH_OUTOFMEMORY)

//-----------------------------------------------------------------------
struct NameSlot {
	TSTR name;
	int maxid;
	NameSlot *next;
	public:
	NameSlot(TCHAR *t, int id) { name = t; maxid = id; next = NULL; }
	};

NameSlot *nameList=NULL;

static void FreeNameList() {
	while (nameList) {
		NameSlot *ns = nameList;
		nameList = nameList->next;
		delete ns;
		}
	}

static void AddNameToNameList(TCHAR *nm) {
	NameSlot *ns = new NameSlot(nm,1);
	ns->next=nameList;
	nameList = ns;
	}

static void StripName(TCHAR* sname) {
	int n = _tcslen(sname)-1;
	while (n>=0 && sname[n]>=_T('0') && sname[n]<=_T('9') ) 
		sname[n--]=0;
	}

static void MakeNameUnique(TCHAR *name) {
	StripName(name); // strip off trailing numbers
	TCHAR buf[20];
	for (NameSlot *ns = nameList; ns!=NULL; ns = ns->next) {
		if (_tcscmp(name,ns->name.data())==0) {
			int i = ++ns->maxid;
			_stprintf(buf,"%02d\0",i);
			strcat(name,buf);
			return;
			}
		}

	AddNameToNameList(name);
	strcat(name,"01");
	}

//-----------------------------------------------------------------------


// Derive objects from...
#define OBJS_LAYER		0
#define OBJS_COLOR		1
#define OBJS_ENTITY		2
#define OBJS_FILMROLL	3

#define NUM_SOURCES 3 		// # of sources in dialog

class DXFImport : public SceneImport {
	friend BOOL CALLBACK ImportOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

public:
	static	int				objsFrom;					// Derive objects from...
	static	float			thresh;						// Weld threshold
	static	BOOL			weld;
	static	float			smoothAngle;				// Smooth angle
	static	BOOL			smooth;
	static	float			arcDegrees;
	static	float			arcSubDegrees;
	static	BOOL			removeDouble;
	static	BOOL			fillPolylines;
	static	BOOL			unifyNormals;
	static	ISpinnerControl* weldSpin;
	static	ISpinnerControl* smoothSpin;
	static	ISpinnerControl* arcSpin;
	static	ISpinnerControl* arcSubSpin;
	static  ImpInterface*   impInt;
	Interface		*gi;						// Generic interface
	long			fileLength;					// Length of the file
	int				lastpct;					// Last percentage displayed on file read
	int				pctcounter;					// Last percentage counter
					DXFImport();
					~DXFImport();
	int				ExtCount();					// Number of extensions supported
	const TCHAR *	Ext(int n);					// Extension #n (i.e. "3DS")
	const TCHAR *	LongDesc();					// Long ASCII description (i.e. "Autodesk 3D Studio File")
	const TCHAR *	ShortDesc();				// Short ASCII description (i.e. "3D Studio")
	const TCHAR *	AuthorName();				// ASCII Author name
	const TCHAR *	CopyrightMessage();			// ASCII Copyright message
	const TCHAR *	OtherMessage1();			// Other message #1
	const TCHAR *	OtherMessage2();			// Other message #2
	unsigned int	Version();					// Version number * 100 (i.e. v3.01 = 301)
	void			ShowAbout(HWND hWnd);		// Show DLL's "About..." box
	int				DoImport(const TCHAR *name,ImpInterface *i,Interface *gi, BOOL suppressPrompts=FALSE);	// Import file
	};

// Statics
ISpinnerControl*	DXFImport::weldSpin     = NULL;
ISpinnerControl*	DXFImport::smoothSpin     = NULL;
ISpinnerControl*	DXFImport::arcSpin     = NULL;
ISpinnerControl*	DXFImport::arcSubSpin     = NULL;
ImpInterface*   	DXFImport::impInt		=NULL;
int					DXFImport::objsFrom = OBJS_LAYER;			// Derive objects from...
float				DXFImport::thresh = 0.01f;					// Weld threshold
BOOL				DXFImport::weld = TRUE;
float				DXFImport::smoothAngle = 30.0f;				// Smooth angle
BOOL				DXFImport::smooth = TRUE;
float				DXFImport::arcDegrees = 10.0f;
float				DXFImport::arcSubDegrees = 90.0f;
BOOL				DXFImport::removeDouble = TRUE;
BOOL				DXFImport::fillPolylines = TRUE;
BOOL				DXFImport::unifyNormals = TRUE;

// Handy file class

class WorkFile {
private:
	FILE *stream;
	long length;	
public:
					WorkFile(const TCHAR *filename,const TCHAR *mode) { stream = NULL; Open(filename, mode); };
					~WorkFile() { Close(); };
	FILE *			Stream() { return stream; };
	void			Close() { if(stream) fclose(stream); stream = NULL; }
	void			Open(const TCHAR *filename,const TCHAR *mode);
	long			Length() { return length; }
	};

void WorkFile::Open(const TCHAR *filename,const TCHAR *mode) {
	Close();
	stream = _tfopen(filename,mode);
	if(stream) {
		fseek(stream, 0, SEEK_END);
		length = ftell(stream);
		fseek(stream, 0, SEEK_SET);
		}
	else
		length = 0; 
#ifdef DBGDXF
		DebugPrint("File length:%d\n",length);
#endif
	}

// Handy memory worker

class Memory {
	void *ptr;
public:
					Memory() { ptr = NULL; }
					Memory(int amount, BOOL zero = FALSE) { ptr = NULL; Alloc(amount, zero); }
					~Memory() { Free(); }
	void *			Ptr() { return ptr; }
	void *			Realloc(int amount);
	void *			Alloc(int amount, BOOL zero = FALSE);
	void			Free() { if(ptr) free(ptr); ptr = NULL; }
	};

void *Memory::Realloc(int amount) {
	if(ptr)
		ptr = realloc(ptr, amount);
	else
		ptr = malloc(amount);
	return ptr;
	}

void *Memory::Alloc(int amount, BOOL zero) {
	Free();
	ptr = malloc(amount);
	if(ptr && zero) {
		char *p = (char *)ptr;
		for(int i = 0; i < amount; ++i)
			*p++ = 0;
		}
	return ptr;
	}

// Jaguar interface code

int controlsInit = FALSE;

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();
		}
	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			//MessageBox(NULL,_T("DXFIMP.DLL: DllMain"),_T("DXFIMP"),MB_OK);
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------

class DXFClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new DXFImport; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_AUTOCAD); }
	SClass_ID		SuperClassID() { return SCENE_IMPORT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(0xd1f,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SCENEIMPORT);  }
	};

static DXFClassDesc DXFDesc;

//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_TH_DXFIMPORTDLL); }

__declspec( dllexport ) int
LibNumberClasses() { return 1; }

__declspec( dllexport ) ClassDesc *
LibClassDesc(int i) {
	switch(i) {
		case 0: return &DXFDesc; break;
		default: return 0; break;
		}
	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

//
// .3DS import module functions follow:
//

DXFImport::DXFImport() {
	lastpct = -1;
	pctcounter = 100;
	}

DXFImport::~DXFImport() {
	}

int
DXFImport::ExtCount() {
	return 1;
	}

const TCHAR *
DXFImport::Ext(int n) {		// Extensions supported for import/export modules
	switch(n) {
		case 0:
			return _T("DXF");
		}
	return _T("");
	}

const TCHAR *
DXFImport::LongDesc() {			// Long ASCII description (i.e. "Targa 2.0 Image File")
	return GetString(IDS_TH_AUTOCADDXFFILE);
	}
	
const TCHAR *
DXFImport::ShortDesc() {			// Short ASCII description (i.e. "Targa")
	return GetString(IDS_TH_AUTOCAD);
	}

const TCHAR *
DXFImport::AuthorName() {			// ASCII Author name
	return GetString(IDS_TH_TOM_HUDSON);
	}

const TCHAR *
DXFImport::CopyrightMessage() {	// ASCII Copyright message
	return GetString(IDS_TH_COPYRIGHT_YOST_GROUP);
	}

const TCHAR *
DXFImport::OtherMessage1() {		// Other message #1
	return _T("");
	}

const TCHAR *
DXFImport::OtherMessage2() {		// Other message #2
	return _T("");
	}

unsigned int
DXFImport::Version() {				// Version number * 100 (i.e. v3.01 = 301)
	return 100;
	}

void
DXFImport::ShowAbout(HWND hWnd) {			// Optional
 	}

static int deriveButtons[] = { IDC_OBJ_LAYER, IDC_OBJ_COLOR, IDC_OBJ_ENTITY };

static BOOL CALLBACK
ImportOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
	static DXFImport *imp;

	switch(message) {
		case WM_INITDIALOG:
			imp = (DXFImport *)lParam;
			CheckDlgButton( hDlg, deriveButtons[imp->objsFrom], TRUE);
			CheckDlgButton( hDlg, IDC_WELD, imp->weld);
			CheckDlgButton( hDlg, IDC_AUTOSMOOTH, imp->smooth);
			CheckDlgButton( hDlg, IDC_REMOVEDOUBLES, imp->removeDouble);
			CheckDlgButton( hDlg, IDC_FILLPOLYLINES, imp->fillPolylines);
			CheckDlgButton( hDlg, IDC_UNIFYNORMALS, imp->unifyNormals);

			imp->weldSpin = SetupUniverseSpinner(hDlg, IDC_WELDSPINNER, IDC_WELDENTRY,0,999999,imp->thresh);
			imp->smoothSpin = SetupFloatSpinner(hDlg,IDC_SMOOTHSPINNER, IDC_SMOOTHENTRY, 0,360,imp->smoothAngle);
			imp->arcSpin = SetupFloatSpinner(hDlg,IDC_ARCSPINNER, IDC_ARCENTRY, .001f, 90.0f, imp->arcDegrees);
			imp->arcSubSpin = SetupFloatSpinner(hDlg,IDC_ARCSUB_SPIN, IDC_ARCSUB, 10.0f,180.0f, imp->arcSubDegrees);

			CenterWindow(hDlg,GetParent(hDlg));
			return FALSE;
		case WM_DESTROY:
			if ( imp->weldSpin ) {
				ReleaseISpinner(imp->weldSpin);
				imp->weldSpin = NULL;
				}
			if ( imp->smoothSpin ) {
				ReleaseISpinner(imp->smoothSpin);
				imp->smoothSpin = NULL;
				}
			if ( imp->arcSpin ) {
				ReleaseISpinner(imp->arcSpin);
				imp->arcSpin = NULL;
				}
			if ( imp->arcSubSpin ) {
				ReleaseISpinner(imp->arcSubSpin);
				imp->arcSubSpin = NULL;
				}
			return FALSE;
		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDOK: {
					// Unload values into DXFImport statics
					imp->thresh = imp->weldSpin->GetFVal();
					imp->smoothAngle = imp->smoothSpin->GetFVal();
					imp->arcDegrees = imp->arcSpin->GetFVal();
					imp->arcSubDegrees = imp->arcSubSpin->GetFVal();
					imp->weld = IsDlgButtonChecked(hDlg, IDC_WELD);
					imp->smooth = IsDlgButtonChecked(hDlg, IDC_AUTOSMOOTH);
					imp->removeDouble = IsDlgButtonChecked(hDlg, IDC_REMOVEDOUBLES);
					imp->fillPolylines = IsDlgButtonChecked(hDlg, IDC_FILLPOLYLINES);
					imp->unifyNormals = IsDlgButtonChecked(hDlg, IDC_UNIFYNORMALS);
					for(int i = 0; i < NUM_SOURCES; ++i) {
						if(IsDlgButtonChecked(hDlg, deriveButtons[i])) {
							imp->objsFrom = i;
							break;
							}
						}
					EndDialog(hDlg, 1);
					}
					return TRUE;
				case IDCANCEL:
					EndDialog(hDlg, 0);
					return TRUE;
			}
		}
	return FALSE;
	}

#define MAXGTXT 256
#define EOS   0  

// Import types
#define DXF3D 1		// The only one at present

// TRUE if we're inside an insert block
BOOL inInsert = FALSE;

// Forward references
extern short ingroup();
extern int layer_color(char *name);
extern int read_entities(int skiphdr);

// Here's some code which mimics the way 3DS worked -- We keep a list of Mesh objects along with names
// for them.  This list is used by the import module and when it's all done, we dump the meshes into
// the Max database.

// Types (also used in DXFNode):
#define DXF_MESH 0
#define DXF_SHAPE 1

class NamedObject {
	public:
		Mesh mesh;
		BezierShape shape;
		TSTR name;
		int type;
		int color;			// The ACI color index
		NamedObject *next;
		NamedObject(char *n, int t, int c);
		~NamedObject();
	};

NamedObject::NamedObject(char *n, int t, int c) {
	name = n;
	type = t;
	color = c;
	if(type == DXF_SHAPE)
		shape.NewSpline();
	next = NULL;
 	}

NamedObject::~NamedObject() {
	if(type == DXF_SHAPE)
		shape.UpdateSels();
	}

class NamedObjects {
	public:
		NamedObject *head;
		NamedObject *tail;
		int count;
		NamedObjects() { head = tail = NULL; count = 0; }
		~NamedObjects() { DeleteAll(); }
		void DeleteAll();
		int Find(char *name);
		int Add(char *name, int type, int color);
		void Delete(int index);
		int Count() { return count; }
		NamedObject *GetNamedPtr(int index);
	};

void NamedObjects::DeleteAll() {
	NamedObject *next = head;
	while(next) {
		NamedObject *del = next;
		next = del->next;
		delete del;
		}
	head = tail = NULL;
	count = 0;
#ifdef DBGNO
DebugPrint("Deleted all named objects\n");
#endif
	}

int NamedObjects::Find(char *name) {
	NamedObject *ptr = head;
	int index = 0;
	while(ptr) {
		if(strcmp(name, ptr->name) == 0)
			return index;
		index++; 
		ptr = ptr->next;
		}
	return -1;
	}

int NamedObjects::Add(char *name, int type, int color) {
//	if(Find(name) >= 0)
//		return -1;
	NamedObject *n = new NamedObject(name, type, color);
	if(tail)
		tail->next = n;
	tail = n;
	if(!head)
		head = n;
	count++;
#ifdef DBGNO
DebugPrint("Added named object #%d: [%s], type %d, color %d\n",count, name, type, color);
#endif
	return count-1;
	}

void NamedObjects::Delete(int index) {
	assert(index < count);
	NamedObject *ptr = head;
	NamedObject *prev = NULL;
	while(index) {
		if(!ptr) {
			assert(0);
			return;
			}
		prev = ptr;
		ptr = ptr->next;
		index--;
		}
	if(prev)
		prev->next = ptr->next;
	else
		head = ptr->next;
	count--;
	if(tail == ptr)
		tail = prev;
	delete ptr;
#ifdef DBGNO
DebugPrint("Deleted named object #%d\n",index);
#endif
	}

NamedObject *NamedObjects::GetNamedPtr(int index) {
	assert(index < count);
	NamedObject *ptr = head;
	while(index) {
		if(!ptr) {
			assert(0);
			return NULL;
			}
		ptr = ptr->next;
		index--;
		}
	return ptr;
	}

static NamedObjects namedObjs;

static BOOL AddVerts(Mesh *mesh, int add) {
	if(mesh->setNumVerts(mesh->getNumVerts() + add, TRUE))
		return 1;
	return -1;
	}

static BOOL AddFaces(Mesh *mesh, int add) {
	if(mesh->setNumFaces(mesh->getNumFaces() + add, TRUE))
		return 1;
	return -1;
	}

typedef struct {
	Point3 p;
	float wstrt;
	Point3 a0,b0;	/* start corners of quadrilateral */
	Point3 a1,b1;	/* end corners of quadrilateral */
	Point3 ai,bi;	/* intersection points */
	} PLPoint;

DXFImport *theImport;
static short anyWide;
static Point3 pnorm;
static float lastbulge=0.0f;
static int inpoly=0,inrat=0,insmooth=0,inflat=0,mclosed=0,nclosed=0;
static int mcount,ncount;
static float pl_thick;
static short nvper,isThick;
static int dxf_type,entity,last_entity;
static int vertbase;
static int dxfobj,dxfverts,startvert,dxffaces;
static int meshvert,meshface;
static int filmroll_color;
static int pverts=0;
static Point3 normal;             /* Extrusion direction */
static Matrix3 normtm;
static char binsent[30];           /* Binary DXF file sentinel buffer */
static BOOL binary;
static BOOL inShape;				// TRUE=making shape, FALSE=making mesh
static BOOL errored;
static int entnum;
static short gcode;                /* Group code */
static short gint;                 /* Group integer value */
static double greal;                 /* Group double value */
static FILE *fp;
static short isEntityTM;
static double plsw, plew;            /* Polyline default start and end width */
static BOOL isR13;
static int chknum=0;
static char ename[200];             /* Entity type name */
static Mesh *dxf_mesh;				// Working mesh for DXF import
static BezierShape *dxf_shape;		// Working shape for DXF import
static Spline3D *dxf_spline;		// Working spline
static NamedObject *dxf_n;
static int nplverts;
static short polyClosed;
static PLPoint plq[2];  /* previous 2 pline segs */
static PLPoint pl0;  /* first pline segment */
static short isSpline,splineType;
static short is_3d_pline=0;

// Work buffers
static char *inbuf;                /* General purpose text buffer */
static char *gtextv;               /* Group text value */
static char *tgroup[10];           /* Group store table for text */
static double *rgroup;               /* Group store table for reals */
static short *igroup;              /* Group store table for integers */
static int bad_reason;

// Error codes
#define INVALID_FILE -1
#define PARTIAL_READ -2
#define USER_CANCEL -4

struct bylayer {
	char layername[40];
	short frozen;
	};

struct bycolor {
	short color;
	};

union lc {
	struct bylayer l;
	struct bycolor c;
	};

typedef struct dxfnlist {
	union lc lc;
	char objname[256];
	int type;
	struct dxfnlist *next;
	} DXFNode;

static DXFNode *LLIST=NULL;

typedef struct lofflist {
	char layername[40];
	struct lofflist *next;
	} LoffList;
static LoffList *offlayer=NULL;

typedef struct layer0 {
	char name[40];
	short color;
	struct layer0 *next;
	} Layer;
static Layer *onlayer=NULL;
	
typedef struct blockentry {
	char name[200];
	long fileAddr;
	struct blockentry *next;
	}  Block;

static BOOL EqualVectors(Point3 p1, Point3 p2) {
	return (p1 == p2) ? TRUE : FALSE;
	}

/*------------------- BLOCK CONTEXT ------------------- */
static short blockLevel = 0;
static Matrix3 curtm;
static Block *blockList=NULL, *curBlock=NULL, *lastBlock=NULL;
static char curLayer[40]=""; 	
static short curBlockCol;

size_t Read(FILE *fp, void *ptr, int count) {
	size_t result = fread(ptr, 1, count, fp);
	theImport->pctcounter++;
	if(theImport->pctcounter > 100) {
		theImport->pctcounter = 0;
		long pos = ftell(fp);
		int pct = pos * 100 / theImport->fileLength / 2;
		if(pct > theImport->lastpct) {
			theImport->lastpct = pct;
			theImport->gi->ProgressUpdate(pct);
			}				
		}
	return result;
	}

/* InRange: */
#define IR(low,high) ((gcode>=low)&&(gcode<high))

inline void PUTVERT(Mesh *t, int i, const Point3& v) {
#ifdef DBGDXF
	DebugPrint(" put_vert # %d, = %.7f,%.7f,%.7f \n", i, v.x,v.y,v.z);
#endif
	t->verts[i] = v;
	}

inline void PUTFACE(Mesh *t, int i, const Face& f) {
#ifdef DBGDXF2
	DebugPrint(" put_face # %d, = (%d,%d,%d)\n", i, f.v[0],f.v[1],f.v[2]);
#endif
	t->faces[i] = f;
	}

/*  DXFERR  --  Diagnose unspecific error in DXF file  */

static void dxferr() {
	errored = TRUE;
	/*        dumpgroup();*/
	}

void TransPt(Point3 &p) {
	if (blockLevel>0)
		p = p * curtm;
	}

static void ApplyTransform(Point3 &p) {
	if (isEntityTM)
		p = p * normtm;
	TransPt(p);
	}

int user_cancel() {
	if (errored) return(1);
	if(theImport->gi->GetCancel()) {
		bad_reason = USER_CANCEL;
		return 1;
		}
	return(0);
	}

/*  INENT  --  Read in next entity  */

static short inent(void) {
	short i;

	if (gcode != 0) {
		dxferr();
		return FALSE;
		}
	if (!strcmp(gtextv, "ENDSEC"))
		return FALSE;           /* End of entity section */
	if (!strcmp(gtextv, "ENDBLK"))
		return FALSE;           /* End of entity section */
	strcpy(ename, gtextv);

#ifdef DBGDXF1
	DebugPrint(" Entity = %s \n",ename);
#else

#ifdef IS_3DSDXF
	if ( ((++entnum)%10)==0) {
		int nv,nf;
		char oname[20];
		nv=nf=0;
		oname[0]=0;
		if (dxfobj>=0) {
			Namedobj *n = get_named_ptr(dxfobj);
			Tri_obj *t = n->dstruct;
			nv = t->verts;
			nf = t->faces;
			strcpy(oname,n->name);
//			DebugPrint(" Entity #%5d:%8s  Object \"%8s\"  V:%5d  F:%5d  #obs:%3d    \r",
//				entnum++,ename, oname,nv,nf,OBJECTS);
			}
//		else 
//			DebugPrint(" Entity #%5d: %8s          \r",entnum++,ename);
		}

#endif
#endif
	/* Supply defaults to fields  */

	igroup[62] = -1;  /* undefined color */
	igroup[67] = 0;
	rgroup[38] = 0.0;
	rgroup[39] = 0.0;
	isEntityTM = 0;
	normal = Point3(0,0,1);

	for (i = 0; i < 10; i++)
		tgroup[i][0] = EOS;
	if (!strcmp(ename, "TEXT")) {
		rgroup[50] = 0.0;
		rgroup[41] = 1.0;
		rgroup[51] = 0.0;
		igroup[71] = 0;
		igroup[72] = 0;
		} 
	else if (!strcmp(ename, "SHAPE")) {
		rgroup[50] = 0.0;
		rgroup[40] = 1.0;
		rgroup[51] = 0.0;
        } 
	else if (!strcmp(ename, "INSERT")) {
		igroup[66] = 0;
		rgroup[41] = rgroup[42] = rgroup[43] = 1.0;
		rgroup[50] = 0.0;
		igroup[70] = 1;
		igroup[71] = 1;
		rgroup[44] = 0.0;
		rgroup[45] = 0.0;
        } 
	else if (!strcmp(ename, "ATTDEF")) {
		igroup[73] = 0;
		rgroup[50] = 0.0;
		rgroup[41] = 1.0;
		rgroup[51] = 0.0;
		igroup[71] = 0;
		igroup[72] = 0;
        } 
	else if (!strcmp(ename, "ATTRIB")) {
		igroup[73] = 0;
		rgroup[50] = 0.0;
		rgroup[41] = 1.0;
		rgroup[51] = 0.0;
		igroup[71] = 0;
		igroup[72] = 0;
        } 
	else if (!strcmp(ename, "POLYLINE")) {
		igroup[75] = 0;
		igroup[70] = 0;
		rgroup[40] = 0.0;
		rgroup[41] = 0.0;
        }  
	else if (!strcmp(ename, "VERTEX")) {
		rgroup[40] = plsw;
		rgroup[41] = plew;
		rgroup[42] = 0.0;
		igroup[70] = igroup[71] = igroup[72] = igroup[73] = igroup[74] = 0;
		rgroup[50] = 0.0;
		}  
	else if (!strcmp(ename, "3DFACE")) {
		igroup[70] = 0;
		}

	while (TRUE) {
		if (!ingroup()) {
			dxferr();
			return FALSE;
			}
		if (gcode == 0)
			break;
		if (gcode < 10) {
			strncpy(tgroup[gcode], gtextv, 256); 
			}
		else if (gcode < 60)                  /* reals */
			rgroup[gcode] = greal;
		else if (gcode >= 210 && gcode < 240) /* extrusion dirs */
			normal[gcode / 10 - 21] = (float)greal;
		else if (gcode >= 60 && gcode < 80)   /* ints */
			igroup[gcode] = gint;
		}   

#ifdef DBGCOL
	DebugPrint(" INENT: layer = %s, color = %d \n",tgroup[8],igroup[62]);
#endif

	/* If in a block, and the layer is "0", use the parent's layer */
	if ((blockLevel>0)&&(strcmp(tgroup[8],"0")==0)) {
		strcpy(tgroup[8],curLayer);
#ifdef DBGCOL
		DebugPrint(" Inheriting current layer = %s \n",curLayer);
#endif
		}

	if (igroup[62]==0) {		/* BYBLOCK */
		if (blockLevel>0) {
			igroup[62] = curBlockCol;
#ifdef DBGCOL 
			DebugPrint(" inheriting BLOCK color = %d \n",igroup[62]);
#endif
			}
		else 
			igroup[62] = 7;
		}
	else {
		if (igroup[62]==-1) {
			igroup[62]=layer_color(tgroup[8]);
#ifdef DBGCOL 
			DebugPrint(" INENT:inheriting LAYER (%s) color = %d \n",tgroup[8],igroup[62]);
#endif
			}
		}

#ifdef DBGCOL 
  	DebugPrint(" FINAL color = %d \n",igroup[62]);
#endif

	if (!strcmp(ename, "POLYLINE")) {
		plsw = rgroup[40];
		plew = rgroup[41];
		}

	return TRUE;
	}

#if 0
getStr(char *buf, int maxc, FILE *f) {
	char c;
	for(i=0; i<maxc; i++) {
		if(!fread(&c,1,1,f)) return 0;
		if (c==CR) continue;
		if (c==LF) 
		}	
	}
#endif	


#define NEWLINE 0xA
#define CR 0xD
static char cpeek; 
static char *getstr(FILE *file,  char *buffer,  LONG maxBytes) {
	int nBytes;
	char c;
	for (nBytes=0; nBytes<maxBytes-1;) {
		if(fread(&c,1,1,file)!=1) return NULL;
		if (c==NEWLINE) {
			buffer[nBytes] = 0;
			break;
			}
		if (c==CR) {
			buffer[nBytes] = 0;
			if(fread(&c,1,1,file)!=1) return buffer;
			if (c!=NEWLINE) {
				cpeek=c;
			  	fseek(file,-1,SEEK_CUR);
				}
			break;
			}
		buffer[nBytes++] = c;
		}
	return(buffer);
	}

/*  GETLINE  --  Obtain next line from input file  */

static BOOL getline() {
	inbuf[255]=0;
	if (getstr(fp,inbuf,256)==NULL)
		return FALSE;
//	if(fgets(inbuf,256,fp)==NULL)
//		return FALSE;
	int len = strlen(inbuf);
	if(inbuf[len-1] == '\n')
		inbuf[len-1] = 0;
	theImport->pctcounter++;
	if(theImport->pctcounter > 100) {
		theImport->pctcounter = 0;
		long pos = ftell(fp);
		int pct = pos * 100 / theImport->fileLength / 2;
		if(pct > theImport->lastpct) {
			theImport->lastpct = pct;
			theImport->gi->ProgressUpdate(pct);
			}				
		}
	return TRUE;
	}

/*  GETTYPE  --  Get the identifier (gcode) for the data item */

static int gettype(short *type)	{
	unsigned short t;
	if (isR13) {
		if (Read(fp,&t, 2)==2) { 
			*type = (short) t;
			return TRUE;
			}
		return FALSE;
		}
	else {
		BYTE b;
		if (Read(fp,&b, 1)==1) { 
			*type = (short) b;
			if (b==0xff) {
				if (Read(fp,type,2)==2) {
#ifdef DBGDXF
					DebugPrint(" Extended entity %d \n",*type);
#endif
					return(TRUE);
					}
				else
					return(FALSE);
				}
			return TRUE;
			}
		}
	return FALSE;
	}



static int GetCh() {
	char c;
	if (Read(fp, &c, 1)==1) return(c);
	return(0);
	}

/*  GETSTRING  --  Get a string from the binary file */

static void getstr(char *s) {
	char c;
	int n;
	for (n=0;n<MAXGTXT-1;n++) {
		if (Read(fp, &c, 1)!=1) c = 0;
		if (!((*s++)=c)) return;
		}
	if (c)	while ((c=GetCh())!=0) ;
	}

/*  GETSHORT  --  Get an integer (in 8086 order!) from the binary file */

static int getshort(short *ptr) {
	if (Read(fp,ptr, 2)==2) {
		return TRUE;
		}
	return FALSE;
	}

/*  GETREAL  --  Get a double (double) from the binary file in IEEE */

static int getreal(double *ptr) {
	if (Read(fp,ptr,8)==8) {
		return TRUE;
		}
	return FALSE;
	}


static TCHAR decimalSymbol = _T('.');
static TCHAR groupSymbol = _T(',');

static void GetDecSymbolFromRegistry() {
    HKEY hKey;
    DWORD dwType, numBytes;
	long status;
    unsigned char symbol[80];
	status = RegOpenKeyEx (HKEY_CURRENT_USER, 
		      "Control Panel\\International", 
		      0, KEY_READ, &hKey);
    if (status == ERROR_SUCCESS) {
		if (ERROR_SUCCESS==RegQueryValueEx (hKey, "sDecimal", 0, &dwType, 
			 symbol, &numBytes))
			decimalSymbol = symbol[0];
		if (ERROR_SUCCESS==RegQueryValueEx (hKey, "sThousand", 0, &dwType, 
					 symbol, &numBytes))
			groupSymbol = symbol[0];
	    }
	}

TCHAR *FixDecimalSymbol(TCHAR *buf)
	{
	TCHAR *cp = buf;
	while(*cp) {
		if( *cp == _T('.'))
			*cp = decimalSymbol;
		else if (*cp == _T(','))
			*cp = groupSymbol;
		cp++;
		}
	return buf;
	}

/*  INGROUP  --  Read in group from DXF file  */

static short ingroup() {
	short wcode;

	if (((++chknum)&15)==0) if (user_cancel()) return FALSE;

	if (binary) {
		/* We're reading a binary file */
		if (!gettype(&gcode)) {	/* End of file */
			return FALSE;
			}
#ifdef DBGINGR
	  	DebugPrint(" Binary INGROUP, gcode = %d ",gcode);
#endif
		if (gcode < 0) { 
#ifdef R13FIX
#ifdef DBGINGR
			DebugPrint(" Negative gcode: %d \n", gcode);
#endif
		
			return TRUE;
#else 
			errored = TRUE; return FALSE; 
#endif
			}
		if (gcode==1004||IR(310,320)) {
			unsigned char c;
			Read(fp,&c, 1); /* read number of bytes */
			fseek(fp,c, 1);  /* skip over them */
			}
		else if (IR(0,10)||IR(100,140)||IR(300,310)||IR(320,370)||IR(1000,1010)){
			getstr(gtextv);
#ifdef DBGINGR
		  	DebugPrint("getstr = %s \n", gtextv);
#endif
			}
		else if (IR(10,60)||IR(140,170)||IR(210,240)||IR(1010,1060)) {
			getreal(&greal);
#ifdef DBGINGR
		  	DebugPrint(" greal = %.4f \n", greal);
#endif
			}
		else if (gcode==1071||IR(90,100)) {
			long dum;
			Read(fp,&dum,4);
			}
		else if ( IR(60,80)||IR(170,210)||IR(270,280)||IR(1070,1080)) {
			getshort(&gint);
#ifdef DBGINGR
		  	DebugPrint(" gint = %d \n", gint);
#endif
			}
		else if (IR(80,90)||IR(280,290)) {
			char cdum;
			Read(fp,&cdum,1);
#ifdef DBGINGR
		  	DebugPrint(" char = %x \n", cdum);
#endif
			}					 
		else {              /* unknown gcode */
#ifdef DBGINGR
	  		DebugPrint(" unknown gcode = %d \n",wcode);
#endif
#ifdef R13FIX
			return TRUE;
#else 
			errored = TRUE; return FALSE; 
#endif
			}
#ifdef DBGINGR
	  	DebugPrint("\n");
#endif
        return TRUE;
   	} 
			
	else { /* We're reading an ASCII DXF file */
		if (getline()) {
			if (sscanf(inbuf, "%hd", &gcode) != 1) {
				// This used to return errored = TRUE, but it
				// was causing files from "Animation Master" to fail to
				// load, because they have a bogus char or two at the end
				// of their file.  I hope this "fix" is harmless
				//     DS 3-14-96
				// errored = TRUE; 
				return FALSE;
				}
#ifdef DBGINGR
	  	DebugPrint("ASCII INGROUP, gcode = %d /",gcode);
#endif
			wcode=gcode;
			if(wcode>=1000)	/* Extended group code ignored */
				wcode-=1000;
			if (wcode < 0) { 
#ifdef R13FIX
#ifdef IS_3DSDXF
			DebugPrint(" Negative gcode: %d \n", gcode);
#endif
				return TRUE;
#else 
				errored = TRUE; return FALSE; 
#endif
				}
			if (!getline()) {
				errored = TRUE;
				return FALSE;
				}
#ifdef DBGINGR
		  	DebugPrint(" %s\n",inbuf);
#endif
			if (wcode < 10) { strcpy(gtextv, inbuf); } 
			else if (wcode < 60) {
				FixDecimalSymbol(inbuf);
				if (sscanf(inbuf, "%lf", &greal) != 1) {
					errored = TRUE;
					return FALSE;
					}
				} 
			else if (wcode >= 210 && wcode < 240) {
				FixDecimalSymbol(inbuf);
				if (sscanf(inbuf, "%lf", &greal) != 1) {
					errored = TRUE;
					return FALSE;
					}
				} 
			else if (wcode >= 60 && wcode < 80) {
				if (sscanf(inbuf, "%hd", &gint) != 1) {
					errored = TRUE;
					return FALSE;
					}
				} 
			else if (wcode==999) {  /* Skip comment */
#ifdef DBGINGR
				DebugPrint("Comment: [%s]\n",inbuf); 
#endif
				}
			else if (wcode >= 140 && wcode < 150) { }
			else if (wcode >= 170 && wcode < 180) { }
			else if (wcode >= 60 && wcode < 80) { }
			else if (wcode >= 1000) {	/* Ignore >1000 */  }
			else {  /* unknown gcode */
#ifdef DBGINGR
		  		DebugPrint(" unknown gcode = %d \n",wcode);
#endif
#ifdef R13FIX
				return TRUE;
#else 
				errored = TRUE; return FALSE; 
#endif
				}
			return TRUE;
			}
		return FALSE;              /* End of file */
	    }
	} 

#ifdef DBGDXF
void prblocks(void) {
	Block *bl;
	DebugPrint("\n BLOCK LIST------- \n");
	for (bl=blockList; bl!=NULL; bl = bl->next) {
		DebugPrint("    Block [%X]   %s \n",bl->fileAddr, bl->name);
		}
	DebugPrint("--------------------------\n\n");
	}
#endif

/*  INBLOCK  --  Read in next block  */

static short inblock(void) {
	Block *bl;

	if (gcode != 0) { 
		dxferr();	
		return FALSE; 
		}

	if (!strcmp(gtextv, "ENDSEC"))
		return FALSE;	/* End of BLOCKS section */

	if (strcmp(gtextv, "BLOCK")) { dxferr(); return FALSE; }

	bl = (Block *)malloc(sizeof(Block));
	if (bl==NULL) return(FALSE);
	bl->name[0] = 0;
	bl->next = blockList;
	blockList = bl;
	bl->fileAddr = ftell(fp);

#ifdef DBGDXF
	DebugPrint(" INBLOCK, addr = %X \n",bl->fileAddr);
#endif
	while (!errored) {
		if (!ingroup()) {	dxferr();	return FALSE; }
		if (gcode == 0) break;
		if (gcode < 10)
			strncpy(tgroup[gcode], gtextv, 256); /* text */
		}   

	strcpy(bl->name,tgroup[2]);

	if (strcmp(gtextv,"ENDBLK")!=0) {
		while (!errored) {
			if (!ingroup()) {	dxferr();	return FALSE; }
			if (gcode == 0) {
				if (strcmp(gtextv,"ENDBLK")==0) break;
				}
			}   
		}

	/* Read in the ENDBLK entity; */
	while (!errored) {
		if (!ingroup()) { dxferr();	return FALSE; }
		if (gcode == 0) 
			break;
		}   

#ifdef DBGDXF
	DebugPrint(" exit INBLOCK, addr = %X, name =%s \n",bl->fileAddr,bl->name);
	prblocks();
#else
#ifdef IS_3DSDXF
	DebugPrint(" Block read: %s        \r",bl->name);
#endif
#endif
	return TRUE;
	}


/* READ_BLOCKS  */

int read_blocks(void) {
	int nbl=0;

	if (!errored && !ingroup())	{
		dxferr();
		return(0);
		}
	while (!errored && inblock())  nbl++ ;
	if(errored)
		return(0);
	return(1);
	}

/* READ_TABLES */

int read_tables(void) {
	struct lofflist *ol;

	if (!errored && !ingroup()) {
		dxferr();
		return(0);
		}
	while (!errored && inent())	{
		if (!strcmp(ename, "LAYER") && tgroup[2]!=NULL)	{
			if(igroup[62]<0 || (igroup[70] & 1)) {
				if((ol = (LoffList *)malloc(sizeof(LoffList)))==NULL) {
					if(showPrompts)
						no_RAM();
					return(0);
					}
				ol->next=offlayer;
				offlayer=ol;
				strcpy(ol->layername,tgroup[2]);
#ifdef DBGCOL 
				DebugPrint("*** OFF Layer %s\n",ol->layername);
#endif
				}
			else {
				Layer *layer;
				if((layer = (Layer *)malloc(sizeof(Layer)))==NULL) {
					if(showPrompts)
						no_RAM();
					return(0);
					}
				strcpy(layer->name,tgroup[2]);
				layer->color = igroup[62];
				layer->next = onlayer;
#ifdef DBGCOL 
				DebugPrint("*** Layer %s, color = %d \n",layer->name,layer->color);
#endif
				onlayer = layer;
				}
			}
		}
	if(errored)
		return(0);
	return(1);
	}

/*****
See if a given layer is being ignored
*****/

int ignore_layer(char *name) {
	struct lofflist *ol;
	
	if(name==NULL)
		return(0);
	
	ol=offlayer;
	while(ol != NULL) {
		if(strcmp(name,ol->layername)==0)
			return(1);
		ol=ol->next;
		}
	return(0);
	}

static int layer_color(char *name) {
	Layer *l;
	if(name==NULL)	return(0);
	for (l=onlayer; l!=NULL; l= l->next) 
		if(strcmp(name,l->name)==0)
			return(l->color);
	return(0);
	}

/***** Free up  lists *****/
static void free_lists(void)	{
	struct dxfnlist *lp,*nlp;
	struct lofflist *ol,*nol;
	Layer *layer,*nextlayer;
	Block *bl,*nbl;

	/* Free layer list */
	for (lp=LLIST; lp!=NULL; lp = nlp) {
		nlp = lp->next;
		free(lp);
		}
	LLIST=NULL;
	
	/* Free ignored layer list */
	for (ol=offlayer; ol!=NULL; ol = nol) {
		nol = ol->next;
		free(ol);
		}
	offlayer=NULL;

	
	/* Free active layer list */
	for (layer=onlayer; layer!=NULL; layer = nextlayer) {
		nextlayer = layer->next;
		free(layer);
		}
	onlayer=NULL;

	/* Free block list */
	for (bl = blockList; bl!=NULL; bl = nbl) {
		nbl = bl->next;
		free(bl);
		}
	blockList = NULL;
	}

/*------------ POINT ----------------*/
int dxfpoint(void)	{
	return(0);
	}

/*------------ VERT ----------------*/

void load_vert(Point3 &v, int n) {
	v.x = (float)rgroup[n];
	v.y = (float)rgroup[n+10];
	v.z = (float)rgroup[n+20];
	if (rgroup[38]!=0.0) v.z = (float)rgroup[38];
#ifdef DBGDXF
	DebugPrint("load_vert, vert = (%.5f, %.5f %.5f)\n",v.x,v.y,v.z);
#endif
	}

uchar acad_mtl(int colorwk) {
//	char tryname[32];
	/* color 255 is a legal ACAD color, but it is DEFAULT for 3DStudio:
		use 254 instead */
	if (colorwk==255) colorwk = 254; 
	if (colorwk>256||colorwk<=0) return(255);
//	sprintf(tryname,"%s%02d",progstr(KFST0078),colorwk);
//	return(inst_material(tryname,0));
	return 255;
	}

static uchar get_mtl_id() { 
	return(acad_mtl(igroup[62])); 
	}

typedef struct {
	Point3 p;
	float ws,bulge;
	} PVert;

typedef Tab<PVert> PVertTab;

PVertTab pvtab;
#define PV_EL(i)  (&pvtab[i])

void RecPlineVert(Point3 p, float ws, float bulge) {
	PVert pv;
	if (ws>0.0) anyWide = 1;
	pv.p = p;
	pv.ws = ws;
	pv.bulge = bulge;
	pvtab.Append(1, &pv);
	}

/* Find angle for given vector, and its 90-degree offset	*/
/* Returns angles in radians					*/
/* Returns 0 if angle indeterminate				*/

int
find_angle(float deltax,float deltay,float *angle,float *angle90) {
	float awk,a90wk;

	if(deltax==0.0f) {
		if(deltay==0.0f) {
			if(angle)
				*angle=0.0f;
			if(angle90)
				*angle90=0.0f;
			return(0);
			}
		if(deltay<0.0f)
			awk=PI + HALFPI;	// 270
		else
			awk=PI;				// 90
		goto get_90;
		}
	if(deltay==0.0f) {
		if(deltax<0.0f)
			awk=TWOPI;
		else
			awk=0.0f;
		goto get_90;
		}

	awk=(float)atan(deltay/deltax);

	if(deltax<0)
		awk+=PI;
	while(awk<0.0)
		awk+=TWOPI;
	while(awk>=TWOPI)
		awk-=TWOPI;

	get_90:
	a90wk=awk+HALFPI;
	while(a90wk>=TWOPI)
		a90wk-=TWOPI;

	if(angle)
		*angle=awk;
	if(angle90)
		*angle90=a90wk;
	return(1);
	}

/* Find the vector length for a circle segment	*/
/* Returns a unit value (radius=1.0)		*/
/* Angle expressed in radians			*/

static float
veccalc(float angstep) {
	static float lastin = -9999.0f,lastout;
	if(lastin == angstep)
		return lastout;

	float lo,hi,totdist;
	float sinfac=(float)sin(angstep),cosfac=(float)cos(angstep),test;
	int ix,count;
	Spline3D work;
	Point3 k1((float)cos(0.0f),(float)sin(0.0f),0.0f);
	Point3 k2(cosfac,sinfac,0.0f);

	hi=1.5f;
	lo=0.0f;
	count=200;

	/* Loop thru test vectors */

	loop:
	work.NewSpline();
	test=(hi+lo)/2.0f;
	Point3 out = k1 + Point3(0.0f, test, 0.0f);
	Point3 in = k2 + Point3(sinfac * test, -cosfac * test, 0.0f);

 	work.AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,k1,k1,out));
 	work.AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,k2,in,k2));

	totdist=0.0f;
	for(ix=0; ix<10; ++ix) {
		Point3 terp = work.InterpBezier3D(0,(float)ix/10.0f);
		totdist += (float)sqrt(terp.x * terp.x + terp.y * terp.y);
		}
	
	totdist /= 10.0f;
	count--;
	if(totdist==1.0f || count<=0)
		goto done;
	if(totdist>1.0f) {
		hi=test;
		goto loop;
		}
	lo=test;
	goto loop;

	done:
	lastin = angstep;
	lastout = test;
	return test;
	}

/*--------------------------------------------------
Process bulge information for a given segment and
convert to Bezier curve control vertices
-------------------------------------------------*/

class WorkKnot {
	public:
		Point3 p;
		Point3 in;
		Point3 out;
		WorkKnot() { p = in = out = Point3(0,0,0); }
		WorkKnot(Point3 p, Point3 i, Point3 o) { this->p = p; in = i; out = o; }
		WorkKnot(Spline3D *spline, int index);
	};

WorkKnot::WorkKnot(Spline3D *spline, int index) {
	p = spline->GetKnotPoint(index);
	in = spline->GetInVec(index);
	out = spline->GetOutVec(index);
	}

// NEW ALGORITHM ==========================================
// DS 4/7/96

int  proc_bulge(WorkKnot *p1,WorkKnot *p2, WorkKnot *pmid, float bulge)	{
	double angle,wlength;
	double radius,veclen,vecang,chordang,perpang,radang;
	double dx,dy,angsign,rotang;
	int midVerts = 0;

#ifdef DBGBULG
	DebugPrint("\nproc bulge: p1 = (%.3f,%.3f,%.3f), p2 = (%.3f,%.3f,%.3f) bulge=%.3f\n",
		p1->p.x,p1->p.y,p1->p.z,p2->p.x,p2->p.y,p2->p.z,bulge);

#endif

	float maxAng = DegToRad(theImport->arcSubDegrees);

	dx = p2->p.x-p1->p.x;
	dy = p2->p.y-p1->p.y;
	
	wlength = sqrt(dx*dx+dy*dy);
	
	angsign = (bulge>0.0f)?1.0f:-1.0f;
	angle = atan(fabs(bulge))*4.0;
	if (angle==0.0) {
		//straight line:	
		p1->out = p1->p + (p2->p-p1->p)/3.0f;
		p2->in  = p2->p + (p1->p-p2->p)/3.0f;
		return FALSE;
		}

	chordang = atan2(dy,dx);
	radius = float(wlength/(2.0*sin(angle/2.0)));
	vecang = angsign*(angle/2.0);
	rotang = chordang-vecang;

	if (angle>maxAng) {
		Point3 pm = (p1->p+p2->p)/2.0f; // midpoint of chord
		double pd = (wlength/2.0)/fabs(tan(angle/2.0)); // perp dist from center to chord

		perpang = chordang+angsign*HALFPI;
		if (angle>PI) perpang+=PI;

		Point3 norm(cos(perpang),sin(perpang),0.0); // perp to chord, towards center of circle
		Point3 cent(pm+float(pd)*norm);  // center of circle

		midVerts = int(angle/maxAng);
		if (midVerts>=MAXMID) 
			midVerts = MAXMID;

		double newang = angle/double(midVerts+1);
		veclen = veccalc(float(newang)) * radius;

		p1->out.x = p1->p.x + float(veclen*cos(rotang));
		p1->out.y = p1->p.y + float(veclen*sin(rotang));
		p1->out.z = p1->p.z;

		for (int i=0; i<midVerts; i++) {
			rotang += angsign*newang;
			radang = rotang-HALFPI*angsign;
			WorkKnot &pm = pmid[i];
			pm.p = cent + float(radius)*Point3((float)cos(radang),(float)sin(radang),p1->p.z);	
			float xl = float(veclen*cos(rotang)); 
			float yl = float(veclen*sin(rotang));
			pm.in.x  = pm.p.x - xl;
			pm.in.y  = pm.p.y - yl;
			pm.out.x = pm.p.x + xl;
			pm.out.y = pm.p.y + yl;
			pm.out.z = pm.in.z = pm.p.z;
			}

		rotang = chordang+PI+vecang;
		p2->in.x = p2->p.x + float(veclen*cos(rotang));
		p2->in.y = p2->p.y + float(veclen*sin(rotang));
		p2->out.z = p2->p.z;
		}
	else {
		veclen = veccalc((float)angle) * radius;
	
		p1->out.x = p1->p.x + float(veclen*cos(rotang));
		p1->out.y = p1->p.y + float(veclen*sin(rotang));
		p1->out.z = p1->p.z;
	
		rotang = chordang+PI+vecang;
		p2->in.x = p2->p.x + float(veclen*cos(rotang));
		p2->in.y = p2->p.y + float(veclen*sin(rotang));
		p2->out.z = p2->p.z;
		}

	return midVerts;
	}


static int vert (void)	{
	Point3 v;
	Face f;
	static WorkKnot lastKnot;

#ifdef DBGDXF
	DebugPrint(" VERT: (%.3f, %.3f, %.3f): ptct=?? isSpline=%d\n",rgroup[10],rgroup[20],rgroup[30],/*ptct,*/isSpline);
#endif
	if (dxf_type==DXF3D) {
		/* ---- 3D --------- */
		if(inShape) {
			if(igroup[70] & 16)
				return(0);	   /* spline frame control point */
	
			load_vert(v,10);
	
			NormTrans(v, pnorm);  // ????
	
			//TransPt(v);  /* for blocks */	 // DS 4/6/96 -- this is done later in ApplyTransform

			Point3 in = v;
			Point3 out = v;

			WorkKnot k(v,v,v);
			WorkKnot kmid[MAXMID];

			/* If previous vertex had a bulge, process it here */
	
			int midpts = 0;
			if(lastbulge!=0.0) {
				midpts = proc_bulge(&lastKnot,&k,kmid,lastbulge);
				int lastpt = dxf_spline->KnotCount() - 1;
				if(lastpt >= 0)
					dxf_spline->SetOutVec(lastpt, lastKnot.out);
				}
			
			assert(dxf_spline != NULL);

			for (int i=0; i<midpts; i++)
				dxf_spline->AddKnot(SplineKnot(KTYPE_BEZIER, LTYPE_CURVE, kmid[i].p, kmid[i].in, kmid[i].out));

			dxf_spline->AddKnot(SplineKnot(KTYPE_BEZIER, LTYPE_CURVE, k.p, k.in, k.out));
			if(inpoly && polyClosed)
				dxf_spline->SetClosed();

			if(inpoly)
				pverts++;
	
			lastKnot = k;
			}
		else {
			if(inrat) {
				if((igroup[70] & 192)==192) { 	/* Rat vert */
					if(meshvert>=dxfverts)	{
						dxfverts+=10;
						dxf_mesh->setNumVerts(dxf_mesh->getNumVerts() + 10, TRUE);
						}
					load_vert(v,10);
//					TransPt(v);  /* for blocks */
					ApplyTransform(v);  // entity tm  & block tm DS 4/5/96
					dxf_mesh->setVert(meshvert++, v);
					}
				else
				if((igroup[70] & 192)==128) {	/* Rat face */
	
					/* Don't add face w/less than 3 verts */
	
					if(igroup[71]==0 || igroup[72]==0 || igroup[73]==0)	{
						bad_rat:
						if(showPrompts)
							Alert(IDS_TH_INVALIDRATSNEST);

						killmesh:
						if (dxfobj>=0)
							namedObjs.Delete(dxfobj);
						return(1);
						}
					if((abs(igroup[71])==abs(igroup[74])) ||
							(abs(igroup[72])==abs(igroup[74])) ||
							(abs(igroup[73])==abs(igroup[74])))
						igroup[74]=0;
					if(abs(igroup[71])>(meshvert-vertbase) ||
							abs(igroup[72])>(meshvert-vertbase) ||
							abs(igroup[73])>(meshvert-vertbase) || 
							abs(igroup[74])>(meshvert-vertbase))
						goto bad_rat;
					if(meshface>=(dxffaces-1))	{
						/* Could be two tri-faces */
						dxffaces+=10;
						dxf_mesh->setNumFaces(dxf_mesh->getNumFaces() + 10, TRUE);
						}
					f.setMatID(get_mtl_id());
					f.smGroup=0;
					if(igroup[74]==0) {
						f.flags |= EDGE_ALL;
						if(igroup[71]<0)
							f.flags &= ~EDGE_A;
						if(igroup[72]<0)
							f.flags &= ~EDGE_B;
						if(igroup[73]<0)
							f.flags &= ~EDGE_C;
						f.v[0]=abs(igroup[71])-1+vertbase;
						f.v[1]=abs(igroup[72])-1+vertbase;
						f.v[2]=abs(igroup[73])-1+vertbase;
						if(f.v[0]!=f.v[1] && f.v[0]!=f.v[2] && f.v[1]!=f.v[2])
							dxf_mesh->faces[meshface++] = f;
						}
					else
						{
						f.flags=EDGE_A | EDGE_B;
						if(igroup[71]<0)
							f.flags &= ~EDGE_A;
						if(igroup[72]<0)
							f.flags &= ~EDGE_B;
						f.v[0]=abs(igroup[71])-1+vertbase;
						f.v[1]=abs(igroup[72])-1+vertbase;
						f.v[2]=abs(igroup[73])-1+vertbase;
						if(f.v[0]!=f.v[1] && f.v[0]!=f.v[2] && f.v[1]!=f.v[2])
							dxf_mesh->faces[meshface++] = f;
	
						f.flags=EDGE_A | EDGE_B;
						if(igroup[73]<0)
							f.flags &= ~EDGE_A;
						if(igroup[74]<0)
							f.flags &= ~EDGE_B;
						f.v[0]=abs(igroup[73])-1+vertbase;
						f.v[1]=abs(igroup[74])-1+vertbase;
						f.v[2]=abs(igroup[71])-1+vertbase;
						if(f.v[0]!=f.v[1] && f.v[0]!=f.v[2] && f.v[1]!=f.v[2])
							dxf_mesh->faces[meshface++] = f;
						}
					}
				}
			else
			if(insmooth) {
				if(igroup[70] & 8) {
					if(meshvert>=dxfverts) {
						if(showPrompts)
							Alert(IDS_TH_INVALIDSPLINEMESH);
						goto killmesh;
						}
					load_vert(v,10);
//					TransPt(v);  /* for blocks */
					ApplyTransform(v);  // entity tm  & block tm DS 4/5/96
					dxf_mesh->setVert(meshvert++, v);
					}
				}
			else
			if (inflat) {
				if(igroup[70] & 64) {
					if(meshvert>=dxfverts) {
						if(showPrompts)
							Alert(IDS_TH_INVALID3DMESH);
						goto killmesh;
						}
					load_vert(v,10);
//					TransPt(v);  /* for blocks */
					ApplyTransform(v);  // entity tm  & block tm DS 4/5/96
					dxf_mesh->setVert(meshvert++, v);
					}
				}
			if (inpoly) {
				Point3 p;
			
				if(igroup[70] & 16)
					return(0);	   /* spline frame control point */

				load_vert(p, 10);

				RecPlineVert(p, (float)rgroup[40], (float)rgroup[42]);
				}
			}
		}
	lastbulge = (float)rgroup[42];
	return(0);
	}

/* Find a named object's number */
/* Returns -1 if not found */

int
nobj_number(char *name) {
	return namedObjs.Find(name);
	}

#if 0
/* Strip numbers off the end of a name -- prepares it for next naming */

void
name_strip(char *name)
	{
	while(strlen(name)>0 && name[strlen(name)-1]>='0' && name[strlen(name)-1]<='9')
		name[strlen(name)-1]=0;
	}

void
inc_name(char *string,int limit) {
	int ix,len,numlen;
	long count;
	char number[20];

	len=strlen(string);
	ix=len-1;

	while(ix>=0 && isdigit(string[ix]))
	 --ix;
	++ix;

	if(ix!=len)
	 count=atol(&string[ix])+1;
	else
	 count=1;

	loop:
	sprintf(number,"%02ld",count);
	numlen=strlen(number);
	if(numlen>limit)
	 {
	 count=1;
	 goto loop;
	 }
	if((ix+numlen)>limit)
	 ix=limit-numlen;
	strcpy(&string[ix],number);
	}

#endif

void
nextname(char *iprefix,char *output) {
	strcpy(output,iprefix);
	MakeNameUnique(output);
#if 0
	name_strip(output);
	loop:
	inc_name(output,32);
	while(namedObjs.Find(output)>=0)
		goto loop;
#endif
	}

static int find_layer(int type) {
	DXFNode *lp;
	for (lp=LLIST; lp!=NULL; lp = lp->next) {
	 	if(strcmp(tgroup[8],lp->lc.l.layername)==0 && lp->type == type)	
	 		return(nobj_number(lp->objname));
		}
	return(-1);
	}

static int find_color(int type) {
	DXFNode *lp;
	for (lp=LLIST; lp!=NULL; lp = lp->next) {
		if(lp->lc.c.color==igroup[62] && lp->type == type)
	 		return(nobj_number(lp->objname));
		}
	return(-1);
	}					  

static int find_flmcol(int type) {
	DXFNode *lp;
	for (lp=LLIST; lp!=NULL; lp = lp->next) {
		if(lp->lc.c.color==filmroll_color && lp->type == type)
	 		return(nobj_number(lp->objname));
		}
	return(-1);
	}

/*--------------------------------------------------------
Find a DXF entity's corresponding object name.
If it's not in list, try adding it.
If name found, load its info into mesh variables and return 1.
If not found, try creating.  If error, return 0.
------------------------------------------------------*/

int find_dxfobj(int type) {
	int d1,d2,colorwk,addcolor;
	DXFNode *l;
	char tryname[64],tryname2[64],dd1[2]="A",dd2[2]="A";
	char finalname[64], name[64];
	BOOL created = FALSE;

	if(theImport->objsFrom==OBJS_ENTITY)	{ 
		/* Entity */ 
		if(blockLevel>0) {
			/* inside block: use block name for single entity */
			if(curBlock==lastBlock)
				goto got_obj;
			lastBlock = curBlock;
			for(int i = 0; i < 32; ++i)
				tryname[i] = 0;							
			if (curBlock->name[0]=='*') 
				strncpy(tryname,curBlock->name+1,20);
			else 
				strncpy(tryname,curBlock->name,20);
			}
		else {
			if(entity==last_entity)
				goto got_obj;
			last_entity=entity;
			strcpy(tryname,"Entity");
			}
		if(type == DXF_SHAPE)
			sprintf(finalname,"Shape_%s",tryname);
		else
			strcpy(finalname,tryname);
		nextname(finalname,name);
		//strcpy(name,finalname);
		
		colorwk = igroup[62];
		if(colorwk > 0 && colorwk < 256)
			addcolor = colorwk;
		else
		if(colorwk > 255)
			addcolor = layer_color(tgroup[8]);
		else
		if(colorwk == 0) {
			if(inInsert)
				addcolor = curBlockCol;
			else
				addcolor = 7;
			}
		else
			assert(0);

		if((dxfobj = namedObjs.Add(name, type, addcolor))<0)
			goto cantmake;
		if(type == DXF_MESH) {
			dxf_mesh = &(namedObjs.GetNamedPtr(dxfobj)->mesh);
			dxf_shape = NULL;
			dxf_spline = NULL;
			meshface=meshvert=0;
			}
		else {
			dxf_shape = &(namedObjs.GetNamedPtr(dxfobj)->shape);
assert(dxf_shape != NULL);
			if(dxf_shape->SplineCount())
				dxf_spline = dxf_shape->splines[dxf_shape->SplineCount()-1];
			else
				dxf_spline = NULL;
			dxf_mesh = NULL;
			}

#ifdef DBGDXF
		DebugPrint("*********** STARTING OBJECT: %s \n", name);
#endif
#ifndef IS_3DSDXF
//		dxf_ob_prompt(name);
#endif
		goto got_obj;
		}
	
	switch(theImport->objsFrom) {
		case OBJS_LAYER:	/* Layer */
			if ((dxfobj=find_layer(type))>=0) goto got_obj;
			break;
		case OBJS_COLOR:	/* Color */
			if ((dxfobj=find_color(type))>=0) goto got_obj;
			break;
		case OBJS_FILMROLL:	/* Filmroll */
			if ((dxfobj=find_flmcol(type))>=0) goto got_obj;
			break;   
			}
	
	/* Not in list, try adding */
	
	if((l=(DXFNode *)malloc(sizeof(struct dxfnlist)))==NULL)
		goto noram;
	
	/* Now try creating object */
	
	switch(theImport->objsFrom) {
		case OBJS_LAYER:	/* Layer */
			if(strlen(tgroup[8])==0)
				sprintf(finalname,"%s%s",type==DXF_SHAPE?"Shape_":"","Unnamed");
			else {
				strncpy(tryname2,tgroup[8],8);
				tryname2[8]=0;
				sprintf(finalname,"%s%s",type==DXF_SHAPE?"Shape_":"",tryname2);
				}
			addcolor = layer_color(tgroup[8]);
			break;
		case OBJS_COLOR:	/* Color */
			addcolor = colorwk = igroup[62];
			goto testcolor;
		case OBJS_FILMROLL:	/* Filmroll color */
			addcolor = colorwk = filmroll_color;
	
			testcolor:
			if(colorwk>256 || colorwk<0)
				colorwk=0;
			sprintf(tryname,"%s%s%02d",type==DXF_SHAPE?"Shape_":"","Color",colorwk);
			if(namedObjs.Find(tryname)<0) {
				strcpy(name,tryname);
				goto make_dxf_obj;
				}
			for(d1=0; d1<26; ++d1) {
				dd1[0]=(d1==0) ? 0:'A'+d1;
				for(d2=0; d2<26; ++d2) {
					dd2[0]='A'+d2;
					sprintf(finalname,"%s%s%s",tryname,dd1,dd2);
					if(namedObjs.Find(finalname)<0)	{
						strcpy(name,finalname);
						goto make_dxf_obj;
						}
					}
				}
			break;
		}
	
	nextname(finalname,name);
	
	make_dxf_obj:
	if(addcolor < 1 || addcolor > 255)
		addcolor = 7;	// This is just a guess, but it seems like the normal default
	if((dxfobj=namedObjs.Add(name, type, addcolor))<0) {
		free(l);	/* Free up allocated layer slot */
    cantmake:
    noram:
		if(showPrompts)
			no_RAM();
		return(0);
		}
	else {
#ifdef DBGDXF
		DebugPrint("*********** STARTING OBJECT: %s \n", name);
#endif

#ifndef IS_3DSDXF
//		dxf_ob_prompt(name);
#endif
		created = TRUE;
		}
	
	meshface=meshvert=0;
	
	/* Now new element into list */
	l->next = LLIST;
	LLIST = l;
	
	/* Plug in the appropriate matching variable */
	
	switch(theImport->objsFrom)	{
		case OBJS_LAYER:	/* Layer */
			strcpy(l->lc.l.layername,tgroup[8]);
			break;
		case OBJS_COLOR:	/* Color */
			l->lc.c.color=igroup[62];
			break;
		case OBJS_FILMROLL:
			l->lc.c.color=filmroll_color;
			break;
		}
	strcpy(l->objname,name);
	l->type = type;		// Shape or mesh
		
  got_obj:

	dxf_n = namedObjs.GetNamedPtr(dxfobj);

	if (dxf_n==NULL) 	return(0);
	if(type==DXF_MESH) {
		dxf_mesh = &dxf_n->mesh;
		dxf_shape = NULL;
		dxf_spline = NULL;
		vertbase=meshvert=dxfverts=dxf_mesh->getNumVerts();
		meshface=dxffaces=dxf_mesh->getNumFaces();
		}
	else {
		dxf_shape = &dxf_n->shape;
assert(dxf_shape != NULL);
		if(created) {
			if(dxf_shape->SplineCount())
				dxf_spline = dxf_shape->splines[dxf_shape->SplineCount()-1];
			else
				dxf_spline = NULL;
			}
		else {
			dxf_spline = dxf_shape->NewSpline();
			}
		dxf_mesh = NULL;
		}
	return(1);
	}

static void ovflow_msg(char *name, int nv, int nf) {
	DebugPrint("Overflow: [%s] %d %d\n",name,nv,nf);
	}

static void object_overflow(int error) {
	int nverts, nfaces;
	if((dxfobj>=0)&&(error==-2)) {
		NamedObject *n = namedObjs.GetNamedPtr(dxfobj);
		Mesh *m = &n->mesh;
		nverts = m->getNumVerts();
		nfaces = m->getNumFaces();
		ovflow_msg(n->name,nverts,nfaces);
		namedObjs.Delete(dxfobj);
		dxfobj=-1;
		}
	else 	{
		if(dxfobj>=0)
			namedObjs.Delete(dxfobj);
		dxfobj = -1;
		if(showPrompts)
			no_RAM();
		}
	} 

/*---------- FACE3D -----------------*/

static int face3d (void) {
	Point3 v1,v2,v3,v4;
	Face f;
	int res;
	if(dxf_type==DXF3D) {
		entity++;
		if(find_dxfobj(DXF_MESH)==0)
			return(1);
	
		f.smGroup=0L;
		f.setMatID(get_mtl_id());
	
		load_vert(v1,10);
		load_vert(v2,11);
		load_vert(v3,12);
		load_vert(v4,13);
		TransPt(v1);  /* for blocks */
		TransPt(v2);  /* for blocks */
		TransPt(v3);  /* for blocks */
		TransPt(v4);  /* for blocks */
#ifdef DBGDXF
	  	DebugPrint(" FACE3D vertex = (%.4f,%.4f,%.4f) \n",v1.x,v1.y, v1.z);
#endif

		if(v3.x==v4.x && v3.y==v4.y && v3.z==v4.z) {
			if(res=AddVerts(dxf_mesh,3)<0) {
				noram:
				object_overflow(res); 
				return(1);
				}
			if(res=AddFaces(dxf_mesh,1)<0)
				goto noram;
	
			PUTVERT(dxf_mesh,dxfverts++,v1);
			PUTVERT(dxf_mesh,dxfverts++,v2);
			PUTVERT(dxf_mesh,dxfverts++,v3);
	
			f.v[0]=dxfverts-3;
			f.v[1]=dxfverts-2;
			f.v[2]=dxfverts-1;
			f.flags=EDGE_A | EDGE_B | EDGE_C;
			if(igroup[70] & 1)
				f.flags &= ~EDGE_A;
			if(igroup[70] & 2)
				f.flags &= ~EDGE_B;
			if(igroup[70] & 4)
				f.flags &= ~EDGE_C;
			PUTFACE(dxf_mesh,dxffaces++,f);
			}
		else {
			if(res=AddVerts(dxf_mesh,4)<0)
				goto noram;
			if(res=AddFaces(dxf_mesh,2)<0)
				goto noram;
	
			PUTVERT(dxf_mesh,dxfverts++,v1);
			PUTVERT(dxf_mesh,dxfverts++,v2);
			PUTVERT(dxf_mesh,dxfverts++,v3);
			PUTVERT(dxf_mesh,dxfverts++,v4);
	
			f.v[0]=dxfverts-4;
			f.v[1]=dxfverts-3;
			f.v[2]=dxfverts-2;
			f.flags=EDGE_A | EDGE_B;
			if(igroup[70] & 1)
				f.flags &= ~EDGE_A;
			if(igroup[70] & 2)
				f.flags &= ~EDGE_B;
			PUTFACE(dxf_mesh,dxffaces++,f);
	
			f.v[0]=dxfverts-2;
			f.v[1]=dxfverts-1;
			f.v[2]=dxfverts-4;
			f.flags=EDGE_A | EDGE_B;
			if(igroup[70] & 4)
				f.flags &= ~EDGE_A;
			if(igroup[70] & 8)
				f.flags &= ~EDGE_B;
			PUTFACE(dxf_mesh,dxffaces++,f);
			}
		}
	return(0);
	}

#ifdef MAYBE
/*_LINE_*/
static int line2d() {
	Shppt p;
	if((ptct+2)>SHAPE_MAX) {
		snprintf(gp_buffer,256,progstr(R3ST0240));
		continu_line(gp_buffer);
		bad_reason=EXCEEDS_SETUP;
		return(1);
		}
	p.x=rgroup[10];
	p.y=rgroup[20];
	p.z = p.inx=p.iny=p.inz=
	p.outx=p.outy=p.outz=0.0;
	p.flags=POLYSTART;
	if (rgroup[38]!=0.0) p.z = rgroup[38];
 	ApplyTransform(p); // includes Block transform. too
	datacopy(&shpdata[ptct++],&p,sizeof(Shppt));
	p.x=rgroup[11];
	p.y=rgroup[21];
	p.flags=POLYEND;
 	ApplyTransform(p); // includes Block transform. too
	datacopy(&shpdata[ptct++],&p,sizeof(Shppt));
	return(0);
	}
#endif // MAYBE

static int AddVertsFaces(int nv, int nf) {
	int res;
#ifdef DBGDXF
	DebugPrint("AddVertsFaces, nv=%d, nf = %d \n",nv,nf);
#endif
	if (nv>0) 
		if (res=AddVerts(dxf_mesh,nv) < 0) { 
			object_overflow(res); 
			return(0); 
			}
	if (nf>0) 
		if (res=AddFaces(dxf_mesh,nf) < 0) { 
			object_overflow(res); 
			return(0); 
			}
	return(1);
	}

static void PutAFace(int a, int b, int c, int smg, int fl) {
	Face f;
	f.setMatID(get_mtl_id());
#ifdef DBGDXFFACES
	DebugPrint("PutAFace %d,%d,%d (dxfverts=%d) mtl=%d\n",a,b,c,dxfverts,f.getMatID());
#endif
	if (smg>=0)	f.smGroup = 1<<smg;
	else f.smGroup = 0;
	f.flags |= (fl & EDGE_ALL);
	f.v[0] = a;	f.v[1] = b;  f.v[2] = c;
	PUTFACE(dxf_mesh,dxffaces++,f);
	}

static int put_quad(Point3 *p) {
	Face f;
	Point3 v;
	int i;
	if (find_dxfobj(DXF_MESH)==0) return(1);	
	if (!AddVertsFaces(4, 2)) return(1);
	for (i=0; i<4; i++) {
		v = p[i];
#ifdef DBGDXF
		DebugPrint(" putquad: vert = %.4f,%.4f,%.4f \n",v.x,v.y,v.z);
#endif
	 	ApplyTransform(v); 
		PUTVERT(dxf_mesh,dxfverts++, v);
		}
	PutAFace(dxfverts-4,dxfverts-3,dxfverts-2, -1, EDGE_A|EDGE_B);
	PutAFace(dxfverts-2,dxfverts-1,dxfverts-4, -1, EDGE_A|EDGE_B);
	return(0);
	}

static int put_line_segment(Point3 *p) {
	if (find_dxfobj(DXF_SHAPE)==0)
		return(1);	
	// DS 6-17-97: this used to always create a NewSpline, but find_dxfobj already
	// has created a spline.
	Spline3D *spline = (dxf_spline)? dxf_spline : dxf_shape->NewSpline(); 
	spline->AddKnot(SplineKnot(KTYPE_AUTO, LTYPE_CURVE, p[0], p[0], p[0]));
	spline->AddKnot(SplineKnot(KTYPE_AUTO, LTYPE_CURVE, p[1], p[1], p[1]));
	spline->ComputeBezPoints();				// Let spline package compute vectors
	spline->SetKnotType(0, KTYPE_BEZIER);	// And make the vectors final!
	spline->SetKnotType(1, KTYPE_BEZIER);
	dxf_shape->UpdateSels();
	return(0);
	}

static int line3d(void) {
	Point3 offs;
	if (rgroup[39]!=0.0) {	/* extruded line */
		Point3 p[4];
#ifdef DBGDXF
		DebugPrint("line3d Extruded \n");
#endif
		entity++;
		load_vert(p[0],10);
		load_vert(p[1],11);

		offs = normal * (float)rgroup[39];
		p[2] = p[1] + offs;
		p[3] = p[0] + offs;

		return (put_quad(p));
		}
	inShape = TRUE; // DS 2-29-96  fixes QA# 116080
//	if(inShape) {
		Point3 p[2];
#ifdef DBGDXF
		DebugPrint("line3d to shape \n");
#endif
		entity++;
		load_vert(p[0],10);
		load_vert(p[1],11);

		ApplyTransform(p[0]);   // DS 4/6/96
		ApplyTransform(p[1]);   // DS 4/6/96


		return (put_line_segment(p));
//		}
//	return(0);
	}

static int line (void) {
	switch (dxf_type) {
//		case DXF2D: return (line2d());
		case DXF3D: return (line3d());
		}
	return(0);
	}

static int MakeSolidArcObj(float astrt,float aend,short isCircle) {
	Point3 v1,v2;
	Face f;
	float angstep,rad,t;
	Point3 pt;
	int i,nv1,nv2,nsteps,nverts,nstart,ncent1,ncent2;
	float stepsize = DEG_TO_RAD*theImport->arcDegrees;	   /* circle subdivisions size for polygon arc approximation */

	entity++;
	if (find_dxfobj(DXF_MESH)==0) return(1);	

	load_vert(pt,10);
	t = (float)rgroup[39];
	rad = (float)rgroup[40];

	if (isCircle) {
		nsteps = (int)ceil(TWOPI/stepsize);
		angstep = TWOPI / (float)nsteps;
		nverts = 2*nsteps;
		if (!AddVertsFaces(nverts+2,nsteps*4)) 
		return(1);
		}
	else {
		nsteps = (int)ceil((aend-astrt)/stepsize);			
		angstep = (aend-astrt)/nsteps;
		nverts = 2*(nsteps+1);
		if (!AddVertsFaces(nverts,nsteps*2)) 
		return(1);
		}

	if (isCircle) {
		/* output center verts */
		v1 = pt;
		v2 = v1 + Point3(0.0f, 0.0f, t);
		ApplyTransform(v1);	 
		ApplyTransform(v2);
		ncent1 = dxfverts;
		PUTVERT(dxf_mesh,dxfverts++, v1);
		ncent2 = dxfverts;
		PUTVERT(dxf_mesh,dxfverts++, v2);
		}

	nstart = dxfverts;
	for (i=0; i<=nsteps; i++) {
		v1.x = pt.x + rad * (float)cos(astrt+angstep*i);
		v1.y = pt.y + rad * (float)sin(astrt+angstep*i);
		v1.z = pt.z;
		v2.x = v1.x;
		v2.y = v1.y;
		v2.z = v1.z + t; // should this be in directio of normal ?????
		if (i==nsteps&&isCircle) { 
			/* connect cyclically */
			nv1 = dxfverts-2;
			nv2 = nstart;
			}
		else {
			/* output two verts */
			ApplyTransform(v1);	 /* includes Block transf too */
			ApplyTransform(v2);
			PUTVERT(dxf_mesh,dxfverts++, v1);
			PUTVERT(dxf_mesh,dxfverts++, v2);
			nv1 = dxfverts-4;
			nv2 = dxfverts-2;
			}
		if (i>0) {
			/* output two side faces */
			PutAFace(nv1+1,  nv1,  nv2, 1, EDGE_A | EDGE_B);
			PutAFace(nv2, nv2+1, nv1+1, 1, EDGE_A | EDGE_B);
			if (isCircle) {
				/* output cap faces */
				PutAFace(nv2,nv1,ncent1,0,EDGE_A);
				PutAFace(nv1+1,nv2+1,ncent2,0,EDGE_A);
				}
			}
		}
	return(0);
	}

static int MakeDisk() {
	Point3 v1;
	Face f;
	float angstep,rad;
	Point3 pt;
	int i,nv1,nv2,nsteps,nstart,ncent1;
	double stepsize = DEG_TO_RAD*theImport->arcDegrees;	   /* circle subdivisions size for polygon arc approximation */

	entity++;
	if (find_dxfobj(DXF_MESH)==0) return(1);	

	load_vert(pt,10);
	rad = (float)rgroup[40];

	nsteps = (int)ceil(TWOPI/stepsize);
	angstep = TWOPI / (float)nsteps;
	if (!AddVertsFaces(nsteps+1,nsteps)) 
		return(1);

	/* output center vert */
	v1 = pt;
	ApplyTransform(v1);	 
	ncent1 = dxfverts;
	PUTVERT(dxf_mesh,dxfverts++, v1);

	nstart = dxfverts;
	for (i=0; i<=nsteps; i++) {
		v1.x = pt.x + rad * (float)cos(angstep*i);
		v1.y = pt.y + rad * (float)sin(angstep*i);
		v1.z = pt.z;
		if (i==nsteps) { 
			nv1 = dxfverts-1;
			nv2 = nstart;
			}
		else {
			ApplyTransform(v1);	 /* includes Block transf too */
			PUTVERT(dxf_mesh,dxfverts++, v1);
			nv1 = dxfverts-2;
			nv2 = dxfverts-1;
			}
		if (i>0) /* output cap face */
			PutAFace(nv1,nv2,ncent1,0,EDGE_A);
		}
	return(0);
	}



static void MakeNormTM(Matrix3& tm, Point3 ni) {
	matrix m;
	point n;
	n[0] = ni.x;
	n[1] = ni.y;
	n[2] = ni.z;
	geta4by4(n, m);
	Point3 row0((float)m[0][0], (float)m[1][0], (float)m[2][0]);
	Point3 row1((float)m[0][1], (float)m[1][1], (float)m[2][1]);
	Point3 row2((float)m[0][2], (float)m[1][2], (float)m[2][2]);
	tm.SetRow(0,row0);
	tm.SetRow(1,row1);
	tm.SetRow(2,row2);
	tm.SetRow(3, Point3(0,0,0));
	}



/*  NORMTEST  --  Test a normal to see if it's been set.	 */

static int normtest (Point3 norm) {
	return (norm[0] == 0.0 && norm[1] == 0.0 && norm[2] == 1.0);
	}


static void NormTrans(Point3& p, Point3 norm) {
//	if (!normtest(norm)) 
//	    p += norm;
	}

void pmat(TCHAR *txt, Matrix3 &m) {
	MRow *n = m.GetAddr();
	DebugPrint("\n--Matrix --- %s --- \n",txt);
	for (int j=0; j<4; j++) {
		DebugPrint(" %.4f  %.4f  %.4f \n", n[j][0], n[j][1], n[j][2]); 
		}
	}

static void CompEntityTransform(Point3 &norm) {
	if (normtest(norm)) {
		isEntityTM = 0;
		normtm.IdentityMatrix();
		}
	else {
		isEntityTM = 1;
		MakeNormTM(normtm, norm);
		}
#ifdef DBGDXF
	DebugPrint(" CompEntityTransform: isEntityTM= %d:  norm = %.4f,%.4f,%.4f\n",
		isEntityTM,norm[0],norm[1],norm[2]);
	pmat(" norm transform", normtm);
#endif
	}

/* Calc incoming & outgoing vectors for a point */

#define POLY_CIRC_TENSION 0.551785439253f

void
calc_vecs(WorkKnot *p,WorkKnot *pl,WorkKnot *pn) {
	float i_len,o_len,i_pct,o_pct,totlen;

	/* Calc deltas for the points */

	/* Calc some temps to speed things up */

	Point3 ddi = p->p - pl->p;		/* Ctl-to-last */
	Point3 ddo = pn->p - p->p;		/* Ctl-to-next */
	Point3 dln = pn->p - pl->p;	/* Last-to-next */

	dln*=POLY_CIRC_TENSION;

	i_len=Length(ddi);
	o_len=Length(ddo);
	totlen=i_len+o_len;
	if(totlen==0) {
		p->in = p->out = p->p;
		return;
		}
	i_pct = i_len / totlen;
	o_pct = 1.0f - i_pct;

	/* Figure out vectors */

	p->in = p->p - i_pct * dln;
	p->out = p->p + o_pct * dln;
	}

/*------ CIRC --- circle */
static int circ(void)	{
	CompEntityTransform(normal);
	if (dxf_type==DXF3D) {
		 /* 3D Loading */
		if (rgroup[39]!=0.0) {	/* extruded circle */
			return(MakeSolidArcObj(0.0f, TWOPI,1));
			}
		else {
			if(DXFImport::fillPolylines)
				return(MakeDisk());
			else {
				WorkKnot p1,p2,p3,p4;
				Point3 pt;
	
				entity++;
				if (find_dxfobj(DXF_SHAPE)==0) return(1);	

				load_vert(pt,10);

				NormTrans(pt, normal);

				p1.p = p1.in = p1.out = Point3(0,0,0);
				p1.p.x = pt.x;
				p1.p.y = pt.y + (float)rgroup[40];
				p1.p.z = pt.z;
				ApplyTransform(p1.p);  /* for blocks */
				ApplyTransform(p1.in);  /* for blocks */
				ApplyTransform(p1.out);  /* for blocks */
				dxf_spline->AddKnot(SplineKnot(KTYPE_BEZIER, LTYPE_CURVE, p1.p, p1.in, p1.out));

				p2.p = p2.in = p2.out = Point3(0,0,0);
				p2.p.x = pt.x+(float)rgroup[40];
				p2.p.y = pt.y;
				p2.p.z = pt.z;
				ApplyTransform(p2.p);  /* for blocks */
				ApplyTransform(p2.in);  /* for blocks */
				ApplyTransform(p2.out);  /* for blocks */
				dxf_spline->AddKnot(SplineKnot(KTYPE_BEZIER, LTYPE_CURVE, p2.p, p2.in, p2.out));

				p3.p = p3.in = p3.out = Point3(0,0,0);
				p3.p.x = pt.x;
				p3.p.y = pt.y-(float)rgroup[40];
				p3.p.z = pt.z;
				ApplyTransform(p3.p);  /* for blocks */
				ApplyTransform(p3.in);  /* for blocks */
				ApplyTransform(p3.out);  /* for blocks */
				dxf_spline->AddKnot(SplineKnot(KTYPE_BEZIER, LTYPE_CURVE, p3.p, p3.in, p3.out));

				p4.p = p4.in = p4.out = Point3(0,0,0);
				p4.p.x = pt.x-(float)rgroup[40];
				p4.p.y = pt.y;
				p4.p.z = pt.z;
				ApplyTransform(p4.p);  /* for blocks */
				ApplyTransform(p4.in);  /* for blocks */
				ApplyTransform(p4.out);  /* for blocks */
				dxf_spline->AddKnot(SplineKnot(KTYPE_BEZIER, LTYPE_CURVE, p4.p, p4.in, p4.out));
				dxf_spline->SetClosed();

				calc_vecs(&p1,&p4,&p2);
				dxf_spline->SetInVec(0, p1.in);
				dxf_spline->SetOutVec(0, p1.out);
				calc_vecs(&p2,&p1,&p3);
				dxf_spline->SetInVec(1, p2.in);
				dxf_spline->SetOutVec(1, p2.out);
				calc_vecs(&p3,&p2,&p4);
				dxf_spline->SetInVec(2, p3.in);
				dxf_spline->SetOutVec(2, p3.out);
				calc_vecs(&p4,&p3,&p1);
				dxf_spline->SetInVec(3, p4.in);
				dxf_spline->SetOutVec(3, p4.out);
				return 0;
				}
			}
		}
	return(0);
	}

/* --------------- ARC ---------------------*/
static int arc(void)	{
	CompEntityTransform(normal);
	if (dxf_type==DXF3D) {
		/* 3D Loading */
		if (rgroup[39]!=0.0) {	/* extruded arc */
			float aend,astrt;
			astrt=(float)rgroup[50];
			aend=(float)rgroup[51];
			while(aend<astrt)
				aend+=360.0f;
			astrt/=RAD_TO_DEG;	/* Convert degrees to radians */
			aend/=RAD_TO_DEG;
			return(MakeSolidArcObj(astrt,aend,0));
			}
		else {
			WorkKnot p;
			Point3 pt;
			int ix;
			float astrt,aend,arcstep,arcvec,vecwk,sinfac,cosfac,xvec,yvec,angle;
	
			entity++;
			if (find_dxfobj(DXF_SHAPE)==0) return(1);	

			load_vert(pt,10);
			

			NormTrans(pt, normal);
	
			astrt = (float)rgroup[50];
			aend = (float)rgroup[51];
			while(aend<astrt)
				aend += 360.0f;

#ifdef DBGDXF
DebugPrint("Got arc %.4f to %.4f\n",astrt,aend);
#endif

			astrt *= DEG_TO_RAD;
			aend *= DEG_TO_RAD;
			float maxAng = DegToRad(theImport->arcSubDegrees);
			int nsegs = (int)((float(aend-astrt)+maxAng-.001f)/maxAng);

			arcstep =(aend-astrt)/nsegs;	/* Our arcs take 4 pts */
			arcvec = veccalc(arcstep);	/* Calc bezier control vector length */
			vecwk = arcvec*(float)rgroup[40];		/* Scale vector by radius */
	
			angle=astrt;

			for(ix=0; ix<nsegs+1; ++ix,angle+=arcstep) {
				sinfac = (float)sin(angle);
				cosfac = (float)cos(angle);
				
				p.p.x = pt.x + (float)rgroup[40]*cosfac;
				p.p.y = pt.y + (float)rgroup[40]*sinfac;
				
				p.p.z = p.in.z = p.out.z = pt.z;

				xvec = vecwk*sinfac;
				yvec = vecwk*cosfac;
				
				p.in.x = p.p.x + xvec;	  p.in.y = p.p.y - yvec;
				p.out.x = p.p.x - xvec;	  p.out.y = p.p.y + yvec;

				ApplyTransform(p.p); 
				ApplyTransform(p.in);
				ApplyTransform(p.out);  
				dxf_spline->AddKnot(SplineKnot(KTYPE_BEZIER, LTYPE_CURVE, p.p, p.in, p.out));
				}
			}
		}
	return(0);
	}

typedef int BFunc(Point3 p, float wstart);

static int  DoBulge(Point3 ps, Point3 pe, float ws, float we, float bulge, short closing, BFunc *dothis) {
	float wstrt, wend, midx,midy, perp;
	Point3 n, q;
	float wlength,dx,dy,angle,radius,angstep,ang0,dw,ang;
	int nsteps,i,angsign;
	float cx,cy;

#ifdef DBGDXF1
	DebugPrint(" DoBulge, ws= %4f, we = %4f\n",ws,we);
#endif
	wstrt = ws;
	wend = we;

	dx = pe[0]-ps[0];
	dy = pe[1]-ps[1];
	wlength = (float)sqrt(dx*dx+dy*dy);

	angle = (float)atan(bulge)*4.0f;
	if(angle<0) {
		angsign= -1;
		angle = -angle;
		}
	else 
	if(angle>0)
		angsign=1;
	else
		angsign=0;

	if (angle==0.0f) angle = .00001f;
	radius = wlength/(2.0f * (float)sin(angle*.5));

	nsteps = (int)ceil(angle/(DEG_TO_RAD*theImport->arcDegrees));
	angstep = angle/nsteps;

	n = Normalize(Point3(-dy, dx, 0.0f));
	if (angsign==-1.0) {
		n = -n;
		angstep = -angstep;
		}

	midx = .5f*(pe.x+ps.x); 
	midy = .5f*(pe.y+ps.y);

	perp = radius*(float)cos(.5*angle);
	cx = midx + perp*n.x;
	cy = midy + perp*n.y;
	
	
	ang0 = (radius==0.0)?0.0f:(float)atan2(ps.y-cy,ps.x-cx);

	dw = (wend-wstrt)/((float)nsteps);

#ifdef DBGDXF1
	DebugPrint(" cx = %.3f, cy = %.3f, radius = %.3f, ang0=%3f, angstep=%3f, nsteps =%d\n",
		cx,cy,radius,ang0,angstep,nsteps);
#endif
	for (i=1; i<nsteps; i++) {
		ang = ang0 + i*angstep;
		q = Point3(cx + radius*(float)cos(ang), cy + radius*(float)sin(ang), ps.z);
		(*dothis)(q, wstrt+i*dw);
		}
	if (!closing) (*dothis)(pe, we);
	return(0);	
	}

/* find intersection of lines defined by (a,b) and (c,d) */
/* returns 1 if valid intersection, 0 if parallel lines */

static int Int2PntLines(Point3 p1, Point3 q1, Point3 p2, Point3 q2, Point3 &p) {
	double dx1,dx2,dy1,dy2,r1,r2,den;
	dx1 = q1.x-p1.x; 	
	dy1 = q1.y-p1.y;
	dx2 = q2.x-p2.x; 	
	dy2 = q2.y-p2.y;
	den = dx1*dy2-dx2*dy1;
	if (den==0.0) 
		return(0);
	r1 = p1.y*dx1-p1.x*dy1;
	r2 = p2.y*dx2-p2.x*dy2;
	p.x = (float)((r1*dx2-r2*dx1)/den);	
	p.y = (float)((r1*dy2-r2*dy1)/den);	
	p.z = p1.z;
	return(1);
	}

static void IntsctSegments(PLPoint *p1, PLPoint *p2) {
	if (!Int2PntLines(p1->a0,p1->a1,p2->a0,p2->a1, p2->ai))
		p2->ai = p2->a0;
	if (!Int2PntLines(p1->b0,p1->b1,p2->b0,p2->b1, p2->bi))
		p2->bi = p2->b0;
#ifdef DBGDXF
	DebugPrint(" IntsctSegs: (%.3f,%.3f,%.3f) (%.3f,%.3f,%.3f) \n",
		p2->ai[0], p2->ai[1],p2->ai[2],p2->bi[0],p2->bi[1],p2->bi[2]);
#endif
	}

static void put_2verts(Point3 p, int i1, int i2) {
	Point3 v = p;

	ApplyTransform(v);	 /* includes Block transf too */
	PUTVERT(dxf_mesh,i1,v);
	if (isThick) {
		v.x = p.x;
		v.y = p.y;
		v.z = p.z+pl_thick;
		ApplyTransform(v);	 /* includes Block transf too */
		PUTVERT(dxf_mesh,i2,v);
		}
	}

static void put_dbl_vert(Point3 p) {
	put_2verts(p,dxfverts,dxfverts+1);
	dxfverts++;
	if (isThick) dxfverts++;
	}	

#define POLSTART 1
#define POLEND 2

static void PutSideFaces(int n1, int n2, int type) {
	int f1,f2;

#ifdef DBGDXF1
	DebugPrint(" PutSideFaces\n");
#endif
	f1 = (type == POLSTART)? (int)(EDGE_A|EDGE_B) : (int)EDGE_A; 		
	f2 = (type == POLEND)? (int)(EDGE_A|EDGE_B) : (int)EDGE_A; 		

	if (isThick) {
		PutAFace(n2+2, n1+2, n1, 0, f1);   /* bottom 0 */
		PutAFace(n2+1, n1+1, n1+3, 2, f1);	/* top 0 */
		PutAFace(n2+3, n1+3, n1+2, 3, EDGE_A|EDGE_B);	/* side 0 */
		PutAFace(n2, n1, n1+1, 1, EDGE_A|EDGE_B);	  /* side 0 */

		PutAFace(n1, n2, n2+2, 0, f2);			/* bottom 1 */
		PutAFace(n1+3, n2+3, n2+1, 2, f2);			/* top 1 */
		PutAFace(n1+1, n2+1, n2, 1, EDGE_A|EDGE_B);  	/* side	1 */
		PutAFace(n1+2, n2+2, n2+3, 3, EDGE_A|EDGE_B);	/* side 1 */
		}
	else {
		PutAFace(n2+1, n1+1, n1, 0, f1);
		PutAFace(n1, n2, n2+1, 0, f2);
		}
	}

static void ComputeLineEnds(PLPoint *pl0, PLPoint *pl1) {
	Point3 n;
	float hws,hwe;
	n = Normalize(Point3(pl0->p.y - pl1->p.y, pl1->p.x - pl0->p.x, 0.0f));
	
	hws = pl0->wstrt*.5f;
	hwe = pl1->wstrt*.5f; /* force width to be continuous */

	pl0->a0 = pl0->p + n * hws;
	pl0->b0 = pl0->p - n * hws;
	pl0->a1 = pl1->p + n * hwe;
	pl0->b1 = pl1->p - n * hwe;
	}

static int AddPlineVert(Point3 p, float wstart) {
	PLPoint plp;
	int res;

#ifdef DBGDXF1
	DebugPrint(" AddPlineVert:  nplverts=%d, polyClosed = %d, isThick = %d\n",nplverts,polyClosed,isThick);
	DebugPrint("    0 = (%.3f,%.3f,%.3f) \n",p[0],p[1],p[2]);
#endif
	plp.p = p;
	plp.wstrt = wstart;

	if (nplverts>0)	{
		ComputeLineEnds(&plq[1],&plp); /* compute plq[1].a0,a1,b0,b1 */
		}

	if (nplverts==1) {
		pl0 = plq[1];
		if (!polyClosed) {
			if (!AddVertsFaces(nvper,isThick?2:0)) return(1);
			put_dbl_vert(plq[1].a0); 
			put_dbl_vert(plq[1].b0);
			/* cap starting end */
			if (isThick) {
				PutAFace(dxfverts-3, dxfverts-4, dxfverts-2, 4,EDGE_A|EDGE_B);
				PutAFace(dxfverts-2, dxfverts-1, dxfverts-3, 4,EDGE_A|EDGE_B);
				}
			}
		}

	if (nplverts>1) {
		IntsctSegments(&plq[0],&plq[1]);  /* compute plq[1].ai, bi */
		if (res=AddVerts(dxf_mesh,nvper) < 0) { 
			object_overflow(res); 
			return(1); 
			}
		put_dbl_vert(plq[1].ai);
		put_dbl_vert(plq[1].bi);
		if (nplverts>2||(!polyClosed)) {
			if (res=AddFaces(dxf_mesh,isThick?8:2) < 0) { 
				object_overflow(res); 
				return(1); 
				}
			PutSideFaces(dxfverts-2*nvper,dxfverts-nvper,(nplverts==2)?POLSTART:0);
			}
		}
	plq[0] = plq[1];
	plq[1] = plp;
	nplverts++;
	return(0);
	}

static int AddPlineBulge(Point3 p, float we, float bulge, short closing) {
	return DoBulge(plq[1].p,p,plq[1].wstrt,we,bulge,closing,AddPlineVert);
	}

static int count_steps(float bulge) {
	float angle = (float)atan(bulge)*4.0f;
	if(angle<0) angle = -angle; 
	return (int)ceil(angle/(DEG_TO_RAD*theImport->arcDegrees));
	}

/* Calculate a 3D triangle's normal */

static void
t3normal(Point3 a, Point3 b, Point3 c, Point3 &norm) {
	Point3 v1, v2;

	/* Figure two vectors */

	v1 = b - a;
	v2 = c - a;

	norm = -Normalize(v1 ^ v2);	// Get cross product's unit vector
	}

static int DoCap(int nstart, int npoints, int flip) {
	int nend = nstart + npoints - 1;
	PolyShape shape;
	shape.SetNumLines(1);

	PolyLine &line = shape.lines[0];
	line.SetNumPts(npoints);

	int i,norm_axis;
	Point3 n, norm;

	/* find normal axis */
	norm = Point3(0,0,0);
	for (i=0; i<npoints-2; i++) {
		Point3 va = dxf_mesh->verts[nstart+i];
		Point3 vb = dxf_mesh->verts[nstart+i+1];
		Point3 vc = dxf_mesh->verts[nstart+i+2];
		t3normal(va, vb, vc, n);
		norm += n;
		}
	norm = Normalize(norm);
	norm_axis = (fabs(norm.x)>fabs(norm.y))?0:1;
	norm_axis = (fabs(norm[norm_axis])>fabs(norm.z))?norm_axis:2;

	for (i=0; i<npoints; i++) {
		Point3 v = dxf_mesh->verts[nstart+i];
		switch(norm_axis) {
			case 0:
				line.pts[i] = PolyPt(Point3(v.y, v.z, 0.0f), POLYPT_VISEDGE, nstart+i);
				break;
			case 1:
				line.pts[i] = PolyPt(Point3(v.z, v.x, 0.0f), POLYPT_VISEDGE, nstart+i);
				break;
			case 2:
				line.pts[i] = PolyPt(Point3(v.x, v.y, 0.0f), POLYPT_VISEDGE, nstart+i);
				break;
			}
		}
	line.Close();
	BOOL reversed = FALSE;
	if(line.IsClockWise()) {
		reversed = TRUE;
		line.Reverse();
		}
		
	// Organize the shape
	ShapeHierarchy hier;
	shape.OrganizeCurves(0, &hier);		// Time is irrelevant here -- Make it zero

	// Cap it!
	int oldfaces = dxf_mesh->getNumFaces();
	MeshCapInfo capInfo;
	shape.MakeCap(0, capInfo, CAPTYPE_MORPH);
	// Build information for capping
	MeshCapper capper(shape);
	int vert = nstart;
	MeshCapPoly &capline = capper[0];
	int lverts = line.numPts;
	// If we reversed the input polygon, reverse the points here
	if(reversed) {
		for(int v = lverts-1; v >= 0; --v)
			capline.SetVert(v, vert++);			// Gives this vert's location in the mesh!
		}
	else {
		for(int v = 0; v < lverts; ++v)
			capline.SetVert(v, vert++);			// Gives this vert's location in the mesh!
		}
	capper.CapMesh(*dxf_mesh, capInfo, hier.reverse[0] ? TRUE : FALSE, 16);

	dxffaces = dxf_mesh->getNumFaces();
	return(1);
	}

static int nCapPoints,ivert;

static int out_vert(Point3 p, float wstart) {
	Point3 v;
	v = p;
	PUTVERT(dxf_mesh,ivert,v);
	if (isThick) {
		v += Point3(0.0f, 0.0f, pl_thick);
		PUTVERT(dxf_mesh,ivert+nCapPoints,v);
		}
	ivert++;
	return 1;
	}

static int FinishThinPline(void) {
	PVert *pv,*pvlast;
	Point3 v;
	int nTotal,i,k,npv,icap,vstart,res = 1,err;
	float lastb;

#ifdef DBGDXF1
	DebugPrint("FinishThinPline\n");
#endif

	npv = pvtab.Count();

	ivert = vstart = dxfverts;

	/* Count number of verts required */
	nCapPoints = 0;
	lastb = 0.0f;
	for (i=0; i<npv; i++) {
		pv = PV_EL(i);
		if (lastb!=0.0)
			nCapPoints += count_steps(lastb);
		else
			nCapPoints++;
		lastb = pv->bulge;
		}
	if (polyClosed&&lastb!=0.0) 
		nCapPoints += (count_steps(lastb)-1);
		
	nTotal = isThick?2*nCapPoints:nCapPoints;

	if (err=AddVerts(dxf_mesh,nTotal) < 0) {
		object_overflow(err); 
		goto bye;
		}
	dxfverts += nTotal;

	/* create verts */
	lastb = 0.0f;
	for (icap=0; icap<npv; icap++) {
		pv = PV_EL(icap);
		if (lastb!=0) {
			if (DoBulge(pvlast->p, pv->p, 1.0f, 1.0f, lastb,0, out_vert))
				goto bye;
			}
		else 
			out_vert(pv->p, 0.0f);
		lastb = pv->bulge;
		pvlast = pv;
		}

	if (polyClosed) {
		if (lastb!=0) {
			pv = PV_EL(0);
			if (DoBulge(pvlast->p, pv->p, 1.0f, 1.0f, lastb,1, out_vert))
				goto bye;
			}
		}

	/* do first Cap */
	if (polyClosed && theImport->fillPolylines) 
		DoCap(vstart,nCapPoints,0);

	if (isThick) { /* do the side faces */
		int nf = polyClosed? nCapPoints*2 : (nCapPoints-1)*2;
		if (err=AddFaces(dxf_mesh,nf) < 0) {
			object_overflow(err); 
			goto bye; 
			}
		for (i=0; i<nCapPoints-1; i++) {
			k = vstart+i;
			PutAFace(k, k+1, k+nCapPoints+1,1,EDGE_A | EDGE_B);
			PutAFace(k+nCapPoints+1, k+nCapPoints, k,1,EDGE_A | EDGE_B);
			}
		if (polyClosed) {
			PutAFace(vstart+nCapPoints-1,vstart,vstart+nCapPoints,1,EDGE_A | EDGE_B);
			PutAFace(vstart+nCapPoints,vstart+nTotal-1,vstart+nCapPoints-1,1,EDGE_A | EDGE_B);
			if(theImport->fillPolylines)
				DoCap(vstart+nCapPoints,nCapPoints,1);
			}
		}

	/* transform points */

	for (i=vstart; i<dxfverts; i++) {
		v = dxf_mesh->verts[i];
		ApplyTransform(v);	 /* includes Block transf too */
		PUTVERT(dxf_mesh,i,v);
		}

	res = 0;
 bye:
	return(res);
	}
	
static int FinishWidePline(void) {
	int n = pvtab.Count();
	int i;
	float lastb = 0.0f;
	PVert *pv;
	int res = 1;
#ifdef DBGDXF1
	DebugPrint("FinishWidePline  n = %d, closed = %d \n",n,polyClosed);
#endif
	for (i=0; i<n; i++) {
		pv = PV_EL(i);
		if (lastb!=0) {
			if (AddPlineBulge(pv->p, pv->ws,lastb,0)) goto bye;
			}
		else {
			if (AddPlineVert(pv->p,pv->ws)) goto bye;
			}
		lastb = pv->bulge;
		}
	if (polyClosed) {
		if (lastb!=0) {
			if (AddPlineBulge(pl0.p, pl0.wstrt, lastb,1)) goto bye;
			}
		/* ---- close the tube ---- */
		if (EqualVectors(plq[1].p, pl0.p)) {
			if (!AddVertsFaces(nvper,isThick?16:4)) return(1);
			IntsctSegments(&plq[0],&pl0); /* compute pl0.ai,bi */
			put_dbl_vert(pl0.ai); 
			put_dbl_vert(pl0.bi); 
			PutSideFaces(dxfverts-2*nvper,dxfverts-nvper,0);
			PutSideFaces(dxfverts-nvper,startvert,0);
			}
		else {
			if (!AddVertsFaces(2*nvper,isThick?24:6)) return(1);
			ComputeLineEnds(&plq[1],&pl0); /* compute plq[1].a0,a1,b0,b1 */
			IntsctSegments(&plq[0],&plq[1]); /* compute plq[1].ai,bi */
			IntsctSegments(&plq[1],&pl0);  /* compute pl0.ai,bi */
			put_dbl_vert(plq[1].ai); 
			put_dbl_vert(plq[1].bi); 
			put_dbl_vert(pl0.ai); 
			put_dbl_vert(pl0.bi); 
			PutSideFaces(dxfverts-3*nvper,dxfverts-2*nvper,0);
			PutSideFaces(dxfverts-2*nvper,dxfverts-nvper,0);
			PutSideFaces(dxfverts-nvper,startvert,0);
			}
		}
	else {
		/* --- Cap end at last point --- */
		if (!AddVertsFaces(nvper,isThick?10:2)) return(1);
		put_dbl_vert(plq[0].a1); 
		put_dbl_vert(plq[0].b1); 
		PutSideFaces(dxfverts-2*nvper,dxfverts-nvper,POLEND);  
		if (isThick) {
			PutAFace(dxfverts-1, dxfverts-2, dxfverts-4, 4,EDGE_A | EDGE_B);
			PutAFace(dxfverts-4, dxfverts-3, dxfverts-1, 4,EDGE_A | EDGE_B);
			}
		}
	res = 0;
 bye:
	return(res);
	}

static void SetThick(void) {
	pl_thick = (float)rgroup[39];
	if (pl_thick!=0.0) { isThick=1; nvper = 4;	}
	else {	isThick=0;	nvper = 2;	}
	}

static int pline(void) {
	int mverts,mfaces,res;

	inpoly=insmooth=inflat=FALSE;
	inShape = FALSE;  // DS 2-28-96	 -- fixes QA# 116096

	is_3d_pline = igroup[70]&(8+16+64)?1:0;
	polyClosed = (igroup[70] & 1)?1:0;
	pnorm = normal;

#ifdef DBGDXF
	DebugPrint(" PLINE: normal = %.4f, %.4f, %.4f \n", normal[0],normal[1],normal[2]);
#endif

	if (dxf_type==DXF3D) {
		isEntityTM = 0;
		/* ------ 3D ------*/
		if(igroup[70] & 64)	{ /* polyface mesh */
			entity++;
			if(find_dxfobj(DXF_MESH)==0)
				return(1);		/* Errored! */
#ifdef DBGDXF
			DebugPrint(" PLINE:  PolyFace mesh\n");
#endif
			inrat=TRUE;
			}
		else
		if(igroup[70] & 16) { 	/*3D polygon mesh */
			mclosed=nclosed=FALSE;
			if(igroup[70] & 1)
				mclosed=TRUE;
			if(igroup[70] & 32)
				nclosed=TRUE;
			if(igroup[75]) {
				mcount=igroup[73];
				ncount=igroup[74];
				}
			else {
				mcount=igroup[71];
				ncount=igroup[72];
				}

			if (ncount<=0||mcount<=0) {
#if 0
				DebugPrint("    Null Poly mesh: grp[70] =%X  grp[75] = %X  Ncount = %d  Mcount = %d \n",
					igroup[70], igroup[75], ncount,mcount);
#endif
				return(0);
				}

			entity++;
			if(find_dxfobj(DXF_MESH)==0)
				return(1);		/* Errored! */
	
#ifdef DBGDXF
			DebugPrint(" PLINE:  3D Polygon mesh\n");
#endif
			mverts=mcount*ncount;
	
			if(mclosed && nclosed)
				mfaces=mcount*ncount*2;
			else
			if(mclosed)
				mfaces=mcount*(ncount-1)*2;
			else
			if(nclosed)
				mfaces=(mcount-1)*ncount*2;
			else
				mfaces=(mcount-1)*(ncount-1)*2;

			if(res=AddVerts(dxf_mesh,mverts)<0) {
				noram:
				object_overflow(res); 
				return(1); 
				}
			dxfverts+=mverts;
			if(res=AddFaces(dxf_mesh,mfaces)<0)
				goto noram;
			dxffaces+=mfaces;
	
	/* Set flags which tell what to do with verts */
	
			if(igroup[75])
				insmooth=TRUE;
			else
				inflat=TRUE;
			}
		else {	// Polyline or spline
			/* if closed, thick, or wide, input as 3D solid */
			if ((polyClosed&&DXFImport::fillPolylines)||rgroup[39]!=0.0||rgroup[40]!=0) { 
				entity++;
				if (find_dxfobj(DXF_MESH)==0) return(1);	
#ifdef DBGDXF
				DebugPrint(" PLINE: As 3d solid: closed=%d  thick =%.3f, wide=%.3f\n", polyClosed, rgroup[39],rgroup[40]);
#endif
				SetThick();
				lastbulge=0.0f;
				nplverts=0;
				startvert = dxfverts;
				pverts=0;
				inpoly = TRUE;
				anyWide=0;
				pvtab.Delete(0, pvtab.Count());
				inShape = FALSE;
				}
			else {		// We're making a shape object!
				entity++;
				if (find_dxfobj(DXF_SHAPE)==0)
					return(1);	
#ifdef DBGDXF
				DebugPrint("Started pline shape, closed=%d\n",polyClosed);
#endif
				SetThick();		// This will be OFF
				lastbulge=0.0f;
				nplverts=0;
				pverts=0;
				inpoly = TRUE;
				anyWide=0;
				pvtab.Delete(0, pvtab.Count());
				inShape = TRUE;
				isSpline = (igroup[70]&4)?1:0;
				if (isSpline)
					splineType = igroup[75];
				}
			}
		}
	return(0);
	}

/* ---------------- SEQEND ---------------*/
static int seqend (void)	{
	int fixmesh;
	int m,n,p1,p2,p3,p4;
	Face f;
	
#ifdef DBGDXF
	DebugPrint(" SEQEND: dxf_type = %d, inpoly=%d anyWide=%d  inrat=%d closed=%d\n",
		dxf_type,inpoly,anyWide,inrat,polyClosed);
#endif
	if (!is_3d_pline)
		CompEntityTransform(pnorm);
	fixmesh=0;
	if (inpoly) {
		inpoly = FALSE;
#ifdef MAYBE
		if (dxf_type==DXF2D||(dxf_type==DXFPATH&&!isSpline))	{

			/* If handling a bulge on closed polygon, wrap it up! */
			if((shpdata[ptct-1].flags & POLYCLOSED) && lastbulge!=0.0) {
				polys = poly_count();
				pstrt = poly_start(polys-1);
				proc_bulge(&shpdata[ptct-1],&shpdata[pstrt],lastbulge);
				}
			}
		else if (dxf_type==DXFPATH) {
			if (isSpline) {
				if (COUNT(splineTab)>0) {
#ifdef DBGSPLINE
					{
					int i,count;
					FPoint3 *sp;
					count = COUNT(splineTab);
					sp = SPLINE_EL(0);
					DebugPrint("\n\nSPLINE: polyClosed = %d\n",polyClosed);
					for (i=0; i<count; i++) {
						DebugPrint(" point[%d] = (%2f,%.2f,%.2f) \n",i,sp[i].x,sp[i].y,sp[i].z);
						}
					DebugPrint("\n");
					}
#endif
					if((COUNT(splineTab)+1)>PATH_MAX)	{
						DisposTab(&splineTab);
						snprintf(gp_buffer,256,progstr(R3ST0527));
						continu_line(gp_buffer);
						bad_reason=EXCEEDS_SETUP;
						return(1);
						}
					switch (splineType) {
						case 5: QuadraticSpline(); break;
						case 6: CubicSpline(); break;
						}
					}
				DisposTab(&splineTab);
				}
			}
		else
#endif // MAYBE
		if (dxf_type==DXF3D) {
			if (anyWide)  {
				if (pvtab.Count()<2) {
					//TSTR s1(GetString(IDS_TH_BADPOLYLINE));
					//TSTR s2(GetString(IDS_TH_DXFIMP));
					//MessageBox(GetActiveWindow(), s1.data(), s2.data(), MB_OK);
					pvtab.Delete(0, pvtab.Count());
					inrat = insmooth = inflat = FALSE;
					return (0);
					//bad_reason=INVALID_FILE;
					//return(1);
					}
				FinishWidePline();
				}
			else { 
				if(inShape) {
					/* If handling a bulge on closed polygon, wrap it up! */
					if(dxf_spline->Closed() && lastbulge!=0.0f) {
						WorkKnot pstrt(dxf_spline,0);
						int lastknot = dxf_spline->KnotCount() - 1; 
						WorkKnot pend(dxf_spline, lastknot);
						WorkKnot pmid[MAXMID];
						int midpts = proc_bulge(&pend,&pstrt,pmid,lastbulge);
						dxf_spline->SetInVec(0, pstrt.in);
						dxf_spline->SetOutVec(lastknot, pend.out);
						for (int i=0; i<midpts; i++)
							dxf_spline->AddKnot(SplineKnot(KTYPE_BEZIER, LTYPE_CURVE, pmid[i].p, pmid[i].in, pmid[i].out));
						}
					// transform all points in shape  --DS 3-15-96
					for (int i=0; i<dxf_spline->KnotCount()*3; i++) {
						Point3 p = dxf_spline->GetVert(i);
						ApplyTransform(p);
						dxf_spline->SetVert(i, p);
						}
					}
				else
					FinishThinPline();
				}
			pvtab.Delete(0, pvtab.Count());
			}
		}	  
	if(inrat) {
		inrat=FALSE;
		fixmesh=1;
		}
	if(insmooth) {
		insmooth=FALSE;
		f.smGroup=1L;
		goto finish_mesh;
		}
	if(inflat)	{
		inflat=FALSE;
		f.smGroup=0L;
		
		finish_mesh:
		fixmesh=1;
		f.setMatID(get_mtl_id());
		for(m=0; m<mcount; ++m) {
			for(n=0; n<ncount; ++n) {
				p1=m*ncount+n;
				p2=m*ncount+n+1;
				p3=p2+ncount;
				p4=p1+ncount;
				if(n==(ncount-1)) {
					if(nclosed==0)
						goto nextn;
					p2-=ncount;
					p3-=ncount;
					}
				if(m==(mcount-1)){
					if(mclosed==0)
						goto nextn;
					p3-=(mcount*ncount);
					p4-=(mcount*ncount);
					}
				f.flags=EDGE_A | EDGE_B;
				f.v[0]=p1+vertbase;
				f.v[1]=p2+vertbase;
				f.v[2]=p3+vertbase;
				PUTFACE(dxf_mesh,meshface++,f);
	
				f.v[0]=p3+vertbase;
				f.v[1]=p4+vertbase;
				f.v[2]=p1+vertbase;
				PUTFACE(dxf_mesh,meshface++,f);
	
				nextn:;
				}
			}
		}
	if(fixmesh) {
		dxf_mesh->setNumVerts(meshvert, TRUE);
		dxf_mesh->setNumFaces(meshface, TRUE);
		}
	return(0);
	}


static void ConcatTransf(Point3 base, Point3 ins, Point3 scl, float ang, Point3 n) {
	int i;
	Matrix3 tm, tmnorm;
	MRow *tmrow = tm.GetAddr();
	float fang = ang*DEG_TO_RAD;
	tm.IdentityMatrix();
	tm.Translate(-base);
	if (scl.x!=1.0) { for (i=0; i<4; i++) tmrow[i][0]*=scl.x; tm.SetNotIdent(); }
	if (scl.y!=1.0) { for (i=0; i<4; i++) tmrow[i][1]*=scl.y; tm.SetNotIdent(); }
	if (scl.z!=1.0) { for (i=0; i<4; i++) tmrow[i][2]*=scl.z; tm.SetNotIdent(); }
	if (ang!=0.0)
		tm.RotateZ(fang);
	tm.Translate(ins);
	if (!normtest(n)) {
		MakeNormTM(tmnorm,n);
		tm = tm * tmnorm;	
		}
	curtm = tm * curtm;
	}

Block *find_block(char *s) {
	Block *b;
	for (b = blockList; b!=NULL; b= b->next) {
		if (strcmp(s,b->name)==0) return(b);
		}
	return(NULL);
	}

/* INSERT block */

int insert() {
	long svaddr;
	short sv_gcode;
	char *sv_gtextv=NULL;
	char *sv_layer=NULL;
	Block *sv_block,*b;
	short sv_block_col;	
	Point3 inspt,basept,sclfct;
	float rotang;
	float dcol,drow,col_offset,row_offset;
	short ncol,nrow,i,j;
	short error = 0;
	Point3 norm;
	Matrix3 svtm;

	if ((b = find_block(tgroup[2]))==NULL)  {
#ifdef IS_3DSDXF
		DebugPrint(" Couldn't find block %s\n", tgroup[2]);
#endif
		return(0);
		}
	
#ifdef DBGDXF1
	DebugPrint(" INSERT, level# %d,  block %s, layer = %s,gtextv=%s \n", blockLevel,tgroup[2], tgroup[8],gtextv);
#endif

	/*------ Save State--------- */
	svaddr = ftell(fp);
	sv_gcode = gcode;
	sv_block = curBlock;	
	sv_block_col = curBlockCol;	
	sv_gtextv = (char *)malloc(strlen(gtextv)+1);
	if (sv_gtextv==NULL) return(1);

	strcpy(sv_gtextv,gtextv);	
	svtm = curtm;

	sv_layer = (char *)malloc(strlen(curLayer)+1);
	if (sv_layer==NULL) {
		error = 1;
		goto bail;
		}
	strcpy(sv_layer,curLayer);

	/*--- Stash the insert point, scaling, rotation, repeat spacing & count ---*/
	load_vert(inspt,10);
	norm = normal;
	sclfct = Point3((float)rgroup[41],(float)rgroup[42],(float)rgroup[43]);
	rotang = (float)rgroup[50];
	ncol = igroup[70];
	nrow = igroup[71];
	dcol = (float)rgroup[44];
	drow = (float)rgroup[45];
	strcpy(curLayer,tgroup[8]);
	curBlock = b;
	curBlockCol = igroup[62];
	inInsert = TRUE;

#ifdef  DBGCOL 
	DebugPrint(" BlockCol = %d \n", curBlockCol);
#endif

#ifdef  DBGDXF1 
	DebugPrint(" InsPoint = (%.3f,%.3f,%.3f) norm=(%.3f,%.3f,%.3f)\n",
		inspt[0],inspt[1],inspt[2],norm[0],norm[1],norm[2]);
	DebugPrint(" Angle = %.4f, Scaling= (%.3f,%.3f,%.3f)\n",
		rotang,sclfct[0],sclfct[1],sclfct[2]);
#endif


	for (i=0; i<ncol; i++) {
		col_offset = i*dcol;
		for (j=0; j<nrow; j++) {
			row_offset = j*drow;

			/* position "read-head" at start of block */
			fseek(fp, b->fileAddr, SEEK_SET);
			gcode = 0;
			strcpy(gtextv,"BLOCK");
			curBlock = b;
			
			rgroup[10] = rgroup[20] = rgroup[30] = 0.0;

			/* Read in rest of BLOCK entity, to next 0-group */
			if (!inent()||errored) {
				inInsert = FALSE;
				return(FALSE);
				}
		
			/*---- Get the block's base point ----*/
			load_vert(basept,10);

			basept.y-=row_offset;
			basept.x-=col_offset;
		
			/* compute and concatenate transformation */
			ConcatTransf(basept,inspt,sclfct,rotang,norm);

#ifdef  DBGDXF1 
			DebugPrint(" basePoint = (%.3f,%.3f,%.3f) \n",
				basept[0],basept[1],basept[2]);
			pmat(" curtm", curtm);
#endif
		
			/*---- insert the block's contents--- */
			blockLevel++;
			if (!read_entities(1)) {
				error = 1;
				goto outahere;
				}
			blockLevel--;

			/* restore transform */
			curtm = svtm;
			}
		}	

	outahere:
	inInsert = FALSE;

	/*------ Restore State--------- */
	fseek(fp, svaddr, SEEK_SET);
	gcode = sv_gcode;
	curBlock = sv_block;
	curBlockCol = sv_block_col;	
	strcpy(gtextv,sv_gtextv);
	strcpy(curLayer,sv_layer);

#ifdef DBGDXF1
	DebugPrint(" LEAVING INSERT, level# %d,gtextv=%s,ename=%s\n\n", blockLevel,
		gtextv,ename);
#endif
bail:
	if (sv_gtextv) free(sv_gtextv);
	if (sv_layer) free(sv_layer);
	return(error);
	}

void CompPlaneEqn(float *plane, Point3 p0, Point3 p1, Point3 p2) {
	Point3 e1 = p1 - p0;
	Point3 e2 = p2 - p1;
	Point3 cross = Normalize(CrossProd(e1,e2));
	plane[0] = cross.x;
	plane[1] = cross.y;
	plane[2] = cross.z;
	plane[3] = -DotProd(p0,cross);
	}

float DistanceToPlane(Point3 p, float *plane) {
	Point3 planeVec(plane[0], plane[1], plane[2]);
	return(DotProd(planeVec,p) + plane[3]);
	}

/* 3 points a,b,c define a plane: compare Point p with them */
int PointInsideFace(Point3 p, Point3 a, Point3 b, Point3 c) {
	float plane[4];
	CompPlaneEqn(plane,a,b,c);
	return(DistanceToPlane(p,plane)<0.0);
	}

static int VertInsideFace(int nv, int nf) {
	Point3 va,vb,vc,vx;
	Face face;
	face = dxf_mesh->faces[nf];
	va = dxf_mesh->verts[face.v[0]];
	vb = dxf_mesh->verts[face.v[1]];
	vc = dxf_mesh->verts[face.v[2]];
	vx = dxf_mesh->verts[nv];
	return(PointInsideFace(vx, va, vb, vc));
	}

void flipface(Face *f) {
	int ab,bc;
#ifdef DBGNORM
 	DebugPrint("flipping \n");
#endif
	int hold = f->v[0];
	f->v[0] = f->v[2];
	f->v[2] = hold;
	ab = f->flags & EDGE_A;
	bc = f->flags & EDGE_B;
	f->flags &= (~EDGE_A & ~EDGE_B);
	if(ab)
		f->flags |= EDGE_B;
	if(bc)
		f->flags |= EDGE_A;
	}

static void FlipFaces(int nf, int n) {
	int i;
	Face *flist = dxf_mesh->faces;
	for (i=0; i<n; i++) 
		flipface(&flist[nf+i]);
	}

#define PFace(a,b,c) PutAFace(a,b,c, -1, EDGE_ALL)

static void PQuad(int a,int b,int c,int d) {
	PutAFace(a,b,c, -1, EDGE_A|EDGE_B);
	PutAFace(c,d,a, -1, EDGE_A|EDGE_B);
	}

/* _SOLID_ */
static int solid (void) {
	Point3 v[4];
	int i, nsides,nv,dbl,nf,nfaces;
	if (dxf_type==DXF3D) {
		entity++;
		if (find_dxfobj(DXF_MESH)==0) return(1);	
		nv = dxfverts;
		nf = dxffaces;
		CompEntityTransform(normal);
		SetThick();
		dbl = (isThick)?2:1;
		for (i=0; i<4; i++)	
			load_vert(v[i],10+i);
		if (EqualVectors(v[2],v[3])) {
			nsides = 3;
 			nfaces = isThick?8:1;
			if(!AddVertsFaces(dbl*3,nfaces)) return(1);
			}
		else {
			nsides = 4;
 			nfaces = isThick?12:2;
			if(!AddVertsFaces(dbl*4,nfaces)) return(1);
			}
		
		for (i=0; i<nsides; i++) 
			put_dbl_vert(v[i]);
			
		if (nsides==3) {
			PFace(nv, nv+2*dbl, nv+1*dbl); 
			if (isThick) {
				PQuad(nv,nv+2,nv+3,nv+1);				
				PQuad(nv+2,nv+4,nv+5,nv+3);				
				PQuad(nv+4,nv+0,nv+1,nv+5);				
				PFace(nv+1,nv+3,nv+5);
				}
			}
		else {
			PQuad(nv, nv+2*dbl, nv+3*dbl, nv+1*dbl);
			if (isThick) {
				PQuad(nv, nv+2, nv+3, nv+1);
				PQuad(nv+1, nv+3, nv+7, nv+5);
				PQuad(nv+3, nv+2, nv+6, nv+7);
				PQuad(nv+4, nv+5, nv+7, nv+6);
				PQuad(nv, nv+1, nv+5, nv+4);
				}
			}
		/* check the face parity: */
		if (isThick) {
			if (!VertInsideFace(nv+4,(nsides==3)?nf+1:nf+2)) 
				FlipFaces(nf,nfaces);
			}
		}
	return(0);
	}

static int trace(void) {
	return(solid());
	}

/* READ_ENTITIES  */

int read_entities(int skiphdr) {

	/* Read the first Entity header */
	if (!skiphdr) {
		if (!errored && !ingroup())	{
			dxferr();
			return(0);
			}
		}
	while (!errored && inent())	{
		if(ignore_layer(tgroup[8])||igroup[67])	   {
			/* No action, just ignore the entity */
#ifdef DBGDXF1
			if (igroup[67])
				DebugPrint(" Ignoring PAPER SPACE entity %s, layer =%s \n",ename,tgroup[8]);
			else 
				DebugPrint(" Ignoring entity on OFF LAYER %s \n",tgroup[8]);
#endif
			}
		else {
#ifdef DBGDXF
			DebugPrint(" Processing %s entity layer = %s, \n",ename,tgroup[8]);
#endif
			if (!strcmp(ename, "VERTEX")) {	errored=vert();	}
			else
			if (!strcmp(ename, "3DFACE")) {	errored=face3d(); }
			else
			if (!strcmp(ename, "LINE"))	{ errored=line(); }
			else
			if (!strcmp(ename, "POINT")) { errored=dxfpoint(); }
			else 
			if (!strcmp(ename, "CIRCLE"))	{ errored=circ(); }
			else
			if (!strcmp(ename, "ARC"))	{ errored=arc(); }
			else
			if (!strcmp(ename, "POLYLINE"))	{ errored=pline(); }
			else
			if (!strcmp(ename, "SOLID")) {	errored=solid();}
			else
			if (!strcmp(ename, "TRACE")) {	errored=trace();}
			else
			if (!strcmp(ename, "SEQEND")) {	errored=seqend();}
			else
			if (!strcmp(ename, "INSERT")) {	errored=insert(); }
#ifdef IS_3DSDXF
			else
			if (!strcmp(ename, "TEXT")) {	}
			else
			if (!strcmp(ename, "ATTDEF")) {	}
			else 
			if (!strcmp(ename, "ATTRIB")) {	}
			else {
	  			DebugPrint("     Unknown Entity: %s \n", ename);
				}
#endif
			}
		}
	if(errored)
		return(0);
	return(1);
	}

static void free_dxf_objects() {
	namedObjs.DeleteAll();
	}

static BOOL replaceScene = FALSE;



static BOOL CALLBACK
ImportDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
	switch(message) {
		case WM_INITDIALOG:
			CheckRadioButton( hDlg, IDC_3DS_MERGE, IDC_3DS_REPLACE, replaceScene?IDC_3DS_REPLACE:IDC_3DS_MERGE );
			CenterWindow(hDlg,GetParent(hDlg));
			SetFocus(hDlg); // For some reason this was necessary.  DS-3/4/96
			return FALSE;
		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDOK: {
	            	replaceScene = IsDlgButtonChecked(hDlg,IDC_3DS_REPLACE);
					EndDialog(hDlg, 1);
					}
					return TRUE;
				case IDCANCEL:
					EndDialog(hDlg, 0);
					return TRUE;
			}
		}
	return FALSE;
	}


int
dxf_load(const TCHAR *filename, DXFImport *imp) {
	BOOL ram_ok;
	int i;

	// Store import pointer
	theImport = imp;

	// Start out trying the file as text
	WorkFile theFile(filename,_T("r"));
	fp = theFile.Stream();
	if(!fp) {
		badopen:
		if(showPrompts)
			Alert(IDS_TH_ERR_OPENING_FILE);
		return -1;						// Didn't open!
		}
	imp->fileLength = theFile.Length();
		
	// Got the file -- Now put up the options dialog!
	if (showPrompts) {
		int result = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_IMPORTOPTIONS), 
			imp->gi->GetMAXHWnd(), ImportOptionsDlgProc, (LPARAM)imp);
		if(result <= 0)
			return 0;
		}


	if (replaceScene) {
		if (!imp->impInt->NewScene())
			return IMPEXP_CANCEL;
		}
	
	binsent[18] = 0;
	
	/*  Peek at the header to see if it's binary  */
	
	if ((Read(fp,binsent,18) != 18) ||
		  	(strcmp(binsent, "AutoCAD Binary DXF") != 0))	{
		fseek(fp,0L,SEEK_SET);
		binary = FALSE;
		GetDecSymbolFromRegistry();
		}
	else {
		/* This is a binary DXF file.  To insure correct processing
			of binary information we must close the file and re-open
			it with the binary I/O attribute. */

		// Reopen the file as binary
		theFile.Close();
		theFile.Open(filename,_T("rb"));
		fp = theFile.Stream();
		if (!fp)
			goto badopen;

		// see if its R13 or later, which has WORD instead of BYTE codes
		Read(fp,binsent,24);
		isR13 = (binsent[23]==0)?1:0;
	
		/* Skip past the header */
		fseek(fp, 22L, SEEK_SET);  
		binary = TRUE;
		}
	
//	please_wait(progstr(STR0560));

	/*  Allocate dynamic storage to read file  */
	
	ram_ok=FALSE;

	Memory inBuf, gTextV, tGroup[10], rGroup, iGroup;
	if(!(inbuf = (char *)inBuf.Alloc(256,TRUE)))
		goto bailout;
	if(!(gtextv = (char *)gTextV.Alloc(MAXGTXT,TRUE)))
		goto bailout;
	for (i = 0; i < 10; i++) {
		if(!(tgroup[i] = (char *)tGroup[i].Alloc(256,TRUE)))
			goto bailout;
		}
	if(!(rgroup = (double *)rGroup.Alloc(60 * sizeof(double),TRUE)))
		goto bailout;
	if(!(igroup = (short *)iGroup.Alloc(80 * sizeof(short),TRUE)))
		goto bailout;
	
	ram_ok=TRUE;
	entnum=0;
	
	/*  Ignore all of DXF file before ENTITIES section  */
	/*  This code could be modified to recognized other sections */

	curtm.IdentityMatrix();	

	blockLevel=0;
	errored = FALSE;
	while (!errored && ingroup()){
		if (gcode == 0 && !strcmp(gtextv, "SECTION")) {
			if (!ingroup())	{  dxferr(); break;	}
			if (gcode != 2) {  dxferr(); break;	}
			if (!strcmp(gtextv, "BLOCKS"))
				read_blocks();
			else
			if (!strcmp(gtextv, "TABLES"))
				read_tables();
			else
			if (!strcmp(gtextv, "ENTITIES"))
				read_entities(0);
			}
		}

	/* Release dynamic storage used whilst reading DXF file */
	
 bailout:
	if(!ram_ok) {
		if(showPrompts)
			no_RAM();
		return(-1);
		}
	else
	if (errored) {
		
		free_dxf_objects();	

		switch(bad_reason) {
			case INVALID_FILE:
				if(showPrompts)
					Alert(IDS_TH_ERRORINDXF);
				break;
			case PARTIAL_READ:
				if(showPrompts)
					Alert(IDS_TH_PARTIALREAD);
				break;
			case USER_CANCEL:	// No need to return an error state on this
				return 1;
			default:
				if(showPrompts)
					Alert(IDS_TH_UNKNOWNERR);
				break;
			}
		return(-1);
		}
	return 1;
	}

// Weld a mesh based on a weld threshold.
// There are two parts to this procedure:
// (1) Build a BitArray noting the verts to weld together
// (2) Weld 'em!
// This code "borrowed" from Rolf's Edit Mesh modifier and altered to suit my needs

DWORD GetOtherIndex(Face *f,DWORD v0,DWORD v1)
	{
	for (int i=0; i<3; i++) {
		if (f->v[i]!=v0 && f->v[i]!=v1) return f->v[i];
		}
	// Invalid face
	return 0;
	}

int GetEdgeIndex(Face &f,DWORD v0,DWORD v1)
	{
	int j0, j1;
	for (int i=0; i<3; i++) {
		if (f.v[i]==v0) j0 = i;
		if (f.v[i]==v1) j1 = i;
		}
	switch (j0) {
		case 0: return j1==1?0:2;
		case 1: return j1==2?1:0;
		case 2: return j1==0?2:1;
		default:
			assert(0);
			return 0;
		}	
	}

void MeshDeleteFaces(Mesh &mesh,BitArray& set)
	{
	int j = 0;
	for (int i=0; i<mesh.getNumFaces(); i++) {
		if (set[i]) continue;		
		mesh.faces[j] = mesh.faces[i];		
		if (mesh.tvFace) {
			mesh.tvFace[j] = mesh.tvFace[i];
			}
		j++;
		}
	if (j!=mesh.getNumFaces()) {
		mesh.setNumFaces(j,TRUE);
		}
	}

void MeshDeleteVertices(Mesh &mesh,BitArray& set)
	{
	int j = 0;
	for (int i=0; i<mesh.getNumVerts(); i++) {
		if (set[i]) continue;		
		mesh.verts[j] = mesh.verts[i];		
		j++;
		}
	if (j!=mesh.getNumVerts()) {
		mesh.setNumVerts(j,TRUE);
		}
	}

void WeldVertSet(Mesh *mesh,BitArray &set)
	{
	int i;
	int firstSel = -1, numSel=0;
	Point3 pt(0,0,0), dt;

	// Find the first selected vert and find the average of all
	// selected verts
	for (i=0; i<set.GetSize(); i++) {
		if (set[i]) {
			if (firstSel<0) firstSel = i;
			numSel++;
			pt += mesh->verts[i];
			}
		}
	if (firstSel < 0) return;
	pt /= float(numSel);

	// Move the first point to the average position of all verts
	// getting welded.
	dt = pt-mesh->verts[firstSel];
	mesh->verts[firstSel] = pt;

	// Go through each face. If exactly one of the faces vertices is
	// going to be welded, Then remap it. If more than one is going to
	// be welded then delete the face.
	BitArray delSet;
	delSet.SetSize(mesh->getNumFaces());
	for (i=0; i<mesh->getNumFaces(); i++) {
		int ct = 0;
		for (int j=0; j<3; j++) {
			if (set[mesh->faces[i].v[j]]) ct++;			
			}

		if (ct > 1) delSet.Set(i); // Delete it
		else if (ct == 1) {
			// Remap it.
			DWORD v[3] = {mesh->faces[i].v[0],mesh->faces[i].v[1],mesh->faces[i].v[2]};
			for (int j=0; j<3; j++) {
				if (set[mesh->faces[i].v[j]]) {
					v[j] = firstSel;
					mesh->faces[i].v[j] = firstSel;
					break;
					}
				}
			}
		}
	int j=0;
	for (i=0; i<mesh->getNumFaces(); i++) {
		if (!delSet[i])
			j++;
		}
	MeshDeleteFaces(*mesh,delSet);	
	
	// Build the delMap. This is a table with one entry per vertex. The
	// entry is the number of vertices deleted before this vertex.
	DWORDTab delMap;
	DWORD deleted = 0;
	delMap.SetCount(mesh->getNumVerts());
	for (i=0; i<mesh->getNumVerts(); i++) {
		delMap[i] = deleted;
		if (set[i] && i!=firstSel) {
			deleted++;
			}
		}

	// Now remap the faces using the delMap
	for (i=0; i<mesh->getNumFaces(); i++) {
		DWORD v[3];
		v[0] = mesh->faces[i].v[0] - delMap[mesh->faces[i].v[0]];
		v[1] = mesh->faces[i].v[1] - delMap[mesh->faces[i].v[1]];
		v[2] = mesh->faces[i].v[2] - delMap[mesh->faces[i].v[2]];		
		mesh->faces[i].v[0] = v[0];
		mesh->faces[i].v[1] = v[1];
		mesh->faces[i].v[2] = v[2];
		}

	// Go through all selected vertices, except the first and delete them.	
	set.Set(firstSel,FALSE);
	j=firstSel+1;
	for (i=firstSel+1; i<mesh->getNumVerts(); i++) {
		if (!set[i])
			j++;
		}
	MeshDeleteVertices(*mesh,set);

	mesh->InvalidateEdgeList();
	mesh->InvalidateGeomCache();	
	}


static void WeldVerts(Mesh *mesh,float thresh)
	{
	int i, j;	
	// So we can compare length squared
	thresh = thresh * thresh;

#ifdef DBGFINAL
int origVerts = mesh->getNumVerts();
#endif // DBGFINAL
	
	for (i=0; i<mesh->getNumVerts(); i++) {
		// We'll flag verts that are within the threshold for the ith vert
		BitArray set;
		set.SetSize(mesh->getNumVerts());			
		set.Set(i);
		int found = 0;

		for (j=0; j<mesh->getNumVerts(); j++) {
			if (i==j) continue;

			if (LengthSquared(mesh->verts[i]-mesh->verts[j]) < thresh) {
				set.Set(j);
				found++;
				}
			}
		
		// If we found any to weld, weld away!
		if (found)
			WeldVertSet(mesh,set);
		}

#ifdef DBGFINAL
int finalVerts = mesh->getNumVerts();
if(finalVerts != origVerts)
	DebugPrint("Weld dropped vert count to %d from %d\n",finalVerts,origVerts);
#endif // DBGFINAL
	}

inline Point3 FaceNormal( Mesh& mesh, DWORD fi )
	{
	Face *f = &mesh.faces[fi];
	Point3 v1 = mesh.verts[f->v[1]] - mesh.verts[f->v[0]];
	Point3 v2 = mesh.verts[f->v[2]] - mesh.verts[f->v[1]];
	return v1^v2;
	}

/* Finalize the 3D DXF or filmroll load */

BOOL dxf_finalstep(ImpInterface *iface) {
	int ox;
	NamedObject *n;
	Mesh *m;
	BezierShape *s;

#ifdef xxDBGFINAL
	prblocks();
#endif
	
	free_lists();

#ifdef xxDBGDXF
		    dump_objects(); 
#endif
	theImport->gi->ProgressUpdate(0, FALSE, GetString(IDS_TH_FINALIZING));
	/* Fix up the new objects */
	for(ox=0; ox<namedObjs.Count(); ++ox) {
		theImport->gi->ProgressUpdate(50 + ox * 100 / namedObjs.Count() / 2);
		if (user_cancel()) break;
		n=namedObjs.GetNamedPtr(ox);
		switch(n->type) {
			case DXF_MESH: {
				m = &n->mesh;
		//		check_faces(m);
				int verts = m->getNumVerts();
				int faces = m->getNumFaces();
#ifdef DBGFINAL
				DebugPrint("     Object %s created, %d Verts,  %d Faces\n", n->name, verts, faces);
#endif
				if(verts || faces) {
					if (theImport->weld) {
#ifdef DBGFINAL
						DebugPrint("     		Welding (%f)...", theImport->thresh);
#endif
						WeldVerts(m, theImport->thresh);

#ifdef DBGFINAL
						DebugPrint("    %d Verts,  %d Faces\n", m->getNumVerts(), m->getNumFaces());
#endif
						}
					if (theImport->weld || theImport->removeDouble) {
#ifdef DBGFINAL
						DebugPrint("     		Removing double faces...");
#endif
						RemoveDoubleFaces(m);
						m->RemoveDegenerateFaces();

#ifdef DBGFINAL
						DebugPrint("    %d Verts,  %d Faces\n", m->getNumVerts(), m->getNumFaces());
#endif
						}
					if (user_cancel()) break;

					m->RemoveIllegalFaces();

					if (theImport->unifyNormals) {
#ifdef DBGFINAL
						DebugPrint("     		Unifying Normals...\n");
#endif
						m->UnifyNormals(FALSE);
						}
					if (user_cancel()) break;
					if (theImport->smooth) {
#ifdef DBGFINAL
						DebugPrint("     		Smoothing...\n");
#endif
						m->AutoSmooth(theImport->smoothAngle * DEG_TO_RAD,FALSE);
						}
			
					// Now add the objects to the MAX database...

					m->buildNormals();
					m->EnableEdgeList(1);

					ImpNode *node = iface->CreateNode();
					if(node) {
						TriObject *tri = CreateNewTriObject();
						// Now find the center of the vertices and use that as the pivot
						int verts = m->getNumVerts();
						Point3 accum(0,0,0);
						for(int i = 0; i < verts; ++i)
							accum += m->verts[i];
						Point3 delta = accum / (float)verts;
						for(i = 0; i < verts; ++i)
							m->verts[i] -= delta;
						tri->GetMesh() = *m;
						node->Reference(tri);
						Matrix3 tm;
						tm.IdentityMatrix();		// Reset initial matrix to identity
						tm.SetTrans(delta);			// Add in the center point
						node->SetTransform(0,tm);
						iface->AddNodeToScene(node);
						node->SetName(_T(n->name));
						// Get access to the actual node for the next part
						INode *inode = node->GetINode();
						inode->SetWireColor(DWORD_FROM_OC(aciColors[n->color]));
						}
					else
						return FALSE;

					}
				}
				break;
			case DXF_SHAPE: {
				s = &n->shape;
				// Delete any empty splines
				int splines = s->SplineCount();
				s->UpdateSels();
				for(int i = splines - 1; i >= 0; --i) {
					Spline3D *spline = s->splines[i];
					if(spline->KnotCount() < 2)
						s->DeleteSpline(i);
					}
				// Now add the shape to the scene if it's got anything left!
				if(s->SplineCount()) {
					s->UpdateSels();

					ImpNode *node = iface->CreateNode();
					if(node) {
						SplineShape *shape = new SplineShape;
						// Now find the center of the vertices and use that as the pivot
						int polys = s->SplineCount();
						Point3 accum(0,0,0);
						int verts = 0;
						for(int poly = 0; poly < polys; ++poly) {
							Spline3D *spline = s->splines[poly];
							int knots = spline->KnotCount();
							verts += knots;
							for(int k = 0; k < knots; ++k)
								accum += spline->GetKnotPoint(k);
							}
						Point3 delta = accum / (float)verts;
						Matrix3 tm = TransMatrix(-delta);
						for(poly = 0; poly < polys; ++poly)
							s->splines[poly]->Transform(&tm);

						shape->shape = *s;
						node->Reference(shape);
						tm.IdentityMatrix();		// Reset initial matrix to identity
						tm.SetTrans(delta);			// Add in the center point
						node->SetTransform(0,tm);
						iface->AddNodeToScene(node);
						node->SetName(_T(n->name));
						// Get access to the actual node for the next part
						INode *inode = node->GetINode();
						inode->SetWireColor(DWORD_FROM_OC(aciColors[n->color]));
						}
					else
						return FALSE;

					}
				}
				break;
			}
		}
#ifdef DBGFINAL
				DebugPrint("Final complete!\n");
#endif
	theImport->gi->ProgressUpdate(100);

	return TRUE;
	}

// Dummy thread routine
DWORD WINAPI dummy(LPVOID arg) { return 0; }

int
DXFImport::DoImport(const TCHAR *filename,ImpInterface *iface,Interface *gi, BOOL suppressPrompts) {
	// Set a global prompt display switch
	showPrompts = suppressPrompts ? FALSE : TRUE;

	int status;

	impInt = iface;
	this->gi = gi;

	inInsert = FALSE;		
	dxf_type= DXF3D;
	curBlock = lastBlock = NULL;
	last_entity=entity=0;
	dxf_mesh = NULL;
	dxf_shape = NULL;
	dxf_spline = NULL;

	if(suppressPrompts) {	// Set default parameters here
		objsFrom = OBJS_LAYER;			// Derive objects from...
		thresh = 0.01f;					// Weld threshold
		weld = TRUE;
		smoothAngle = 30.0f;				// Smooth angle
		smooth = TRUE;
		arcDegrees = 10.0f;
		arcSubDegrees = 90.0f;
		removeDouble = TRUE;
		fillPolylines = TRUE;
		unifyNormals = TRUE;
		}
	else {
		if (!DialogBox(hInstance, MAKEINTRESOURCE(IDD_MERGEORREPL), gi->GetMAXHWnd(), ImportDlgProc))
			return IMPEXP_CANCEL;
		}
	
	gi->ProgressStart(GetString(IDS_TH_IMPORTINGDXF), TRUE, dummy, 0);
	status = dxf_load(filename, this);

	if(status == 0)
		status = IMPEXP_CANCEL;	
	else {
		if(status > 0)	{
			if(!dxf_finalstep(iface))
				DebugPrint("Error loading into MAX\n");
			}
		}

	// Get rid of our named objects list
	free_dxf_objects();

	FreeNameList(); 

	// Get rid of the progress bar
	gi->ProgressEnd();

	return(status<=0?IMPEXP_FAIL:status);
	}

static void	RemoveDoubleFaces(Mesh *m) {
	Edge *edgeList;
	int numedges;
	// clear all flags
	for (int i=0; i<m->numFaces; i++)	
		m->faces[i].flags &= ~FACE_WORK;
	if ((edgeList = m->MakeEdgeList(&numedges,1))==NULL) 
		return;
	delete[] edgeList;

	// Now delete all the flagged faces
	m->DeleteFlaggedFaces();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\arbaxis.cpp ===
/*  ARBAXIS.C    9/15/88 */


/*  This module defines the ARBAXIS routine for obtaining an
    arbitrary but repeatable coordinate axis from a given entity
    normal (extrusion direction).  In this manner, a complete coordinate
    system can be (reliably) built from only 3 real numbers.

    Support routines are provided here for creating a 4x4 coordinate
    system matrix from an entity normal, and for transforming a point
    given the normal.  Some general vector geometry support routines
    are also included.


*/


#include <math.h>

#define X  0			   /* Coordinate indices */
#define Y  1
#define Z  2
#define T  3

#define TRUE  1
#define FALSE 0

typedef double point[3];	   /* Three dimensional point */
typedef double vector[4];	   /* Homogeneous coordinate vector */
typedef double matrix[4][4];	   /* Transformation matrix */

#define ARBBOUND  0.015625  /* aka "1/64" */
#define ZERO 1e-10

/*  Forward decls */


/*  Local stuff */

static double yaxis[3] = {0.0, 1.0, 0.0};
static double zaxis[3] = {0.0, 0.0, 1.0};

/*  MATIDENT  --  Set a matrix to the identity matrix  */

void matident(matrix a)
{
	register int i, j;

	for (i = 0; i < 4; i++) {
	   for (j = 0; j < 4; j++) {
	      a[i][j] = (i == j) ? 1.0 : 0.0;
	   }
	}
}

/*  POINTCOPY  --  Copy point to another  */

void pointcopy(point po, point p)
{
	po[X] = p[X];
	po[Y] = p[Y];
	po[Z] = p[Z];
}

/*  VECCROSS  --  Get the cross product of two vectors.  Return
                  the result in o.  */

void veccross(point o, point a, point b)
{
	point r;

	r[X] = a[Y] * b[Z] - a[Z] * b[Y];
	r[Y] = a[Z] * b[X] - a[X] * b[Z];
	r[Z] = a[X] * b[Y] - a[Y] * b[X];

	pointcopy(o, r);
}

/*  VECSCAL  --  Multiply vector by a scalar and store the result
		 in a second vector.  Expects points.  */

void vecscal(point o, point a, double s)
{
	o[X] = a[X] * s;
	o[Y] = a[Y] * s;
	o[Z] = a[Z] * s;
}

/*  VECMAG  --	Returns magnitude of a vector.	This expects a point
		and uses only the first three terms.  */

double vecmag(point a)
{
	return sqrt(a[X] * a[X] + a[Y] * a[Y] + a[Z] * a[Z]);
}

/*  VECNORM  --  Normalise vector and store normalised result in
		 a second vector.  Works on points.  */

void vecnorm(point o, point a)
{
	vecscal(o, a, 1.0 / vecmag(a));
}

/*  MATORIE  --  Specify explicit orientation  */

void matorie(matrix m, double a, double b, double c, double d, double e, double f, double p, double q, double r)
{
	matident(m);
	m[0][0] = a;
	m[1][0] = b;
	m[2][0] = c;
	m[0][1] = d;
	m[1][1] = e;
	m[2][1] = f;
	m[0][2] = p;
	m[1][2] = q;
	m[2][2] = r;
}

/*  ARBAXIS -- Given a unit vector to be used as one of the axes of a
               coordinate system, choose a second axis.  The choice is
               in principal arbitrary; we just want to make it pre-
               dictable.  Our method is to examine the given Z axis
               and see if it is close to the world Z axis or the
               negative of the world Z axis.  If it is, we cross the
               given Z axis with the world Y axis to arrive at the
               arbitrary X axis.  If not, we cross the given Z axis with
               the world Z axis to arrive at the arbitrary X axis.
               The boundary at which the decision is made was designed to
               be both inexpensive to calculate and to be completely
               portable across machines.  This is done by having a
               sort of "square" polar cap, the bounds of which is
               1/64, which is fully specifiable in 6 decimal fraction
               digits and in 6 binary fraction bits.

               To get a right-handed system, treat the axis returned by
               this function as the cyclically next one after the given
               axis (e.g., if you give it a Z-axis, it returns a
               suitable X-axis).

*/
void arbaxis(double *newaxis, double *givenaxis)
{
    if (fabs(givenaxis[X]) < ARBBOUND && fabs(givenaxis[Y]) < ARBBOUND)
        veccross(newaxis, yaxis, givenaxis);
    else
        veccross(newaxis, zaxis, givenaxis);

    vecnorm(newaxis, newaxis);
}

/*  GETA4BY4 -- Given the entity's normal (extrusion direction vector),
                return a 4x4 matrix that defines the transform in 3D.
                mat is assumed to be matrix[4][4], where the
                the first subscript represents X,Y,Z,Dummy.

                Speed is sacrificed here in favor of comprehensibility.
*/

void geta4by4(point normaxis, matrix mat)
{
    point xdir, ydir, zdir;

    pointcopy(zdir, normaxis);

    /* First get the arbitrary x axis of the entity given its norm (Z) */

    arbaxis(xdir, zdir);

    /* Now we cross our new X-axis with our norm (Z) to get the Y-axis */

    veccross(ydir, zdir, xdir);

    /* And we normalize that to a unit vector */

    vecnorm(ydir, ydir);

    /* We now have all the components of the transformation matrix. */
    
    matorie(mat, xdir[X], xdir[Y], xdir[Z],
                 ydir[X], ydir[Y], ydir[Z],
                 zdir[X], zdir[Y], zdir[Z]);

}

/*  TRANS  --   Transform a point, given a normal vector (3 reals).
                This uses geta4by4, so it's not super fast.
                Returns the point in o.  */

void trans(point o, point pt, point vec)
{
    register int i;
    matrix m;
    point sum;

    /* First, get the transformation matrix from the normal */

    geta4by4(vec, m);

    /* Now, do a standard matrix transformation on the point. */

    for (i=0; i<3; i++)
        sum[i] = m[i][0] * pt[X] +
                 m[i][1] * pt[Y] +
                 m[i][2] * pt[Z] +
                 m[i][3];

    o[X] = sum[X];
    o[Y] = sum[Y];
    o[Z] = sum[Z];

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\dxfexp.cpp ===
/**********************************************************************
 *<
	FILE: dxfexp.cpp

	DESCRIPTION:  .DXF file export module

	CREATED BY: Tom Hudson

	HISTORY: created 30 November 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "Max.h"
#include "dxferes.h"


#include <stdarg.h>

static BOOL showPrompts;
static BOOL exportSelected;

static TCHAR decimalSymbol = _T('.');

static void GetDecSymbolFromRegistry() {
    HKEY hKey;
    DWORD dwType, numBytes;
	long status;
    unsigned char symbol[80];
	decimalSymbol = _T('.');
	status = RegOpenKeyEx (HKEY_CURRENT_USER, 
		      "Control Panel\\International", 
		      0, KEY_READ, &hKey);
    if (status == ERROR_SUCCESS) {
		if (ERROR_SUCCESS==RegQueryValueEx (hKey, "sDecimal", 0, &dwType, 
			 symbol, &numBytes))
			decimalSymbol = symbol[0];
	    }
	}

TCHAR *FixDecSymbol(TCHAR *buf)
	{
	TCHAR *cp = buf;
	while(*cp) {
		if( *cp == decimalSymbol)
			*cp = _T('.');
		cp++;
		}
	return buf;
	}

int Xprintf(FILE *stream, const TCHAR *format, ...) {
	TCHAR buf[512];
	va_list args;
	va_start(args,format);
	_vsntprintf(buf,512,format,args);
	va_end(args);
	FixDecSymbol(buf);
	return fputs(buf, stream);
	}

HINSTANCE hInstance;

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

static void MessageBox(int s1, int s2) {
	TSTR str1(GetString(s1));
	TSTR str2(GetString(s2));
	MessageBox(GetActiveWindow(), str1.data(), str2.data(), MB_OK);
	}

static int MessageBox(int s1, int s2, int option = MB_OK) {
	TSTR str1(GetString(s1));
	TSTR str2(GetString(s2));
	return MessageBox(GetActiveWindow(), str1, str2, option);
	}

static int Alert(int s1, int s2 = IDS_DXFEXP, int option = MB_OK) {
	return MessageBox(s1, s2, option);
	}

// Here are the 256 ACI (Autodesk Color Index) colors:
struct ObjectColors {
	BYTE	r, g, b;
	}; 

inline DWORD DWORD_FROM_OC(ObjectColors x) {
	return (x.r | (x.g << 8) | (x.b << 16));
	}

static ObjectColors aciColors[256] = {
    {0, 0, 0}, {250, 0, 0}, {250, 250, 0}, {0, 250, 0}, {0, 250, 250},
    {0, 0, 250}, {250, 0, 250}, {250, 250, 250}, {135, 135, 135},
    {203, 203, 203}, {255, 0, 0}, {255, 127, 127}, {165, 0, 0}, {165, 82, 82},
    {127, 0, 0}, {127, 63, 63}, {76, 0, 0}, {76, 38, 38}, {38, 0, 0},
    {38, 19, 19}, {255, 63, 0}, {255, 159, 127}, {165, 41, 0}, {165, 103, 82},
    {127, 31, 0}, {127, 79, 63}, {76, 19, 0}, {76, 47, 38}, {38, 9, 0},
    {38, 23, 19}, {255, 127, 0}, {255, 191, 127}, {165, 82, 0}, {165, 124, 82},
    {127, 63, 0}, {127, 95, 63}, {76, 38, 0}, {76, 57, 38}, {38, 19, 0},
    {38, 28, 19}, {255, 191, 0}, {255, 223, 127}, {165, 124, 0},
    {165, 145, 82}, {127, 95, 0}, {127, 111, 63}, {76, 57, 0}, {76, 66, 38},
    {38, 28, 0}, {38, 33, 19}, {255, 255, 0}, {255, 255, 127}, {165, 165, 0},
    {165, 165, 82}, {127, 127, 0}, {127, 127, 63}, {76, 76, 0}, {76, 76, 38},
    {38, 38, 0}, {38, 38, 19}, {191, 255, 0}, {223, 255, 127},
    {124, 165, 0}, {145, 165, 82}, {95, 127, 0}, {111, 127, 63}, {57, 76, 0},
    {66, 76, 38}, {28, 38, 0}, {33, 38, 19}, {127, 255, 0}, {191, 255, 127},
    {82, 165, 0}, {124, 165, 82}, {63, 127, 0}, {95, 127, 63}, {38, 76, 0},
    {57, 76, 38}, {19, 38, 0}, {28, 38, 19}, {63, 255, 0}, {159, 255, 127},
    {41, 165, 0}, {103, 165, 82}, {31, 127, 0}, {79, 127, 63}, {19, 76, 0},
    {47, 76, 38}, {9, 38, 0}, {23, 38, 19}, {0, 255, 0}, {127, 255, 127},
    {0, 165, 0}, {82, 165, 82}, {0, 127, 0}, {63, 127, 63}, {0, 76, 0},
    {38, 76, 38}, {0, 38, 0}, {19, 38, 19}, {0, 255, 63}, {127, 255, 159},
    {0, 165, 41}, {82, 165, 103}, {0, 127, 31}, {63, 127, 79}, {0, 76, 19},
    {38, 76, 47}, {0, 38, 9}, {19, 38, 23}, {0, 255, 127}, {127, 255, 191},
    {0, 165, 82}, {82, 165, 124}, {0, 127, 63}, {63, 127, 95}, {0, 76, 38},
    {38, 76, 57}, {0, 38, 19}, {19, 38, 28}, {0, 255, 191}, {127, 255, 223},
    {0, 165, 124}, {82, 165, 145}, {0, 127, 95}, {63, 127, 111}, {0, 76, 57},
    {38, 76, 66}, {0, 38, 28}, {19, 38, 33}, {0, 255, 255}, {127, 255, 255},
    {0, 165, 165}, {82, 165, 165}, {0, 127, 127}, {63, 127, 127}, {0, 76, 76},
    {38, 76, 76}, {0, 38, 38}, {19, 38, 38}, {0, 191, 255}, {127, 223, 255},
    {0, 124, 165}, {82, 145, 165}, {0, 95, 127}, {63, 111, 127}, {0, 57, 76},
    {38, 66, 76}, {0, 28, 38}, {19, 33, 38}, {0, 127, 255}, {127, 191, 255},
    {0, 82, 165}, {82, 124, 165}, {0, 63, 127}, {63, 95, 127}, {0, 38, 76},
    {38, 57, 76}, {0, 19, 38}, {19, 28, 38}, {0, 63, 255}, {127, 159, 255},
    {0, 41, 165}, {82, 103, 165}, {0, 31, 127}, {63, 79, 127}, {0, 19, 76},
    {38, 47, 76}, {0, 9, 38}, {19, 23, 38}, {0, 0, 255}, {127, 127, 255},
    {0, 0, 165}, {82, 82, 165}, {0, 0, 127}, {63, 63, 127}, {0, 0, 76},
    {38, 38, 76}, {0, 0, 38}, {19, 19, 38}, {63, 0, 255}, {159, 127, 255},
    {41, 0, 165}, {103, 82, 165}, {31, 0, 127}, {79, 63, 127}, {19, 0, 76},
    {47, 38, 76}, {9, 0, 38}, {23, 19, 38}, {127, 0, 255}, {191, 127, 255},
    {82, 0, 165}, {124, 82, 165}, {63, 0, 127}, {95, 63, 127}, {38, 0, 76},
    {57, 38, 76}, {19, 0, 38}, {28, 19, 38}, {191, 0, 255}, {223, 127, 255},
    {124, 0, 165}, {145, 82, 165}, {95, 0, 127}, {111, 63, 127}, {57, 0, 76},
    {66, 38, 76}, {28, 0, 38}, {33, 19, 38}, {255, 0, 255}, {255, 127, 255},
    {165, 0, 165}, {165, 82, 165}, {127, 0, 127}, {127, 63, 127}, {76, 0, 76},
    {76, 38, 76}, {38, 0, 38}, {38, 19, 38}, {255, 0, 191}, {255, 127, 223},
    {165, 0, 124}, {165, 82, 145}, {127, 0, 95}, {127, 63, 111}, {76, 0, 57},
    {76, 38, 66}, {38, 0, 28}, {38, 19, 33}, {255, 0, 127}, {255, 127, 191},
    {165, 0, 82}, {165, 82, 124}, {127, 0, 63}, {127, 63, 95}, {76, 0, 38},
    {76, 38, 57}, {38, 0, 19}, {38, 19, 28}, {255, 0, 63}, {255, 127, 159},
    {165, 0, 41}, {165, 82, 103}, {127, 0, 31}, {127, 63, 79},  {76, 0, 19},
    {76, 38, 47}, {38, 0, 9}, {38, 19, 23}, {84, 84, 84}, {118, 118, 118},
    {152, 152, 152}, {186, 186, 186}, {220, 220, 220}, {255, 255, 255}
};

static int ColDist(ObjectColors a, ObjectColors b) {
	int dr = a.r-b.r;
	int dg = a.g-b.g;
	int db = a.b-b.b;
	return dr*dr + dg*dg + db*db;
	}

static int FindACIColor(DWORD color) {
	ObjectColors dc;
	dc.r = (BYTE)(color&255);
	dc.g = (BYTE)((color>>8)&255);
	dc.b = (BYTE)((color>>16)&255);
	int ibest=-1;
	int dist=1000000;
	for (int i=1; i<255; i++) {
		int d = ColDist(aciColors[i],dc);
		if (d<dist) {
			dist = d;
			ibest = i;
			}
		}
	return ibest;
	}

#define no_RAM() Alert(IDS_TH_OUTOFMEMORY)

#define LAYERS_BY_OBJECT 0
#define LAYERS_BY_MATERIAL 1
#define LAYERS_ONE_LAYER 2

#define NUM_SOURCES 3 		// # of sources in dialog

class DXFExport : public SceneExport {
	friend BOOL CALLBACK ExportOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

public:
	static	int		layersFrom;					// Derive layers from...
					DXFExport();
					~DXFExport();
	int				ExtCount();					// Number of extensions supported
	const TCHAR *	Ext(int n);					// Extension #n (i.e. "3DS")
	const TCHAR *	LongDesc();					// Long ASCII description (i.e. "Autodesk 3D Studio File")
	const TCHAR *	ShortDesc();				// Short ASCII description (i.e. "3D Studio")
	const TCHAR *	AuthorName();				// ASCII Author name
	const TCHAR *	CopyrightMessage();			// ASCII Copyright message
	const TCHAR *	OtherMessage1();			// Other message #1
	const TCHAR *	OtherMessage2();			// Other message #2
	unsigned int	Version();					// Version number * 100 (i.e. v3.01 = 301)
	void			ShowAbout(HWND hWnd);		// Show DLL's "About..." box
	int				DoExport(const TCHAR *name,ExpInterface *ei,Interface *i, BOOL suppressPrompts=FALSE, DWORD options=0);	// Export file
	BOOL			SupportsOptions(int ext, DWORD options);
	};

// Statics
int					DXFExport::layersFrom = LAYERS_BY_OBJECT;			// Derive layers from...

// Handy file class

class WorkFile {
private:
	FILE *stream;
	
public:
					WorkFile(const TCHAR *filename,const TCHAR *mode) { stream = NULL; Open(filename, mode); };
					~WorkFile() { Close(); };
	FILE *			Stream() { return stream; };
	int				Close() { int result=0; if(stream) result=fclose(stream); stream = NULL; return result; }
	void			Open(const TCHAR *filename,const TCHAR *mode) { Close(); stream = _tfopen(filename,mode); }
	};

// Handy memory worker

class Memory {
	void *ptr;
public:
					Memory() { ptr = NULL; }
					Memory(int amount, BOOL zero = FALSE) { ptr = NULL; Alloc(amount, zero); }
					~Memory() { Free(); }
	void *			Ptr() { return ptr; }
	void *			Realloc(int amount);
	void *			Alloc(int amount, BOOL zero = FALSE);
	void			Free() { if(ptr) free(ptr); ptr = NULL; }
	};

void *Memory::Realloc(int amount) {
	if(ptr)
		ptr = realloc(ptr, amount);
	else
		ptr = malloc(amount);
	return ptr;
	}

void *Memory::Alloc(int amount, BOOL zero) {
	Free();
	ptr = malloc(amount);
	if(ptr && zero) {
		char *p = (char *)ptr;
		for(int i = 0; i < amount; ++i)
			*p++ = 0;
		}
	return ptr;
	}

// Jaguar interface code

int controlsInit = FALSE;

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();
		}
	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			//MessageBox(NULL,_T("DXFIMP.DLL: DllMain"),_T("DXFIMP"),MB_OK);
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------

class DXFClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new DXFExport; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_AUTOCAD); }
	SClass_ID		SuperClassID() { return SCENE_EXPORT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(0xd1e,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SCENEEXPORT);  }
	};

static DXFClassDesc DXFDesc;

//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_TH_DXFEXPORTDLL); }

__declspec( dllexport ) int
LibNumberClasses() { return 1; }

__declspec( dllexport ) ClassDesc *
LibClassDesc(int i) {
	switch(i) {
		case 0: return &DXFDesc; break;
		default: return 0; break;
		}
	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

//
// .DXF export module functions follow:
//

DXFExport::DXFExport() {
	}

DXFExport::~DXFExport() {
	}

int
DXFExport::ExtCount() {
	return 1;
	}

const TCHAR *
DXFExport::Ext(int n) {		// Extensions supported for import/export modules
	switch(n) {
		case 0:
			return _T("DXF");
		}
	return _T("");
	}

const TCHAR *
DXFExport::LongDesc() {			// Long ASCII description (i.e. "Targa 2.0 Image File")
	return GetString(IDS_TH_AUTOCADDXFFILE);
	}
	
const TCHAR *
DXFExport::ShortDesc() {			// Short ASCII description (i.e. "Targa")
	return GetString(IDS_TH_AUTOCAD);
	}

const TCHAR *
DXFExport::AuthorName() {			// ASCII Author name
	return GetString(IDS_TH_TOM_HUDSON);
	}

const TCHAR *
DXFExport::CopyrightMessage() {	// ASCII Copyright message
	return GetString(IDS_TH_COPYRIGHT_YOST_GROUP);
	}

const TCHAR *
DXFExport::OtherMessage1() {		// Other message #1
	return _T("");
	}

const TCHAR *
DXFExport::OtherMessage2() {		// Other message #2
	return _T("");
	}

unsigned int
DXFExport::Version() {				// Version number * 100 (i.e. v3.01 = 301)
	return 100;
	}

void
DXFExport::ShowAbout(HWND hWnd) {			// Optional
 	}

static int deriveButtons[] = { IDC_BYOBJECT, IDC_BYMATERIAL, IDC_1LAYER };

static BOOL CALLBACK
ExportOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
	static DXFExport *exp;

	switch(message) {
		case WM_INITDIALOG:
			exp = (DXFExport *)lParam;
			CheckDlgButton( hDlg, deriveButtons[exp->layersFrom], TRUE);
			CenterWindow(hDlg,GetParent(hDlg));
			SetFocus(hDlg); // For some reason this was necessary.  DS-3/4/96
			return FALSE;
		case WM_DESTROY:
			return FALSE;
		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDOK: {
					// Unload values into DXFExport statics
					for(int i = 0; i < NUM_SOURCES; ++i) {
						if(IsDlgButtonChecked(hDlg, deriveButtons[i])) {
							exp->layersFrom = i;
							break;
							}
						}
					EndDialog(hDlg, 1);
					}
					return TRUE;
				case IDCANCEL:
					EndDialog(hDlg, 0);
					return TRUE;
			}
		}
	return FALSE;
	}

/* Fix our names (perhaps lowercase, perhaps with spaces) for DXF */

void
dxf_fix_name(TSTR &name)
	{
	int ix;
	
	name.toUpper();
	for(ix=0; ix<name.Length(); ++ix)
		{
		if(name[ix]==' '||name[ix]=='/'||name[ix]>127||name[ix]=='#')
			name[ix]='_';
		}
	if (name.Length()>31) name.Resize(31);
	}

class MySceneEntry {
	public:
		INode *node;
		Object *obj;
		MySceneEntry *next;
		MySceneEntry(INode *n, Object *o) { node = n; obj = o; next = NULL; }
	};

class MySceneEnumProc : public ITreeEnumProc {
	public:
		Interface	*i;
		MySceneEntry *head;
		MySceneEntry *tail;
		IScene		*theScene;
		int			count;
		TimeValue	time;
					MySceneEnumProc(IScene *scene, TimeValue t, Interface *i);
					~MySceneEnumProc();
		int			Count() { return count; }
		void		Append(INode *node, Object *obj);
		int			callback( INode *node );
		Box3		Bound();
		MySceneEntry *operator[](int index);
	};

MySceneEnumProc::MySceneEnumProc(IScene *scene, TimeValue t, Interface *i) {
	time = t;
	theScene = scene;
	count = 0;
	head = tail = NULL;
	this->i = i;
	theScene->EnumTree(this);
	}

MySceneEnumProc::~MySceneEnumProc() {
	while(head) {
		MySceneEntry *next = head->next;
		delete head;
		head = next;
		}
	head = tail = NULL;
	count = 0;	
	}

int MySceneEnumProc::callback(INode *node) {
	if(exportSelected && node->Selected() == FALSE)
		return TREE_CONTINUE;
	Object *obj = node->EvalWorldState(time).obj;
	if(obj->CanConvertToType(triObjectClassID)) {
		Append(node, obj);
		}
	return TREE_CONTINUE;	// Keep on enumeratin'!
	}

void MySceneEnumProc::Append(INode *node, Object *obj) {
	MySceneEntry *entry = new MySceneEntry(node, obj);
	if(tail)
		tail->next = entry;
	tail = entry;
	if(!head)
		head = entry;
	count++;	
	}

Box3 MySceneEnumProc::Bound() {
	Box3 bound;
	bound.Init();
	MySceneEntry *e = head;
	ViewExp *vpt = i->GetViewport(NULL);
	while(e) {
		Box3 bb;
		e->obj->GetWorldBoundBox(time, e->node, vpt, bb);
		bound += bb;
		e = e->next;
		}
	return bound;
	}

MySceneEntry *MySceneEnumProc::operator[](int index) {
	MySceneEntry *e = head;
	while(index) {
		e = e->next;
		index--;
		}
	return e;
	}

static int ColorNumber(int i) {
	// want to avoid 0 (by block) and 256 (by layer).
	return (i%255)+1;
	}

int
dxf_save(const TCHAR *filename, ExpInterface *ei, Interface *gi, DXFExport *exp) {

	if(showPrompts) {
		// Put up the options dialog to find out how they want the file written!
		int result = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_EXPORTOPTIONS), 
			gi->GetMAXHWnd(), ExportOptionsDlgProc, (LPARAM)exp);
		if(result <= 0)
			return 0;
		}
	else {	// Set default parameters here
		DXFExport::layersFrom = LAYERS_BY_OBJECT;
		}

	// Make sure there are nodes we're interested in!
	// Ask the scene to enumerate all its nodes so we can determine if there are any we can use
	MySceneEnumProc myScene(ei->theScene, gi->GetTime(), gi);

	// Any useful nodes?
	if(!myScene.Count()) {
		if(showPrompts)
			Alert(IDS_TH_NODATATOEXPORT);
		return 1;
		}

	GetDecSymbolFromRegistry();

	// Output the file as text
	WorkFile theFile(filename,_T("w"));
	FILE *stream = theFile.Stream();
	if(!stream) {
		if(showPrompts)
			Alert(IDS_TH_CANTCREATE);
		return -1;						// Didn't open!
		}

	// Build a bounding box for the objects we're exporting
	Box3 bbox = myScene.Bound();

	// Let's get busy!

	int ox,a,b,c;
	int ix;
	TSTR layername;
	
	/* Write header stuff */
	
	if(fprintf(stream,"0\nSECTION\n2\nHEADER\n")<0)
		{
		wrterr:
		if(showPrompts)
			Alert(IDS_TH_WRITEERROR);
		theFile.Close();
		remove(filename);
		return 0;
		}
	
	if(fprintf(stream,"9\n$ACADVER\n1\nAC1008\n")<0)
		goto wrterr;
	if(fprintf(stream,"9\n$UCSORG\n10\n0.0\n20\n0.0\n30\n0.0\n")<0)
		goto wrterr;
	if(fprintf(stream,"9\n$UCSXDIR\n10\n1.0\n20\n0.0\n30\n0.0\n")<0)
		goto wrterr;
	if(fprintf(stream,"9\n$TILEMODE\n70\n1\n")<0)
		goto wrterr;
	if(fprintf(stream,"9\n$UCSYDIR\n10\n0.0\n20\n1.0\n30\n0.0\n")<0)
		goto wrterr;
	if(Xprintf(stream,"9\n$EXTMIN\n10\n%f\n20\n%f\n30\n%f\n",bbox.pmin.x,bbox.pmin.y,bbox.pmin.z)<0)
		goto wrterr;
	if(Xprintf(stream,"9\n$EXTMAX\n10\n%f\n20\n%f\n30\n%f\n",bbox.pmax.x,bbox.pmax.y,bbox.pmax.z)<0)
		goto wrterr;
	if(fprintf(stream,"0\nENDSEC\n")<0)
		goto wrterr;
	
	/* Tables section */
	
	if(fprintf(stream,"0\nSECTION\n2\nTABLES\n")<0)
		goto wrterr;
	
	/* Continuous line type */
	if(fprintf(stream,"0\nTABLE\n2\nLTYPE\n70\n1\n0\nLTYPE\n2\nCONTINUOUS\n70\n64\n3\nSolid line\n72\n65\n73\n0\n40\n0.0\n")<0)
		goto wrterr;
	if(fprintf(stream,"0\nENDTAB\n")<0)
		goto wrterr;
	
	/* Object names for layers */
	if(fprintf(stream,"0\nTABLE\n2\nLAYER\n70\n%d\n",myScene.Count())<0)
		goto wrterr;
	switch(exp->layersFrom) {
		case LAYERS_BY_MATERIAL: {
			NameTab mtlNames;
			for(ox=0; ox<myScene.Count(); ++ox) {
				INode *n = myScene[ox]->node;
				Mtl *mtl = n->GetMtl();
				if (mtl==NULL) layername = GetString(IDS_NO_MATERIAL);
				else layername = mtl->GetName();
				if (!mtlNames.FindName(layername)) {
					mtlNames.AddName(layername);
					dxf_fix_name(layername);
					if(fprintf(stream,"0\nLAYER\n2\n%s\n70\n0\n62\n%d\n6\nCONTINUOUS\n",
						layername.data(),
						FindACIColor(n->GetWireColor())			//ColorNumber(ox)
						)<0)
						goto wrterr;
					}
				}
			}
			break;
		case LAYERS_BY_OBJECT:
			for(ox=0; ox<myScene.Count(); ++ox) {
				INode *n = myScene[ox]->node;
				layername = TSTR(n->GetName());
				dxf_fix_name(layername);
				if(fprintf(stream,"0\nLAYER\n2\n%s\n70\n0\n62\n%d\n6\nCONTINUOUS\n",
					layername.data(),FindACIColor(n->GetWireColor()))<0)
						goto wrterr;
				}
			break;
		case LAYERS_ONE_LAYER:
			if(fprintf(stream,"0\nLAYER\n2\n0\n70\n0\n62\n7\n6\nCONTINUOUS\n")<0)
				goto wrterr;
		}
	if(fprintf(stream,"0\nENDTAB\n")<0)
		goto wrterr;
	
	/* Default style */
	if(fprintf(stream,"0\nTABLE\n2\nSTYLE\n70\n1\n0\nSTYLE\n2\nSTANDARD\n70\n0\n40\n0.0\n41\n1.0\n50\n0.0\n71\n0\n42\n0.2\n3\ntxt\n4\n\n0\nENDTAB\n")<0)
		goto wrterr;
	
	/* Default View? */
	
	/* UCS */ 
	if(fprintf(stream,"0\nTABLE\n2\nUCS\n70\n0\n0\nENDTAB\n")<0)
		goto wrterr;
	
	if(fprintf(stream,"0\nENDSEC\n")<0)
		goto wrterr;
	
	/* Entities section */
	
	if(fprintf(stream,"0\nSECTION\n2\nENTITIES\n")<0)
		goto wrterr;
	for(ox=0; ox<myScene.Count(); ++ox)
		{
		INode *n = myScene[ox]->node;
		Object *obj = myScene[ox]->obj;
		TriObject *tri = (TriObject *)obj->ConvertToType(gi->GetTime(), triObjectClassID);
		Mesh &mesh = tri->GetMesh();
		Matrix3 tm = n->GetObjectTM(gi->GetTime());
		if (mesh.numFaces==0)
			continue;
		switch(exp->layersFrom) {
			case LAYERS_BY_MATERIAL:{
				Mtl *mtl = n->GetMtl();
				if (mtl==NULL) layername = GetString(IDS_NO_MATERIAL);
				else layername = mtl->GetName();
				dxf_fix_name(layername);
				}
				break;
			case LAYERS_BY_OBJECT:
				layername = TSTR(n->GetName());
				dxf_fix_name(layername);
				break;
			case LAYERS_ONE_LAYER:
				layername = TSTR(_T("0"));
				break;
			}

		int verts = mesh.getNumVerts();
		int faces = mesh.getNumFaces();
		if(fprintf(stream,"0\nPOLYLINE\n8\n%s\n66\n1\n70\n64\n71\n%u\n72\n%u\n",
								layername.data(),verts,faces)<0) {
			write_error:
			// Delete the working object, if necessary
			if(obj != (Object *)tri)
				tri->DeleteThis();
			goto wrterr;
			}
		if (fprintf(stream,"62\n%d\n",FindACIColor(n->GetWireColor()))<0) goto write_error;

		Point3 vert;
		Face face;
		for(ix=0; ix<verts; ++ix) {
			vert = mesh.verts[ix] * tm;
			if(Xprintf(stream,
				"0\nVERTEX\n8\n%s\n10\n%.6f\n20\n%.6f\n30\n%.6f\n70\n192\n",
					layername.data(),vert.x,vert.y,vert.z)<0)
				goto write_error;
			}

		BOOL isFlipped = DotProd(CrossProd(tm.GetRow(0),tm.GetRow(1)),tm.GetRow(2)) < 0.0f ? 1 : 0;

		for(ix=0; ix<faces; ++ix)
			{
			face = mesh.faces[ix];
			if (isFlipped) {
				a=face.v[0]+1;
				b=face.v[2]+1;
				c=face.v[1]+1;
				if(!(face.flags & EDGE_C))	a= -a;
				if(!(face.flags & EDGE_B))	b= -b;
				if(!(face.flags & EDGE_A))	c= -c;
				}
			else {
				a=face.v[0]+1;
				b=face.v[1]+1;
				c=face.v[2]+1;
				if(!(face.flags & EDGE_A))	a= -a;
				if(!(face.flags & EDGE_B))	b= -b;
				if(!(face.flags & EDGE_C))	c= -c;
				}
			if(fprintf(stream,
				"0\nVERTEX\n8\n%s\n10\n0\n20\n0\n30\n0\n70\n128\n71\n%d\n72\n%d\n73\n%d\n",
								layername.data(),a,b,c)<0)
				goto write_error;
			}
		if(fprintf(stream,"0\nSEQEND\n8\n%s\n",layername.data())<0)
			goto write_error;
		// Delete the working object, if necessary
		if(obj != (Object *)tri)
			tri->DeleteThis();
		}
	
	if(fprintf(stream,"0\nENDSEC\n0\nEOF\n")<0)
		goto wrterr;
	
	if(theFile.Close())
		goto wrterr;

	return 1;	
	}

int
DXFExport::DoExport(const TCHAR *filename,ExpInterface *ei,Interface *gi, BOOL suppressPrompts, DWORD options) {
	// Set a global prompt display switch
	showPrompts = suppressPrompts ? FALSE : TRUE;
	exportSelected = (options & SCENE_EXPORT_SELECTED) ? TRUE : FALSE;

	int status;
		
	status=dxf_save(filename, ei, gi, this);

	if(status == 0)
		return 1;		// Dialog cancelled
	if(status > 0)	{
#ifdef DBGDXF
DebugPrint("DXF status OK!\n");
#endif
		}
#ifdef DBGDXF
	else
	if(status < 0)
		DebugPrint("Error somewhere in DXF!\n");
#endif

	return(status);
	}

BOOL DXFExport::SupportsOptions(int ext, DWORD options) {
	assert(ext == 0);	// We only support one extension
	return(options == SCENE_EXPORT_SELECTED) ? TRUE : FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\kfio.h ===
#ifndef __kfio__
#define __kfio__


#define DOGIO
#define KFVERSION 5

/* kfio.h: defs for saving and loading .KFB files */

#define UNREC_OBJECT_NAME 0xff00
#define BAD_PARENT_REF 0xff01
#define BAD_OBJ_NAME 0xff02

#define NO_PARENT 0xFFFF

#define M3DMAGIC 0x4D4D	
#define M3D_VERSION 0x0002

#define KFDATA  0xB000
#define KFHDR 0xB00A
#define AMBIENT_NODE_TAG  0xB001
#define OBJECT_NODE_TAG  0xB002
#define CAMERA_NODE_TAG  0xB003
#define TARGET_NODE_TAG  0xB004	 /* for cameras only */
#define LIGHT_NODE_TAG  0xB005
#define L_TARGET_NODE_TAG  0xB006	 /* for lights only */
#define SPOTLIGHT_NODE_TAG  0xB007
#define KFSEG  0xB008
#define KFCURTIME  0xB009
#define NODE_HDR  0xB010
#define INSTANCE_NAME 0xB011
#define PRESCALE 0xB012
#define PIVOT 0xB013
#define BOUNDBOX  0xB014
#define MORPH_SMOOTH  0xB015
#define POS_TRACK_TAG 0xB020
#define ROT_TRACK_TAG 0xB021
#define SCL_TRACK_TAG 0xB022
#define FOV_TRACK_TAG 0xB023
#define ROLL_TRACK_TAG 0xB024
#define COL_TRACK_TAG 0xB025
#define MORPH_TRACK_TAG 0xB026
#define HOT_TRACK_TAG 0xB027
#define FALL_TRACK_TAG 0xB028
#define HIDE_TRACK_TAG 0xB029
#define NODE_ID 0xB030

#define W_TENS  1
#define W_CONT  (1<<1)
#define W_BIAS  (1<<2)
#define W_EASETO  (1<<3)
#define W_EASEFROM  (1<<4)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\loadmli.cpp ===
/*******************************************************************
 *
 *    DESCRIPTION: LOADMLI.CPP: 3dsr4 material loader
 *
 *    AUTHOR:
 *
 *    HISTORY:    
 *
 *******************************************************************/


#include "Max.h"
#include <stdio.h>
#include <direct.h>
#include <commdlg.h>
#include "splshape.h"
#include "3dsires.h"
#include "imtl.h"
#include "dummy.h"
#include "3dsimp.h"
#include "mtldef.h"
#include "gamma.h"

#include "dummy.h"
#define xxDBGLDMLI

int dbgldmli=0;

SMtl *loadmtl,inmtl;

extern UWORD file_in_degamtab[];


static void MtlError() {
	// handy place to put a breakpoint
	}

int put_lib_mtl(SMtl *loadmtl) {
	return 1;
	}


//===========================================================
int load_app_data(FILE *stream,void **pdata, int size) {
	ULONG *plong;
	if (*pdata!=NULL) 
		XMFreeAndZero(pdata);
	*pdata = (void *)XMAlloc(size+4);
	if (*pdata==NULL) {
		MtlError();
		return(0);	
		}		
	plong = (ULONG *)(*pdata);
	plong[0] = size;
	RDERR((void *)&plong[1],size);
	return(1);
	}

extern int bad_reason,antiquated,lastchunk;
int just_name=0,strlimit;

/* Percentage work areas */

short ipct;
float fpct;

/* Incoming color work areas */

Color_24 C24,LC24;
Color_f Cf,LCf;

/* Error codes */

#define INVALID_FILE 1
#define PARTIAL_READ 2
#define EXCEEDS_SETUP 3


int
get_mapdata_chunk(FILE *stream, int tag, MapData *md) {
	switch (tag) {
		case MAT_MAPNAME:
			strlimit=13;
			if (!get_mtlchunk(stream,md->name)) {
				return(0);
				}
#ifdef DBGLDMLI
		if (dbgldmli)
				printf("  get_map : mapname: %s \n",md->name);
#endif
			return(1);
		case MAT_MAP_TILING: 
			return(get_mtlchunk(stream,&md->p.tex.texflags));
		case MAT_MAP_TILINGOLD: 
			if (!get_mtlchunk(stream,&md->p.tex.texflags)) {
				return(0);
				}
			if (md->p.tex.texflags&TEX_DECAL)
				md->p.tex.texflags|=TEX_NOWRAP;				
			return(1);
		case MAT_MAP_TEXBLUR: 
			return(get_mtlchunk(stream,&md->p.tex.texblur));
		case MAT_MAP_TEXBLUR_OLD: 
			return(get_mtlchunk(stream,&md->p.tex.texblur));
		case MAT_MAP_USCALE: 
			return(get_mtlchunk(stream,&md->p.tex.uscale));
		case MAT_MAP_VSCALE: 
			return(get_mtlchunk(stream,&md->p.tex.vscale));
		case MAT_MAP_UOFFSET: 
			return(get_mtlchunk(stream,&md->p.tex.uoffset));
		case MAT_MAP_VOFFSET: 
			return(get_mtlchunk(stream,&md->p.tex.voffset));
		case MAT_MAP_ANG: 
			return(get_mtlchunk(stream,&md->p.tex));
		case MAT_MAP_COL1: 
			return(get_mtlchunk(stream,&md->p.tex.col1));
		case MAT_MAP_COL2: 
			return(get_mtlchunk(stream,&md->p.tex.col2));
		case MAT_MAP_RCOL: 
			return(get_mtlchunk(stream,&md->p.tex.rcol));
		case MAT_MAP_GCOL: 
			return(get_mtlchunk(stream,&md->p.tex.gcol));
		case MAT_MAP_BCOL: 
			return(get_mtlchunk(stream,&md->p.tex.bcol));
		default:
			return(skip_chunk(stream));
		}
	}

int get_map(FILE *stream, int n, int size) {
	uint nexttag;
	Chunk_hdr nxt;
	Mapping *m = loadmtl->map[n];
#ifdef DBGLDMLI
	if (dbgldmli)
		printf(" GET_MAP: n = %d\n",n);
#endif
	if (m==NULL) {
		m = NewMapping(n,0);
		if (m==NULL) {
			MtlError();
			return(0);
			}
		loadmtl->map[n] = m;
		}
	m->use = 1;
	while(size) {
		if(get_next_chunk(stream,&nxt)==0)
			return(0);
		nexttag = nxt.tag;
		switch(nexttag) {
			case INT_PERCENTAGE:
			case FLOAT_PERCENTAGE:
				if(get_mtlchunk(stream,NULL)==0)
					return(0);
				m->amt.pct = ipct; 
				if (n==Nbump) 
					m->amt.pct = (ipct<=20)?4*ipct:100;  /* for old files */
			
#ifdef DBGLDMLI
				if (dbgldmli)
					printf("  get_map %d : pct: %d \n",n,ipct);
#endif
				break;
			case MAT_BUMP_PERCENT:
				if(get_mtlchunk(stream,NULL)==0)
					return(0);
				m->amt.pct = ipct; /* for version 3+ files */
				break;
			default:
				if (!get_mapdata_chunk(stream,nexttag,&m->map)) {
#ifdef DBGLDMLI
					if (dbgldmli)
						printf(" Error in get_mapdata_chunk, nexttag = %X\n",nexttag);
#endif
					MtlError();
					return(0);
					}
				break;
			}
		size-=nxt.size;
		}

#ifdef DBGLDMLI
	if (dbgldmli)
		printf(" EXIT GET_MAP: n = %d\n",n);
#endif
	return(1);
	}

int get_mask(FILE *stream, int n, int size) {
	uint nexttag;
	Chunk_hdr nxt;
	Mapping *m = loadmtl->map[n];
	if (m==NULL) {
		m = NewMapping(n,0);
		if (m==NULL) {
			MtlError();
			return(0);
			}
		loadmtl->map[n] = m;
		}
	m->use = 1;
	while(size) {
		if(get_next_chunk(stream,&nxt)==0)
			return(0);
		nexttag = nxt.tag;
#ifdef DBGLDMLI
		if (dbgldmli)
			printf("  get_MASK loop: nexttag = %X \n",nexttag);
#endif
		if (!get_mapdata_chunk(stream,nexttag,&m->mask)) return(0);

		size-=nxt.size;
		}
	return(1);
	}

int get_sxp_data(FILE *stream, int n, int size, int isMask) {
	ULONG **pp,*ptr;
	Mapping *m = loadmtl->map[n];
#ifdef DBGLDMLI
	if (dbgldmli)
		printf("GET_SXP_DATA: n=%d, size = %d, isMask = %d, m=%X\n",
			n,size,isMask,m);
#endif
	if (size==0) return(1);
	if (m==NULL) {
		m = NewMapping(n,0);
		if (m==NULL) {
			MtlError();
			return(0);
			}
		loadmtl->map[n] = m;
		}
	if (isMask)
		pp = (ULONG **)&m->mask.p.tex.sxp_data;
	else 
		pp = (ULONG **)&m->map.p.tex.sxp_data;
	if (*pp!=NULL) XMFreeAndZero((void **)pp);
	ptr = (ULONG *)XMAlloc(size+4);
	if (ptr==NULL)  {
		MtlError();
		return(0);   
		}
	ptr[0] = size;

#ifdef DBGLDMLI
	if (dbgldmli)
		printf("  sxp_data: addr = %X,  size = %X\n", ptr, ptr[0]);
#endif
	RDERR(&ptr[1],size);
	*pp = ptr;
	return(1);
	}       

#define GET_SXP(num,type) if (!get_sxp_data(stream,num,chunk.size,type)) return(0); chunk.size=0;      
#define GET_MAP(num) if (!get_map(stream,num,chunk.size)) return(0); chunk.size=0;      
#define GET_MASK(num) if (!get_mask(stream,num,chunk.size)) return(0); chunk.size=0;      

int
get_mtlchunk(FILE *stream,void *data)
	{
	/* Grab a chunk from the file and process all its subsets */
	Chunk_hdr chunk;
	Chunk_hdr nxt;
	uint thistag,nexttag;
	char *string;
	short *pshort;
	
	RDERR(&chunk,6);
	
	thistag=chunk.tag;
	
#ifdef DBGLDMLI
	if (dbgldmli)
		printf("          get_mtlchunk: tag=%X, size=%d \n",thistag,chunk.size);
#endif
	
	/* Update chunk size to account for header */
	
	chunk.size-=6L;
	
	/* Find chunk type and go process it */
	
	switch(thistag)
		{
		case MLIBMAGIC:
			while(chunk.size)
				{
				if(get_next_chunk(stream,&nxt)==0)
					return(0);
				nexttag=nxt.tag;
				switch(nexttag)
					{
					case MAT_ENTRY:
						loadmtl= &inmtl;
						/* Zero out data structure first */
						init_mtl_struct(loadmtl);
	
						if(get_mtlchunk(stream,NULL)==0)
							return(0);
						if(put_lib_mtl(loadmtl)==0)
							return(0);
						break;     
					default:
						if(skip_chunk(stream)==0){
							MtlError();
							return(0);
							}
						break;
					}
				chunk.size-=nxt.size;
				}
			break;
		case MAT_ENTRY:
		case MATMAGIC:
			while(chunk.size)
				{
				if(get_next_chunk(stream,&nxt)==0)
					return(0);
				nexttag=nxt.tag;
				switch(nexttag)
					{
					case MAT_NAME:
						strlimit=17;
						if(get_mtlchunk(stream,loadmtl->name)==0)
							return(0);
#ifdef DBGLDMLI
						if (dbgldmli)
							printf(" **** Loading material : %s \n", loadmtl->name);
#endif
						if(just_name) /* If all we need is the name, return */
							return(1);
						break;     
					case MAT_AMBIENT:
						if(get_mtlchunk(stream,&loadmtl->amb)==0)
							return(0);
						break;     
					case MAT_DIFFUSE:
						if(get_mtlchunk(stream,&loadmtl->diff)==0)
							return(0);
						break;     
					case MAT_SPECULAR:
						if(get_mtlchunk(stream,&loadmtl->spec)==0)
							return(0);
						break;     
					case MAT_ACUBIC:
						{
						Mapping *m = loadmtl->map[Nrefl];
						if (m==NULL) goto	skip_mtl_chunk;
						if (get_mtlchunk(stream,&m->map.p.ref.acb)==0)
							return(0);
						}
						break;     
	
					case MAT_SXP_TEXT_DATA:       
					case MAT_SXP_TEXT2_DATA: 
					case MAT_SXP_OPAC_DATA:  
					case MAT_SXP_BUMP_DATA:  
					case MAT_SXP_SPEC_DATA:  
					case MAT_SXP_SELFI_DATA: 
					case MAT_SXP_SHIN_DATA:  
				
					case MAT_SXP_TEXT_MASKDATA:  
					case MAT_SXP_TEXT2_MASKDATA: 
					case MAT_SXP_OPAC_MASKDATA:  
					case MAT_SXP_BUMP_MASKDATA:  
					case MAT_SXP_SPEC_MASKDATA:  
					case MAT_SXP_SELFI_MASKDATA: 
					case MAT_SXP_SHIN_MASKDATA:  
					case MAT_SXP_REFL_MASKDATA:  
						if(get_mtlchunk(stream,NULL)==0)
							return(0);
						break;
				
					case MAT_TEXMAP:   
					case MAT_TEX2MAP:  
					case MAT_OPACMAP:  
					case MAT_BUMPMAP:  
					case MAT_SPECMAP:  
					case MAT_SHINMAP:  
					case MAT_SELFIMAP: 
					case MAT_REFLMAP:  
	
					case MAT_TEXMASK:   
					case MAT_TEX2MASK:  
					case MAT_OPACMASK:  
					case MAT_BUMPMASK:  
					case MAT_SPECMASK:  
					case MAT_SHINMASK:  
					case MAT_SELFIMASK: 
					case MAT_REFLMASK:  
						if(get_mtlchunk(stream,NULL)==0)
							return(0);
						break;
	
					case MAT_SHININESS:
					case MAT_SHIN2PCT:
					case MAT_TRANSPARENCY:
					case MAT_XPFALL:
					case MAT_REFBLUR:
					case MAT_SELF_ILPCT:
					case MAT_SHADING:
					case MAT_TWO_SIDE:
					case MAT_SUPERSMP:
					case MAT_SELF_ILLUM:
					case MAT_DECAL:
					case MAT_ADDITIVE:
					case MAT_WIRE:
					case MAT_FACEMAP:
					case MAT_XPFALLIN:
					case MAT_PHONGSOFT:
					case MAT_WIREABS:
					case MAT_USE_XPFALL:
					case MAT_USE_REFBLUR:
					case MAT_WIRESIZE:
						if(get_mtlchunk(stream,NULL)==0)
							return(0);
						break;
					case APP_DATA:
						if(get_mtlchunk(stream,&loadmtl->appdata)==0)
							return(0);
						break;
					default:
						skip_mtl_chunk:
						if(skip_chunk(stream)==0) {
							MtlError();
							return(0);
							}
						break;
					}
				chunk.size-=nxt.size;
				}
						
#ifdef DBGLDMLI
			if (dbgldmli)
					printf("  finished loading mtl %s, flags = %X\n",
						loadmtl->name, loadmtl->flags);
#endif
			/* convert old data formats to new */
			if (loadmtl->shading==REND_WIRE) {
				loadmtl->shading = REND_FLAT;
				loadmtl->flags |= MF_WIRE;
				loadmtl->flags |= MF_TWOSIDE;
				loadmtl->shininess=0;
				loadmtl->shin2pct=0;
				loadmtl->transparency=0;
				}

			if (loadmtl->xpfall<0.0) {
				loadmtl->flags|= MF_XPFALLIN;
				loadmtl->xpfall = -loadmtl->xpfall;
				}
			if (loadmtl->flags&MF_DECAL) {
				set_mtl_decal(loadmtl);
				loadmtl->flags &= ~MF_DECAL;
				}
			if (loadmtl->shin2pct==255) {
				float shin = (((float)(loadmtl->shininess))/100.0f);
				float atten = (float)sin(1.5707*shin);
				loadmtl->shin2pct = (int)((atten)*100.0f+0.5f);
				}

			break;

		case MAT_SXP_TEXT_DATA:  GET_SXP(Ntex,0); break;     
		case MAT_SXP_TEXT2_DATA: GET_SXP(Ntex2,0);  break;     
		case MAT_SXP_OPAC_DATA:  GET_SXP(Nopac,0);  break;
		case MAT_SXP_BUMP_DATA:  GET_SXP(Nbump,0);  break; 
		case MAT_SXP_SPEC_DATA:  GET_SXP(Nspec,0);  break;
		case MAT_SXP_SELFI_DATA: GET_SXP(Nselfi,0);  break;
		case MAT_SXP_SHIN_DATA:  GET_SXP(Nshin,0);  break;
	
		case MAT_SXP_TEXT_MASKDATA:  GET_SXP(Ntex,1);  break;     
		case MAT_SXP_TEXT2_MASKDATA: GET_SXP(Ntex2,1);  break;     
		case MAT_SXP_OPAC_MASKDATA:  GET_SXP(Nopac,1);  break;
		case MAT_SXP_BUMP_MASKDATA:  GET_SXP(Nbump,1);  break; 
		case MAT_SXP_SPEC_MASKDATA:  GET_SXP(Nspec,1);  break;
		case MAT_SXP_SELFI_MASKDATA: GET_SXP(Nselfi,1);  break;
		case MAT_SXP_SHIN_MASKDATA:  GET_SXP(Nshin,1);  break;
		case MAT_SXP_REFL_MASKDATA:  GET_SXP(Nrefl,1);  break;

		case MAT_TEXMAP:   GET_MAP(Ntex);  break;     
		case MAT_TEX2MAP:  GET_MAP(Ntex2);  break;     
		case MAT_OPACMAP:  GET_MAP(Nopac);  break;     
		case MAT_BUMPMAP:  GET_MAP(Nbump);  break;     
		case MAT_SPECMAP:  GET_MAP(Nspec);  break;     
		case MAT_SHINMAP:  GET_MAP(Nshin);  break;     
		case MAT_SELFIMAP: GET_MAP(Nselfi);  break;     
		case MAT_REFLMAP:  GET_MAP(Nrefl);  break;     

		case MAT_TEXMASK:   GET_MASK(Ntex);  break;     
		case MAT_TEX2MASK:  GET_MASK(Ntex2);  break;     
		case MAT_OPACMASK:  GET_MASK(Nopac);  break;     
		case MAT_BUMPMASK:  GET_MASK(Nbump);  break;     
		case MAT_SPECMASK:  GET_MASK(Nspec);  break;     
		case MAT_SHINMASK:  GET_MASK(Nshin);  break;     
		case MAT_SELFIMASK: GET_MASK(Nselfi);  break;     
		case MAT_REFLMASK:  GET_MASK(Nrefl);  break;     

		case MAT_AMBIENT:
		case MAT_DIFFUSE:
		case MAT_SPECULAR:
			{
			int got_lin,got_gam;
			got_lin = got_gam = 0;
			while(chunk.size)
				{
				if(get_next_chunk(stream,&nxt)==0)
					return(0);
				nexttag=nxt.tag;
				switch(nexttag)	{
					case COLOR_F:
					case COLOR_24:
						got_gam = 1;
						if(get_mtlchunk(stream,NULL)==0) return(0);
						break;     
					case LIN_COLOR_24:
						got_lin = 1;
						if(get_mtlchunk(stream,NULL)==0)	return(0);
						break;     
					default:
						if(skip_chunk(stream)==0) {
							MtlError();
							return(0);
							}
						break;
					}
				chunk.size-=nxt.size;
				}
			if (got_lin) {
				memcpy((char *)data,(char *)&LC24,sizeof(Color_24));
				}
			else { 
				if (!got_gam) {
					MtlError();
					return(0);
					}
				if (gammaMgr.enable) {
					Color_24 gc;
					gc.r = gammaMgr.file_in_degamtab[C24.r]>>8;
					gc.g = gammaMgr.file_in_degamtab[C24.g]>>8;
					gc.b = gammaMgr.file_in_degamtab[C24.b]>>8;
					memcpy((char *)data,(char *)&gc,sizeof(Color_24));
					}
				else { 
					memcpy((char *)data,(char *)&C24,sizeof(Color_24));
					}
				}
			}
			break;
		case MAT_SELF_ILLUM:	
				loadmtl->flags |= MF_SELF;	  
				loadmtl->selfipct = 100;				
				break;
		case MAT_TWO_SIDE:	loadmtl->flags |= MF_TWOSIDE;	break;
		case MAT_SUPERSMP:	loadmtl->flags |= MF_SUPERSMP;	break;
		case MAT_ADDITIVE:	loadmtl->flags |= MF_ADDITIVE;break;
		case MAT_DECAL:   loadmtl->flags |= MF_DECAL;  	break;
		case MAT_WIRE:	loadmtl->flags |= MF_WIRE; break;
		case MAT_FACEMAP:	loadmtl->flags |= MF_FACEMAP; break;
		case MAT_XPFALLIN:	loadmtl->flags |= MF_XPFALLIN; break;
		case MAT_PHONGSOFT:	loadmtl->flags |= MF_PHONGSOFT; break;
		case MAT_WIREABS:	loadmtl->flags |= MF_WIREABS; break;
		case MAT_USE_XPFALL:	loadmtl->use |= MATUSE_XPFALL; break;
		case MAT_USE_REFBLUR:	loadmtl->use |= MATUSE_REFBLUR;	break;

		case MAT_SHININESS:
			pshort = &loadmtl->shininess;
			goto get_int_float_chunk;
	
		case MAT_SHIN2PCT:
			pshort = &loadmtl->shin2pct;
			goto get_int_float_chunk;
	
		case MAT_TRANSPARENCY:
			pshort = &loadmtl->transparency;
			goto get_int_float_chunk;
	
		case MAT_XPFALL:
			pshort = &loadmtl->xpfall;
			goto get_int_float_chunk;
	
		case MAT_REFBLUR:
			pshort = &loadmtl->refblur;
			goto get_int_float_chunk;
	
		case MAT_SELF_ILPCT:
			pshort = &loadmtl->selfipct;
			goto get_int_float_chunk;
	
			get_int_float_chunk:
			while(chunk.size)
				{
				if(get_next_chunk(stream,&nxt)==0)
					return(0);
				nexttag=nxt.tag;
				switch(nexttag)
					{
					case INT_PERCENTAGE:
					case FLOAT_PERCENTAGE:
						if(get_mtlchunk(stream,NULL)==0)
							return(0);
#ifdef DBGLDMLI
						if (dbgldmli)
							printf(" get_int_float_chunk: val = %d \n",ipct);
#endif 

						*pshort=ipct;
						break;
					default:
						if(skip_chunk(stream)==0) {
							MtlError();
							return(0);
							}
						break;
					}
				chunk.size-=nxt.size;
				}
			break;
		case MAT_SHADING:
			RDERR(&loadmtl->shading,2);
			chunk.size-=2L;
			goto skiprest;
		case MAT_MAP_TILING: 
		case MAT_MAP_TILINGOLD: 
			RDERR(data,2);
			chunk.size-=2L;
			goto skiprest;
		case MAT_MAP_TEXBLUR_OLD: {
			float foo;
			RDERR(&foo,sizeof(float));
			foo = (foo-1.0f)/7.0f;
			if (foo<0.0f) foo = 0.0f;
			if (foo>1.0f) foo = 1.0f;
			memmove(data,&foo,4);
			chunk.size -=4L;
			}
			goto skiprest;
		case MAT_MAP_TEXBLUR: 
		case MAT_MAP_USCALE: 
		case MAT_MAP_VSCALE: 
		case MAT_MAP_UOFFSET: 
		case MAT_MAP_VOFFSET: 
			RDERR(data,sizeof(float));
			chunk.size -=4L;
			goto skiprest;
		case MAT_MAP_ANG: {
			MapParams *mp = (MapParams *)data;
			float ang;
			RDERR(&ang,4);
			ang = DegToRad(ang);
			mp->ang_sin = (float)sin(ang);
			mp->ang_cos = (float)cos(ang);
			chunk.size -=4L;
			goto skiprest;
			}

		case MAT_MAP_COL1: 
		case MAT_MAP_COL2: 
		case MAT_MAP_RCOL: 
		case MAT_MAP_GCOL: 
		case MAT_MAP_BCOL: 
			{
			Color_24 *pcol = (Color_24 *)data;
			RDERR(pcol,3);
        	}
			chunk.size-=3L;
			goto skiprest;
		case COLOR_F:
			RDERR(&Cf,12);
			chunk.size-=12L;
			C24.r=(uchar)(Cf.r*255.0f);
			C24.g=(uchar)(Cf.g*255.0f);
			C24.b=(uchar)(Cf.b*255.0f);
			goto skiprest;
		case COLOR_24:
			RDERR(&C24,3);
			Cf.r=(float)C24.r/255.0f;
			Cf.g=(float)C24.g/255.0f;
			Cf.b=(float)C24.b/255.0f;
			chunk.size-=3L;
			goto skiprest;
		case LIN_COLOR_24:
			RDERR(&LC24,3);
			LCf.r=(float)LC24.r/255.0f;
			LCf.g=(float)LC24.g/255.0f;
			LCf.b=(float)LC24.b/255.0f;
			chunk.size-=3L;
			goto skiprest;
		case MAT_NAME:  /* Simple strings */
		case MAT_MAPNAME:
			string=(char *)data;
			if(read_string(string,stream,strlimit)==0) {
				MtlError();
				return(0);
				}
			chunk.size-=(long)(strlen(string)+1);
			goto skiprest;


		case MAT_ACUBIC: 
			{
			AutoCubicParams *ac = (AutoCubicParams *)data;
			RDERR(&ac->shade,1);
			RDERR(&ac->aalevel,1);
			RDERR(&ac->flags,2);
			RDERR(&ac->size,4);
			RDERR(&ac->nth,4);
			chunk.size-=12;
			}
			goto skiprest;
		case INT_PERCENTAGE:
			RDERR(&ipct,2);
			fpct=(float)ipct/100.0f;
			chunk.size-=2L;
			goto skiprest;
		case MAT_WIRESIZE:
			RDERR(&loadmtl->wiresize,4);
			chunk.size-=4L;
			goto skiprest;
		case MAT_BUMP_PERCENT:
			RDERR(&ipct,2);
			fpct=(float)ipct/100.0f;
			chunk.size-=2L;
			goto skiprest;
		case FLOAT_PERCENTAGE:
			RDERR(&fpct,4);
			ipct=(short)(fpct*100.0f);
			chunk.size-=4;
			goto skiprest;
		case APP_DATA:
//			if (!load_app_data(stream, (void **)data, chunk.size))
//				return(0);
//			chunk.size = 0;
			goto skiprest;
			
	/* The following routine is used to dump any sub-chunks */
	/* in the current chunk.    */
			skiprest:
			while(chunk.size)
				{
				if(get_next_chunk(stream,&nxt)==0)
					return(0);
				if(skip_chunk(stream)==0) {
					MtlError();
					return(0);
					}
				chunk.size-=nxt.size;
				}  
			break;
		}
	//done:
	return(1);
	}

void end_loadmli(){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\mtldef.h ===
/*******************************************************************
 *
 *    DESCRIPTION:  3DStudio R4 Material definitions
 *
 *    AUTHOR:
 *
 *    HISTORY:    
 *
 *******************************************************************/

#ifndef __MTLDEF__H
#define __MTLDEF__H

#define REND_WIRE 0
#define REND_FLAT 1
#define REND_GOURAUD 2
#define REND_PHONG 3
#define REND_METAL 4

/* Material flags field bit definitions	*/
#define MF_TWOSIDE  	(1<<0)	/* Material seen from both sides	*/
#define MF_SELF 	  	(1<<1)	/* Material self-illuminated		*/
#define MF_DECAL 		(1<<2)	/* Material maps act as decals (transparent color)	*/
#define MF_ADDITIVE 	(1<<3)	/* Material uses additive transparency	*/
#define MF_WIRE	 	(1<<4)	/* Material renders as wire frame */
#define MF_NEEDUV 	(1<<5)	/* Material has some UV type maps */
#define MF_NEED3D    (1<<6)	/* Material needs 3D coords for SXP */
#define MF_XPFALLIN  (1<<7)   /* Transparency fall-off to inside	*/
#define MF_MATTE  	(1<<8)	/* Material used as a matte		*/
#define MF_CUBICMAP 	(1<<9)	/* Reflection map is cubic		*/
#define MF_XPFALL   	(1<<10)  /* Do Transparency fall-off		*/
#define MF_SUPERSMP	(1<<11)	/* Super sample material */
#define MF_FACEMAP	(1<<12)	/* Face-texture-coords */
#define MF_PHONGSOFT	(1<<13)	/* Soften phong hilites */
#define MF_WIREABS	(1<<14)	/* Absolute wire size */
#define MF_REFBLUR   (1<<15)	/* blurred reflection map */
/* for clearing temporary flags */
#define MF_CLEAR_TEMPFLAGS ~(MF_NEEDUV|MF_NEED3D|MF_REFBLUR|MF_CUBICMAP)

typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;


typedef struct {
	uchar shade;		/* shading level for auto-cubic */
	uchar aalevel;		/* anti-alias level for auto-cubic */
	ushort flags;		/* auto cubic flags */
	int size;			/* bitmap size for auto-cubic */
	int nth;				/* do nth frame for auto-cubic */
	} AutoCubicParams;


#define CM_UP 0
#define CM_DOWN 1
#define CM_LEFT 2
#define CM_RIGHT 3
#define CM_FRONT 4
#define CM_BACK 5
#define CUBMAP_READY 1

typedef struct cubmap	{
    //	Bitmap *mapptr[6];
	char mapname[6][13];
	short flags;
	short objnum;	/* for auto-cubic= point-of-view object: -1 for user defined*/
	short mtlobj; /* object referred to to find which face is mapped (morphing)*/
	struct cubmap *next;
	// Bitmap *blurmap;  
	int x,y;  /* location for mirrors */
	} Cubmap;

/* Auto-cubic flags */
#define AC_ON  1	  /* if ON this is an auto-cubic mapped material */
#define AC_SHADOW  (1<<1)
#define AC_2SIDE  (1<<2)
#define AC_FIRSTONLY (1<<3)
#define AC_MIRROR (1<<4)

/* rmtl.use flags */
#define MATUSE_XPFALL (1<<0)
#define MATUSE_REFBLUR (1<<1)

/* TextureParam.texflags */
#define TEX_DECAL (1)
#define TEX_MIRROR (1<<1)
#define TEX_UNUSED1 (1<<2)
#define TEX_INVERT (1<<3)
#define TEX_NOWRAP (1<<4)
#define TEX_SAT (1<<5)	 /* summed area table */
#define TEX_ALPHA_SOURCE (1<<6) /* use ALPHA instead of RGB of map */
#define TEX_TINT (1<<7)         /* tint for color */
#define TEX_DONT_USE_ALPHA (1<<8)    /* don't use map alpha */
#define TEX_RGB_TINT (1<<9)    /* Do RGB color transform */

typedef struct sxpent {
	char name[13];
	ULONG handle;
	void *pdata;
	struct sxpent *next;
	} SXPentry;

#define NMAPTYPES 8
#define Ntex 0
#define Ntex2 1
#define Nopac 2
#define Nbump 3
#define Nspec 4
#define Nshin 5
#define Nselfi 6
#define Nrefl 7

#define USE_tex  (1<<Ntex)
#define USE_tex2  (1<<Ntex2)
#define USE_opac  (1<<Nopac)
#define USE_bump  (1<<Nbump)
#define USE_spec  (1<<Nspec)
#define USE_shin  (1<<Nshin)
#define USE_selfi  (1<<Nselfi)
#define USE_refl  (1<<Nrefl)


#define MAP_TYPE_UV 1
#define MAP_TYPE_SXP 2

typedef struct {
	uchar type; /* MAP_TYPE_UV, MAP_TYPE_SXP */
	ushort texflags;
	void *sxp_data;
	Bitmap *bm;
	float texblur;		/* texture blur  */
	float uscale,vscale;
	float uoffset,voffset;
	float ang_sin,ang_cos;
	Color_24 col1,col2;  /* tinting colors */
	Color_24 rcol,gcol,bcol;  /* RGB tinting colors */
	} MapParams;

typedef struct {
	AutoCubicParams acb;  /* auto-cubic params */
	Bitmap *bm;
	Bitmap *blurbm;
	} RMapParams;


typedef struct {
	uchar ok; 
	uchar kind;		/* Texture(0) or Reflection map (1)*/
	char name[13];
	union {
		MapParams tex;	  /* kind == 0 */
		RMapParams ref;  /* kind == 1 */
		} p;
	} MapData;

typedef struct {
	uchar use;
	union { float f; int pct;} amt;
	MapData map;
	MapData mask;
	} Mapping;

struct SMtl {
	char name[17];		 	/* Material's 16-char name		*/
	Color_24 amb;		 	/* 0-255 triplets			*/
	Color_24 diff;			 /* 0-255 triplets			*/
	Color_24 spec;		 	/* 0-255 triplets			*/
	short transparency;	/* 0-100	*/
	short shading;		 	/* 0=WIRE 1=FLAT 2=GOURAUD 3=PHONG 4=METAL	*/
	ulong flags;		 	/* Material flags	*/
	ushort use;   			/* Use  flags */

	/* Effect percent sliders */
	short shininess;	 	/* 0-100	   */
	short shin2pct;		/* 0-100    */
	short shin3pct;		/* 0-100    */
	short xpfall;			/* 0-100   	*/
	short refblur;			/* 0-100   	*/
	short selfipct;	  	/* 0-100    */
	float wiresize;   /* size of wire frame */

	Mapping *map[8];
	void *appdata;
	};

int get_mtlchunk(FILE *stream,void *data);
int dump_mtlchunk(ushort tag,FILE *stream,void *data);
void init_mtl_struct(SMtl *mtl);

extern SMtl *loadmtl,inmtl;

/* Material library in-memory list */
struct Mliblist	{
	SMtl material;
	Mliblist *next;
	};

/* Current mesh's in-memory list */
struct Mmtllist	{
	SMtl material;
	Mmtllist *next;
	short flags;
	};

extern SMtl *savemtl;
void FreeMatRefs(SMtl *m);
void *XMAlloc(int size);
void *XMAllocZero(int size);
void XMFree(void *p);
void XMFreeAndZero(void **p);
int TexBlurToPct(float tb);
float PctToTexBlur(int p);
void ResetMapData(MapData *md, int n, int ismask);
void InitMappingValues(Mapping *m, int n, int isRmtl);
void FreeMapDataRefs(MapData *md);
void FreeMatRefs(SMtl *m);
void ResetMapping(Mapping *m, int n, int isRmtl);
Mapping *NewMapping(int n,int isRmtl);
void init_mtl_struct(SMtl *mtl);
void set_mtl_decal(SMtl *mtl);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\objimp.h ===
/**********************************************************************
 *<
	FILE: objimp.h

	DESCRIPTION:  Wavefront .OBJ file import module header file

	CREATED BY: Don Brittain & Tom Hudson

	HISTORY: created 30 December 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

class OBJImport : public SceneImport {
public:
					OBJImport();
					~OBJImport();
	int				ExtCount();					// Number of extensions supported
	const TCHAR *	Ext(int n);					// Extension #n (i.e. "3DS")
	const TCHAR *	LongDesc();					// Long ASCII description (i.e. "Autodesk 3D Studio File")
	const TCHAR *	ShortDesc();				// Short ASCII description (i.e. "3D Studio")
	const TCHAR *	AuthorName();				// ASCII Author name
	const TCHAR *	CopyrightMessage();			// ASCII Copyright message
	const TCHAR *	OtherMessage1();			// Other message #1
	const TCHAR *	OtherMessage2();			// Other message #2
	unsigned int	Version();					// Version number * 100 (i.e. v3.01 = 301)
	void			ShowAbout(HWND hWnd);		// Show DLL's "About..." box
	int				DoImport(const TCHAR *name,ImpInterface *i,Interface *gi, BOOL suppressPrompts=FALSE);	// Import file
	};


// Handy file class

class WorkFile {
private:
	FILE *stream;
public:
					WorkFile(const TCHAR *filename,const TCHAR *mode) { stream = _tfopen(filename,mode); };
					~WorkFile() { if(stream) fclose(stream); stream = NULL; };
	FILE *			Stream() { return stream; };
	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\ofile.h ===
/* 3D object file defines */

#ifndef _OFILE_H_DEFINED

/* Error types for file loads */

#define INVALID_FILE 1
#define PARTIAL_READ 2
#define EXCEEDS_SETUP 3

#define MMAGIC 0x3D3D	/* Mesh magic */
#define SMAGIC 0x2D2D	/* Shaper magic */
#define LMAGIC 0x2D3D	/* Lofter magic */
#define MLIBMAGIC 0x3DAA	/* Material library magic */
#define MATMAGIC 0x3DFF	/* Material magic */

#define MESH_VERSION 0x3D3E  /* version chunk */

#define COLOR_F 0x0010
#define COLOR_24 0x0011
#define LIN_COLOR_24 0x0012
#define LIN_COLOR_F 0x0013
#define INT_PERCENTAGE 0x0030
#define FLOAT_PERCENTAGE 0x0031

#define MASTER_SCALE 0x0100

#define BIT_MAP 0x1100
#define USE_BIT_MAP 0x1101
#define SOLID_BGND 0x1200
#define USE_SOLID_BGND 0x1201
#define V_GRADIENT 0x1300
#define USE_V_GRADIENT 0x1301

#define LO_SHADOW_BIAS 0x1400
#define HI_SHADOW_BIAS 0x1410
#define SHADOW_MAP_SIZE 0x1420
#define SHADOW_SAMPLES 0x1430
#define SHADOW_RANGE 0x1440
#define SHADOW_FILTER 0x1450
#define RAY_BIAS 0x1460
#define RAY_SHADOWS 0x1470

#define O_CONSTS 0x1500
 
#define AMBIENT_LIGHT 0x2100

#define FOG 0x2200
#define USE_FOG 0x2201
#define FOG_BGND 0x2210
#define DISTANCE_CUE 0x2300
#define USE_DISTANCE_CUE 0x2301
#define LAYER_FOG 0x2302
#define USE_LAYER_FOG 0x2303
#define DCUE_BGND 0x2310

#define DEFAULT_VIEW 0x3000
#define VIEW_TOP 0x3010
#define VIEW_BOTTOM 0x3020
#define VIEW_LEFT 0x3030
#define VIEW_RIGHT 0x3040
#define VIEW_FRONT 0x3050
#define VIEW_BACK 0x3060
#define VIEW_USER 0x3070
#define VIEW_CAMERA 0x3080
#define VIEW_WINDOW 0x3090

#define NAMED_OBJECT 0x4000
#define OBJ_HIDDEN 0x4010
#define OBJ_VIS_LOFTER 0x4011
#define OBJ_DOESNT_CAST 0x4012
#define OBJ_MATTE 0x4013
#define OBJ_FAST 0x4014
#define OBJ_PROCEDURAL 0x4015
#define OBJ_FROZEN 0x4016
#define OBJ_DONT_RCVSHADOW  0x4017

#define N_TRI_OBJECT 0x4100

#define POINT_ARRAY 0x4110
#define POINT_FLAG_ARRAY 0x4111
#define FACE_ARRAY 0x4120
#define MSH_MAT_GROUP 0x4130
#define OLD_MAT_GROUP 0x4131
#define TEX_VERTS 0x4140
#define SMOOTH_GROUP 0x4150
#define MESH_MATRIX 0x4160
#define MESH_COLOR 0x4165
#define MESH_TEXTURE_INFO 0x4170
#define PROC_NAME 0x4181
#define PROC_DATA 0x4182
#define MSH_BOXMAP 0x4190

#define N_D_L_OLD 0x4400

#define N_CAM_OLD 0x4500

#define N_DIRECT_LIGHT 0x4600
#define DL_SPOTLIGHT 0x4610
#define DL_OFF 0x4620
#define DL_ATTENUATE 0x4625
#define DL_RAYSHAD 0x4627
#define DL_SHADOWED 0x4630
#define DL_LOCAL_SHADOW 0x4640
#define DL_LOCAL_SHADOW2 0x4641
#define DL_SEE_CONE 0x4650
#define DL_SPOT_RECTANGULAR 0x4651
#define DL_SPOT_OVERSHOOT 0x4652
#define DL_SPOT_PROJECTOR 0x4653
#define DL_EXCLUDE 0x4654
#define DL_RANGE 0x4655	/* Old style chunk -- don't write */
#define DL_SPOT_ROLL 0x4656
#define DL_SPOT_ASPECT 0x4657
#define DL_RAY_BIAS 0x4658
#define DL_INNER_RANGE 0x4659
#define DL_OUTER_RANGE 0x465A
#define DL_MULTIPLIER 0x465B

#define N_AMBIENT_LIGHT 0x4680

#define N_CAMERA 0x4700
#define CAM_SEE_CONE 0x4710
#define CAM_RANGES 0x4720

#define HIERARCHY 0x4F00
#define PARENT_OBJECT 0x4F10
#define PIVOT_OBJECT 0x4F20
#define PIVOT_LIMITS 0x4F30
#define PIVOT_ORDER 0x4F40
#define XLATE_RANGE 0x4F50

#define POLY_2D 0x5000

/* Flags in shaper file that tell whether polys make up an ok shape */

#define SHAPE_OK 0x5010
#define SHAPE_NOT_OK 0x5011

#define SHAPE_HOOK 0x5020

#define PATH_3D 0x6000
#define PATH_MATRIX 0x6005
#define SHAPE_2D 0x6010
#define M_SCALE 0x6020
#define M_TWIST 0x6030
#define M_TEETER 0x6040
#define M_FIT 0x6050
#define M_BEVEL 0x6060
#define XZ_CURVE 0x6070
#define YZ_CURVE 0x6080
#define INTERPCT 0x6090
#define DEFORM_LIMIT 0x60A0

/* Flags for Modeler options */

#define USE_CONTOUR 0x6100
#define USE_TWEEN 0x6110
#define USE_SCALE 0x6120
#define USE_TWIST 0x6130
#define USE_TEETER 0x6140
#define USE_FIT 0x6150
#define USE_BEVEL 0x6160

/* Viewport description chunks */

#define VIEWPORT_LAYOUT_OLD 0x7000
#define VIEWPORT_DATA_OLD 0x7010
#define VIEWPORT_LAYOUT 0x7001
#define VIEWPORT_DATA 0x7011
#define VIEWPORT_DATA_3 0x7012	/* Version 3.0 -- not backward-compatible */
#define VIEWPORT_SIZE 0x7020
#define NETWORK_VIEW 0x7030

/* Material file chunk IDs */

#define	MAT_ENTRY		0xAFFF
#define MAT_NAME		0xA000
#define MAT_AMBIENT		0xA010
#define MAT_DIFFUSE		0xA020
#define MAT_SPECULAR		0xA030
#define MAT_SHININESS		0xA040
#define MAT_SHIN2PCT		0xA041
#define MAT_SHIN3PCT		0xA042
#define MAT_TRANSPARENCY	0xA050
#define MAT_XPFALL	0xA052
#define MAT_REFBLUR	0xA053

#define MAT_SELF_ILLUM		0xA080
#define MAT_TWO_SIDE		0xA081
#define MAT_DECAL		0xA082
#define MAT_ADDITIVE		0xA083
#define MAT_SELF_ILPCT	0xA084
#define MAT_WIRE			0xA085
#define MAT_SUPERSMP		0xA086
#define MAT_WIRESIZE		0xA087
#define MAT_FACEMAP		0xA088
#define MAT_XPFALLIN		0xA08A
#define MAT_PHONGSOFT	0xA08C
#define MAT_WIREABS  	0xA08E

#define MAT_SHADING		0xA100

#define MAT_TEXMAP		0xA200
#define MAT_OPACMAP		0xA210
#define MAT_BUMPMAP		0xA230
#define MAT_SPECMAP		0xA204
#define MAT_REFLMAP		0xA220
#define MAT_USE_XPFALL	0xA240
#define MAT_USE_REFBLUR	0xA250
#define MAT_BUMP_PERCENT 0xA252  /* new scaled up bump value */

#define MAT_MAPNAME		0xA300
#define MAT_ACUBIC		0xA310

#define MAT_SXP_TEXT_DATA 0xA320
#define MAT_SXP_TEXT2_DATA 0xA321
#define MAT_SXP_OPAC_DATA 0xA322
#define MAT_SXP_BUMP_DATA 0xA324
#define MAT_SXP_SPEC_DATA 0xA325
#define MAT_SXP_SHIN_DATA 0xA326
#define MAT_SXP_SELFI_DATA 0xA328
#define MAT_SXP_TEXT_MASKDATA 0xA32A
#define MAT_SXP_TEXT2_MASKDATA 0xA32C
#define MAT_SXP_OPAC_MASKDATA	0xA32E
#define MAT_SXP_BUMP_MASKDATA	0xA330
#define MAT_SXP_SPEC_MASKDATA	0xA332
#define MAT_SXP_SHIN_MASKDATA	0xA334
#define MAT_SXP_SELFI_MASKDATA 0xA336
#define MAT_SXP_REFL_MASKDATA	 0xA338
#define MAT_TEX2MAP 	0xA33A
#define MAT_SHINMAP 	0xA33C
#define MAT_SELFIMAP 0xA33D
#define MAT_TEXMASK 0xA33E
#define MAT_TEX2MASK 0xA340
#define MAT_OPACMASK 0xA342
#define MAT_BUMPMASK 0xA344
#define MAT_SHINMASK 0xA346
#define MAT_SPECMASK 0xA348
#define MAT_SELFIMASK 0xA34A
#define MAT_REFLMASK 0xA34C
#define MAT_MAP_TILINGOLD 0xA350
#define MAT_MAP_TILING 0xA351
#define MAT_MAP_TEXBLUR_OLD 0xA352
#define MAT_MAP_TEXBLUR 0xA353
#define MAT_MAP_USCALE 0xA354
#define MAT_MAP_VSCALE 0xA356
#define MAT_MAP_UOFFSET 0xA358
#define MAT_MAP_VOFFSET 0xA35A
#define MAT_MAP_ANG 0xA35C
#define MAT_MAP_COL1 0xA360
#define MAT_MAP_COL2 0xA362
#define MAT_MAP_RCOL 0xA364 
#define MAT_MAP_GCOL 0xA366 
#define MAT_MAP_BCOL 0xA368 

/* NOTE Numbers 0x8000 through 0x8FFF are reserved for external
   applications to include in APP_DATA chunks */
#define APP_DATA 0x8000

/* Dummy chunk ID */

#define DUMMY 0xFFFF



#endif

#define _OFILE_H_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dxfimp.rc
//
#define IDD_IMPORTOPTIONS               101
#define IDD_MERGEORREPL                 102
#define IDC_OBJ_LAYER                   1000
#define IDC_OBJ_COLOR                   1001
#define IDC_OBJ_ENTITY                  1002
#define IDC_3DS_MERGE                   1002
#define IDC_3DS_REPLACE                 1003
#define IDC_REMOVEDOUBLES               1004
#define IDC_FILLPOLYLINES               1005
#define IDC_AUTOSMOOTH                  1006
#define IDC_WELDENTRY                   1007
#define IDC_WELDSPINNER                 1008
#define IDC_SMOOTHSPINNER               1009
#define IDC_SMOOTHENTRY                 1010
#define IDC_ARCSPINNER                  1011
#define IDC_ARCENTRY                    1012
#define IDC_WELD                        1013
#define IDC_UNIFYNORMALS                1014
#define IDC_DBG1                        1015
#define IDC_ARCSUB                      1015
#define IDC_ARCSUB_SPIN                 1016
#define IDS_TH_SCENEIMPORT              40217
#define IDS_TH_TOM_HUDSON               40222
#define IDS_TH_COPYRIGHT_YOST_GROUP     40223
#define IDS_TH_ERR_OPENING_FILE         40225
#define IDS_TH_OUTOFMEMORY              40230
#define IDS_TH_AUTOCAD                  40236
#define IDS_TH_AUTOCADDXFFILE           40238
#define IDS_TH_DXFIMP                   40240
#define IDS_TH_DXFIMPORTDLL             40241
#define IDS_TH_PARTIALREAD              40242
#define IDS_TH_UNKNOWNERR               40243
#define IDS_TH_FINALIZING               40244
#define IDS_TH_IMPORTINGDXF             40245
#define IDS_TH_INVALIDRATSNEST          40253
#define IDS_TH_INVALIDSPLINEMESH        40254
#define IDS_TH_INVALID3DMESH            40255
#define IDS_TH_ERRORINDXF               40256
#define IDS_TH_BADPOLYLINE              40257
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\objimp.cpp ===
/**********************************************************************
 *<
	FILE: objimp.cpp

	DESCRIPTION:  Wavefront .OBJ file import module

	CREATED BY: Don Brittain and Tom Hudson

	HISTORY: created 30 December 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "Max.h"
#include <stdio.h>
#include <direct.h>
#include <commdlg.h>
#include "objimp.h"
#include "objires.h"

// The file stream


HINSTANCE hInstance;

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

// Jaguar interface code

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;
	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			//MessageBox(NULL,L"OBJIMP.DLL: DllMain",L"OBJIMP",MB_OK);
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------

class OBJClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new OBJImport; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_WAVEFRONT); }
	SClass_ID		SuperClassID() { return SCENE_IMPORT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(1,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SCENEIMPORT);  }
	};

static OBJClassDesc OBJDesc;

//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_TH_OBJIMPORTDLL); }

__declspec( dllexport ) int
LibNumberClasses() { return 1; }

__declspec( dllexport ) ClassDesc *
LibClassDesc(int i) {
	switch(i) {
		case 0: return &OBJDesc; break;
		default: return 0; break;
		}

	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

//
// .OBJ import module functions follow:
//

OBJImport::OBJImport() {
	}

OBJImport::~OBJImport() {
	}

int
OBJImport::ExtCount() {
	return 1;
	}

const TCHAR *
OBJImport::Ext(int n) {		// Extensions supported for import/export modules
	switch(n) {
		case 0:
			return _T("OBJ");
		}
	return _T("");
	}

const TCHAR *
OBJImport::LongDesc() {			// Long ASCII description (i.e. "Targa 2.0 Image File")
	return GetString(IDS_TH_WAVEFRONTOBJFILE);
	}
	
const TCHAR *
OBJImport::ShortDesc() {			// Short ASCII description (i.e. "Targa")
	return GetString(IDS_TH_WAVEFRONT);
	}

const TCHAR *
OBJImport::AuthorName() {			// ASCII Author name
	return GetString(IDS_TH_DON_AND_TOM);
	}

const TCHAR *
OBJImport::CopyrightMessage() {	// ASCII Copyright message
	return GetString(IDS_TH_COPYRIGHT_YOST_GROUP);
	}

const TCHAR *
OBJImport::OtherMessage1() {		// Other message #1
	return _T("");
	}

const TCHAR *
OBJImport::OtherMessage2() {		// Other message #2
	return _T("");
	}

unsigned int
OBJImport::Version() {				// Version number * 100 (i.e. v3.01 = 301)
	return 100;
	}

void
OBJImport::ShowAbout(HWND hWnd) {			// Optional
 	}

int normparse(TCHAR *s, int *nnum)
{
    int slashcnt;

    slashcnt = 0;
    while(*s) {
        if(*s++ == '/')
            slashcnt++;
        if(slashcnt == 2) {
            *nnum = _ttoi(s) - 1;
            return 1;
        }
    }
    return 0;
}

int texparse(TCHAR *s, int *tnum)
{
    int slashcnt;

    slashcnt = 0;
    while(*s) {
        if(*s++ == '/')
            slashcnt++;
        if(slashcnt == 1 && *s != '/') {
            *tnum = _ttoi(s) - 1;
            return 1;
        }
    }
    return 0;
}

int parse(TCHAR *s, TCHAR **v)
{
    int c;                 /* number of tokens */

    c = 0;
    while(1) {
		      /* skip spaces or tabs - currently only delimiters */
		while((*s == ' ') || (*s == '\t'))
            s++;
		if(*s && *s != '\n' && *s != '\r') {  /* found a token - set ptr and bump counter */
            v[c++] = s;
		}
        if(*s == '"') {      /* in quoted string */
            v[c-1] += 1;
            s++;
	    	while(*s != '"' && *s && *s != '\n' && *s != '\r')  /* skip over string */
	        	s++;
           	if(*s == '"')
               	*s++ = '\0';
        }
		else                 /* in ordinary token: skip over it */
		    while(*s != ' ' && *s != '\t' && *s && *s != '\n' && *s != '\r')
	    	    s++;
		if(*s == 0 || *s == '\n' || *s == '\r') {   /* if at end of input string, leave */
	   		*s = 0;
    	    break;
		}
		else                 /* else terminate the token string */
            *s++ = 0;
    }
    v[c] = _T("");
    return c;
}

inline int getLine(FILE *fp, TCHAR *buf)
{
    return _fgetts(buf, 500, fp) != NULL;
}	

BOOL objFileRead(const TCHAR *filename, Mesh *msh)
{
    TCHAR buf[512];
    TCHAR *av[25];
	FILE *fp;
    int ac = 0;
    int vcnt = 0;
    int ncnt = 0;
    int tcnt = 0;
    int gons = 0;
    int i, vnum;
    int index;
    int normals;
    int texverts;
	DWORD vtxIndex[32];
	Point3 *vlst, *nlst, *tlst;
	TCHAR *stop;

	if((fp = _tfopen(filename, _T("r"))) == NULL)
		return 0;

	// scan to count verts and faces

    while(getLine(fp, buf)) {
		ac = parse(buf, av);
		switch(av[0][0]) {
		default :
	    	break;
		case 'v' :
	    	if(av[0][1] == 't') {
    	        tcnt++;
				break;
            }
	    	if(av[0][1] == 'n') {
    	        ncnt++;
				break;
            }
	    	vcnt++;
	    	break;
		case 'f' :
			gons++;
			if(ac > 4)
				gons++;
	    	break;
		}
    }
	fclose(fp);

	vlst = new Point3[vcnt];
	nlst = new Point3[ncnt];
	tlst = new Point3[tcnt];

	msh->setNumVerts(vcnt);
	msh->setNumTVerts(tcnt);
	msh->setNumFaces(gons);

	vcnt = ncnt = tcnt = gons = 0;

	if((fp = _tfopen(filename, _T("r"))) == NULL)
		return 0;

    while(getLine(fp, buf)) {
		ac = parse(buf, av);
		switch(av[0][0]) {
		default :
	    	break;
		case 'v' :
	    	if(av[0][1] == 't') {
	        	tlst[tcnt][0] = (float)_tcstod(av[1], &stop);
	        	tlst[tcnt][1] = (float)_tcstod(av[2], &stop);
	        	tlst[tcnt][2] = (float)_tcstod(av[3], &stop);
    	        tcnt++;
				break;
            }
	    	else if(av[0][1] == 'n') {
	        	nlst[ncnt][0] = (float)_tcstod(av[1], &stop);
	        	nlst[ncnt][1] = (float)_tcstod(av[2], &stop);
	        	nlst[ncnt][2] = (float)_tcstod(av[3], &stop);
    	        ncnt++;
				break;
            }
	    	vlst[vcnt][0] = (float)20.0 * (float)_tcstod(av[1], &stop);
	    	vlst[vcnt][1] = (float)20.0 * (float)_tcstod(av[2], &stop);
	    	vlst[vcnt][2] = (float)20.0 * (float)_tcstod(av[3], &stop);
	    	vcnt++;
	    	break;
		case 'f' :
            normals = normparse(av[1], &vnum);
			texverts = texparse(av[1], &vnum);
	    	for(i = 1; i < ac; i++) {
				vnum = _ttoi(av[i]) - 1;
				vtxIndex[i-1] = (DWORD)vnum;
				msh->setVert(vnum, vlst[vnum]);
        	    if(texverts) {
            	    texparse(av[i], &index);
					msh->setTVert(vnum, tlst[index]);
	            }
        	    if(normals) {
            	    normparse(av[i], &index);
					msh->setNormal(vnum, nlst[index]);
	            }
			}
			msh->faces[gons].setVerts(vtxIndex);
			// don't set texture verts yet -- wait till GFX supports it!

			if(ac == 4)	{	// we got a triangle
				msh->faces[gons++].setEdgeVisFlags(1, 1, 1);
			}
			else {	// we got >= quad -- assume it's a quad
				msh->faces[gons++].setEdgeVisFlags(1, 1, 0);
				vtxIndex[1] = vtxIndex[2];
				vtxIndex[2] = vtxIndex[3];
				msh->faces[gons].setVerts(vtxIndex);
				msh->faces[gons++].setEdgeVisFlags(0, 1, 1);
			}
			break;
		}
    }
	fclose(fp);
	msh->buildNormals();
	msh->buildBoundingBox();
	msh->InvalidateEdgeList();

    delete [] vlst;
    delete [] nlst;
    delete [] tlst;

	return TRUE;
}

int
OBJImport::DoImport(const TCHAR *filename,ImpInterface *i,Interface *gi, BOOL suppressPrompts) {
	TriObject *object = CreateNewTriObject();
	if(!object)
		return 0;
	if(objFileRead(filename, &object->GetMesh())) {
		ImpNode *node = i->CreateNode();
		if(!node) {
			delete object;
			return 0;
			}
		Matrix3 tm;
		tm.IdentityMatrix();
		node->Reference(object);
		node->SetTransform(0,tm);
		i->AddNodeToScene(node);
		node->SetName(GetString(IDS_TH_WAVE_OBJ_NAME));
		i->RedrawViews();
		return 1;
		}
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\objires.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by objimp.rc
//
#define IDS_TH_SCENEIMPORT              40217
#define IDS_TH_COPYRIGHT_YOST_GROUP     40223
#define IDS_TH_WAVEFRONT                40246
#define IDS_TH_OBJIMPORTDLL             40247
#define IDS_TH_WAVEFRONTOBJFILE         40248
#define IDS_TH_DON_AND_TOM              40249
#define IDS_TH_WAVE_OBJ_NAME            40252

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ImpExp\AsciiExp\animout.cpp ===
//************************************************************************** 
//* Animout.cpp	- Ascii File Exporter
//* 
//* By Christer Janson
//* Kinetix Development
//*
//* January 20, 1997 CCJ Initial coding
//*
//* This module handles controller key output and controller sampling.
//*
//* Copyright (c) 1997, All Rights Reserved. 
//***************************************************************************

#include "asciiexp.h"

#define ALMOST_ZERO 1.0e-3f
BOOL EqualPoint3(Point3 p1, Point3 p2);

/****************************************************************************

  TM Animation output
  
****************************************************************************/

// Get hold of the transform controllers for the node... 
void AsciiExp::ExportAnimKeys(INode* node, int indentLevel) 
{
	TSTR indent = GetIndent(indentLevel);
	BOOL bPosAnim;
	BOOL bRotAnim;
	BOOL bScaleAnim;
	BOOL bDoKeys = FALSE;

	// We can only export keys if all TM controllers are "known" to us.
	// The reason for that is that some controllers control more than what
	// they should. Consider a path position controller, if you turn on
	// follow and banking, this position controller will also control
	// rotation. If a node that had a path position controller also had a
	// TCB rotation controller, the TCB keys would not describe the whole
	// rotation of the node.
	// For that reason we will only export keys if all controllers
	// position, rotation and scale are linear, hybrid (bezier) or tcb.

	if (!GetAlwaysSample()) {
		Control* pC = node->GetTMController()->GetPositionController();
		Control* rC = node->GetTMController()->GetRotationController();
		Control* sC = node->GetTMController()->GetScaleController();

		if (IsKnownController(pC) && IsKnownController(rC) && IsKnownController(sC)) {
			bDoKeys = TRUE;
		}
	}

	if (bDoKeys) {
		// Only dump the track header if any of the controllers have keys
		if (node->GetTMController()->GetPositionController()->NumKeys() ||
			node->GetTMController()->GetRotationController()->NumKeys() ||
			node->GetTMController()->GetScaleController()->NumKeys()) {

			fprintf(pStream,"%s\t%s {\n", indent.data(), ID_TM_ANIMATION); 
			fprintf(pStream,"%s\t\t%s \"%s\"\n", indent.data(), ID_NODE_NAME,
				FixupName(node->GetName()));

			DumpPosKeys(node->GetTMController()->GetPositionController(), indentLevel);
			DumpRotKeys(node->GetTMController()->GetRotationController(), indentLevel);
			DumpScaleKeys(node->GetTMController()->GetScaleController(), indentLevel);

			fprintf(pStream,"%s\t}\n", indent.data());
		}
	}
	else if (CheckForAnimation(node, bPosAnim, bRotAnim, bScaleAnim)) {
		fprintf(pStream,"%s\t%s {\n", indent.data(), ID_TM_ANIMATION); 
		fprintf(pStream,"%s\t\t%s \"%s\"\n", indent.data(), ID_NODE_NAME,
			FixupName(node->GetName()));

		if (bPosAnim) {
			DumpPosSample(node, indentLevel);
		}
		if (bRotAnim) {
			DumpRotSample(node, indentLevel);
		}
		if (bScaleAnim) {
			DumpScaleSample(node, indentLevel);
		}

		fprintf(pStream,"%s\t}\n", indent.data());
	}
}

// To really see if a node is animated we can step through the animation range
// and decompose the TM matrix for every frame and examine the components.
// This way we can identify position, rotation and scale animation separately.
// 
// Some controllers makes it problematic to examine the TMContollers instead of
// the actual TMMatrix. For example, a path controller is a position controller, 
// but if you turn on follow and banking, it will also affect the rotation component.
// If we want to, we can examine the position, rotation and scale controllers and
// if they all are Linear, Hybrid (bezier) or TCB, then we could export the actual keys.
// This is not at all difficult, but the importer has to know the exact interpolation
// algorithm in order to use it. The source code to the interpolation routines are available
// to ADN members.
// 
// For an example of how to export actual keys, look at DumpPoint3Keys() below.
// This method will check the actual controller to determine if the controller is known.
// If we know how to work this controller, its actual keys will be exported,
// otherwise the controller will be sampled using the user specified sampling frequency.

BOOL AsciiExp::CheckForAnimation(INode* node, BOOL& bPos, BOOL& bRot, BOOL& bScale)
{
	TimeValue start = ip->GetAnimRange().Start();
	TimeValue end = ip->GetAnimRange().End();
	TimeValue t;
	int delta = GetTicksPerFrame();
	Matrix3 tm;
	AffineParts ap;
	Point3 firstPos;
	float rotAngle, firstRotAngle;
	Point3 rotAxis, firstRotAxis;
	Point3 firstScaleFactor;

	bPos = bRot = bScale = FALSE;

	for (t=start; t<=end; t+=delta) {
		tm = node->GetNodeTM(t) * Inverse(node->GetParentTM(t));

		decomp_affine(tm, &ap);

		AngAxisFromQ(ap.q, &rotAngle, rotAxis);

		if (t != start) {
			if (!bPos) {
				if (!EqualPoint3(ap.t, firstPos)) {
					bPos = TRUE;
					}
				}
			// MAX 2.x:
			// We examine the rotation angle to see if the rotation component
			// has changed.
			// Although not entierly true, it should work.
			// It is rare that the rotation axis is animated without
			// the rotation angle being somewhat affected.
			// MAX 3.x:
			// The above did not work, I have a repro scene that doesn't export a rotation track
			// because of this. I fixed it to also compare the axis.
			if (!bRot) {
				if (fabs(rotAngle - firstRotAngle) > ALMOST_ZERO) {
					bRot = TRUE;
					}
				else if (!EqualPoint3(rotAxis, firstRotAxis)) {
					bRot = TRUE;
					}
				}

			if (!bScale) {
				if (!EqualPoint3(ap.k, firstScaleFactor)) {
					bScale = TRUE;
					}
				}
			}
		else {
			firstPos = ap.t;
			firstRotAngle = rotAngle;
			firstRotAxis = rotAxis;
			firstScaleFactor = ap.k;
			}

		// No need to continue looping if all components are animated
		if (bPos && bRot && bScale)
			break;
		}

	return bPos || bRot || bScale;
	}

void AsciiExp::DumpPosSample(INode* node, int indentLevel) 
{	
	TSTR indent = GetIndent(indentLevel);
	
	fprintf(pStream,"%s\t\t%s {\n", indent.data(), ID_POS_TRACK);

	TimeValue start = ip->GetAnimRange().Start();
	TimeValue end = ip->GetAnimRange().End();
	TimeValue t;
	int delta = GetTicksPerFrame() * GetKeyFrameStep();
	Matrix3 tm;
	AffineParts ap;
	Point3	prevPos;

	for (t=start; t<=end; t+=delta) {
		tm = node->GetNodeTM(t) * Inverse(node->GetParentTM(t));
		decomp_affine(tm, &ap);

		Point3 pos = ap.t;

		if (t!= start && EqualPoint3(pos, prevPos)) {
			// Skip identical keys 
			continue;
		}

		prevPos = pos;

		// Output the sample
		fprintf(pStream, "%s\t\t\t%s %d\t%s\n",
			indent.data(),
			ID_POS_SAMPLE,
			t,
			Format(pos));
	}

	fprintf(pStream,"%s\t\t}\n", indent.data());
}

void AsciiExp::DumpRotSample(INode* node, int indentLevel) 
{	
	TSTR indent = GetIndent(indentLevel);
	
	fprintf(pStream,"%s\t\t%s {\n", indent.data(), ID_ROT_TRACK);

	TimeValue start = ip->GetAnimRange().Start();
	TimeValue end = ip->GetAnimRange().End();
	TimeValue t;
	int delta = GetTicksPerFrame() * GetKeyFrameStep();
	Matrix3 tm;
	AffineParts ap;
	Quat prevQ;

	prevQ.Identity();

	for (t=start; t<=end; t+=delta) {
		tm = node->GetNodeTM(t) * Inverse(node->GetParentTM(t));

		decomp_affine(tm, &ap);

		// Rotation keys should be relative, so we need to convert these
		// absolute samples to relative values.

		Quat q = ap.q / prevQ;
		prevQ = ap.q;

		if (q.IsIdentity()) {
			// No point in exporting null keys...
			continue;
		}

		// Output the sample
		fprintf(pStream, "%s\t\t\t%s %d\t%s\n",
			indent.data(),
			ID_ROT_SAMPLE,
			t,
			Format(q));
	}

	fprintf(pStream,"%s\t\t}\n", indent.data());
}

void AsciiExp::DumpScaleSample(INode* node, int indentLevel) 
{	
	TSTR indent = GetIndent(indentLevel);
	
	fprintf(pStream,"%s\t\t%s {\n", indent.data(), ID_SCALE_TRACK);

	TimeValue start = ip->GetAnimRange().Start();
	TimeValue end = ip->GetAnimRange().End();
	TimeValue t;
	int delta = GetTicksPerFrame() * GetKeyFrameStep();
	Matrix3 tm;
	AffineParts ap;
	Point3	prevFac;

	for (t=start; t<=end; t+=delta) {
		tm = node->GetNodeTM(t) * Inverse(node->GetParentTM(t));
		decomp_affine(tm, &ap);

		if (t!= start && EqualPoint3(ap.k, prevFac)) {
			// Skip identical keys 
			continue;
		}

		prevFac = ap.k;

		// Output the sample
		fprintf(pStream, "%s\t\t\t%s %d\t%s %s\n",
			indent.data(),
			ID_SCALE_SAMPLE,
			t,
			Format(ap.k),
			Format(ap.u));
	}

	fprintf(pStream,"%s\t\t}\n", indent.data());
}

// Output point3 keys if this is a known point3 controller that
// supports key operations. Otherwise we will sample the controller 
// once for each frame to get the value.
// Point3 controllers can control, for example, color.
void AsciiExp::DumpPoint3Keys(Control* cont, int indentLevel) 
{
	if (!cont)	// Bug out if no controller.
		return;
	
	int i;
	TSTR indent = GetIndent(indentLevel);
	IKeyControl *ikc = NULL;

	// If the user wants us to always sample, we will ignore the KeyControlInterface
	if (!GetAlwaysSample())
		ikc = GetKeyControlInterface(cont);
	
	// TCB point3
	if (ikc && cont->ClassID() == Class_ID(TCBINTERP_POINT3_CLASS_ID, 0)) {
		fprintf(pStream,"%s\t\t%s {\n", indent.data(), ID_CONTROL_POINT3_TCB); 
		for (i=0; i<ikc->GetNumKeys(); i++) {
			ITCBPoint3Key key;
			ikc->GetKey(i, &key);
			fprintf(pStream, "%s\t\t\t%s %d\t%s",
				indent.data(),
				ID_TCB_POINT3_KEY,
				key.time,
				Format(key.val));
			// Add TCB specific data
			fprintf(pStream, "\t%s\t%s\t%s\t%s\t%s\n", Format(key.tens), Format(key.cont), Format(key.bias), Format(key.easeIn), Format(key.easeOut));
		}
		fprintf(pStream,"%s\t\t}\n", indent.data());
	}
	// Bezier point3
	else if (ikc && cont->ClassID() == Class_ID(HYBRIDINTERP_POINT3_CLASS_ID, 0)) {
		fprintf(pStream,"%s\t\t%s {\n", indent.data(), ID_CONTROL_POINT3_BEZIER); 
		for (i=0; i<ikc->GetNumKeys(); i++) {
			IBezPoint3Key key;
			ikc->GetKey(i, &key);
			fprintf(pStream, "%s\t\t\t%s %d\t%s",
				indent.data(),
				ID_BEZIER_POINT3_KEY,
				key.time, 
				Format(key.val));
			fprintf(pStream, "\t%s\t%s\t%d\n", Format(key.intan), Format(key.outtan), key.flags);
		}
		fprintf(pStream,"%s\t\t}\n", indent.data());
	}
	// Bezier color
	else if (ikc && cont->ClassID() == Class_ID(HYBRIDINTERP_COLOR_CLASS_ID, 0)) {
		fprintf(pStream,"%s\t\t%s {\n", indent.data(), ID_CONTROL_COLOR_BEZIER); 
		for (i=0; i<ikc->GetNumKeys(); i++) {
			IBezPoint3Key key;
			ikc->GetKey(i, &key);
			fprintf(pStream, "%s\t\t\t%s %d\t%s", 
				indent.data(),
				ID_BEZIER_POINT3_KEY,
				key.time,
				Format(key.val));
			fprintf(pStream, "\t%s\t%s\t%d\n", Format(key.intan), Format(key.outtan), key.flags);
		}
		fprintf(pStream,"%s\t\t}\n", indent.data());
	}
	else {
		
		// Unknown controller, no key interface or sample on demand -
		// This might be a procedural controller or something else we
		// don't know about. The last resort is to get the value from the 
		// controller at every n frames.
		
		TSTR name;
		cont->GetClassName(name);
		fprintf(pStream,"%s\t\t%s \"%s\" {\n", indent.data(), ID_CONTROL_POINT3_SAMPLE,
			FixupName(name));
		
		// If it is animated at all...
		if (cont->IsAnimated()) {
			// Get the range of the controller animation 
			Interval range; 
			// Get range of full animation
			Interval animRange = ip->GetAnimRange(); 
			TimeValue t = cont->GetTimeRange(TIMERANGE_ALL).Start();
			Point3 value;
			
			// While we are inside the animation... 
			while (animRange.InInterval(t)) {
				// Sample the controller
				range = FOREVER;
				cont->GetValue(t, &value, range);
				
				// Set time to start of controller validity interval 
				t = range.Start();
				
				// Output the sample
				fprintf(pStream, "%s\t\t\t%s %d\t%s\n",
					indent.data(),
					ID_POINT3_KEY,
					t,
					Format(value));
				
				// If the end of the controller validity is beyond the 
				// range of the animation
				if (range.End() > cont->GetTimeRange(TIMERANGE_ALL).End()) {
					break;
				}
				else {
					t = (range.End()/GetTicksPerFrame()+GetKeyFrameStep()) * GetTicksPerFrame();
				}
			}
		}
		fprintf(pStream,"%s\t\t}\n", indent.data());
	}
}

// Output float keys if this is a known float controller that
// supports key operations. Otherwise we will sample the controller 
// once for each frame to get the value.
void AsciiExp::DumpFloatKeys(Control* cont, int indentLevel) 
{
	if (!cont)
		return;
	
	int i;
	TSTR indent = GetIndent(indentLevel);
	IKeyControl *ikc = NULL;

	// If the user wants us to always sample, we will ignore the KeyControlInterface
	if (!GetAlwaysSample())
		ikc = GetKeyControlInterface(cont);
	
	// TCB float
	if (ikc && cont->ClassID() == Class_ID(TCBINTERP_FLOAT_CLASS_ID, 0)) {
		fprintf(pStream,"%s\t\t%s {\n", indent.data(), ID_CONTROL_FLOAT_TCB); 
		for (i=0; i<ikc->GetNumKeys(); i++) {
			ITCBFloatKey key;
			ikc->GetKey(i, &key);
			fprintf(pStream, "%s\t\t\t%s %d\t%s",
				indent.data(),
				ID_TCB_FLOAT_KEY,
				key.time,
				Format(key.val));
			fprintf(pStream, "\t%s\t%s\t%s\t%s\t%s\n", Format(key.tens), Format(key.cont), Format(key.bias), Format(key.easeIn), Format(key.easeOut));
		}
		fprintf(pStream,"%s\t\t}\n", indent.data());
	}
	// Bezier float
	else if (ikc && cont->ClassID() == Class_ID(HYBRIDINTERP_FLOAT_CLASS_ID, 0)) {
		fprintf(pStream,"%s\t\t%s {\n", indent.data(), ID_CONTROL_FLOAT_BEZIER); 
		for (i=0; i<ikc->GetNumKeys(); i++) {
			IBezFloatKey key;
			ikc->GetKey(i, &key);
			fprintf(pStream, "%s\t\t\t%s %d\t%s",
				indent.data(),
				ID_BEZIER_FLOAT_KEY,
				key.time, 
				Format(key.val));
			fprintf(pStream, "\t%s\t%s\t%d\n", Format(key.intan), Format(key.outtan), key.flags);
		}
		fprintf(pStream,"%s\t\t}\n", indent.data());
	}
	else if (ikc && cont->ClassID() == Class_ID(LININTERP_FLOAT_CLASS_ID, 0)) {
		fprintf(pStream,"%s\t\t%s {\n", indent.data(), ID_CONTROL_FLOAT_LINEAR); 
		for (i=0; i<ikc->GetNumKeys(); i++) {
			ILinFloatKey key;
			ikc->GetKey(i, &key);
			fprintf(pStream, "%s\t\t\t%s %d\t%s\n",
				indent.data(),
				ID_FLOAT_KEY,
				key.time,
				Format(key.val));
		}
		fprintf(pStream,"%s\t\t}\n", indent.data());
	}
	else {
		
		// Unknown controller, no key interface or sample on demand -
		// This might be a procedural controller or something else we
		// don't know about. The last resort is to get the value from the 
		// controller at every n frames.
		
		TSTR name;
		cont->GetClassName(name);
		fprintf(pStream,"%s\t\t%s \"%s\" {\n", indent.data(), ID_CONTROL_FLOAT_SAMPLE,
			FixupName(name));
		
		// If it is animated at all...
		if (cont->IsAnimated()) {
			// Get the range of the controller animation 
			Interval range; 
			// Get range of full animation
			Interval animRange = ip->GetAnimRange(); 
			TimeValue t = cont->GetTimeRange(TIMERANGE_ALL).Start();
			float value;
			
			// While we are inside the animation... 
			while (animRange.InInterval(t)) {
				// Sample the controller
				range = FOREVER;
				cont->GetValue(t, &value, range);
				
				// Set time to start of controller validity interval 
				t = range.Start();
				
				// Output the sample
				fprintf(pStream, "%s\t\t\t%s %d\t%s\n",
					indent.data(),
					ID_FLOAT_KEY,
					t,
					Format(value));
				
				// If the end of the controller validity is beyond the 
				// range of the animation
				if (range.End() > cont->GetTimeRange(TIMERANGE_ALL).End()) {
					break;
				}
				else {
					t = (range.End()/GetTicksPerFrame()+GetKeyFrameStep()) * GetTicksPerFrame();
				}
			}
		}
		fprintf(pStream,"%s\t\t}\n", indent.data());
	}
}


void AsciiExp::DumpPosKeys(Control* cont, int indentLevel) 
{
	if (!cont)
		return;
	
	int i;
	TSTR indent = GetIndent(indentLevel);
	IKeyControl *ikc = GetKeyControlInterface(cont);
	
	// TCB position
	if (ikc && cont->ClassID() == Class_ID(TCBINTERP_POSITION_CLASS_ID, 0)) {
		int numKeys;
		if (numKeys = ikc->GetNumKeys()) {
			fprintf(pStream,"%s\t\t%s {\n", indent.data(), ID_CONTROL_POS_TCB); 
			for (i=0; i<numKeys; i++) {
				ITCBPoint3Key key;
				ikc->GetKey(i, &key);
				fprintf(pStream, "%s\t\t\t%s %d\t%s",
					indent.data(),
					ID_TCB_POS_KEY,
					key.time,
					Format(key.val));
				fprintf(pStream, "\t%s\t%s\t%s\t%s\t%s\n", Format(key.tens), Format(key.cont), Format(key.bias), Format(key.easeIn), Format(key.easeOut));
			}
			fprintf(pStream,"%s\t\t}\n", indent.data());
		}
	}
	// Bezier position
	else if (ikc && cont->ClassID() == Class_ID(HYBRIDINTERP_POSITION_CLASS_ID, 0))
	{
		int numKeys;
		if(numKeys = ikc->GetNumKeys())
		{
			fprintf(pStream,"%s\t\t%s {\n", indent.data(), ID_CONTROL_POS_BEZIER); 
			for (i=0; i<numKeys; i++) {
				IBezPoint3Key key;
				ikc->GetKey(i, &key);
				fprintf(pStream, "%s\t\t\t%s %d\t%s",
					indent.data(), 
					ID_BEZIER_POS_KEY,
					key.time,
					Format(key.val));
				fprintf(pStream, "\t%s\t%s\t%d\n", Format(key.intan), Format(key.outtan), key.flags);
			}
			fprintf(pStream,"%s\t\t}\n", indent.data());
		}
	}
	// Linear position
	else if (ikc && cont->ClassID() == Class_ID(LININTERP_POSITION_CLASS_ID, 0)) {
		int numKeys;
		if(numKeys = ikc->GetNumKeys())
		{
			fprintf(pStream,"%s\t\t%s {\n", indent.data(), ID_CONTROL_POS_LINEAR); 
			for (i=0; i<numKeys; i++) {
				ILinPoint3Key key;
				ikc->GetKey(i, &key);
				fprintf(pStream, "%s\t\t\t%s %d\t%s\n",
					indent.data(),
					ID_POS_KEY,
					key.time,
					Format(key.val));
			}
			fprintf(pStream,"%s\t\t}\n", indent.data());
		}
	}
}

void AsciiExp::DumpRotKeys(Control* cont, int indentLevel) 
{
	if (!cont)
		return;
	
	int i;
	TSTR indent = GetIndent(indentLevel);
	IKeyControl *ikc = GetKeyControlInterface(cont);
	
	if (ikc && cont->ClassID() == Class_ID(TCBINTERP_ROTATION_CLASS_ID, 0)) {
		int numKeys;
		if (numKeys = ikc->GetNumKeys()) {
			fprintf(pStream,"%s\t\t%s {\n", indent.data(), ID_CONTROL_ROT_TCB); 
			for (i=0; i<numKeys; i++) {
				ITCBRotKey key;
				ikc->GetKey(i, &key);
				fprintf(pStream, "%s\t\t\t%s %d\t%s", 
					indent.data(),
					ID_TCB_ROT_KEY,
					key.time,
					Format(key.val));
				fprintf(pStream, "\t%s\t%s\t%s\t%s\t%s\n", Format(key.tens), Format(key.cont), Format(key.bias), Format(key.easeIn), Format(key.easeOut));
			}
			fprintf(pStream,"%s\t\t}\n", indent.data());
		}
	}
	else if (ikc && cont->ClassID() == Class_ID(HYBRIDINTERP_ROTATION_CLASS_ID, 0))
	{
		int numKeys;
		if (numKeys = ikc->GetNumKeys()) {
			fprintf(pStream,"%s\t\t%s {\n", indent.data(), ID_CONTROL_ROT_BEZIER); 
			for (i=0; i<numKeys; i++) {
				IBezQuatKey key;
				ikc->GetKey(i, &key);
				fprintf(pStre