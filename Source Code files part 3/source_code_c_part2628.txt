);
        
        END_INTERFACE
    } IADsLocalityVtbl;

    interface IADsLocality
    {
        CONST_VTBL struct IADsLocalityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsLocality_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsLocality_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsLocality_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsLocality_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsLocality_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsLocality_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsLocality_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsLocality_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsLocality_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsLocality_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsLocality_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsLocality_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsLocality_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsLocality_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsLocality_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsLocality_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsLocality_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsLocality_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsLocality_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsLocality_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsLocality_get_Description(This,retval)	\
    (This)->lpVtbl -> get_Description(This,retval)

#define IADsLocality_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IADsLocality_get_LocalityName(This,retval)	\
    (This)->lpVtbl -> get_LocalityName(This,retval)

#define IADsLocality_put_LocalityName(This,bstrLocalityName)	\
    (This)->lpVtbl -> put_LocalityName(This,bstrLocalityName)

#define IADsLocality_get_PostalAddress(This,retval)	\
    (This)->lpVtbl -> get_PostalAddress(This,retval)

#define IADsLocality_put_PostalAddress(This,bstrPostalAddress)	\
    (This)->lpVtbl -> put_PostalAddress(This,bstrPostalAddress)

#define IADsLocality_get_SeeAlso(This,retval)	\
    (This)->lpVtbl -> get_SeeAlso(This,retval)

#define IADsLocality_put_SeeAlso(This,vSeeAlso)	\
    (This)->lpVtbl -> put_SeeAlso(This,vSeeAlso)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsLocality_get_Description_Proxy( 
    IADsLocality * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsLocality_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsLocality_put_Description_Proxy( 
    IADsLocality * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IADsLocality_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsLocality_get_LocalityName_Proxy( 
    IADsLocality * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsLocality_get_LocalityName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsLocality_put_LocalityName_Proxy( 
    IADsLocality * This,
    /* [in] */ BSTR bstrLocalityName);


void __RPC_STUB IADsLocality_put_LocalityName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsLocality_get_PostalAddress_Proxy( 
    IADsLocality * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsLocality_get_PostalAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsLocality_put_PostalAddress_Proxy( 
    IADsLocality * This,
    /* [in] */ BSTR bstrPostalAddress);


void __RPC_STUB IADsLocality_put_PostalAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsLocality_get_SeeAlso_Proxy( 
    IADsLocality * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsLocality_get_SeeAlso_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsLocality_put_SeeAlso_Proxy( 
    IADsLocality * This,
    /* [in] */ VARIANT vSeeAlso);


void __RPC_STUB IADsLocality_put_SeeAlso_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsLocality_INTERFACE_DEFINED__ */


#ifndef __IADsO_INTERFACE_DEFINED__
#define __IADsO_INTERFACE_DEFINED__

/* interface IADsO */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a1cd2dc6-effe-11cf-8abc-00c04fd8d503")
    IADsO : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LocalityName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LocalityName( 
            /* [in] */ BSTR bstrLocalityName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PostalAddress( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PostalAddress( 
            /* [in] */ BSTR bstrPostalAddress) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_TelephoneNumber( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_TelephoneNumber( 
            /* [in] */ BSTR bstrTelephoneNumber) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FaxNumber( 
            /* [in] */ BSTR bstrFaxNumber) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SeeAlso( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SeeAlso( 
            /* [in] */ VARIANT vSeeAlso) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsO * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsO * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsO * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsO * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsO * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsO * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsO * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsO * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsO * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsO * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsO * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsO * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsO * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsO * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsO * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsO * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsO * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsO * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsO * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IADsO * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IADsO * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalityName )( 
            IADsO * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocalityName )( 
            IADsO * This,
            /* [in] */ BSTR bstrLocalityName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PostalAddress )( 
            IADsO * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PostalAddress )( 
            IADsO * This,
            /* [in] */ BSTR bstrPostalAddress);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TelephoneNumber )( 
            IADsO * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TelephoneNumber )( 
            IADsO * This,
            /* [in] */ BSTR bstrTelephoneNumber);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FaxNumber )( 
            IADsO * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FaxNumber )( 
            IADsO * This,
            /* [in] */ BSTR bstrFaxNumber);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SeeAlso )( 
            IADsO * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SeeAlso )( 
            IADsO * This,
            /* [in] */ VARIANT vSeeAlso);
        
        END_INTERFACE
    } IADsOVtbl;

    interface IADsO
    {
        CONST_VTBL struct IADsOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsO_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsO_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsO_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsO_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsO_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsO_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsO_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsO_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsO_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsO_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsO_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsO_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsO_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsO_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsO_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsO_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsO_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsO_get_Description(This,retval)	\
    (This)->lpVtbl -> get_Description(This,retval)

#define IADsO_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IADsO_get_LocalityName(This,retval)	\
    (This)->lpVtbl -> get_LocalityName(This,retval)

#define IADsO_put_LocalityName(This,bstrLocalityName)	\
    (This)->lpVtbl -> put_LocalityName(This,bstrLocalityName)

#define IADsO_get_PostalAddress(This,retval)	\
    (This)->lpVtbl -> get_PostalAddress(This,retval)

#define IADsO_put_PostalAddress(This,bstrPostalAddress)	\
    (This)->lpVtbl -> put_PostalAddress(This,bstrPostalAddress)

#define IADsO_get_TelephoneNumber(This,retval)	\
    (This)->lpVtbl -> get_TelephoneNumber(This,retval)

#define IADsO_put_TelephoneNumber(This,bstrTelephoneNumber)	\
    (This)->lpVtbl -> put_TelephoneNumber(This,bstrTelephoneNumber)

#define IADsO_get_FaxNumber(This,retval)	\
    (This)->lpVtbl -> get_FaxNumber(This,retval)

#define IADsO_put_FaxNumber(This,bstrFaxNumber)	\
    (This)->lpVtbl -> put_FaxNumber(This,bstrFaxNumber)

#define IADsO_get_SeeAlso(This,retval)	\
    (This)->lpVtbl -> get_SeeAlso(This,retval)

#define IADsO_put_SeeAlso(This,vSeeAlso)	\
    (This)->lpVtbl -> put_SeeAlso(This,vSeeAlso)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsO_get_Description_Proxy( 
    IADsO * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsO_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsO_put_Description_Proxy( 
    IADsO * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IADsO_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsO_get_LocalityName_Proxy( 
    IADsO * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsO_get_LocalityName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsO_put_LocalityName_Proxy( 
    IADsO * This,
    /* [in] */ BSTR bstrLocalityName);


void __RPC_STUB IADsO_put_LocalityName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsO_get_PostalAddress_Proxy( 
    IADsO * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsO_get_PostalAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsO_put_PostalAddress_Proxy( 
    IADsO * This,
    /* [in] */ BSTR bstrPostalAddress);


void __RPC_STUB IADsO_put_PostalAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsO_get_TelephoneNumber_Proxy( 
    IADsO * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsO_get_TelephoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsO_put_TelephoneNumber_Proxy( 
    IADsO * This,
    /* [in] */ BSTR bstrTelephoneNumber);


void __RPC_STUB IADsO_put_TelephoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsO_get_FaxNumber_Proxy( 
    IADsO * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsO_get_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsO_put_FaxNumber_Proxy( 
    IADsO * This,
    /* [in] */ BSTR bstrFaxNumber);


void __RPC_STUB IADsO_put_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsO_get_SeeAlso_Proxy( 
    IADsO * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsO_get_SeeAlso_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsO_put_SeeAlso_Proxy( 
    IADsO * This,
    /* [in] */ VARIANT vSeeAlso);


void __RPC_STUB IADsO_put_SeeAlso_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsO_INTERFACE_DEFINED__ */


#ifndef __IADsOU_INTERFACE_DEFINED__
#define __IADsOU_INTERFACE_DEFINED__

/* interface IADsOU */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsOU;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a2f733b8-effe-11cf-8abc-00c04fd8d503")
    IADsOU : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LocalityName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LocalityName( 
            /* [in] */ BSTR bstrLocalityName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PostalAddress( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PostalAddress( 
            /* [in] */ BSTR bstrPostalAddress) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_TelephoneNumber( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_TelephoneNumber( 
            /* [in] */ BSTR bstrTelephoneNumber) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FaxNumber( 
            /* [in] */ BSTR bstrFaxNumber) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SeeAlso( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SeeAlso( 
            /* [in] */ VARIANT vSeeAlso) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BusinessCategory( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BusinessCategory( 
            /* [in] */ BSTR bstrBusinessCategory) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsOUVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsOU * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsOU * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsOU * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsOU * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsOU * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsOU * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsOU * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsOU * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsOU * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsOU * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsOU * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsOU * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsOU * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsOU * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsOU * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsOU * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsOU * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsOU * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsOU * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsOU * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IADsOU * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IADsOU * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalityName )( 
            IADsOU * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocalityName )( 
            IADsOU * This,
            /* [in] */ BSTR bstrLocalityName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PostalAddress )( 
            IADsOU * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PostalAddress )( 
            IADsOU * This,
            /* [in] */ BSTR bstrPostalAddress);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TelephoneNumber )( 
            IADsOU * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TelephoneNumber )( 
            IADsOU * This,
            /* [in] */ BSTR bstrTelephoneNumber);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FaxNumber )( 
            IADsOU * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FaxNumber )( 
            IADsOU * This,
            /* [in] */ BSTR bstrFaxNumber);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SeeAlso )( 
            IADsOU * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SeeAlso )( 
            IADsOU * This,
            /* [in] */ VARIANT vSeeAlso);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BusinessCategory )( 
            IADsOU * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BusinessCategory )( 
            IADsOU * This,
            /* [in] */ BSTR bstrBusinessCategory);
        
        END_INTERFACE
    } IADsOUVtbl;

    interface IADsOU
    {
        CONST_VTBL struct IADsOUVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsOU_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsOU_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsOU_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsOU_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsOU_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsOU_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsOU_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsOU_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsOU_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsOU_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsOU_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsOU_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsOU_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsOU_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsOU_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsOU_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsOU_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsOU_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsOU_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsOU_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsOU_get_Description(This,retval)	\
    (This)->lpVtbl -> get_Description(This,retval)

#define IADsOU_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IADsOU_get_LocalityName(This,retval)	\
    (This)->lpVtbl -> get_LocalityName(This,retval)

#define IADsOU_put_LocalityName(This,bstrLocalityName)	\
    (This)->lpVtbl -> put_LocalityName(This,bstrLocalityName)

#define IADsOU_get_PostalAddress(This,retval)	\
    (This)->lpVtbl -> get_PostalAddress(This,retval)

#define IADsOU_put_PostalAddress(This,bstrPostalAddress)	\
    (This)->lpVtbl -> put_PostalAddress(This,bstrPostalAddress)

#define IADsOU_get_TelephoneNumber(This,retval)	\
    (This)->lpVtbl -> get_TelephoneNumber(This,retval)

#define IADsOU_put_TelephoneNumber(This,bstrTelephoneNumber)	\
    (This)->lpVtbl -> put_TelephoneNumber(This,bstrTelephoneNumber)

#define IADsOU_get_FaxNumber(This,retval)	\
    (This)->lpVtbl -> get_FaxNumber(This,retval)

#define IADsOU_put_FaxNumber(This,bstrFaxNumber)	\
    (This)->lpVtbl -> put_FaxNumber(This,bstrFaxNumber)

#define IADsOU_get_SeeAlso(This,retval)	\
    (This)->lpVtbl -> get_SeeAlso(This,retval)

#define IADsOU_put_SeeAlso(This,vSeeAlso)	\
    (This)->lpVtbl -> put_SeeAlso(This,vSeeAlso)

#define IADsOU_get_BusinessCategory(This,retval)	\
    (This)->lpVtbl -> get_BusinessCategory(This,retval)

#define IADsOU_put_BusinessCategory(This,bstrBusinessCategory)	\
    (This)->lpVtbl -> put_BusinessCategory(This,bstrBusinessCategory)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsOU_get_Description_Proxy( 
    IADsOU * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsOU_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsOU_put_Description_Proxy( 
    IADsOU * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IADsOU_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsOU_get_LocalityName_Proxy( 
    IADsOU * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsOU_get_LocalityName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsOU_put_LocalityName_Proxy( 
    IADsOU * This,
    /* [in] */ BSTR bstrLocalityName);


void __RPC_STUB IADsOU_put_LocalityName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsOU_get_PostalAddress_Proxy( 
    IADsOU * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsOU_get_PostalAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsOU_put_PostalAddress_Proxy( 
    IADsOU * This,
    /* [in] */ BSTR bstrPostalAddress);


void __RPC_STUB IADsOU_put_PostalAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsOU_get_TelephoneNumber_Proxy( 
    IADsOU * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsOU_get_TelephoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsOU_put_TelephoneNumber_Proxy( 
    IADsOU * This,
    /* [in] */ BSTR bstrTelephoneNumber);


void __RPC_STUB IADsOU_put_TelephoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsOU_get_FaxNumber_Proxy( 
    IADsOU * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsOU_get_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsOU_put_FaxNumber_Proxy( 
    IADsOU * This,
    /* [in] */ BSTR bstrFaxNumber);


void __RPC_STUB IADsOU_put_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsOU_get_SeeAlso_Proxy( 
    IADsOU * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsOU_get_SeeAlso_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsOU_put_SeeAlso_Proxy( 
    IADsOU * This,
    /* [in] */ VARIANT vSeeAlso);


void __RPC_STUB IADsOU_put_SeeAlso_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsOU_get_BusinessCategory_Proxy( 
    IADsOU * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsOU_get_BusinessCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsOU_put_BusinessCategory_Proxy( 
    IADsOU * This,
    /* [in] */ BSTR bstrBusinessCategory);


void __RPC_STUB IADsOU_put_BusinessCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsOU_INTERFACE_DEFINED__ */


#ifndef __IADsDomain_INTERFACE_DEFINED__
#define __IADsDomain_INTERFACE_DEFINED__

/* interface IADsDomain */
/* [object][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IADsDomain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00e4c220-fd16-11ce-abc4-02608c9e7553")
    IADsDomain : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_IsWorkgroup( 
            /* [retval][out] */ VARIANT_BOOL *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MinPasswordLength( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MinPasswordLength( 
            /* [in] */ long lnMinPasswordLength) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MinPasswordAge( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MinPasswordAge( 
            /* [in] */ long lnMinPasswordAge) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxPasswordAge( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxPasswordAge( 
            /* [in] */ long lnMaxPasswordAge) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxBadPasswordsAllowed( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxBadPasswordsAllowed( 
            /* [in] */ long lnMaxBadPasswordsAllowed) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PasswordHistoryLength( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PasswordHistoryLength( 
            /* [in] */ long lnPasswordHistoryLength) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PasswordAttributes( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PasswordAttributes( 
            /* [in] */ long lnPasswordAttributes) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoUnlockInterval( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoUnlockInterval( 
            /* [in] */ long lnAutoUnlockInterval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LockoutObservationInterval( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LockoutObservationInterval( 
            /* [in] */ long lnLockoutObservationInterval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsDomainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsDomain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsDomain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsDomain * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsDomain * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsDomain * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsDomain * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsDomain * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsDomain * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsDomain * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsDomain * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsDomain * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsDomain * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsDomain * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsDomain * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsDomain * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsDomain * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsDomain * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsDomain * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsDomain * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsWorkgroup )( 
            IADsDomain * This,
            /* [retval][out] */ VARIANT_BOOL *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinPasswordLength )( 
            IADsDomain * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinPasswordLength )( 
            IADsDomain * This,
            /* [in] */ long lnMinPasswordLength);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinPasswordAge )( 
            IADsDomain * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinPasswordAge )( 
            IADsDomain * This,
            /* [in] */ long lnMinPasswordAge);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxPasswordAge )( 
            IADsDomain * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxPasswordAge )( 
            IADsDomain * This,
            /* [in] */ long lnMaxPasswordAge);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxBadPasswordsAllowed )( 
            IADsDomain * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxBadPasswordsAllowed )( 
            IADsDomain * This,
            /* [in] */ long lnMaxBadPasswordsAllowed);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PasswordHistoryLength )( 
            IADsDomain * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PasswordHistoryLength )( 
            IADsDomain * This,
            /* [in] */ long lnPasswordHistoryLength);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PasswordAttributes )( 
            IADsDomain * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PasswordAttributes )( 
            IADsDomain * This,
            /* [in] */ long lnPasswordAttributes);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoUnlockInterval )( 
            IADsDomain * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoUnlockInterval )( 
            IADsDomain * This,
            /* [in] */ long lnAutoUnlockInterval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LockoutObservationInterval )( 
            IADsDomain * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LockoutObservationInterval )( 
            IADsDomain * This,
            /* [in] */ long lnLockoutObservationInterval);
        
        END_INTERFACE
    } IADsDomainVtbl;

    interface IADsDomain
    {
        CONST_VTBL struct IADsDomainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsDomain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsDomain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsDomain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsDomain_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsDomain_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsDomain_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsDomain_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsDomain_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsDomain_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsDomain_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsDomain_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsDomain_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsDomain_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsDomain_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsDomain_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsDomain_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsDomain_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsDomain_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsDomain_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsDomain_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsDomain_get_IsWorkgroup(This,retval)	\
    (This)->lpVtbl -> get_IsWorkgroup(This,retval)

#define IADsDomain_get_MinPasswordLength(This,retval)	\
    (This)->lpVtbl -> get_MinPasswordLength(This,retval)

#define IADsDomain_put_MinPasswordLength(This,lnMinPasswordLength)	\
    (This)->lpVtbl -> put_MinPasswordLength(This,lnMinPasswordLength)

#define IADsDomain_get_MinPasswordAge(This,retval)	\
    (This)->lpVtbl -> get_MinPasswordAge(This,retval)

#define IADsDomain_put_MinPasswordAge(This,lnMinPasswordAge)	\
    (This)->lpVtbl -> put_MinPasswordAge(This,lnMinPasswordAge)

#define IADsDomain_get_MaxPasswordAge(This,retval)	\
    (This)->lpVtbl -> get_MaxPasswordAge(This,retval)

#define IADsDomain_put_MaxPasswordAge(This,lnMaxPasswordAge)	\
    (This)->lpVtbl -> put_MaxPasswordAge(This,lnMaxPasswordAge)

#define IADsDomain_get_MaxBadPasswordsAllowed(This,retval)	\
    (This)->lpVtbl -> get_MaxBadPasswordsAllowed(This,retval)

#define IADsDomain_put_MaxBadPasswordsAllowed(This,lnMaxBadPasswordsAllowed)	\
    (This)->lpVtbl -> put_MaxBadPasswordsAllowed(This,lnMaxBadPasswordsAllowed)

#define IADsDomain_get_PasswordHistoryLength(This,retval)	\
    (This)->lpVtbl -> get_PasswordHistoryLength(This,retval)

#define IADsDomain_put_PasswordHistoryLength(This,lnPasswordHistoryLength)	\
    (This)->lpVtbl -> put_PasswordHistoryLength(This,lnPasswordHistoryLength)

#define IADsDomain_get_PasswordAttributes(This,retval)	\
    (This)->lpVtbl -> get_PasswordAttributes(This,retval)

#define IADsDomain_put_PasswordAttributes(This,lnPasswordAttributes)	\
    (This)->lpVtbl -> put_PasswordAttributes(This,lnPasswordAttributes)

#define IADsDomain_get_AutoUnlockInterval(This,retval)	\
    (This)->lpVtbl -> get_AutoUnlockInterval(This,retval)

#define IADsDomain_put_AutoUnlockInterval(This,lnAutoUnlockInterval)	\
    (This)->lpVtbl -> put_AutoUnlockInterval(This,lnAutoUnlockInterval)

#define IADsDomain_get_LockoutObservationInterval(This,retval)	\
    (This)->lpVtbl -> get_LockoutObservationInterval(This,retval)

#define IADsDomain_put_LockoutObservationInterval(This,lnLockoutObservationInterval)	\
    (This)->lpVtbl -> put_LockoutObservationInterval(This,lnLockoutObservationInterval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsDomain_get_IsWorkgroup_Proxy( 
    IADsDomain * This,
    /* [retval][out] */ VARIANT_BOOL *retval);


void __RPC_STUB IADsDomain_get_IsWorkgroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsDomain_get_MinPasswordLength_Proxy( 
    IADsDomain * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsDomain_get_MinPasswordLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsDomain_put_MinPasswordLength_Proxy( 
    IADsDomain * This,
    /* [in] */ long lnMinPasswordLength);


void __RPC_STUB IADsDomain_put_MinPasswordLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsDomain_get_MinPasswordAge_Proxy( 
    IADsDomain * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsDomain_get_MinPasswordAge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsDomain_put_MinPasswordAge_Proxy( 
    IADsDomain * This,
    /* [in] */ long lnMinPasswordAge);


void __RPC_STUB IADsDomain_put_MinPasswordAge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsDomain_get_MaxPasswordAge_Proxy( 
    IADsDomain * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsDomain_get_MaxPasswordAge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsDomain_put_MaxPasswordAge_Proxy( 
    IADsDomain * This,
    /* [in] */ long lnMaxPasswordAge);


void __RPC_STUB IADsDomain_put_MaxPasswordAge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsDomain_get_MaxBadPasswordsAllowed_Proxy( 
    IADsDomain * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsDomain_get_MaxBadPasswordsAllowed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsDomain_put_MaxBadPasswordsAllowed_Proxy( 
    IADsDomain * This,
    /* [in] */ long lnMaxBadPasswordsAllowed);


void __RPC_STUB IADsDomain_put_MaxBadPasswordsAllowed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsDomain_get_PasswordHistoryLength_Proxy( 
    IADsDomain * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsDomain_get_PasswordHistoryLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsDomain_put_PasswordHistoryLength_Proxy( 
    IADsDomain * This,
    /* [in] */ long lnPasswordHistoryLength);


void __RPC_STUB IADsDomain_put_PasswordHistoryLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsDomain_get_PasswordAttributes_Proxy( 
    IADsDomain * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsDomain_get_PasswordAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsDomain_put_PasswordAttributes_Proxy( 
    IADsDomain * This,
    /* [in] */ long lnPasswordAttributes);


void __RPC_STUB IADsDomain_put_PasswordAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsDomain_get_AutoUnlockInterval_Proxy( 
    IADsDomain * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsDomain_get_AutoUnlockInterval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsDomain_put_AutoUnlockInterval_Proxy( 
    IADsDomain * This,
    /* [in] */ long lnAutoUnlockInterval);


void __RPC_STUB IADsDomain_put_AutoUnlockInterval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsDomain_get_LockoutObservationInterval_Proxy( 
    IADsDomain * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsDomain_get_LockoutObservationInterval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsDomain_put_LockoutObservationInterval_Proxy( 
    IADsDomain * This,
    /* [in] */ long lnLockoutObservationInterval);


void __RPC_STUB IADsDomain_put_LockoutObservationInterval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsDomain_INTERFACE_DEFINED__ */


#ifndef __IADsComputer_INTERFACE_DEFINED__
#define __IADsComputer_INTERFACE_DEFINED__

/* interface IADsComputer */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsComputer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("efe3cc70-1d9f-11cf-b1f3-02608c9e7553")
    IADsComputer : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ComputerID( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Site( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Location( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Location( 
            /* [in] */ BSTR bstrLocation) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PrimaryUser( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PrimaryUser( 
            /* [in] */ BSTR bstrPrimaryUser) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Owner( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Owner( 
            /* [in] */ BSTR bstrOwner) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Division( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Division( 
            /* [in] */ BSTR bstrDivision) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Department( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Department( 
            /* [in] */ BSTR bstrDepartment) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Role( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Role( 
            /* [in] */ BSTR bstrRole) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OperatingSystem( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OperatingSystem( 
            /* [in] */ BSTR bstrOperatingSystem) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OperatingSystemVersion( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OperatingSystemVersion( 
            /* [in] */ BSTR bstrOperatingSystemVersion) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Model( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Model( 
            /* [in] */ BSTR bstrModel) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Processor( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Processor( 
            /* [in] */ BSTR bstrProcessor) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ProcessorCount( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ProcessorCount( 
            /* [in] */ BSTR bstrProcessorCount) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MemorySize( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MemorySize( 
            /* [in] */ BSTR bstrMemorySize) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StorageCapacity( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StorageCapacity( 
            /* [in] */ BSTR bstrStorageCapacity) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_NetAddresses( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_NetAddresses( 
            /* [in] */ VARIANT vNetAddresses) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsComputerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsComputer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsComputer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsComputer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsComputer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsComputer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsComputer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsComputer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsComputer * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsComputer * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsComputer * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsComputer * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ComputerID )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Site )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Location )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Location )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrLocation);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrimaryUser )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrimaryUser )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrPrimaryUser);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Owner )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Owner )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrOwner);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Division )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Division )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrDivision);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Department )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Department )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrDepartment);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Role )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Role )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrRole);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OperatingSystem )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OperatingSystem )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrOperatingSystem);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OperatingSystemVersion )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OperatingSystemVersion )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrOperatingSystemVersion);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Model )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Model )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrModel);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Processor )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Processor )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrProcessor);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProcessorCount )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProcessorCount )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrProcessorCount);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemorySize )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MemorySize )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrMemorySize);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StorageCapacity )( 
            IADsComputer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StorageCapacity )( 
            IADsComputer * This,
            /* [in] */ BSTR bstrStorageCapacity);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetAddresses )( 
            IADsComputer * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_NetAddresses )( 
            IADsComputer * This,
            /* [in] */ VARIANT vNetAddresses);
        
        END_INTERFACE
    } IADsComputerVtbl;

    interface IADsComputer
    {
        CONST_VTBL struct IADsComputerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsComputer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsComputer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsComputer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsComputer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsComputer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsComputer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsComputer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsComputer_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsComputer_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsComputer_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsComputer_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsComputer_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsComputer_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsComputer_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsComputer_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsComputer_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsComputer_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsComputer_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsComputer_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsComputer_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsComputer_get_ComputerID(This,retval)	\
    (This)->lpVtbl -> get_ComputerID(This,retval)

#define IADsComputer_get_Site(This,retval)	\
    (This)->lpVtbl -> get_Site(This,retval)

#define IADsComputer_get_Description(This,retval)	\
    (This)->lpVtbl -> get_Description(This,retval)

#define IADsComputer_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IADsComputer_get_Location(This,retval)	\
    (This)->lpVtbl -> get_Location(This,retval)

#define IADsComputer_put_Location(This,bstrLocation)	\
    (This)->lpVtbl -> put_Location(This,bstrLocation)

#define IADsComputer_get_PrimaryUser(This,retval)	\
    (This)->lpVtbl -> get_PrimaryUser(This,retval)

#define IADsComputer_put_PrimaryUser(This,bstrPrimaryUser)	\
    (This)->lpVtbl -> put_PrimaryUser(This,bstrPrimaryUser)

#define IADsComputer_get_Owner(This,retval)	\
    (This)->lpVtbl -> get_Owner(This,retval)

#define IADsComputer_put_Owner(This,bstrOwner)	\
    (This)->lpVtbl -> put_Owner(This,bstrOwner)

#define IADsComputer_get_Division(This,retval)	\
    (This)->lpVtbl -> get_Division(This,retval)

#define IADsComputer_put_Division(This,bstrDivision)	\
    (This)->lpVtbl -> put_Division(This,bstrDivision)

#define IADsComputer_get_Department(This,retval)	\
    (This)->lpVtbl -> get_Department(This,retval)

#define IADsComputer_put_Department(This,bstrDepartment)	\
    (This)->lpVtbl -> put_Department(This,bstrDepartment)

#define IADsComputer_get_Role(This,retval)	\
    (This)->lpVtbl -> get_Role(This,retval)

#define IADsComputer_put_Role(This,bstrRole)	\
    (This)->lpVtbl -> put_Role(This,bstrRole)

#define IADsComputer_get_OperatingSystem(This,retval)	\
    (This)->lpVtbl -> get_OperatingSystem(This,retval)

#define IADsComputer_put_OperatingSystem(This,bstrOperatingSystem)	\
    (This)->lpVtbl -> put_OperatingSystem(This,bstrOperatingSystem)

#define IADsComputer_get_OperatingSystemVersion(This,retval)	\
    (This)->lpVtbl -> get_OperatingSystemVersion(This,retval)

#define IADsComputer_put_OperatingSystemVersion(This,bstrOperatingSystemVersion)	\
    (This)->lpVtbl -> put_OperatingSystemVersion(This,bstrOperatingSystemVersion)

#define IADsComputer_get_Model(This,retval)	\
    (This)->lpVtbl -> get_Model(This,retval)

#define IADsComputer_put_Model(This,bstrModel)	\
    (This)->lpVtbl -> put_Model(This,bstrModel)

#define IADsComputer_get_Processor(This,retval)	\
    (This)->lpVtbl -> get_Processor(This,retval)

#define IADsComputer_put_Processor(This,bstrProcessor)	\
    (This)->lpVtbl -> put_Processor(This,bstrProcessor)

#define IADsComputer_get_ProcessorCount(This,retval)	\
    (This)->lpVtbl -> get_ProcessorCount(This,retval)

#define IADsComputer_put_ProcessorCount(This,bstrProcessorCount)	\
    (This)->lpVtbl -> put_ProcessorCount(This,bstrProcessorCount)

#define IADsComputer_get_MemorySize(This,retval)	\
    (This)->lpVtbl -> get_MemorySize(This,retval)

#define IADsComputer_put_MemorySize(This,bstrMemorySize)	\
    (This)->lpVtbl -> put_MemorySize(This,bstrMemorySize)

#define IADsComputer_get_StorageCapacity(This,retval)	\
    (This)->lpVtbl -> get_StorageCapacity(This,retval)

#define IADsComputer_put_StorageCapacity(This,bstrStorageCapacity)	\
    (This)->lpVtbl -> put_StorageCapacity(This,bstrStorageCapacity)

#define IADsComputer_get_NetAddresses(This,retval)	\
    (This)->lpVtbl -> get_NetAddresses(This,retval)

#define IADsComputer_put_NetAddresses(This,vNetAddresses)	\
    (This)->lpVtbl -> put_NetAddresses(This,vNetAddresses)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_ComputerID_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_ComputerID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_Site_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_Site_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_Description_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_Description_Proxy( 
    IADsComputer * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IADsComputer_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_Location_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_Location_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_Location_Proxy( 
    IADsComputer * This,
    /* [in] */ BSTR bstrLocation);


void __RPC_STUB IADsComputer_put_Location_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_PrimaryUser_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_PrimaryUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_PrimaryUser_Proxy( 
    IADsComputer * This,
    /* [in] */ BSTR bstrPrimaryUser);


void __RPC_STUB IADsComputer_put_PrimaryUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_Owner_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_Owner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_Owner_Proxy( 
    IADsComputer * This,
    /* [in] */ BSTR bstrOwner);


void __RPC_STUB IADsComputer_put_Owner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_Division_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_Division_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_Division_Proxy( 
    IADsComputer * This,
    /* [in] */ BSTR bstrDivision);


void __RPC_STUB IADsComputer_put_Division_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_Department_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_Department_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_Department_Proxy( 
    IADsComputer * This,
    /* [in] */ BSTR bstrDepartment);


void __RPC_STUB IADsComputer_put_Department_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_Role_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_Role_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_Role_Proxy( 
    IADsComputer * This,
    /* [in] */ BSTR bstrRole);


void __RPC_STUB IADsComputer_put_Role_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_OperatingSystem_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_OperatingSystem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_OperatingSystem_Proxy( 
    IADsComputer * This,
    /* [in] */ BSTR bstrOperatingSystem);


void __RPC_STUB IADsComputer_put_OperatingSystem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_OperatingSystemVersion_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_OperatingSystemVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_OperatingSystemVersion_Proxy( 
    IADsComputer * This,
    /* [in] */ BSTR bstrOperatingSystemVersion);


void __RPC_STUB IADsComputer_put_OperatingSystemVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_Model_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_Model_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_Model_Proxy( 
    IADsComputer * This,
    /* [in] */ BSTR bstrModel);


void __RPC_STUB IADsComputer_put_Model_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_Processor_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_Processor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_Processor_Proxy( 
    IADsComputer * This,
    /* [in] */ BSTR bstrProcessor);


void __RPC_STUB IADsComputer_put_Processor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_ProcessorCount_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_ProcessorCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_ProcessorCount_Proxy( 
    IADsComputer * This,
    /* [in] */ BSTR bstrProcessorCount);


void __RPC_STUB IADsComputer_put_ProcessorCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_MemorySize_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_MemorySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_MemorySize_Proxy( 
    IADsComputer * This,
    /* [in] */ BSTR bstrMemorySize);


void __RPC_STUB IADsComputer_put_MemorySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_StorageCapacity_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsComputer_get_StorageCapacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_StorageCapacity_Proxy( 
    IADsComputer * This,
    /* [in] */ BSTR bstrStorageCapacity);


void __RPC_STUB IADsComputer_put_StorageCapacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsComputer_get_NetAddresses_Proxy( 
    IADsComputer * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsComputer_get_NetAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsComputer_put_NetAddresses_Proxy( 
    IADsComputer * This,
    /* [in] */ VARIANT vNetAddresses);


void __RPC_STUB IADsComputer_put_NetAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsComputer_INTERFACE_DEFINED__ */


#ifndef __IADsComputerOperations_INTERFACE_DEFINED__
#define __IADsComputerOperations_INTERFACE_DEFINED__

/* interface IADsComputerOperations */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsComputerOperations;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ef497680-1d9f-11cf-b1f3-02608c9e7553")
    IADsComputerOperations : public IADs
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Status( 
            /* [retval][out] */ IDispatch **ppObject) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Shutdown( 
            /* [in] */ VARIANT_BOOL bReboot) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsComputerOperationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsComputerOperations * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsComputerOperations * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsComputerOperations * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsComputerOperations * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsComputerOperations * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsComputerOperations * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsComputerOperations * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsComputerOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsComputerOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsComputerOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsComputerOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsComputerOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsComputerOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsComputerOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsComputerOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsComputerOperations * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsComputerOperations * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsComputerOperations * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsComputerOperations * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsComputerOperations * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Status )( 
            IADsComputerOperations * This,
            /* [retval][out] */ IDispatch **ppObject);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IADsComputerOperations * This,
            /* [in] */ VARIANT_BOOL bReboot);
        
        END_INTERFACE
    } IADsComputerOperationsVtbl;

    interface IADsComputerOperations
    {
        CONST_VTBL struct IADsComputerOperationsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsComputerOperations_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsComputerOperations_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsComputerOperations_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsComputerOperations_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsComputerOperations_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsComputerOperations_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsComputerOperations_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsComputerOperations_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsComputerOperations_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsComputerOperations_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsComputerOperations_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsComputerOperations_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsComputerOperations_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsComputerOperations_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsComputerOperations_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsComputerOperations_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsComputerOperations_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsComputerOperations_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsComputerOperations_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsComputerOperations_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsComputerOperations_Status(This,ppObject)	\
    (This)->lpVtbl -> Status(This,ppObject)

#define IADsComputerOperations_Shutdown(This,bReboot)	\
    (This)->lpVtbl -> Shutdown(This,bReboot)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IADsComputerOperations_Status_Proxy( 
    IADsComputerOperations * This,
    /* [retval][out] */ IDispatch **ppObject);


void __RPC_STUB IADsComputerOperations_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsComputerOperations_Shutdown_Proxy( 
    IADsComputerOperations * This,
    /* [in] */ VARIANT_BOOL bReboot);


void __RPC_STUB IADsComputerOperations_Shutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsComputerOperations_INTERFACE_DEFINED__ */


#ifndef __IADsGroup_INTERFACE_DEFINED__
#define __IADsGroup_INTERFACE_DEFINED__

/* interface IADsGroup */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27636b00-410f-11cf-b1ff-02608c9e7553")
    IADsGroup : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Members( 
            /* [retval][out] */ IADsMembers **ppMembers) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsMember( 
            /* [in] */ BSTR bstrMember,
            /* [retval][out] */ VARIANT_BOOL *bMember) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrNewItem) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ BSTR bstrItemToBeRemoved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsGroup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsGroup * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsGroup * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsGroup * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsGroup * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsGroup * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsGroup * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsGroup * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsGroup * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsGroup * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsGroup * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsGroup * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsGroup * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsGroup * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsGroup * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsGroup * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsGroup * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsGroup * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IADsGroup * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IADsGroup * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Members )( 
            IADsGroup * This,
            /* [retval][out] */ IADsMembers **ppMembers);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsMember )( 
            IADsGroup * This,
            /* [in] */ BSTR bstrMember,
            /* [retval][out] */ VARIANT_BOOL *bMember);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IADsGroup * This,
            /* [in] */ BSTR bstrNewItem);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IADsGroup * This,
            /* [in] */ BSTR bstrItemToBeRemoved);
        
        END_INTERFACE
    } IADsGroupVtbl;

    interface IADsGroup
    {
        CONST_VTBL struct IADsGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsGroup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsGroup_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsGroup_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsGroup_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsGroup_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsGroup_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsGroup_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsGroup_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsGroup_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsGroup_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsGroup_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsGroup_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsGroup_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsGroup_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsGroup_get_Description(This,retval)	\
    (This)->lpVtbl -> get_Description(This,retval)

#define IADsGroup_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IADsGroup_Members(This,ppMembers)	\
    (This)->lpVtbl -> Members(This,ppMembers)

#define IADsGroup_IsMember(This,bstrMember,bMember)	\
    (This)->lpVtbl -> IsMember(This,bstrMember,bMember)

#define IADsGroup_Add(This,bstrNewItem)	\
    (This)->lpVtbl -> Add(This,bstrNewItem)

#define IADsGroup_Remove(This,bstrItemToBeRemoved)	\
    (This)->lpVtbl -> Remove(This,bstrItemToBeRemoved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsGroup_get_Description_Proxy( 
    IADsGroup * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsGroup_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsGroup_put_Description_Proxy( 
    IADsGroup * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IADsGroup_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsGroup_Members_Proxy( 
    IADsGroup * This,
    /* [retval][out] */ IADsMembers **ppMembers);


void __RPC_STUB IADsGroup_Members_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsGroup_IsMember_Proxy( 
    IADsGroup * This,
    /* [in] */ BSTR bstrMember,
    /* [retval][out] */ VARIANT_BOOL *bMember);


void __RPC_STUB IADsGroup_IsMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsGroup_Add_Proxy( 
    IADsGroup * This,
    /* [in] */ BSTR bstrNewItem);


void __RPC_STUB IADsGroup_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsGroup_Remove_Proxy( 
    IADsGroup * This,
    /* [in] */ BSTR bstrItemToBeRemoved);


void __RPC_STUB IADsGroup_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsGroup_INTERFACE_DEFINED__ */


#ifndef __IADsUser_INTERFACE_DEFINED__
#define __IADsUser_INTERFACE_DEFINED__

/* interface IADsUser */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3e37e320-17e2-11cf-abc4-02608c9e7553")
    IADsUser : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BadLoginAddress( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BadLoginCount( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LastLogin( 
            /* [retval][out] */ DATE *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LastLogoff( 
            /* [retval][out] */ DATE *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LastFailedLogin( 
            /* [retval][out] */ DATE *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PasswordLastChanged( 
            /* [retval][out] */ DATE *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Division( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Division( 
            /* [in] */ BSTR bstrDivision) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Department( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Department( 
            /* [in] */ BSTR bstrDepartment) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_EmployeeID( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EmployeeID( 
            /* [in] */ BSTR bstrEmployeeID) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FullName( 
            /* [in] */ BSTR bstrFullName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FirstName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FirstName( 
            /* [in] */ BSTR bstrFirstName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LastName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LastName( 
            /* [in] */ BSTR bstrLastName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OtherName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OtherName( 
            /* [in] */ BSTR bstrOtherName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_NamePrefix( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_NamePrefix( 
            /* [in] */ BSTR bstrNamePrefix) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_NameSuffix( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_NameSuffix( 
            /* [in] */ BSTR bstrNameSuffix) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Title( 
            /* [in] */ BSTR bstrTitle) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Manager( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Manager( 
            /* [in] */ BSTR bstrManager) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_TelephoneHome( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_TelephoneHome( 
            /* [in] */ VARIANT vTelephoneHome) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_TelephoneMobile( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_TelephoneMobile( 
            /* [in] */ VARIANT vTelephoneMobile) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_TelephoneNumber( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_TelephoneNumber( 
            /* [in] */ VARIANT vTelephoneNumber) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_TelephonePager( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_TelephonePager( 
            /* [in] */ VARIANT vTelephonePager) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FaxNumber( 
            /* [in] */ VARIANT vFaxNumber) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OfficeLocations( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OfficeLocations( 
            /* [in] */ VARIANT vOfficeLocations) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PostalAddresses( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PostalAddresses( 
            /* [in] */ VARIANT vPostalAddresses) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PostalCodes( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PostalCodes( 
            /* [in] */ VARIANT vPostalCodes) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SeeAlso( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SeeAlso( 
            /* [in] */ VARIANT vSeeAlso) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AccountDisabled( 
            /* [retval][out] */ VARIANT_BOOL *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AccountDisabled( 
            /* [in] */ VARIANT_BOOL fAccountDisabled) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AccountExpirationDate( 
            /* [retval][out] */ DATE *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AccountExpirationDate( 
            /* [in] */ DATE daAccountExpirationDate) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GraceLoginsAllowed( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GraceLoginsAllowed( 
            /* [in] */ long lnGraceLoginsAllowed) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GraceLoginsRemaining( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GraceLoginsRemaining( 
            /* [in] */ long lnGraceLoginsRemaining) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_IsAccountLocked( 
            /* [retval][out] */ VARIANT_BOOL *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_IsAccountLocked( 
            /* [in] */ VARIANT_BOOL fIsAccountLocked) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LoginHours( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LoginHours( 
            /* [in] */ VARIANT vLoginHours) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LoginWorkstations( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LoginWorkstations( 
            /* [in] */ VARIANT vLoginWorkstations) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxLogins( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxLogins( 
            /* [in] */ long lnMaxLogins) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxStorage( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxStorage( 
            /* [in] */ long lnMaxStorage) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PasswordExpirationDate( 
            /* [retval][out] */ DATE *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PasswordExpirationDate( 
            /* [in] */ DATE daPasswordExpirationDate) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PasswordMinimumLength( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PasswordMinimumLength( 
            /* [in] */ long lnPasswordMinimumLength) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PasswordRequired( 
            /* [retval][out] */ VARIANT_BOOL *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PasswordRequired( 
            /* [in] */ VARIANT_BOOL fPasswordRequired) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_RequireUniquePassword( 
            /* [retval][out] */ VARIANT_BOOL *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_RequireUniquePassword( 
            /* [in] */ VARIANT_BOOL fRequireUniquePassword) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_EmailAddress( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EmailAddress( 
            /* [in] */ BSTR bstrEmailAddress) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HomeDirectory( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_HomeDirectory( 
            /* [in] */ BSTR bstrHomeDirectory) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Languages( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Languages( 
            /* [in] */ VARIANT vLanguages) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Profile( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Profile( 
            /* [in] */ BSTR bstrProfile) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LoginScript( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LoginScript( 
            /* [in] */ BSTR bstrLoginScript) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Picture( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Picture( 
            /* [in] */ VARIANT vPicture) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HomePage( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_HomePage( 
            /* [in] */ BSTR bstrHomePage) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Groups( 
            /* [retval][out] */ IADsMembers **ppGroups) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetPassword( 
            /* [in] */ BSTR NewPassword) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ChangePassword( 
            /* [in] */ BSTR bstrOldPassword,
            /* [in] */ BSTR bstrNewPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsUser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsUser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsUser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsUser * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsUser * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsUser * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsUser * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsUser * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsUser * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsUser * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsUser * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsUser * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsUser * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsUser * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BadLoginAddress )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BadLoginCount )( 
            IADsUser * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastLogin )( 
            IADsUser * This,
            /* [retval][out] */ DATE *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastLogoff )( 
            IADsUser * This,
            /* [retval][out] */ DATE *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastFailedLogin )( 
            IADsUser * This,
            /* [retval][out] */ DATE *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PasswordLastChanged )( 
            IADsUser * This,
            /* [retval][out] */ DATE *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IADsUser * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Division )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Division )( 
            IADsUser * This,
            /* [in] */ BSTR bstrDivision);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Department )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Department )( 
            IADsUser * This,
            /* [in] */ BSTR bstrDepartment);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EmployeeID )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EmployeeID )( 
            IADsUser * This,
            /* [in] */ BSTR bstrEmployeeID);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FullName )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FullName )( 
            IADsUser * This,
            /* [in] */ BSTR bstrFullName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FirstName )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FirstName )( 
            IADsUser * This,
            /* [in] */ BSTR bstrFirstName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastName )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LastName )( 
            IADsUser * This,
            /* [in] */ BSTR bstrLastName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OtherName )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OtherName )( 
            IADsUser * This,
            /* [in] */ BSTR bstrOtherName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NamePrefix )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_NamePrefix )( 
            IADsUser * This,
            /* [in] */ BSTR bstrNamePrefix);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NameSuffix )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_NameSuffix )( 
            IADsUser * This,
            /* [in] */ BSTR bstrNameSuffix);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Title )( 
            IADsUser * This,
            /* [in] */ BSTR bstrTitle);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Manager )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Manager )( 
            IADsUser * This,
            /* [in] */ BSTR bstrManager);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TelephoneHome )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TelephoneHome )( 
            IADsUser * This,
            /* [in] */ VARIANT vTelephoneHome);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TelephoneMobile )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TelephoneMobile )( 
            IADsUser * This,
            /* [in] */ VARIANT vTelephoneMobile);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TelephoneNumber )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TelephoneNumber )( 
            IADsUser * This,
            /* [in] */ VARIANT vTelephoneNumber);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TelephonePager )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TelephonePager )( 
            IADsUser * This,
            /* [in] */ VARIANT vTelephonePager);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FaxNumber )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FaxNumber )( 
            IADsUser * This,
            /* [in] */ VARIANT vFaxNumber);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OfficeLocations )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OfficeLocations )( 
            IADsUser * This,
            /* [in] */ VARIANT vOfficeLocations);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PostalAddresses )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PostalAddresses )( 
            IADsUser * This,
            /* [in] */ VARIANT vPostalAddresses);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PostalCodes )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PostalCodes )( 
            IADsUser * This,
            /* [in] */ VARIANT vPostalCodes);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SeeAlso )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SeeAlso )( 
            IADsUser * This,
            /* [in] */ VARIANT vSeeAlso);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AccountDisabled )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT_BOOL *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AccountDisabled )( 
            IADsUser * This,
            /* [in] */ VARIANT_BOOL fAccountDisabled);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AccountExpirationDate )( 
            IADsUser * This,
            /* [retval][out] */ DATE *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AccountExpirationDate )( 
            IADsUser * This,
            /* [in] */ DATE daAccountExpirationDate);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GraceLoginsAllowed )( 
            IADsUser * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GraceLoginsAllowed )( 
            IADsUser * This,
            /* [in] */ long lnGraceLoginsAllowed);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GraceLoginsRemaining )( 
            IADsUser * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GraceLoginsRemaining )( 
            IADsUser * This,
            /* [in] */ long lnGraceLoginsRemaining);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsAccountLocked )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT_BOOL *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IsAccountLocked )( 
            IADsUser * This,
            /* [in] */ VARIANT_BOOL fIsAccountLocked);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoginHours )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoginHours )( 
            IADsUser * This,
            /* [in] */ VARIANT vLoginHours);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoginWorkstations )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoginWorkstations )( 
            IADsUser * This,
            /* [in] */ VARIANT vLoginWorkstations);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxLogins )( 
            IADsUser * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxLogins )( 
            IADsUser * This,
            /* [in] */ long lnMaxLogins);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxStorage )( 
            IADsUser * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxStorage )( 
            IADsUser * This,
            /* [in] */ long lnMaxStorage);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PasswordExpirationDate )( 
            IADsUser * This,
            /* [retval][out] */ DATE *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PasswordExpirationDate )( 
            IADsUser * This,
            /* [in] */ DATE daPasswordExpirationDate);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PasswordMinimumLength )( 
            IADsUser * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PasswordMinimumLength )( 
            IADsUser * This,
            /* [in] */ long lnPasswordMinimumLength);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PasswordRequired )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT_BOOL *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PasswordRequired )( 
            IADsUser * This,
            /* [in] */ VARIANT_BOOL fPasswordRequired);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequireUniquePassword )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT_BOOL *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequireUniquePassword )( 
            IADsUser * This,
            /* [in] */ VARIANT_BOOL fRequireUniquePassword);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EmailAddress )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EmailAddress )( 
            IADsUser * This,
            /* [in] */ BSTR bstrEmailAddress);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HomeDirectory )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HomeDirectory )( 
            IADsUser * This,
            /* [in] */ BSTR bstrHomeDirectory);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Languages )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Languages )( 
            IADsUser * This,
            /* [in] */ VARIANT vLanguages);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Profile )( 
            IADsUser * This,
            /* [in] */ BSTR bstrProfile);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoginScript )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoginScript )( 
            IADsUser * This,
            /* [in] */ BSTR bstrLoginScript);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Picture )( 
            IADsUser * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Picture )( 
            IADsUser * This,
            /* [in] */ VARIANT vPicture);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HomePage )( 
            IADsUser * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HomePage )( 
            IADsUser * This,
            /* [in] */ BSTR bstrHomePage);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Groups )( 
            IADsUser * This,
            /* [retval][out] */ IADsMembers **ppGroups);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetPassword )( 
            IADsUser * This,
            /* [in] */ BSTR NewPassword);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ChangePassword )( 
            IADsUser * This,
            /* [in] */ BSTR bstrOldPassword,
            /* [in] */ BSTR bstrNewPassword);
        
        END_INTERFACE
    } IADsUserVtbl;

    interface IADsUser
    {
        CONST_VTBL struct IADsUserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsUser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsUser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsUser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsUser_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsUser_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsUser_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsUser_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsUser_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsUser_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsUser_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsUser_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsUser_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsUser_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsUser_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsUser_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsUser_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsUser_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsUser_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsUser_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsUser_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsUser_get_BadLoginAddress(This,retval)	\
    (This)->lpVtbl -> get_BadLoginAddress(This,retval)

#define IADsUser_get_BadLoginCount(This,retval)	\
    (This)->lpVtbl -> get_BadLoginCount(This,retval)

#define IADsUser_get_LastLogin(This,retval)	\
    (This)->lpVtbl -> get_LastLogin(This,retval)

#define IADsUser_get_LastLogoff(This,retval)	\
    (This)->lpVtbl -> get_LastLogoff(This,retval)

#define IADsUser_get_LastFailedLogin(This,retval)	\
    (This)->lpVtbl -> get_LastFailedLogin(This,retval)

#define IADsUser_get_PasswordLastChanged(This,retval)	\
    (This)->lpVtbl -> get_PasswordLastChanged(This,retval)

#define IADsUser_get_Description(This,retval)	\
    (This)->lpVtbl -> get_Description(This,retval)

#define IADsUser_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IADsUser_get_Division(This,retval)	\
    (This)->lpVtbl -> get_Division(This,retval)

#define IADsUser_put_Division(This,bstrDivision)	\
    (This)->lpVtbl -> put_Division(This,bstrDivision)

#define IADsUser_get_Department(This,retval)	\
    (This)->lpVtbl -> get_Department(This,retval)

#define IADsUser_put_Department(This,bstrDepartment)	\
    (This)->lpVtbl -> put_Department(This,bstrDepartment)

#define IADsUser_get_EmployeeID(This,retval)	\
    (This)->lpVtbl -> get_EmployeeID(This,retval)

#define IADsUser_put_EmployeeID(This,bstrEmployeeID)	\
    (This)->lpVtbl -> put_EmployeeID(This,bstrEmployeeID)

#define IADsUser_get_FullName(This,retval)	\
    (This)->lpVtbl -> get_FullName(This,retval)

#define IADsUser_put_FullName(This,bstrFullName)	\
    (This)->lpVtbl -> put_FullName(This,bstrFullName)

#define IADsUser_get_FirstName(This,retval)	\
    (This)->lpVtbl -> get_FirstName(This,retval)

#define IADsUser_put_FirstName(This,bstrFirstName)	\
    (This)->lpVtbl -> put_FirstName(This,bstrFirstName)

#define IADsUser_get_LastName(This,retval)	\
    (This)->lpVtbl -> get_LastName(This,retval)

#define IADsUser_put_LastName(This,bstrLastName)	\
    (This)->lpVtbl -> put_LastName(This,bstrLastName)

#define IADsUser_get_OtherName(This,retval)	\
    (This)->lpVtbl -> get_OtherName(This,retval)

#define IADsUser_put_OtherName(This,bstrOtherName)	\
    (This)->lpVtbl -> put_OtherName(This,bstrOtherName)

#define IADsUser_get_NamePrefix(This,retval)	\
    (This)->lpVtbl -> get_NamePrefix(This,retval)

#define IADsUser_put_NamePrefix(This,bstrNamePrefix)	\
    (This)->lpVtbl -> put_NamePrefix(This,bstrNamePrefix)

#define IADsUser_get_NameSuffix(This,retval)	\
    (This)->lpVtbl -> get_NameSuffix(This,retval)

#define IADsUser_put_NameSuffix(This,bstrNameSuffix)	\
    (This)->lpVtbl -> put_NameSuffix(This,bstrNameSuffix)

#define IADsUser_get_Title(This,retval)	\
    (This)->lpVtbl -> get_Title(This,retval)

#define IADsUser_put_Title(This,bstrTitle)	\
    (This)->lpVtbl -> put_Title(This,bstrTitle)

#define IADsUser_get_Manager(This,retval)	\
    (This)->lpVtbl -> get_Manager(This,retval)

#define IADsUser_put_Manager(This,bstrManager)	\
    (This)->lpVtbl -> put_Manager(This,bstrManager)

#define IADsUser_get_TelephoneHome(This,retval)	\
    (This)->lpVtbl -> get_TelephoneHome(This,retval)

#define IADsUser_put_TelephoneHome(This,vTelephoneHome)	\
    (This)->lpVtbl -> put_TelephoneHome(This,vTelephoneHome)

#define IADsUser_get_TelephoneMobile(This,retval)	\
    (This)->lpVtbl -> get_TelephoneMobile(This,retval)

#define IADsUser_put_TelephoneMobile(This,vTelephoneMobile)	\
    (This)->lpVtbl -> put_TelephoneMobile(This,vTelephoneMobile)

#define IADsUser_get_TelephoneNumber(This,retval)	\
    (This)->lpVtbl -> get_TelephoneNumber(This,retval)

#define IADsUser_put_TelephoneNumber(This,vTelephoneNumber)	\
    (This)->lpVtbl -> put_TelephoneNumber(This,vTelephoneNumber)

#define IADsUser_get_TelephonePager(This,retval)	\
    (This)->lpVtbl -> get_TelephonePager(This,retval)

#define IADsUser_put_TelephonePager(This,vTelephonePager)	\
    (This)->lpVtbl -> put_TelephonePager(This,vTelephonePager)

#define IADsUser_get_FaxNumber(This,retval)	\
    (This)->lpVtbl -> get_FaxNumber(This,retval)

#define IADsUser_put_FaxNumber(This,vFaxNumber)	\
    (This)->lpVtbl -> put_FaxNumber(This,vFaxNumber)

#define IADsUser_get_OfficeLocations(This,retval)	\
    (This)->lpVtbl -> get_OfficeLocations(This,retval)

#define IADsUser_put_OfficeLocations(This,vOfficeLocations)	\
    (This)->lpVtbl -> put_OfficeLocations(This,vOfficeLocations)

#define IADsUser_get_PostalAddresses(This,retval)	\
    (This)->lpVtbl -> get_PostalAddresses(This,retval)

#define IADsUser_put_PostalAddresses(This,vPostalAddresses)	\
    (This)->lpVtbl -> put_PostalAddresses(This,vPostalAddresses)

#define IADsUser_get_PostalCodes(This,retval)	\
    (This)->lpVtbl -> get_PostalCodes(This,retval)

#define IADsUser_put_PostalCodes(This,vPostalCodes)	\
    (This)->lpVtbl -> put_PostalCodes(This,vPostalCodes)

#define IADsUser_get_SeeAlso(This,retval)	\
    (This)->lpVtbl -> get_SeeAlso(This,retval)

#define IADsUser_put_SeeAlso(This,vSeeAlso)	\
    (This)->lpVtbl -> put_SeeAlso(This,vSeeAlso)

#define IADsUser_get_AccountDisabled(This,retval)	\
    (This)->lpVtbl -> get_AccountDisabled(This,retval)

#define IADsUser_put_AccountDisabled(This,fAccountDisabled)	\
    (This)->lpVtbl -> put_AccountDisabled(This,fAccountDisabled)

#define IADsUser_get_AccountExpirationDate(This,retval)	\
    (This)->lpVtbl -> get_AccountExpirationDate(This,retval)

#define IADsUser_put_AccountExpirationDate(This,daAccountExpirationDate)	\
    (This)->lpVtbl -> put_AccountExpirationDate(This,daAccountExpirationDate)

#define IADsUser_get_GraceLoginsAllowed(This,retval)	\
    (This)->lpVtbl -> get_GraceLoginsAllowed(This,retval)

#define IADsUser_put_GraceLoginsAllowed(This,lnGraceLoginsAllowed)	\
    (This)->lpVtbl -> put_GraceLoginsAllowed(This,lnGraceLoginsAllowed)

#define IADsUser_get_GraceLoginsRemaining(This,retval)	\
    (This)->lpVtbl -> get_GraceLoginsRemaining(This,retval)

#define IADsUser_put_GraceLoginsRemaining(This,lnGraceLoginsRemaining)	\
    (This)->lpVtbl -> put_GraceLoginsRemaining(This,lnGraceLoginsRemaining)

#define IADsUser_get_IsAccountLocked(This,retval)	\
    (This)->lpVtbl -> get_IsAccountLocked(This,retval)

#define IADsUser_put_IsAccountLocked(This,fIsAccountLocked)	\
    (This)->lpVtbl -> put_IsAccountLocked(This,fIsAccountLocked)

#define IADsUser_get_LoginHours(This,retval)	\
    (This)->lpVtbl -> get_LoginHours(This,retval)

#define IADsUser_put_LoginHours(This,vLoginHours)	\
    (This)->lpVtbl -> put_LoginHours(This,vLoginHours)

#define IADsUser_get_LoginWorkstations(This,retval)	\
    (This)->lpVtbl -> get_LoginWorkstations(This,retval)

#define IADsUser_put_LoginWorkstations(This,vLoginWorkstations)	\
    (This)->lpVtbl -> put_LoginWorkstations(This,vLoginWorkstations)

#define IADsUser_get_MaxLogins(This,retval)	\
    (This)->lpVtbl -> get_MaxLogins(This,retval)

#define IADsUser_put_MaxLogins(This,lnMaxLogins)	\
    (This)->lpVtbl -> put_MaxLogins(This,lnMaxLogins)

#define IADsUser_get_MaxStorage(This,retval)	\
    (This)->lpVtbl -> get_MaxStorage(This,retval)

#define IADsUser_put_MaxStorage(This,lnMaxStorage)	\
    (This)->lpVtbl -> put_MaxStorage(This,lnMaxStorage)

#define IADsUser_get_PasswordExpirationDate(This,retval)	\
    (This)->lpVtbl -> get_PasswordExpirationDate(This,retval)

#define IADsUser_put_PasswordExpirationDate(This,daPasswordExpirationDate)	\
    (This)->lpVtbl -> put_PasswordExpirationDate(This,daPasswordExpirationDate)

#define IADsUser_get_PasswordMinimumLength(This,retval)	\
    (This)->lpVtbl -> get_PasswordMinimumLength(This,retval)

#define IADsUser_put_PasswordMinimumLength(This,lnPasswordMinimumLength)	\
    (This)->lpVtbl -> put_PasswordMinimumLength(This,lnPasswordMinimumLength)

#define IADsUser_get_PasswordRequired(This,retval)	\
    (This)->lpVtbl -> get_PasswordRequired(This,retval)

#define IADsUser_put_PasswordRequired(This,fPasswordRequired)	\
    (This)->lpVtbl -> put_PasswordRequired(This,fPasswordRequired)

#define IADsUser_get_RequireUniquePassword(This,retval)	\
    (This)->lpVtbl -> get_RequireUniquePassword(This,retval)

#define IADsUser_put_RequireUniquePassword(This,fRequireUniquePassword)	\
    (This)->lpVtbl -> put_RequireUniquePassword(This,fRequireUniquePassword)

#define IADsUser_get_EmailAddress(This,retval)	\
    (This)->lpVtbl -> get_EmailAddress(This,retval)

#define IADsUser_put_EmailAddress(This,bstrEmailAddress)	\
    (This)->lpVtbl -> put_EmailAddress(This,bstrEmailAddress)

#define IADsUser_get_HomeDirectory(This,retval)	\
    (This)->lpVtbl -> get_HomeDirectory(This,retval)

#define IADsUser_put_HomeDirectory(This,bstrHomeDirectory)	\
    (This)->lpVtbl -> put_HomeDirectory(This,bstrHomeDirectory)

#define IADsUser_get_Languages(This,retval)	\
    (This)->lpVtbl -> get_Languages(This,retval)

#define IADsUser_put_Languages(This,vLanguages)	\
    (This)->lpVtbl -> put_Languages(This,vLanguages)

#define IADsUser_get_Profile(This,retval)	\
    (This)->lpVtbl -> get_Profile(This,retval)

#define IADsUser_put_Profile(This,bstrProfile)	\
    (This)->lpVtbl -> put_Profile(This,bstrProfile)

#define IADsUser_get_LoginScript(This,retval)	\
    (This)->lpVtbl -> get_LoginScript(This,retval)

#define IADsUser_put_LoginScript(This,bstrLoginScript)	\
    (This)->lpVtbl -> put_LoginScript(This,bstrLoginScript)

#define IADsUser_get_Picture(This,retval)	\
    (This)->lpVtbl -> get_Picture(This,retval)

#define IADsUser_put_Picture(This,vPicture)	\
    (This)->lpVtbl -> put_Picture(This,vPicture)

#define IADsUser_get_HomePage(This,retval)	\
    (This)->lpVtbl -> get_HomePage(This,retval)

#define IADsUser_put_HomePage(This,bstrHomePage)	\
    (This)->lpVtbl -> put_HomePage(This,bstrHomePage)

#define IADsUser_Groups(This,ppGroups)	\
    (This)->lpVtbl -> Groups(This,ppGroups)

#define IADsUser_SetPassword(This,NewPassword)	\
    (This)->lpVtbl -> SetPassword(This,NewPassword)

#define IADsUser_ChangePassword(This,bstrOldPassword,bstrNewPassword)	\
    (This)->lpVtbl -> ChangePassword(This,bstrOldPassword,bstrNewPassword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_BadLoginAddress_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_BadLoginAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_BadLoginCount_Proxy( 
    IADsUser * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsUser_get_BadLoginCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_LastLogin_Proxy( 
    IADsUser * This,
    /* [retval][out] */ DATE *retval);


void __RPC_STUB IADsUser_get_LastLogin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_LastLogoff_Proxy( 
    IADsUser * This,
    /* [retval][out] */ DATE *retval);


void __RPC_STUB IADsUser_get_LastLogoff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_LastFailedLogin_Proxy( 
    IADsUser * This,
    /* [retval][out] */ DATE *retval);


void __RPC_STUB IADsUser_get_LastFailedLogin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_PasswordLastChanged_Proxy( 
    IADsUser * This,
    /* [retval][out] */ DATE *retval);


void __RPC_STUB IADsUser_get_PasswordLastChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_Description_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_Description_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IADsUser_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_Division_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_Division_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_Division_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrDivision);


void __RPC_STUB IADsUser_put_Division_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_Department_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_Department_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_Department_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrDepartment);


void __RPC_STUB IADsUser_put_Department_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_EmployeeID_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_EmployeeID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_EmployeeID_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrEmployeeID);


void __RPC_STUB IADsUser_put_EmployeeID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_FullName_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_FullName_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrFullName);


void __RPC_STUB IADsUser_put_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_FirstName_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_FirstName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_FirstName_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrFirstName);


void __RPC_STUB IADsUser_put_FirstName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_LastName_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_LastName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_LastName_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrLastName);


void __RPC_STUB IADsUser_put_LastName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_OtherName_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_OtherName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_OtherName_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrOtherName);


void __RPC_STUB IADsUser_put_OtherName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_NamePrefix_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_NamePrefix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_NamePrefix_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrNamePrefix);


void __RPC_STUB IADsUser_put_NamePrefix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_NameSuffix_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_NameSuffix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_NameSuffix_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrNameSuffix);


void __RPC_STUB IADsUser_put_NameSuffix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_Title_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_Title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_Title_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrTitle);


void __RPC_STUB IADsUser_put_Title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_Manager_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_Manager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_Manager_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrManager);


void __RPC_STUB IADsUser_put_Manager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_TelephoneHome_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsUser_get_TelephoneHome_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_TelephoneHome_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT vTelephoneHome);


void __RPC_STUB IADsUser_put_TelephoneHome_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_TelephoneMobile_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsUser_get_TelephoneMobile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_TelephoneMobile_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT vTelephoneMobile);


void __RPC_STUB IADsUser_put_TelephoneMobile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_TelephoneNumber_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsUser_get_TelephoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_TelephoneNumber_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT vTelephoneNumber);


void __RPC_STUB IADsUser_put_TelephoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_TelephonePager_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsUser_get_TelephonePager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_TelephonePager_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT vTelephonePager);


void __RPC_STUB IADsUser_put_TelephonePager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_FaxNumber_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsUser_get_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_FaxNumber_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT vFaxNumber);


void __RPC_STUB IADsUser_put_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_OfficeLocations_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsUser_get_OfficeLocations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_OfficeLocations_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT vOfficeLocations);


void __RPC_STUB IADsUser_put_OfficeLocations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_PostalAddresses_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsUser_get_PostalAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_PostalAddresses_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT vPostalAddresses);


void __RPC_STUB IADsUser_put_PostalAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_PostalCodes_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsUser_get_PostalCodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_PostalCodes_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT vPostalCodes);


void __RPC_STUB IADsUser_put_PostalCodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_SeeAlso_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsUser_get_SeeAlso_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_SeeAlso_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT vSeeAlso);


void __RPC_STUB IADsUser_put_SeeAlso_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_AccountDisabled_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT_BOOL *retval);


void __RPC_STUB IADsUser_get_AccountDisabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_AccountDisabled_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT_BOOL fAccountDisabled);


void __RPC_STUB IADsUser_put_AccountDisabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_AccountExpirationDate_Proxy( 
    IADsUser * This,
    /* [retval][out] */ DATE *retval);


void __RPC_STUB IADsUser_get_AccountExpirationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_AccountExpirationDate_Proxy( 
    IADsUser * This,
    /* [in] */ DATE daAccountExpirationDate);


void __RPC_STUB IADsUser_put_AccountExpirationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_GraceLoginsAllowed_Proxy( 
    IADsUser * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsUser_get_GraceLoginsAllowed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_GraceLoginsAllowed_Proxy( 
    IADsUser * This,
    /* [in] */ long lnGraceLoginsAllowed);


void __RPC_STUB IADsUser_put_GraceLoginsAllowed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_GraceLoginsRemaining_Proxy( 
    IADsUser * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsUser_get_GraceLoginsRemaining_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_GraceLoginsRemaining_Proxy( 
    IADsUser * This,
    /* [in] */ long lnGraceLoginsRemaining);


void __RPC_STUB IADsUser_put_GraceLoginsRemaining_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_IsAccountLocked_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT_BOOL *retval);


void __RPC_STUB IADsUser_get_IsAccountLocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_IsAccountLocked_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT_BOOL fIsAccountLocked);


void __RPC_STUB IADsUser_put_IsAccountLocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_LoginHours_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsUser_get_LoginHours_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_LoginHours_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT vLoginHours);


void __RPC_STUB IADsUser_put_LoginHours_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_LoginWorkstations_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsUser_get_LoginWorkstations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_LoginWorkstations_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT vLoginWorkstations);


void __RPC_STUB IADsUser_put_LoginWorkstations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_MaxLogins_Proxy( 
    IADsUser * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsUser_get_MaxLogins_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_MaxLogins_Proxy( 
    IADsUser * This,
    /* [in] */ long lnMaxLogins);


void __RPC_STUB IADsUser_put_MaxLogins_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_MaxStorage_Proxy( 
    IADsUser * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsUser_get_MaxStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_MaxStorage_Proxy( 
    IADsUser * This,
    /* [in] */ long lnMaxStorage);


void __RPC_STUB IADsUser_put_MaxStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_PasswordExpirationDate_Proxy( 
    IADsUser * This,
    /* [retval][out] */ DATE *retval);


void __RPC_STUB IADsUser_get_PasswordExpirationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_PasswordExpirationDate_Proxy( 
    IADsUser * This,
    /* [in] */ DATE daPasswordExpirationDate);


void __RPC_STUB IADsUser_put_PasswordExpirationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_PasswordMinimumLength_Proxy( 
    IADsUser * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsUser_get_PasswordMinimumLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_PasswordMinimumLength_Proxy( 
    IADsUser * This,
    /* [in] */ long lnPasswordMinimumLength);


void __RPC_STUB IADsUser_put_PasswordMinimumLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_PasswordRequired_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT_BOOL *retval);


void __RPC_STUB IADsUser_get_PasswordRequired_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_PasswordRequired_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT_BOOL fPasswordRequired);


void __RPC_STUB IADsUser_put_PasswordRequired_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_RequireUniquePassword_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT_BOOL *retval);


void __RPC_STUB IADsUser_get_RequireUniquePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_RequireUniquePassword_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT_BOOL fRequireUniquePassword);


void __RPC_STUB IADsUser_put_RequireUniquePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_EmailAddress_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_EmailAddress_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrEmailAddress);


void __RPC_STUB IADsUser_put_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_HomeDirectory_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_HomeDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_HomeDirectory_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrHomeDirectory);


void __RPC_STUB IADsUser_put_HomeDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_Languages_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsUser_get_Languages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_Languages_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT vLanguages);


void __RPC_STUB IADsUser_put_Languages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_Profile_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_Profile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_Profile_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrProfile);


void __RPC_STUB IADsUser_put_Profile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_LoginScript_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_LoginScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_LoginScript_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrLoginScript);


void __RPC_STUB IADsUser_put_LoginScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_Picture_Proxy( 
    IADsUser * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsUser_get_Picture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_Picture_Proxy( 
    IADsUser * This,
    /* [in] */ VARIANT vPicture);


void __RPC_STUB IADsUser_put_Picture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsUser_get_HomePage_Proxy( 
    IADsUser * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsUser_get_HomePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsUser_put_HomePage_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrHomePage);


void __RPC_STUB IADsUser_put_HomePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsUser_Groups_Proxy( 
    IADsUser * This,
    /* [retval][out] */ IADsMembers **ppGroups);


void __RPC_STUB IADsUser_Groups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsUser_SetPassword_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR NewPassword);


void __RPC_STUB IADsUser_SetPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsUser_ChangePassword_Proxy( 
    IADsUser * This,
    /* [in] */ BSTR bstrOldPassword,
    /* [in] */ BSTR bstrNewPassword);


void __RPC_STUB IADsUser_ChangePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsUser_INTERFACE_DEFINED__ */


#ifndef __IADsPrintQueue_INTERFACE_DEFINED__
#define __IADsPrintQueue_INTERFACE_DEFINED__

/* interface IADsPrintQueue */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsPrintQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b15160d0-1226-11cf-a985-00aa006bc149")
    IADsPrintQueue : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PrinterPath( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PrinterPath( 
            /* [in] */ BSTR bstrPrinterPath) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Model( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Model( 
            /* [in] */ BSTR bstrModel) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Datatype( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Datatype( 
            /* [in] */ BSTR bstrDatatype) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PrintProcessor( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PrintProcessor( 
            /* [in] */ BSTR bstrPrintProcessor) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Location( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Location( 
            /* [in] */ BSTR bstrLocation) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ DATE *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartTime( 
            /* [in] */ DATE daStartTime) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_UntilTime( 
            /* [retval][out] */ DATE *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_UntilTime( 
            /* [in] */ DATE daUntilTime) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultJobPriority( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultJobPriority( 
            /* [in] */ long lnDefaultJobPriority) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ long lnPriority) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BannerPage( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BannerPage( 
            /* [in] */ BSTR bstrBannerPage) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PrintDevices( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PrintDevices( 
            /* [in] */ VARIANT vPrintDevices) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_NetAddresses( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_NetAddresses( 
            /* [in] */ VARIANT vNetAddresses) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsPrintQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsPrintQueue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsPrintQueue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsPrintQueue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsPrintQueue * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsPrintQueue * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsPrintQueue * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsPrintQueue * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsPrintQueue * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsPrintQueue * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsPrintQueue * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsPrintQueue * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsPrintQueue * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsPrintQueue * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsPrintQueue * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsPrintQueue * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsPrintQueue * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsPrintQueue * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsPrintQueue * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsPrintQueue * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsPrintQueue * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrinterPath )( 
            IADsPrintQueue * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrinterPath )( 
            IADsPrintQueue * This,
            /* [in] */ BSTR bstrPrinterPath);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Model )( 
            IADsPrintQueue * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Model )( 
            IADsPrintQueue * This,
            /* [in] */ BSTR bstrModel);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Datatype )( 
            IADsPrintQueue * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Datatype )( 
            IADsPrintQueue * This,
            /* [in] */ BSTR bstrDatatype);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrintProcessor )( 
            IADsPrintQueue * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrintProcessor )( 
            IADsPrintQueue * This,
            /* [in] */ BSTR bstrPrintProcessor);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IADsPrintQueue * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IADsPrintQueue * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Location )( 
            IADsPrintQueue * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Location )( 
            IADsPrintQueue * This,
            /* [in] */ BSTR bstrLocation);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            IADsPrintQueue * This,
            /* [retval][out] */ DATE *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartTime )( 
            IADsPrintQueue * This,
            /* [in] */ DATE daStartTime);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UntilTime )( 
            IADsPrintQueue * This,
            /* [retval][out] */ DATE *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UntilTime )( 
            IADsPrintQueue * This,
            /* [in] */ DATE daUntilTime);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultJobPriority )( 
            IADsPrintQueue * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultJobPriority )( 
            IADsPrintQueue * This,
            /* [in] */ long lnDefaultJobPriority);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IADsPrintQueue * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IADsPrintQueue * This,
            /* [in] */ long lnPriority);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BannerPage )( 
            IADsPrintQueue * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BannerPage )( 
            IADsPrintQueue * This,
            /* [in] */ BSTR bstrBannerPage);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrintDevices )( 
            IADsPrintQueue * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrintDevices )( 
            IADsPrintQueue * This,
            /* [in] */ VARIANT vPrintDevices);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetAddresses )( 
            IADsPrintQueue * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_NetAddresses )( 
            IADsPrintQueue * This,
            /* [in] */ VARIANT vNetAddresses);
        
        END_INTERFACE
    } IADsPrintQueueVtbl;

    interface IADsPrintQueue
    {
        CONST_VTBL struct IADsPrintQueueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsPrintQueue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsPrintQueue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsPrintQueue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsPrintQueue_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsPrintQueue_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsPrintQueue_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsPrintQueue_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsPrintQueue_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsPrintQueue_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsPrintQueue_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsPrintQueue_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsPrintQueue_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsPrintQueue_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsPrintQueue_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsPrintQueue_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsPrintQueue_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsPrintQueue_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsPrintQueue_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsPrintQueue_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsPrintQueue_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsPrintQueue_get_PrinterPath(This,retval)	\
    (This)->lpVtbl -> get_PrinterPath(This,retval)

#define IADsPrintQueue_put_PrinterPath(This,bstrPrinterPath)	\
    (This)->lpVtbl -> put_PrinterPath(This,bstrPrinterPath)

#define IADsPrintQueue_get_Model(This,retval)	\
    (This)->lpVtbl -> get_Model(This,retval)

#define IADsPrintQueue_put_Model(This,bstrModel)	\
    (This)->lpVtbl -> put_Model(This,bstrModel)

#define IADsPrintQueue_get_Datatype(This,retval)	\
    (This)->lpVtbl -> get_Datatype(This,retval)

#define IADsPrintQueue_put_Datatype(This,bstrDatatype)	\
    (This)->lpVtbl -> put_Datatype(This,bstrDatatype)

#define IADsPrintQueue_get_PrintProcessor(This,retval)	\
    (This)->lpVtbl -> get_PrintProcessor(This,retval)

#define IADsPrintQueue_put_PrintProcessor(This,bstrPrintProcessor)	\
    (This)->lpVtbl -> put_PrintProcessor(This,bstrPrintProcessor)

#define IADsPrintQueue_get_Description(This,retval)	\
    (This)->lpVtbl -> get_Description(This,retval)

#define IADsPrintQueue_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IADsPrintQueue_get_Location(This,retval)	\
    (This)->lpVtbl -> get_Location(This,retval)

#define IADsPrintQueue_put_Location(This,bstrLocation)	\
    (This)->lpVtbl -> put_Location(This,bstrLocation)

#define IADsPrintQueue_get_StartTime(This,retval)	\
    (This)->lpVtbl -> get_StartTime(This,retval)

#define IADsPrintQueue_put_StartTime(This,daStartTime)	\
    (This)->lpVtbl -> put_StartTime(This,daStartTime)

#define IADsPrintQueue_get_UntilTime(This,retval)	\
    (This)->lpVtbl -> get_UntilTime(This,retval)

#define IADsPrintQueue_put_UntilTime(This,daUntilTime)	\
    (This)->lpVtbl -> put_UntilTime(This,daUntilTime)

#define IADsPrintQueue_get_DefaultJobPriority(This,retval)	\
    (This)->lpVtbl -> get_DefaultJobPriority(This,retval)

#define IADsPrintQueue_put_DefaultJobPriority(This,lnDefaultJobPriority)	\
    (This)->lpVtbl -> put_DefaultJobPriority(This,lnDefaultJobPriority)

#define IADsPrintQueue_get_Priority(This,retval)	\
    (This)->lpVtbl -> get_Priority(This,retval)

#define IADsPrintQueue_put_Priority(This,lnPriority)	\
    (This)->lpVtbl -> put_Priority(This,lnPriority)

#define IADsPrintQueue_get_BannerPage(This,retval)	\
    (This)->lpVtbl -> get_BannerPage(This,retval)

#define IADsPrintQueue_put_BannerPage(This,bstrBannerPage)	\
    (This)->lpVtbl -> put_BannerPage(This,bstrBannerPage)

#define IADsPrintQueue_get_PrintDevices(This,retval)	\
    (This)->lpVtbl -> get_PrintDevices(This,retval)

#define IADsPrintQueue_put_PrintDevices(This,vPrintDevices)	\
    (This)->lpVtbl -> put_PrintDevices(This,vPrintDevices)

#define IADsPrintQueue_get_NetAddresses(This,retval)	\
    (This)->lpVtbl -> get_NetAddresses(This,retval)

#define IADsPrintQueue_put_NetAddresses(This,vNetAddresses)	\
    (This)->lpVtbl -> put_NetAddresses(This,vNetAddresses)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_get_PrinterPath_Proxy( 
    IADsPrintQueue * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPrintQueue_get_PrinterPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_put_PrinterPath_Proxy( 
    IADsPrintQueue * This,
    /* [in] */ BSTR bstrPrinterPath);


void __RPC_STUB IADsPrintQueue_put_PrinterPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_get_Model_Proxy( 
    IADsPrintQueue * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPrintQueue_get_Model_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_put_Model_Proxy( 
    IADsPrintQueue * This,
    /* [in] */ BSTR bstrModel);


void __RPC_STUB IADsPrintQueue_put_Model_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_get_Datatype_Proxy( 
    IADsPrintQueue * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPrintQueue_get_Datatype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_put_Datatype_Proxy( 
    IADsPrintQueue * This,
    /* [in] */ BSTR bstrDatatype);


void __RPC_STUB IADsPrintQueue_put_Datatype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_get_PrintProcessor_Proxy( 
    IADsPrintQueue * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPrintQueue_get_PrintProcessor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_put_PrintProcessor_Proxy( 
    IADsPrintQueue * This,
    /* [in] */ BSTR bstrPrintProcessor);


void __RPC_STUB IADsPrintQueue_put_PrintProcessor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_get_Description_Proxy( 
    IADsPrintQueue * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPrintQueue_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_put_Description_Proxy( 
    IADsPrintQueue * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IADsPrintQueue_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_get_Location_Proxy( 
    IADsPrintQueue * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPrintQueue_get_Location_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_put_Location_Proxy( 
    IADsPrintQueue * This,
    /* [in] */ BSTR bstrLocation);


void __RPC_STUB IADsPrintQueue_put_Location_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_get_StartTime_Proxy( 
    IADsPrintQueue * This,
    /* [retval][out] */ DATE *retval);


void __RPC_STUB IADsPrintQueue_get_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_put_StartTime_Proxy( 
    IADsPrintQueue * This,
    /* [in] */ DATE daStartTime);


void __RPC_STUB IADsPrintQueue_put_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_get_UntilTime_Proxy( 
    IADsPrintQueue * This,
    /* [retval][out] */ DATE *retval);


void __RPC_STUB IADsPrintQueue_get_UntilTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_put_UntilTime_Proxy( 
    IADsPrintQueue * This,
    /* [in] */ DATE daUntilTime);


void __RPC_STUB IADsPrintQueue_put_UntilTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_get_DefaultJobPriority_Proxy( 
    IADsPrintQueue * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsPrintQueue_get_DefaultJobPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_put_DefaultJobPriority_Proxy( 
    IADsPrintQueue * This,
    /* [in] */ long lnDefaultJobPriority);


void __RPC_STUB IADsPrintQueue_put_DefaultJobPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_get_Priority_Proxy( 
    IADsPrintQueue * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsPrintQueue_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_put_Priority_Proxy( 
    IADsPrintQueue * This,
    /* [in] */ long lnPriority);


void __RPC_STUB IADsPrintQueue_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_get_BannerPage_Proxy( 
    IADsPrintQueue * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPrintQueue_get_BannerPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_put_BannerPage_Proxy( 
    IADsPrintQueue * This,
    /* [in] */ BSTR bstrBannerPage);


void __RPC_STUB IADsPrintQueue_put_BannerPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_get_PrintDevices_Proxy( 
    IADsPrintQueue * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsPrintQueue_get_PrintDevices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_put_PrintDevices_Proxy( 
    IADsPrintQueue * This,
    /* [in] */ VARIANT vPrintDevices);


void __RPC_STUB IADsPrintQueue_put_PrintDevices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_get_NetAddresses_Proxy( 
    IADsPrintQueue * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsPrintQueue_get_NetAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintQueue_put_NetAddresses_Proxy( 
    IADsPrintQueue * This,
    /* [in] */ VARIANT vNetAddresses);


void __RPC_STUB IADsPrintQueue_put_NetAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsPrintQueue_INTERFACE_DEFINED__ */


#ifndef __IADsPrintQueueOperations_INTERFACE_DEFINED__
#define __IADsPrintQueueOperations_INTERFACE_DEFINED__

/* interface IADsPrintQueueOperations */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsPrintQueueOperations;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("124be5c0-156e-11cf-a986-00aa006bc149")
    IADsPrintQueueOperations : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PrintJobs( 
            /* [retval][out] */ IADsCollection **pObject) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Purge( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsPrintQueueOperationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsPrintQueueOperations * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsPrintQueueOperations * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsPrintQueueOperations * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsPrintQueueOperations * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsPrintQueueOperations * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsPrintQueueOperations * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsPrintQueueOperations * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsPrintQueueOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsPrintQueueOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsPrintQueueOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsPrintQueueOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsPrintQueueOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsPrintQueueOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsPrintQueueOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsPrintQueueOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsPrintQueueOperations * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsPrintQueueOperations * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsPrintQueueOperations * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsPrintQueueOperations * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsPrintQueueOperations * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IADsPrintQueueOperations * This,
            /* [retval][out] */ long *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PrintJobs )( 
            IADsPrintQueueOperations * This,
            /* [retval][out] */ IADsCollection **pObject);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IADsPrintQueueOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IADsPrintQueueOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Purge )( 
            IADsPrintQueueOperations * This);
        
        END_INTERFACE
    } IADsPrintQueueOperationsVtbl;

    interface IADsPrintQueueOperations
    {
        CONST_VTBL struct IADsPrintQueueOperationsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsPrintQueueOperations_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsPrintQueueOperations_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsPrintQueueOperations_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsPrintQueueOperations_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsPrintQueueOperations_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsPrintQueueOperations_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsPrintQueueOperations_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsPrintQueueOperations_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsPrintQueueOperations_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsPrintQueueOperations_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsPrintQueueOperations_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsPrintQueueOperations_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsPrintQueueOperations_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsPrintQueueOperations_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsPrintQueueOperations_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsPrintQueueOperations_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsPrintQueueOperations_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsPrintQueueOperations_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsPrintQueueOperations_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsPrintQueueOperations_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsPrintQueueOperations_get_Status(This,retval)	\
    (This)->lpVtbl -> get_Status(This,retval)

#define IADsPrintQueueOperations_PrintJobs(This,pObject)	\
    (This)->lpVtbl -> PrintJobs(This,pObject)

#define IADsPrintQueueOperations_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IADsPrintQueueOperations_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IADsPrintQueueOperations_Purge(This)	\
    (This)->lpVtbl -> Purge(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintQueueOperations_get_Status_Proxy( 
    IADsPrintQueueOperations * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsPrintQueueOperations_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsPrintQueueOperations_PrintJobs_Proxy( 
    IADsPrintQueueOperations * This,
    /* [retval][out] */ IADsCollection **pObject);


void __RPC_STUB IADsPrintQueueOperations_PrintJobs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsPrintQueueOperations_Pause_Proxy( 
    IADsPrintQueueOperations * This);


void __RPC_STUB IADsPrintQueueOperations_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsPrintQueueOperations_Resume_Proxy( 
    IADsPrintQueueOperations * This);


void __RPC_STUB IADsPrintQueueOperations_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsPrintQueueOperations_Purge_Proxy( 
    IADsPrintQueueOperations * This);


void __RPC_STUB IADsPrintQueueOperations_Purge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsPrintQueueOperations_INTERFACE_DEFINED__ */


#ifndef __IADsPrintJob_INTERFACE_DEFINED__
#define __IADsPrintJob_INTERFACE_DEFINED__

/* interface IADsPrintJob */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsPrintJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("32fb6780-1ed0-11cf-a988-00aa006bc149")
    IADsPrintJob : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HostPrintQueue( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_User( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_UserPath( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_TimeSubmitted( 
            /* [retval][out] */ DATE *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalPages( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ long lnPriority) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ DATE *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartTime( 
            /* [in] */ DATE daStartTime) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_UntilTime( 
            /* [retval][out] */ DATE *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_UntilTime( 
            /* [in] */ DATE daUntilTime) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Notify( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Notify( 
            /* [in] */ BSTR bstrNotify) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_NotifyPath( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_NotifyPath( 
            /* [in] */ BSTR bstrNotifyPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsPrintJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsPrintJob * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsPrintJob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsPrintJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsPrintJob * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsPrintJob * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsPrintJob * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsPrintJob * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsPrintJob * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsPrintJob * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsPrintJob * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsPrintJob * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsPrintJob * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsPrintJob * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsPrintJob * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsPrintJob * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsPrintJob * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsPrintJob * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsPrintJob * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsPrintJob * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsPrintJob * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostPrintQueue )( 
            IADsPrintJob * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_User )( 
            IADsPrintJob * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserPath )( 
            IADsPrintJob * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimeSubmitted )( 
            IADsPrintJob * This,
            /* [retval][out] */ DATE *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalPages )( 
            IADsPrintJob * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IADsPrintJob * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IADsPrintJob * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IADsPrintJob * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IADsPrintJob * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IADsPrintJob * This,
            /* [in] */ long lnPriority);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            IADsPrintJob * This,
            /* [retval][out] */ DATE *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartTime )( 
            IADsPrintJob * This,
            /* [in] */ DATE daStartTime);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UntilTime )( 
            IADsPrintJob * This,
            /* [retval][out] */ DATE *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UntilTime )( 
            IADsPrintJob * This,
            /* [in] */ DATE daUntilTime);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Notify )( 
            IADsPrintJob * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Notify )( 
            IADsPrintJob * This,
            /* [in] */ BSTR bstrNotify);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NotifyPath )( 
            IADsPrintJob * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_NotifyPath )( 
            IADsPrintJob * This,
            /* [in] */ BSTR bstrNotifyPath);
        
        END_INTERFACE
    } IADsPrintJobVtbl;

    interface IADsPrintJob
    {
        CONST_VTBL struct IADsPrintJobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsPrintJob_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsPrintJob_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsPrintJob_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsPrintJob_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsPrintJob_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsPrintJob_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsPrintJob_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsPrintJob_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsPrintJob_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsPrintJob_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsPrintJob_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsPrintJob_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsPrintJob_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsPrintJob_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsPrintJob_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsPrintJob_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsPrintJob_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsPrintJob_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsPrintJob_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsPrintJob_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsPrintJob_get_HostPrintQueue(This,retval)	\
    (This)->lpVtbl -> get_HostPrintQueue(This,retval)

#define IADsPrintJob_get_User(This,retval)	\
    (This)->lpVtbl -> get_User(This,retval)

#define IADsPrintJob_get_UserPath(This,retval)	\
    (This)->lpVtbl -> get_UserPath(This,retval)

#define IADsPrintJob_get_TimeSubmitted(This,retval)	\
    (This)->lpVtbl -> get_TimeSubmitted(This,retval)

#define IADsPrintJob_get_TotalPages(This,retval)	\
    (This)->lpVtbl -> get_TotalPages(This,retval)

#define IADsPrintJob_get_Size(This,retval)	\
    (This)->lpVtbl -> get_Size(This,retval)

#define IADsPrintJob_get_Description(This,retval)	\
    (This)->lpVtbl -> get_Description(This,retval)

#define IADsPrintJob_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IADsPrintJob_get_Priority(This,retval)	\
    (This)->lpVtbl -> get_Priority(This,retval)

#define IADsPrintJob_put_Priority(This,lnPriority)	\
    (This)->lpVtbl -> put_Priority(This,lnPriority)

#define IADsPrintJob_get_StartTime(This,retval)	\
    (This)->lpVtbl -> get_StartTime(This,retval)

#define IADsPrintJob_put_StartTime(This,daStartTime)	\
    (This)->lpVtbl -> put_StartTime(This,daStartTime)

#define IADsPrintJob_get_UntilTime(This,retval)	\
    (This)->lpVtbl -> get_UntilTime(This,retval)

#define IADsPrintJob_put_UntilTime(This,daUntilTime)	\
    (This)->lpVtbl -> put_UntilTime(This,daUntilTime)

#define IADsPrintJob_get_Notify(This,retval)	\
    (This)->lpVtbl -> get_Notify(This,retval)

#define IADsPrintJob_put_Notify(This,bstrNotify)	\
    (This)->lpVtbl -> put_Notify(This,bstrNotify)

#define IADsPrintJob_get_NotifyPath(This,retval)	\
    (This)->lpVtbl -> get_NotifyPath(This,retval)

#define IADsPrintJob_put_NotifyPath(This,bstrNotifyPath)	\
    (This)->lpVtbl -> put_NotifyPath(This,bstrNotifyPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_get_HostPrintQueue_Proxy( 
    IADsPrintJob * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPrintJob_get_HostPrintQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_get_User_Proxy( 
    IADsPrintJob * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPrintJob_get_User_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_get_UserPath_Proxy( 
    IADsPrintJob * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPrintJob_get_UserPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_get_TimeSubmitted_Proxy( 
    IADsPrintJob * This,
    /* [retval][out] */ DATE *retval);


void __RPC_STUB IADsPrintJob_get_TimeSubmitted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_get_TotalPages_Proxy( 
    IADsPrintJob * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsPrintJob_get_TotalPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_get_Size_Proxy( 
    IADsPrintJob * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsPrintJob_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_get_Description_Proxy( 
    IADsPrintJob * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPrintJob_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_put_Description_Proxy( 
    IADsPrintJob * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IADsPrintJob_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_get_Priority_Proxy( 
    IADsPrintJob * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsPrintJob_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_put_Priority_Proxy( 
    IADsPrintJob * This,
    /* [in] */ long lnPriority);


void __RPC_STUB IADsPrintJob_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_get_StartTime_Proxy( 
    IADsPrintJob * This,
    /* [retval][out] */ DATE *retval);


void __RPC_STUB IADsPrintJob_get_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_put_StartTime_Proxy( 
    IADsPrintJob * This,
    /* [in] */ DATE daStartTime);


void __RPC_STUB IADsPrintJob_put_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_get_UntilTime_Proxy( 
    IADsPrintJob * This,
    /* [retval][out] */ DATE *retval);


void __RPC_STUB IADsPrintJob_get_UntilTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_put_UntilTime_Proxy( 
    IADsPrintJob * This,
    /* [in] */ DATE daUntilTime);


void __RPC_STUB IADsPrintJob_put_UntilTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_get_Notify_Proxy( 
    IADsPrintJob * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPrintJob_get_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_put_Notify_Proxy( 
    IADsPrintJob * This,
    /* [in] */ BSTR bstrNotify);


void __RPC_STUB IADsPrintJob_put_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_get_NotifyPath_Proxy( 
    IADsPrintJob * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPrintJob_get_NotifyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintJob_put_NotifyPath_Proxy( 
    IADsPrintJob * This,
    /* [in] */ BSTR bstrNotifyPath);


void __RPC_STUB IADsPrintJob_put_NotifyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsPrintJob_INTERFACE_DEFINED__ */


#ifndef __IADsPrintJobOperations_INTERFACE_DEFINED__
#define __IADsPrintJobOperations_INTERFACE_DEFINED__

/* interface IADsPrintJobOperations */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsPrintJobOperations;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9a52db30-1ecf-11cf-a988-00aa006bc149")
    IADsPrintJobOperations : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_TimeElapsed( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PagesPrinted( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Position( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Position( 
            /* [in] */ long lnPosition) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsPrintJobOperationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsPrintJobOperations * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsPrintJobOperations * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsPrintJobOperations * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsPrintJobOperations * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsPrintJobOperations * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsPrintJobOperations * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsPrintJobOperations * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsPrintJobOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsPrintJobOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsPrintJobOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsPrintJobOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsPrintJobOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsPrintJobOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsPrintJobOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsPrintJobOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsPrintJobOperations * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsPrintJobOperations * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsPrintJobOperations * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsPrintJobOperations * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsPrintJobOperations * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IADsPrintJobOperations * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimeElapsed )( 
            IADsPrintJobOperations * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PagesPrinted )( 
            IADsPrintJobOperations * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Position )( 
            IADsPrintJobOperations * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Position )( 
            IADsPrintJobOperations * This,
            /* [in] */ long lnPosition);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IADsPrintJobOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IADsPrintJobOperations * This);
        
        END_INTERFACE
    } IADsPrintJobOperationsVtbl;

    interface IADsPrintJobOperations
    {
        CONST_VTBL struct IADsPrintJobOperationsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsPrintJobOperations_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsPrintJobOperations_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsPrintJobOperations_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsPrintJobOperations_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsPrintJobOperations_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsPrintJobOperations_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsPrintJobOperations_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsPrintJobOperations_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsPrintJobOperations_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsPrintJobOperations_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsPrintJobOperations_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsPrintJobOperations_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsPrintJobOperations_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsPrintJobOperations_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsPrintJobOperations_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsPrintJobOperations_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsPrintJobOperations_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsPrintJobOperations_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsPrintJobOperations_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsPrintJobOperations_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsPrintJobOperations_get_Status(This,retval)	\
    (This)->lpVtbl -> get_Status(This,retval)

#define IADsPrintJobOperations_get_TimeElapsed(This,retval)	\
    (This)->lpVtbl -> get_TimeElapsed(This,retval)

#define IADsPrintJobOperations_get_PagesPrinted(This,retval)	\
    (This)->lpVtbl -> get_PagesPrinted(This,retval)

#define IADsPrintJobOperations_get_Position(This,retval)	\
    (This)->lpVtbl -> get_Position(This,retval)

#define IADsPrintJobOperations_put_Position(This,lnPosition)	\
    (This)->lpVtbl -> put_Position(This,lnPosition)

#define IADsPrintJobOperations_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IADsPrintJobOperations_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJobOperations_get_Status_Proxy( 
    IADsPrintJobOperations * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsPrintJobOperations_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJobOperations_get_TimeElapsed_Proxy( 
    IADsPrintJobOperations * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsPrintJobOperations_get_TimeElapsed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJobOperations_get_PagesPrinted_Proxy( 
    IADsPrintJobOperations * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsPrintJobOperations_get_PagesPrinted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPrintJobOperations_get_Position_Proxy( 
    IADsPrintJobOperations * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsPrintJobOperations_get_Position_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPrintJobOperations_put_Position_Proxy( 
    IADsPrintJobOperations * This,
    /* [in] */ long lnPosition);


void __RPC_STUB IADsPrintJobOperations_put_Position_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsPrintJobOperations_Pause_Proxy( 
    IADsPrintJobOperations * This);


void __RPC_STUB IADsPrintJobOperations_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsPrintJobOperations_Resume_Proxy( 
    IADsPrintJobOperations * This);


void __RPC_STUB IADsPrintJobOperations_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsPrintJobOperations_INTERFACE_DEFINED__ */


#ifndef __IADsService_INTERFACE_DEFINED__
#define __IADsService_INTERFACE_DEFINED__

/* interface IADsService */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("68af66e0-31ca-11cf-a98a-00aa006bc149")
    IADsService : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HostComputer( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_HostComputer( 
            /* [in] */ BSTR bstrHostComputer) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DisplayName( 
            /* [in] */ BSTR bstrDisplayName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Version( 
            /* [in] */ BSTR bstrVersion) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ServiceType( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ServiceType( 
            /* [in] */ long lnServiceType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StartType( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartType( 
            /* [in] */ long lnStartType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR bstrPath) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StartupParameters( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartupParameters( 
            /* [in] */ BSTR bstrStartupParameters) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorControl( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorControl( 
            /* [in] */ long lnErrorControl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LoadOrderGroup( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LoadOrderGroup( 
            /* [in] */ BSTR bstrLoadOrderGroup) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ServiceAccountName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ServiceAccountName( 
            /* [in] */ BSTR bstrServiceAccountName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ServiceAccountPath( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ServiceAccountPath( 
            /* [in] */ BSTR bstrServiceAccountPath) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Dependencies( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Dependencies( 
            /* [in] */ VARIANT vDependencies) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsService * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsService * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsService * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsService * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsService * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsService * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsService * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsService * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsService * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsService * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsService * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsService * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostComputer )( 
            IADsService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HostComputer )( 
            IADsService * This,
            /* [in] */ BSTR bstrHostComputer);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            IADsService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayName )( 
            IADsService * This,
            /* [in] */ BSTR bstrDisplayName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            IADsService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Version )( 
            IADsService * This,
            /* [in] */ BSTR bstrVersion);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceType )( 
            IADsService * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceType )( 
            IADsService * This,
            /* [in] */ long lnServiceType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartType )( 
            IADsService * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartType )( 
            IADsService * This,
            /* [in] */ long lnStartType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IADsService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Path )( 
            IADsService * This,
            /* [in] */ BSTR bstrPath);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartupParameters )( 
            IADsService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartupParameters )( 
            IADsService * This,
            /* [in] */ BSTR bstrStartupParameters);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorControl )( 
            IADsService * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorControl )( 
            IADsService * This,
            /* [in] */ long lnErrorControl);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoadOrderGroup )( 
            IADsService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoadOrderGroup )( 
            IADsService * This,
            /* [in] */ BSTR bstrLoadOrderGroup);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceAccountName )( 
            IADsService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceAccountName )( 
            IADsService * This,
            /* [in] */ BSTR bstrServiceAccountName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceAccountPath )( 
            IADsService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceAccountPath )( 
            IADsService * This,
            /* [in] */ BSTR bstrServiceAccountPath);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Dependencies )( 
            IADsService * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Dependencies )( 
            IADsService * This,
            /* [in] */ VARIANT vDependencies);
        
        END_INTERFACE
    } IADsServiceVtbl;

    interface IADsService
    {
        CONST_VTBL struct IADsServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsService_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsService_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsService_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsService_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsService_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsService_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsService_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsService_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsService_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsService_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsService_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsService_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsService_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsService_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsService_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsService_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsService_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsService_get_HostComputer(This,retval)	\
    (This)->lpVtbl -> get_HostComputer(This,retval)

#define IADsService_put_HostComputer(This,bstrHostComputer)	\
    (This)->lpVtbl -> put_HostComputer(This,bstrHostComputer)

#define IADsService_get_DisplayName(This,retval)	\
    (This)->lpVtbl -> get_DisplayName(This,retval)

#define IADsService_put_DisplayName(This,bstrDisplayName)	\
    (This)->lpVtbl -> put_DisplayName(This,bstrDisplayName)

#define IADsService_get_Version(This,retval)	\
    (This)->lpVtbl -> get_Version(This,retval)

#define IADsService_put_Version(This,bstrVersion)	\
    (This)->lpVtbl -> put_Version(This,bstrVersion)

#define IADsService_get_ServiceType(This,retval)	\
    (This)->lpVtbl -> get_ServiceType(This,retval)

#define IADsService_put_ServiceType(This,lnServiceType)	\
    (This)->lpVtbl -> put_ServiceType(This,lnServiceType)

#define IADsService_get_StartType(This,retval)	\
    (This)->lpVtbl -> get_StartType(This,retval)

#define IADsService_put_StartType(This,lnStartType)	\
    (This)->lpVtbl -> put_StartType(This,lnStartType)

#define IADsService_get_Path(This,retval)	\
    (This)->lpVtbl -> get_Path(This,retval)

#define IADsService_put_Path(This,bstrPath)	\
    (This)->lpVtbl -> put_Path(This,bstrPath)

#define IADsService_get_StartupParameters(This,retval)	\
    (This)->lpVtbl -> get_StartupParameters(This,retval)

#define IADsService_put_StartupParameters(This,bstrStartupParameters)	\
    (This)->lpVtbl -> put_StartupParameters(This,bstrStartupParameters)

#define IADsService_get_ErrorControl(This,retval)	\
    (This)->lpVtbl -> get_ErrorControl(This,retval)

#define IADsService_put_ErrorControl(This,lnErrorControl)	\
    (This)->lpVtbl -> put_ErrorControl(This,lnErrorControl)

#define IADsService_get_LoadOrderGroup(This,retval)	\
    (This)->lpVtbl -> get_LoadOrderGroup(This,retval)

#define IADsService_put_LoadOrderGroup(This,bstrLoadOrderGroup)	\
    (This)->lpVtbl -> put_LoadOrderGroup(This,bstrLoadOrderGroup)

#define IADsService_get_ServiceAccountName(This,retval)	\
    (This)->lpVtbl -> get_ServiceAccountName(This,retval)

#define IADsService_put_ServiceAccountName(This,bstrServiceAccountName)	\
    (This)->lpVtbl -> put_ServiceAccountName(This,bstrServiceAccountName)

#define IADsService_get_ServiceAccountPath(This,retval)	\
    (This)->lpVtbl -> get_ServiceAccountPath(This,retval)

#define IADsService_put_ServiceAccountPath(This,bstrServiceAccountPath)	\
    (This)->lpVtbl -> put_ServiceAccountPath(This,bstrServiceAccountPath)

#define IADsService_get_Dependencies(This,retval)	\
    (This)->lpVtbl -> get_Dependencies(This,retval)

#define IADsService_put_Dependencies(This,vDependencies)	\
    (This)->lpVtbl -> put_Dependencies(This,vDependencies)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsService_get_HostComputer_Proxy( 
    IADsService * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsService_get_HostComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsService_put_HostComputer_Proxy( 
    IADsService * This,
    /* [in] */ BSTR bstrHostComputer);


void __RPC_STUB IADsService_put_HostComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsService_get_DisplayName_Proxy( 
    IADsService * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsService_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsService_put_DisplayName_Proxy( 
    IADsService * This,
    /* [in] */ BSTR bstrDisplayName);


void __RPC_STUB IADsService_put_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsService_get_Version_Proxy( 
    IADsService * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsService_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsService_put_Version_Proxy( 
    IADsService * This,
    /* [in] */ BSTR bstrVersion);


void __RPC_STUB IADsService_put_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsService_get_ServiceType_Proxy( 
    IADsService * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsService_get_ServiceType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsService_put_ServiceType_Proxy( 
    IADsService * This,
    /* [in] */ long lnServiceType);


void __RPC_STUB IADsService_put_ServiceType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsService_get_StartType_Proxy( 
    IADsService * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsService_get_StartType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsService_put_StartType_Proxy( 
    IADsService * This,
    /* [in] */ long lnStartType);


void __RPC_STUB IADsService_put_StartType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsService_get_Path_Proxy( 
    IADsService * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsService_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsService_put_Path_Proxy( 
    IADsService * This,
    /* [in] */ BSTR bstrPath);


void __RPC_STUB IADsService_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsService_get_StartupParameters_Proxy( 
    IADsService * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsService_get_StartupParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsService_put_StartupParameters_Proxy( 
    IADsService * This,
    /* [in] */ BSTR bstrStartupParameters);


void __RPC_STUB IADsService_put_StartupParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsService_get_ErrorControl_Proxy( 
    IADsService * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsService_get_ErrorControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsService_put_ErrorControl_Proxy( 
    IADsService * This,
    /* [in] */ long lnErrorControl);


void __RPC_STUB IADsService_put_ErrorControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsService_get_LoadOrderGroup_Proxy( 
    IADsService * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsService_get_LoadOrderGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsService_put_LoadOrderGroup_Proxy( 
    IADsService * This,
    /* [in] */ BSTR bstrLoadOrderGroup);


void __RPC_STUB IADsService_put_LoadOrderGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsService_get_ServiceAccountName_Proxy( 
    IADsService * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsService_get_ServiceAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsService_put_ServiceAccountName_Proxy( 
    IADsService * This,
    /* [in] */ BSTR bstrServiceAccountName);


void __RPC_STUB IADsService_put_ServiceAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsService_get_ServiceAccountPath_Proxy( 
    IADsService * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsService_get_ServiceAccountPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsService_put_ServiceAccountPath_Proxy( 
    IADsService * This,
    /* [in] */ BSTR bstrServiceAccountPath);


void __RPC_STUB IADsService_put_ServiceAccountPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsService_get_Dependencies_Proxy( 
    IADsService * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsService_get_Dependencies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsService_put_Dependencies_Proxy( 
    IADsService * This,
    /* [in] */ VARIANT vDependencies);


void __RPC_STUB IADsService_put_Dependencies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsService_INTERFACE_DEFINED__ */


#ifndef __IADsServiceOperations_INTERFACE_DEFINED__
#define __IADsServiceOperations_INTERFACE_DEFINED__

/* interface IADsServiceOperations */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsServiceOperations;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5d7b33f0-31ca-11cf-a98a-00aa006bc149")
    IADsServiceOperations : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Continue( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetPassword( 
            /* [in] */ BSTR bstrNewPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsServiceOperationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsServiceOperations * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsServiceOperations * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsServiceOperations * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsServiceOperations * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsServiceOperations * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsServiceOperations * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsServiceOperations * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsServiceOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsServiceOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsServiceOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsServiceOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsServiceOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsServiceOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsServiceOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsServiceOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsServiceOperations * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsServiceOperations * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsServiceOperations * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsServiceOperations * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsServiceOperations * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IADsServiceOperations * This,
            /* [retval][out] */ long *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Start )( 
            IADsServiceOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IADsServiceOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IADsServiceOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IADsServiceOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetPassword )( 
            IADsServiceOperations * This,
            /* [in] */ BSTR bstrNewPassword);
        
        END_INTERFACE
    } IADsServiceOperationsVtbl;

    interface IADsServiceOperations
    {
        CONST_VTBL struct IADsServiceOperationsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsServiceOperations_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsServiceOperations_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsServiceOperations_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsServiceOperations_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsServiceOperations_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsServiceOperations_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsServiceOperations_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsServiceOperations_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsServiceOperations_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsServiceOperations_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsServiceOperations_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsServiceOperations_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsServiceOperations_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsServiceOperations_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsServiceOperations_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsServiceOperations_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsServiceOperations_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsServiceOperations_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsServiceOperations_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsServiceOperations_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsServiceOperations_get_Status(This,retval)	\
    (This)->lpVtbl -> get_Status(This,retval)

#define IADsServiceOperations_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IADsServiceOperations_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IADsServiceOperations_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IADsServiceOperations_Continue(This)	\
    (This)->lpVtbl -> Continue(This)

#define IADsServiceOperations_SetPassword(This,bstrNewPassword)	\
    (This)->lpVtbl -> SetPassword(This,bstrNewPassword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsServiceOperations_get_Status_Proxy( 
    IADsServiceOperations * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsServiceOperations_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsServiceOperations_Start_Proxy( 
    IADsServiceOperations * This);


void __RPC_STUB IADsServiceOperations_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsServiceOperations_Stop_Proxy( 
    IADsServiceOperations * This);


void __RPC_STUB IADsServiceOperations_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsServiceOperations_Pause_Proxy( 
    IADsServiceOperations * This);


void __RPC_STUB IADsServiceOperations_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsServiceOperations_Continue_Proxy( 
    IADsServiceOperations * This);


void __RPC_STUB IADsServiceOperations_Continue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsServiceOperations_SetPassword_Proxy( 
    IADsServiceOperations * This,
    /* [in] */ BSTR bstrNewPassword);


void __RPC_STUB IADsServiceOperations_SetPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsServiceOperations_INTERFACE_DEFINED__ */


#ifndef __IADsFileService_INTERFACE_DEFINED__
#define __IADsFileService_INTERFACE_DEFINED__

/* interface IADsFileService */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsFileService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a89d1900-31ca-11cf-a98a-00aa006bc149")
    IADsFileService : public IADsService
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxUserCount( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxUserCount( 
            /* [in] */ long lnMaxUserCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsFileServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsFileService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsFileService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsFileService * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsFileService * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsFileService * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsFileService * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsFileService * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsFileService * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsFileService * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsFileService * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsFileService * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsFileService * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsFileService * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsFileService * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostComputer )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HostComputer )( 
            IADsFileService * This,
            /* [in] */ BSTR bstrHostComputer);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayName )( 
            IADsFileService * This,
            /* [in] */ BSTR bstrDisplayName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Version )( 
            IADsFileService * This,
            /* [in] */ BSTR bstrVersion);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceType )( 
            IADsFileService * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceType )( 
            IADsFileService * This,
            /* [in] */ long lnServiceType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartType )( 
            IADsFileService * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartType )( 
            IADsFileService * This,
            /* [in] */ long lnStartType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Path )( 
            IADsFileService * This,
            /* [in] */ BSTR bstrPath);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartupParameters )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartupParameters )( 
            IADsFileService * This,
            /* [in] */ BSTR bstrStartupParameters);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorControl )( 
            IADsFileService * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorControl )( 
            IADsFileService * This,
            /* [in] */ long lnErrorControl);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoadOrderGroup )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoadOrderGroup )( 
            IADsFileService * This,
            /* [in] */ BSTR bstrLoadOrderGroup);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceAccountName )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceAccountName )( 
            IADsFileService * This,
            /* [in] */ BSTR bstrServiceAccountName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceAccountPath )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceAccountPath )( 
            IADsFileService * This,
            /* [in] */ BSTR bstrServiceAccountPath);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Dependencies )( 
            IADsFileService * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Dependencies )( 
            IADsFileService * This,
            /* [in] */ VARIANT vDependencies);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IADsFileService * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IADsFileService * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxUserCount )( 
            IADsFileService * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxUserCount )( 
            IADsFileService * This,
            /* [in] */ long lnMaxUserCount);
        
        END_INTERFACE
    } IADsFileServiceVtbl;

    interface IADsFileService
    {
        CONST_VTBL struct IADsFileServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsFileService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsFileService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsFileService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsFileService_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsFileService_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsFileService_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsFileService_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsFileService_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsFileService_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsFileService_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsFileService_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsFileService_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsFileService_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsFileService_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsFileService_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsFileService_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsFileService_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsFileService_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsFileService_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsFileService_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsFileService_get_HostComputer(This,retval)	\
    (This)->lpVtbl -> get_HostComputer(This,retval)

#define IADsFileService_put_HostComputer(This,bstrHostComputer)	\
    (This)->lpVtbl -> put_HostComputer(This,bstrHostComputer)

#define IADsFileService_get_DisplayName(This,retval)	\
    (This)->lpVtbl -> get_DisplayName(This,retval)

#define IADsFileService_put_DisplayName(This,bstrDisplayName)	\
    (This)->lpVtbl -> put_DisplayName(This,bstrDisplayName)

#define IADsFileService_get_Version(This,retval)	\
    (This)->lpVtbl -> get_Version(This,retval)

#define IADsFileService_put_Version(This,bstrVersion)	\
    (This)->lpVtbl -> put_Version(This,bstrVersion)

#define IADsFileService_get_ServiceType(This,retval)	\
    (This)->lpVtbl -> get_ServiceType(This,retval)

#define IADsFileService_put_ServiceType(This,lnServiceType)	\
    (This)->lpVtbl -> put_ServiceType(This,lnServiceType)

#define IADsFileService_get_StartType(This,retval)	\
    (This)->lpVtbl -> get_StartType(This,retval)

#define IADsFileService_put_StartType(This,lnStartType)	\
    (This)->lpVtbl -> put_StartType(This,lnStartType)

#define IADsFileService_get_Path(This,retval)	\
    (This)->lpVtbl -> get_Path(This,retval)

#define IADsFileService_put_Path(This,bstrPath)	\
    (This)->lpVtbl -> put_Path(This,bstrPath)

#define IADsFileService_get_StartupParameters(This,retval)	\
    (This)->lpVtbl -> get_StartupParameters(This,retval)

#define IADsFileService_put_StartupParameters(This,bstrStartupParameters)	\
    (This)->lpVtbl -> put_StartupParameters(This,bstrStartupParameters)

#define IADsFileService_get_ErrorControl(This,retval)	\
    (This)->lpVtbl -> get_ErrorControl(This,retval)

#define IADsFileService_put_ErrorControl(This,lnErrorControl)	\
    (This)->lpVtbl -> put_ErrorControl(This,lnErrorControl)

#define IADsFileService_get_LoadOrderGroup(This,retval)	\
    (This)->lpVtbl -> get_LoadOrderGroup(This,retval)

#define IADsFileService_put_LoadOrderGroup(This,bstrLoadOrderGroup)	\
    (This)->lpVtbl -> put_LoadOrderGroup(This,bstrLoadOrderGroup)

#define IADsFileService_get_ServiceAccountName(This,retval)	\
    (This)->lpVtbl -> get_ServiceAccountName(This,retval)

#define IADsFileService_put_ServiceAccountName(This,bstrServiceAccountName)	\
    (This)->lpVtbl -> put_ServiceAccountName(This,bstrServiceAccountName)

#define IADsFileService_get_ServiceAccountPath(This,retval)	\
    (This)->lpVtbl -> get_ServiceAccountPath(This,retval)

#define IADsFileService_put_ServiceAccountPath(This,bstrServiceAccountPath)	\
    (This)->lpVtbl -> put_ServiceAccountPath(This,bstrServiceAccountPath)

#define IADsFileService_get_Dependencies(This,retval)	\
    (This)->lpVtbl -> get_Dependencies(This,retval)

#define IADsFileService_put_Dependencies(This,vDependencies)	\
    (This)->lpVtbl -> put_Dependencies(This,vDependencies)


#define IADsFileService_get_Description(This,retval)	\
    (This)->lpVtbl -> get_Description(This,retval)

#define IADsFileService_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IADsFileService_get_MaxUserCount(This,retval)	\
    (This)->lpVtbl -> get_MaxUserCount(This,retval)

#define IADsFileService_put_MaxUserCount(This,lnMaxUserCount)	\
    (This)->lpVtbl -> put_MaxUserCount(This,lnMaxUserCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsFileService_get_Description_Proxy( 
    IADsFileService * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsFileService_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsFileService_put_Description_Proxy( 
    IADsFileService * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IADsFileService_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsFileService_get_MaxUserCount_Proxy( 
    IADsFileService * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsFileService_get_MaxUserCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsFileService_put_MaxUserCount_Proxy( 
    IADsFileService * This,
    /* [in] */ long lnMaxUserCount);


void __RPC_STUB IADsFileService_put_MaxUserCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsFileService_INTERFACE_DEFINED__ */


#ifndef __IADsFileServiceOperations_INTERFACE_DEFINED__
#define __IADsFileServiceOperations_INTERFACE_DEFINED__

/* interface IADsFileServiceOperations */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsFileServiceOperations;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a02ded10-31ca-11cf-a98a-00aa006bc149")
    IADsFileServiceOperations : public IADsServiceOperations
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Sessions( 
            /* [retval][out] */ IADsCollection **ppSessions) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Resources( 
            /* [retval][out] */ IADsCollection **ppResources) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsFileServiceOperationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsFileServiceOperations * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsFileServiceOperations * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsFileServiceOperations * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsFileServiceOperations * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsFileServiceOperations * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsFileServiceOperations * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsFileServiceOperations * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsFileServiceOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsFileServiceOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsFileServiceOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsFileServiceOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsFileServiceOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsFileServiceOperations * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsFileServiceOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsFileServiceOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsFileServiceOperations * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsFileServiceOperations * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsFileServiceOperations * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsFileServiceOperations * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsFileServiceOperations * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IADsFileServiceOperations * This,
            /* [retval][out] */ long *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Start )( 
            IADsFileServiceOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IADsFileServiceOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IADsFileServiceOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IADsFileServiceOperations * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetPassword )( 
            IADsFileServiceOperations * This,
            /* [in] */ BSTR bstrNewPassword);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Sessions )( 
            IADsFileServiceOperations * This,
            /* [retval][out] */ IADsCollection **ppSessions);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Resources )( 
            IADsFileServiceOperations * This,
            /* [retval][out] */ IADsCollection **ppResources);
        
        END_INTERFACE
    } IADsFileServiceOperationsVtbl;

    interface IADsFileServiceOperations
    {
        CONST_VTBL struct IADsFileServiceOperationsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsFileServiceOperations_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsFileServiceOperations_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsFileServiceOperations_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsFileServiceOperations_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsFileServiceOperations_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsFileServiceOperations_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsFileServiceOperations_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsFileServiceOperations_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsFileServiceOperations_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsFileServiceOperations_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsFileServiceOperations_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsFileServiceOperations_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsFileServiceOperations_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsFileServiceOperations_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsFileServiceOperations_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsFileServiceOperations_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsFileServiceOperations_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsFileServiceOperations_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsFileServiceOperations_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsFileServiceOperations_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsFileServiceOperations_get_Status(This,retval)	\
    (This)->lpVtbl -> get_Status(This,retval)

#define IADsFileServiceOperations_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IADsFileServiceOperations_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IADsFileServiceOperations_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IADsFileServiceOperations_Continue(This)	\
    (This)->lpVtbl -> Continue(This)

#define IADsFileServiceOperations_SetPassword(This,bstrNewPassword)	\
    (This)->lpVtbl -> SetPassword(This,bstrNewPassword)


#define IADsFileServiceOperations_Sessions(This,ppSessions)	\
    (This)->lpVtbl -> Sessions(This,ppSessions)

#define IADsFileServiceOperations_Resources(This,ppResources)	\
    (This)->lpVtbl -> Resources(This,ppResources)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IADsFileServiceOperations_Sessions_Proxy( 
    IADsFileServiceOperations * This,
    /* [retval][out] */ IADsCollection **ppSessions);


void __RPC_STUB IADsFileServiceOperations_Sessions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsFileServiceOperations_Resources_Proxy( 
    IADsFileServiceOperations * This,
    /* [retval][out] */ IADsCollection **ppResources);


void __RPC_STUB IADsFileServiceOperations_Resources_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsFileServiceOperations_INTERFACE_DEFINED__ */


#ifndef __IADsFileShare_INTERFACE_DEFINED__
#define __IADsFileShare_INTERFACE_DEFINED__

/* interface IADsFileShare */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsFileShare;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eb6dcaf0-4b83-11cf-a995-00aa006bc149")
    IADsFileShare : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentUserCount( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HostComputer( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_HostComputer( 
            /* [in] */ BSTR bstrHostComputer) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR bstrPath) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxUserCount( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxUserCount( 
            /* [in] */ long lnMaxUserCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsFileShareVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsFileShare * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsFileShare * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsFileShare * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsFileShare * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsFileShare * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsFileShare * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsFileShare * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsFileShare * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsFileShare * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsFileShare * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsFileShare * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsFileShare * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsFileShare * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsFileShare * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsFileShare * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsFileShare * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsFileShare * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsFileShare * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsFileShare * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsFileShare * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentUserCount )( 
            IADsFileShare * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IADsFileShare * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IADsFileShare * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostComputer )( 
            IADsFileShare * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HostComputer )( 
            IADsFileShare * This,
            /* [in] */ BSTR bstrHostComputer);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IADsFileShare * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Path )( 
            IADsFileShare * This,
            /* [in] */ BSTR bstrPath);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxUserCount )( 
            IADsFileShare * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxUserCount )( 
            IADsFileShare * This,
            /* [in] */ long lnMaxUserCount);
        
        END_INTERFACE
    } IADsFileShareVtbl;

    interface IADsFileShare
    {
        CONST_VTBL struct IADsFileShareVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsFileShare_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsFileShare_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsFileShare_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsFileShare_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsFileShare_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsFileShare_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsFileShare_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsFileShare_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsFileShare_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsFileShare_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsFileShare_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsFileShare_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsFileShare_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsFileShare_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsFileShare_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsFileShare_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsFileShare_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsFileShare_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsFileShare_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsFileShare_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsFileShare_get_CurrentUserCount(This,retval)	\
    (This)->lpVtbl -> get_CurrentUserCount(This,retval)

#define IADsFileShare_get_Description(This,retval)	\
    (This)->lpVtbl -> get_Description(This,retval)

#define IADsFileShare_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IADsFileShare_get_HostComputer(This,retval)	\
    (This)->lpVtbl -> get_HostComputer(This,retval)

#define IADsFileShare_put_HostComputer(This,bstrHostComputer)	\
    (This)->lpVtbl -> put_HostComputer(This,bstrHostComputer)

#define IADsFileShare_get_Path(This,retval)	\
    (This)->lpVtbl -> get_Path(This,retval)

#define IADsFileShare_put_Path(This,bstrPath)	\
    (This)->lpVtbl -> put_Path(This,bstrPath)

#define IADsFileShare_get_MaxUserCount(This,retval)	\
    (This)->lpVtbl -> get_MaxUserCount(This,retval)

#define IADsFileShare_put_MaxUserCount(This,lnMaxUserCount)	\
    (This)->lpVtbl -> put_MaxUserCount(This,lnMaxUserCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsFileShare_get_CurrentUserCount_Proxy( 
    IADsFileShare * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsFileShare_get_CurrentUserCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsFileShare_get_Description_Proxy( 
    IADsFileShare * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsFileShare_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsFileShare_put_Description_Proxy( 
    IADsFileShare * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IADsFileShare_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsFileShare_get_HostComputer_Proxy( 
    IADsFileShare * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsFileShare_get_HostComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsFileShare_put_HostComputer_Proxy( 
    IADsFileShare * This,
    /* [in] */ BSTR bstrHostComputer);


void __RPC_STUB IADsFileShare_put_HostComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsFileShare_get_Path_Proxy( 
    IADsFileShare * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsFileShare_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsFileShare_put_Path_Proxy( 
    IADsFileShare * This,
    /* [in] */ BSTR bstrPath);


void __RPC_STUB IADsFileShare_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsFileShare_get_MaxUserCount_Proxy( 
    IADsFileShare * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsFileShare_get_MaxUserCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsFileShare_put_MaxUserCount_Proxy( 
    IADsFileShare * This,
    /* [in] */ long lnMaxUserCount);


void __RPC_STUB IADsFileShare_put_MaxUserCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsFileShare_INTERFACE_DEFINED__ */


#ifndef __IADsSession_INTERFACE_DEFINED__
#define __IADsSession_INTERFACE_DEFINED__

/* interface IADsSession */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("398b7da0-4aab-11cf-ae2c-00aa006ebfb9")
    IADsSession : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_User( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_UserPath( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Computer( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ComputerPath( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectTime( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_IdleTime( 
            /* [retval][out] */ long *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsSession * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsSession * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsSession * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsSession * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsSession * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsSession * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsSession * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsSession * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsSession * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsSession * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsSession * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsSession * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsSession * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsSession * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsSession * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsSession * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsSession * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_User )( 
            IADsSession * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserPath )( 
            IADsSession * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Computer )( 
            IADsSession * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ComputerPath )( 
            IADsSession * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectTime )( 
            IADsSession * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IdleTime )( 
            IADsSession * This,
            /* [retval][out] */ long *retval);
        
        END_INTERFACE
    } IADsSessionVtbl;

    interface IADsSession
    {
        CONST_VTBL struct IADsSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsSession_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsSession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsSession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsSession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsSession_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsSession_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsSession_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsSession_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsSession_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsSession_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsSession_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsSession_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsSession_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsSession_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsSession_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsSession_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsSession_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsSession_get_User(This,retval)	\
    (This)->lpVtbl -> get_User(This,retval)

#define IADsSession_get_UserPath(This,retval)	\
    (This)->lpVtbl -> get_UserPath(This,retval)

#define IADsSession_get_Computer(This,retval)	\
    (This)->lpVtbl -> get_Computer(This,retval)

#define IADsSession_get_ComputerPath(This,retval)	\
    (This)->lpVtbl -> get_ComputerPath(This,retval)

#define IADsSession_get_ConnectTime(This,retval)	\
    (This)->lpVtbl -> get_ConnectTime(This,retval)

#define IADsSession_get_IdleTime(This,retval)	\
    (This)->lpVtbl -> get_IdleTime(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSession_get_User_Proxy( 
    IADsSession * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsSession_get_User_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSession_get_UserPath_Proxy( 
    IADsSession * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsSession_get_UserPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSession_get_Computer_Proxy( 
    IADsSession * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsSession_get_Computer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSession_get_ComputerPath_Proxy( 
    IADsSession * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsSession_get_ComputerPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSession_get_ConnectTime_Proxy( 
    IADsSession * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsSession_get_ConnectTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSession_get_IdleTime_Proxy( 
    IADsSession * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsSession_get_IdleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsSession_INTERFACE_DEFINED__ */


#ifndef __IADsResource_INTERFACE_DEFINED__
#define __IADsResource_INTERFACE_DEFINED__

/* interface IADsResource */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34a05b20-4aab-11cf-ae2c-00aa006ebfb9")
    IADsResource : public IADs
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_User( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_UserPath( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LockCount( 
            /* [retval][out] */ long *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsResource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsResource * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsResource * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsResource * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsResource * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADsResource * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADsResource * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADsResource * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADsResource * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADsResource * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADsResource * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADsResource * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADsResource * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsResource * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADsResource * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsResource * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADsResource * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADsResource * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_User )( 
            IADsResource * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserPath )( 
            IADsResource * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IADsResource * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LockCount )( 
            IADsResource * This,
            /* [retval][out] */ long *retval);
        
        END_INTERFACE
    } IADsResourceVtbl;

    interface IADsResource
    {
        CONST_VTBL struct IADsResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsResource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsResource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsResource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsResource_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsResource_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsResource_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsResource_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsResource_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IADsResource_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IADsResource_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IADsResource_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IADsResource_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IADsResource_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IADsResource_GetInfo(This)	\
    (This)->lpVtbl -> GetInfo(This)

#define IADsResource_SetInfo(This)	\
    (This)->lpVtbl -> SetInfo(This)

#define IADsResource_Get(This,bstrName,pvProp)	\
    (This)->lpVtbl -> Get(This,bstrName,pvProp)

#define IADsResource_Put(This,bstrName,vProp)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp)

#define IADsResource_GetEx(This,bstrName,pvProp)	\
    (This)->lpVtbl -> GetEx(This,bstrName,pvProp)

#define IADsResource_PutEx(This,lnControlCode,bstrName,vProp)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp)

#define IADsResource_GetInfoEx(This,vProperties,lnReserved)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved)


#define IADsResource_get_User(This,retval)	\
    (This)->lpVtbl -> get_User(This,retval)

#define IADsResource_get_UserPath(This,retval)	\
    (This)->lpVtbl -> get_UserPath(This,retval)

#define IADsResource_get_Path(This,retval)	\
    (This)->lpVtbl -> get_Path(This,retval)

#define IADsResource_get_LockCount(This,retval)	\
    (This)->lpVtbl -> get_LockCount(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsResource_get_User_Proxy( 
    IADsResource * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsResource_get_User_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsResource_get_UserPath_Proxy( 
    IADsResource * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsResource_get_UserPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsResource_get_Path_Proxy( 
    IADsResource * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsResource_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsResource_get_LockCount_Proxy( 
    IADsResource * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsResource_get_LockCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsResource_INTERFACE_DEFINED__ */


#ifndef __IADsOpenDSObject_INTERFACE_DEFINED__
#define __IADsOpenDSObject_INTERFACE_DEFINED__

/* interface IADsOpenDSObject */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsOpenDSObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddf2891e-0f9c-11d0-8ad4-00c04fd8d503")
    IADsOpenDSObject : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE OpenDSObject( 
            /* [in] */ BSTR lpszDNName,
            /* [in] */ BSTR lpszUserName,
            /* [in] */ BSTR lpszPassword,
            /* [in] */ long lnReserved,
            /* [retval][out] */ IDispatch **ppOleDsObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsOpenDSObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsOpenDSObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsOpenDSObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsOpenDSObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsOpenDSObject * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsOpenDSObject * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsOpenDSObject * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsOpenDSObject * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *OpenDSObject )( 
            IADsOpenDSObject * This,
            /* [in] */ BSTR lpszDNName,
            /* [in] */ BSTR lpszUserName,
            /* [in] */ BSTR lpszPassword,
            /* [in] */ long lnReserved,
            /* [retval][out] */ IDispatch **ppOleDsObj);
        
        END_INTERFACE
    } IADsOpenDSObjectVtbl;

    interface IADsOpenDSObject
    {
        CONST_VTBL struct IADsOpenDSObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsOpenDSObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsOpenDSObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsOpenDSObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsOpenDSObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsOpenDSObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsOpenDSObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsOpenDSObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsOpenDSObject_OpenDSObject(This,lpszDNName,lpszUserName,lpszPassword,lnReserved,ppOleDsObj)	\
    (This)->lpVtbl -> OpenDSObject(This,lpszDNName,lpszUserName,lpszPassword,lnReserved,ppOleDsObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IADsOpenDSObject_OpenDSObject_Proxy( 
    IADsOpenDSObject * This,
    /* [in] */ BSTR lpszDNName,
    /* [in] */ BSTR lpszUserName,
    /* [in] */ BSTR lpszPassword,
    /* [in] */ long lnReserved,
    /* [retval][out] */ IDispatch **ppOleDsObj);


void __RPC_STUB IADsOpenDSObject_OpenDSObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsOpenDSObject_INTERFACE_DEFINED__ */


#ifndef __IDirectoryObject_INTERFACE_DEFINED__
#define __IDirectoryObject_INTERFACE_DEFINED__

/* interface IDirectoryObject */
/* [object][uuid] */ 


EXTERN_C const IID IID_IDirectoryObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e798de2c-22e4-11d0-84fe-00c04fd8d503")
    IDirectoryObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObjectInformation( 
            /* [out] */ PADS_OBJECT_INFO *ppObjInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectAttributes( 
            /* [in] */ LPWSTR *pAttributeNames,
            /* [in] */ DWORD dwNumberAttributes,
            /* [out] */ PADS_ATTR_INFO *ppAttributeEntries,
            /* [out] */ DWORD *pdwNumAttributesReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetObjectAttributes( 
            /* [in] */ PADS_ATTR_INFO pAttributeEntries,
            /* [in] */ DWORD dwNumAttributes,
            /* [out] */ DWORD *pdwNumAttributesModified) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDSObject( 
            /* [in] */ LPWSTR pszRDNName,
            /* [in] */ PADS_ATTR_INFO pAttributeEntries,
            /* [in] */ DWORD dwNumAttributes,
            /* [out] */ IDispatch **ppObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteDSObject( 
            /* [in] */ LPWSTR pszRDNName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectoryObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectoryObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectoryObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectoryObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectInformation )( 
            IDirectoryObject * This,
            /* [out] */ PADS_OBJECT_INFO *ppObjInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectAttributes )( 
            IDirectoryObject * This,
            /* [in] */ LPWSTR *pAttributeNames,
            /* [in] */ DWORD dwNumberAttributes,
            /* [out] */ PADS_ATTR_INFO *ppAttributeEntries,
            /* [out] */ DWORD *pdwNumAttributesReturned);
        
        HRESULT ( STDMETHODCALLTYPE *SetObjectAttributes )( 
            IDirectoryObject * This,
            /* [in] */ PADS_ATTR_INFO pAttributeEntries,
            /* [in] */ DWORD dwNumAttributes,
            /* [out] */ DWORD *pdwNumAttributesModified);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDSObject )( 
            IDirectoryObject * This,
            /* [in] */ LPWSTR pszRDNName,
            /* [in] */ PADS_ATTR_INFO pAttributeEntries,
            /* [in] */ DWORD dwNumAttributes,
            /* [out] */ IDispatch **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteDSObject )( 
            IDirectoryObject * This,
            /* [in] */ LPWSTR pszRDNName);
        
        END_INTERFACE
    } IDirectoryObjectVtbl;

    interface IDirectoryObject
    {
        CONST_VTBL struct IDirectoryObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectoryObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirectoryObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirectoryObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirectoryObject_GetObjectInformation(This,ppObjInfo)	\
    (This)->lpVtbl -> GetObjectInformation(This,ppObjInfo)

#define IDirectoryObject_GetObjectAttributes(This,pAttributeNames,dwNumberAttributes,ppAttributeEntries,pdwNumAttributesReturned)	\
    (This)->lpVtbl -> GetObjectAttributes(This,pAttributeNames,dwNumberAttributes,ppAttributeEntries,pdwNumAttributesReturned)

#define IDirectoryObject_SetObjectAttributes(This,pAttributeEntries,dwNumAttributes,pdwNumAttributesModified)	\
    (This)->lpVtbl -> SetObjectAttributes(This,pAttributeEntries,dwNumAttributes,pdwNumAttributesModified)

#define IDirectoryObject_CreateDSObject(This,pszRDNName,pAttributeEntries,dwNumAttributes,ppObject)	\
    (This)->lpVtbl -> CreateDSObject(This,pszRDNName,pAttributeEntries,dwNumAttributes,ppObject)

#define IDirectoryObject_DeleteDSObject(This,pszRDNName)	\
    (This)->lpVtbl -> DeleteDSObject(This,pszRDNName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirectoryObject_GetObjectInformation_Proxy( 
    IDirectoryObject * This,
    /* [out] */ PADS_OBJECT_INFO *ppObjInfo);


void __RPC_STUB IDirectoryObject_GetObjectInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectoryObject_GetObjectAttributes_Proxy( 
    IDirectoryObject * This,
    /* [in] */ LPWSTR *pAttributeNames,
    /* [in] */ DWORD dwNumberAttributes,
    /* [out] */ PADS_ATTR_INFO *ppAttributeEntries,
    /* [out] */ DWORD *pdwNumAttributesReturned);


void __RPC_STUB IDirectoryObject_GetObjectAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectoryObject_SetObjectAttributes_Proxy( 
    IDirectoryObject * This,
    /* [in] */ PADS_ATTR_INFO pAttributeEntries,
    /* [in] */ DWORD dwNumAttributes,
    /* [out] */ DWORD *pdwNumAttributesModified);


void __RPC_STUB IDirectoryObject_SetObjectAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectoryObject_CreateDSObject_Proxy( 
    IDirectoryObject * This,
    /* [in] */ LPWSTR pszRDNName,
    /* [in] */ PADS_ATTR_INFO pAttributeEntries,
    /* [in] */ DWORD dwNumAttributes,
    /* [out] */ IDispatch **ppObject);


void __RPC_STUB IDirectoryObject_CreateDSObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectoryObject_DeleteDSObject_Proxy( 
    IDirectoryObject * This,
    /* [in] */ LPWSTR pszRDNName);


void __RPC_STUB IDirectoryObject_DeleteDSObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirectoryObject_INTERFACE_DEFINED__ */


#ifndef __IDirectorySearch_INTERFACE_DEFINED__
#define __IDirectorySearch_INTERFACE_DEFINED__

/* interface IDirectorySearch */
/* [object][uuid] */ 


EXTERN_C const IID IID_IDirectorySearch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("109ba8ec-92f0-11d0-a790-00c04fd8d5a8")
    IDirectorySearch : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSearchPreference( 
            /* [in] */ PADS_SEARCHPREF_INFO pSearchPrefs,
            /* [in] */ DWORD dwNumPrefs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteSearch( 
            /* [in] */ LPWSTR pszSearchFilter,
            /* [in] */ LPWSTR *pAttributeNames,
            /* [in] */ DWORD dwNumberAttributes,
            /* [out] */ PADS_SEARCH_HANDLE phSearchResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbandonSearch( 
            /* [in] */ ADS_SEARCH_HANDLE phSearchResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstRow( 
            /* [in] */ ADS_SEARCH_HANDLE hSearchResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextRow( 
            /* [in] */ ADS_SEARCH_HANDLE hSearchResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreviousRow( 
            /* [in] */ ADS_SEARCH_HANDLE hSearchResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextColumnName( 
            /* [in] */ ADS_SEARCH_HANDLE hSearchHandle,
            /* [out] */ LPWSTR *ppszColumnName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumn( 
            /* [in] */ ADS_SEARCH_HANDLE hSearchResult,
            /* [in] */ LPWSTR szColumnName,
            /* [out] */ PADS_SEARCH_COLUMN pSearchColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeColumn( 
            /* [in] */ PADS_SEARCH_COLUMN pSearchColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseSearchHandle( 
            /* [in] */ ADS_SEARCH_HANDLE hSearchResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectorySearchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectorySearch * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectorySearch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectorySearch * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSearchPreference )( 
            IDirectorySearch * This,
            /* [in] */ PADS_SEARCHPREF_INFO pSearchPrefs,
            /* [in] */ DWORD dwNumPrefs);
        
        HRESULT ( STDMETHODCALLTYPE *ExecuteSearch )( 
            IDirectorySearch * This,
            /* [in] */ LPWSTR pszSearchFilter,
            /* [in] */ LPWSTR *pAttributeNames,
            /* [in] */ DWORD dwNumberAttributes,
            /* [out] */ PADS_SEARCH_HANDLE phSearchResult);
        
        HRESULT ( STDMETHODCALLTYPE *AbandonSearch )( 
            IDirectorySearch * This,
            /* [in] */ ADS_SEARCH_HANDLE phSearchResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstRow )( 
            IDirectorySearch * This,
            /* [in] */ ADS_SEARCH_HANDLE hSearchResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextRow )( 
            IDirectorySearch * This,
            /* [in] */ ADS_SEARCH_HANDLE hSearchResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreviousRow )( 
            IDirectorySearch * This,
            /* [in] */ ADS_SEARCH_HANDLE hSearchResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextColumnName )( 
            IDirectorySearch * This,
            /* [in] */ ADS_SEARCH_HANDLE hSearchHandle,
            /* [out] */ LPWSTR *ppszColumnName);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumn )( 
            IDirectorySearch * This,
            /* [in] */ ADS_SEARCH_HANDLE hSearchResult,
            /* [in] */ LPWSTR szColumnName,
            /* [out] */ PADS_SEARCH_COLUMN pSearchColumn);
        
        HRESULT ( STDMETHODCALLTYPE *FreeColumn )( 
            IDirectorySearch * This,
            /* [in] */ PADS_SEARCH_COLUMN pSearchColumn);
        
        HRESULT ( STDMETHODCALLTYPE *CloseSearchHandle )( 
            IDirectorySearch * This,
            /* [in] */ ADS_SEARCH_HANDLE hSearchResult);
        
        END_INTERFACE
    } IDirectorySearchVtbl;

    interface IDirectorySearch
    {
        CONST_VTBL struct IDirectorySearchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectorySearch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirectorySearch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirectorySearch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirectorySearch_SetSearchPreference(This,pSearchPrefs,dwNumPrefs)	\
    (This)->lpVtbl -> SetSearchPreference(This,pSearchPrefs,dwNumPrefs)

#define IDirectorySearch_ExecuteSearch(This,pszSearchFilter,pAttributeNames,dwNumberAttributes,phSearchResult)	\
    (This)->lpVtbl -> ExecuteSearch(This,pszSearchFilter,pAttributeNames,dwNumberAttributes,phSearchResult)

#define IDirectorySearch_AbandonSearch(This,phSearchResult)	\
    (This)->lpVtbl -> AbandonSearch(This,phSearchResult)

#define IDirectorySearch_GetFirstRow(This,hSearchResult)	\
    (This)->lpVtbl -> GetFirstRow(This,hSearchResult)

#define IDirectorySearch_GetNextRow(This,hSearchResult)	\
    (This)->lpVtbl -> GetNextRow(This,hSearchResult)

#define IDirectorySearch_GetPreviousRow(This,hSearchResult)	\
    (This)->lpVtbl -> GetPreviousRow(This,hSearchResult)

#define IDirectorySearch_GetNextColumnName(This,hSearchHandle,ppszColumnName)	\
    (This)->lpVtbl -> GetNextColumnName(This,hSearchHandle,ppszColumnName)

#define IDirectorySearch_GetColumn(This,hSearchResult,szColumnName,pSearchColumn)	\
    (This)->lpVtbl -> GetColumn(This,hSearchResult,szColumnName,pSearchColumn)

#define IDirectorySearch_FreeColumn(This,pSearchColumn)	\
    (This)->lpVtbl -> FreeColumn(This,pSearchColumn)

#define IDirectorySearch_CloseSearchHandle(This,hSearchResult)	\
    (This)->lpVtbl -> CloseSearchHandle(This,hSearchResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirectorySearch_SetSearchPreference_Proxy( 
    IDirectorySearch * This,
    /* [in] */ PADS_SEARCHPREF_INFO pSearchPrefs,
    /* [in] */ DWORD dwNumPrefs);


void __RPC_STUB IDirectorySearch_SetSearchPreference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySearch_ExecuteSearch_Proxy( 
    IDirectorySearch * This,
    /* [in] */ LPWSTR pszSearchFilter,
    /* [in] */ LPWSTR *pAttributeNames,
    /* [in] */ DWORD dwNumberAttributes,
    /* [out] */ PADS_SEARCH_HANDLE phSearchResult);


void __RPC_STUB IDirectorySearch_ExecuteSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySearch_AbandonSearch_Proxy( 
    IDirectorySearch * This,
    /* [in] */ ADS_SEARCH_HANDLE phSearchResult);


void __RPC_STUB IDirectorySearch_AbandonSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySearch_GetFirstRow_Proxy( 
    IDirectorySearch * This,
    /* [in] */ ADS_SEARCH_HANDLE hSearchResult);


void __RPC_STUB IDirectorySearch_GetFirstRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySearch_GetNextRow_Proxy( 
    IDirectorySearch * This,
    /* [in] */ ADS_SEARCH_HANDLE hSearchResult);


void __RPC_STUB IDirectorySearch_GetNextRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySearch_GetPreviousRow_Proxy( 
    IDirectorySearch * This,
    /* [in] */ ADS_SEARCH_HANDLE hSearchResult);


void __RPC_STUB IDirectorySearch_GetPreviousRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySearch_GetNextColumnName_Proxy( 
    IDirectorySearch * This,
    /* [in] */ ADS_SEARCH_HANDLE hSearchHandle,
    /* [out] */ LPWSTR *ppszColumnName);


void __RPC_STUB IDirectorySearch_GetNextColumnName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySearch_GetColumn_Proxy( 
    IDirectorySearch * This,
    /* [in] */ ADS_SEARCH_HANDLE hSearchResult,
    /* [in] */ LPWSTR szColumnName,
    /* [out] */ PADS_SEARCH_COLUMN pSearchColumn);


void __RPC_STUB IDirectorySearch_GetColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySearch_FreeColumn_Proxy( 
    IDirectorySearch * This,
    /* [in] */ PADS_SEARCH_COLUMN pSearchColumn);


void __RPC_STUB IDirectorySearch_FreeColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySearch_CloseSearchHandle_Proxy( 
    IDirectorySearch * This,
    /* [in] */ ADS_SEARCH_HANDLE hSearchResult);


void __RPC_STUB IDirectorySearch_CloseSearchHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirectorySearch_INTERFACE_DEFINED__ */


#ifndef __IDirectorySchemaMgmt_INTERFACE_DEFINED__
#define __IDirectorySchemaMgmt_INTERFACE_DEFINED__

/* interface IDirectorySchemaMgmt */
/* [object][uuid] */ 


EXTERN_C const IID IID_IDirectorySchemaMgmt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75db3b9c-a4d8-11d0-a79c-00c04fd8d5a8")
    IDirectorySchemaMgmt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumAttributes( 
            LPWSTR *ppszAttrNames,
            DWORD dwNumAttributes,
            PADS_ATTR_DEF *ppAttrDefinition,
            DWORD *pdwNumAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAttributeDefinition( 
            LPWSTR pszAttributeName,
            PADS_ATTR_DEF pAttributeDefinition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteAttributeDefinition( 
            LPWSTR pszAttributeName,
            PADS_ATTR_DEF pAttributeDefinition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAttributeDefinition( 
            LPWSTR pszAttributeName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumClasses( 
            LPWSTR *ppszClassNames,
            DWORD dwNumClasses,
            PADS_CLASS_DEF *ppClassDefinition,
            DWORD *pdwNumClasses) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteClassDefinition( 
            LPWSTR pszClassName,
            PADS_CLASS_DEF pClassDefinition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassDefinition( 
            LPWSTR pszClassName,
            PADS_CLASS_DEF pClassDefinition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClassDefinition( 
            LPWSTR pszClassName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectorySchemaMgmtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectorySchemaMgmt * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectorySchemaMgmt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectorySchemaMgmt * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAttributes )( 
            IDirectorySchemaMgmt * This,
            LPWSTR *ppszAttrNames,
            DWORD dwNumAttributes,
            PADS_ATTR_DEF *ppAttrDefinition,
            DWORD *pdwNumAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAttributeDefinition )( 
            IDirectorySchemaMgmt * This,
            LPWSTR pszAttributeName,
            PADS_ATTR_DEF pAttributeDefinition);
        
        HRESULT ( STDMETHODCALLTYPE *WriteAttributeDefinition )( 
            IDirectorySchemaMgmt * This,
            LPWSTR pszAttributeName,
            PADS_ATTR_DEF pAttributeDefinition);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAttributeDefinition )( 
            IDirectorySchemaMgmt * This,
            LPWSTR pszAttributeName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumClasses )( 
            IDirectorySchemaMgmt * This,
            LPWSTR *ppszClassNames,
            DWORD dwNumClasses,
            PADS_CLASS_DEF *ppClassDefinition,
            DWORD *pdwNumClasses);
        
        HRESULT ( STDMETHODCALLTYPE *WriteClassDefinition )( 
            IDirectorySchemaMgmt * This,
            LPWSTR pszClassName,
            PADS_CLASS_DEF pClassDefinition);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClassDefinition )( 
            IDirectorySchemaMgmt * This,
            LPWSTR pszClassName,
            PADS_CLASS_DEF pClassDefinition);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteClassDefinition )( 
            IDirectorySchemaMgmt * This,
            LPWSTR pszClassName);
        
        END_INTERFACE
    } IDirectorySchemaMgmtVtbl;

    interface IDirectorySchemaMgmt
    {
        CONST_VTBL struct IDirectorySchemaMgmtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectorySchemaMgmt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirectorySchemaMgmt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirectorySchemaMgmt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirectorySchemaMgmt_EnumAttributes(This,ppszAttrNames,dwNumAttributes,ppAttrDefinition,pdwNumAttributes)	\
    (This)->lpVtbl -> EnumAttributes(This,ppszAttrNames,dwNumAttributes,ppAttrDefinition,pdwNumAttributes)

#define IDirectorySchemaMgmt_CreateAttributeDefinition(This,pszAttributeName,pAttributeDefinition)	\
    (This)->lpVtbl -> CreateAttributeDefinition(This,pszAttributeName,pAttributeDefinition)

#define IDirectorySchemaMgmt_WriteAttributeDefinition(This,pszAttributeName,pAttributeDefinition)	\
    (This)->lpVtbl -> WriteAttributeDefinition(This,pszAttributeName,pAttributeDefinition)

#define IDirectorySchemaMgmt_DeleteAttributeDefinition(This,pszAttributeName)	\
    (This)->lpVtbl -> DeleteAttributeDefinition(This,pszAttributeName)

#define IDirectorySchemaMgmt_EnumClasses(This,ppszClassNames,dwNumClasses,ppClassDefinition,pdwNumClasses)	\
    (This)->lpVtbl -> EnumClasses(This,ppszClassNames,dwNumClasses,ppClassDefinition,pdwNumClasses)

#define IDirectorySchemaMgmt_WriteClassDefinition(This,pszClassName,pClassDefinition)	\
    (This)->lpVtbl -> WriteClassDefinition(This,pszClassName,pClassDefinition)

#define IDirectorySchemaMgmt_CreateClassDefinition(This,pszClassName,pClassDefinition)	\
    (This)->lpVtbl -> CreateClassDefinition(This,pszClassName,pClassDefinition)

#define IDirectorySchemaMgmt_DeleteClassDefinition(This,pszClassName)	\
    (This)->lpVtbl -> DeleteClassDefinition(This,pszClassName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirectorySchemaMgmt_EnumAttributes_Proxy( 
    IDirectorySchemaMgmt * This,
    LPWSTR *ppszAttrNames,
    DWORD dwNumAttributes,
    PADS_ATTR_DEF *ppAttrDefinition,
    DWORD *pdwNumAttributes);


void __RPC_STUB IDirectorySchemaMgmt_EnumAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySchemaMgmt_CreateAttributeDefinition_Proxy( 
    IDirectorySchemaMgmt * This,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition);


void __RPC_STUB IDirectorySchemaMgmt_CreateAttributeDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySchemaMgmt_WriteAttributeDefinition_Proxy( 
    IDirectorySchemaMgmt * This,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition);


void __RPC_STUB IDirectorySchemaMgmt_WriteAttributeDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySchemaMgmt_DeleteAttributeDefinition_Proxy( 
    IDirectorySchemaMgmt * This,
    LPWSTR pszAttributeName);


void __RPC_STUB IDirectorySchemaMgmt_DeleteAttributeDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySchemaMgmt_EnumClasses_Proxy( 
    IDirectorySchemaMgmt * This,
    LPWSTR *ppszClassNames,
    DWORD dwNumClasses,
    PADS_CLASS_DEF *ppClassDefinition,
    DWORD *pdwNumClasses);


void __RPC_STUB IDirectorySchemaMgmt_EnumClasses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySchemaMgmt_WriteClassDefinition_Proxy( 
    IDirectorySchemaMgmt * This,
    LPWSTR pszClassName,
    PADS_CLASS_DEF pClassDefinition);


void __RPC_STUB IDirectorySchemaMgmt_WriteClassDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySchemaMgmt_CreateClassDefinition_Proxy( 
    IDirectorySchemaMgmt * This,
    LPWSTR pszClassName,
    PADS_CLASS_DEF pClassDefinition);


void __RPC_STUB IDirectorySchemaMgmt_CreateClassDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectorySchemaMgmt_DeleteClassDefinition_Proxy( 
    IDirectorySchemaMgmt * This,
    LPWSTR pszClassName);


void __RPC_STUB IDirectorySchemaMgmt_DeleteClassDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirectorySchemaMgmt_INTERFACE_DEFINED__ */


#ifndef __IADsAggregatee_INTERFACE_DEFINED__
#define __IADsAggregatee_INTERFACE_DEFINED__

/* interface IADsAggregatee */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsAggregatee;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1346ce8c-9039-11d0-8528-00c04fd8d503")
    IADsAggregatee : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectAsAggregatee( 
            IUnknown *pOuterUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisconnectAsAggregatee( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RelinquishInterface( 
            REFIID riid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestoreInterface( 
            REFIID riid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsAggregateeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsAggregatee * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsAggregatee * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsAggregatee * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectAsAggregatee )( 
            IADsAggregatee * This,
            IUnknown *pOuterUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *DisconnectAsAggregatee )( 
            IADsAggregatee * This);
        
        HRESULT ( STDMETHODCALLTYPE *RelinquishInterface )( 
            IADsAggregatee * This,
            REFIID riid);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreInterface )( 
            IADsAggregatee * This,
            REFIID riid);
        
        END_INTERFACE
    } IADsAggregateeVtbl;

    interface IADsAggregatee
    {
        CONST_VTBL struct IADsAggregateeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsAggregatee_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsAggregatee_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsAggregatee_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsAggregatee_ConnectAsAggregatee(This,pOuterUnknown)	\
    (This)->lpVtbl -> ConnectAsAggregatee(This,pOuterUnknown)

#define IADsAggregatee_DisconnectAsAggregatee(This)	\
    (This)->lpVtbl -> DisconnectAsAggregatee(This)

#define IADsAggregatee_RelinquishInterface(This,riid)	\
    (This)->lpVtbl -> RelinquishInterface(This,riid)

#define IADsAggregatee_RestoreInterface(This,riid)	\
    (This)->lpVtbl -> RestoreInterface(This,riid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsAggregatee_ConnectAsAggregatee_Proxy( 
    IADsAggregatee * This,
    IUnknown *pOuterUnknown);


void __RPC_STUB IADsAggregatee_ConnectAsAggregatee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsAggregatee_DisconnectAsAggregatee_Proxy( 
    IADsAggregatee * This);


void __RPC_STUB IADsAggregatee_DisconnectAsAggregatee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsAggregatee_RelinquishInterface_Proxy( 
    IADsAggregatee * This,
    REFIID riid);


void __RPC_STUB IADsAggregatee_RelinquishInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsAggregatee_RestoreInterface_Proxy( 
    IADsAggregatee * This,
    REFIID riid);


void __RPC_STUB IADsAggregatee_RestoreInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsAggregatee_INTERFACE_DEFINED__ */


#ifndef __IADsAggregator_INTERFACE_DEFINED__
#define __IADsAggregator_INTERFACE_DEFINED__

/* interface IADsAggregator */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsAggregator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52db5fb0-941f-11d0-8529-00c04fd8d503")
    IADsAggregator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectAsAggregator( 
            IUnknown *pAggregatee) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisconnectAsAggregator( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsAggregatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsAggregator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsAggregator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsAggregator * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectAsAggregator )( 
            IADsAggregator * This,
            IUnknown *pAggregatee);
        
        HRESULT ( STDMETHODCALLTYPE *DisconnectAsAggregator )( 
            IADsAggregator * This);
        
        END_INTERFACE
    } IADsAggregatorVtbl;

    interface IADsAggregator
    {
        CONST_VTBL struct IADsAggregatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsAggregator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsAggregator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsAggregator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsAggregator_ConnectAsAggregator(This,pAggregatee)	\
    (This)->lpVtbl -> ConnectAsAggregator(This,pAggregatee)

#define IADsAggregator_DisconnectAsAggregator(This)	\
    (This)->lpVtbl -> DisconnectAsAggregator(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsAggregator_ConnectAsAggregator_Proxy( 
    IADsAggregator * This,
    IUnknown *pAggregatee);


void __RPC_STUB IADsAggregator_ConnectAsAggregator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsAggregator_DisconnectAsAggregator_Proxy( 
    IADsAggregator * This);


void __RPC_STUB IADsAggregator_DisconnectAsAggregator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsAggregator_INTERFACE_DEFINED__ */


#ifndef __IADsAccessControlEntry_INTERFACE_DEFINED__
#define __IADsAccessControlEntry_INTERFACE_DEFINED__

/* interface IADsAccessControlEntry */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsAccessControlEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b4f3a14c-9bdd-11d0-852c-00c04fd8d503")
    IADsAccessControlEntry : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AccessMask( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AccessMask( 
            /* [in] */ long lnAccessMask) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AceType( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AceType( 
            /* [in] */ long lnAceType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AceFlags( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AceFlags( 
            /* [in] */ long lnAceFlags) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Flags( 
            /* [in] */ long lnFlags) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ObjectType( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ObjectType( 
            /* [in] */ BSTR bstrObjectType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_InheritedObjectType( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_InheritedObjectType( 
            /* [in] */ BSTR bstrInheritedObjectType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Trustee( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Trustee( 
            /* [in] */ BSTR bstrTrustee) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsAccessControlEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsAccessControlEntry * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsAccessControlEntry * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsAccessControlEntry * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsAccessControlEntry * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsAccessControlEntry * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsAccessControlEntry * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsAccessControlEntry * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AccessMask )( 
            IADsAccessControlEntry * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AccessMask )( 
            IADsAccessControlEntry * This,
            /* [in] */ long lnAccessMask);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AceType )( 
            IADsAccessControlEntry * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AceType )( 
            IADsAccessControlEntry * This,
            /* [in] */ long lnAceType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AceFlags )( 
            IADsAccessControlEntry * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AceFlags )( 
            IADsAccessControlEntry * This,
            /* [in] */ long lnAceFlags);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            IADsAccessControlEntry * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Flags )( 
            IADsAccessControlEntry * This,
            /* [in] */ long lnFlags);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectType )( 
            IADsAccessControlEntry * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ObjectType )( 
            IADsAccessControlEntry * This,
            /* [in] */ BSTR bstrObjectType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InheritedObjectType )( 
            IADsAccessControlEntry * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InheritedObjectType )( 
            IADsAccessControlEntry * This,
            /* [in] */ BSTR bstrInheritedObjectType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Trustee )( 
            IADsAccessControlEntry * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Trustee )( 
            IADsAccessControlEntry * This,
            /* [in] */ BSTR bstrTrustee);
        
        END_INTERFACE
    } IADsAccessControlEntryVtbl;

    interface IADsAccessControlEntry
    {
        CONST_VTBL struct IADsAccessControlEntryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsAccessControlEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsAccessControlEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsAccessControlEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsAccessControlEntry_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsAccessControlEntry_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsAccessControlEntry_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsAccessControlEntry_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsAccessControlEntry_get_AccessMask(This,retval)	\
    (This)->lpVtbl -> get_AccessMask(This,retval)

#define IADsAccessControlEntry_put_AccessMask(This,lnAccessMask)	\
    (This)->lpVtbl -> put_AccessMask(This,lnAccessMask)

#define IADsAccessControlEntry_get_AceType(This,retval)	\
    (This)->lpVtbl -> get_AceType(This,retval)

#define IADsAccessControlEntry_put_AceType(This,lnAceType)	\
    (This)->lpVtbl -> put_AceType(This,lnAceType)

#define IADsAccessControlEntry_get_AceFlags(This,retval)	\
    (This)->lpVtbl -> get_AceFlags(This,retval)

#define IADsAccessControlEntry_put_AceFlags(This,lnAceFlags)	\
    (This)->lpVtbl -> put_AceFlags(This,lnAceFlags)

#define IADsAccessControlEntry_get_Flags(This,retval)	\
    (This)->lpVtbl -> get_Flags(This,retval)

#define IADsAccessControlEntry_put_Flags(This,lnFlags)	\
    (This)->lpVtbl -> put_Flags(This,lnFlags)

#define IADsAccessControlEntry_get_ObjectType(This,retval)	\
    (This)->lpVtbl -> get_ObjectType(This,retval)

#define IADsAccessControlEntry_put_ObjectType(This,bstrObjectType)	\
    (This)->lpVtbl -> put_ObjectType(This,bstrObjectType)

#define IADsAccessControlEntry_get_InheritedObjectType(This,retval)	\
    (This)->lpVtbl -> get_InheritedObjectType(This,retval)

#define IADsAccessControlEntry_put_InheritedObjectType(This,bstrInheritedObjectType)	\
    (This)->lpVtbl -> put_InheritedObjectType(This,bstrInheritedObjectType)

#define IADsAccessControlEntry_get_Trustee(This,retval)	\
    (This)->lpVtbl -> get_Trustee(This,retval)

#define IADsAccessControlEntry_put_Trustee(This,bstrTrustee)	\
    (This)->lpVtbl -> put_Trustee(This,bstrTrustee)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsAccessControlEntry_get_AccessMask_Proxy( 
    IADsAccessControlEntry * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsAccessControlEntry_get_AccessMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsAccessControlEntry_put_AccessMask_Proxy( 
    IADsAccessControlEntry * This,
    /* [in] */ long lnAccessMask);


void __RPC_STUB IADsAccessControlEntry_put_AccessMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsAccessControlEntry_get_AceType_Proxy( 
    IADsAccessControlEntry * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsAccessControlEntry_get_AceType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsAccessControlEntry_put_AceType_Proxy( 
    IADsAccessControlEntry * This,
    /* [in] */ long lnAceType);


void __RPC_STUB IADsAccessControlEntry_put_AceType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsAccessControlEntry_get_AceFlags_Proxy( 
    IADsAccessControlEntry * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsAccessControlEntry_get_AceFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsAccessControlEntry_put_AceFlags_Proxy( 
    IADsAccessControlEntry * This,
    /* [in] */ long lnAceFlags);


void __RPC_STUB IADsAccessControlEntry_put_AceFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsAccessControlEntry_get_Flags_Proxy( 
    IADsAccessControlEntry * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsAccessControlEntry_get_Flags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsAccessControlEntry_put_Flags_Proxy( 
    IADsAccessControlEntry * This,
    /* [in] */ long lnFlags);


void __RPC_STUB IADsAccessControlEntry_put_Flags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsAccessControlEntry_get_ObjectType_Proxy( 
    IADsAccessControlEntry * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsAccessControlEntry_get_ObjectType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsAccessControlEntry_put_ObjectType_Proxy( 
    IADsAccessControlEntry * This,
    /* [in] */ BSTR bstrObjectType);


void __RPC_STUB IADsAccessControlEntry_put_ObjectType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsAccessControlEntry_get_InheritedObjectType_Proxy( 
    IADsAccessControlEntry * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsAccessControlEntry_get_InheritedObjectType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsAccessControlEntry_put_InheritedObjectType_Proxy( 
    IADsAccessControlEntry * This,
    /* [in] */ BSTR bstrInheritedObjectType);


void __RPC_STUB IADsAccessControlEntry_put_InheritedObjectType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsAccessControlEntry_get_Trustee_Proxy( 
    IADsAccessControlEntry * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsAccessControlEntry_get_Trustee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsAccessControlEntry_put_Trustee_Proxy( 
    IADsAccessControlEntry * This,
    /* [in] */ BSTR bstrTrustee);


void __RPC_STUB IADsAccessControlEntry_put_Trustee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsAccessControlEntry_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_AccessControlEntry;

#ifdef __cplusplus

class DECLSPEC_UUID("b75ac000-9bdd-11d0-852c-00c04fd8d503")
AccessControlEntry;
#endif

#ifndef __IADsAccessControlList_INTERFACE_DEFINED__
#define __IADsAccessControlList_INTERFACE_DEFINED__

/* interface IADsAccessControlList */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsAccessControlList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b7ee91cc-9bdd-11d0-852c-00c04fd8d503")
    IADsAccessControlList : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AclRevision( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AclRevision( 
            /* [in] */ long lnAclRevision) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AceCount( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AceCount( 
            /* [in] */ long lnAceCount) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddAce( 
            /* [in] */ IDispatch *pAccessControlEntry) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RemoveAce( 
            /* [in] */ IDispatch *pAccessControlEntry) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CopyAccessList( 
            /* [retval][out] */ IDispatch **ppAccessControlList) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsAccessControlListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsAccessControlList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsAccessControlList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsAccessControlList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsAccessControlList * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsAccessControlList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsAccessControlList * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsAccessControlList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AclRevision )( 
            IADsAccessControlList * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AclRevision )( 
            IADsAccessControlList * This,
            /* [in] */ long lnAclRevision);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AceCount )( 
            IADsAccessControlList * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AceCount )( 
            IADsAccessControlList * This,
            /* [in] */ long lnAceCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *AddAce )( 
            IADsAccessControlList * This,
            /* [in] */ IDispatch *pAccessControlEntry);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RemoveAce )( 
            IADsAccessControlList * This,
            /* [in] */ IDispatch *pAccessControlEntry);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *CopyAccessList )( 
            IADsAccessControlList * This,
            /* [retval][out] */ IDispatch **ppAccessControlList);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IADsAccessControlList * This,
            /* [retval][out] */ IUnknown **retval);
        
        END_INTERFACE
    } IADsAccessControlListVtbl;

    interface IADsAccessControlList
    {
        CONST_VTBL struct IADsAccessControlListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsAccessControlList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsAccessControlList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsAccessControlList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsAccessControlList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsAccessControlList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsAccessControlList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsAccessControlList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsAccessControlList_get_AclRevision(This,retval)	\
    (This)->lpVtbl -> get_AclRevision(This,retval)

#define IADsAccessControlList_put_AclRevision(This,lnAclRevision)	\
    (This)->lpVtbl -> put_AclRevision(This,lnAclRevision)

#define IADsAccessControlList_get_AceCount(This,retval)	\
    (This)->lpVtbl -> get_AceCount(This,retval)

#define IADsAccessControlList_put_AceCount(This,lnAceCount)	\
    (This)->lpVtbl -> put_AceCount(This,lnAceCount)

#define IADsAccessControlList_AddAce(This,pAccessControlEntry)	\
    (This)->lpVtbl -> AddAce(This,pAccessControlEntry)

#define IADsAccessControlList_RemoveAce(This,pAccessControlEntry)	\
    (This)->lpVtbl -> RemoveAce(This,pAccessControlEntry)

#define IADsAccessControlList_CopyAccessList(This,ppAccessControlList)	\
    (This)->lpVtbl -> CopyAccessList(This,ppAccessControlList)

#define IADsAccessControlList_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsAccessControlList_get_AclRevision_Proxy( 
    IADsAccessControlList * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsAccessControlList_get_AclRevision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsAccessControlList_put_AclRevision_Proxy( 
    IADsAccessControlList * This,
    /* [in] */ long lnAclRevision);


void __RPC_STUB IADsAccessControlList_put_AclRevision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsAccessControlList_get_AceCount_Proxy( 
    IADsAccessControlList * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsAccessControlList_get_AceCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsAccessControlList_put_AceCount_Proxy( 
    IADsAccessControlList * This,
    /* [in] */ long lnAceCount);


void __RPC_STUB IADsAccessControlList_put_AceCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsAccessControlList_AddAce_Proxy( 
    IADsAccessControlList * This,
    /* [in] */ IDispatch *pAccessControlEntry);


void __RPC_STUB IADsAccessControlList_AddAce_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsAccessControlList_RemoveAce_Proxy( 
    IADsAccessControlList * This,
    /* [in] */ IDispatch *pAccessControlEntry);


void __RPC_STUB IADsAccessControlList_RemoveAce_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsAccessControlList_CopyAccessList_Proxy( 
    IADsAccessControlList * This,
    /* [retval][out] */ IDispatch **ppAccessControlList);


void __RPC_STUB IADsAccessControlList_CopyAccessList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE IADsAccessControlList_get__NewEnum_Proxy( 
    IADsAccessControlList * This,
    /* [retval][out] */ IUnknown **retval);


void __RPC_STUB IADsAccessControlList_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsAccessControlList_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_AccessControlList;

#ifdef __cplusplus

class DECLSPEC_UUID("b85ea052-9bdd-11d0-852c-00c04fd8d503")
AccessControlList;
#endif

#ifndef __IADsSecurityDescriptor_INTERFACE_DEFINED__
#define __IADsSecurityDescriptor_INTERFACE_DEFINED__

/* interface IADsSecurityDescriptor */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsSecurityDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b8c787ca-9bdd-11d0-852c-00c04fd8d503")
    IADsSecurityDescriptor : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Revision( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Revision( 
            /* [in] */ long lnRevision) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Control( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Control( 
            /* [in] */ long lnControl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Owner( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Owner( 
            /* [in] */ BSTR bstrOwner) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OwnerDefaulted( 
            /* [retval][out] */ VARIANT_BOOL *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OwnerDefaulted( 
            /* [in] */ VARIANT_BOOL fOwnerDefaulted) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Group( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Group( 
            /* [in] */ BSTR bstrGroup) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GroupDefaulted( 
            /* [retval][out] */ VARIANT_BOOL *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GroupDefaulted( 
            /* [in] */ VARIANT_BOOL fGroupDefaulted) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscretionaryAcl( 
            /* [retval][out] */ IDispatch **retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscretionaryAcl( 
            /* [in] */ IDispatch *pDiscretionaryAcl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DaclDefaulted( 
            /* [retval][out] */ VARIANT_BOOL *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DaclDefaulted( 
            /* [in] */ VARIANT_BOOL fDaclDefaulted) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SystemAcl( 
            /* [retval][out] */ IDispatch **retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SystemAcl( 
            /* [in] */ IDispatch *pSystemAcl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SaclDefaulted( 
            /* [retval][out] */ VARIANT_BOOL *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SaclDefaulted( 
            /* [in] */ VARIANT_BOOL fSaclDefaulted) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CopySecurityDescriptor( 
            /* [retval][out] */ IDispatch **ppSecurityDescriptor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsSecurityDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsSecurityDescriptor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsSecurityDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsSecurityDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsSecurityDescriptor * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsSecurityDescriptor * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsSecurityDescriptor * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsSecurityDescriptor * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Revision )( 
            IADsSecurityDescriptor * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Revision )( 
            IADsSecurityDescriptor * This,
            /* [in] */ long lnRevision);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Control )( 
            IADsSecurityDescriptor * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Control )( 
            IADsSecurityDescriptor * This,
            /* [in] */ long lnControl);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Owner )( 
            IADsSecurityDescriptor * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Owner )( 
            IADsSecurityDescriptor * This,
            /* [in] */ BSTR bstrOwner);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OwnerDefaulted )( 
            IADsSecurityDescriptor * This,
            /* [retval][out] */ VARIANT_BOOL *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OwnerDefaulted )( 
            IADsSecurityDescriptor * This,
            /* [in] */ VARIANT_BOOL fOwnerDefaulted);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Group )( 
            IADsSecurityDescriptor * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Group )( 
            IADsSecurityDescriptor * This,
            /* [in] */ BSTR bstrGroup);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GroupDefaulted )( 
            IADsSecurityDescriptor * This,
            /* [retval][out] */ VARIANT_BOOL *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GroupDefaulted )( 
            IADsSecurityDescriptor * This,
            /* [in] */ VARIANT_BOOL fGroupDefaulted);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscretionaryAcl )( 
            IADsSecurityDescriptor * This,
            /* [retval][out] */ IDispatch **retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscretionaryAcl )( 
            IADsSecurityDescriptor * This,
            /* [in] */ IDispatch *pDiscretionaryAcl);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DaclDefaulted )( 
            IADsSecurityDescriptor * This,
            /* [retval][out] */ VARIANT_BOOL *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DaclDefaulted )( 
            IADsSecurityDescriptor * This,
            /* [in] */ VARIANT_BOOL fDaclDefaulted);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SystemAcl )( 
            IADsSecurityDescriptor * This,
            /* [retval][out] */ IDispatch **retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SystemAcl )( 
            IADsSecurityDescriptor * This,
            /* [in] */ IDispatch *pSystemAcl);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SaclDefaulted )( 
            IADsSecurityDescriptor * This,
            /* [retval][out] */ VARIANT_BOOL *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SaclDefaulted )( 
            IADsSecurityDescriptor * This,
            /* [in] */ VARIANT_BOOL fSaclDefaulted);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *CopySecurityDescriptor )( 
            IADsSecurityDescriptor * This,
            /* [retval][out] */ IDispatch **ppSecurityDescriptor);
        
        END_INTERFACE
    } IADsSecurityDescriptorVtbl;

    interface IADsSecurityDescriptor
    {
        CONST_VTBL struct IADsSecurityDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsSecurityDescriptor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsSecurityDescriptor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsSecurityDescriptor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsSecurityDescriptor_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsSecurityDescriptor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsSecurityDescriptor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsSecurityDescriptor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsSecurityDescriptor_get_Revision(This,retval)	\
    (This)->lpVtbl -> get_Revision(This,retval)

#define IADsSecurityDescriptor_put_Revision(This,lnRevision)	\
    (This)->lpVtbl -> put_Revision(This,lnRevision)

#define IADsSecurityDescriptor_get_Control(This,retval)	\
    (This)->lpVtbl -> get_Control(This,retval)

#define IADsSecurityDescriptor_put_Control(This,lnControl)	\
    (This)->lpVtbl -> put_Control(This,lnControl)

#define IADsSecurityDescriptor_get_Owner(This,retval)	\
    (This)->lpVtbl -> get_Owner(This,retval)

#define IADsSecurityDescriptor_put_Owner(This,bstrOwner)	\
    (This)->lpVtbl -> put_Owner(This,bstrOwner)

#define IADsSecurityDescriptor_get_OwnerDefaulted(This,retval)	\
    (This)->lpVtbl -> get_OwnerDefaulted(This,retval)

#define IADsSecurityDescriptor_put_OwnerDefaulted(This,fOwnerDefaulted)	\
    (This)->lpVtbl -> put_OwnerDefaulted(This,fOwnerDefaulted)

#define IADsSecurityDescriptor_get_Group(This,retval)	\
    (This)->lpVtbl -> get_Group(This,retval)

#define IADsSecurityDescriptor_put_Group(This,bstrGroup)	\
    (This)->lpVtbl -> put_Group(This,bstrGroup)

#define IADsSecurityDescriptor_get_GroupDefaulted(This,retval)	\
    (This)->lpVtbl -> get_GroupDefaulted(This,retval)

#define IADsSecurityDescriptor_put_GroupDefaulted(This,fGroupDefaulted)	\
    (This)->lpVtbl -> put_GroupDefaulted(This,fGroupDefaulted)

#define IADsSecurityDescriptor_get_DiscretionaryAcl(This,retval)	\
    (This)->lpVtbl -> get_DiscretionaryAcl(This,retval)

#define IADsSecurityDescriptor_put_DiscretionaryAcl(This,pDiscretionaryAcl)	\
    (This)->lpVtbl -> put_DiscretionaryAcl(This,pDiscretionaryAcl)

#define IADsSecurityDescriptor_get_DaclDefaulted(This,retval)	\
    (This)->lpVtbl -> get_DaclDefaulted(This,retval)

#define IADsSecurityDescriptor_put_DaclDefaulted(This,fDaclDefaulted)	\
    (This)->lpVtbl -> put_DaclDefaulted(This,fDaclDefaulted)

#define IADsSecurityDescriptor_get_SystemAcl(This,retval)	\
    (This)->lpVtbl -> get_SystemAcl(This,retval)

#define IADsSecurityDescriptor_put_SystemAcl(This,pSystemAcl)	\
    (This)->lpVtbl -> put_SystemAcl(This,pSystemAcl)

#define IADsSecurityDescriptor_get_SaclDefaulted(This,retval)	\
    (This)->lpVtbl -> get_SaclDefaulted(This,retval)

#define IADsSecurityDescriptor_put_SaclDefaulted(This,fSaclDefaulted)	\
    (This)->lpVtbl -> put_SaclDefaulted(This,fSaclDefaulted)

#define IADsSecurityDescriptor_CopySecurityDescriptor(This,ppSecurityDescriptor)	\
    (This)->lpVtbl -> CopySecurityDescriptor(This,ppSecurityDescriptor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_get_Revision_Proxy( 
    IADsSecurityDescriptor * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsSecurityDescriptor_get_Revision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_put_Revision_Proxy( 
    IADsSecurityDescriptor * This,
    /* [in] */ long lnRevision);


void __RPC_STUB IADsSecurityDescriptor_put_Revision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_get_Control_Proxy( 
    IADsSecurityDescriptor * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsSecurityDescriptor_get_Control_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_put_Control_Proxy( 
    IADsSecurityDescriptor * This,
    /* [in] */ long lnControl);


void __RPC_STUB IADsSecurityDescriptor_put_Control_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_get_Owner_Proxy( 
    IADsSecurityDescriptor * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsSecurityDescriptor_get_Owner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_put_Owner_Proxy( 
    IADsSecurityDescriptor * This,
    /* [in] */ BSTR bstrOwner);


void __RPC_STUB IADsSecurityDescriptor_put_Owner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_get_OwnerDefaulted_Proxy( 
    IADsSecurityDescriptor * This,
    /* [retval][out] */ VARIANT_BOOL *retval);


void __RPC_STUB IADsSecurityDescriptor_get_OwnerDefaulted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_put_OwnerDefaulted_Proxy( 
    IADsSecurityDescriptor * This,
    /* [in] */ VARIANT_BOOL fOwnerDefaulted);


void __RPC_STUB IADsSecurityDescriptor_put_OwnerDefaulted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_get_Group_Proxy( 
    IADsSecurityDescriptor * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsSecurityDescriptor_get_Group_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_put_Group_Proxy( 
    IADsSecurityDescriptor * This,
    /* [in] */ BSTR bstrGroup);


void __RPC_STUB IADsSecurityDescriptor_put_Group_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_get_GroupDefaulted_Proxy( 
    IADsSecurityDescriptor * This,
    /* [retval][out] */ VARIANT_BOOL *retval);


void __RPC_STUB IADsSecurityDescriptor_get_GroupDefaulted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_put_GroupDefaulted_Proxy( 
    IADsSecurityDescriptor * This,
    /* [in] */ VARIANT_BOOL fGroupDefaulted);


void __RPC_STUB IADsSecurityDescriptor_put_GroupDefaulted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_get_DiscretionaryAcl_Proxy( 
    IADsSecurityDescriptor * This,
    /* [retval][out] */ IDispatch **retval);


void __RPC_STUB IADsSecurityDescriptor_get_DiscretionaryAcl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_put_DiscretionaryAcl_Proxy( 
    IADsSecurityDescriptor * This,
    /* [in] */ IDispatch *pDiscretionaryAcl);


void __RPC_STUB IADsSecurityDescriptor_put_DiscretionaryAcl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_get_DaclDefaulted_Proxy( 
    IADsSecurityDescriptor * This,
    /* [retval][out] */ VARIANT_BOOL *retval);


void __RPC_STUB IADsSecurityDescriptor_get_DaclDefaulted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_put_DaclDefaulted_Proxy( 
    IADsSecurityDescriptor * This,
    /* [in] */ VARIANT_BOOL fDaclDefaulted);


void __RPC_STUB IADsSecurityDescriptor_put_DaclDefaulted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_get_SystemAcl_Proxy( 
    IADsSecurityDescriptor * This,
    /* [retval][out] */ IDispatch **retval);


void __RPC_STUB IADsSecurityDescriptor_get_SystemAcl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_put_SystemAcl_Proxy( 
    IADsSecurityDescriptor * This,
    /* [in] */ IDispatch *pSystemAcl);


void __RPC_STUB IADsSecurityDescriptor_put_SystemAcl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_get_SaclDefaulted_Proxy( 
    IADsSecurityDescriptor * This,
    /* [retval][out] */ VARIANT_BOOL *retval);


void __RPC_STUB IADsSecurityDescriptor_get_SaclDefaulted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_put_SaclDefaulted_Proxy( 
    IADsSecurityDescriptor * This,
    /* [in] */ VARIANT_BOOL fSaclDefaulted);


void __RPC_STUB IADsSecurityDescriptor_put_SaclDefaulted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsSecurityDescriptor_CopySecurityDescriptor_Proxy( 
    IADsSecurityDescriptor * This,
    /* [retval][out] */ IDispatch **ppSecurityDescriptor);


void __RPC_STUB IADsSecurityDescriptor_CopySecurityDescriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsSecurityDescriptor_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SecurityDescriptor;

#ifdef __cplusplus

class DECLSPEC_UUID("b958f73c-9bdd-11d0-852c-00c04fd8d503")
SecurityDescriptor;
#endif

#ifndef __IADsLargeInteger_INTERFACE_DEFINED__
#define __IADsLargeInteger_INTERFACE_DEFINED__

/* interface IADsLargeInteger */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsLargeInteger;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9068270b-0939-11d1-8be1-00c04fd8d503")
    IADsLargeInteger : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HighPart( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_HighPart( 
            /* [in] */ long lnHighPart) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LowPart( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LowPart( 
            /* [in] */ long lnLowPart) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsLargeIntegerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsLargeInteger * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsLargeInteger * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsLargeInteger * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsLargeInteger * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsLargeInteger * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsLargeInteger * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsLargeInteger * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HighPart )( 
            IADsLargeInteger * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HighPart )( 
            IADsLargeInteger * This,
            /* [in] */ long lnHighPart);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LowPart )( 
            IADsLargeInteger * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LowPart )( 
            IADsLargeInteger * This,
            /* [in] */ long lnLowPart);
        
        END_INTERFACE
    } IADsLargeIntegerVtbl;

    interface IADsLargeInteger
    {
        CONST_VTBL struct IADsLargeIntegerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsLargeInteger_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsLargeInteger_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsLargeInteger_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsLargeInteger_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsLargeInteger_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsLargeInteger_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsLargeInteger_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsLargeInteger_get_HighPart(This,retval)	\
    (This)->lpVtbl -> get_HighPart(This,retval)

#define IADsLargeInteger_put_HighPart(This,lnHighPart)	\
    (This)->lpVtbl -> put_HighPart(This,lnHighPart)

#define IADsLargeInteger_get_LowPart(This,retval)	\
    (This)->lpVtbl -> get_LowPart(This,retval)

#define IADsLargeInteger_put_LowPart(This,lnLowPart)	\
    (This)->lpVtbl -> put_LowPart(This,lnLowPart)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsLargeInteger_get_HighPart_Proxy( 
    IADsLargeInteger * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsLargeInteger_get_HighPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsLargeInteger_put_HighPart_Proxy( 
    IADsLargeInteger * This,
    /* [in] */ long lnHighPart);


void __RPC_STUB IADsLargeInteger_put_HighPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsLargeInteger_get_LowPart_Proxy( 
    IADsLargeInteger * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsLargeInteger_get_LowPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsLargeInteger_put_LowPart_Proxy( 
    IADsLargeInteger * This,
    /* [in] */ long lnLowPart);


void __RPC_STUB IADsLargeInteger_put_LowPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsLargeInteger_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_LargeInteger;

#ifdef __cplusplus

class DECLSPEC_UUID("927971f5-0939-11d1-8be1-00c04fd8d503")
LargeInteger;
#endif

#ifndef __IADsNameTranslate_INTERFACE_DEFINED__
#define __IADsNameTranslate_INTERFACE_DEFINED__

/* interface IADsNameTranslate */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsNameTranslate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b1b272a3-3625-11d1-a3a4-00c04fb950dc")
    IADsNameTranslate : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ChaseReferral( 
            /* [in] */ long lnChaseReferral) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ long lnSetType,
            /* [in] */ BSTR bstrADsPath) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE InitEx( 
            /* [in] */ long lnSetType,
            /* [in] */ BSTR bstrADsPath,
            /* [in] */ BSTR bstrUserID,
            /* [in] */ BSTR bstrDomain,
            /* [in] */ BSTR bstrPassword) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ long lnSetType,
            /* [in] */ BSTR bstrADsPath) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ long lnFormatType,
            /* [retval][out] */ BSTR *pbstrADsPath) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetEx( 
            /* [in] */ long lnFormatType,
            /* [in] */ VARIANT pvar) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetEx( 
            /* [in] */ long lnFormatType,
            /* [retval][out] */ VARIANT *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsNameTranslateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsNameTranslate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsNameTranslate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsNameTranslate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsNameTranslate * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsNameTranslate * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsNameTranslate * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsNameTranslate * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ChaseReferral )( 
            IADsNameTranslate * This,
            /* [in] */ long lnChaseReferral);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Init )( 
            IADsNameTranslate * This,
            /* [in] */ long lnSetType,
            /* [in] */ BSTR bstrADsPath);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *InitEx )( 
            IADsNameTranslate * This,
            /* [in] */ long lnSetType,
            /* [in] */ BSTR bstrADsPath,
            /* [in] */ BSTR bstrUserID,
            /* [in] */ BSTR bstrDomain,
            /* [in] */ BSTR bstrPassword);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Set )( 
            IADsNameTranslate * This,
            /* [in] */ long lnSetType,
            /* [in] */ BSTR bstrADsPath);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADsNameTranslate * This,
            /* [in] */ long lnFormatType,
            /* [retval][out] */ BSTR *pbstrADsPath);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetEx )( 
            IADsNameTranslate * This,
            /* [in] */ long lnFormatType,
            /* [in] */ VARIANT pvar);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADsNameTranslate * This,
            /* [in] */ long lnFormatType,
            /* [retval][out] */ VARIANT *pvar);
        
        END_INTERFACE
    } IADsNameTranslateVtbl;

    interface IADsNameTranslate
    {
        CONST_VTBL struct IADsNameTranslateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsNameTranslate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsNameTranslate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsNameTranslate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsNameTranslate_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsNameTranslate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsNameTranslate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsNameTranslate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsNameTranslate_put_ChaseReferral(This,lnChaseReferral)	\
    (This)->lpVtbl -> put_ChaseReferral(This,lnChaseReferral)

#define IADsNameTranslate_Init(This,lnSetType,bstrADsPath)	\
    (This)->lpVtbl -> Init(This,lnSetType,bstrADsPath)

#define IADsNameTranslate_InitEx(This,lnSetType,bstrADsPath,bstrUserID,bstrDomain,bstrPassword)	\
    (This)->lpVtbl -> InitEx(This,lnSetType,bstrADsPath,bstrUserID,bstrDomain,bstrPassword)

#define IADsNameTranslate_Set(This,lnSetType,bstrADsPath)	\
    (This)->lpVtbl -> Set(This,lnSetType,bstrADsPath)

#define IADsNameTranslate_Get(This,lnFormatType,pbstrADsPath)	\
    (This)->lpVtbl -> Get(This,lnFormatType,pbstrADsPath)

#define IADsNameTranslate_SetEx(This,lnFormatType,pvar)	\
    (This)->lpVtbl -> SetEx(This,lnFormatType,pvar)

#define IADsNameTranslate_GetEx(This,lnFormatType,pvar)	\
    (This)->lpVtbl -> GetEx(This,lnFormatType,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsNameTranslate_put_ChaseReferral_Proxy( 
    IADsNameTranslate * This,
    /* [in] */ long lnChaseReferral);


void __RPC_STUB IADsNameTranslate_put_ChaseReferral_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsNameTranslate_Init_Proxy( 
    IADsNameTranslate * This,
    /* [in] */ long lnSetType,
    /* [in] */ BSTR bstrADsPath);


void __RPC_STUB IADsNameTranslate_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsNameTranslate_InitEx_Proxy( 
    IADsNameTranslate * This,
    /* [in] */ long lnSetType,
    /* [in] */ BSTR bstrADsPath,
    /* [in] */ BSTR bstrUserID,
    /* [in] */ BSTR bstrDomain,
    /* [in] */ BSTR bstrPassword);


void __RPC_STUB IADsNameTranslate_InitEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsNameTranslate_Set_Proxy( 
    IADsNameTranslate * This,
    /* [in] */ long lnSetType,
    /* [in] */ BSTR bstrADsPath);


void __RPC_STUB IADsNameTranslate_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsNameTranslate_Get_Proxy( 
    IADsNameTranslate * This,
    /* [in] */ long lnFormatType,
    /* [retval][out] */ BSTR *pbstrADsPath);


void __RPC_STUB IADsNameTranslate_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsNameTranslate_SetEx_Proxy( 
    IADsNameTranslate * This,
    /* [in] */ long lnFormatType,
    /* [in] */ VARIANT pvar);


void __RPC_STUB IADsNameTranslate_SetEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsNameTranslate_GetEx_Proxy( 
    IADsNameTranslate * This,
    /* [in] */ long lnFormatType,
    /* [retval][out] */ VARIANT *pvar);


void __RPC_STUB IADsNameTranslate_GetEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsNameTranslate_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_NameTranslate;

#ifdef __cplusplus

class DECLSPEC_UUID("274fae1f-3626-11d1-a3a4-00c04fb950dc")
NameTranslate;
#endif

#ifndef __IADsCaseIgnoreList_INTERFACE_DEFINED__
#define __IADsCaseIgnoreList_INTERFACE_DEFINED__

/* interface IADsCaseIgnoreList */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsCaseIgnoreList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7b66b533-4680-11d1-a3b4-00c04fb950dc")
    IADsCaseIgnoreList : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_CaseIgnoreList( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_CaseIgnoreList( 
            /* [in] */ VARIANT vCaseIgnoreList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsCaseIgnoreListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsCaseIgnoreList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsCaseIgnoreList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsCaseIgnoreList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsCaseIgnoreList * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsCaseIgnoreList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsCaseIgnoreList * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsCaseIgnoreList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CaseIgnoreList )( 
            IADsCaseIgnoreList * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CaseIgnoreList )( 
            IADsCaseIgnoreList * This,
            /* [in] */ VARIANT vCaseIgnoreList);
        
        END_INTERFACE
    } IADsCaseIgnoreListVtbl;

    interface IADsCaseIgnoreList
    {
        CONST_VTBL struct IADsCaseIgnoreListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsCaseIgnoreList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsCaseIgnoreList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsCaseIgnoreList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsCaseIgnoreList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsCaseIgnoreList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsCaseIgnoreList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsCaseIgnoreList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsCaseIgnoreList_get_CaseIgnoreList(This,retval)	\
    (This)->lpVtbl -> get_CaseIgnoreList(This,retval)

#define IADsCaseIgnoreList_put_CaseIgnoreList(This,vCaseIgnoreList)	\
    (This)->lpVtbl -> put_CaseIgnoreList(This,vCaseIgnoreList)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsCaseIgnoreList_get_CaseIgnoreList_Proxy( 
    IADsCaseIgnoreList * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsCaseIgnoreList_get_CaseIgnoreList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsCaseIgnoreList_put_CaseIgnoreList_Proxy( 
    IADsCaseIgnoreList * This,
    /* [in] */ VARIANT vCaseIgnoreList);


void __RPC_STUB IADsCaseIgnoreList_put_CaseIgnoreList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsCaseIgnoreList_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CaseIgnoreList;

#ifdef __cplusplus

class DECLSPEC_UUID("15f88a55-4680-11d1-a3b4-00c04fb950dc")
CaseIgnoreList;
#endif

#ifndef __IADsFaxNumber_INTERFACE_DEFINED__
#define __IADsFaxNumber_INTERFACE_DEFINED__

/* interface IADsFaxNumber */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsFaxNumber;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a910dea9-4680-11d1-a3b4-00c04fb950dc")
    IADsFaxNumber : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_TelephoneNumber( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_TelephoneNumber( 
            /* [in] */ BSTR bstrTelephoneNumber) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Parameters( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Parameters( 
            /* [in] */ VARIANT vParameters) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsFaxNumberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsFaxNumber * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsFaxNumber * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsFaxNumber * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsFaxNumber * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsFaxNumber * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsFaxNumber * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsFaxNumber * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TelephoneNumber )( 
            IADsFaxNumber * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TelephoneNumber )( 
            IADsFaxNumber * This,
            /* [in] */ BSTR bstrTelephoneNumber);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parameters )( 
            IADsFaxNumber * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Parameters )( 
            IADsFaxNumber * This,
            /* [in] */ VARIANT vParameters);
        
        END_INTERFACE
    } IADsFaxNumberVtbl;

    interface IADsFaxNumber
    {
        CONST_VTBL struct IADsFaxNumberVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsFaxNumber_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsFaxNumber_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsFaxNumber_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsFaxNumber_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsFaxNumber_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsFaxNumber_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsFaxNumber_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsFaxNumber_get_TelephoneNumber(This,retval)	\
    (This)->lpVtbl -> get_TelephoneNumber(This,retval)

#define IADsFaxNumber_put_TelephoneNumber(This,bstrTelephoneNumber)	\
    (This)->lpVtbl -> put_TelephoneNumber(This,bstrTelephoneNumber)

#define IADsFaxNumber_get_Parameters(This,retval)	\
    (This)->lpVtbl -> get_Parameters(This,retval)

#define IADsFaxNumber_put_Parameters(This,vParameters)	\
    (This)->lpVtbl -> put_Parameters(This,vParameters)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsFaxNumber_get_TelephoneNumber_Proxy( 
    IADsFaxNumber * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsFaxNumber_get_TelephoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsFaxNumber_put_TelephoneNumber_Proxy( 
    IADsFaxNumber * This,
    /* [in] */ BSTR bstrTelephoneNumber);


void __RPC_STUB IADsFaxNumber_put_TelephoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsFaxNumber_get_Parameters_Proxy( 
    IADsFaxNumber * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsFaxNumber_get_Parameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsFaxNumber_put_Parameters_Proxy( 
    IADsFaxNumber * This,
    /* [in] */ VARIANT vParameters);


void __RPC_STUB IADsFaxNumber_put_Parameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsFaxNumber_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_FaxNumber;

#ifdef __cplusplus

class DECLSPEC_UUID("a5062215-4681-11d1-a3b4-00c04fb950dc")
FaxNumber;
#endif

#ifndef __IADsNetAddress_INTERFACE_DEFINED__
#define __IADsNetAddress_INTERFACE_DEFINED__

/* interface IADsNetAddress */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsNetAddress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b21a50a9-4080-11d1-a3ac-00c04fb950dc")
    IADsNetAddress : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AddressType( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AddressType( 
            /* [in] */ long lnAddressType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Address( 
            /* [in] */ VARIANT vAddress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsNetAddressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsNetAddress * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsNetAddress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsNetAddress * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsNetAddress * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsNetAddress * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsNetAddress * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsNetAddress * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AddressType )( 
            IADsNetAddress * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AddressType )( 
            IADsNetAddress * This,
            /* [in] */ long lnAddressType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            IADsNetAddress * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Address )( 
            IADsNetAddress * This,
            /* [in] */ VARIANT vAddress);
        
        END_INTERFACE
    } IADsNetAddressVtbl;

    interface IADsNetAddress
    {
        CONST_VTBL struct IADsNetAddressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsNetAddress_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsNetAddress_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsNetAddress_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsNetAddress_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsNetAddress_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsNetAddress_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsNetAddress_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsNetAddress_get_AddressType(This,retval)	\
    (This)->lpVtbl -> get_AddressType(This,retval)

#define IADsNetAddress_put_AddressType(This,lnAddressType)	\
    (This)->lpVtbl -> put_AddressType(This,lnAddressType)

#define IADsNetAddress_get_Address(This,retval)	\
    (This)->lpVtbl -> get_Address(This,retval)

#define IADsNetAddress_put_Address(This,vAddress)	\
    (This)->lpVtbl -> put_Address(This,vAddress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsNetAddress_get_AddressType_Proxy( 
    IADsNetAddress * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsNetAddress_get_AddressType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsNetAddress_put_AddressType_Proxy( 
    IADsNetAddress * This,
    /* [in] */ long lnAddressType);


void __RPC_STUB IADsNetAddress_put_AddressType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsNetAddress_get_Address_Proxy( 
    IADsNetAddress * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsNetAddress_get_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsNetAddress_put_Address_Proxy( 
    IADsNetAddress * This,
    /* [in] */ VARIANT vAddress);


void __RPC_STUB IADsNetAddress_put_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsNetAddress_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_NetAddress;

#ifdef __cplusplus

class DECLSPEC_UUID("b0b71247-4080-11d1-a3ac-00c04fb950dc")
NetAddress;
#endif

#ifndef __IADsOctetList_INTERFACE_DEFINED__
#define __IADsOctetList_INTERFACE_DEFINED__

/* interface IADsOctetList */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsOctetList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7b28b80f-4680-11d1-a3b4-00c04fb950dc")
    IADsOctetList : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OctetList( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OctetList( 
            /* [in] */ VARIANT vOctetList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsOctetListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsOctetList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsOctetList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsOctetList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsOctetList * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsOctetList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsOctetList * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsOctetList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OctetList )( 
            IADsOctetList * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OctetList )( 
            IADsOctetList * This,
            /* [in] */ VARIANT vOctetList);
        
        END_INTERFACE
    } IADsOctetListVtbl;

    interface IADsOctetList
    {
        CONST_VTBL struct IADsOctetListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsOctetList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsOctetList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsOctetList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsOctetList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsOctetList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsOctetList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsOctetList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsOctetList_get_OctetList(This,retval)	\
    (This)->lpVtbl -> get_OctetList(This,retval)

#define IADsOctetList_put_OctetList(This,vOctetList)	\
    (This)->lpVtbl -> put_OctetList(This,vOctetList)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsOctetList_get_OctetList_Proxy( 
    IADsOctetList * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsOctetList_get_OctetList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsOctetList_put_OctetList_Proxy( 
    IADsOctetList * This,
    /* [in] */ VARIANT vOctetList);


void __RPC_STUB IADsOctetList_put_OctetList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsOctetList_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_OctetList;

#ifdef __cplusplus

class DECLSPEC_UUID("1241400f-4680-11d1-a3b4-00c04fb950dc")
OctetList;
#endif

#ifndef __IADsEmail_INTERFACE_DEFINED__
#define __IADsEmail_INTERFACE_DEFINED__

/* interface IADsEmail */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsEmail;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97af011a-478e-11d1-a3b4-00c04fb950dc")
    IADsEmail : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Type( 
            /* [in] */ long lnType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Address( 
            /* [in] */ BSTR bstrAddress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsEmailVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsEmail * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsEmail * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsEmail * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsEmail * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsEmail * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsEmail * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsEmail * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IADsEmail * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Type )( 
            IADsEmail * This,
            /* [in] */ long lnType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            IADsEmail * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Address )( 
            IADsEmail * This,
            /* [in] */ BSTR bstrAddress);
        
        END_INTERFACE
    } IADsEmailVtbl;

    interface IADsEmail
    {
        CONST_VTBL struct IADsEmailVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsEmail_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsEmail_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsEmail_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsEmail_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsEmail_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsEmail_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsEmail_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsEmail_get_Type(This,retval)	\
    (This)->lpVtbl -> get_Type(This,retval)

#define IADsEmail_put_Type(This,lnType)	\
    (This)->lpVtbl -> put_Type(This,lnType)

#define IADsEmail_get_Address(This,retval)	\
    (This)->lpVtbl -> get_Address(This,retval)

#define IADsEmail_put_Address(This,bstrAddress)	\
    (This)->lpVtbl -> put_Address(This,bstrAddress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsEmail_get_Type_Proxy( 
    IADsEmail * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsEmail_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsEmail_put_Type_Proxy( 
    IADsEmail * This,
    /* [in] */ long lnType);


void __RPC_STUB IADsEmail_put_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsEmail_get_Address_Proxy( 
    IADsEmail * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsEmail_get_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsEmail_put_Address_Proxy( 
    IADsEmail * This,
    /* [in] */ BSTR bstrAddress);


void __RPC_STUB IADsEmail_put_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsEmail_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_Email;

#ifdef __cplusplus

class DECLSPEC_UUID("8f92a857-478e-11d1-a3b4-00c04fb950dc")
Email;
#endif

#ifndef __IADsPath_INTERFACE_DEFINED__
#define __IADsPath_INTERFACE_DEFINED__

/* interface IADsPath */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsPath;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b287fcd5-4080-11d1-a3ac-00c04fb950dc")
    IADsPath : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Type( 
            /* [in] */ long lnType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_VolumeName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_VolumeName( 
            /* [in] */ BSTR bstrVolumeName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR bstrPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsPathVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsPath * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsPath * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsPath * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsPath * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsPath * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsPath * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsPath * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IADsPath * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Type )( 
            IADsPath * This,
            /* [in] */ long lnType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumeName )( 
            IADsPath * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_VolumeName )( 
            IADsPath * This,
            /* [in] */ BSTR bstrVolumeName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IADsPath * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Path )( 
            IADsPath * This,
            /* [in] */ BSTR bstrPath);
        
        END_INTERFACE
    } IADsPathVtbl;

    interface IADsPath
    {
        CONST_VTBL struct IADsPathVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsPath_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsPath_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsPath_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsPath_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsPath_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsPath_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsPath_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsPath_get_Type(This,retval)	\
    (This)->lpVtbl -> get_Type(This,retval)

#define IADsPath_put_Type(This,lnType)	\
    (This)->lpVtbl -> put_Type(This,lnType)

#define IADsPath_get_VolumeName(This,retval)	\
    (This)->lpVtbl -> get_VolumeName(This,retval)

#define IADsPath_put_VolumeName(This,bstrVolumeName)	\
    (This)->lpVtbl -> put_VolumeName(This,bstrVolumeName)

#define IADsPath_get_Path(This,retval)	\
    (This)->lpVtbl -> get_Path(This,retval)

#define IADsPath_put_Path(This,bstrPath)	\
    (This)->lpVtbl -> put_Path(This,bstrPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPath_get_Type_Proxy( 
    IADsPath * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsPath_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPath_put_Type_Proxy( 
    IADsPath * This,
    /* [in] */ long lnType);


void __RPC_STUB IADsPath_put_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPath_get_VolumeName_Proxy( 
    IADsPath * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPath_get_VolumeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPath_put_VolumeName_Proxy( 
    IADsPath * This,
    /* [in] */ BSTR bstrVolumeName);


void __RPC_STUB IADsPath_put_VolumeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPath_get_Path_Proxy( 
    IADsPath * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsPath_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPath_put_Path_Proxy( 
    IADsPath * This,
    /* [in] */ BSTR bstrPath);


void __RPC_STUB IADsPath_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsPath_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_Path;

#ifdef __cplusplus

class DECLSPEC_UUID("b2538919-4080-11d1-a3ac-00c04fb950dc")
Path;
#endif

#ifndef __IADsReplicaPointer_INTERFACE_DEFINED__
#define __IADsReplicaPointer_INTERFACE_DEFINED__

/* interface IADsReplicaPointer */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsReplicaPointer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f60fb803-4080-11d1-a3ac-00c04fb950dc")
    IADsReplicaPointer : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ServerName( 
            /* [in] */ BSTR bstrServerName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ReplicaType( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ReplicaType( 
            /* [in] */ long lnReplicaType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ReplicaNumber( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ReplicaNumber( 
            /* [in] */ long lnReplicaNumber) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Count( 
            /* [in] */ long lnCount) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ReplicaAddressHints( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ReplicaAddressHints( 
            /* [in] */ VARIANT vReplicaAddressHints) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsReplicaPointerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsReplicaPointer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsReplicaPointer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsReplicaPointer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsReplicaPointer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsReplicaPointer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsReplicaPointer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsReplicaPointer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServerName )( 
            IADsReplicaPointer * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServerName )( 
            IADsReplicaPointer * This,
            /* [in] */ BSTR bstrServerName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReplicaType )( 
            IADsReplicaPointer * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReplicaType )( 
            IADsReplicaPointer * This,
            /* [in] */ long lnReplicaType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReplicaNumber )( 
            IADsReplicaPointer * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReplicaNumber )( 
            IADsReplicaPointer * This,
            /* [in] */ long lnReplicaNumber);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IADsReplicaPointer * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Count )( 
            IADsReplicaPointer * This,
            /* [in] */ long lnCount);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReplicaAddressHints )( 
            IADsReplicaPointer * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReplicaAddressHints )( 
            IADsReplicaPointer * This,
            /* [in] */ VARIANT vReplicaAddressHints);
        
        END_INTERFACE
    } IADsReplicaPointerVtbl;

    interface IADsReplicaPointer
    {
        CONST_VTBL struct IADsReplicaPointerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsReplicaPointer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsReplicaPointer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsReplicaPointer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsReplicaPointer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsReplicaPointer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsReplicaPointer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsReplicaPointer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsReplicaPointer_get_ServerName(This,retval)	\
    (This)->lpVtbl -> get_ServerName(This,retval)

#define IADsReplicaPointer_put_ServerName(This,bstrServerName)	\
    (This)->lpVtbl -> put_ServerName(This,bstrServerName)

#define IADsReplicaPointer_get_ReplicaType(This,retval)	\
    (This)->lpVtbl -> get_ReplicaType(This,retval)

#define IADsReplicaPointer_put_ReplicaType(This,lnReplicaType)	\
    (This)->lpVtbl -> put_ReplicaType(This,lnReplicaType)

#define IADsReplicaPointer_get_ReplicaNumber(This,retval)	\
    (This)->lpVtbl -> get_ReplicaNumber(This,retval)

#define IADsReplicaPointer_put_ReplicaNumber(This,lnReplicaNumber)	\
    (This)->lpVtbl -> put_ReplicaNumber(This,lnReplicaNumber)

#define IADsReplicaPointer_get_Count(This,retval)	\
    (This)->lpVtbl -> get_Count(This,retval)

#define IADsReplicaPointer_put_Count(This,lnCount)	\
    (This)->lpVtbl -> put_Count(This,lnCount)

#define IADsReplicaPointer_get_ReplicaAddressHints(This,retval)	\
    (This)->lpVtbl -> get_ReplicaAddressHints(This,retval)

#define IADsReplicaPointer_put_ReplicaAddressHints(This,vReplicaAddressHints)	\
    (This)->lpVtbl -> put_ReplicaAddressHints(This,vReplicaAddressHints)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsReplicaPointer_get_ServerName_Proxy( 
    IADsReplicaPointer * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsReplicaPointer_get_ServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsReplicaPointer_put_ServerName_Proxy( 
    IADsReplicaPointer * This,
    /* [in] */ BSTR bstrServerName);


void __RPC_STUB IADsReplicaPointer_put_ServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsReplicaPointer_get_ReplicaType_Proxy( 
    IADsReplicaPointer * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsReplicaPointer_get_ReplicaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsReplicaPointer_put_ReplicaType_Proxy( 
    IADsReplicaPointer * This,
    /* [in] */ long lnReplicaType);


void __RPC_STUB IADsReplicaPointer_put_ReplicaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsReplicaPointer_get_ReplicaNumber_Proxy( 
    IADsReplicaPointer * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsReplicaPointer_get_ReplicaNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsReplicaPointer_put_ReplicaNumber_Proxy( 
    IADsReplicaPointer * This,
    /* [in] */ long lnReplicaNumber);


void __RPC_STUB IADsReplicaPointer_put_ReplicaNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsReplicaPointer_get_Count_Proxy( 
    IADsReplicaPointer * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsReplicaPointer_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsReplicaPointer_put_Count_Proxy( 
    IADsReplicaPointer * This,
    /* [in] */ long lnCount);


void __RPC_STUB IADsReplicaPointer_put_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsReplicaPointer_get_ReplicaAddressHints_Proxy( 
    IADsReplicaPointer * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsReplicaPointer_get_ReplicaAddressHints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsReplicaPointer_put_ReplicaAddressHints_Proxy( 
    IADsReplicaPointer * This,
    /* [in] */ VARIANT vReplicaAddressHints);


void __RPC_STUB IADsReplicaPointer_put_ReplicaAddressHints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsReplicaPointer_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ReplicaPointer;

#ifdef __cplusplus

class DECLSPEC_UUID("f5d1badf-4080-11d1-a3ac-00c04fb950dc")
ReplicaPointer;
#endif

#ifndef __IADsAcl_INTERFACE_DEFINED__
#define __IADsAcl_INTERFACE_DEFINED__

/* interface IADsAcl */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsAcl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8452d3ab-0869-11d1-a377-00c04fb950dc")
    IADsAcl : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ProtectedAttrName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ProtectedAttrName( 
            /* [in] */ BSTR bstrProtectedAttrName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SubjectName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SubjectName( 
            /* [in] */ BSTR bstrSubjectName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Privileges( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Privileges( 
            /* [in] */ long lnPrivileges) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CopyAcl( 
            /* [retval][out] */ IDispatch **ppAcl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsAclVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsAcl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsAcl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsAcl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsAcl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsAcl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsAcl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsAcl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProtectedAttrName )( 
            IADsAcl * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProtectedAttrName )( 
            IADsAcl * This,
            /* [in] */ BSTR bstrProtectedAttrName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubjectName )( 
            IADsAcl * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SubjectName )( 
            IADsAcl * This,
            /* [in] */ BSTR bstrSubjectName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Privileges )( 
            IADsAcl * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Privileges )( 
            IADsAcl * This,
            /* [in] */ long lnPrivileges);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *CopyAcl )( 
            IADsAcl * This,
            /* [retval][out] */ IDispatch **ppAcl);
        
        END_INTERFACE
    } IADsAclVtbl;

    interface IADsAcl
    {
        CONST_VTBL struct IADsAclVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsAcl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsAcl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsAcl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsAcl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsAcl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsAcl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsAcl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsAcl_get_ProtectedAttrName(This,retval)	\
    (This)->lpVtbl -> get_ProtectedAttrName(This,retval)

#define IADsAcl_put_ProtectedAttrName(This,bstrProtectedAttrName)	\
    (This)->lpVtbl -> put_ProtectedAttrName(This,bstrProtectedAttrName)

#define IADsAcl_get_SubjectName(This,retval)	\
    (This)->lpVtbl -> get_SubjectName(This,retval)

#define IADsAcl_put_SubjectName(This,bstrSubjectName)	\
    (This)->lpVtbl -> put_SubjectName(This,bstrSubjectName)

#define IADsAcl_get_Privileges(This,retval)	\
    (This)->lpVtbl -> get_Privileges(This,retval)

#define IADsAcl_put_Privileges(This,lnPrivileges)	\
    (This)->lpVtbl -> put_Privileges(This,lnPrivileges)

#define IADsAcl_CopyAcl(This,ppAcl)	\
    (This)->lpVtbl -> CopyAcl(This,ppAcl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsAcl_get_ProtectedAttrName_Proxy( 
    IADsAcl * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsAcl_get_ProtectedAttrName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsAcl_put_ProtectedAttrName_Proxy( 
    IADsAcl * This,
    /* [in] */ BSTR bstrProtectedAttrName);


void __RPC_STUB IADsAcl_put_ProtectedAttrName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsAcl_get_SubjectName_Proxy( 
    IADsAcl * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsAcl_get_SubjectName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsAcl_put_SubjectName_Proxy( 
    IADsAcl * This,
    /* [in] */ BSTR bstrSubjectName);


void __RPC_STUB IADsAcl_put_SubjectName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsAcl_get_Privileges_Proxy( 
    IADsAcl * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsAcl_get_Privileges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsAcl_put_Privileges_Proxy( 
    IADsAcl * This,
    /* [in] */ long lnPrivileges);


void __RPC_STUB IADsAcl_put_Privileges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsAcl_CopyAcl_Proxy( 
    IADsAcl * This,
    /* [retval][out] */ IDispatch **ppAcl);


void __RPC_STUB IADsAcl_CopyAcl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsAcl_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_Acl;

#ifdef __cplusplus

class DECLSPEC_UUID("7af1efb6-0869-11d1-a377-00c04fb950dc")
Acl;
#endif

#ifndef __IADsTimestamp_INTERFACE_DEFINED__
#define __IADsTimestamp_INTERFACE_DEFINED__

/* interface IADsTimestamp */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsTimestamp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b2f5a901-4080-11d1-a3ac-00c04fb950dc")
    IADsTimestamp : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_WholeSeconds( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_WholeSeconds( 
            /* [in] */ long lnWholeSeconds) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_EventID( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EventID( 
            /* [in] */ long lnEventID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsTimestampVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsTimestamp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsTimestamp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsTimestamp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsTimestamp * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsTimestamp * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsTimestamp * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsTimestamp * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WholeSeconds )( 
            IADsTimestamp * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WholeSeconds )( 
            IADsTimestamp * This,
            /* [in] */ long lnWholeSeconds);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventID )( 
            IADsTimestamp * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EventID )( 
            IADsTimestamp * This,
            /* [in] */ long lnEventID);
        
        END_INTERFACE
    } IADsTimestampVtbl;

    interface IADsTimestamp
    {
        CONST_VTBL struct IADsTimestampVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsTimestamp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsTimestamp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsTimestamp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsTimestamp_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsTimestamp_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsTimestamp_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsTimestamp_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsTimestamp_get_WholeSeconds(This,retval)	\
    (This)->lpVtbl -> get_WholeSeconds(This,retval)

#define IADsTimestamp_put_WholeSeconds(This,lnWholeSeconds)	\
    (This)->lpVtbl -> put_WholeSeconds(This,lnWholeSeconds)

#define IADsTimestamp_get_EventID(This,retval)	\
    (This)->lpVtbl -> get_EventID(This,retval)

#define IADsTimestamp_put_EventID(This,lnEventID)	\
    (This)->lpVtbl -> put_EventID(This,lnEventID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsTimestamp_get_WholeSeconds_Proxy( 
    IADsTimestamp * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsTimestamp_get_WholeSeconds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsTimestamp_put_WholeSeconds_Proxy( 
    IADsTimestamp * This,
    /* [in] */ long lnWholeSeconds);


void __RPC_STUB IADsTimestamp_put_WholeSeconds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsTimestamp_get_EventID_Proxy( 
    IADsTimestamp * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsTimestamp_get_EventID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsTimestamp_put_EventID_Proxy( 
    IADsTimestamp * This,
    /* [in] */ long lnEventID);


void __RPC_STUB IADsTimestamp_put_EventID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsTimestamp_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_Timestamp;

#ifdef __cplusplus

class DECLSPEC_UUID("b2bed2eb-4080-11d1-a3ac-00c04fb950dc")
Timestamp;
#endif

#ifndef __IADsPostalAddress_INTERFACE_DEFINED__
#define __IADsPostalAddress_INTERFACE_DEFINED__

/* interface IADsPostalAddress */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsPostalAddress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7adecf29-4680-11d1-a3b4-00c04fb950dc")
    IADsPostalAddress : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PostalAddress( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PostalAddress( 
            /* [in] */ VARIANT vPostalAddress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsPostalAddressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsPostalAddress * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsPostalAddress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsPostalAddress * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsPostalAddress * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsPostalAddress * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsPostalAddress * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsPostalAddress * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PostalAddress )( 
            IADsPostalAddress * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PostalAddress )( 
            IADsPostalAddress * This,
            /* [in] */ VARIANT vPostalAddress);
        
        END_INTERFACE
    } IADsPostalAddressVtbl;

    interface IADsPostalAddress
    {
        CONST_VTBL struct IADsPostalAddressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsPostalAddress_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsPostalAddress_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsPostalAddress_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsPostalAddress_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsPostalAddress_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsPostalAddress_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsPostalAddress_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsPostalAddress_get_PostalAddress(This,retval)	\
    (This)->lpVtbl -> get_PostalAddress(This,retval)

#define IADsPostalAddress_put_PostalAddress(This,vPostalAddress)	\
    (This)->lpVtbl -> put_PostalAddress(This,vPostalAddress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPostalAddress_get_PostalAddress_Proxy( 
    IADsPostalAddress * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsPostalAddress_get_PostalAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPostalAddress_put_PostalAddress_Proxy( 
    IADsPostalAddress * This,
    /* [in] */ VARIANT vPostalAddress);


void __RPC_STUB IADsPostalAddress_put_PostalAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsPostalAddress_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_PostalAddress;

#ifdef __cplusplus

class DECLSPEC_UUID("0a75afcd-4680-11d1-a3b4-00c04fb950dc")
PostalAddress;
#endif

#ifndef __IADsBackLink_INTERFACE_DEFINED__
#define __IADsBackLink_INTERFACE_DEFINED__

/* interface IADsBackLink */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsBackLink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fd1302bd-4080-11d1-a3ac-00c04fb950dc")
    IADsBackLink : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_RemoteID( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_RemoteID( 
            /* [in] */ long lnRemoteID) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ObjectName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ObjectName( 
            /* [in] */ BSTR bstrObjectName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsBackLinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsBackLink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsBackLink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsBackLink * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsBackLink * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsBackLink * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsBackLink * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsBackLink * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteID )( 
            IADsBackLink * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RemoteID )( 
            IADsBackLink * This,
            /* [in] */ long lnRemoteID);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectName )( 
            IADsBackLink * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ObjectName )( 
            IADsBackLink * This,
            /* [in] */ BSTR bstrObjectName);
        
        END_INTERFACE
    } IADsBackLinkVtbl;

    interface IADsBackLink
    {
        CONST_VTBL struct IADsBackLinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsBackLink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsBackLink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsBackLink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsBackLink_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsBackLink_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsBackLink_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsBackLink_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsBackLink_get_RemoteID(This,retval)	\
    (This)->lpVtbl -> get_RemoteID(This,retval)

#define IADsBackLink_put_RemoteID(This,lnRemoteID)	\
    (This)->lpVtbl -> put_RemoteID(This,lnRemoteID)

#define IADsBackLink_get_ObjectName(This,retval)	\
    (This)->lpVtbl -> get_ObjectName(This,retval)

#define IADsBackLink_put_ObjectName(This,bstrObjectName)	\
    (This)->lpVtbl -> put_ObjectName(This,bstrObjectName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsBackLink_get_RemoteID_Proxy( 
    IADsBackLink * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsBackLink_get_RemoteID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsBackLink_put_RemoteID_Proxy( 
    IADsBackLink * This,
    /* [in] */ long lnRemoteID);


void __RPC_STUB IADsBackLink_put_RemoteID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsBackLink_get_ObjectName_Proxy( 
    IADsBackLink * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsBackLink_get_ObjectName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsBackLink_put_ObjectName_Proxy( 
    IADsBackLink * This,
    /* [in] */ BSTR bstrObjectName);


void __RPC_STUB IADsBackLink_put_ObjectName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsBackLink_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_BackLink;

#ifdef __cplusplus

class DECLSPEC_UUID("fcbf906f-4080-11d1-a3ac-00c04fb950dc")
BackLink;
#endif

#ifndef __IADsTypedName_INTERFACE_DEFINED__
#define __IADsTypedName_INTERFACE_DEFINED__

/* interface IADsTypedName */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsTypedName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b371a349-4080-11d1-a3ac-00c04fb950dc")
    IADsTypedName : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ObjectName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ObjectName( 
            /* [in] */ BSTR bstrObjectName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Level( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Level( 
            /* [in] */ long lnLevel) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Interval( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Interval( 
            /* [in] */ long lnInterval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsTypedNameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsTypedName * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsTypedName * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsTypedName * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsTypedName * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsTypedName * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsTypedName * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsTypedName * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectName )( 
            IADsTypedName * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ObjectName )( 
            IADsTypedName * This,
            /* [in] */ BSTR bstrObjectName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Level )( 
            IADsTypedName * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Level )( 
            IADsTypedName * This,
            /* [in] */ long lnLevel);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Interval )( 
            IADsTypedName * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Interval )( 
            IADsTypedName * This,
            /* [in] */ long lnInterval);
        
        END_INTERFACE
    } IADsTypedNameVtbl;

    interface IADsTypedName
    {
        CONST_VTBL struct IADsTypedNameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsTypedName_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsTypedName_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsTypedName_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsTypedName_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsTypedName_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsTypedName_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsTypedName_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsTypedName_get_ObjectName(This,retval)	\
    (This)->lpVtbl -> get_ObjectName(This,retval)

#define IADsTypedName_put_ObjectName(This,bstrObjectName)	\
    (This)->lpVtbl -> put_ObjectName(This,bstrObjectName)

#define IADsTypedName_get_Level(This,retval)	\
    (This)->lpVtbl -> get_Level(This,retval)

#define IADsTypedName_put_Level(This,lnLevel)	\
    (This)->lpVtbl -> put_Level(This,lnLevel)

#define IADsTypedName_get_Interval(This,retval)	\
    (This)->lpVtbl -> get_Interval(This,retval)

#define IADsTypedName_put_Interval(This,lnInterval)	\
    (This)->lpVtbl -> put_Interval(This,lnInterval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsTypedName_get_ObjectName_Proxy( 
    IADsTypedName * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsTypedName_get_ObjectName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsTypedName_put_ObjectName_Proxy( 
    IADsTypedName * This,
    /* [in] */ BSTR bstrObjectName);


void __RPC_STUB IADsTypedName_put_ObjectName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsTypedName_get_Level_Proxy( 
    IADsTypedName * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsTypedName_get_Level_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsTypedName_put_Level_Proxy( 
    IADsTypedName * This,
    /* [in] */ long lnLevel);


void __RPC_STUB IADsTypedName_put_Level_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsTypedName_get_Interval_Proxy( 
    IADsTypedName * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsTypedName_get_Interval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsTypedName_put_Interval_Proxy( 
    IADsTypedName * This,
    /* [in] */ long lnInterval);


void __RPC_STUB IADsTypedName_put_Interval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsTypedName_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_TypedName;

#ifdef __cplusplus

class DECLSPEC_UUID("b33143cb-4080-11d1-a3ac-00c04fb950dc")
TypedName;
#endif

#ifndef __IADsHold_INTERFACE_DEFINED__
#define __IADsHold_INTERFACE_DEFINED__

/* interface IADsHold */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsHold;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b3eb3b37-4080-11d1-a3ac-00c04fb950dc")
    IADsHold : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ObjectName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ObjectName( 
            /* [in] */ BSTR bstrObjectName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Amount( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Amount( 
            /* [in] */ long lnAmount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsHoldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsHold * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsHold * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsHold * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsHold * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsHold * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsHold * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsHold * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectName )( 
            IADsHold * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ObjectName )( 
            IADsHold * This,
            /* [in] */ BSTR bstrObjectName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Amount )( 
            IADsHold * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Amount )( 
            IADsHold * This,
            /* [in] */ long lnAmount);
        
        END_INTERFACE
    } IADsHoldVtbl;

    interface IADsHold
    {
        CONST_VTBL struct IADsHoldVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsHold_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsHold_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsHold_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsHold_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsHold_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsHold_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsHold_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsHold_get_ObjectName(This,retval)	\
    (This)->lpVtbl -> get_ObjectName(This,retval)

#define IADsHold_put_ObjectName(This,bstrObjectName)	\
    (This)->lpVtbl -> put_ObjectName(This,bstrObjectName)

#define IADsHold_get_Amount(This,retval)	\
    (This)->lpVtbl -> get_Amount(This,retval)

#define IADsHold_put_Amount(This,lnAmount)	\
    (This)->lpVtbl -> put_Amount(This,lnAmount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsHold_get_ObjectName_Proxy( 
    IADsHold * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsHold_get_ObjectName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsHold_put_ObjectName_Proxy( 
    IADsHold * This,
    /* [in] */ BSTR bstrObjectName);


void __RPC_STUB IADsHold_put_ObjectName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsHold_get_Amount_Proxy( 
    IADsHold * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsHold_get_Amount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsHold_put_Amount_Proxy( 
    IADsHold * This,
    /* [in] */ long lnAmount);


void __RPC_STUB IADsHold_put_Amount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsHold_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_Hold;

#ifdef __cplusplus

class DECLSPEC_UUID("b3ad3e13-4080-11d1-a3ac-00c04fb950dc")
Hold;
#endif

#ifndef __IADsObjectOptions_INTERFACE_DEFINED__
#define __IADsObjectOptions_INTERFACE_DEFINED__

/* interface IADsObjectOptions */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsObjectOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("46f14fda-232b-11d1-a808-00c04fd8d5a8")
    IADsObjectOptions : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetOption( 
            /* [in] */ long lnOption,
            /* [retval][out] */ VARIANT *pvValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetOption( 
            /* [in] */ long lnOption,
            /* [in] */ VARIANT vValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsObjectOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsObjectOptions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsObjectOptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsObjectOptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsObjectOptions * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsObjectOptions * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsObjectOptions * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsObjectOptions * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetOption )( 
            IADsObjectOptions * This,
            /* [in] */ long lnOption,
            /* [retval][out] */ VARIANT *pvValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetOption )( 
            IADsObjectOptions * This,
            /* [in] */ long lnOption,
            /* [in] */ VARIANT vValue);
        
        END_INTERFACE
    } IADsObjectOptionsVtbl;

    interface IADsObjectOptions
    {
        CONST_VTBL struct IADsObjectOptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsObjectOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsObjectOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsObjectOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsObjectOptions_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsObjectOptions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsObjectOptions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsObjectOptions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsObjectOptions_GetOption(This,lnOption,pvValue)	\
    (This)->lpVtbl -> GetOption(This,lnOption,pvValue)

#define IADsObjectOptions_SetOption(This,lnOption,vValue)	\
    (This)->lpVtbl -> SetOption(This,lnOption,vValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IADsObjectOptions_GetOption_Proxy( 
    IADsObjectOptions * This,
    /* [in] */ long lnOption,
    /* [retval][out] */ VARIANT *pvValue);


void __RPC_STUB IADsObjectOptions_GetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsObjectOptions_SetOption_Proxy( 
    IADsObjectOptions * This,
    /* [in] */ long lnOption,
    /* [in] */ VARIANT vValue);


void __RPC_STUB IADsObjectOptions_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsObjectOptions_INTERFACE_DEFINED__ */


#ifndef __IADsPathname_INTERFACE_DEFINED__
#define __IADsPathname_INTERFACE_DEFINED__

/* interface IADsPathname */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsPathname;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d592aed4-f420-11d0-a36e-00c04fb950dc")
    IADsPathname : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ BSTR bstrADsPath,
            /* [in] */ long lnSetType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetDisplayType( 
            /* [in] */ long lnDisplayType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Retrieve( 
            /* [in] */ long lnFormatType,
            /* [retval][out] */ BSTR *pbstrADsPath) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetNumElements( 
            /* [retval][out] */ long *plnNumPathElements) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetElement( 
            /* [in] */ long lnElementIndex,
            /* [retval][out] */ BSTR *pbstrElement) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddLeafElement( 
            /* [in] */ BSTR bstrLeafElement) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RemoveLeafElement( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CopyPath( 
            /* [retval][out] */ IDispatch **ppAdsPath) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetEscapedElement( 
            /* [in] */ long lnReserved,
            /* [in] */ BSTR bstrInStr,
            /* [retval][out] */ BSTR *pbstrOutStr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_EscapedMode( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EscapedMode( 
            /* [in] */ long lnEscapedMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsPathnameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsPathname * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsPathname * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsPathname * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsPathname * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsPathname * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsPathname * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsPathname * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Set )( 
            IADsPathname * This,
            /* [in] */ BSTR bstrADsPath,
            /* [in] */ long lnSetType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetDisplayType )( 
            IADsPathname * This,
            /* [in] */ long lnDisplayType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Retrieve )( 
            IADsPathname * This,
            /* [in] */ long lnFormatType,
            /* [retval][out] */ BSTR *pbstrADsPath);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetNumElements )( 
            IADsPathname * This,
            /* [retval][out] */ long *plnNumPathElements);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetElement )( 
            IADsPathname * This,
            /* [in] */ long lnElementIndex,
            /* [retval][out] */ BSTR *pbstrElement);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *AddLeafElement )( 
            IADsPathname * This,
            /* [in] */ BSTR bstrLeafElement);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RemoveLeafElement )( 
            IADsPathname * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *CopyPath )( 
            IADsPathname * This,
            /* [retval][out] */ IDispatch **ppAdsPath);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEscapedElement )( 
            IADsPathname * This,
            /* [in] */ long lnReserved,
            /* [in] */ BSTR bstrInStr,
            /* [retval][out] */ BSTR *pbstrOutStr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EscapedMode )( 
            IADsPathname * This,
            /* [retval][out] */ long *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EscapedMode )( 
            IADsPathname * This,
            /* [in] */ long lnEscapedMode);
        
        END_INTERFACE
    } IADsPathnameVtbl;

    interface IADsPathname
    {
        CONST_VTBL struct IADsPathnameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsPathname_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsPathname_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsPathname_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsPathname_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsPathname_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsPathname_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsPathname_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsPathname_Set(This,bstrADsPath,lnSetType)	\
    (This)->lpVtbl -> Set(This,bstrADsPath,lnSetType)

#define IADsPathname_SetDisplayType(This,lnDisplayType)	\
    (This)->lpVtbl -> SetDisplayType(This,lnDisplayType)

#define IADsPathname_Retrieve(This,lnFormatType,pbstrADsPath)	\
    (This)->lpVtbl -> Retrieve(This,lnFormatType,pbstrADsPath)

#define IADsPathname_GetNumElements(This,plnNumPathElements)	\
    (This)->lpVtbl -> GetNumElements(This,plnNumPathElements)

#define IADsPathname_GetElement(This,lnElementIndex,pbstrElement)	\
    (This)->lpVtbl -> GetElement(This,lnElementIndex,pbstrElement)

#define IADsPathname_AddLeafElement(This,bstrLeafElement)	\
    (This)->lpVtbl -> AddLeafElement(This,bstrLeafElement)

#define IADsPathname_RemoveLeafElement(This)	\
    (This)->lpVtbl -> RemoveLeafElement(This)

#define IADsPathname_CopyPath(This,ppAdsPath)	\
    (This)->lpVtbl -> CopyPath(This,ppAdsPath)

#define IADsPathname_GetEscapedElement(This,lnReserved,bstrInStr,pbstrOutStr)	\
    (This)->lpVtbl -> GetEscapedElement(This,lnReserved,bstrInStr,pbstrOutStr)

#define IADsPathname_get_EscapedMode(This,retval)	\
    (This)->lpVtbl -> get_EscapedMode(This,retval)

#define IADsPathname_put_EscapedMode(This,lnEscapedMode)	\
    (This)->lpVtbl -> put_EscapedMode(This,lnEscapedMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IADsPathname_Set_Proxy( 
    IADsPathname * This,
    /* [in] */ BSTR bstrADsPath,
    /* [in] */ long lnSetType);


void __RPC_STUB IADsPathname_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsPathname_SetDisplayType_Proxy( 
    IADsPathname * This,
    /* [in] */ long lnDisplayType);


void __RPC_STUB IADsPathname_SetDisplayType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsPathname_Retrieve_Proxy( 
    IADsPathname * This,
    /* [in] */ long lnFormatType,
    /* [retval][out] */ BSTR *pbstrADsPath);


void __RPC_STUB IADsPathname_Retrieve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsPathname_GetNumElements_Proxy( 
    IADsPathname * This,
    /* [retval][out] */ long *plnNumPathElements);


void __RPC_STUB IADsPathname_GetNumElements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsPathname_GetElement_Proxy( 
    IADsPathname * This,
    /* [in] */ long lnElementIndex,
    /* [retval][out] */ BSTR *pbstrElement);


void __RPC_STUB IADsPathname_GetElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsPathname_AddLeafElement_Proxy( 
    IADsPathname * This,
    /* [in] */ BSTR bstrLeafElement);


void __RPC_STUB IADsPathname_AddLeafElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsPathname_RemoveLeafElement_Proxy( 
    IADsPathname * This);


void __RPC_STUB IADsPathname_RemoveLeafElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsPathname_CopyPath_Proxy( 
    IADsPathname * This,
    /* [retval][out] */ IDispatch **ppAdsPath);


void __RPC_STUB IADsPathname_CopyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsPathname_GetEscapedElement_Proxy( 
    IADsPathname * This,
    /* [in] */ long lnReserved,
    /* [in] */ BSTR bstrInStr,
    /* [retval][out] */ BSTR *pbstrOutStr);


void __RPC_STUB IADsPathname_GetEscapedElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsPathname_get_EscapedMode_Proxy( 
    IADsPathname * This,
    /* [retval][out] */ long *retval);


void __RPC_STUB IADsPathname_get_EscapedMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsPathname_put_EscapedMode_Proxy( 
    IADsPathname * This,
    /* [in] */ long lnEscapedMode);


void __RPC_STUB IADsPathname_put_EscapedMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsPathname_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_Pathname;

#ifdef __cplusplus

class DECLSPEC_UUID("080d0d78-f421-11d0-a36e-00c04fb950dc")
Pathname;
#endif

#ifndef __IADsADSystemInfo_INTERFACE_DEFINED__
#define __IADsADSystemInfo_INTERFACE_DEFINED__

/* interface IADsADSystemInfo */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsADSystemInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5BB11929-AFD1-11d2-9CB9-0000F87A369E")
    IADsADSystemInfo : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_UserName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ComputerName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SiteName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainShortName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainDNSName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ForestDNSName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PDCRoleOwner( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SchemaRoleOwner( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_IsNativeMode( 
            /* [retval][out] */ VARIANT_BOOL *retval) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetAnyDCName( 
            /* [retval][out] */ BSTR *pszDCName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetDCSiteName( 
            /* [in] */ BSTR szServer,
            /* [retval][out] */ BSTR *pszSiteName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RefreshSchemaCache( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetTrees( 
            /* [retval][out] */ VARIANT *pvTrees) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsADSystemInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsADSystemInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsADSystemInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsADSystemInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsADSystemInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsADSystemInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsADSystemInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsADSystemInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserName )( 
            IADsADSystemInfo * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ComputerName )( 
            IADsADSystemInfo * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SiteName )( 
            IADsADSystemInfo * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DomainShortName )( 
            IADsADSystemInfo * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DomainDNSName )( 
            IADsADSystemInfo * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForestDNSName )( 
            IADsADSystemInfo * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PDCRoleOwner )( 
            IADsADSystemInfo * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SchemaRoleOwner )( 
            IADsADSystemInfo * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsNativeMode )( 
            IADsADSystemInfo * This,
            /* [retval][out] */ VARIANT_BOOL *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetAnyDCName )( 
            IADsADSystemInfo * This,
            /* [retval][out] */ BSTR *pszDCName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetDCSiteName )( 
            IADsADSystemInfo * This,
            /* [in] */ BSTR szServer,
            /* [retval][out] */ BSTR *pszSiteName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RefreshSchemaCache )( 
            IADsADSystemInfo * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetTrees )( 
            IADsADSystemInfo * This,
            /* [retval][out] */ VARIANT *pvTrees);
        
        END_INTERFACE
    } IADsADSystemInfoVtbl;

    interface IADsADSystemInfo
    {
        CONST_VTBL struct IADsADSystemInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsADSystemInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsADSystemInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsADSystemInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsADSystemInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsADSystemInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsADSystemInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsADSystemInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsADSystemInfo_get_UserName(This,retval)	\
    (This)->lpVtbl -> get_UserName(This,retval)

#define IADsADSystemInfo_get_ComputerName(This,retval)	\
    (This)->lpVtbl -> get_ComputerName(This,retval)

#define IADsADSystemInfo_get_SiteName(This,retval)	\
    (This)->lpVtbl -> get_SiteName(This,retval)

#define IADsADSystemInfo_get_DomainShortName(This,retval)	\
    (This)->lpVtbl -> get_DomainShortName(This,retval)

#define IADsADSystemInfo_get_DomainDNSName(This,retval)	\
    (This)->lpVtbl -> get_DomainDNSName(This,retval)

#define IADsADSystemInfo_get_ForestDNSName(This,retval)	\
    (This)->lpVtbl -> get_ForestDNSName(This,retval)

#define IADsADSystemInfo_get_PDCRoleOwner(This,retval)	\
    (This)->lpVtbl -> get_PDCRoleOwner(This,retval)

#define IADsADSystemInfo_get_SchemaRoleOwner(This,retval)	\
    (This)->lpVtbl -> get_SchemaRoleOwner(This,retval)

#define IADsADSystemInfo_get_IsNativeMode(This,retval)	\
    (This)->lpVtbl -> get_IsNativeMode(This,retval)

#define IADsADSystemInfo_GetAnyDCName(This,pszDCName)	\
    (This)->lpVtbl -> GetAnyDCName(This,pszDCName)

#define IADsADSystemInfo_GetDCSiteName(This,szServer,pszSiteName)	\
    (This)->lpVtbl -> GetDCSiteName(This,szServer,pszSiteName)

#define IADsADSystemInfo_RefreshSchemaCache(This)	\
    (This)->lpVtbl -> RefreshSchemaCache(This)

#define IADsADSystemInfo_GetTrees(This,pvTrees)	\
    (This)->lpVtbl -> GetTrees(This,pvTrees)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsADSystemInfo_get_UserName_Proxy( 
    IADsADSystemInfo * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsADSystemInfo_get_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsADSystemInfo_get_ComputerName_Proxy( 
    IADsADSystemInfo * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsADSystemInfo_get_ComputerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsADSystemInfo_get_SiteName_Proxy( 
    IADsADSystemInfo * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsADSystemInfo_get_SiteName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsADSystemInfo_get_DomainShortName_Proxy( 
    IADsADSystemInfo * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsADSystemInfo_get_DomainShortName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsADSystemInfo_get_DomainDNSName_Proxy( 
    IADsADSystemInfo * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsADSystemInfo_get_DomainDNSName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsADSystemInfo_get_ForestDNSName_Proxy( 
    IADsADSystemInfo * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsADSystemInfo_get_ForestDNSName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsADSystemInfo_get_PDCRoleOwner_Proxy( 
    IADsADSystemInfo * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsADSystemInfo_get_PDCRoleOwner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsADSystemInfo_get_SchemaRoleOwner_Proxy( 
    IADsADSystemInfo * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsADSystemInfo_get_SchemaRoleOwner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsADSystemInfo_get_IsNativeMode_Proxy( 
    IADsADSystemInfo * This,
    /* [retval][out] */ VARIANT_BOOL *retval);


void __RPC_STUB IADsADSystemInfo_get_IsNativeMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsADSystemInfo_GetAnyDCName_Proxy( 
    IADsADSystemInfo * This,
    /* [retval][out] */ BSTR *pszDCName);


void __RPC_STUB IADsADSystemInfo_GetAnyDCName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsADSystemInfo_GetDCSiteName_Proxy( 
    IADsADSystemInfo * This,
    /* [in] */ BSTR szServer,
    /* [retval][out] */ BSTR *pszSiteName);


void __RPC_STUB IADsADSystemInfo_GetDCSiteName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsADSystemInfo_RefreshSchemaCache_Proxy( 
    IADsADSystemInfo * This);


void __RPC_STUB IADsADSystemInfo_RefreshSchemaCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IADsADSystemInfo_GetTrees_Proxy( 
    IADsADSystemInfo * This,
    /* [retval][out] */ VARIANT *pvTrees);


void __RPC_STUB IADsADSystemInfo_GetTrees_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsADSystemInfo_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ADSystemInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("50B6327F-AFD1-11d2-9CB9-0000F87A369E")
ADSystemInfo;
#endif

#ifndef __IADsWinNTSystemInfo_INTERFACE_DEFINED__
#define __IADsWinNTSystemInfo_INTERFACE_DEFINED__

/* interface IADsWinNTSystemInfo */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsWinNTSystemInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6C6D65DC-AFD1-11d2-9CB9-0000F87A369E")
    IADsWinNTSystemInfo : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_UserName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ComputerName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainName( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PDC( 
            /* [retval][out] */ BSTR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsWinNTSystemInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsWinNTSystemInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsWinNTSystemInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsWinNTSystemInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsWinNTSystemInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsWinNTSystemInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsWinNTSystemInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsWinNTSystemInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserName )( 
            IADsWinNTSystemInfo * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ComputerName )( 
            IADsWinNTSystemInfo * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DomainName )( 
            IADsWinNTSystemInfo * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PDC )( 
            IADsWinNTSystemInfo * This,
            /* [retval][out] */ BSTR *retval);
        
        END_INTERFACE
    } IADsWinNTSystemInfoVtbl;

    interface IADsWinNTSystemInfo
    {
        CONST_VTBL struct IADsWinNTSystemInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsWinNTSystemInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsWinNTSystemInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsWinNTSystemInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsWinNTSystemInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsWinNTSystemInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsWinNTSystemInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsWinNTSystemInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsWinNTSystemInfo_get_UserName(This,retval)	\
    (This)->lpVtbl -> get_UserName(This,retval)

#define IADsWinNTSystemInfo_get_ComputerName(This,retval)	\
    (This)->lpVtbl -> get_ComputerName(This,retval)

#define IADsWinNTSystemInfo_get_DomainName(This,retval)	\
    (This)->lpVtbl -> get_DomainName(This,retval)

#define IADsWinNTSystemInfo_get_PDC(This,retval)	\
    (This)->lpVtbl -> get_PDC(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsWinNTSystemInfo_get_UserName_Proxy( 
    IADsWinNTSystemInfo * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsWinNTSystemInfo_get_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsWinNTSystemInfo_get_ComputerName_Proxy( 
    IADsWinNTSystemInfo * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsWinNTSystemInfo_get_ComputerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsWinNTSystemInfo_get_DomainName_Proxy( 
    IADsWinNTSystemInfo * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsWinNTSystemInfo_get_DomainName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsWinNTSystemInfo_get_PDC_Proxy( 
    IADsWinNTSystemInfo * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsWinNTSystemInfo_get_PDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsWinNTSystemInfo_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WinNTSystemInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("66182EC4-AFD1-11d2-9CB9-0000F87A369E")
WinNTSystemInfo;
#endif

#ifndef __IADsDNWithBinary_INTERFACE_DEFINED__
#define __IADsDNWithBinary_INTERFACE_DEFINED__

/* interface IADsDNWithBinary */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsDNWithBinary;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7e99c0a2-f935-11d2-ba96-00c04fb6d0d1")
    IADsDNWithBinary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BinaryValue( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BinaryValue( 
            /* [in] */ VARIANT vBinaryValue) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DNString( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DNString( 
            /* [in] */ BSTR bstrDNString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsDNWithBinaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsDNWithBinary * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsDNWithBinary * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsDNWithBinary * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsDNWithBinary * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsDNWithBinary * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsDNWithBinary * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsDNWithBinary * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BinaryValue )( 
            IADsDNWithBinary * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BinaryValue )( 
            IADsDNWithBinary * This,
            /* [in] */ VARIANT vBinaryValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DNString )( 
            IADsDNWithBinary * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DNString )( 
            IADsDNWithBinary * This,
            /* [in] */ BSTR bstrDNString);
        
        END_INTERFACE
    } IADsDNWithBinaryVtbl;

    interface IADsDNWithBinary
    {
        CONST_VTBL struct IADsDNWithBinaryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsDNWithBinary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsDNWithBinary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsDNWithBinary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsDNWithBinary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsDNWithBinary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsDNWithBinary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsDNWithBinary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsDNWithBinary_get_BinaryValue(This,retval)	\
    (This)->lpVtbl -> get_BinaryValue(This,retval)

#define IADsDNWithBinary_put_BinaryValue(This,vBinaryValue)	\
    (This)->lpVtbl -> put_BinaryValue(This,vBinaryValue)

#define IADsDNWithBinary_get_DNString(This,retval)	\
    (This)->lpVtbl -> get_DNString(This,retval)

#define IADsDNWithBinary_put_DNString(This,bstrDNString)	\
    (This)->lpVtbl -> put_DNString(This,bstrDNString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsDNWithBinary_get_BinaryValue_Proxy( 
    IADsDNWithBinary * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IADsDNWithBinary_get_BinaryValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsDNWithBinary_put_BinaryValue_Proxy( 
    IADsDNWithBinary * This,
    /* [in] */ VARIANT vBinaryValue);


void __RPC_STUB IADsDNWithBinary_put_BinaryValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsDNWithBinary_get_DNString_Proxy( 
    IADsDNWithBinary * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsDNWithBinary_get_DNString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsDNWithBinary_put_DNString_Proxy( 
    IADsDNWithBinary * This,
    /* [in] */ BSTR bstrDNString);


void __RPC_STUB IADsDNWithBinary_put_DNString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsDNWithBinary_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DNWithBinary;

#ifdef __cplusplus

class DECLSPEC_UUID("7e99c0a3-f935-11d2-ba96-00c04fb6d0d1")
DNWithBinary;
#endif

#ifndef __IADsDNWithString_INTERFACE_DEFINED__
#define __IADsDNWithString_INTERFACE_DEFINED__

/* interface IADsDNWithString */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsDNWithString;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("370df02e-f934-11d2-ba96-00c04fb6d0d1")
    IADsDNWithString : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StringValue( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StringValue( 
            /* [in] */ BSTR bstrStringValue) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DNString( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DNString( 
            /* [in] */ BSTR bstrDNString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsDNWithStringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsDNWithString * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsDNWithString * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsDNWithString * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsDNWithString * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsDNWithString * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsDNWithString * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsDNWithString * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StringValue )( 
            IADsDNWithString * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StringValue )( 
            IADsDNWithString * This,
            /* [in] */ BSTR bstrStringValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DNString )( 
            IADsDNWithString * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DNString )( 
            IADsDNWithString * This,
            /* [in] */ BSTR bstrDNString);
        
        END_INTERFACE
    } IADsDNWithStringVtbl;

    interface IADsDNWithString
    {
        CONST_VTBL struct IADsDNWithStringVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsDNWithString_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsDNWithString_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsDNWithString_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsDNWithString_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADsDNWithString_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADsDNWithString_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADsDNWithString_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADsDNWithString_get_StringValue(This,retval)	\
    (This)->lpVtbl -> get_StringValue(This,retval)

#define IADsDNWithString_put_StringValue(This,bstrStringValue)	\
    (This)->lpVtbl -> put_StringValue(This,bstrStringValue)

#define IADsDNWithString_get_DNString(This,retval)	\
    (This)->lpVtbl -> get_DNString(This,retval)

#define IADsDNWithString_put_DNString(This,bstrDNString)	\
    (This)->lpVtbl -> put_DNString(This,bstrDNString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsDNWithString_get_StringValue_Proxy( 
    IADsDNWithString * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsDNWithString_get_StringValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsDNWithString_put_StringValue_Proxy( 
    IADsDNWithString * This,
    /* [in] */ BSTR bstrStringValue);


void __RPC_STUB IADsDNWithString_put_StringValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADsDNWithString_get_DNString_Proxy( 
    IADsDNWithString * This,
    /* [retval][out] */ BSTR *retval);


void __RPC_STUB IADsDNWithString_get_DNString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADsDNWithString_put_DNString_Proxy( 
    IADsDNWithString * This,
    /* [in] */ BSTR bstrDNString);


void __RPC_STUB IADsDNWithString_put_DNString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsDNWithString_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DNWithString;

#ifdef __cplusplus

class DECLSPEC_UUID("334857cc-f934-11d2-ba96-00c04fb6d0d1")
DNWithString;
#endif
#endif /* __ActiveDs_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ieventq.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Mon Sep 20 16:32:23 1999
 */
/* Compiler settings for ieventq.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ieventq_h__
#define __ieventq_h__

/* Forward Declarations */ 

#ifndef __IAddEvents_FWD_DEFINED__
#define __IAddEvents_FWD_DEFINED__
typedef interface IAddEvents IAddEvents;
#endif 	/* __IAddEvents_FWD_DEFINED__ */


#ifndef __IReadEvents_FWD_DEFINED__
#define __IReadEvents_FWD_DEFINED__
typedef interface IReadEvents IReadEvents;
#endif 	/* __IReadEvents_FWD_DEFINED__ */


#ifndef __EVENTQUEUE_FWD_DEFINED__
#define __EVENTQUEUE_FWD_DEFINED__

#ifdef __cplusplus
typedef class EVENTQUEUE EVENTQUEUE;
#else
typedef struct EVENTQUEUE EVENTQUEUE;
#endif /* __cplusplus */

#endif 	/* __EVENTQUEUE_FWD_DEFINED__ */


/* header files for imported files */
#include "nmevent.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_ieventq_0000 */
/* [local] */ 

// The new event notification callback, expose this function:
// void WINAPI Callback(LPVOID pInstanceData, DWORD QueueIndex, DWORD EventIndex);
typedef void (WINAPI * PEVENTQCALLBACK )( LPVOID, DWORD, DWORD );
typedef struct _COLUMNENTRY
    {
    DWORD ColumnNumber;
    char __RPC_FAR *pColumnString;
    }	COLUMNENTRY;

typedef COLUMNENTRY __RPC_FAR *PCOLUMNENTRY;

typedef struct _COLUMNSTRINGTABLE
    {
    DWORD NumStrings;
    SIZE_T TotalStringLength;
    /* [size_is] */ COLUMNENTRY ColumnEntry[ 1 ];
    }	COLUMNSTRINGTABLE;

typedef COLUMNSTRINGTABLE __RPC_FAR *PCOLUMNSTRINGTABLE;

typedef struct _COLUMNFORMATARRAY
    {
    DWORD NumColumns;
    /* [size_is] */ DWORD FormatFlags[ 1 ];
    }	COLUMNFORMATARRAY;

typedef COLUMNFORMATARRAY __RPC_FAR *PCOLUMNFORMATARRAY;

#define FORMAT_HEX    0x00000001
#define FORMAT_YESNO  0x00000002
#define FORMAT_ONOFF  0x00000004
#define FORMAT_NODATE 0x00000010
typedef 
enum _EVENTFILTEROP
    {	EVENTFILTEROP_Equal	= 0,
	EVENTFILTEROP_NotEqual	= EVENTFILTEROP_Equal + 1,
	EVENTFILTEROP_GreaterThan	= EVENTFILTEROP_NotEqual + 1,
	EVENTFILTEROP_EqualOrGreaterThan	= EVENTFILTEROP_GreaterThan + 1,
	EVENTFILTEROP_LessThan	= EVENTFILTEROP_EqualOrGreaterThan + 1,
	EVENTFILTEROP_EqualOrLessThan	= EVENTFILTEROP_LessThan + 1
    }	EVENTFILTEROP;

typedef struct _EVENTFILTERENTRY
    {
    DWORD dwColumnNumber;
    EVENTFILTEROP Operator;
    NMCOLUMNVARIANT ColumnVariant;
    }	EVENTFILTERENTRY;

typedef EVENTFILTERENTRY __RPC_FAR *PEVENTFILTERENTRY;

typedef struct _EVENTFILTER
    {
    DWORD NumEntries;
    /* [size_is] */ EVENTFILTERENTRY Entry[ 1 ];
    }	EVENTFILTER;

typedef EVENTFILTER __RPC_FAR *PEVENTFILTER;

#define EVENT_FIXED_DISPLAYABLE_COLUMNS 7          


extern RPC_IF_HANDLE __MIDL_itf_ieventq_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ieventq_0000_v0_0_s_ifspec;

#ifndef __IAddEvents_INTERFACE_DEFINED__
#define __IAddEvents_INTERFACE_DEFINED__

/* interface IAddEvents */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IAddEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D710A6AE-3371-11d1-BE5B-00C04FC9E2BB")
    IAddEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddQueue( 
            /* [in] */ const char __RPC_FAR *szBaseDirectory,
            /* [in] */ char __RPC_FAR *szQueueName,
            /* [out] */ DWORD __RPC_FAR *pdwQueueIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEvent( 
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ PNMEVENTDATA pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAddEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAddEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAddEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAddEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddQueue )( 
            IAddEvents __RPC_FAR * This,
            /* [in] */ const char __RPC_FAR *szBaseDirectory,
            /* [in] */ char __RPC_FAR *szQueueName,
            /* [out] */ DWORD __RPC_FAR *pdwQueueIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddEvent )( 
            IAddEvents __RPC_FAR * This,
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ PNMEVENTDATA pEvent);
        
        END_INTERFACE
    } IAddEventsVtbl;

    interface IAddEvents
    {
        CONST_VTBL struct IAddEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAddEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAddEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAddEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAddEvents_AddQueue(This,szBaseDirectory,szQueueName,pdwQueueIndex)	\
    (This)->lpVtbl -> AddQueue(This,szBaseDirectory,szQueueName,pdwQueueIndex)

#define IAddEvents_AddEvent(This,dwQueueIndex,pEvent)	\
    (This)->lpVtbl -> AddEvent(This,dwQueueIndex,pEvent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAddEvents_AddQueue_Proxy( 
    IAddEvents __RPC_FAR * This,
    /* [in] */ const char __RPC_FAR *szBaseDirectory,
    /* [in] */ char __RPC_FAR *szQueueName,
    /* [out] */ DWORD __RPC_FAR *pdwQueueIndex);


void __RPC_STUB IAddEvents_AddQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAddEvents_AddEvent_Proxy( 
    IAddEvents __RPC_FAR * This,
    /* [in] */ DWORD dwQueueIndex,
    /* [in] */ PNMEVENTDATA pEvent);


void __RPC_STUB IAddEvents_AddEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAddEvents_INTERFACE_DEFINED__ */


#ifndef __IReadEvents_INTERFACE_DEFINED__
#define __IReadEvents_INTERFACE_DEFINED__

/* interface IReadEvents */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IReadEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F64AEFDE-3376-11d1-BE5B-00C04FC9E2BB")
    IReadEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterNotificationCallback( 
            /* [in] */ LPVOID pEventCallback,
            /* [in] */ LPVOID pInstanceData,
            /* [out] */ DWORD __RPC_FAR *pCallbackKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeregisterNotificationCallback( 
            /* [in] */ DWORD CallbackKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLatestQueueIndex( 
            /* [out] */ DWORD __RPC_FAR *pdwQueueIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQueueName( 
            /* [in] */ DWORD dwQueueIndex,
            /* [out] */ char __RPC_FAR *__RPC_FAR *ppColumnName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLatestEventIndex( 
            /* [in] */ DWORD dwQueueIndex,
            /* [out] */ DWORD __RPC_FAR *pdwEventIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesEventPassFilter( 
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ DWORD dwEventIndex,
            /* [in] */ PEVENTFILTER pFilter,
            /* [out] */ BOOL __RPC_FAR *pfDoesItPass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareEvents( 
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ DWORD dwFirstEventIndex,
            /* [in] */ DWORD dwSecondEventIndex,
            /* [in] */ DWORD dwColumnNumber,
            /* [out] */ long __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEvent( 
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ DWORD dwEventIndex,
            /* [out] */ PNMEVENTDATA __RPC_FAR *ppEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFullFormattedEvent( 
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ DWORD dwEventIndex,
            /* [in] */ PCOLUMNFORMATARRAY pColumnFormatArray,
            /* [out] */ PCOLUMNSTRINGTABLE __RPC_FAR *ppColumnStringTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSparseFormattedEvent( 
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ DWORD dwEventIndex,
            /* [in] */ PCOLUMNFORMATARRAY pColumnFormatArray,
            /* [out] */ PCOLUMNSTRINGTABLE __RPC_FAR *ppColumnStringTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnIndex( 
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ char __RPC_FAR *szColumnName,
            /* [out] */ DWORD __RPC_FAR *pdwColumnNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnName( 
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ DWORD dwColumnNumber,
            /* [out] */ char __RPC_FAR *__RPC_FAR *ppColumnName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushEvents( 
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ DWORD dwNumberOfEventsToDelete) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReadEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReadEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReadEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReadEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterNotificationCallback )( 
            IReadEvents __RPC_FAR * This,
            /* [in] */ LPVOID pEventCallback,
            /* [in] */ LPVOID pInstanceData,
            /* [out] */ DWORD __RPC_FAR *pCallbackKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeregisterNotificationCallback )( 
            IReadEvents __RPC_FAR * This,
            /* [in] */ DWORD CallbackKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLatestQueueIndex )( 
            IReadEvents __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwQueueIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQueueName )( 
            IReadEvents __RPC_FAR * This,
            /* [in] */ DWORD dwQueueIndex,
            /* [out] */ char __RPC_FAR *__RPC_FAR *ppColumnName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLatestEventIndex )( 
            IReadEvents __RPC_FAR * This,
            /* [in] */ DWORD dwQueueIndex,
            /* [out] */ DWORD __RPC_FAR *pdwEventIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoesEventPassFilter )( 
            IReadEvents __RPC_FAR * This,
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ DWORD dwEventIndex,
            /* [in] */ PEVENTFILTER pFilter,
            /* [out] */ BOOL __RPC_FAR *pfDoesItPass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareEvents )( 
            IReadEvents __RPC_FAR * This,
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ DWORD dwFirstEventIndex,
            /* [in] */ DWORD dwSecondEventIndex,
            /* [in] */ DWORD dwColumnNumber,
            /* [out] */ long __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEvent )( 
            IReadEvents __RPC_FAR * This,
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ DWORD dwEventIndex,
            /* [out] */ PNMEVENTDATA __RPC_FAR *ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFullFormattedEvent )( 
            IReadEvents __RPC_FAR * This,
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ DWORD dwEventIndex,
            /* [in] */ PCOLUMNFORMATARRAY pColumnFormatArray,
            /* [out] */ PCOLUMNSTRINGTABLE __RPC_FAR *ppColumnStringTable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSparseFormattedEvent )( 
            IReadEvents __RPC_FAR * This,
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ DWORD dwEventIndex,
            /* [in] */ PCOLUMNFORMATARRAY pColumnFormatArray,
            /* [out] */ PCOLUMNSTRINGTABLE __RPC_FAR *ppColumnStringTable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnIndex )( 
            IReadEvents __RPC_FAR * This,
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ char __RPC_FAR *szColumnName,
            /* [out] */ DWORD __RPC_FAR *pdwColumnNumber);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnName )( 
            IReadEvents __RPC_FAR * This,
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ DWORD dwColumnNumber,
            /* [out] */ char __RPC_FAR *__RPC_FAR *ppColumnName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FlushEvents )( 
            IReadEvents __RPC_FAR * This,
            /* [in] */ DWORD dwQueueIndex,
            /* [in] */ DWORD dwNumberOfEventsToDelete);
        
        END_INTERFACE
    } IReadEventsVtbl;

    interface IReadEvents
    {
        CONST_VTBL struct IReadEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReadEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReadEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReadEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReadEvents_RegisterNotificationCallback(This,pEventCallback,pInstanceData,pCallbackKey)	\
    (This)->lpVtbl -> RegisterNotificationCallback(This,pEventCallback,pInstanceData,pCallbackKey)

#define IReadEvents_DeregisterNotificationCallback(This,CallbackKey)	\
    (This)->lpVtbl -> DeregisterNotificationCallback(This,CallbackKey)

#define IReadEvents_GetLatestQueueIndex(This,pdwQueueIndex)	\
    (This)->lpVtbl -> GetLatestQueueIndex(This,pdwQueueIndex)

#define IReadEvents_GetQueueName(This,dwQueueIndex,ppColumnName)	\
    (This)->lpVtbl -> GetQueueName(This,dwQueueIndex,ppColumnName)

#define IReadEvents_GetLatestEventIndex(This,dwQueueIndex,pdwEventIndex)	\
    (This)->lpVtbl -> GetLatestEventIndex(This,dwQueueIndex,pdwEventIndex)

#define IReadEvents_DoesEventPassFilter(This,dwQueueIndex,dwEventIndex,pFilter,pfDoesItPass)	\
    (This)->lpVtbl -> DoesEventPassFilter(This,dwQueueIndex,dwEventIndex,pFilter,pfDoesItPass)

#define IReadEvents_CompareEvents(This,dwQueueIndex,dwFirstEventIndex,dwSecondEventIndex,dwColumnNumber,plResult)	\
    (This)->lpVtbl -> CompareEvents(This,dwQueueIndex,dwFirstEventIndex,dwSecondEventIndex,dwColumnNumber,plResult)

#define IReadEvents_GetEvent(This,dwQueueIndex,dwEventIndex,ppEvent)	\
    (This)->lpVtbl -> GetEvent(This,dwQueueIndex,dwEventIndex,ppEvent)

#define IReadEvents_GetFullFormattedEvent(This,dwQueueIndex,dwEventIndex,pColumnFormatArray,ppColumnStringTable)	\
    (This)->lpVtbl -> GetFullFormattedEvent(This,dwQueueIndex,dwEventIndex,pColumnFormatArray,ppColumnStringTable)

#define IReadEvents_GetSparseFormattedEvent(This,dwQueueIndex,dwEventIndex,pColumnFormatArray,ppColumnStringTable)	\
    (This)->lpVtbl -> GetSparseFormattedEvent(This,dwQueueIndex,dwEventIndex,pColumnFormatArray,ppColumnStringTable)

#define IReadEvents_GetColumnIndex(This,dwQueueIndex,szColumnName,pdwColumnNumber)	\
    (This)->lpVtbl -> GetColumnIndex(This,dwQueueIndex,szColumnName,pdwColumnNumber)

#define IReadEvents_GetColumnName(This,dwQueueIndex,dwColumnNumber,ppColumnName)	\
    (This)->lpVtbl -> GetColumnName(This,dwQueueIndex,dwColumnNumber,ppColumnName)

#define IReadEvents_FlushEvents(This,dwQueueIndex,dwNumberOfEventsToDelete)	\
    (This)->lpVtbl -> FlushEvents(This,dwQueueIndex,dwNumberOfEventsToDelete)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IReadEvents_RegisterNotificationCallback_Proxy( 
    IReadEvents __RPC_FAR * This,
    /* [in] */ LPVOID pEventCallback,
    /* [in] */ LPVOID pInstanceData,
    /* [out] */ DWORD __RPC_FAR *pCallbackKey);


void __RPC_STUB IReadEvents_RegisterNotificationCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReadEvents_DeregisterNotificationCallback_Proxy( 
    IReadEvents __RPC_FAR * This,
    /* [in] */ DWORD CallbackKey);


void __RPC_STUB IReadEvents_DeregisterNotificationCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReadEvents_GetLatestQueueIndex_Proxy( 
    IReadEvents __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwQueueIndex);


void __RPC_STUB IReadEvents_GetLatestQueueIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReadEvents_GetQueueName_Proxy( 
    IReadEvents __RPC_FAR * This,
    /* [in] */ DWORD dwQueueIndex,
    /* [out] */ char __RPC_FAR *__RPC_FAR *ppColumnName);


void __RPC_STUB IReadEvents_GetQueueName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReadEvents_GetLatestEventIndex_Proxy( 
    IReadEvents __RPC_FAR * This,
    /* [in] */ DWORD dwQueueIndex,
    /* [out] */ DWORD __RPC_FAR *pdwEventIndex);


void __RPC_STUB IReadEvents_GetLatestEventIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReadEvents_DoesEventPassFilter_Proxy( 
    IReadEvents __RPC_FAR * This,
    /* [in] */ DWORD dwQueueIndex,
    /* [in] */ DWORD dwEventIndex,
    /* [in] */ PEVENTFILTER pFilter,
    /* [out] */ BOOL __RPC_FAR *pfDoesItPass);


void __RPC_STUB IReadEvents_DoesEventPassFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReadEvents_CompareEvents_Proxy( 
    IReadEvents __RPC_FAR * This,
    /* [in] */ DWORD dwQueueIndex,
    /* [in] */ DWORD dwFirstEventIndex,
    /* [in] */ DWORD dwSecondEventIndex,
    /* [in] */ DWORD dwColumnNumber,
    /* [out] */ long __RPC_FAR *plResult);


void __RPC_STUB IReadEvents_CompareEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReadEvents_GetEvent_Proxy( 
    IReadEvents __RPC_FAR * This,
    /* [in] */ DWORD dwQueueIndex,
    /* [in] */ DWORD dwEventIndex,
    /* [out] */ PNMEVENTDATA __RPC_FAR *ppEvent);


void __RPC_STUB IReadEvents_GetEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReadEvents_GetFullFormattedEvent_Proxy( 
    IReadEvents __RPC_FAR * This,
    /* [in] */ DWORD dwQueueIndex,
    /* [in] */ DWORD dwEventIndex,
    /* [in] */ PCOLUMNFORMATARRAY pColumnFormatArray,
    /* [out] */ PCOLUMNSTRINGTABLE __RPC_FAR *ppColumnStringTable);


void __RPC_STUB IReadEvents_GetFullFormattedEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReadEvents_GetSparseFormattedEvent_Proxy( 
    IReadEvents __RPC_FAR * This,
    /* [in] */ DWORD dwQueueIndex,
    /* [in] */ DWORD dwEventIndex,
    /* [in] */ PCOLUMNFORMATARRAY pColumnFormatArray,
    /* [out] */ PCOLUMNSTRINGTABLE __RPC_FAR *ppColumnStringTable);


void __RPC_STUB IReadEvents_GetSparseFormattedEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReadEvents_GetColumnIndex_Proxy( 
    IReadEvents __RPC_FAR * This,
    /* [in] */ DWORD dwQueueIndex,
    /* [in] */ char __RPC_FAR *szColumnName,
    /* [out] */ DWORD __RPC_FAR *pdwColumnNumber);


void __RPC_STUB IReadEvents_GetColumnIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReadEvents_GetColumnName_Proxy( 
    IReadEvents __RPC_FAR * This,
    /* [in] */ DWORD dwQueueIndex,
    /* [in] */ DWORD dwColumnNumber,
    /* [out] */ char __RPC_FAR *__RPC_FAR *ppColumnName);


void __RPC_STUB IReadEvents_GetColumnName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReadEvents_FlushEvents_Proxy( 
    IReadEvents __RPC_FAR * This,
    /* [in] */ DWORD dwQueueIndex,
    /* [in] */ DWORD dwNumberOfEventsToDelete);


void __RPC_STUB IReadEvents_FlushEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReadEvents_INTERFACE_DEFINED__ */



#ifndef __EventQLib_LIBRARY_DEFINED__
#define __EventQLib_LIBRARY_DEFINED__

/* library EventQLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_EventQLib;

EXTERN_C const CLSID CLSID_EVENTQUEUE;

#ifdef __cplusplus

class DECLSPEC_UUID("6E0FF466-339E-11d1-BE5B-00C04FC9E2BB")
EVENTQUEUE;
#endif
#endif /* __EventQLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ih26xcd.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Sat Jul 31 00:49:47 1999
 */
/* Compiler settings for ih26xcd.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ih26xcd_h__
#define __ih26xcd_h__

/* Forward Declarations */ 

#ifndef __IH26XVideoEffects_FWD_DEFINED__
#define __IH26XVideoEffects_FWD_DEFINED__
typedef interface IH26XVideoEffects IH26XVideoEffects;
#endif 	/* __IH26XVideoEffects_FWD_DEFINED__ */


#ifndef __IH26XEncodeOptions_FWD_DEFINED__
#define __IH26XEncodeOptions_FWD_DEFINED__
typedef interface IH26XEncodeOptions IH26XEncodeOptions;
#endif 	/* __IH26XEncodeOptions_FWD_DEFINED__ */


#ifndef __IH26XSnapshot_FWD_DEFINED__
#define __IH26XSnapshot_FWD_DEFINED__
typedef interface IH26XSnapshot IH26XSnapshot;
#endif 	/* __IH26XSnapshot_FWD_DEFINED__ */


#ifndef __IH26XEncoderControl_FWD_DEFINED__
#define __IH26XEncoderControl_FWD_DEFINED__
typedef interface IH26XEncoderControl IH26XEncoderControl;
#endif 	/* __IH26XEncoderControl_FWD_DEFINED__ */


#ifndef __IH26XRTPControl_FWD_DEFINED__
#define __IH26XRTPControl_FWD_DEFINED__
typedef interface IH26XRTPControl IH26XRTPControl;
#endif 	/* __IH26XRTPControl_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IH26XVideoEffects_INTERFACE_DEFINED__
#define __IH26XVideoEffects_INTERFACE_DEFINED__

/* interface IH26XVideoEffects */
/* [object][uuid] */ 

// STRUCTURES
typedef /* [public][public][public][public][public][public] */ 
enum __MIDL_IH26XVideoEffects_0001
    {	H26X_VE_UNDEFINED	= 0,
	H26X_VE_BRIGHTNESS	= H26X_VE_UNDEFINED + 1,
	H26X_VE_CONTRAST	= H26X_VE_BRIGHTNESS + 1,
	H26X_VE_SATURATION	= H26X_VE_CONTRAST + 1,
	H26X_VE_TINT	= H26X_VE_SATURATION + 1,
	H26X_VE_MIRROR	= H26X_VE_TINT + 1,
	H26X_VE_ASPECT_CORRECT	= H26X_VE_MIRROR + 1
    }	H26X_VIDEO_EFFECT;

typedef /* [public] */ struct __MIDL_IH26XVideoEffects_0002
    {
    int iBrightness;
    int iSaturation;
    int iContrast;
    int iMirror;
    int iAspectCorrect;
    }	VIDEO_EFFECT_VALUES;

typedef struct __MIDL_IH26XVideoEffects_0002 __RPC_FAR *PTR_VIDEO_EFFECT_VALUES;

// METHODS

EXTERN_C const IID IID_IH26XVideoEffects;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21555140-9C2B-11cf-90FA-00AA00A729EA")
    IH26XVideoEffects : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getFactoryDefault( 
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [out] */ int __RPC_FAR *pinDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getFactoryLimits( 
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [out] */ int __RPC_FAR *pinLower,
            /* [out] */ int __RPC_FAR *pinUpper) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCurrent( 
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [out] */ int __RPC_FAR *pinValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE setCurrent( 
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [in] */ int inValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetCurrent( 
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IH26XVideoEffectsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IH26XVideoEffects __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IH26XVideoEffects __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IH26XVideoEffects __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getFactoryDefault )( 
            IH26XVideoEffects __RPC_FAR * This,
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [out] */ int __RPC_FAR *pinDefault);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getFactoryLimits )( 
            IH26XVideoEffects __RPC_FAR * This,
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [out] */ int __RPC_FAR *pinLower,
            /* [out] */ int __RPC_FAR *pinUpper);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getCurrent )( 
            IH26XVideoEffects __RPC_FAR * This,
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [out] */ int __RPC_FAR *pinValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setCurrent )( 
            IH26XVideoEffects __RPC_FAR * This,
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
            /* [in] */ int inValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *resetCurrent )( 
            IH26XVideoEffects __RPC_FAR * This,
            /* [in] */ H26X_VIDEO_EFFECT veVideoEffect);
        
        END_INTERFACE
    } IH26XVideoEffectsVtbl;

    interface IH26XVideoEffects
    {
        CONST_VTBL struct IH26XVideoEffectsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IH26XVideoEffects_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IH26XVideoEffects_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IH26XVideoEffects_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IH26XVideoEffects_getFactoryDefault(This,veVideoEffect,pinDefault)	\
    (This)->lpVtbl -> getFactoryDefault(This,veVideoEffect,pinDefault)

#define IH26XVideoEffects_getFactoryLimits(This,veVideoEffect,pinLower,pinUpper)	\
    (This)->lpVtbl -> getFactoryLimits(This,veVideoEffect,pinLower,pinUpper)

#define IH26XVideoEffects_getCurrent(This,veVideoEffect,pinValue)	\
    (This)->lpVtbl -> getCurrent(This,veVideoEffect,pinValue)

#define IH26XVideoEffects_setCurrent(This,veVideoEffect,inValue)	\
    (This)->lpVtbl -> setCurrent(This,veVideoEffect,inValue)

#define IH26XVideoEffects_resetCurrent(This,veVideoEffect)	\
    (This)->lpVtbl -> resetCurrent(This,veVideoEffect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IH26XVideoEffects_getFactoryDefault_Proxy( 
    IH26XVideoEffects __RPC_FAR * This,
    /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
    /* [out] */ int __RPC_FAR *pinDefault);


void __RPC_STUB IH26XVideoEffects_getFactoryDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XVideoEffects_getFactoryLimits_Proxy( 
    IH26XVideoEffects __RPC_FAR * This,
    /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
    /* [out] */ int __RPC_FAR *pinLower,
    /* [out] */ int __RPC_FAR *pinUpper);


void __RPC_STUB IH26XVideoEffects_getFactoryLimits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XVideoEffects_getCurrent_Proxy( 
    IH26XVideoEffects __RPC_FAR * This,
    /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
    /* [out] */ int __RPC_FAR *pinValue);


void __RPC_STUB IH26XVideoEffects_getCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XVideoEffects_setCurrent_Proxy( 
    IH26XVideoEffects __RPC_FAR * This,
    /* [in] */ H26X_VIDEO_EFFECT veVideoEffect,
    /* [in] */ int inValue);


void __RPC_STUB IH26XVideoEffects_setCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XVideoEffects_resetCurrent_Proxy( 
    IH26XVideoEffects __RPC_FAR * This,
    /* [in] */ H26X_VIDEO_EFFECT veVideoEffect);


void __RPC_STUB IH26XVideoEffects_resetCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IH26XVideoEffects_INTERFACE_DEFINED__ */


#ifndef __IH26XEncodeOptions_INTERFACE_DEFINED__
#define __IH26XEncodeOptions_INTERFACE_DEFINED__

/* interface IH26XEncodeOptions */
/* [object][uuid] */ 

// STRUCTURES
typedef /* [public] */ struct __MIDL_IH26XEncodeOptions_0001
    {
    int bExtendedMV;
    int bPBFrames;
    int bAdvPrediction;
    }	ENCODE_OPTIONS_VALUES;

typedef struct __MIDL_IH26XEncodeOptions_0001 __RPC_FAR *PTR_ENCODE_OPTIONS_VALUES;

// METHODS

EXTERN_C const IID IID_IH26XEncodeOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65698D40-282D-11d0-8800-444553540000")
    IH26XEncodeOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_EncodeOptions( 
            /* [out] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_EncodeOptionsDefault( 
            /* [out] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE set_EncodeOptions( 
            /* [in] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IH26XEncodeOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IH26XEncodeOptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IH26XEncodeOptions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IH26XEncodeOptions __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EncodeOptions )( 
            IH26XEncodeOptions __RPC_FAR * This,
            /* [out] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EncodeOptionsDefault )( 
            IH26XEncodeOptions __RPC_FAR * This,
            /* [out] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *set_EncodeOptions )( 
            IH26XEncodeOptions __RPC_FAR * This,
            /* [in] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues);
        
        END_INTERFACE
    } IH26XEncodeOptionsVtbl;

    interface IH26XEncodeOptions
    {
        CONST_VTBL struct IH26XEncodeOptionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IH26XEncodeOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IH26XEncodeOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IH26XEncodeOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IH26XEncodeOptions_get_EncodeOptions(This,pOptionValues)	\
    (This)->lpVtbl -> get_EncodeOptions(This,pOptionValues)

#define IH26XEncodeOptions_get_EncodeOptionsDefault(This,pOptionValues)	\
    (This)->lpVtbl -> get_EncodeOptionsDefault(This,pOptionValues)

#define IH26XEncodeOptions_set_EncodeOptions(This,pOptionValues)	\
    (This)->lpVtbl -> set_EncodeOptions(This,pOptionValues)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IH26XEncodeOptions_get_EncodeOptions_Proxy( 
    IH26XEncodeOptions __RPC_FAR * This,
    /* [out] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues);


void __RPC_STUB IH26XEncodeOptions_get_EncodeOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XEncodeOptions_get_EncodeOptionsDefault_Proxy( 
    IH26XEncodeOptions __RPC_FAR * This,
    /* [out] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues);


void __RPC_STUB IH26XEncodeOptions_get_EncodeOptionsDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XEncodeOptions_set_EncodeOptions_Proxy( 
    IH26XEncodeOptions __RPC_FAR * This,
    /* [in] */ PTR_ENCODE_OPTIONS_VALUES pOptionValues);


void __RPC_STUB IH26XEncodeOptions_set_EncodeOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IH26XEncodeOptions_INTERFACE_DEFINED__ */


#ifndef __IH26XSnapshot_INTERFACE_DEFINED__
#define __IH26XSnapshot_INTERFACE_DEFINED__

/* interface IH26XSnapshot */
/* [object][uuid] */ 

#ifndef _WINGDI_
// STRUCTURES
typedef struct __MIDL_IH26XSnapshot_0001
    {
    DWORD biSize;
    LONG biWidth;
    LONG biHeight;
    WORD biPlanes;
    WORD biBitCount;
    DWORD biCompression;
    DWORD biSizeImage;
    LONG biXPelsPerMeter;
    LONG biYPelsPerMeter;
    DWORD biClrUsed;
    DWORD biClrImportant;
    }	__RPC_FAR *LPBITMAPINFOHEADER;

#endif
// METHODS

EXTERN_C const IID IID_IH26XSnapshot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3CB194A0-10AA-11d0-8800-444553540000")
    IH26XSnapshot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getBitmapInfoHeader( 
            /* [out] */ LPBITMAPINFOHEADER lpBmi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getSnapshot( 
            /* [in] */ LPBITMAPINFOHEADER lpBmi,
            /* [out] */ unsigned char __RPC_FAR *pvBuffer,
            /* [in] */ DWORD dwTimeout) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IH26XSnapshotVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IH26XSnapshot __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IH26XSnapshot __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IH26XSnapshot __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getBitmapInfoHeader )( 
            IH26XSnapshot __RPC_FAR * This,
            /* [out] */ LPBITMAPINFOHEADER lpBmi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getSnapshot )( 
            IH26XSnapshot __RPC_FAR * This,
            /* [in] */ LPBITMAPINFOHEADER lpBmi,
            /* [out] */ unsigned char __RPC_FAR *pvBuffer,
            /* [in] */ DWORD dwTimeout);
        
        END_INTERFACE
    } IH26XSnapshotVtbl;

    interface IH26XSnapshot
    {
        CONST_VTBL struct IH26XSnapshotVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IH26XSnapshot_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IH26XSnapshot_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IH26XSnapshot_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IH26XSnapshot_getBitmapInfoHeader(This,lpBmi)	\
    (This)->lpVtbl -> getBitmapInfoHeader(This,lpBmi)

#define IH26XSnapshot_getSnapshot(This,lpBmi,pvBuffer,dwTimeout)	\
    (This)->lpVtbl -> getSnapshot(This,lpBmi,pvBuffer,dwTimeout)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IH26XSnapshot_getBitmapInfoHeader_Proxy( 
    IH26XSnapshot __RPC_FAR * This,
    /* [out] */ LPBITMAPINFOHEADER lpBmi);


void __RPC_STUB IH26XSnapshot_getBitmapInfoHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XSnapshot_getSnapshot_Proxy( 
    IH26XSnapshot __RPC_FAR * This,
    /* [in] */ LPBITMAPINFOHEADER lpBmi,
    /* [out] */ unsigned char __RPC_FAR *pvBuffer,
    /* [in] */ DWORD dwTimeout);


void __RPC_STUB IH26XSnapshot_getSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IH26XSnapshot_INTERFACE_DEFINED__ */


#ifndef __IH26XEncoderControl_INTERFACE_DEFINED__
#define __IH26XEncoderControl_INTERFACE_DEFINED__

/* interface IH26XEncoderControl */
/* [object][uuid] */ 

// STRUCTURES
typedef /* [public] */ struct __MIDL_IH26XEncoderControl_0001
    {
    DWORD dwTargetFrameSize;
    BOOL bFrameSizeBRC;
    BOOL bSendKey;
    DWORD dwQuality;
    DWORD dwFrameRate;
    DWORD dwDataRate;
    DWORD dwScale;
    DWORD dwWidth;
    DWORD dwKeyFrameInterval;
    DWORD dwKeyFramePeriod;
    }	ENC_CMP_DATA;

typedef struct __MIDL_IH26XEncoderControl_0001 __RPC_FAR *PTR_ENC_CMP_DATA;

// METHODS

EXTERN_C const IID IID_IH26XEncoderControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F9B78AA1-EA12-11cf-9FEC-00AA00A59F69")
    IH26XEncoderControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_EncodeCompression( 
            /* [out] */ PTR_ENC_CMP_DATA pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_EncodeCompressionDefault( 
            /* [out] */ PTR_ENC_CMP_DATA pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE set_EncodeCompression( 
            /* [in] */ PTR_ENC_CMP_DATA pData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IH26XEncoderControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IH26XEncoderControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IH26XEncoderControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IH26XEncoderControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EncodeCompression )( 
            IH26XEncoderControl __RPC_FAR * This,
            /* [out] */ PTR_ENC_CMP_DATA pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EncodeCompressionDefault )( 
            IH26XEncoderControl __RPC_FAR * This,
            /* [out] */ PTR_ENC_CMP_DATA pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *set_EncodeCompression )( 
            IH26XEncoderControl __RPC_FAR * This,
            /* [in] */ PTR_ENC_CMP_DATA pData);
        
        END_INTERFACE
    } IH26XEncoderControlVtbl;

    interface IH26XEncoderControl
    {
        CONST_VTBL struct IH26XEncoderControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IH26XEncoderControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IH26XEncoderControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IH26XEncoderControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IH26XEncoderControl_get_EncodeCompression(This,pData)	\
    (This)->lpVtbl -> get_EncodeCompression(This,pData)

#define IH26XEncoderControl_get_EncodeCompressionDefault(This,pData)	\
    (This)->lpVtbl -> get_EncodeCompressionDefault(This,pData)

#define IH26XEncoderControl_set_EncodeCompression(This,pData)	\
    (This)->lpVtbl -> set_EncodeCompression(This,pData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IH26XEncoderControl_get_EncodeCompression_Proxy( 
    IH26XEncoderControl __RPC_FAR * This,
    /* [out] */ PTR_ENC_CMP_DATA pData);


void __RPC_STUB IH26XEncoderControl_get_EncodeCompression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XEncoderControl_get_EncodeCompressionDefault_Proxy( 
    IH26XEncoderControl __RPC_FAR * This,
    /* [out] */ PTR_ENC_CMP_DATA pData);


void __RPC_STUB IH26XEncoderControl_get_EncodeCompressionDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XEncoderControl_set_EncodeCompression_Proxy( 
    IH26XEncoderControl __RPC_FAR * This,
    /* [in] */ PTR_ENC_CMP_DATA pData);


void __RPC_STUB IH26XEncoderControl_set_EncodeCompression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IH26XEncoderControl_INTERFACE_DEFINED__ */


#ifndef __IH26XRTPControl_INTERFACE_DEFINED__
#define __IH26XRTPControl_INTERFACE_DEFINED__

/* interface IH26XRTPControl */
/* [object][uuid] */ 

// STRUCTURES
typedef /* [public] */ struct __MIDL_IH26XRTPControl_0001
    {
    BOOL bRTPHeader;
    DWORD dwPacketSize;
    DWORD dwPacketLoss;
    }	ENC_RTP_DATA;

typedef struct __MIDL_IH26XRTPControl_0001 __RPC_FAR *PTR_ENC_RTP_DATA;

// METHODS

EXTERN_C const IID IID_IH26XRTPControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1FC3F2C0-2BFD-11d0-8800-444553540000")
    IH26XRTPControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_RTPCompression( 
            /* [out] */ PTR_ENC_RTP_DATA pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_RTPCompressionDefault( 
            /* [out] */ PTR_ENC_RTP_DATA pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE set_RTPCompression( 
            /* [in] */ PTR_ENC_RTP_DATA pData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IH26XRTPControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IH26XRTPControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IH26XRTPControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IH26XRTPControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RTPCompression )( 
            IH26XRTPControl __RPC_FAR * This,
            /* [out] */ PTR_ENC_RTP_DATA pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RTPCompressionDefault )( 
            IH26XRTPControl __RPC_FAR * This,
            /* [out] */ PTR_ENC_RTP_DATA pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *set_RTPCompression )( 
            IH26XRTPControl __RPC_FAR * This,
            /* [in] */ PTR_ENC_RTP_DATA pData);
        
        END_INTERFACE
    } IH26XRTPControlVtbl;

    interface IH26XRTPControl
    {
        CONST_VTBL struct IH26XRTPControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IH26XRTPControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IH26XRTPControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IH26XRTPControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IH26XRTPControl_get_RTPCompression(This,pData)	\
    (This)->lpVtbl -> get_RTPCompression(This,pData)

#define IH26XRTPControl_get_RTPCompressionDefault(This,pData)	\
    (This)->lpVtbl -> get_RTPCompressionDefault(This,pData)

#define IH26XRTPControl_set_RTPCompression(This,pData)	\
    (This)->lpVtbl -> set_RTPCompression(This,pData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IH26XRTPControl_get_RTPCompression_Proxy( 
    IH26XRTPControl __RPC_FAR * This,
    /* [out] */ PTR_ENC_RTP_DATA pData);


void __RPC_STUB IH26XRTPControl_get_RTPCompression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XRTPControl_get_RTPCompressionDefault_Proxy( 
    IH26XRTPControl __RPC_FAR * This,
    /* [out] */ PTR_ENC_RTP_DATA pData);


void __RPC_STUB IH26XRTPControl_get_RTPCompressionDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IH26XRTPControl_set_RTPCompression_Proxy( 
    IH26XRTPControl __RPC_FAR * This,
    /* [in] */ PTR_ENC_RTP_DATA pData);


void __RPC_STUB IH26XRTPControl_set_RTPCompression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IH26XRTPControl_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\iimgctx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1996-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: iimgctx.h
//
//--------------------------------------------------------------------------

#ifndef _IImgCtxObjects_H_
#define _IImgCtxObjects_H_

#ifdef __cplusplus
extern "C" {
#endif
typedef void (CALLBACK *PFNIMGCTXCALLBACK)(void *, void *);
#ifdef __cplusplus
}
#endif

#define IMGCHG_SIZE         0x0001
#define IMGCHG_VIEW         0x0002
#define IMGCHG_COMPLETE     0x0004
#define IMGCHG_ANIMATE      0x0008
#define IMGCHG_MASK         0x000F

#define IMGLOAD_NOTLOADED   0x00100000  // Image has not yet been loaded
#define IMGLOAD_LOADING     0x00200000  // Image in the process of being loaded
#define IMGLOAD_STOPPED     0x00400000  // Imaged aborted
#define IMGLOAD_ERROR       0x00800000  // Error loading image
#define IMGLOAD_COMPLETE    0x01000000  // Image loaded
#define IMGLOAD_MASK        0x01F00000

#define IMGBITS_NONE        0x02000000
#define IMGBITS_PARTIAL     0x04000000
#define IMGBITS_TOTAL       0x08000000
#define IMGBITS_MASK        0x0E000000

#define IMGANIM_ANIMATED    0x10000000
#define IMGANIM_MASK        0x10000000

#define IMGTRANS_OPAQUE     0x20000000
#define IMGTRANS_MASK       0x20000000

#define DWN_COLORMODE       0x0000003F  // Explicit color mode requested
#define DWN_DOWNLOADONLY    0x00000040  // Download data only, don't decode
#define DWN_FORCEDITHER     0x00000080  // Override automatic dithering
#define DWN_RAWIMAGE        0x00000100  // Disable dithering
#define DWN_MIRRORIMAGE     0x00000200  // Mirror the image

/* Definition of interface: IImgCtx */
#undef INTERFACE
#define INTERFACE IImgCtx

// {3050f3d7-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(IID_IImgCtx, 0x3050f3d7, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

DECLARE_INTERFACE_(IImgCtx, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IImgCtx methods */

    /* Initialization/Download methods */
    STDMETHOD(Load)(THIS_ LPCWSTR pszUrl, DWORD dwFlags) PURE;
    STDMETHOD(SelectChanges)(THIS_ ULONG ulChgOn, ULONG ulChgOff, BOOL fSignal) PURE;
    STDMETHOD(SetCallback)(THIS_ PFNIMGCTXCALLBACK pfn, void * pvPrivateData) PURE;
    STDMETHOD(Disconnect)(THIS) PURE;

        /* Query methods */
    STDMETHOD(GetUpdateRects)(THIS_ struct tagRECT FAR* prc, struct tagRECT FAR* prcImg, long FAR* pcrc) PURE;
    STDMETHOD(GetStateInfo)(THIS_ ULONG FAR* pulState, struct tagSIZE FAR* psize, BOOL fClearChanges) PURE;
    STDMETHOD(GetPalette)(THIS_ HPALETTE FAR* phpal) PURE;

    /* Rendering methods */
    STDMETHOD(Draw)(THIS_ HDC hdc, struct tagRECT FAR* prcBounds) PURE;
    STDMETHOD(Tile)(THIS_ HDC hdc, struct tagPOINT FAR* pptBackOrg, struct tagRECT FAR* prcClip, struct tagSIZE FAR* psize) PURE;
    STDMETHOD(StretchBlt)(THIS_ HDC hdc, int dstX, int dstY, int dstXE, int dstYE, int srcX, int srcY, int srcXE, int srcYE, DWORD dwROP) PURE;
};

#ifdef COBJMACROS


#define IImgCtx_QueryInterface(This,riid,ppvObject)     \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImgCtx_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IImgCtx_Release(This)   \
    (This)->lpVtbl -> Release(This)

#define IImgCtx_Load(This, pszUrl, dwFlags)     \
        (This)->lpVtbl -> Load(This, pszUrl, dwFlags)

#define IImgCtx_Draw(This, hdc, prcBounds)              \
        (This)->lpVtbl -> Draw(This, hdc, prcBounds)

#define IImgCtx_Tile(This, hdc, pptBackOrg, prcClip, psize)             \
        (This)->lpVtbl -> Tile(This, hdc, pptBackOrg, prcClip, psize)

#define IImgCtx_GetUpdateRects(This, prc, prcImg, pcrc) \
        (This)->lpVtbl -> GetUpdateRects(This, prc, prcImg, pcrc)

#define IImgCtx_GetStateInfo(This, pulState, psize, fClearChanges)      \
        (This)->lpVtbl -> GetStateInfo(This, pulState, psize, fClearChanges)

#define IImgCtx_GetPalette(This, phpal) \
        (This)->lpVtbl -> GetPalette(This, phpal)
        
#define IImgCtx_SelectChanges(This, ulChgOn, ulChgOff, fSignal) \
        (This)->lpVtbl -> SelectChanges(This, ulChgOn, ulChgOff, fSignal)

#define IImgCtx_SetCallback(This, pfnCallback, pvPrivateData)   \
        (This)->lpVtbl -> SetCallback(This, pfnCallback, pvPrivateData)

#define IImgCtx_Disconnect(This) \
    (This)->lpVtbl -> Disconnect(This)

#define IImgCtx_StretchBlt(This, hdc, dstX, dstY, dstXE, dstYE, srcX, srcY, srcXE, srcYE, dwROP)   \
    (This)->lpVtbl -> StretchBlt(This, hdc, dstX, dstY, dstXE, dstYE, srcX, srcY, srcXE, srcYE, dwROP)

#endif /* COBJMACROS */


// {3050f3d6-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(CLSID_IImgCtx, 0x3050f3d6, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\iesp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Mon Sep 20 16:32:17 1999
 */
/* Compiler settings for iesp.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iesp_h__
#define __iesp_h__

/* Forward Declarations */ 

#ifndef __IESP_FWD_DEFINED__
#define __IESP_FWD_DEFINED__
typedef interface IESP IESP;
#endif 	/* __IESP_FWD_DEFINED__ */


/* header files for imported files */
#include "NPPTypes.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IESP_INTERFACE_DEFINED__
#define __IESP_INTERFACE_DEFINED__

/* interface IESP */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IESP;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E99A04AA-AB95-11d0-BE96-00A0C94989DE")
    IESP : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ NETWORKSTATUS __RPC_FAR *pNetworkStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [out][string] */ char __RPC_FAR *pFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            /* [out] */ LPSTATISTICS lpStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [out] */ LPSTATISTICS lpStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [out] */ BOOL __RPC_FAR *IsRunnning,
            /* [out] */ BOOL __RPC_FAR *IsPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStations( 
            /* [out][in] */ QUERYTABLE __RPC_FAR *lpQueryTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IESPVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IESP __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IESP __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IESP __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IESP __RPC_FAR * This,
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IESP __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryStatus )( 
            IESP __RPC_FAR * This,
            /* [out] */ NETWORKSTATUS __RPC_FAR *pNetworkStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IESP __RPC_FAR * This,
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IESP __RPC_FAR * This,
            /* [out][string] */ char __RPC_FAR *pFileName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IESP __RPC_FAR * This,
            /* [out] */ LPSTATISTICS lpStats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IESP __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IESP __RPC_FAR * This,
            /* [out] */ LPSTATISTICS lpStats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetControlState )( 
            IESP __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *IsRunnning,
            /* [out] */ BOOL __RPC_FAR *IsPaused);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryStations )( 
            IESP __RPC_FAR * This,
            /* [out][in] */ QUERYTABLE __RPC_FAR *lpQueryTable);
        
        END_INTERFACE
    } IESPVtbl;

    interface IESP
    {
        CONST_VTBL struct IESPVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IESP_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IESP_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IESP_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IESP_Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob)	\
    (This)->lpVtbl -> Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob)

#define IESP_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IESP_QueryStatus(This,pNetworkStatus)	\
    (This)->lpVtbl -> QueryStatus(This,pNetworkStatus)

#define IESP_Configure(This,hConfigurationBlob,hErrorBlob)	\
    (This)->lpVtbl -> Configure(This,hConfigurationBlob,hErrorBlob)

#define IESP_Start(This,pFileName)	\
    (This)->lpVtbl -> Start(This,pFileName)

#define IESP_Pause(This,lpStats)	\
    (This)->lpVtbl -> Pause(This,lpStats)

#define IESP_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IESP_Stop(This,lpStats)	\
    (This)->lpVtbl -> Stop(This,lpStats)

#define IESP_GetControlState(This,IsRunnning,IsPaused)	\
    (This)->lpVtbl -> GetControlState(This,IsRunnning,IsPaused)

#define IESP_QueryStations(This,lpQueryTable)	\
    (This)->lpVtbl -> QueryStations(This,lpQueryTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IESP_Connect_Proxy( 
    IESP __RPC_FAR * This,
    /* [in] */ HBLOB hInputBlob,
    /* [in] */ LPVOID StatusCallbackProc,
    /* [in] */ LPVOID UserContext,
    /* [out] */ HBLOB hErrorBlob);


void __RPC_STUB IESP_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_Disconnect_Proxy( 
    IESP __RPC_FAR * This);


void __RPC_STUB IESP_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_QueryStatus_Proxy( 
    IESP __RPC_FAR * This,
    /* [out] */ NETWORKSTATUS __RPC_FAR *pNetworkStatus);


void __RPC_STUB IESP_QueryStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_Configure_Proxy( 
    IESP __RPC_FAR * This,
    /* [in] */ HBLOB hConfigurationBlob,
    /* [out] */ HBLOB hErrorBlob);


void __RPC_STUB IESP_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_Start_Proxy( 
    IESP __RPC_FAR * This,
    /* [out][string] */ char __RPC_FAR *pFileName);


void __RPC_STUB IESP_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_Pause_Proxy( 
    IESP __RPC_FAR * This,
    /* [out] */ LPSTATISTICS lpStats);


void __RPC_STUB IESP_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_Resume_Proxy( 
    IESP __RPC_FAR * This);


void __RPC_STUB IESP_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_Stop_Proxy( 
    IESP __RPC_FAR * This,
    /* [out] */ LPSTATISTICS lpStats);


void __RPC_STUB IESP_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_GetControlState_Proxy( 
    IESP __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *IsRunnning,
    /* [out] */ BOOL __RPC_FAR *IsPaused);


void __RPC_STUB IESP_GetControlState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IESP_QueryStations_Proxy( 
    IESP __RPC_FAR * This,
    /* [out][in] */ QUERYTABLE __RPC_FAR *lpQueryTable);


void __RPC_STUB IESP_QueryStations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IESP_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\IEDial.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for iedial.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iedial_h__
#define __iedial_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDialEventSink_FWD_DEFINED__
#define __IDialEventSink_FWD_DEFINED__
typedef interface IDialEventSink IDialEventSink;
#endif 	/* __IDialEventSink_FWD_DEFINED__ */


#ifndef __IDialEngine_FWD_DEFINED__
#define __IDialEngine_FWD_DEFINED__
typedef interface IDialEngine IDialEngine;
#endif 	/* __IDialEngine_FWD_DEFINED__ */


#ifndef __IDialBranding_FWD_DEFINED__
#define __IDialBranding_FWD_DEFINED__
typedef interface IDialBranding IDialBranding;
#endif 	/* __IDialBranding_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_iedial_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// iedial.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Channel Manager Interfaces.



extern RPC_IF_HANDLE __MIDL_itf_iedial_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iedial_0000_v0_0_s_ifspec;

#ifndef __IDialEventSink_INTERFACE_DEFINED__
#define __IDialEventSink_INTERFACE_DEFINED__

/* interface IDialEventSink */
/* [object][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IDialEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2d86f4ff-6e2d-4488-b2e9-6934afd41bea")
    IDialEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnEvent( 
            /* [in] */ DWORD dwEvent,
            /* [in] */ DWORD dwStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDialEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDialEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDialEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDialEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEvent )( 
            IDialEventSink * This,
            /* [in] */ DWORD dwEvent,
            /* [in] */ DWORD dwStatus);
        
        END_INTERFACE
    } IDialEventSinkVtbl;

    interface IDialEventSink
    {
        CONST_VTBL struct IDialEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDialEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDialEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDialEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDialEventSink_OnEvent(This,dwEvent,dwStatus)	\
    (This)->lpVtbl -> OnEvent(This,dwEvent,dwStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDialEventSink_OnEvent_Proxy( 
    IDialEventSink * This,
    /* [in] */ DWORD dwEvent,
    /* [in] */ DWORD dwStatus);


void __RPC_STUB IDialEventSink_OnEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDialEventSink_INTERFACE_DEFINED__ */


#ifndef __IDialEngine_INTERFACE_DEFINED__
#define __IDialEngine_INTERFACE_DEFINED__

/* interface IDialEngine */
/* [object][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IDialEngine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("39fd782b-7905-40d5-9148-3c9b190423d5")
    IDialEngine : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCWSTR pwzConnectoid,
            /* [in] */ IDialEventSink *pIDES) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ LPCWSTR pwzProperty,
            /* [in] */ LPWSTR pwzValue,
            /* [in] */ DWORD dwBufSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ LPCWSTR pwzProperty,
            /* [in] */ LPCWSTR pwzValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Dial( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HangUp( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectedState( 
            /* [out] */ DWORD *pdwState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectHandle( 
            /* [out] */ DWORD_PTR *pdwHandle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDialEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDialEngine * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDialEngine * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDialEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDialEngine * This,
            /* [in] */ LPCWSTR pwzConnectoid,
            /* [in] */ IDialEventSink *pIDES);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IDialEngine * This,
            /* [in] */ LPCWSTR pwzProperty,
            /* [in] */ LPWSTR pwzValue,
            /* [in] */ DWORD dwBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IDialEngine * This,
            /* [in] */ LPCWSTR pwzProperty,
            /* [in] */ LPCWSTR pwzValue);
        
        HRESULT ( STDMETHODCALLTYPE *Dial )( 
            IDialEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *HangUp )( 
            IDialEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectedState )( 
            IDialEngine * This,
            /* [out] */ DWORD *pdwState);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectHandle )( 
            IDialEngine * This,
            /* [out] */ DWORD_PTR *pdwHandle);
        
        END_INTERFACE
    } IDialEngineVtbl;

    interface IDialEngine
    {
        CONST_VTBL struct IDialEngineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDialEngine_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDialEngine_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDialEngine_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDialEngine_Initialize(This,pwzConnectoid,pIDES)	\
    (This)->lpVtbl -> Initialize(This,pwzConnectoid,pIDES)

#define IDialEngine_GetProperty(This,pwzProperty,pwzValue,dwBufSize)	\
    (This)->lpVtbl -> GetProperty(This,pwzProperty,pwzValue,dwBufSize)

#define IDialEngine_SetProperty(This,pwzProperty,pwzValue)	\
    (This)->lpVtbl -> SetProperty(This,pwzProperty,pwzValue)

#define IDialEngine_Dial(This)	\
    (This)->lpVtbl -> Dial(This)

#define IDialEngine_HangUp(This)	\
    (This)->lpVtbl -> HangUp(This)

#define IDialEngine_GetConnectedState(This,pdwState)	\
    (This)->lpVtbl -> GetConnectedState(This,pdwState)

#define IDialEngine_GetConnectHandle(This,pdwHandle)	\
    (This)->lpVtbl -> GetConnectHandle(This,pdwHandle)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDialEngine_Initialize_Proxy( 
    IDialEngine * This,
    /* [in] */ LPCWSTR pwzConnectoid,
    /* [in] */ IDialEventSink *pIDES);


void __RPC_STUB IDialEngine_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDialEngine_GetProperty_Proxy( 
    IDialEngine * This,
    /* [in] */ LPCWSTR pwzProperty,
    /* [in] */ LPWSTR pwzValue,
    /* [in] */ DWORD dwBufSize);


void __RPC_STUB IDialEngine_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDialEngine_SetProperty_Proxy( 
    IDialEngine * This,
    /* [in] */ LPCWSTR pwzProperty,
    /* [in] */ LPCWSTR pwzValue);


void __RPC_STUB IDialEngine_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDialEngine_Dial_Proxy( 
    IDialEngine * This);


void __RPC_STUB IDialEngine_Dial_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDialEngine_HangUp_Proxy( 
    IDialEngine * This);


void __RPC_STUB IDialEngine_HangUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDialEngine_GetConnectedState_Proxy( 
    IDialEngine * This,
    /* [out] */ DWORD *pdwState);


void __RPC_STUB IDialEngine_GetConnectedState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDialEngine_GetConnectHandle_Proxy( 
    IDialEngine * This,
    /* [out] */ DWORD_PTR *pdwHandle);


void __RPC_STUB IDialEngine_GetConnectHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDialEngine_INTERFACE_DEFINED__ */


#ifndef __IDialBranding_INTERFACE_DEFINED__
#define __IDialBranding_INTERFACE_DEFINED__

/* interface IDialBranding */
/* [object][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IDialBranding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8aecafa9-4306-43cc-8c5a-765f2979cc16")
    IDialBranding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCWSTR pwzConnectoid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBitmap( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ HBITMAP *phBitmap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDialBrandingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDialBranding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDialBranding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDialBranding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDialBranding * This,
            /* [in] */ LPCWSTR pwzConnectoid);
        
        HRESULT ( STDMETHODCALLTYPE *GetBitmap )( 
            IDialBranding * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ HBITMAP *phBitmap);
        
        END_INTERFACE
    } IDialBrandingVtbl;

    interface IDialBranding
    {
        CONST_VTBL struct IDialBrandingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDialBranding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDialBranding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDialBranding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDialBranding_Initialize(This,pwzConnectoid)	\
    (This)->lpVtbl -> Initialize(This,pwzConnectoid)

#define IDialBranding_GetBitmap(This,dwIndex,phBitmap)	\
    (This)->lpVtbl -> GetBitmap(This,dwIndex,phBitmap)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDialBranding_Initialize_Proxy( 
    IDialBranding * This,
    /* [in] */ LPCWSTR pwzConnectoid);


void __RPC_STUB IDialBranding_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDialBranding_GetBitmap_Proxy( 
    IDialBranding * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ HBITMAP *phBitmap);


void __RPC_STUB IDialBranding_GetBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDialBranding_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_iedial_0250 */
/* [local] */ 

#define DIALPROP_USERNAME       L"UserName"        
#define DIALPROP_PASSWORD       L"Password"        
#define DIALPROP_DOMAIN         L"Domain"          
#define DIALPROP_SAVEPASSWORD   L"SavePassword"    
#define DIALPROP_REDIALCOUNT    L"RedialCount"     
#define DIALPROP_REDIALINTERVAL L"RedialInterval"  
#define DIALPROP_PHONENUMBER    L"PhoneNumber"     
#define DIALPROP_LASTERROR      L"LastError"       
#define DIALPROP_RESOLVEDPHONE  L"ResolvedPhone"   

#define DIALENG_OperationComplete   0x10000          
#define DIALENG_RedialAttempt       0x10001          
#define DIALENG_RedialWait          0x10002          


extern RPC_IF_HANDLE __MIDL_itf_iedial_0250_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iedial_0250_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HBITMAP_UserSize(     unsigned long *, unsigned long            , HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserMarshal(  unsigned long *, unsigned char *, HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserUnmarshal(unsigned long *, unsigned char *, HBITMAP * ); 
void                      __RPC_USER  HBITMAP_UserFree(     unsigned long *, HBITMAP * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\IdxAdminSdk.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Wed Apr 22 20:00:57 1998
 */
/* Compiler settings for idxadminsdk.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __idxadminsdk_h__
#define __idxadminsdk_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IIndexDs_FWD_DEFINED__
#define __IIndexDs_FWD_DEFINED__
typedef interface IIndexDs IIndexDs;
#endif 	/* __IIndexDs_FWD_DEFINED__ */


#ifndef __ICatalogSearchServerList_FWD_DEFINED__
#define __ICatalogSearchServerList_FWD_DEFINED__
typedef interface ICatalogSearchServerList ICatalogSearchServerList;
#endif 	/* __ICatalogSearchServerList_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IIndexDs_INTERFACE_DEFINED__
#define __IIndexDs_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IIndexDs
 * at Wed Apr 22 20:00:57 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][public][object] */ 



EXTERN_C const IID IID_IIndexDs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("798e43e0-c659-11d0-8f55-00c04fb67f46")
    IIndexDs : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PropDestination( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDestination) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PropDestination( 
            /* [in] */ BSTR bstrDestination) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIndexDsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IIndexDs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IIndexDs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IIndexDs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IIndexDs __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IIndexDs __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IIndexDs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IIndexDs __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IIndexDs __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PropDestination )( 
            IIndexDs __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDestination);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PropDestination )( 
            IIndexDs __RPC_FAR * This,
            /* [in] */ BSTR bstrDestination);
        
        END_INTERFACE
    } IIndexDsVtbl;

    interface IIndexDs
    {
        CONST_VTBL struct IIndexDsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIndexDs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIndexDs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIndexDs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIndexDs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IIndexDs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IIndexDs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IIndexDs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IIndexDs_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define IIndexDs_get_PropDestination(This,pbstrDestination)	\
    (This)->lpVtbl -> get_PropDestination(This,pbstrDestination)

#define IIndexDs_put_PropDestination(This,bstrDestination)	\
    (This)->lpVtbl -> put_PropDestination(This,bstrDestination)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IIndexDs_get_Name_Proxy( 
    IIndexDs __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IIndexDs_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IIndexDs_get_PropDestination_Proxy( 
    IIndexDs __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDestination);


void __RPC_STUB IIndexDs_get_PropDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IIndexDs_put_PropDestination_Proxy( 
    IIndexDs __RPC_FAR * This,
    /* [in] */ BSTR bstrDestination);


void __RPC_STUB IIndexDs_put_PropDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIndexDs_INTERFACE_DEFINED__ */


#ifndef __ICatalogSearchServerList_INTERFACE_DEFINED__
#define __ICatalogSearchServerList_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatalogSearchServerList
 * at Wed Apr 22 20:00:57 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][public][object] */ 



EXTERN_C const IID IID_ICatalogSearchServerList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("549b5add-c1d1-11d0-8107-00c04fc29723")
    ICatalogSearchServerList : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT __RPC_FAR *pCatalog) = 0;
        
        virtual /* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pNewEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrServer,
            /* [retval][out] */ VARIANT __RPC_FAR *pIndexDs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ BSTR bstrServer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogSearchServerListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalogSearchServerList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalogSearchServerList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalogSearchServerList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalogSearchServerList __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalogSearchServerList __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalogSearchServerList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalogSearchServerList __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ICatalogSearchServerList __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ICatalogSearchServerList __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT __RPC_FAR *pCatalog);
        
        /* [helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ICatalogSearchServerList __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pNewEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            ICatalogSearchServerList __RPC_FAR * This,
            /* [in] */ BSTR bstrServer,
            /* [retval][out] */ VARIANT __RPC_FAR *pIndexDs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            ICatalogSearchServerList __RPC_FAR * This,
            /* [in] */ BSTR bstrServer);
        
        END_INTERFACE
    } ICatalogSearchServerListVtbl;

    interface ICatalogSearchServerList
    {
        CONST_VTBL struct ICatalogSearchServerListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogSearchServerList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalogSearchServerList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalogSearchServerList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalogSearchServerList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalogSearchServerList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalogSearchServerList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalogSearchServerList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalogSearchServerList_get_Count(This,pCount)	\
    (This)->lpVtbl -> get_Count(This,pCount)

#define ICatalogSearchServerList_get_Item(This,bstrName,pCatalog)	\
    (This)->lpVtbl -> get_Item(This,bstrName,pCatalog)

#define ICatalogSearchServerList_get__NewEnum(This,pNewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,pNewEnum)

#define ICatalogSearchServerList_Add(This,bstrServer,pIndexDs)	\
    (This)->lpVtbl -> Add(This,bstrServer,pIndexDs)

#define ICatalogSearchServerList_Remove(This,bstrServer)	\
    (This)->lpVtbl -> Remove(This,bstrServer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ICatalogSearchServerList_get_Count_Proxy( 
    ICatalogSearchServerList __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ICatalogSearchServerList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogSearchServerList_get_Item_Proxy( 
    ICatalogSearchServerList __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ VARIANT __RPC_FAR *pCatalog);


void __RPC_STUB ICatalogSearchServerList_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ICatalogSearchServerList_get__NewEnum_Proxy( 
    ICatalogSearchServerList __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pNewEnum);


void __RPC_STUB ICatalogSearchServerList_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatalogSearchServerList_Add_Proxy( 
    ICatalogSearchServerList __RPC_FAR * This,
    /* [in] */ BSTR bstrServer,
    /* [retval][out] */ VARIANT __RPC_FAR *pIndexDs);


void __RPC_STUB ICatalogSearchServerList_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatalogSearchServerList_Remove_Proxy( 
    ICatalogSearchServerList __RPC_FAR * This,
    /* [in] */ BSTR bstrServer);


void __RPC_STUB ICatalogSearchServerList_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalogSearchServerList_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\iiis.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0268 */
/* at Wed Jul 07 15:53:18 1999
 */
/* Compiler settings for iis.odl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __iiis_h__
#define __iiis_h__

/* Forward Declarations */ 

#ifndef __IISMimeType_FWD_DEFINED__
#define __IISMimeType_FWD_DEFINED__
typedef interface IISMimeType IISMimeType;
#endif 	/* __IISMimeType_FWD_DEFINED__ */


#ifndef __MimeMap_FWD_DEFINED__
#define __MimeMap_FWD_DEFINED__

#ifdef __cplusplus
typedef class MimeMap MimeMap;
#else
typedef struct MimeMap MimeMap;
#endif /* __cplusplus */

#endif 	/* __MimeMap_FWD_DEFINED__ */


#ifndef __IISIPSecurity_FWD_DEFINED__
#define __IISIPSecurity_FWD_DEFINED__
typedef interface IISIPSecurity IISIPSecurity;
#endif 	/* __IISIPSecurity_FWD_DEFINED__ */


#ifndef __IPSecurity_FWD_DEFINED__
#define __IPSecurity_FWD_DEFINED__

#ifdef __cplusplus
typedef class IPSecurity IPSecurity;
#else
typedef struct IPSecurity IPSecurity;
#endif /* __cplusplus */

#endif 	/* __IPSecurity_FWD_DEFINED__ */


#ifndef __IISNamespace_FWD_DEFINED__
#define __IISNamespace_FWD_DEFINED__

#ifdef __cplusplus
typedef class IISNamespace IISNamespace;
#else
typedef struct IISNamespace IISNamespace;
#endif /* __cplusplus */

#endif 	/* __IISNamespace_FWD_DEFINED__ */


#ifndef __IISProvider_FWD_DEFINED__
#define __IISProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class IISProvider IISProvider;
#else
typedef struct IISProvider IISProvider;
#endif /* __cplusplus */

#endif 	/* __IISProvider_FWD_DEFINED__ */


#ifndef __IISBaseObject_FWD_DEFINED__
#define __IISBaseObject_FWD_DEFINED__
typedef interface IISBaseObject IISBaseObject;
#endif 	/* __IISBaseObject_FWD_DEFINED__ */


#ifndef __IISSchemaObject_FWD_DEFINED__
#define __IISSchemaObject_FWD_DEFINED__
typedef interface IISSchemaObject IISSchemaObject;
#endif 	/* __IISSchemaObject_FWD_DEFINED__ */


#ifndef __IISPropertyAttribute_FWD_DEFINED__
#define __IISPropertyAttribute_FWD_DEFINED__
typedef interface IISPropertyAttribute IISPropertyAttribute;
#endif 	/* __IISPropertyAttribute_FWD_DEFINED__ */


#ifndef __PropertyAttribute_FWD_DEFINED__
#define __PropertyAttribute_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropertyAttribute PropertyAttribute;
#else
typedef struct PropertyAttribute PropertyAttribute;
#endif /* __cplusplus */

#endif 	/* __PropertyAttribute_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_iis_0000 */
/* [local] */ 

DEFINE_GUID(LIBID_IISOle,0x49D704A0L,0x89F7,0x11D0,0x85,0x27,0x00,0xC0,0x4F,0xD8,0xD5,0x03);
DEFINE_GUID(IID_IISBaseObject, 0x4b42e390, 0xe96, 0x11d1, 0x9c, 0x3f, 0x0, 0xa0,0xc9, 0x22, 0xe7, 0x3);


extern RPC_IF_HANDLE __MIDL_itf_iis_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iis_0000_v0_0_s_ifspec;


#ifndef __IISOle_LIBRARY_DEFINED__
#define __IISOle_LIBRARY_DEFINED__

/* library IISOle */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_IISOle;

#ifndef __IISMimeType_INTERFACE_DEFINED__
#define __IISMimeType_INTERFACE_DEFINED__

/* interface IISMimeType */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IISMimeType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9036B027-A780-11d0-9B3D-0080C710EF95")
    IISMimeType : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MimeType( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MimeType( 
            /* [in] */ BSTR bstrMimeType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Extension( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Extension( 
            /* [in] */ BSTR bstrExtension) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISMimeTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISMimeType __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISMimeType __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISMimeType __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MimeType )( 
            IISMimeType __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MimeType )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ BSTR bstrMimeType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Extension )( 
            IISMimeType __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Extension )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ BSTR bstrExtension);
        
        END_INTERFACE
    } IISMimeTypeVtbl;

    interface IISMimeType
    {
        CONST_VTBL struct IISMimeTypeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISMimeType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IISMimeType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IISMimeType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IISMimeType_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IISMimeType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IISMimeType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IISMimeType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IISMimeType_get_MimeType(This,retval)	\
    (This)->lpVtbl -> get_MimeType(This,retval)

#define IISMimeType_put_MimeType(This,bstrMimeType)	\
    (This)->lpVtbl -> put_MimeType(This,bstrMimeType)

#define IISMimeType_get_Extension(This,retval)	\
    (This)->lpVtbl -> get_Extension(This,retval)

#define IISMimeType_put_Extension(This,bstrExtension)	\
    (This)->lpVtbl -> put_Extension(This,bstrExtension)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISMimeType_get_MimeType_Proxy( 
    IISMimeType __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IISMimeType_get_MimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISMimeType_put_MimeType_Proxy( 
    IISMimeType __RPC_FAR * This,
    /* [in] */ BSTR bstrMimeType);


void __RPC_STUB IISMimeType_put_MimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISMimeType_get_Extension_Proxy( 
    IISMimeType __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IISMimeType_get_Extension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISMimeType_put_Extension_Proxy( 
    IISMimeType __RPC_FAR * This,
    /* [in] */ BSTR bstrExtension);


void __RPC_STUB IISMimeType_put_Extension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISMimeType_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MimeMap;

#ifdef __cplusplus

class DECLSPEC_UUID("9036B028-A780-11d0-9B3D-0080C710EF95")
MimeMap;
#endif

#ifndef __IISIPSecurity_INTERFACE_DEFINED__
#define __IISIPSecurity_INTERFACE_DEFINED__

/* interface IISIPSecurity */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IISIPSecurity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F3287521-BBA3-11d0-9BDC-00A0C922E703")
    IISIPSecurity : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_IPDeny( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_IPDeny( 
            /* [in] */ VARIANT vIPDeny) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_IPGrant( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_IPGrant( 
            /* [in] */ VARIANT vIPGrant) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainDeny( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DomainDeny( 
            /* [in] */ VARIANT vDomainDeny) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainGrant( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DomainGrant( 
            /* [in] */ VARIANT vDomainGrant) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GrantByDefault( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GrantByDefault( 
            /* [in] */ VARIANT_BOOL fGrantByDefault) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISIPSecurityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISIPSecurity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISIPSecurity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISIPSecurity __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IPDeny )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IPDeny )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT vIPDeny);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IPGrant )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IPGrant )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT vIPGrant);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DomainDeny )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DomainDeny )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT vDomainDeny);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DomainGrant )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DomainGrant )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT vDomainGrant);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GrantByDefault )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GrantByDefault )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fGrantByDefault);
        
        END_INTERFACE
    } IISIPSecurityVtbl;

    interface IISIPSecurity
    {
        CONST_VTBL struct IISIPSecurityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISIPSecurity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IISIPSecurity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IISIPSecurity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IISIPSecurity_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IISIPSecurity_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IISIPSecurity_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IISIPSecurity_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IISIPSecurity_get_IPDeny(This,retval)	\
    (This)->lpVtbl -> get_IPDeny(This,retval)

#define IISIPSecurity_put_IPDeny(This,vIPDeny)	\
    (This)->lpVtbl -> put_IPDeny(This,vIPDeny)

#define IISIPSecurity_get_IPGrant(This,retval)	\
    (This)->lpVtbl -> get_IPGrant(This,retval)

#define IISIPSecurity_put_IPGrant(This,vIPGrant)	\
    (This)->lpVtbl -> put_IPGrant(This,vIPGrant)

#define IISIPSecurity_get_DomainDeny(This,retval)	\
    (This)->lpVtbl -> get_DomainDeny(This,retval)

#define IISIPSecurity_put_DomainDeny(This,vDomainDeny)	\
    (This)->lpVtbl -> put_DomainDeny(This,vDomainDeny)

#define IISIPSecurity_get_DomainGrant(This,retval)	\
    (This)->lpVtbl -> get_DomainGrant(This,retval)

#define IISIPSecurity_put_DomainGrant(This,vDomainGrant)	\
    (This)->lpVtbl -> put_DomainGrant(This,vDomainGrant)

#define IISIPSecurity_get_GrantByDefault(This,retval)	\
    (This)->lpVtbl -> get_GrantByDefault(This,retval)

#define IISIPSecurity_put_GrantByDefault(This,fGrantByDefault)	\
    (This)->lpVtbl -> put_GrantByDefault(This,fGrantByDefault)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_IPDeny_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_IPDeny_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_IPDeny_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT vIPDeny);


void __RPC_STUB IISIPSecurity_put_IPDeny_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_IPGrant_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_IPGrant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_IPGrant_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT vIPGrant);


void __RPC_STUB IISIPSecurity_put_IPGrant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_DomainDeny_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_DomainDeny_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_DomainDeny_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT vDomainDeny);


void __RPC_STUB IISIPSecurity_put_DomainDeny_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_DomainGrant_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_DomainGrant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_DomainGrant_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT vDomainGrant);


void __RPC_STUB IISIPSecurity_put_DomainGrant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_GrantByDefault_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_GrantByDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_GrantByDefault_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fGrantByDefault);


void __RPC_STUB IISIPSecurity_put_GrantByDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISIPSecurity_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_IPSecurity;

#ifdef __cplusplus

class DECLSPEC_UUID("F3287520-BBA3-11d0-9BDC-00A0C922E703")
IPSecurity;
#endif

EXTERN_C const CLSID CLSID_IISNamespace;

#ifdef __cplusplus

class DECLSPEC_UUID("d6bfa35e-89f2-11d0-8527-00c04fd8d503")
IISNamespace;
#endif

EXTERN_C const CLSID CLSID_IISProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("d88966de-89f2-11d0-8527-00c04fd8d503")
IISProvider;
#endif

#ifndef __IISBaseObject_INTERFACE_DEFINED__
#define __IISBaseObject_INTERFACE_DEFINED__

/* interface IISBaseObject */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IISBaseObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4B42E390-0E96-11d1-9C3F-00A0C922E703")
    IISBaseObject : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetDataPaths( 
            /* [in] */ BSTR bstrName,
            /* [in] */ LONG lnAttribute,
            /* [retval][out] */ VARIANT __RPC_FAR *pvPaths) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetPropertyAttribObj( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISBaseObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISBaseObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISBaseObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISBaseObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataPaths )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ LONG lnAttribute,
            /* [retval][out] */ VARIANT __RPC_FAR *pvPaths);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyAttribObj )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObject);
        
        END_INTERFACE
    } IISBaseObjectVtbl;

    interface IISBaseObject
    {
        CONST_VTBL struct IISBaseObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISBaseObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IISBaseObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IISBaseObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IISBaseObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IISBaseObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IISBaseObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IISBaseObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IISBaseObject_GetDataPaths(This,bstrName,lnAttribute,pvPaths)	\
    (This)->lpVtbl -> GetDataPaths(This,bstrName,lnAttribute,pvPaths)

#define IISBaseObject_GetPropertyAttribObj(This,bstrName,ppObject)	\
    (This)->lpVtbl -> GetPropertyAttribObj(This,bstrName,ppObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IISBaseObject_GetDataPaths_Proxy( 
    IISBaseObject __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ LONG lnAttribute,
    /* [retval][out] */ VARIANT __RPC_FAR *pvPaths);


void __RPC_STUB IISBaseObject_GetDataPaths_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISBaseObject_GetPropertyAttribObj_Proxy( 
    IISBaseObject __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObject);


void __RPC_STUB IISBaseObject_GetPropertyAttribObj_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISBaseObject_INTERFACE_DEFINED__ */


#ifndef __IISSchemaObject_INTERFACE_DEFINED__
#define __IISSchemaObject_INTERFACE_DEFINED__

/* interface IISSchemaObject */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IISSchemaObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6865A9C-3F64-11D2-A600-00A0C922E703")
    IISSchemaObject : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetSchemaPropertyAttributes( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObject) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutSchemaPropertyAttributes( 
            /* [in] */ IDispatch __RPC_FAR *pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISSchemaObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISSchemaObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISSchemaObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISSchemaObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISSchemaObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISSchemaObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISSchemaObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISSchemaObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSchemaPropertyAttributes )( 
            IISSchemaObject __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObject);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutSchemaPropertyAttributes )( 
            IISSchemaObject __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pObject);
        
        END_INTERFACE
    } IISSchemaObjectVtbl;

    interface IISSchemaObject
    {
        CONST_VTBL struct IISSchemaObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISSchemaObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IISSchemaObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IISSchemaObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IISSchemaObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IISSchemaObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IISSchemaObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IISSchemaObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IISSchemaObject_GetSchemaPropertyAttributes(This,bstrName,ppObject)	\
    (This)->lpVtbl -> GetSchemaPropertyAttributes(This,bstrName,ppObject)

#define IISSchemaObject_PutSchemaPropertyAttributes(This,pObject)	\
    (This)->lpVtbl -> PutSchemaPropertyAttributes(This,pObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IISSchemaObject_GetSchemaPropertyAttributes_Proxy( 
    IISSchemaObject __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObject);


void __RPC_STUB IISSchemaObject_GetSchemaPropertyAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISSchemaObject_PutSchemaPropertyAttributes_Proxy( 
    IISSchemaObject __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pObject);


void __RPC_STUB IISSchemaObject_PutSchemaPropertyAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISSchemaObject_INTERFACE_DEFINED__ */


#ifndef __IISPropertyAttribute_INTERFACE_DEFINED__
#define __IISPropertyAttribute_INTERFACE_DEFINED__

/* interface IISPropertyAttribute */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IISPropertyAttribute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50E21930-A247-11D1-B79C-00A0C922E703")
    IISPropertyAttribute : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PropName( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MetaId( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MetaId( 
            /* [in] */ long lnMetaId) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_UserType( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_UserType( 
            /* [in] */ long lnUserType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AllAttributes( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Inherit( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Inherit( 
            /* [in] */ VARIANT_BOOL fInherit) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Secure( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Secure( 
            /* [in] */ VARIANT_BOOL fSecure) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Reference( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Reference( 
            /* [in] */ VARIANT_BOOL fReference) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Volatile( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Volatile( 
            /* [in] */ VARIANT_BOOL fVolatile) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Isinherit( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Default( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Default( 
            /* [in] */ VARIANT vDefault) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISPropertyAttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISPropertyAttribute __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISPropertyAttribute __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PropName )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MetaId )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MetaId )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [in] */ long lnMetaId);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UserType )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UserType )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [in] */ long lnUserType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllAttributes )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Inherit )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Inherit )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fInherit);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Secure )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Secure )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fSecure);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Reference )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Reference )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fReference);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Volatile )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Volatile )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fVolatile);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Isinherit )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Default )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Default )( 
            IISPropertyAttribute __RPC_FAR * This,
            /* [in] */ VARIANT vDefault);
        
        END_INTERFACE
    } IISPropertyAttributeVtbl;

    interface IISPropertyAttribute
    {
        CONST_VTBL struct IISPropertyAttributeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISPropertyAttribute_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IISPropertyAttribute_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IISPropertyAttribute_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IISPropertyAttribute_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IISPropertyAttribute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IISPropertyAttribute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IISPropertyAttribute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IISPropertyAttribute_get_PropName(This,retval)	\
    (This)->lpVtbl -> get_PropName(This,retval)

#define IISPropertyAttribute_get_MetaId(This,retval)	\
    (This)->lpVtbl -> get_MetaId(This,retval)

#define IISPropertyAttribute_put_MetaId(This,lnMetaId)	\
    (This)->lpVtbl -> put_MetaId(This,lnMetaId)

#define IISPropertyAttribute_get_UserType(This,retval)	\
    (This)->lpVtbl -> get_UserType(This,retval)

#define IISPropertyAttribute_put_UserType(This,lnUserType)	\
    (This)->lpVtbl -> put_UserType(This,lnUserType)

#define IISPropertyAttribute_get_AllAttributes(This,retval)	\
    (This)->lpVtbl -> get_AllAttributes(This,retval)

#define IISPropertyAttribute_get_Inherit(This,retval)	\
    (This)->lpVtbl -> get_Inherit(This,retval)

#define IISPropertyAttribute_put_Inherit(This,fInherit)	\
    (This)->lpVtbl -> put_Inherit(This,fInherit)

#define IISPropertyAttribute_get_Secure(This,retval)	\
    (This)->lpVtbl -> get_Secure(This,retval)

#define IISPropertyAttribute_put_Secure(This,fSecure)	\
    (This)->lpVtbl -> put_Secure(This,fSecure)

#define IISPropertyAttribute_get_Reference(This,retval)	\
    (This)->lpVtbl -> get_Reference(This,retval)

#define IISPropertyAttribute_put_Reference(This,fReference)	\
    (This)->lpVtbl -> put_Reference(This,fReference)

#define IISPropertyAttribute_get_Volatile(This,retval)	\
    (This)->lpVtbl -> get_Volatile(This,retval)

#define IISPropertyAttribute_put_Volatile(This,fVolatile)	\
    (This)->lpVtbl -> put_Volatile(This,fVolatile)

#define IISPropertyAttribute_get_Isinherit(This,retval)	\
    (This)->lpVtbl -> get_Isinherit(This,retval)

#define IISPropertyAttribute_get_Default(This,retval)	\
    (This)->lpVtbl -> get_Default(This,retval)

#define IISPropertyAttribute_put_Default(This,vDefault)	\
    (This)->lpVtbl -> put_Default(This,vDefault)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_get_PropName_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IISPropertyAttribute_get_PropName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_get_MetaId_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IISPropertyAttribute_get_MetaId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_put_MetaId_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [in] */ long lnMetaId);


void __RPC_STUB IISPropertyAttribute_put_MetaId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_get_UserType_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IISPropertyAttribute_get_UserType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_put_UserType_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [in] */ long lnUserType);


void __RPC_STUB IISPropertyAttribute_put_UserType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_get_AllAttributes_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IISPropertyAttribute_get_AllAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_get_Inherit_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IISPropertyAttribute_get_Inherit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_put_Inherit_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fInherit);


void __RPC_STUB IISPropertyAttribute_put_Inherit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_get_Secure_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IISPropertyAttribute_get_Secure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_put_Secure_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fSecure);


void __RPC_STUB IISPropertyAttribute_put_Secure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_get_Reference_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IISPropertyAttribute_get_Reference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_put_Reference_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fReference);


void __RPC_STUB IISPropertyAttribute_put_Reference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_get_Volatile_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IISPropertyAttribute_get_Volatile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_put_Volatile_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fVolatile);


void __RPC_STUB IISPropertyAttribute_put_Volatile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_get_Isinherit_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IISPropertyAttribute_get_Isinherit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_get_Default_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IISPropertyAttribute_get_Default_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISPropertyAttribute_put_Default_Proxy( 
    IISPropertyAttribute __RPC_FAR * This,
    /* [in] */ VARIANT vDefault);


void __RPC_STUB IISPropertyAttribute_put_Default_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISPropertyAttribute_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_PropertyAttribute;

#ifdef __cplusplus

class DECLSPEC_UUID("FD2280A8-51A4-11D2-A601-3078302C2030")
PropertyAttribute;
#endif
#endif /* __IISOle_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ime.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    ime.h

Abstract:

    Procedure declarations, constant definitions and macros for the IME
    component.

--*/

#ifndef _IME_
#define _IME_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


#ifndef _WINDEF_
typedef unsigned int UINT;
#endif // _WINDEF_

#define IME_MAXPROCESS 32

LRESULT WINAPI SendIMEMessageExA( IN HWND, IN LPARAM);
LRESULT WINAPI SendIMEMessageExW( IN HWND, IN LPARAM);
#ifdef UNICODE
#define SendIMEMessageEx  SendIMEMessageExW
#else
#define SendIMEMessageEx  SendIMEMessageExA
#endif // !UNICODE

//
// IMESTRUCT structure for SendIMEMessageEx
//
typedef struct tagIMESTRUCT {
    UINT     fnc;        // function code
    WPARAM   wParam;     // word parameter
    UINT     wCount;     // word counter
    UINT     dchSource;  // offset to Source from top of memory object
    UINT     dchDest;    // offset to Desrination from top of memory object
    LPARAM   lParam1;
    LPARAM   lParam2;
    LPARAM   lParam3;
} IMESTRUCT,*PIMESTRUCT,NEAR *NPIMESTRUCT,FAR *LPIMESTRUCT;



#define CP_HWND                 0
#define CP_OPEN                 1
#define CP_DIRECT               2
#define CP_LEVEL                3


//
//      Virtual Keys
//

#define VK_DBE_ALPHANUMERIC              0x0f0
#define VK_DBE_KATAKANA                  0x0f1
#define VK_DBE_HIRAGANA                  0x0f2
#define VK_DBE_SBCSCHAR                  0x0f3
#define VK_DBE_DBCSCHAR                  0x0f4
#define VK_DBE_ROMAN                     0x0f5
#define VK_DBE_NOROMAN                   0x0f6
#define VK_DBE_ENTERWORDREGISTERMODE     0x0f7
#define VK_DBE_ENTERIMECONFIGMODE        0x0f8
#define VK_DBE_FLUSHSTRING               0x0f9
#define VK_DBE_CODEINPUT                 0x0fa
#define VK_DBE_NOCODEINPUT               0x0fb
#define VK_DBE_DETERMINESTRING           0x0fc
#define VK_DBE_ENTERDLGCONVERSIONMODE    0x0fd



//
//     switch for wParam of IME_SETCONVERSIONWINDOW
//
#define MCW_DEFAULT             0x00
#define MCW_RECT                0x01
#define MCW_WINDOW              0x02
#define MCW_SCREEN              0x04
#define MCW_VERTICAL            0x08
#define MCW_HIDDEN              0x10

//
//    switch for wParam of IME_SETCONVERSIONMODE
//       and IME_GETCONVERSIONMODE
//
#define IME_MODE_ALPHANUMERIC   0x0001

#ifdef KOREA    // BeomOh - 9/29/92
#define IME_MODE_SBCSCHAR       0x0002
#else
#define IME_MODE_SBCSCHAR       0x0008
#endif

#define IME_MODE_KATAKANA       0x0002
#define IME_MODE_HIRAGANA       0x0004
#define IME_MODE_HANJACONVERT   0x0004
#define IME_MODE_DBCSCHAR       0x0010
#define IME_MODE_ROMAN          0x0020
#define IME_MODE_NOROMAN        0x0040
#define IME_MODE_CODEINPUT      0x0080
#define IME_MODE_NOCODEINPUT    0x0100
//
//

//
//     IME APIs
//
#define IME_GETIMECAPS            0x03
#define IME_SETOPEN               0x04
#define IME_GETOPEN               0x05
#define IME_GETVERSION            0x07
#define IME_SETCONVERSIONWINDOW   0x08
#define IME_MOVEIMEWINDOW         IME_SETCONVERSIONWINDOW       // KOREA only
#define IME_SETCONVERSIONMODE     0x10

#define IME_GETCONVERSIONMODE     0x11
#define IME_SET_MODE              0x12          // KOREA only
#define IME_SENDVKEY              0x13
#define IME_ENTERWORDREGISTERMODE 0x18
#define IME_SETCONVERSIONFONTEX   0x19

//
// IME_CODECONVERT subfunctions
//
#define IME_BANJAtoJUNJA        0x13            // KOREA only
#define IME_JUNJAtoBANJA        0x14            // KOREA only
#define IME_JOHABtoKS           0x15            // KOREA only
#define IME_KStoJOHAB           0x16            // KOREA only

//
// IME_AUTOMATA subfunctions
//
#define IMEA_INIT               0x01            // KOREA only
#define IMEA_NEXT               0x02            // KOREA only
#define IMEA_PREV               0x03            // KOREA only

//
// IME_HANJAMODE subfunctions
//
#define IME_REQUEST_CONVERT     0x01            // KOREA only
#define IME_ENABLE_CONVERT      0x02            // KOREA only

//
// IME_MOVEIMEWINDOW subfunctions
//
#define INTERIM_WINDOW          0x00            // KOREA only
#define MODE_WINDOW             0x01            // KOREA only
#define HANJA_WINDOW            0x02            // KOREA only

//
//    error code
//
#define IME_RS_ERROR            0x01    // genetal error
#define IME_RS_NOIME            0x02    // IME is not installed
#define IME_RS_TOOLONG          0x05    // given string is too long
#define IME_RS_ILLEGAL          0x06    // illegal charactor(s) is string
#define IME_RS_NOTFOUND         0x07    // no (more) candidate
#define IME_RS_NOROOM           0x0a    // no disk/memory space
#define IME_RS_DISKERROR        0x0e    // disk I/O error
#define IME_RS_INVALID          0x11    // Win3.1/NT
#define IME_RS_NEST             0x12    // called nested
#define IME_RS_SYSTEMMODAL      0x13    // called when system mode

//
//   report messge from IME to WinApps
//
#define WM_IME_REPORT       0x0280

//
//   report message parameter for WM_IME_REPORT
//
#define IR_STRINGSTART      0x100
#define IR_STRINGEND        0x101
#define IR_OPENCONVERT      0x120
#define IR_CHANGECONVERT    0x121
#define IR_CLOSECONVERT     0x122
#define IR_FULLCONVERT      0x123
#define IR_IMESELECT        0x130
#define IR_STRING       0x140
#define IR_DBCSCHAR             0x160
#define IR_UNDETERMINE          0x170
#define IR_STRINGEX             0x180   // New for 3.1
#define IR_MODEINFO             0x190

//#define WM_CONVERTREQUESTEX     0x0109
#define WM_WNT_CONVERTREQUESTEX 0x0109 /* WM_CONVERTREQUESTEX: 109 for NT, 108 for OT */
#define WM_CONVERTREQUEST       0x010A
#define WM_CONVERTRESULT        0x010B
#define WM_INTERIM              0x010C

#define WM_IMEKEYDOWN           0x290
#define WM_IMEKEYUP             0x291


//
// UNDETERMINESTRING structure for IR_UNDETERMINE
//
typedef struct tagUNDETERMINESTRUCT {
    DWORD    dwSize;
    UINT     uDefIMESize;
    UINT     uDefIMEPos;
    UINT     uUndetTextLen;
    UINT     uUndetTextPos;
    UINT     uUndetAttrPos;
    UINT     uCursorPos;
    UINT     uDeltaStart;
    UINT     uDetermineTextLen;
    UINT     uDetermineTextPos;
    UINT     uDetermineDelimPos;
    UINT     uYomiTextLen;
    UINT     uYomiTextPos;
    UINT     uYomiDelimPos;
} UNDETERMINESTRUCT,*PUNDETERMINESTRUCT,NEAR *NPUNDETERMINESTRUCT,FAR *LPUNDETERMINESTRUCT;


typedef struct tagSTRINGEXSTRUCT {
    DWORD    dwSize;
    UINT     uDeterminePos;
    UINT     uDetermineDelimPos;
    UINT     uYomiPos;
    UINT     uYomiDelimPos;
} STRINGEXSTRUCT,NEAR *NPSTRINGEXSTRUCT,FAR *LPSTRINGEXSTRUCT;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _IME_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\imgguids.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   imgguids.h
*
* Abstract:
*
*   GUIDs defined and used by the imaging library
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

//
// Image file format identifiers
//

DEFINE_GUID(IMGFMT_UNDEFINED, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_MEMORYBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_BMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_WMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_JPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_GIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_TIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PHOTOCD, 0xb96b3cb3,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_FLASHPIX, 0xb96b3cb4,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_ICO, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//
// Interface and class identifiers
//

DEFINE_GUID(IID_IImagingFactory, 0x327abda7,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(CLSID_ImagingFactory, 0x327abda8,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImage, 0x327abda9,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBitmapImage, 0x327abdaa,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageDecoder, 0x327abdab,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageEncoder, 0x327abdac,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageSink, 0x327abdae,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBasicBitmapOps, 0x327abdaf,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//
// Predefined multi-frame dimension IDs
//

DEFINE_GUID(FRAMEDIM_TIME, 0x6aedbd6d,0x3fb5,0x418a,0x83,0xa6,0x7f,0x45,0x22,0x9d,0xc8,0x72);
DEFINE_GUID(FRAMEDIM_RESOLUTION, 0x84236f7b,0x3bd3,0x428f,0x8d,0xab,0x4e,0xa1,0x43,0x9c,0xa3,0x15);
DEFINE_GUID(FRAMEDIM_PAGE, 0x7462dc86,0x6180,0x4c7e,0x8e,0x3f,0xee,0x73,0x33,0xa7,0xa4,0x83);

//
// Property sets
//

DEFINE_GUID(FMTID_ImageInformation, 0xe5836cbe,0x5eef,0x4f1d,0xac,0xde,0xae,0x4c,0x43,0xb6,0x08,0xce);
DEFINE_GUID(FMTID_JpegAppHeaders, 0x1c4afdcd,0x6177,0x43cf,0xab,0xc7,0x5f,0x51,0xaf,0x39,0xee,0x85);

//
// Decoder parameter sets
//
DEFINE_GUID(DECODER_TRANSCOLOR, 0xb7a98c8f,0xdce7,0x457d,0xbf,0xa5,0xce,0xa7,0x1b,0xd1,0x4d,0xd6);
DEFINE_GUID(DECODER_TRANSRANGE, 0xabeed189,0xd988,0x4d03,0xb4,0x25,0x57,0x10,0x55,0xc7,0x6a,0xd1);
DEFINE_GUID(DECODER_OUTPUTCHANNEL, 0x2ff8f51e,0x724d,0x45fe,0x86,0xce,0x17,0x77,0xa0,0x56,0xda,0x60);
DEFINE_GUID(DECODER_ICONRES, 0x5c656eec,0xe94f,0x45ba,0xa6,0xf6,0x10,0x62,0xe8,0x5f,0x4a,0x7f);
 
//
// Encoder parameter sets
//
DEFINE_GUID(ENCODER_COMPRESSION, 0xe09d739d,0xccd4,0x44ee,0x8e,0xba,0x3f,0xbf,0x8b,0xe4,0xfc,0x58);
DEFINE_GUID(ENCODER_COLORDEPTH, 0x66087055,0xad66,0x4c7c,0x9a,0x18,0x38,0xa2,0x31,0x0b,0x83,0x37);
DEFINE_GUID(ENCODER_SCANMETHOD, 0x3a4e2661,0x3109,0x4e56,0x85,0x36,0x42,0xc1,0x56,0xe7,0xdc,0xfa);
DEFINE_GUID(ENCODER_VERSION, 0x24d18c76,0x814a,0x41a4,0xbf,0x53,0x1c,0x21,0x9c,0xcc,0xf7,0x97);
DEFINE_GUID(ENCODER_RENDERMETHOD, 0x6d42c53a,0x229a,0x4825,0x8b,0xb7,0x5c,0x99,0xe2,0xb9,0xa8,0xb8);
DEFINE_GUID(ENCODER_QUALITY, 0x1d5be4b5,0xfa4a,0x452d,0x9c,0xdd,0x5d,0xb3,0x51,0x05,0xe7,0xeb);
DEFINE_GUID(ENCODER_ROTATION,0x109555d4,0x2ab6,0x4379,0xa8,0x3f,0x5d,0x78,0xfa,0x53,0x8c,0x45);
DEFINE_GUID(ENCODER_TRANSFORMATION,0x8d0eb2d1,0xa58e,0x4ea8,0xaa,0x14,0x10,0x80,0x74,0xb7,0xb6,0xf9);
DEFINE_GUID(ENCODER_LUMINANCE_TABLE,0xedb33bce,0x0266,0x4a77,0xb9,0x04,0x27,0x21,0x60,0x99,0xe7,0x17);
DEFINE_GUID(ENCODER_CHROMINANCE_TABLE,0xf2e455dc,0x09b3,0x4316,0x82,0x60,0x67,0x6a,0xda,0x32,0x48,0x1c);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\iiscnfg.h ===
/*++



   Copyright (c) 1997-1999 Microsoft Corporation

   Module  Name :

       iiscnfg.h

   Abstract:

        Contains public Metadata IDs used by IIS.

   Environment:

      Win32 User Mode

--*/

#ifndef _IISCNFG_H_
#define _IISCNFG_H_


//
// Paths
//

#define IIS_MD_LOCAL_MACHINE_PATH       "LM"

//
// Name of the default publishing root under an instance
//

#define IIS_MD_INSTANCE_ROOT            "Root"

//
//  ISAPI Filters are kept in a list under the instances and the service (for
//  global filters) in the following format:
//
//  LM/W3Svc/<Instance>/Filters
//      MD_FILTER_LOAD_ORDER  "Filter1, Filter2, Filter3"
//
//  LM/W3Svc/<Instance>/Filters/Filter1
//      MD_FILTER_IMAGE_PATH  "d:\inetsrv\myfilter.dll"
//
//  LM/W3Svc/<Instance>/Filters/Filter2
//      MD_FILTER_IMAGE_PATH  "d:\inetsrv\otherfilter.dll"
//

#define IIS_MD_ISAPI_FILTERS            "/Filters"

//
// Path below each service to the key that publishes service information
//

#define IIS_MD_SVC_INFO_PATH            "Info"

//
// ADSI schema properties path
//

#define IIS_MD_ADSI_SCHEMA_PATH_A       "/Schema"
#define IIS_MD_ADSI_SCHEMA_PATH_W       L"/Schema"
#define IIS_MD_ADSI_METAID_BEGIN        130000

//
// user types
//
// There are two user types:
//
//   Server configuration - All the properties for configuring the server that
//      are not applicable to files and directories - such as Port, Host name,
//      Server comment, Connection timeout etc.
//
//  File/Dir configuration - All the properties that can be configured down to
//      the files and directories - such as Access permissions (Read, Write etc),
//      Extension mapping, IP Security etc.
//

#define IIS_MD_UT_SERVER                1   // Server configuration parameters
#define IIS_MD_UT_FILE                  2   // File/Dir inheritable properties
#define IIS_MD_UT_WAM                 100   // Web Application configuration parameters
#define ASP_MD_UT_APP                 101   // ASP application configuration parameters
#define IIS_MD_UT_END_RESERVED       2000   // All user types below this are
                                            // reserved for IIS services


//
//  Metabase property IDs must be unique.  This table defines reserved ranges
//

#define IIS_MD_ID_BEGIN_RESERVED    0x00000001      // IIS reserved range
#define IIS_MD_ID_END_RESERVED      0x00007fff
#define ASP_MD_ID_BEGIN_RESERVED    0x00007000      // ASP reserved range, subrange of IIS.
#define ASP_MD_ID_END_RESERVED      0x000074ff
#define WAM_MD_ID_BEGIN_RESERVED    0x00007500      // ASP reserved range, subrange of IIS.
#define WAM_MD_ID_END_RESERVED      0x00007fff
#define FP_MD_ID_BEGIN_RESERVED     0x00008000      // Front page reserved range
#define FP_MD_ID_END_RESERVED       0x00008fff
#define SMTP_MD_ID_BEGIN_RESERVED   0x00009000
#define SMTP_MD_ID_END_RESERVED     0x00009fff
#define POP3_MD_ID_BEGIN_RESERVED   0x0000a000
#define POP3_MD_ID_END_RESERVED     0x0000afff
#define NNTP_MD_ID_BEGIN_RESERVED   0x0000b000
#define NNTP_MD_ID_END_RESERVED     0x0000bfff
#define IMAP_MD_ID_BEGIN_RESERVED   0x0000c000
#define IMAP_MD_ID_END_RESERVED     0x0000cfff
#define MSCS_MD_ID_BEGIN_RESERVED   0x0000d000
#define MSCS_MD_ID_END_RESERVED     0x0000dfff
#define APPCTR_MD_ID_BEGIN_RESERVED 0x0000e000
#define APPCTR_MD_ID_END_RESERVED   0x0000efff

#define USER_MD_ID_BASE_RESERVED    0x0000ffff

//
//  General server related attributes - these should be added in the metabase
//  with a user type of IIS_MD_UT_SERVER
//

#define IIS_MD_SERVER_BASE              1000

//
//  These are global to all services and should only be set at
//  the IIS root
//

#define MD_MAX_BANDWIDTH                (IIS_MD_SERVER_BASE+0  )
#define MD_KEY_TYPE                     (IIS_MD_SERVER_BASE+2  )
#define MD_MAX_BANDWIDTH_BLOCKED        (IIS_MD_SERVER_BASE+3  )
#define MD_SCHEMA_METAID                (IIS_MD_SERVER_BASE+4  )

//
//  These properties are applicable to both HTTP and FTP virtual
//  servers
//

#define MD_SERVER_COMMAND               (IIS_MD_SERVER_BASE+12 )
#define MD_CONNECTION_TIMEOUT           (IIS_MD_SERVER_BASE+13 )
#define MD_MAX_CONNECTIONS              (IIS_MD_SERVER_BASE+14 )
#define MD_SERVER_COMMENT               (IIS_MD_SERVER_BASE+15 )
#define MD_SERVER_STATE                 (IIS_MD_SERVER_BASE+16 )
#define MD_SERVER_AUTOSTART             (IIS_MD_SERVER_BASE+17 )
#define MD_SERVER_SIZE                  (IIS_MD_SERVER_BASE+18 )
#define MD_SERVER_LISTEN_BACKLOG        (IIS_MD_SERVER_BASE+19 )
#define MD_SERVER_LISTEN_TIMEOUT        (IIS_MD_SERVER_BASE+20 )
#define MD_DOWNLEVEL_ADMIN_INSTANCE     (IIS_MD_SERVER_BASE+21 )
#define MD_LEVELS_TO_SCAN               (IIS_MD_SERVER_BASE+22 )
#define MD_SERVER_BINDINGS              (IIS_MD_SERVER_BASE+23 )
#define MD_MAX_ENDPOINT_CONNECTIONS     (IIS_MD_SERVER_BASE+24 )
#define MD_SERVER_CONFIGURATION_INFO    (IIS_MD_SERVER_BASE+27 )
#define MD_IISADMIN_EXTENSIONS          (IIS_MD_SERVER_BASE+28 )
#define MD_DISABLE_SOCKET_POOLING       (IIS_MD_SERVER_BASE+29 )
#define MD_METADATA_ID_REGISTRATION     (IIS_MD_SERVER_BASE+30 )


//
//  These properties are specific to HTTP and belong to the website
//

#define IIS_MD_HTTP_BASE                2000

#define MD_SECURE_BINDINGS              (IIS_MD_HTTP_BASE+21 )

#define MD_FILTER_LOAD_ORDER            (IIS_MD_HTTP_BASE+40 )
#define MD_FILTER_IMAGE_PATH            (IIS_MD_HTTP_BASE+41 )
#define MD_FILTER_STATE                 (IIS_MD_HTTP_BASE+42 )
#define MD_FILTER_ENABLED               (IIS_MD_HTTP_BASE+43 )
#define MD_FILTER_FLAGS                 (IIS_MD_HTTP_BASE+44 )
#define MD_FILTER_DESCRIPTION           (IIS_MD_HTTP_BASE+45 )

#define MD_ADV_NOTIFY_PWD_EXP_IN_DAYS   (IIS_MD_HTTP_BASE+63 )
#define MD_ADV_CACHE_TTL                (IIS_MD_HTTP_BASE+64 )
#define MD_NET_LOGON_WKS                (IIS_MD_HTTP_BASE+65 )
#define MD_USE_HOST_NAME                (IIS_MD_HTTP_BASE+66 )
#define MD_AUTH_CHANGE_FLAGS            (IIS_MD_HTTP_BASE+68 )

#define MD_PROCESS_NTCR_IF_LOGGED_ON    (IIS_MD_HTTP_BASE+70 )

#define MD_FRONTPAGE_WEB                (IIS_MD_HTTP_BASE+72 )
#define MD_IN_PROCESS_ISAPI_APPS        (IIS_MD_HTTP_BASE+73 )

#define MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS  ( IIS_MD_HTTP_BASE+95)

#define MD_APP_FRIENDLY_NAME            (IIS_MD_HTTP_BASE+102)
#define MD_APP_ROOT                     (IIS_MD_HTTP_BASE+103)
#define MD_APP_ISOLATED                 (IIS_MD_HTTP_BASE+104)
#define MD_APP_WAM_CLSID                (IIS_MD_HTTP_BASE+105)
#define MD_APP_PACKAGE_ID               (IIS_MD_HTTP_BASE+106)
#define MD_APP_PACKAGE_NAME             (IIS_MD_HTTP_BASE+107)
#define MD_APP_OOP_RECOVER_LIMIT        (IIS_MD_HTTP_BASE+110)
#define MD_APP_PERIODIC_RESTART_TIME    (IIS_MD_HTTP_BASE+111)
#define MD_APP_PERIODIC_RESTART_REQUESTS  (IIS_MD_HTTP_BASE+112)
#define MD_APP_PERIODIC_RESTART_SCHEDULE  (IIS_MD_HTTP_BASE+113)
#define MD_APP_SHUTDOWN_TIME_LIMIT      (IIS_MD_HTTP_BASE+114)


#define MD_ADMIN_INSTANCE               (IIS_MD_HTTP_BASE+115)
// This is only used by setup & UI
#define MD_NOT_DELETABLE                (IIS_MD_HTTP_BASE+116)

#define MD_CUSTOM_ERROR_DESC            (IIS_MD_HTTP_BASE+120)

//
//  Client Access License parameters
//

#define MD_CAL_VC_PER_CONNECT           (IIS_MD_HTTP_BASE+130)
#define MD_CAL_AUTH_RESERVE_TIMEOUT     (IIS_MD_HTTP_BASE+131)
#define MD_CAL_SSL_RESERVE_TIMEOUT      (IIS_MD_HTTP_BASE+132)
#define MD_CAL_W3_ERROR                 (IIS_MD_HTTP_BASE+133)

//
// CPU Accounting and Throttling Properties
//

//
// The enabled flags are per Application or CGI
//

#define MD_CPU_CGI_ENABLED              (IIS_MD_HTTP_BASE+140)
#define MD_CPU_APP_ENABLED              (IIS_MD_HTTP_BASE+141)

//
// These values are per site
//

#define MD_CPU_LIMITS_ENABLED           (IIS_MD_HTTP_BASE+143)
#define MD_CPU_RESET_INTERVAL           (IIS_MD_HTTP_BASE+144)
#define MD_CPU_LOGGING_INTERVAL         (IIS_MD_HTTP_BASE+145)
#define MD_CPU_LOGGING_OPTIONS          (IIS_MD_HTTP_BASE+146)
#define MD_CPU_CGI_LIMIT                (IIS_MD_HTTP_BASE+148)
#define MD_CPU_LIMIT_LOGEVENT           (IIS_MD_HTTP_BASE+149)
#define MD_CPU_LIMIT_PRIORITY           (IIS_MD_HTTP_BASE+150)
#define MD_CPU_LIMIT_PROCSTOP           (IIS_MD_HTTP_BASE+151)
#define MD_CPU_LIMIT_PAUSE              (IIS_MD_HTTP_BASE+152)

//
// Valid values for CPU Accounting's MD_CPU_LOGGING_OPTIONS field
//

#define MD_CPU_DISABLE_ALL_LOGGING      0x0
#define MD_CPU_ENABLE_ALL_PROC_LOGGING  0x1
#define MD_CPU_ENABLE_CGI_LOGGING       0x2
#define MD_CPU_ENABLE_APP_LOGGING       0x4

//
// Valid values for CPU Accounting's MD_CPU_LOGGING_MASK field
// This defines which fields will be logged
//

#define MD_CPU_ENABLE_EVENT             0x01
#define MD_CPU_ENABLE_PROC_TYPE         0x02
#define MD_CPU_ENABLE_USER_TIME         0x04
#define MD_CPU_ENABLE_KERNEL_TIME       0x08
#define MD_CPU_ENABLE_PAGE_FAULTS       0x10
#define MD_CPU_ENABLE_TOTAL_PROCS       0x20
#define MD_CPU_ENABLE_ACTIVE_PROCS      0x40
#define MD_CPU_ENABLE_TERMINATED_PROCS  0x80

#define MD_CPU_ENABLE_LOGGING           0x80000000

//
//  Site Server properties
//


#define MD_MD_SERVER_SS_AUTH_MAPPING    (IIS_MD_HTTP_BASE+200)

//
// valid values for MD_CERT_CHECK_MODE
//

#define MD_CERT_NO_REVOC_CHECK          0x00000001
#define MD_CERT_CACHE_RETRIEVAL_ONLY    0x00000002

//
// HTTP Compression properties.  All are global and unheritable.
//

#define MD_HC_COMPRESSION_DIRECTORY        (IIS_MD_HTTP_BASE+210)
#define MD_HC_CACHE_CONTROL_HEADER         (IIS_MD_HTTP_BASE+211)
#define MD_HC_EXPIRES_HEADER               (IIS_MD_HTTP_BASE+212)
#define MD_HC_DO_DYNAMIC_COMPRESSION       (IIS_MD_HTTP_BASE+213)
#define MD_HC_DO_STATIC_COMPRESSION        (IIS_MD_HTTP_BASE+214)
#define MD_HC_DO_ON_DEMAND_COMPRESSION     (IIS_MD_HTTP_BASE+215)
#define MD_HC_DO_DISK_SPACE_LIMITING       (IIS_MD_HTTP_BASE+216)
#define MD_HC_NO_COMPRESSION_FOR_HTTP_10   (IIS_MD_HTTP_BASE+217)
#define MD_HC_NO_COMPRESSION_FOR_PROXIES   (IIS_MD_HTTP_BASE+218)
#define MD_HC_NO_COMPRESSION_FOR_RANGE     (IIS_MD_HTTP_BASE+219)
#define MD_HC_SEND_CACHE_HEADERS           (IIS_MD_HTTP_BASE+220)
#define MD_HC_MAX_DISK_SPACE_USAGE         (IIS_MD_HTTP_BASE+221)
#define MD_HC_IO_BUFFER_SIZE               (IIS_MD_HTTP_BASE+222)
#define MD_HC_COMPRESSION_BUFFER_SIZE      (IIS_MD_HTTP_BASE+223)
#define MD_HC_MAX_QUEUE_LENGTH             (IIS_MD_HTTP_BASE+224)
#define MD_HC_FILES_DELETED_PER_DISK_FREE  (IIS_MD_HTTP_BASE+225)
#define MD_HC_MIN_FILE_SIZE_FOR_COMP       (IIS_MD_HTTP_BASE+226)

#define MD_HC_COMPRESSION_DLL              (IIS_MD_HTTP_BASE+237)
#define MD_HC_FILE_EXTENSIONS              (IIS_MD_HTTP_BASE+238)
#define MD_HC_MIME_TYPE                    (IIS_MD_HTTP_BASE+239)
#define MD_HC_PRIORITY                     (IIS_MD_HTTP_BASE+240)
#define MD_HC_DYNAMIC_COMPRESSION_LEVEL    (IIS_MD_HTTP_BASE+241)
#define MD_HC_ON_DEMAND_COMP_LEVEL         (IIS_MD_HTTP_BASE+242)
#define MD_HC_CREATE_FLAGS                 (IIS_MD_HTTP_BASE+243)
#define MD_HC_SCRIPT_FILE_EXTENSIONS       (IIS_MD_HTTP_BASE+244)

//
// Generic property indicating a failure status code - Can be used under
// any component that can fail (virtual directory, filters, applications etc)
//

#define MD_WIN32_ERROR                  (IIS_MD_SERVER_BASE+99 )

//
// Virtual root properties - note MD_ACCESS_PERM is also generally set at
// the virtual directory.  These are used for both HTTP and FTP
//

#define IIS_MD_VR_BASE                  3000

#define MD_VR_PATH                      (IIS_MD_VR_BASE+1 )
#define MD_VR_USERNAME                  (IIS_MD_VR_BASE+2 )
#define MD_VR_PASSWORD                  (IIS_MD_VR_BASE+3 )
#define MD_VR_PASSTHROUGH               (IIS_MD_VR_BASE+6 )
#define MD_VR_NO_CACHE                  (IIS_MD_VR_BASE+7 )
#define MD_VR_IGNORE_TRANSLATE          (IIS_MD_VR_BASE+8 )


//
//  Logging related attributes
//

#define IIS_MD_LOG_BASE                 4000

#define MD_LOG_TYPE                     (IIS_MD_LOG_BASE+0  )
#define MD_LOGFILE_DIRECTORY            (IIS_MD_LOG_BASE+1  )
#define MD_LOG_UNUSED1                  (IIS_MD_LOG_BASE+2  )
#define MD_LOGFILE_PERIOD               (IIS_MD_LOG_BASE+3  )
#define MD_LOGFILE_TRUNCATE_SIZE        (IIS_MD_LOG_BASE+4  )
#define MD_LOG_PLUGIN_MOD_ID            (IIS_MD_LOG_BASE+5  )
#define MD_LOG_PLUGIN_UI_ID             (IIS_MD_LOG_BASE+6  )
#define MD_LOGSQL_DATA_SOURCES          (IIS_MD_LOG_BASE+7  )
#define MD_LOGSQL_TABLE_NAME            (IIS_MD_LOG_BASE+8  )
#define MD_LOGSQL_USER_NAME             (IIS_MD_LOG_BASE+9  )
#define MD_LOGSQL_PASSWORD              (IIS_MD_LOG_BASE+10 )
#define MD_LOG_PLUGIN_ORDER             (IIS_MD_LOG_BASE+11 )
#define MD_LOG_PLUGINS_AVAILABLE        (IIS_MD_LOG_BASE+12 )
#define MD_LOGEXT_FIELD_MASK            (IIS_MD_LOG_BASE+13 )
#define MD_LOGEXT_FIELD_MASK2           (IIS_MD_LOG_BASE+14 )

//
// Allow W3C logging file naming and rollover based on Local Time
//

#define MD_LOGFILE_LOCALTIME_ROLLOVER   (IIS_MD_LOG_BASE+15)

#define IIS_MD_LOG_LAST                 MD_LOGFILE_LOCALTIME_ROLLOVER

//
// Log type
//

#define MD_LOG_TYPE_DISABLED            0
#define MD_LOG_TYPE_ENABLED             1

//
// LOGGING values
//

#define MD_LOGFILE_PERIOD_NONE          0
#define MD_LOGFILE_PERIOD_MAXSIZE       0
#define MD_LOGFILE_PERIOD_DAILY         1
#define MD_LOGFILE_PERIOD_WEEKLY        2
#define MD_LOGFILE_PERIOD_MONTHLY       3
#define MD_LOGFILE_PERIOD_HOURLY        4

//
// Field masks for extended logging
// Fields are logged in order of increasing mask value
//

#define MD_EXTLOG_DATE                  0x00000001
#define MD_EXTLOG_TIME                  0x00000002
#define MD_EXTLOG_CLIENT_IP             0x00000004
#define MD_EXTLOG_USERNAME              0x00000008
#define MD_EXTLOG_SITE_NAME             0x00000010
#define MD_EXTLOG_COMPUTER_NAME         0x00000020
#define MD_EXTLOG_SERVER_IP             0x00000040
#define MD_EXTLOG_METHOD                0x00000080
#define MD_EXTLOG_URI_STEM              0x00000100
#define MD_EXTLOG_URI_QUERY             0x00000200
#define MD_EXTLOG_HTTP_STATUS           0x00000400
#define MD_EXTLOG_WIN32_STATUS          0x00000800
#define MD_EXTLOG_BYTES_SENT            0x00001000
#define MD_EXTLOG_BYTES_RECV            0x00002000
#define MD_EXTLOG_TIME_TAKEN            0x00004000
#define MD_EXTLOG_SERVER_PORT           0x00008000
#define MD_EXTLOG_USER_AGENT            0x00010000
#define MD_EXTLOG_COOKIE                0x00020000
#define MD_EXTLOG_REFERER               0x00040000
#define MD_EXTLOG_PROTOCOL_VERSION      0x00080000
#define MD_EXTLOG_HOST                  0x00100000


#define MD_DEFAULT_EXTLOG_FIELDS        (MD_EXTLOG_CLIENT_IP | \
                                         MD_EXTLOG_TIME      | \
                                         MD_EXTLOG_METHOD    | \
                                         MD_EXTLOG_URI_STEM  | \
                                         MD_EXTLOG_HTTP_STATUS)

//
// Custom Logging related attributes
//

#define IIS_MD_LOGCUSTOM_BASE           4500

//
// Custom Logging configuration attributes
//

#define MD_LOGCUSTOM_PROPERTY_NAME      (IIS_MD_LOGCUSTOM_BASE+1 )
#define MD_LOGCUSTOM_PROPERTY_HEADER    (IIS_MD_LOGCUSTOM_BASE+2 )
#define MD_LOGCUSTOM_PROPERTY_ID        (IIS_MD_LOGCUSTOM_BASE+3 )
#define MD_LOGCUSTOM_PROPERTY_MASK      (IIS_MD_LOGCUSTOM_BASE+4 )
#define MD_LOGCUSTOM_PROPERTY_DATATYPE  (IIS_MD_LOGCUSTOM_BASE+5 )
#define MD_LOGCUSTOM_SERVICES_STRING    (IIS_MD_LOGCUSTOM_BASE+6 )      // MultiSZ List of services that the property is applicable to.

#define MD_CPU_LOGGING_MASK             (IIS_MD_LOGCUSTOM_BASE+7 )

//
// The values for MD_CPU_LOGGING_MASK are defined above.
// See MD_CPU_ENABLE_EVENT, etc.
//


#define IIS_MD_LOGCUSTOM_LAST           MD_CPU_LOGGING_MASK

//
// Valid values for Custom Logging's MD_LOGCUSTOM_PROPERTY_DATATYPE field
//

#define MD_LOGCUSTOM_DATATYPE_INT       0
#define MD_LOGCUSTOM_DATATYPE_UINT      1
#define MD_LOGCUSTOM_DATATYPE_LONG      2
#define MD_LOGCUSTOM_DATATYPE_ULONG     3
#define MD_LOGCUSTOM_DATATYPE_FLOAT     4
#define MD_LOGCUSTOM_DATATYPE_DOUBLE    5
#define MD_LOGCUSTOM_DATATYPE_LPSTR     6
#define MD_LOGCUSTOM_DATATYPE_LPWSTR    7


//
//  ISAPI Filter Notification Flags
//

#define MD_NOTIFY_SECURE_PORT           0x00000001
#define MD_NOTIFY_NONSECURE_PORT        0x00000002

#define MD_NOTIFY_READ_RAW_DATA         0x00008000
#define MD_NOTIFY_PREPROC_HEADERS       0x00004000
#define MD_NOTIFY_AUTHENTICATION        0x00002000
#define MD_NOTIFY_URL_MAP               0x00001000
#define MD_NOTIFY_ACCESS_DENIED         0x00000800
#define MD_NOTIFY_SEND_RESPONSE         0x00000040
#define MD_NOTIFY_SEND_RAW_DATA         0x00000400
#define MD_NOTIFY_LOG                   0x00000200
#define MD_NOTIFY_END_OF_REQUEST        0x00000080
#define MD_NOTIFY_END_OF_NET_SESSION    0x00000100

//
//  ISAPI Filter ordering flags
//

#define MD_NOTIFY_ORDER_HIGH            0x00080000
#define MD_NOTIFY_ORDER_MEDIUM          0x00040000
#define MD_NOTIFY_ORDER_LOW             0x00020000
#define MD_NOTIFY_ORDER_DEFAULT         MD_NOTIFY_ORDER_LOW

#define MD_NOTIFY_ORDER_MASK            (MD_NOTIFY_ORDER_HIGH   |    \
                                         MD_NOTIFY_ORDER_MEDIUM |    \
                                         MD_NOTIFY_ORDER_LOW)


//
//  These are FTP specific properties
//

#define IIS_MD_FTP_BASE                 5000

#define MD_EXIT_MESSAGE                 (IIS_MD_FTP_BASE+1  )
#define MD_GREETING_MESSAGE             (IIS_MD_FTP_BASE+2  )
#define MD_MAX_CLIENTS_MESSAGE          (IIS_MD_FTP_BASE+3  )
#define MD_MSDOS_DIR_OUTPUT             (IIS_MD_FTP_BASE+4  )
#define MD_ALLOW_ANONYMOUS              (IIS_MD_FTP_BASE+5  )
#define MD_ANONYMOUS_ONLY               (IIS_MD_FTP_BASE+6  )
#define MD_LOG_ANONYMOUS                (IIS_MD_FTP_BASE+7  )
#define MD_LOG_NONANONYMOUS             (IIS_MD_FTP_BASE+8  )
#define MD_ALLOW_REPLACE_ON_RENAME      (IIS_MD_FTP_BASE+9  )
#define MD_SHOW_4_DIGIT_YEAR            (IIS_MD_FTP_BASE+10 )


//
//  These are SSL specific properties
//

#define IIS_MD_SSL_BASE                 5500

#define MD_SSL_PUBLIC_KEY               ( IIS_MD_SSL_BASE+0 )
#define MD_SSL_PRIVATE_KEY              ( IIS_MD_SSL_BASE+1 )
#define MD_SSL_KEY_PASSWORD             ( IIS_MD_SSL_BASE+2 )
#define MD_SSL_KEY_REQUEST              ( IIS_MD_SSL_BASE+3 )

//
// These are server certificate properties
//
//
// These are Certificate Trust List properties
//

//
// Metabase property that defines whether to use DS mapper or not
//
#define MD_SSL_USE_DS_MAPPER            ( IIS_MD_SSL_BASE+19 )


//
// Metabase properties that are used by the CertWiz ActiveX control, that
// is used for the Certificate/CTL UI management tool
//

//
// Metabase properties used for Fortezza certificates
//

//
// Metabase properties that are used by the CertWiz ActiveX control to keep
// track of the user's entry history, and whether DEBUG is enabled.  We keep
// these private properties on a per VS basis.
//

//  File and Directory related properties - these should be added in the
//  metabase with a user type of IIS_MD_UT_FILE
//

#define IIS_MD_FILE_PROP_BASE           6000

#define MD_AUTHORIZATION                (IIS_MD_FILE_PROP_BASE )
#define MD_REALM                        (IIS_MD_FILE_PROP_BASE+1 )
#define MD_HTTP_EXPIRES                 (IIS_MD_FILE_PROP_BASE+2 )
#define MD_HTTP_PICS                    (IIS_MD_FILE_PROP_BASE+3 )
#define MD_HTTP_CUSTOM                  (IIS_MD_FILE_PROP_BASE+4 )
#define MD_DIRECTORY_BROWSING           (IIS_MD_FILE_PROP_BASE+5 )
#define MD_DEFAULT_LOAD_FILE            (IIS_MD_FILE_PROP_BASE+6 )
#define MD_CUSTOM_ERROR                 (IIS_MD_FILE_PROP_BASE+8 )
#define MD_FOOTER_DOCUMENT              (IIS_MD_FILE_PROP_BASE+9 )
#define MD_FOOTER_ENABLED               (IIS_MD_FILE_PROP_BASE+10 )
#define MD_HTTP_REDIRECT                (IIS_MD_FILE_PROP_BASE+11 )
#define MD_DEFAULT_LOGON_DOMAIN         (IIS_MD_FILE_PROP_BASE+12 )
#define MD_LOGON_METHOD                 (IIS_MD_FILE_PROP_BASE+13 )
#define MD_SCRIPT_MAPS                  (IIS_MD_FILE_PROP_BASE+14 )
#define MD_MIME_MAP                     (IIS_MD_FILE_PROP_BASE+15 )
#define MD_ACCESS_PERM                  (IIS_MD_FILE_PROP_BASE+16 )
#define MD_IP_SEC                       (IIS_MD_FILE_PROP_BASE+19 )
#define MD_ANONYMOUS_USER_NAME          (IIS_MD_FILE_PROP_BASE+20 )
#define MD_ANONYMOUS_PWD                (IIS_MD_FILE_PROP_BASE+21 )
#define MD_ANONYMOUS_USE_SUBAUTH        (IIS_MD_FILE_PROP_BASE+22 )
#define MD_DONT_LOG                     (IIS_MD_FILE_PROP_BASE+23 )
#define MD_ADMIN_ACL                    (IIS_MD_FILE_PROP_BASE+27 )
#define MD_SSI_EXEC_DISABLED            (IIS_MD_FILE_PROP_BASE+28 )
#define MD_DO_REVERSE_DNS               (IIS_MD_FILE_PROP_BASE+29 )
#define MD_SSL_ACCESS_PERM              (IIS_MD_FILE_PROP_BASE+30 )
#define MD_AUTHORIZATION_PERSISTENCE    (IIS_MD_FILE_PROP_BASE+31 )
#define MD_NTAUTHENTICATION_PROVIDERS   (IIS_MD_FILE_PROP_BASE+32 )
#define MD_SCRIPT_TIMEOUT               (IIS_MD_FILE_PROP_BASE+33 )
#define MD_CACHE_EXTENSIONS             (IIS_MD_FILE_PROP_BASE+34 )
#define MD_CREATE_PROCESS_AS_USER       (IIS_MD_FILE_PROP_BASE+35 )
#define MD_CREATE_PROC_NEW_CONSOLE      (IIS_MD_FILE_PROP_BASE+36 )
#define MD_POOL_IDC_TIMEOUT             (IIS_MD_FILE_PROP_BASE+37 )
#define MD_ALLOW_KEEPALIVES             (IIS_MD_FILE_PROP_BASE+38 )
#define MD_IS_CONTENT_INDEXED           (IIS_MD_FILE_PROP_BASE+39 )
#define MD_CC_NO_CACHE                  (IIS_MD_FILE_PROP_BASE+41 )
#define MD_CC_MAX_AGE                   (IIS_MD_FILE_PROP_BASE+42 )
#define MD_CC_OTHER                     (IIS_MD_FILE_PROP_BASE+43 )
#define MD_REDIRECT_HEADERS             (IIS_MD_FILE_PROP_BASE+44 )
#define MD_UPLOAD_READAHEAD_SIZE        (IIS_MD_FILE_PROP_BASE+45 )
#define MD_PUT_READ_SIZE                (IIS_MD_FILE_PROP_BASE+46 )
#define MD_USE_DIGEST_SSP               (IIS_MD_FILE_PROP_BASE+47 )


#define ASP_MD_SERVER_BASE                  7000

#define MD_ASP_BUFFERINGON                  (ASP_MD_SERVER_BASE + 0)
#define MD_ASP_LOGERRORREQUESTS             (ASP_MD_SERVER_BASE + 1)
#define MD_ASP_SCRIPTERRORSSENTTOBROWSER    (ASP_MD_SERVER_BASE + 2)
#define MD_ASP_SCRIPTERRORMESSAGE           (ASP_MD_SERVER_BASE + 3)
#define MD_ASP_SCRIPTFILECACHESIZE          (ASP_MD_SERVER_BASE + 4)
#define MD_ASP_SCRIPTENGINECACHEMAX         (ASP_MD_SERVER_BASE + 5)
#define MD_ASP_SCRIPTTIMEOUT                (ASP_MD_SERVER_BASE + 6)
#define MD_ASP_SESSIONTIMEOUT               (ASP_MD_SERVER_BASE + 7)
#define MD_ASP_ENABLEPARENTPATHS            (ASP_MD_SERVER_BASE + 8)
#define MD_ASP_MEMFREEFACTOR                (ASP_MD_SERVER_BASE + 9)    // OBSOLETE
#define MD_ASP_MINUSEDBLOCKS                (ASP_MD_SERVER_BASE + 10)   // OBSOLETE
#define MD_ASP_ALLOWSESSIONSTATE            (ASP_MD_SERVER_BASE + 11)
#define MD_ASP_SCRIPTLANGUAGE               (ASP_MD_SERVER_BASE + 12)
#define MD_ASP_QUEUETIMEOUT                 (ASP_MD_SERVER_BASE + 13)
#define MD_ASP_ALLOWOUTOFPROCCOMPONENTS     (ASP_MD_SERVER_BASE + 14)
#define MD_ASP_ALLOWOUTOFPROCCMPNTS         (MD_ASP_ALLOWOUTOFPROCCOMPONENTS)   // Deprecated.  Use MD_ASP_ALLOWOUTOFPROCCMPNTS
#define MD_ASP_EXCEPTIONCATCHENABLE         (ASP_MD_SERVER_BASE + 15)
#define MD_ASP_CODEPAGE                     (ASP_MD_SERVER_BASE + 16)
#define MD_ASP_SCRIPTLANGUAGELIST           (ASP_MD_SERVER_BASE + 17)
#define MD_ASP_ENABLESERVERDEBUG            (ASP_MD_SERVER_BASE + 18)
#define MD_ASP_ENABLECLIENTDEBUG            (ASP_MD_SERVER_BASE + 19)
#define MD_ASP_TRACKTHREADINGMODEL          (ASP_MD_SERVER_BASE + 20)
// added for IIS 5.0
#define MD_ASP_ENABLEASPHTMLFALLBACK        (ASP_MD_SERVER_BASE + 21)
#define MD_ASP_ENABLECHUNKEDENCODING        (ASP_MD_SERVER_BASE + 22)
#define MD_ASP_ENABLETYPELIBCACHE           (ASP_MD_SERVER_BASE + 23)
#define MD_ASP_ERRORSTONTLOG                (ASP_MD_SERVER_BASE + 24)
#define MD_ASP_PROCESSORTHREADMAX           (ASP_MD_SERVER_BASE + 25)
#define MD_ASP_REQEUSTQUEUEMAX              (ASP_MD_SERVER_BASE + 26)
#define MD_ASP_ENABLEAPPLICATIONRESTART     (ASP_MD_SERVER_BASE + 27)
#define MD_ASP_QUEUECONNECTIONTESTTIME      (ASP_MD_SERVER_BASE + 28)
#define MD_ASP_SESSIONMAX                   (ASP_MD_SERVER_BASE + 29)
// thread gate
#define MD_ASP_THREADGATEENABLED            (ASP_MD_SERVER_BASE + 30)
#define MD_ASP_THREADGATETIMESLICE          (ASP_MD_SERVER_BASE + 31)
#define MD_ASP_THREADGATESLEEPDELAY         (ASP_MD_SERVER_BASE + 32)
#define MD_ASP_THREADGATESLEEPMAX           (ASP_MD_SERVER_BASE + 33)
#define MD_ASP_THREADGATELOADLOW            (ASP_MD_SERVER_BASE + 34)
#define MD_ASP_THREADGATELOADHIGH           (ASP_MD_SERVER_BASE + 35)

// added IIS5.1

// persist template cache
#define MD_ASP_DISKTEMPLATECACHEDIRECTORY   (ASP_MD_SERVER_BASE + 36)
#define MD_ASP_MAXDISKTEMPLATECACHEFILES    (ASP_MD_SERVER_BASE + 40)

#define MD_ASP_EXECUTEINMTA                                     (ASP_MD_SERVER_BASE + 41)

#define MD_ASP_LCID                                                     (ASP_MD_SERVER_BASE + 42)

#define MD_ASP_ID_LAST                      (ASP_MD_SERVER_BASE + 43)


//
//  Valid values for WAM
//
#define WAM_MD_SERVER_BASE                  7500

#define MD_WAM_USER_NAME                (WAM_MD_SERVER_BASE+1)
#define MD_WAM_PWD                      (WAM_MD_SERVER_BASE+2)

//
//  Valid values for MD_AUTHORIZATION
//

#define MD_AUTH_ANONYMOUS               0x00000001
#define MD_AUTH_BASIC                   0x00000002
#define MD_AUTH_NT                      0x00000004    // Use NT auth provider (like NTLM)

//
//  Valid values for MD_AUTHORIZATION_PERSISTENCE
//


#define MD_AUTH_SINGLEREQUEST                   0x00000040
#define MD_AUTH_SINGLEREQUESTIFPROXY            0x00000080
#define MD_AUTH_SINGLEREQUESTALWAYSIFPROXY      0x00000100

//
//  Valid values for MD_ACCESS_PERM
//

#define MD_ACCESS_READ                  0x00000001    // Allow for Read
#define MD_ACCESS_WRITE                 0x00000002    // Allow for Write
#define MD_ACCESS_EXECUTE               0x00000004    // Allow for Execute
#define MD_ACCESS_SOURCE                0x00000010    // Apply access mask to source
#define MD_ACCESS_SCRIPT                0x00000200    // Allow for Script execution
#define MD_ACCESS_NO_REMOTE_WRITE       0x00000400    // Local host access only
#define MD_ACCESS_NO_REMOTE_READ        0x00001000    // Local host access only
#define MD_ACCESS_NO_REMOTE_EXECUTE     0x00002000    // Local host access only
#define MD_ACCESS_NO_REMOTE_SCRIPT      0x00004000    // Local host access only

#define MD_NONSLL_ACCESS_MASK           (MD_ACCESS_READ|                \
                                         MD_ACCESS_WRITE|               \
                                         MD_ACCESS_EXECUTE|             \
                                         MD_ACCESS_SOURCE|              \
                                         MD_ACCESS_SCRIPT|              \
                                         MD_ACCESS_NO_REMOTE_READ|      \
                                         MD_ACCESS_NO_REMOTE_WRITE|     \
                                         MD_ACCESS_NO_REMOTE_EXECUTE|   \
                                         MD_ACCESS_NO_REMOTE_SCRIPT     \
                                         )
//
//  Valid values for MD_SSL_ACCESS_PERM
//

#define MD_ACCESS_SSL                   0x00000008    // Require SSL
#define MD_ACCESS_NEGO_CERT             0x00000020    // Allow client SSL certs
#define MD_ACCESS_REQUIRE_CERT          0x00000040    // Require client SSL certs
#define MD_ACCESS_MAP_CERT              0x00000080    // Map SSL cert to NT account
#define MD_ACCESS_SSL128                0x00000100    // Require 128 bit SSL

#define MD_SSL_ACCESS_MASK              (MD_ACCESS_SSL|\
                                         MD_ACCESS_NEGO_CERT|\
                                         MD_ACCESS_REQUIRE_CERT|\
                                         MD_ACCESS_MAP_CERT|\
                                         MD_ACCESS_SSL128)

#define MD_ACCESS_MASK                  0x00007fff

//
//  Valid values for MD_DIRECTORY_BROWSING
//

#define MD_DIRBROW_SHOW_DATE            0x00000002
#define MD_DIRBROW_SHOW_TIME            0x00000004
#define MD_DIRBROW_SHOW_SIZE            0x00000008
#define MD_DIRBROW_SHOW_EXTENSION       0x00000010
#define MD_DIRBROW_LONG_DATE            0x00000020

#define MD_DIRBROW_ENABLED              0x80000000  // Allow directory browsing
#define MD_DIRBROW_LOADDEFAULT          0x40000000  // Load default doc if exists

#define MD_DIRBROW_MASK                 (MD_DIRBROW_SHOW_DATE      |    \
                                         MD_DIRBROW_SHOW_TIME      |    \
                                         MD_DIRBROW_SHOW_SIZE      |    \
                                         MD_DIRBROW_SHOW_EXTENSION |    \
                                         MD_DIRBROW_LONG_DATE      |    \
                                         MD_DIRBROW_LOADDEFAULT    |    \
                                         MD_DIRBROW_ENABLED)



//
//  Valid values for MD_LOGON_METHOD
//

#define MD_LOGON_INTERACTIVE        0
#define MD_LOGON_BATCH              1
#define MD_LOGON_NETWORK            2
#define MD_LOGON_NETWORK_CLEARTEXT  3

//
// Valid values for MD_NOTIFY_EXAUTH
//

#define MD_NOTIFEXAUTH_NTLMSSL  1

//
//  Valid values for MD_FILTER_STATE
//

#define MD_FILTER_STATE_LOADED          1
#define MD_FILTER_STATE_UNLOADED        4

//
//  Valid values for MD_SERVER_STATE
//

#define MD_SERVER_STATE_STARTING        1
#define MD_SERVER_STATE_STARTED         2
#define MD_SERVER_STATE_STOPPING        3
#define MD_SERVER_STATE_STOPPED         4
#define MD_SERVER_STATE_PAUSING         5
#define MD_SERVER_STATE_PAUSED          6
#define MD_SERVER_STATE_CONTINUING      7

//
//  Valid values for MD_SERVER_COMMAND
//

#define MD_SERVER_COMMAND_START         1
#define MD_SERVER_COMMAND_STOP          2
#define MD_SERVER_COMMAND_PAUSE         3
#define MD_SERVER_COMMAND_CONTINUE      4

//
//  Valid values for MD_SERVER_SIZE
//

#define MD_SERVER_SIZE_SMALL            0
#define MD_SERVER_SIZE_MEDIUM           1
#define MD_SERVER_SIZE_LARGE            2

//
// Valid values for MD_SERVER_CONFIG_INFO
//

#define MD_SERVER_CONFIG_SSL_40         0x00000001
#define MD_SERVER_CONFIG_SSL_128        0x00000002
#define MD_SERVER_CONFIG_ALLOW_ENCRYPT  0x00000004
#define MD_SERVER_CONFIG_AUTO_PW_SYNC   0x00000008

#define MD_SERVER_CONFIGURATION_MASK   (MD_SERVER_CONFIG_SSL_40       | \
                                        MD_SERVER_CONFIG_SSL_128      | \
                                        MD_SERVER_CONFIG_ENCRYPT      | \
                                        MD_SERVER_CONFIG_AUTO_PW_SYNC)

//
// Valid values for MD_SCRIPT_MAPS flag field
//

#define MD_SCRIPTMAPFLAG_SCRIPT                     0x00000001
#define MD_SCRIPTMAPFLAG_CHECK_PATH_INFO            0x00000004

#ifdef REMOVE   // SteveBr
//
//  Bogus value - do not use
//
#define MD_SCRIPTMAPFLAG_ALLOWED_ON_READ_DIR        0x00000001
#endif // REMOVE


//
// Valid values for MD_AUTH_CHANGE_ENABLE
//

#define MD_AUTH_CHANGE_UNSECURE     0x00000001
#define MD_AUTH_CHANGE_DISABLE      0x00000002
#define MD_AUTH_ADVNOTIFY_DISABLE   0x00000004

//
// Valid values for MD_NET_LOGON_WKS
//

#define MD_NETLOGON_WKS_NONE        0
#define MD_NETLOGON_WKS_IP          1
#define MD_NETLOGON_WKS_DNS         2

//
//  Valide substatus errors for MD_CUSTOM_ERROR
//

#define MD_ERROR_SUB401_LOGON                   1
#define MD_ERROR_SUB401_LOGON_CONFIG            2
#define MD_ERROR_SUB401_LOGON_ACL               3
#define MD_ERROR_SUB401_FILTER                  4
#define MD_ERROR_SUB401_APPLICATION             5

#define MD_ERROR_SUB403_EXECUTE_ACCESS_DENIED   1
#define MD_ERROR_SUB403_READ_ACCESS_DENIED      2
#define MD_ERROR_SUB403_WRITE_ACCESS_DENIED     3
#define MD_ERROR_SUB403_SSL_REQUIRED            4
#define MD_ERROR_SUB403_SSL128_REQUIRED         5
#define MD_ERROR_SUB403_ADDR_REJECT             6
#define MD_ERROR_SUB403_CERT_REQUIRED           7
#define MD_ERROR_SUB403_SITE_ACCESS_DENIED      8
#define MD_ERROR_SUB403_TOO_MANY_USERS          9
#define MD_ERROR_SUB403_INVALID_CNFG           10
#define MD_ERROR_SUB403_PWD_CHANGE             11
#define MD_ERROR_SUB403_MAPPER_DENY_ACCESS     12
#define MD_ERROR_SUB403_CERT_REVOKED           13
#define MD_ERROR_SUB403_DIR_LIST_DENIED        14
#define MD_ERROR_SUB403_CAL_EXCEEDED           15
#define MD_ERROR_SUB403_CERT_BAD               16
#define MD_ERROR_SUB403_CERT_TIME_INVALID      17

#define MD_ERROR_SUB404_SITE_NOT_FOUND          1

#define MD_ERROR_SUB502_TIMEOUT                 1
#define MD_ERROR_SUB502_PREMATURE_EXIT          2

#define MD_ERROR_SUB503_CPU_LIMIT               1

//
// Valid access rights for ACE entries in MD_ADMIN_ACL
//

#define MD_ACR_READ                 0x00000001
#define MD_ACR_WRITE                0x00000002
#define MD_ACR_RESTRICTED_WRITE     0x00000020
#define MD_ACR_UNSECURE_PROPS_READ  0x00000080
#define MD_ACR_ENUM_KEYS            0x00000008
#define MD_ACR_WRITE_DAC            0x00040000


//
// MD_IP_SEC binary format description
//

/*

  This object is composed of 4 lists : 2 lists ( deny & grant ) of network addresses,
  the only allowed family is AF_INET.
  Each of this list is composed of sublists, one for each ( network address family,
  significant subnet mask ) combination. The significant subnet mask is stored as
  ( number of bytes all 1 ( 0xff ), bitmask in last byte ).
  This is followed by 2 lists ( deny & grant ) of DNS names. Each of these lists is
  composed of sublists, based on then number of components in the DNS name
  e.g. "microsoft.com" has 2 components, "www.msft.com" has 3.

Header:
    SELFREFINDEX    iDenyAddr;      // address deny list
                                    // points to ADDRESS_HEADER
    SELFREFINDEX    iGrantAddr;     // address grant list
                                    // points to ADDRESS_HEADER
    SELFREFINDEX    iDenyName;      // DNS name deny list
                                    // points to NAME_HEADER
    SELFREFINDEX    iGrantName;     // DNS name grant list
                                    // points to NAME_HEADER
    DWORD           dwFlags;
    DWORD           cRefSize;       // size of reference area ( in bytes )

ADDRESS_HEADER :
    DWORD               cEntries;   // # of Entries[]
    DWORD               cAddresses; // total # of addresses in all
                                    // ADDRESS_LIST_ENTRY
    ADDRESS_LIST_ENTRY  Entries[];

ADDRESS_LIST_ENTRY :
    DWORD           iFamily;
    DWORD           cAddresses;
    DWORD           cFullBytes;
    DWORD           LastByte;
    SELFREFINDEX    iFirstAddress;  // points to array of addresses

NAME_HEADER :
    DWORD           cEntries;
    DWORD           cNames;         // total # of names for all Entries[]
    NAME_LIST_ENTRY Entries[];

Name list entry :
    DWORD           cComponents;    // # of DNS components
    DWORD           cNames;
    SELFREFINDEX    iName[];        // array of references to DNS names

This is followed by address arrays & names pointed to by iFirstAddress & iName
Names are '\0' delimited

SELFREFINDEX is a DWORD offset from start of structure with high bit set to 1

*/

//
// Macros
//

#define MD_SET_DATA_RECORD(_pMDR, _id, _attr, _utype, _dtype, _dlen, _pData) \
            { \
            (_pMDR)->dwMDIdentifier=(_id);      \
            (_pMDR)->dwMDAttributes=(_attr);    \
            (_pMDR)->dwMDUserType=(_utype);     \
            (_pMDR)->dwMDDataType=(_dtype);     \
            (_pMDR)->dwMDDataLen=(_dlen);       \
            (_pMDR)->pbMDData=(LPBYTE)(_pData); \
            }

//
// IIS ADSI Admin Object class names
//

#define IIS_CLASS_COMPUTER             "IIsComputer"
#define IIS_CLASS_WEB_SERVICE          "IIsWebService"
#define IIS_CLASS_WEB_SERVER           "IIsWebServer"
#define IIS_CLASS_WEB_INFO             "IIsWebInfo"
#define IIS_CLASS_WEB_DIR              "IIsWebDirectory"
#define IIS_CLASS_WEB_VDIR             "IIsWebVirtualDir"
#define IIS_CLASS_WEB_FILE             "IIsWebFile"
#define IIS_CLASS_FTP_SERVICE          "IIsFtpService"
#define IIS_CLASS_FTP_SERVER           "IIsFtpServer"
#define IIS_CLASS_FTP_INFO             "IIsFtpInfo"
#define IIS_CLASS_FTP_VDIR             "IIsFtpVirtualDir"
#define IIS_CLASS_FILTERS              "IIsFilters"
#define IIS_CLASS_FILTER               "IIsFilter"
#define IIS_CLASS_LOG_MODULES          "IIsLogModules"
#define IIS_CLASS_LOG_MODULE           "IIsLogModule"
#define IIS_CLASS_MIMEMAP              "IIsMimeMap"
#define IIS_CLASS_CERTMAPPER           "IIsCertMapper"
#define IIS_CLASS_COMPRESS_SCHEMES     "IIsCompressionSchemes"
#define IIS_CLASS_COMPRESS_SCHEME      "IIsCompressionScheme"

#define IIS_CLASS_COMPUTER_W           L"IIsComputer"
#define IIS_CLASS_WEB_SERVICE_W        L"IIsWebService"
#define IIS_CLASS_WEB_SERVER_W         L"IIsWebServer"
#define IIS_CLASS_WEB_INFO_W           L"IIsWebInfo"
#define IIS_CLASS_WEB_DIR_W            L"IIsWebDirectory"
#define IIS_CLASS_WEB_VDIR_W           L"IIsWebVirtualDir"
#define IIS_CLASS_WEB_FILE_W           L"IIsWebFile"
#define IIS_CLASS_FTP_SERVICE_W        L"IIsFtpService"
#define IIS_CLASS_FTP_SERVER_W         L"IIsFtpServer"
#define IIS_CLASS_FTP_INFO_W           L"IIsFtpInfo"
#define IIS_CLASS_FTP_VDIR_W           L"IIsFtpVirtualDir"
#define IIS_CLASS_FILTERS_W            L"IIsFilters"
#define IIS_CLASS_FILTER_W             L"IIsFilter"
#define IIS_CLASS_LOG_MODULES_W        L"IIsLogModules"
#define IIS_CLASS_LOG_MODULE_W         L"IIsLogModule"
#define IIS_CLASS_MIMEMAP_W            L"IIsMimeMap"
#define IIS_CLASS_CERTMAPPER_W         L"IIsCertMapper"
#define IIS_CLASS_COMPRESS_SCHEMES_W   L"IIsCompressionSchemes"
#define IIS_CLASS_COMPRESS_SCHEME_W    L"IIsCompressionScheme"

#endif // _IISCNFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\il21dec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Line 21 Decoder related definitions and interfaces for ActiveMovie

#ifndef __IL21DEC__
#define __IL21DEC__


//
//  Some enum data types used as line 21 decoder params by the interface
//
typedef enum _AM_LINE21_CCLEVEL {  // should we use TC1, TC2 in stead?
    AM_L21_CCLEVEL_TC2 = 0
} AM_LINE21_CCLEVEL, *PAM_LINE21_CCLEVEL ;

typedef enum _AM_LINE21_CCSERVICE {
    AM_L21_CCSERVICE_None = 0,
    AM_L21_CCSERVICE_Caption1,
    AM_L21_CCSERVICE_Caption2,
    AM_L21_CCSERVICE_Text1,
    AM_L21_CCSERVICE_Text2,
    AM_L21_CCSERVICE_XDS,
    AM_L21_CCSERVICE_DefChannel = 10,
    AM_L21_CCSERVICE_Invalid
} AM_LINE21_CCSERVICE, *PAM_LINE21_CCSERVICE ;

typedef enum _AM_LINE21_CCSTATE {
    AM_L21_CCSTATE_Off = 0,
    AM_L21_CCSTATE_On
} AM_LINE21_CCSTATE, *PAM_LINE21_CCSTATE ;

typedef enum _AM_LINE21_CCSTYLE {
    AM_L21_CCSTYLE_None = 0,
    AM_L21_CCSTYLE_PopOn,
    AM_L21_CCSTYLE_PaintOn,
    AM_L21_CCSTYLE_RollUp
} AM_LINE21_CCSTYLE, *PAM_LINE21_CCSTYLE ;

typedef enum _AM_LINE21_DRAWBGMODE {
    AM_L21_DRAWBGMODE_Opaque,
    AM_L21_DRAWBGMODE_Transparent
} AM_LINE21_DRAWBGMODE, *PAM_LINE21_DRAWBGMODE ;


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
//  Line 21 Decoder standard COM interface
//
DECLARE_INTERFACE_(IAMLine21Decoder, IUnknown)
{
    public:
        //
        // Decoder options to be used by apps
        //

        // What is the decoder's level
        STDMETHOD(GetDecoderLevel)(THIS_ AM_LINE21_CCLEVEL *lpLevel) PURE ;  
        // supported level value is AM_L21Level_TC2 only
        // skipping the SetDecoderLevel( )

        // Which of the services is being currently used
        STDMETHOD(GetCurrentService)(THIS_ AM_LINE21_CCSERVICE *lpService) PURE ;  
        STDMETHOD(SetCurrentService)(THIS_ AM_LINE21_CCSERVICE Service) PURE ;  
        // supported service values are AM_L21Service_Caption1, 
        // AM_L21Service_Caption2, AM_L21Service_Text1, AM_L21Service_Text2, 
        // AM_L21Service_XDS, AM_L21Service_None)

        // Query/Set the service state (On/Off)
        // supported state values are AM_L21State_On and AM_L21State_Off
        STDMETHOD(GetServiceState)(THIS_ AM_LINE21_CCSTATE *lpState) PURE ;  
        STDMETHOD(SetServiceState)(THIS_ AM_LINE21_CCSTATE State) PURE ;  

        //
        // Output options to be used by downstream filters
        //

        // What size, bitdepth etc should the output video be
        STDMETHOD(GetOutputFormat)(THIS_ LPBITMAPINFOHEADER lpbmih) PURE ;
        // GetOutputFormat() method, if successful, returns 
        // 1.  S_FALSE if no output format has so far been defined by downstream filters
        // 2.  S_OK if an output format has already been defined by downstream filters
        STDMETHOD(SetOutputFormat)(THIS_ LPBITMAPINFO lpbmi) PURE ;

        // Specify physical color to be used in colorkeying the background 
        // for overlay mixing
        STDMETHOD(GetBackgroundColor)(THIS_ DWORD *pdwPhysColor) PURE ;
        STDMETHOD(SetBackgroundColor)(THIS_ DWORD dwPhysColor) PURE ;

        // Specify if whole output bitmap should be redrawn for each sample
        STDMETHOD(GetRedrawAlways)(THIS_ LPBOOL lpbOption) PURE ;
        STDMETHOD(SetRedrawAlways)(THIS_ BOOL bOption) PURE ;

        // Specify if the caption text background should be opaque/transparent
        STDMETHOD(GetDrawBackgroundMode)(THIS_ AM_LINE21_DRAWBGMODE *lpMode) PURE ;
        STDMETHOD(SetDrawBackgroundMode)(THIS_ AM_LINE21_DRAWBGMODE Mode) PURE ;
        // supported mode values are AM_L21_DrawBGMode_Opaque and
        // AM_L21_DrawBGMode_Transparent

} ;

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __IL21DEC__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ilsguid.h ===
//****************************************************************************
//
//  File:       ilsguid.h
//  Content:    This file contains the class GUID for Internet Location Services.
//
//  Copyright (c) Microsoft Corporation 1996-1999
//
//****************************************************************************

// {A4AD47C0-20EA-11d0-8796-444553540000}
//
DEFINE_GUID(CLSID_InternetLocationServices, 
0xa4ad47c0, 0x20ea, 0x11d0, 0x87, 0x96, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\imessage.h ===
/*
 *	I M E S S A G E . H
 *
 *	External definitions for MAPI's IMessage-on-IStorage facility
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _IMESSAGE_H_
#define _IMESSAGE_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C"
{
#endif

typedef struct _MSGSESS		FAR * LPMSGSESS;

/*	Typedef of optional callback routine to be called on last release of
 *	top-level messages opened with OpenIMsgOnIStg
 */
typedef void (STDAPICALLTYPE MSGCALLRELEASE)(
	ULONG 		ulCallerData,
	LPMESSAGE	lpMessage );

/* DLL Entry Points (found in mapiu.dll) */

/* OpenIMsgSession
 * CloseIMsgSession
 *
 * These entry points allow the caller to "wrap" the creation of messages
 * inside a session, so that when the session is closed, all messages
 * created within that session are closed as well. Use of IMSG sessions
 * is optional. If OpenIMsgOnIStg is called with a NULL for the lpmsgsess
 * parameter, the message is created independent of any session, and has
 * no way to be shutdown. If the caller forgets to release the message, or
 * to release open tables within the message, the memory will be leaked until
 * the external application terminates.
 */

STDAPI_(SCODE) OpenIMsgSession(
	LPMALLOC		lpMalloc,			/* -> Co malloc object			*/
	ULONG			ulFlags,			/* reserved. Must be zero.		*/
	LPMSGSESS FAR	*lppMsgSess );		/* <- message session object	*/

STDAPI_(void) CloseIMsgSession(
	LPMSGSESS		lpMsgSess );		/* -> message session object	*/

/*	OpenIMsgOnIStg - Main entry point
 *
 *	NOTE 1:  The IStg must be opened with STGM_TRANSACTED if STGM_READWRITE
 *	is specified.  Since messages don't support a write only mode, IMessage
 *	doesn't allow a storage object opened in write only mode. If the storage
 *	is opened STGM_READ, then STGM_TRANSACTED is NOT required.
 *
 *	NOTE 2:  The lpMapiSup parameter is optional.  If supplied then IMessage
 *	will support the MAPI_DIALOG and ATTACH_DIALOG flags (by calling
 *	support method: DoMCDialog) on CopyTo and DeleteAttach methods.
 *	If lpMapiSup is not supplied (i.e. passed 0) then dialog flags will be
 *	ignored.  If supplied then ModifyRecipients will attempt to convert
 *	short term entryids to long term entryids (by calling support method
 *	OpenAddressBook and calls on the returned object).  If not supplied
 *	then short term entryid's will be stored without conversion.
 *
 *	NOTE 3:  The lpfMsgCallRelease parameter is optional.  If supplied then
 *	IMessage will call the routine when the last release on (the toplevel only)
 *	message is called.  It is intended to allow the callee to free the IStorage
 *	that contains the message.  IMessage will not use the IStorage object after
 *	making this call.
 *
 *	NOTE 4:  Behavior of multiple opens of sub-objects (Attachments, Streams,
 *	Storages, Messages, etc.) within a message is deliberately undefined in
 *	MAPI.  This implementation allows them, but will do it by AddRef'ing the
 *	existing open and returning it to the caller of OpenAttachment or
 *	OpenProperty.  This means that whatever access mode the first open on a
 *	specific Attachment or Property had is what all others will get regardless
 *	of what the subsequent opens asked for.
 *
 *	NOTE 5:  There is currently one flag defined for use with the ulFlags
 *	parameter. The IMSG_NO_ISTG_COMMIT flag controls whether the commit
 *	method of IStorage is called when the client calls SaveChanges on the
 *	IMessage object. Some clients of IMessage may wish to commit the IStorage
 *	themselves after writing additional data to the storage (beyond what
 *	IMessage itself writes). To aid in this, the IMessage implementation
 *	guarantees to name all sub-storages starting with "__". Therefore,
 *	if the client keeps its names out of that namespace, there will be no
 *	accidental collisions.
 *
 *	WARNING:	
 *
 *	This implementation of IMessage will support OpenProperty w/MAPI_CREATE
 *	where the source interface is IID_IStorage if the property id is
 *	'PR_ATTACH_DATA'.  Once this has been done, the caller has an IStorage
 *	interface on this property.  This is ok and should allow for
 *	easier implementation of OLE 2.0 Server functionality.  However, if you
 *	pass in the new IStorage ptr (to the attachment data) through the
 *	OpenIMsgOnIStg entry point and then proceed to release things in the
 *	wrong order we will make no attempt to behave in a predictable fashion.
 *	Keep in mind that the correct method for placing a message into an
 *	attachment is to call OpenProperty where the source interface is
 *	IID_IMessage.  The IStorage interface is supported to allow an easy way
 *	to stick a WWord doc. into an attachment w/o converting to/from IStream.
 *
 */
STDAPI_(SCODE) OpenIMsgOnIStg(
	LPMSGSESS		lpMsgSess,			/* -> message session obj (optional) */
	LPALLOCATEBUFFER lpAllocateBuffer,	/* -> AllocateBuffer memory routine  */
	LPALLOCATEMORE 	lpAllocateMore, 	/* -> AllocateMore memory routine    */
	LPFREEBUFFER	lpFreeBuffer, 		/* -> FreeBuffer memory routine      */
	LPMALLOC		lpMalloc,			/* -> Co malloc object				 */
	LPVOID			lpMapiSup,			/* -> MAPI Support Obj (optional)    */
	LPSTORAGE 		lpStg, 				/* -> open IStorage containing msg   */
	MSGCALLRELEASE FAR *lpfMsgCallRelease,	/* -> release callback rtn (opt) */
	ULONG			ulCallerData,		/* caller data returned in callback  */
	ULONG			ulFlags,			/* -> flags (controls istg commit)   */
	LPMESSAGE		FAR *lppMsg );		/* <- open message object			 */

#define IMSG_NO_ISTG_COMMIT		((ULONG) 0x00000001)


/* NOTE: Property Attributes are specific to this IMessage on IStorage 		*/
/* implementation and are not a part of standard MAPI 1.0 property methods 	*/

/* Property Attributes */

#define PROPATTR_MANDATORY		((ULONG) 0x00000001)
#define PROPATTR_READABLE		((ULONG) 0x00000002)
#define PROPATTR_WRITEABLE		((ULONG) 0x00000004)

#define PROPATTR_NOT_PRESENT	((ULONG) 0x00000008)

/* Attribute Array */

typedef struct _SPropAttrArray
{
	ULONG	cValues;							
	ULONG	aPropAttr[MAPI_DIM];
} SPropAttrArray, FAR * LPSPropAttrArray;

#define CbNewSPropAttrArray(_cattr) \
	(offsetof(SPropAttrArray,aPropAttr) + (_cattr)*sizeof(ULONG))
#define CbSPropAttrArray(_lparray) \
	(offsetof(SPropAttrArray,aPropAttr) + \
	(UINT)((_lparray)->cValues)*sizeof(ULONG))

#define SizedSPropAttrArray(_cattr, _name) \
struct _SPropAttrArray_ ## _name \
{ \
	ULONG	cValues; \
	ULONG	aPropAttr[_cattr]; \
} _name



/*	GetAttribIMsgOnIStg - To get attributes on properties
 *
 *	This call is provided because there is no method of IMAPIPropSet to allow
 *	getting attributes.
 */
STDAPI GetAttribIMsgOnIStg(
	LPVOID					lpObject,
	LPSPropTagArray			lpPropTagArray,
	LPSPropAttrArray FAR 	*lppPropAttrArray );

/*	SetAttribIMsgOnIStg - To set attributes on properties
 *
 *	This call is provided because there is no method of IMAPIPropSet to allow
 *	setting of attributes.
 */
STDAPI SetAttribIMsgOnIStg(
	LPVOID					lpObject,
	LPSPropTagArray			lpPropTags,
	LPSPropAttrArray		lpPropAttrs,
	LPSPropProblemArray FAR	*lppPropProblems );

/*	MapStorageSCode - To map an IStorage hResult to a MAPI sCode value
 *
 *	This call is provided for the internal use of PDK components that base
 *	their message implementations on IMessage.  Since these components must
 *	open the storage themselves, there is a common need to map OLE 2.0
 *	Storage error returns to MAPI sCodes.
 *
 *	WARNING:	There is no guarantee that this entry point will exist in
 *	shipped versions of mapiu.dll.
 */
STDAPI_(SCODE) MapStorageSCode( SCODE StgSCode );


#ifdef __cplusplus
}
#endif

#endif	/* _IMESSAGE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\imm.h ===
/**********************************************************************/
/*      imm.h - Input Method Manager definitions                      */
/*                                                                    */
/*      Copyright (c) 1993-1998  Microsoft Corporation                */
/**********************************************************************/

#ifndef _IMM_
#define _IMM_


#ifdef __cplusplus
extern "C" {
#endif


#ifndef _IMM_SDK_DEFINED_
#define _IMM_SDK_DEFINED_

#if (WINVER >= 0x040A)
DECLARE_HANDLE(HIMC);
DECLARE_HANDLE(HIMCC);
#else
typedef DWORD   HIMC;
typedef DWORD   HIMCC;
#endif /* WINVER >= 0x040A */

typedef HKL FAR  *LPHKL;
typedef UINT FAR *LPUINT;

typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, NEAR *NPCOMPOSITIONFORM, FAR *LPCOMPOSITIONFORM;


typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, NEAR *NPCANDIDATEFORM, FAR *LPCANDIDATEFORM;


typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, NEAR *NPCANDIDATELIST, FAR *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA, NEAR *NPREGISTERWORDA, FAR *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW, NEAR *NPREGISTERWORDW, FAR *LPREGISTERWORDW;
#ifdef UNICODE
typedef REGISTERWORDW REGISTERWORD;
typedef PREGISTERWORDW PREGISTERWORD;
typedef NPREGISTERWORDW NPREGISTERWORD;
typedef LPREGISTERWORDW LPREGISTERWORD;
#else
typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#endif // UNICODE

#if (WINVER >= 0x040A)

typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING, NEAR *NPRECONVERTSTRING, FAR *LPRECONVERTSTRING;

#endif /* WINVER >= 0x040A */

#define STYLE_DESCRIPTION_SIZE  32

typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFA, *PSTYLEBUFA, NEAR *NPSTYLEBUFA, FAR *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFW, *PSTYLEBUFW, NEAR *NPSTYLEBUFW, FAR *LPSTYLEBUFW;
#ifdef UNICODE
typedef STYLEBUFW STYLEBUF;
typedef PSTYLEBUFW PSTYLEBUF;
typedef NPSTYLEBUFW NPSTYLEBUF;
typedef LPSTYLEBUFW LPSTYLEBUF;
#else
typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#endif // UNICODE


#if (WINVER >= 0x040A)

#define IMEMENUITEM_STRING_SIZE 80

typedef struct tagIMEMENUITEMINFOA {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    CHAR        szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, NEAR *NPIMEMENUITEMINFOA, FAR *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    WCHAR       szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, NEAR *NPIMEMENUITEMINFOW, FAR *LPIMEMENUITEMINFOW;
#ifdef UNICODE
typedef IMEMENUITEMINFOW IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOW PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOW NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOW LPIMEMENUITEMINFO;
#else
typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;
#endif // UNICODE

typedef struct tagIMECHARPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION, NEAR *NPIMECHARPOSITION, FAR *LPIMECHARPOSITION;

typedef BOOL    (CALLBACK* IMCENUMPROC)(HIMC, LPARAM);

#endif /* WINVER >= 0x040A */

// prototype of IMM API

HKL  WINAPI ImmInstallIMEA(IN LPCSTR lpszIMEFileName, IN LPCSTR lpszLayoutText);
HKL  WINAPI ImmInstallIMEW(IN LPCWSTR lpszIMEFileName, IN LPCWSTR lpszLayoutText);
#ifdef UNICODE
#define ImmInstallIME  ImmInstallIMEW
#else
#define ImmInstallIME  ImmInstallIMEA
#endif // !UNICODE

HWND WINAPI ImmGetDefaultIMEWnd(IN HWND);

UINT WINAPI ImmGetDescriptionA(IN HKL, OUT LPSTR, IN UINT uBufLen);
UINT WINAPI ImmGetDescriptionW(IN HKL, OUT LPWSTR, IN UINT uBufLen);
#ifdef UNICODE
#define ImmGetDescription  ImmGetDescriptionW
#else
#define ImmGetDescription  ImmGetDescriptionA
#endif // !UNICODE

UINT WINAPI ImmGetIMEFileNameA(IN HKL, OUT LPSTR, IN UINT uBufLen);
UINT WINAPI ImmGetIMEFileNameW(IN HKL, OUT LPWSTR, IN UINT uBufLen);
#ifdef UNICODE
#define ImmGetIMEFileName  ImmGetIMEFileNameW
#else
#define ImmGetIMEFileName  ImmGetIMEFileNameA
#endif // !UNICODE

DWORD WINAPI ImmGetProperty(IN HKL, IN DWORD);

BOOL WINAPI ImmIsIME(IN HKL);

BOOL WINAPI ImmSimulateHotKey(IN HWND, IN DWORD);

HIMC WINAPI ImmCreateContext(void);
BOOL WINAPI ImmDestroyContext(IN HIMC);
HIMC WINAPI ImmGetContext(IN HWND);
BOOL WINAPI ImmReleaseContext(IN HWND, IN HIMC);
HIMC WINAPI ImmAssociateContext(IN HWND, IN HIMC);
#if (WINVER >= 0x040A)
BOOL WINAPI ImmAssociateContextEx(IN HWND, IN HIMC, IN DWORD);
#endif /* WINVER >= 0x040A */

LONG  WINAPI ImmGetCompositionStringA(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
LONG  WINAPI ImmGetCompositionStringW(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
#ifdef UNICODE
#define ImmGetCompositionString  ImmGetCompositionStringW
#else
#define ImmGetCompositionString  ImmGetCompositionStringA
#endif // !UNICODE

BOOL  WINAPI ImmSetCompositionStringA(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);
BOOL  WINAPI ImmSetCompositionStringW(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);
#ifdef UNICODE
#define ImmSetCompositionString  ImmSetCompositionStringW
#else
#define ImmSetCompositionString  ImmSetCompositionStringA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListCountA(IN HIMC, OUT LPDWORD lpdwListCount);
DWORD WINAPI ImmGetCandidateListCountW(IN HIMC, OUT LPDWORD lpdwListCount);
#ifdef UNICODE
#define ImmGetCandidateListCount  ImmGetCandidateListCountW
#else
#define ImmGetCandidateListCount  ImmGetCandidateListCountA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListA(IN HIMC, IN DWORD deIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
DWORD WINAPI ImmGetCandidateListW(IN HIMC, IN DWORD deIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetCandidateList  ImmGetCandidateListW
#else
#define ImmGetCandidateList  ImmGetCandidateListA
#endif // !UNICODE

DWORD WINAPI ImmGetGuideLineA(IN HIMC, IN DWORD dwIndex, OUT LPSTR, IN DWORD dwBufLen);
DWORD WINAPI ImmGetGuideLineW(IN HIMC, IN DWORD dwIndex, OUT LPWSTR, IN DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetGuideLine  ImmGetGuideLineW
#else
#define ImmGetGuideLine  ImmGetGuideLineA
#endif // !UNICODE

BOOL WINAPI ImmGetConversionStatus(IN HIMC, OUT LPDWORD, OUT LPDWORD);
BOOL WINAPI ImmSetConversionStatus(IN HIMC, IN DWORD, IN DWORD);
BOOL WINAPI ImmGetOpenStatus(IN HIMC);
BOOL WINAPI ImmSetOpenStatus(IN HIMC, IN BOOL);

#if defined(_WINGDI_) && !defined(NOGDI)
BOOL WINAPI ImmGetCompositionFontA(IN HIMC, OUT LPLOGFONTA);
BOOL WINAPI ImmGetCompositionFontW(IN HIMC, OUT LPLOGFONTW);
#ifdef UNICODE
#define ImmGetCompositionFont  ImmGetCompositionFontW
#else
#define ImmGetCompositionFont  ImmGetCompositionFontA
#endif // !UNICODE

BOOL WINAPI ImmSetCompositionFontA(IN HIMC, IN LPLOGFONTA);
BOOL WINAPI ImmSetCompositionFontW(IN HIMC, IN LPLOGFONTW);
#ifdef UNICODE
#define ImmSetCompositionFont  ImmSetCompositionFontW
#else
#define ImmSetCompositionFont  ImmSetCompositionFontA
#endif // !UNICODE
#endif  // defined(_WINGDI_) && !defined(NOGDI)

BOOL    WINAPI ImmConfigureIMEA(IN HKL, IN HWND, IN DWORD, IN LPVOID);
BOOL    WINAPI ImmConfigureIMEW(IN HKL, IN HWND, IN DWORD, IN LPVOID);
#ifdef UNICODE
#define ImmConfigureIME  ImmConfigureIMEW
#else
#define ImmConfigureIME  ImmConfigureIMEA
#endif // !UNICODE

LRESULT WINAPI ImmEscapeA(IN HKL, IN HIMC, IN UINT, IN LPVOID);
LRESULT WINAPI ImmEscapeW(IN HKL, IN HIMC, IN UINT, IN LPVOID);
#ifdef UNICODE
#define ImmEscape  ImmEscapeW
#else
#define ImmEscape  ImmEscapeA
#endif // !UNICODE

DWORD   WINAPI ImmGetConversionListA(IN HKL, IN HIMC, IN LPCSTR, OUT LPCANDIDATELIST, IN DWORD dwBufLen, IN UINT uFlag);
DWORD   WINAPI ImmGetConversionListW(IN HKL, IN HIMC, IN LPCWSTR, OUT LPCANDIDATELIST, IN DWORD dwBufLen, IN UINT uFlag);
#ifdef UNICODE
#define ImmGetConversionList  ImmGetConversionListW
#else
#define ImmGetConversionList  ImmGetConversionListA
#endif // !UNICODE

BOOL    WINAPI ImmNotifyIME(IN HIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue);

BOOL WINAPI ImmGetStatusWindowPos(IN HIMC, OUT LPPOINT);
BOOL WINAPI ImmSetStatusWindowPos(IN HIMC, IN LPPOINT);
BOOL WINAPI ImmGetCompositionWindow(IN HIMC, OUT LPCOMPOSITIONFORM);
BOOL WINAPI ImmSetCompositionWindow(IN HIMC, IN LPCOMPOSITIONFORM);
BOOL WINAPI ImmGetCandidateWindow(IN HIMC, IN DWORD, OUT LPCANDIDATEFORM);
BOOL WINAPI ImmSetCandidateWindow(IN HIMC, IN LPCANDIDATEFORM);

BOOL WINAPI ImmIsUIMessageA(IN HWND, IN UINT, IN WPARAM, IN LPARAM);
BOOL WINAPI ImmIsUIMessageW(IN HWND, IN UINT, IN WPARAM, IN LPARAM);
#ifdef UNICODE
#define ImmIsUIMessage  ImmIsUIMessageW
#else
#define ImmIsUIMessage  ImmIsUIMessageA
#endif // !UNICODE


UINT WINAPI ImmGetVirtualKey(IN HWND);

typedef int (CALLBACK *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int (CALLBACK *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCW
#else
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCA
#endif // !UNICODE

BOOL WINAPI ImmRegisterWordA(IN HKL, IN LPCSTR lpszReading, IN DWORD, IN LPCSTR lpszRegister);
BOOL WINAPI ImmRegisterWordW(IN HKL, IN LPCWSTR lpszReading, IN DWORD, IN LPCWSTR lpszRegister);
#ifdef UNICODE
#define ImmRegisterWord  ImmRegisterWordW
#else
#define ImmRegisterWord  ImmRegisterWordA
#endif // !UNICODE

BOOL WINAPI ImmUnregisterWordA(IN HKL, IN LPCSTR lpszReading, IN DWORD, IN LPCSTR lpszUnregister);
BOOL WINAPI ImmUnregisterWordW(IN HKL, IN LPCWSTR lpszReading, IN DWORD, IN LPCWSTR lpszUnregister);
#ifdef UNICODE
#define ImmUnregisterWord  ImmUnregisterWordW
#else
#define ImmUnregisterWord  ImmUnregisterWordA
#endif // !UNICODE

UINT WINAPI ImmGetRegisterWordStyleA(IN HKL, IN UINT nItem, OUT LPSTYLEBUFA);
UINT WINAPI ImmGetRegisterWordStyleW(IN HKL, IN UINT nItem, OUT LPSTYLEBUFW);
#ifdef UNICODE
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleW
#else
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleA
#endif // !UNICODE

UINT WINAPI ImmEnumRegisterWordA(IN HKL, IN REGISTERWORDENUMPROCA, IN LPCSTR lpszReading, IN DWORD, IN LPCSTR lpszRegister, IN LPVOID);
UINT WINAPI ImmEnumRegisterWordW(IN HKL, IN REGISTERWORDENUMPROCW, IN LPCWSTR lpszReading, IN DWORD, IN LPCWSTR lpszRegister, IN LPVOID);
#ifdef UNICODE
#define ImmEnumRegisterWord  ImmEnumRegisterWordW
#else
#define ImmEnumRegisterWord  ImmEnumRegisterWordA
#endif // !UNICODE

#if (WINVER >= 0x040A)
BOOL WINAPI ImmDisableIME(IN DWORD);
BOOL WINAPI ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
DWORD WINAPI ImmGetImeMenuItemsA(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOA, OUT LPIMEMENUITEMINFOA, IN DWORD);
DWORD WINAPI ImmGetImeMenuItemsW(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOW, OUT LPIMEMENUITEMINFOW, IN DWORD);
#ifdef UNICODE
#define ImmGetImeMenuItems  ImmGetImeMenuItemsW
#else
#define ImmGetImeMenuItems  ImmGetImeMenuItemsA
#endif // !UNICODE
#endif /* WINVER >= 0x040A */

// wParam for WM_IME_CONTROL
#define IMC_GETCANDIDATEPOS             0x0007
#define IMC_SETCANDIDATEPOS             0x0008
#define IMC_GETCOMPOSITIONFONT          0x0009
#define IMC_SETCOMPOSITIONFONT          0x000A
#define IMC_GETCOMPOSITIONWINDOW        0x000B
#define IMC_SETCOMPOSITIONWINDOW        0x000C
#define IMC_GETSTATUSWINDOWPOS          0x000F
#define IMC_SETSTATUSWINDOWPOS          0x0010
#define IMC_CLOSESTATUSWINDOW           0x0021
#define IMC_OPENSTATUSWINDOW            0x0022


// dwAction for ImmNotifyIME
#define NI_OPENCANDIDATE                0x0010
#define NI_CLOSECANDIDATE               0x0011
#define NI_SELECTCANDIDATESTR           0x0012
#define NI_CHANGECANDIDATELIST          0x0013
#define NI_FINALIZECONVERSIONRESULT     0x0014
#define NI_COMPOSITIONSTR               0x0015
#define NI_SETCANDIDATE_PAGESTART       0x0016
#define NI_SETCANDIDATE_PAGESIZE        0x0017
#define NI_IMEMENUSELECTED              0x0018

// lParam for WM_IME_SETCONTEXT
#define ISC_SHOWUICANDIDATEWINDOW       0x00000001
#define ISC_SHOWUICOMPOSITIONWINDOW     0x80000000
#define ISC_SHOWUIGUIDELINE             0x40000000
#define ISC_SHOWUIALLCANDIDATEWINDOW    0x0000000F
#define ISC_SHOWUIALL                   0xC000000F


// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR
#define CPS_COMPLETE                    0x0001
#define CPS_CONVERT                     0x0002
#define CPS_REVERT                      0x0003
#define CPS_CANCEL                      0x0004

// the modifiers of hot key
#define MOD_ALT                         0x0001
#define MOD_CONTROL                     0x0002
#define MOD_SHIFT                       0x0004

#define MOD_LEFT                        0x8000
#define MOD_RIGHT                       0x4000

#define MOD_ON_KEYUP                    0x0800
#define MOD_IGNORE_ALL_MODIFIER         0x0400

// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
#define IME_CHOTKEY_IME_NONIME_TOGGLE           0x10
#define IME_CHOTKEY_SHAPE_TOGGLE                0x11
#define IME_CHOTKEY_SYMBOL_TOGGLE               0x12

// Windows for Japanese Edition hot key ID from 0x30 - 0x4F
#define IME_JHOTKEY_CLOSE_OPEN                  0x30

// Windows for Korean Edition hot key ID from 0x50 - 0x6F
#define IME_KHOTKEY_SHAPE_TOGGLE                0x50
#define IME_KHOTKEY_HANJACONVERT                0x51
#define IME_KHOTKEY_ENGLISH                     0x52

// Windows for Traditional Chinese Edition hot key ID from 0x70 - 0x8F
#define IME_THOTKEY_IME_NONIME_TOGGLE           0x70
#define IME_THOTKEY_SHAPE_TOGGLE                0x71
#define IME_THOTKEY_SYMBOL_TOGGLE               0x72

// direct switch hot key ID from 0x100 - 0x11F
#define IME_HOTKEY_DSWITCH_FIRST                0x100
#define IME_HOTKEY_DSWITCH_LAST                 0x11F

// IME private hot key from 0x200 - 0x21F
#define IME_HOTKEY_PRIVATE_FIRST                0x200
#define IME_ITHOTKEY_RESEND_RESULTSTR           0x200
#define IME_ITHOTKEY_PREVIOUS_COMPOSITION       0x201
#define IME_ITHOTKEY_UISTYLE_TOGGLE             0x202
#define IME_ITHOTKEY_RECONVERTSTRING            0x203
#define IME_HOTKEY_PRIVATE_LAST                 0x21F


// parameter of ImmGetCompositionString
#define GCS_COMPREADSTR                 0x0001
#define GCS_COMPREADATTR                0x0002
#define GCS_COMPREADCLAUSE              0x0004
#define GCS_COMPSTR                     0x0008
#define GCS_COMPATTR                    0x0010
#define GCS_COMPCLAUSE                  0x0020
#define GCS_CURSORPOS                   0x0080
#define GCS_DELTASTART                  0x0100
#define GCS_RESULTREADSTR               0x0200
#define GCS_RESULTREADCLAUSE            0x0400
#define GCS_RESULTSTR                   0x0800
#define GCS_RESULTCLAUSE                0x1000

// style bit flags for WM_IME_COMPOSITION
#define CS_INSERTCHAR                   0x2000
#define CS_NOMOVECARET                  0x4000

// IME version constants
#define IMEVER_0310                     0x0003000A
#define IMEVER_0400                     0x00040000


// IME property bits
#define IME_PROP_AT_CARET               0x00010000
#define IME_PROP_SPECIAL_UI             0x00020000
#define IME_PROP_CANDLIST_START_FROM_1  0x00040000
#define IME_PROP_UNICODE                0x00080000
#define IME_PROP_COMPLETE_ON_UNSELECT   0x00100000


// IME UICapability bits
#define UI_CAP_2700                     0x00000001
#define UI_CAP_ROT90                    0x00000002
#define UI_CAP_ROTANY                   0x00000004

// ImmSetCompositionString Capability bits
#define SCS_CAP_COMPSTR                 0x00000001
#define SCS_CAP_MAKEREAD                0x00000002
#define SCS_CAP_SETRECONVERTSTRING      0x00000004


// IME WM_IME_SELECT inheritance Capability bits
#define SELECT_CAP_CONVERSION           0x00000001
#define SELECT_CAP_SENTENCE             0x00000002


// ID for deIndex of ImmGetGuideLine
#define GGL_LEVEL                       0x00000001
#define GGL_INDEX                       0x00000002
#define GGL_STRING                      0x00000003
#define GGL_PRIVATE                     0x00000004


// ID for dwLevel of GUIDELINE Structure
#define GL_LEVEL_NOGUIDELINE            0x00000000
#define GL_LEVEL_FATAL                  0x00000001
#define GL_LEVEL_ERROR                  0x00000002
#define GL_LEVEL_WARNING                0x00000003
#define GL_LEVEL_INFORMATION            0x00000004


// ID for dwIndex of GUIDELINE Structure
#define GL_ID_UNKNOWN                   0x00000000
#define GL_ID_NOMODULE                  0x00000001
#define GL_ID_NODICTIONARY              0x00000010
#define GL_ID_CANNOTSAVE                0x00000011
#define GL_ID_NOCONVERT                 0x00000020
#define GL_ID_TYPINGERROR               0x00000021
#define GL_ID_TOOMANYSTROKE             0x00000022
#define GL_ID_READINGCONFLICT           0x00000023
#define GL_ID_INPUTREADING              0x00000024
#define GL_ID_INPUTRADICAL              0x00000025
#define GL_ID_INPUTCODE                 0x00000026
#define GL_ID_INPUTSYMBOL               0x00000027
#define GL_ID_CHOOSECANDIDATE           0x00000028
#define GL_ID_REVERSECONVERSION         0x00000029
#define GL_ID_PRIVATE_FIRST             0x00008000
#define GL_ID_PRIVATE_LAST              0x0000FFFF


// ID for dwIndex of ImmGetProperty
#define IGP_GETIMEVERSION               (DWORD)(-4)
#define IGP_PROPERTY                    0x00000004
#define IGP_CONVERSION                  0x00000008
#define IGP_SENTENCE                    0x0000000c
#define IGP_UI                          0x00000010
#define IGP_SETCOMPSTR                  0x00000014
#define IGP_SELECT                      0x00000018

// dwIndex for ImmSetCompositionString API
#define SCS_SETSTR                      (GCS_COMPREADSTR|GCS_COMPSTR)
#define SCS_CHANGEATTR                  (GCS_COMPREADATTR|GCS_COMPATTR)
#define SCS_CHANGECLAUSE                (GCS_COMPREADCLAUSE|GCS_COMPCLAUSE)
#define SCS_SETRECONVERTSTRING          0x00010000
#define SCS_QUERYRECONVERTSTRING        0x00020000

// attribute for COMPOSITIONSTRING Structure
#define ATTR_INPUT                      0x00
#define ATTR_TARGET_CONVERTED           0x01
#define ATTR_CONVERTED                  0x02
#define ATTR_TARGET_NOTCONVERTED        0x03
#define ATTR_INPUT_ERROR                0x04
#define ATTR_FIXEDCONVERTED             0x05

// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_DEFAULT                     0x0000
#define CFS_RECT                        0x0001
#define CFS_POINT                       0x0002
#define CFS_FORCE_POSITION              0x0020
#define CFS_CANDIDATEPOS                0x0040
#define CFS_EXCLUDE                     0x0080

// conversion direction for ImmGetConversionList
#define GCL_CONVERSION                  0x0001
#define GCL_REVERSECONVERSION           0x0002
#define GCL_REVERSE_LENGTH              0x0003

// bit field for conversion mode
#define IME_CMODE_ALPHANUMERIC          0x0000
#define IME_CMODE_NATIVE                0x0001
#define IME_CMODE_CHINESE               IME_CMODE_NATIVE
// IME_CMODE_HANGEUL is old name of IME_CMODE_HANGUL. It will be gone eventually.
#define IME_CMODE_HANGEUL               IME_CMODE_NATIVE
#define IME_CMODE_HANGUL                IME_CMODE_NATIVE
#define IME_CMODE_JAPANESE              IME_CMODE_NATIVE
#define IME_CMODE_KATAKANA              0x0002  // only effect under IME_CMODE_NATIVE
#define IME_CMODE_LANGUAGE              0x0003
#define IME_CMODE_FULLSHAPE             0x0008
#define IME_CMODE_ROMAN                 0x0010
#define IME_CMODE_CHARCODE              0x0020
#define IME_CMODE_HANJACONVERT          0x0040
#define IME_CMODE_SOFTKBD               0x0080
#define IME_CMODE_NOCONVERSION          0x0100
#define IME_CMODE_EUDC                  0x0200
#define IME_CMODE_SYMBOL                0x0400
#define IME_CMODE_FIXED                 0x0800

// bit field for sentence mode
#define IME_SMODE_NONE                  0x0000
#define IME_SMODE_PLAURALCLAUSE         0x0001
#define IME_SMODE_SINGLECONVERT         0x0002
#define IME_SMODE_AUTOMATIC             0x0004
#define IME_SMODE_PHRASEPREDICT         0x0008
#define IME_SMODE_CONVERSATION          0x0010

// style of candidate
#define IME_CAND_UNKNOWN                0x0000
#define IME_CAND_READ                   0x0001
#define IME_CAND_CODE                   0x0002
#define IME_CAND_MEANING                0x0003
#define IME_CAND_RADICAL                0x0004
#define IME_CAND_STROKE                 0x0005

// wParam of report message WM_IME_NOTIFY
#define IMN_CLOSESTATUSWINDOW           0x0001
#define IMN_OPENSTATUSWINDOW            0x0002
#define IMN_CHANGECANDIDATE             0x0003
#define IMN_CLOSECANDIDATE              0x0004
#define IMN_OPENCANDIDATE               0x0005
#define IMN_SETCONVERSIONMODE           0x0006
#define IMN_SETSENTENCEMODE             0x0007
#define IMN_SETOPENSTATUS               0x0008
#define IMN_SETCANDIDATEPOS             0x0009
#define IMN_SETCOMPOSITIONFONT          0x000A
#define IMN_SETCOMPOSITIONWINDOW        0x000B
#define IMN_SETSTATUSWINDOWPOS          0x000C
#define IMN_GUIDELINE                   0x000D
#define IMN_PRIVATE                     0x000E

#if (WINVER >= 0x040A)
// wParam of report message WM_IME_REQUEST
#define IMR_COMPOSITIONWINDOW           0x0001
#define IMR_CANDIDATEWINDOW             0x0002
#define IMR_COMPOSITIONFONT             0x0003
#define IMR_RECONVERTSTRING             0x0004
#define IMR_CONFIRMRECONVERTSTRING      0x0005
#define IMR_QUERYCHARPOSITION           0x0006
#define IMR_DOCUMENTFEED                0x0007
#endif /* WINVER >= 0x040A */

// error code of ImmGetCompositionString
#define IMM_ERROR_NODATA                (-1)
#define IMM_ERROR_GENERAL               (-2)


// dialog mode of ImmConfigureIME
#define IME_CONFIG_GENERAL              1
#define IME_CONFIG_REGISTERWORD         2
#define IME_CONFIG_SELECTDICTIONARY     3


// flags for ImmEscape
#define IME_ESC_QUERY_SUPPORT           0x0003
#define IME_ESC_RESERVED_FIRST          0x0004
#define IME_ESC_RESERVED_LAST           0x07FF
#define IME_ESC_PRIVATE_FIRST           0x0800
#define IME_ESC_PRIVATE_LAST            0x0FFF

#define IME_ESC_SEQUENCE_TO_INTERNAL    0x1001
#define IME_ESC_GET_EUDC_DICTIONARY     0x1003
#define IME_ESC_SET_EUDC_DICTIONARY     0x1004
#define IME_ESC_MAX_KEY                 0x1005
#define IME_ESC_IME_NAME                0x1006
#define IME_ESC_SYNC_HOTKEY             0x1007
#define IME_ESC_HANJA_MODE              0x1008
#define IME_ESC_AUTOMATA                0x1009
#define IME_ESC_PRIVATE_HOTKEY          0x100a
#define IME_ESC_GETHELPFILENAME         0x100b
// style of word registration
#define IME_REGWORD_STYLE_EUDC          0x00000001
#define IME_REGWORD_STYLE_USER_FIRST    0x80000000
#define IME_REGWORD_STYLE_USER_LAST     0xFFFFFFFF


#if (WINVER >= 0x040A)

// dwFlags for ImmAssociateContextEx
#define IACE_CHILDREN                   0x0001
#define IACE_DEFAULT                    0x0010
#define IACE_IGNORENOCONTEXT            0x0020

// dwFlags for ImmGetImeMenuItems
#define IGIMIF_RIGHTMENU                0x0001

// dwType for ImmGetImeMenuItems
#define IGIMII_CMODE                    0x0001
#define IGIMII_SMODE                    0x0002
#define IGIMII_CONFIGURE                0x0004
#define IGIMII_TOOLS                    0x0008
#define IGIMII_HELP                     0x0010
#define IGIMII_OTHER                    0x0020
#define IGIMII_INPUTTOOLS               0x0040

// fType of IMEMENUITEMINFO structure
#define IMFT_RADIOCHECK 0x00001
#define IMFT_SEPARATOR  0x00002
#define IMFT_SUBMENU    0x00004

// fState of IMEMENUITEMINFO structure
#define IMFS_GRAYED          MFS_GRAYED
#define IMFS_DISABLED        MFS_DISABLED
#define IMFS_CHECKED         MFS_CHECKED
#define IMFS_HILITE          MFS_HILITE
#define IMFS_ENABLED         MFS_ENABLED
#define IMFS_UNCHECKED       MFS_UNCHECKED
#define IMFS_UNHILITE        MFS_UNHILITE
#define IMFS_DEFAULT         MFS_DEFAULT

#endif /* WINVER >= 0x040A */

// type of soft keyboard
// for Windows Tranditional Chinese Edition
#define SOFTKEYBOARD_TYPE_T1            0x0001
// for Windows Simplified Chinese Edition
#define SOFTKEYBOARD_TYPE_C1            0x0002


#endif  // _IMM_SDK_DEFINED_

#ifdef __cplusplus
}
#endif

#endif  // _IMM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\imonitor.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Nov 19 19:26:51 1998
 */
/* Compiler settings for imonitor.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imonitor_h__
#define __imonitor_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMonitor_FWD_DEFINED__
#define __IMonitor_FWD_DEFINED__
typedef interface IMonitor IMonitor;
#endif 	/* __IMonitor_FWD_DEFINED__ */


#ifndef __IMonitorEventer_FWD_DEFINED__
#define __IMonitorEventer_FWD_DEFINED__
typedef interface IMonitorEventer IMonitorEventer;
#endif 	/* __IMonitorEventer_FWD_DEFINED__ */


/* header files for imported files */
#include "nmevent.h"
#include "nmMCS.h"
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IMonitor_INTERFACE_DEFINED__
#define __IMonitor_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMonitor
 * at Thu Nov 19 19:26:51 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local][unique][uuid][object] */ 



EXTERN_C const IID IID_IMonitor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("B22A7F70-9398-11d1-A5D6-00A024BA4B62")
    IMonitor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoInitialize( 
            /* [in] */ IUnknown __RPC_FAR *pUnkMonitorCtrl,
            /* [out][in] */ HBLOB hNPPBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoConfigure( 
            /* [in] */ char __RPC_FAR *pName,
            /* [in] */ char __RPC_FAR *pConfiguration,
            /* [out] */ char __RPC_FAR *__RPC_FAR *ppScriptInstance) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStart( 
            /* [in] */ IUnknown __RPC_FAR *pUnkNPP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFrames( 
            /* [in] */ UPDATE_EVENT Event) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ UPDATE_EVENT Event) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMonitorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMonitor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMonitor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMonitor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoInitialize )( 
            IMonitor __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkMonitorCtrl,
            /* [out][in] */ HBLOB hNPPBlob);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoConfigure )( 
            IMonitor __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *pName,
            /* [in] */ char __RPC_FAR *pConfiguration,
            /* [out] */ char __RPC_FAR *__RPC_FAR *ppScriptInstance);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStart )( 
            IMonitor __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkNPP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStop )( 
            IMonitor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnFrames )( 
            IMonitor __RPC_FAR * This,
            /* [in] */ UPDATE_EVENT Event);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IMonitor __RPC_FAR * This,
            /* [in] */ UPDATE_EVENT Event);
        
        END_INTERFACE
    } IMonitorVtbl;

    interface IMonitor
    {
        CONST_VTBL struct IMonitorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMonitor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMonitor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMonitor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMonitor_DoInitialize(This,pUnkMonitorCtrl,hNPPBlob)	\
    (This)->lpVtbl -> DoInitialize(This,pUnkMonitorCtrl,hNPPBlob)

#define IMonitor_DoConfigure(This,pName,pConfiguration,ppScriptInstance)	\
    (This)->lpVtbl -> DoConfigure(This,pName,pConfiguration,ppScriptInstance)

#define IMonitor_OnStart(This,pUnkNPP)	\
    (This)->lpVtbl -> OnStart(This,pUnkNPP)

#define IMonitor_OnStop(This)	\
    (This)->lpVtbl -> OnStop(This)

#define IMonitor_OnFrames(This,Event)	\
    (This)->lpVtbl -> OnFrames(This,Event)

#define IMonitor_OnStatus(This,Event)	\
    (This)->lpVtbl -> OnStatus(This,Event)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMonitor_DoInitialize_Proxy( 
    IMonitor __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkMonitorCtrl,
    /* [out][in] */ HBLOB hNPPBlob);


void __RPC_STUB IMonitor_DoInitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMonitor_DoConfigure_Proxy( 
    IMonitor __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *pName,
    /* [in] */ char __RPC_FAR *pConfiguration,
    /* [out] */ char __RPC_FAR *__RPC_FAR *ppScriptInstance);


void __RPC_STUB IMonitor_DoConfigure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMonitor_OnStart_Proxy( 
    IMonitor __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkNPP);


void __RPC_STUB IMonitor_OnStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMonitor_OnStop_Proxy( 
    IMonitor __RPC_FAR * This);


void __RPC_STUB IMonitor_OnStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMonitor_OnFrames_Proxy( 
    IMonitor __RPC_FAR * This,
    /* [in] */ UPDATE_EVENT Event);


void __RPC_STUB IMonitor_OnFrames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMonitor_OnStatus_Proxy( 
    IMonitor __RPC_FAR * This,
    /* [in] */ UPDATE_EVENT Event);


void __RPC_STUB IMonitor_OnStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMonitor_INTERFACE_DEFINED__ */


#ifndef __IMonitorEventer_INTERFACE_DEFINED__
#define __IMonitorEventer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMonitorEventer
 * at Thu Nov 19 19:26:51 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local][unique][uuid][object] */ 



EXTERN_C const IID IID_IMonitorEventer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7390CC40-95D8-11d1-A5D8-00A024BA4B62")
    IMonitorEventer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEventData( 
            /* [in] */ BYTE bNumColumns,
            /* [out] */ PNMEVENTDATA __RPC_FAR *ppNMEventData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendNMEvent( 
            /* [in] */ PNMEVENTDATA pNMEventData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeEventData( 
            /* [in] */ PNMEVENTDATA pNMEventData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMonitorEventerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMonitorEventer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMonitorEventer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMonitorEventer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEventData )( 
            IMonitorEventer __RPC_FAR * This,
            /* [in] */ BYTE bNumColumns,
            /* [out] */ PNMEVENTDATA __RPC_FAR *ppNMEventData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendNMEvent )( 
            IMonitorEventer __RPC_FAR * This,
            /* [in] */ PNMEVENTDATA pNMEventData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeEventData )( 
            IMonitorEventer __RPC_FAR * This,
            /* [in] */ PNMEVENTDATA pNMEventData);
        
        END_INTERFACE
    } IMonitorEventerVtbl;

    interface IMonitorEventer
    {
        CONST_VTBL struct IMonitorEventerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMonitorEventer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMonitorEventer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMonitorEventer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMonitorEventer_GetEventData(This,bNumColumns,ppNMEventData)	\
    (This)->lpVtbl -> GetEventData(This,bNumColumns,ppNMEventData)

#define IMonitorEventer_SendNMEvent(This,pNMEventData)	\
    (This)->lpVtbl -> SendNMEvent(This,pNMEventData)

#define IMonitorEventer_FreeEventData(This,pNMEventData)	\
    (This)->lpVtbl -> FreeEventData(This,pNMEventData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMonitorEventer_GetEventData_Proxy( 
    IMonitorEventer __RPC_FAR * This,
    /* [in] */ BYTE bNumColumns,
    /* [out] */ PNMEVENTDATA __RPC_FAR *ppNMEventData);


void __RPC_STUB IMonitorEventer_GetEventData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMonitorEventer_SendNMEvent_Proxy( 
    IMonitorEventer __RPC_FAR * This,
    /* [in] */ PNMEVENTDATA pNMEventData);


void __RPC_STUB IMonitorEventer_SendNMEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMonitorEventer_FreeEventData_Proxy( 
    IMonitorEventer __RPC_FAR * This,
    /* [in] */ PNMEVENTDATA pNMEventData);


void __RPC_STUB IMonitorEventer_FreeEventData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMonitorEventer_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_imonitor_0140
 * at Thu Nov 19 19:26:51 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


__MIDL_DECLSPEC_DLLEXPORT HRESULT DllGetMonitorObject( 
    REFIID riid,
    LPVOID __RPC_FAR *ppObj);

__MIDL_DECLSPEC_DLLEXPORT HRESULT OnLoadingDLL( 
    HBLOB hFilterBlob,
    DWORD __RPC_FAR *pCreateFlags,
    char __RPC_FAR *__RPC_FAR *ppDefaultName,
    char __RPC_FAR *__RPC_FAR *ppDescription,
    char __RPC_FAR *__RPC_FAR *ppDefaultScript,
    char __RPC_FAR *__RPC_FAR *ppDefaultConfiguration);



extern RPC_IF_HANDLE __MIDL_itf_imonitor_0140_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imonitor_0140_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\initoid.h ===
/*
 *  I N I T O I D . H
 *
 *  Define macros to be used for initializing MAPI OID's
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#define MAPI_PREFIX         0x2A,0x86,0x48,0x86,0xf7,0x14,0x03

#ifdef _MAC
#undef  DEFINE_OID_1
#define DEFINE_OID_1(name, b0, b1) \
    EXTERN_C const BYTE name[] = { MAPI_PREFIX, b0, b1 }

#undef  DEFINE_OID_2
#define DEFINE_OID_2(name, b0, b1, b2) \
    EXTERN_C const BYTE name[] = { MAPI_PREFIX, b0, b1, b2 }

#undef  DEFINE_OID_3
#define DEFINE_OID_3(name, b0, b1, b2, b3) \
    EXTERN_C const BYTE name[] = { MAPI_PREFIX, b0, b1, b2, b3 }

#undef  DEFINE_OID_4
#define DEFINE_OID_4(name, b0, b1, b2, b3, b4) \
    EXTERN_C const BYTE name[] = { MAPI_PREFIX, b0, b1, b2, b3, b4 }
#else
#undef  DEFINE_OID_1
#define DEFINE_OID_1(name, b0, b1) \
    EXTERN_C const BYTE __based(__segname("_CODE")) name[] =\
        { MAPI_PREFIX, b0, b1 }

#undef  DEFINE_OID_2
#define DEFINE_OID_2(name, b0, b1, b2) \
    EXTERN_C const BYTE __based(__segname("_CODE")) name[] =\
        { MAPI_PREFIX, b0, b1, b2 }

#undef  DEFINE_OID_3
#define DEFINE_OID_3(name, b0, b1, b2, b3) \
    EXTERN_C const BYTE __based(__segname("_CODE")) name[] =\
        { MAPI_PREFIX, b0, b1, b2, b3 }

#undef  DEFINE_OID_4
#define DEFINE_OID_4(name, b0, b1, b2, b3, b4) \
    EXTERN_C const BYTE __based(__segname("_CODE")) name[] =\
        { MAPI_PREFIX, b0, b1, b2, b3, b4 }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\initguid.h ===
/*****************************************************************************\
*                                                                             *
* initguid.h -  Definitions for controlling GUID initialization               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1999, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#define INITGUID
#include <guiddef.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\inetreg.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1998               **
//*********************************************************************

//
//      INETREG.H - String literals for HKEYs in registry
//

#ifndef _INETREGSTRS_H_
#define _INETREGSTRS_H_


//
// HKEY: HKEY_CURRENT_USER
//

//
// Top level defines
//
#define TSZMICROSOFTPATH                  TEXT("Software\\Microsoft")
#define TSZIEPATH        TSZMICROSOFTPATH TEXT("\\Internet Explorer")
#define TSZWINCURVERPATH TSZMICROSOFTPATH TEXT("\\windows\\CurrentVersion")
#define TSZWININETPATH   TSZWINCURVERPATH TEXT("\\Internet Settings")

// Windows : HKLM
#define REGSTR_PATH_RUNONCE_KEY TSZWINCURVERPATH TEXT("\\RunOnce")

// INETCPL : HKLM
#define REGSTR_PATH_INETCPL_PS_EXTENTIONS TSZWINCURVERPATH TEXT("\\Controls Folder\\Internet")

//
// Explorer : HKCU
//
#define REGSTR_PATH_IEXPLORER           TSZIEPATH

// Main
#define SZ_IE_MAIN                      "Main"
#define REGSTR_PATH_MAIN                TSZIEPATH TEXT( "\\") TEXT(SZ_IE_MAIN)
#define REGSTR_KEY_MAIN                 TEXT(SZ_IE_MAIN)

#define REGSTR_VAL_SMOOTHSCROLL         TEXT("SmoothScroll")
#define REGSTR_VAL_SMOOTHSCROLL_DEF     TRUE

#define REGSTR_VAL_SHOWTOOLBAR          TEXT("Show_ToolBar")
#define REGSTR_VAL_SHOWADDRESSBAR       TEXT("Show_URLToolBar")
#define REGSTR_VAL_STARTPAGE            TEXT("Start Page")
#define REGSTRA_VAL_STARTPAGE           "Start Page"
#define REGSTR_VAL_SEARCHPAGE           TEXT("Search Page")
#define REGSTR_VAL_LOCALPAGE            TEXT("Local Page")

#define REGSTR_VAL_USESTYLESHEETS       TEXT("Use Stylesheets")
#define REGSTR_VAL_USESTYLESHEETS_TYPE  REG_SZ  // "yes" or "no"
#define REGSTR_VAL_USESTYLESHEETS_DEF   TEXT("yes")

#define REGSTR_VAL_USEICM               TEXT("UseICM")
#define REGSTR_VAL_USEICM_DEF           FALSE

#define REGSTR_VAL_SHOWFOCUS            TEXT("Tabstop - MouseDown")
#define REGSTR_VAL_SHOWFOCUS_TYPE       REG_SZ  // "yes" or "no"
#define REGSTR_VAL_SHOWFOCUS_DEF        TEXT("no")

#define REGSTR_VAL_LOADIMAGES           TEXT("Display Inline Images")
#define REGSTR_VAL_PLAYSOUNDS           TEXT("Play_Background_Sounds")
#define REGSTR_VAL_PLAYVIDEOS           TEXT("Display Inline Videos")
#define REGSTR_VAL_ANCHORUNDERLINE      TEXT("Anchor Underline")
#define REGSTR_VAL_USEDLGCOLORS         TEXT("Use_DlgBox_Colors")
#define REGSTR_VAL_CHECKASSOC           TEXT("Check_Associations")
#define REGSTR_VAL_SHOWFULLURLS         TEXT("Show_FullURL")
#define REGSTR_VAL_AUTOSEARCH           TEXT("Do404Search")
#define REGSTR_VAL_AUTONAVIGATE         TEXT("SearchForExtensions")
#define REGSTR_VAL_HTTP_ERRORS TEXT("Friendly http errors")

#define REGSTR_VAL_PAGETRANSITIONS      TEXT("Page_Transitions")
#define REGSTR_VAL_PAGETRANSITIONS_DEF  TRUE

// Settings
#define SZ_IE_SETTINGS  "Settings"
#define REGSTR_PATH_IE_SETTINGS         TSZIEPATH TEXT("\\") TEXT(SZ_IE_SETTINGS)
#define REGSTR_KEY_IE_SETTINGS          TEXT(SZ_IE_SETTINGS)

#define REGSTR_VAL_IE_CUSTOMCOLORS      TEXT("Custom Colors")
#define REGSTR_VAL_IE_CUSTOMCOLORS_TYPE REG_BINARY

#define REGSTR_VAL_ANCHORCOLOR          TEXT("Anchor Color")
#define REGSTR_VAL_ANCHORCOLORVISITED   TEXT("Anchor Color Visited")
#define REGSTR_VAL_BACKGROUNDCOLOR      TEXT("Background Color")
#define REGSTR_VAL_TEXTCOLOR            TEXT("Text Color")
#define REGSTR_VAL_ANCHORCOLORHOVER     TEXT("Anchor Color Hover")
#define REGSTR_VAL_USEHOVERCOLOR        TEXT("Use Anchor Hover Color")

// Security
#define SZ_IE_SECURITY  "Security"
#define REGSTR_PATH_IE_SECURITY         TSZIEPATH TEXT("\\") TEXT(SZ_IE_SECURITY)
#define REGSTR_KEY_IE_SECURITY          TEXT(SZ_IE_SECURITY)

#define REGSTR_VAL_SAFETYWARNINGLEVEL   TEXT("Safety Warning Level")

// HTML Editing
#define SZ_IE_DEFAULT_HTML_EDITOR  "Default HTML Editor"
#define REGSTR_PATH_DEFAULT_HTML_EDITOR TSZIEPATH TEXT("\\") TEXT(SZ_IE_DEFAULT_HTML_EDITOR)
#define REGSTR_KEY_DEFAULT_HTML_EDITOR  TEXT(SZ_IE_DEFAULT_HTML_EDITOR)

// Autocomplete
#define REGSTR_PATH_AUTOCOMPLETE        TSZWINCURVERPATH TEXT("\\Explorer\\AutoComplete")
#define REGSTR_VAL_USEAUTOAPPEND        TEXT("Append Completion")
#define REGSTR_VAL_USEAUTOSUGGEST       TEXT("AutoSuggest")

// Old IE4 autocomplete key
#define REGSTR_VAL_USEAUTOCOMPLETE         TEXT("Use AutoComplete")


//
// Internet : HKCU
//
// path to global internet settings (also under HKEY_CURRENT_USER)
#define REGSTR_PATH_INTERNETSETTINGS    TSZWININETPATH
#define REGSTR_PATH_INTERNET_SETTINGS   REGSTR_PATH_INTERNETSETTINGS

#define REGSTR_VAL_USERAGENT            TEXT("User Agent")

// path to lan-specific settings
#define REGSTR_PATH_INTERNET_LAN_SETTINGS REGSTR_PATH_INTERNETSETTINGS TEXT("\\LAN")

// string value under HKCU\REGSTR_PATH_REMOTEACCESS that contains name of
// connectoid used to connect to internet
#define REGSTR_VAL_INTERNETENTRY        TEXT("InternetProfile")
#define REGSTR_VAL_INTERNETPROFILE      REGSTR_VAL_INTERNETENTRY

#define REGSTR_VAL_INTERNETENTRYBKUP    TEXT("BackupInternetProfile")

#define REGSTR_VAL_CODEDOWNLOAD         TEXT("Code Download")
#define REGSTR_VAL_CODEDOWNLOAD_DEF     TEXT("yes")
#define REGSTR_VAL_CODEDOWNLOAD_TYPE    REG_SZ // "yes" or "no"

// policy key for inetcpl restrictions

#define REGSTR_PATH_INETCPL_RESTRICTIONS  TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")

// reg valuenames to restrict whether a tab should be shown or not;
// a value of non-zero means don't show that tab.
// reg key: HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel
#define REGSTR_VAL_INETCPL_GENERALTAB     TEXT("GeneralTab")
#define REGSTR_VAL_INETCPL_SECURITYTAB    TEXT("SecurityTab")
#define REGSTR_VAL_INETCPL_CONTENTTAB     TEXT("ContentTab")
#define REGSTR_VAL_INETCPL_CONNECTIONSTAB TEXT("ConnectionsTab")
#define REGSTR_VAL_INETCPL_PROGRAMSTAB    TEXT("ProgramsTab")
#define REGSTR_VAL_INETCPL_ADVANCEDTAB    TEXT("AdvancedTab")

// setting to indicate whether or not IEAK launched this instance of inetcpl so extra
// info can be exposed
// reg key: HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel
#define REGSTR_VAL_INETCPL_IEAK           TEXT("IEAKContext")

//
//  Cache
//
#define REGSTR_PATH_CACHE  \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Cache")

#define REGSTR_PATH_CACHE_PATHS \
    REGSTR_PATH_CACHE TEXT("\\Paths")

#define REGSTR_PATH_EXTENSIBLE_CACHE \
    REGSTR_PATH_CACHE TEXT("\\Extensible Cache")

#define REGSTR_PATH_TRACKING \
    REGSTR_PATH_EXTENSIBLE_CACHE TEXT("\\Log")

#define REGSTR_PATH_CACHE_SPECIAL_PATHS \
    REGSTR_PATH_CACHE TEXT("Special Paths")

#define REGSTR_VAL_DIRECTORY           TEXT("Directory")
#define REGSTR_VAL_DIRECTORY_TYPE            REG_EXPAND_SZ

#define REGSTR_VAL_NEWDIRECTORY         TEXT("NewDirectory")
#define REGSTR_VAL_NEWDIRECTORY_TYPE    REG_EXPAND_SZ

#define REGSTR_VAL_CACHEPREFIX              TEXT("CachePrefix")
#define REGSTR_VAL_CACHEPREFIX_TYPE     REG_SZ

#define REGSTR_PATH_URLHISTORY \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Url History")

#define REGSTR_PATH_SUBSCRIPTION \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Subscription Folder")

//
// Search Format Strings
//
#define SZ_IE_SEARCHSTRINGS             "UrlTemplate"
#define REGSTR_PATH_SEARCHSTRINGS       REGSTR_PATH_MAIN TEXT( "\\") TEXT(SZ_IE_SEARCHSTRINGS)
#define REGSTR_KEY_SEARCHSTRINGS        TEXT(SZ_IE_SEARCHSTRINGS)

#define MAX_SEARCH_FORMAT_STRING        255

//
// Server error page dispaly/don't display length thresholds.
//
#define SZ_IE_THRESHOLDS                "ErrorThresholds"
#define REGSTR_PATH_THRESHOLDS          REGSTR_PATH_MAIN TEXT( "\\") TEXT(SZ_IE_THRESHOLDS)


//
// Access Medium
//
#define REGSTR_VAL_ACCESSMEDIUM         TEXT("AccessMedium")
// access type (MSN, other)
#define REGSTR_VAL_ACCESSTYPE           TEXT("AccessType")

//
// AutoDial
//
// name of connectoid-specific autodial handler dll and function
#define REGSTR_VAL_AUTODIALDLLNAME      TEXT("AutodialDllName")
#define REGSTR_VAL_AUTODIALFCNNAME      TEXT("AutodialFcnName")
// class name for window to receive Winsock activity messages
#define REGSTR_VAL_AUTODIAL_MONITORCLASSNAME    TEXT("MS_AutodialMonitor")
#define REGSTR_VAL_AUTODIAL_TRYONLYONCE         TEXT("TryAutodialOnce")

//
// Remote Access
//
// path to RNA values (under HKEY_CURRENT_USER)
#define REGSTR_PATH_REMOTEACCESS        TEXT("RemoteAccess")
#define REGSTR_PATH_REMOTEACESS         REGSTR_PATH_REMOTEACCESS
// this is under HKLM... we are using this to determine if RNA is installed
// or not. We can't rely on finding the DLL since removing this component
// with the control panel's "Add/Remove Software" does not remove the RNAdll.
#define REGSTR_PATH_RNACOMPONENT    TSZWINCURVERPATH    TEXT("\\Setup\\OptionalComponents\\RNA")
#define REGSTR_VAL_RNAINSTALLED     TEXT("Installed")

// values under HKCU\REGSTR_PATH_INTERNET_SETTINGS

// 4-byte REG_BINARY, autodialing is enabled if this value is present and
// non-zero, disabled otherwise
// If ForceAutodial is true, will always dial similar to IE4 behavior.
// If it's false, will only dial if network is not available.
#define REGSTR_VAL_ENABLEAUTODIAL               TEXT("EnableAutodial")
#define REGSTR_VAL_ENABLEUNATTENDED             TEXT("EnableUnattended")
#define REGSTR_VAL_NONETAUTODIAL                TEXT("NoNetAutodial")

#define REGSTR_VAL_REDIALATTEMPTS               TEXT("RedialAttempts")
#define REGSTR_VAL_REDIALINTERVAL               TEXT("RedialWait")

#define REGSTR_VAL_ENABLEAUTODIALDISCONNECT     TEXT("EnableAutodisconnect")
#define REGSTR_VAL_ENABLEAUTODISCONNECT         REGSTR_VAL_ENABLEAUTODIALDISCONNECT
#define REGSTR_VAL_ENABLEEXITDISCONNECT         TEXT("EnableExitDisconnect")

#define REGSTR_VAL_ENABLESECURITYCHECK          TEXT("EnableSecurityCheck")

#define REGSTR_VAL_COVEREXCLUDE                 TEXT("CoverExclude")
// 4-byte REG_BINARY containing number of minutes of idle time to allow
// before autodisconnect.  Autodisconnect is disabled if this value is zero
// or not present.
#define REGSTR_VAL_DISCONNECTIDLETIME   TEXT("DisconnectIdleTime")

//
// MOS
//
#define REGSTR_PATH_MOSDISCONNECT       TSZMICROSOFTPATH TEXT("\\MOS\\Preferences")
#define REGSTR_VAL_MOSDISCONNECT        TEXT("DisconnectTimeout")

//
// Proxy : These are under REGSTR_PATH_INTERNETSETTINGS
//
#define REGSTR_VAL_PROXYENABLE          TEXT("ProxyEnable")
#define REGSTR_VAL_PROXYSERVER          TEXT("ProxyServer")
#define REGSTR_VAL_PROXYOVERRIDE        TEXT("ProxyOverride")
#define REGSTR_VAL_BYPASSAUTOCONFIG     TEXT("BypassAutoconfig")



//
// Security : HKCU\\WININETPATH
//
#define SZTRUSTWARNLEVEL                    "Trust Warning Level"
#define REGSTR_KEY_TRUSTWARNINGLEVEL        TSZWININETPATH  TEXT(SZTRUSTWARNLEVEL)
#define REGSTR_VAL_TRUSTWARNINGLEVEL        TEXT(SZTRUSTWARNLEVEL) //"none" will turn off WinVerifyTrust warnings.
#define REGSTR_VAL_TRUSTWARNINGLEVEL_TYPE   REG_SZ
#define REGSTR_VAL_TRUSTWARNINGLEVEL_HIGH   TEXT("High")
#define REGSTR_VAL_TRUSTWARNINGLEVEL_MED    TEXT("Medium")
#define REGSTR_VAL_TRUSTWARNINGLEVEL_LOW    TEXT("No Security")
// default depends on MSHTML's prefs nSafetyWarningLevel

#define REGSTR_VAL_SECURITYWARNONSEND       TEXT("WarnOnPost")
#define REGSTR_VAL_SECURITYWARNONSEND_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONSEND_DEF   TRUE

#define REGSTR_VAL_SECURITYWARNONSENDALWAYS         TEXT("WarnAlwaysOnPost")
#define REGSTR_VAL_SECURITYWARNONSENDALWAYS_TYPE    REG_BINARY // FALSE-Only if... TRUE-Always
#define REGSTR_VAL_SECURITYWARNONSENDALWAYS_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONVIEW       TEXT("WarnOnView")
#define REGSTR_VAL_SECURITYWARNONVIEW_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONVIEW_DEF   TRUE

#define REGSTR_VAL_SECURITYALLOWCOOKIES         TEXT("AllowCookies")
#define REGSTR_VAL_SECURITYALLOWCOOKIES_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYALLOWCOOKIES_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONZONECROSSING       TEXT("WarnOnZoneCrossing")
#define REGSTR_VAL_SECURITYWARNONZONECROSSING_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONZONECROSSING_DEF   TRUE

#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING         TEXT("WarnOnBadCertRecving")
#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING         TEXT("WarnOnBadCertSending")
#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING_DEF     TRUE

#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES       TEXT("DisableCachingOfSSLPages")
#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES_TYPE  REG_DWORD
#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES_DEF   FALSE


//
// Run/Show ActiveX / Java : These are under REGSTR_PATH_INTERNETSETTINGS
//
#define REGSTR_VAL_SECURITYACTIVEX              TEXT("Security_RunActiveXControls")
#define REGSTR_VAL_SECURITYACTIVEX_TYPE         REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYACTIVEX_DEF          TRUE

#define REGSTR_VAL_SECURITYACTICEXSCRIPTS       TEXT("Security_RunScripts")
#define REGSTR_VAL_SECURITYACTICEXSCRIPTS_TYPE  REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYACTICEXSCRIPTS_DEF   TRUE

#define REGSTR_VAL_SECURITYJAVA                 TEXT("Security_RunJavaApplets")
#define REGSTR_VAL_SECURITYJAVA_TYPE            REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYJAVA_DEF             TRUE

//
// Java VM exclusively : HKCU
//
#define SZJAVAVMPATH                            "\\Java VM"
#define REGSTR_PATH_JAVAVM                      TSZMICROSOFTPATH TEXT(SZJAVAVMPATH)

#define REGSTR_VAL_JAVAJIT                      TEXT("EnableJIT")
#define REGSTR_VAL_JAVAJIT_TYPE                 REG_DWORD   // TRUE or FALSE
#define REGSTR_VAL_JAVAJIT_DEF                  FALSE

#define REGSTR_VAL_JAVALOGGING                   TEXT("EnableLogging")
#define REGSTR_VAL_JAVALOGGING_TYPE              REG_DWORD   // TRUE or FALSE
#define REGSTR_VAL_JAVALOGGING_DEF               FALSE


//
// QuickLinks
//
// this is where custom quicklinks are stored
#define SZTOOLBAR               "\\Toolbar"
#define TSZTOOLBAR              TEXT(SZTOOLBAR)
#define REGSTR_PATH_TOOLBAR     TSZIEPATH TEXT(SZTOOLBAR)
#define REGSTR_KEY_QUICKLINKS   TSZIEPATH TSZTOOLBAR TEXT("\\Links")
#define REGSTR_VAL_DAYSTOKEEP   TEXT("DaysToKeep")

#define SZNOTEXT                "NoText"
#define REGSTR_VAL_NOTEXT       TEXT(SZNOTEXT)
#define REGSTR_KEY_NOTEXT       TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZNOTEXT)
#define SZVISIBLE               "VisibleBands"
#define REGSTR_VAL_VISIBLE      TEXT(SZVISIBLE)
#define REGSTR_KEY_VISIBLE      TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZVISIBLE)


#define REGSTR_VAL_VISIBLEBANDS         TEXT("VisibleBands")
#define REGSTR_VAL_VISIBLEBANDS_TYPE    REG_DWORD   // 3 bits (see below)
#define REGSTR_VAL_VISIBLEBANDS_DEF     0x7         // all three bands
#define TOOLSBAND                       0x1
#define ADDRESSBAND                     0x2
#define LINKSBAND                       0x4

#define SZBACKBITMAP          "BackBitmap"
#define REGSTR_VAL_BACKBITMAP       TEXT("BackBitmap")
#define REGSTR_VAL_BACKBITMAP_TYPE  REG_SZ
// "" = no bitmap or fillin with valid path, delete for default

#define REGSTR_KEY_BACKBITMAP   TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZBACKBITMAP)

//
// Schannel Settings: HKLM
//

#define TSZSCHANNELPATH             TEXT("SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL")
#define TSZSCHANNELPROTOCOLSPATH    TSZSCHANNELPATH TEXT("\\Protocols")

#define REGSTR_PATH_PCT1            TSZSCHANNELPROTOCOLSPATH TEXT("\\PCT 1.0\\Client")
#define REGSTR_PATH_SSL2            TSZSCHANNELPROTOCOLSPATH TEXT("\\SSL 2.0\\Client")
#define REGSTR_PATH_SSL3            TSZSCHANNELPROTOCOLSPATH TEXT("\\SSL 3.0\\Client")
#define REGSTR_PATH_UNIHELLO        TSZSCHANNELPROTOCOLSPATH TEXT("\\Multi-Protocol Unified Hello\\Client")

#define REGSTR_VAL_SCHANNELENABLEPROTOCOL         TEXT("Enabled")
#define REGSTR_VAL_SCHANNELENABLEPROTOCOL_TYPE    REG_DWORD
#define REGSTR_VAL_SCHANNELENABLEPROTOCOL_DEF     TRUE


//
// Mail and News: HKLM
//
#ifdef UNIX

#define TSZINTERNETCLIENTSPATH      TEXT("Software\\Microsoft\\Internet Explorer\\Unix")
#define REGSTR_PATH_MAILCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\MailCommand")
#define REGSTR_PATH_NEWSCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\NewsCommand")
#define REGSTR_PATH_VSOURCECLIENTS  TSZINTERNETCLIENTSPATH  TEXT("\\VSourceCommand")
#define REGSTR_PATH_EDITORS         TSZINTERNETCLIENTSPATH  TEXT("\\Editors")
#define REGSTR_PATH_DEFAULT         TEXT("default")
#define REGSTR_PATH_CURRENT         TEXT("current")

#else

#define TSZINTERNETCLIENTSPATH      TEXT("Software\\Clients")
#define REGSTR_PATH_MAILCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\Mail")
#define REGSTR_PATH_NEWSCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\News")
#define REGSTR_PATH_CALENDARCLIENTS TSZINTERNETCLIENTSPATH  TEXT("\\Calendar")
#define REGSTR_PATH_CONTACTCLIENTS TSZINTERNETCLIENTSPATH  TEXT("\\Contacts")
#define REGSTR_PATH_CALLCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\Internet Call")

#endif // !UNIX

#ifdef UNIX
// Registry item containing the exe name to check for disabling OE
#define IE_USE_OE_PRESENT_HKEY HKEY_LOCAL_MACHINE
#define IE_USE_OE_PRESENT_KEY  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\app.paths\\msimn.exe")
#define IE_USE_OE_PRESENT_VALUE NULL

// locations for new OE control variables for unix
#define IE_USE_OE_MAIL_HKEY  HKEY_CURRENT_USER
#define IE_USE_OE_MAIL_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\Mail")
#define IE_USE_OE_MAIL_VALUE TEXT("Use Outlook Express")

#define IE_USE_OE_NEWS_HKEY  HKEY_CURRENT_USER
#define IE_USE_OE_NEWS_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\News")
#define IE_USE_OE_NEWS_VALUE TEXT("Use Outlook Express")
#endif // UNIX

// this is under the mail and news paths
#define TSZPROTOCOLSPATH            TEXT("Protocols\\")
// and one these is under the protocols path
#define TSZMAILTOPROTOCOL           TEXT("mailto")
#define TSZNEWSPROTOCOL             TEXT("news")
#define TSZCALLTOPROTOCOL           TEXT("callto")
#define TSZLDAPPROTOCOL             TEXT("ldap")
#define TSZCALENDARPROTOCOL         TEXT("unk")

#ifdef UNIX
#define TSZVSOURCEPROTOCOL          TEXT("view source")
#endif

//
// International and Fonts: HKCU\\TSZIEPATH
//
#define REGSTR_PATH_INTERNATIONAL   TSZIEPATH   TEXT("\\International")

#define REGSTR_PATH_INTERNATIONAL_SCRIPTS  TSZIEPATH   TEXT("\\International\\Scripts")

#define REGSTR_VAL_DEFAULT_CODEPAGE         TEXT("Default_CodePage")
#define REGSTR_VAL_DEFAULT_CODEPAGE_TYPE    REG_SZ  // code page
                   // will grab default from system if not found

#define REGSTR_VAL_DEFAULT_SCRIPT         TEXT("Default_Script")
#define REGSTR_VAL_DEFAULT_SCRIPT_TYPE    REG_SZ  
                   // will grab default from system if not found


#define REGSTR_VAL_ACCEPT_LANGUAGE          TEXT("AcceptLanguage")
#define REGSTR_VAL_ACCETP_LANGUAGE_TYPE     REG_SZ


// each CHARSET has a unique key under REGSTR_PATH_INTERNATIONAL
// which has the following values defined
#define REGSTR_VAL_FONT_SCRIPTS          TEXT("Scripts")
#define REGSTR_VAL_FONT_SCRIPT           TEXT("Script")
#define REGSTR_VAL_FONT_SCRIPT_TYPE      REG_SZ  // friendly name of font if other than system
                                                 // no default

#define REGSTR_VAL_FONT_SCRIPT_NAME           TEXT("Script")
#define REGSTR_VAL_FONT_SCRIPT_NAME_TYPE      REG_SZ                                                        


#define REGSTR_VAL_DEF_ENCODING         TEXT("Default_Encoding")
#define REGSTR_VAL_DEF_ENCODING_TYPE    REG_SZ  // internal MIME table name
                                                // no default

#define REGSTR_VAL_DEF_INETENCODING         TEXT("Default_InternetEncoding")
#define REGSTR_VAL_DEF_INETENCODING_TYPE    REG_DWORD
                                                // no default

#define REGSTR_VAL_FIXED_FONT       TEXT("IEFixedFontName")
#define REGSTR_VAL_FIXED_FONT_TYPE  REG_SZ  // must match a registered font name
                                            // no default

#define REGSTR_VAL_SCRIPT_FIXED_FONT       TEXT("IEFixedFontName")
#define REGSTR_VAL_SCRIPT_FIXED_FONT_TYPE  REG_SZ  // must match a registered font name
                                                   // no default

#define REGSTR_VAL_PROP_FONT        TEXT("IEPropFontName")
#define REGSTR_VAL_PROP_FONT_TYPE   REG_SZ  // must match a registered font name
                                            // no default

#define REGSTR_VAL_SCRIPT_PROP_FONT        TEXT("IEPropFontName")
#define REGSTR_VAL_SCRIPT_PROP_FONT_TYPE   REG_SZ  // must match a registered font name
                                                   // no default

#define REGSTR_VAL_FONT_SIZE        TEXT("IEFontSize")
#define REGSTR_VAL_FONT_SIZE_TYPE   REG_BINARY
#define REGSTR_VAL_FONT_SIZE_DEF    2       // default size : Medium

#define REGSTR_VAL_AUTODETECT         TEXT("AutoDetect")
#define REGSTR_VAL_AUTODETECT_TYPE    REG_SZ

// MIME database charset extension
#define REGSTR_PATH_MIME_DATABASE           TEXT("MIME\\Database")
#define REGSTR_KEY_MIME_DATABASE_CHARSET    REGSTR_PATH_MIME_DATABASE TEXT("\\Charset")
#define REGSTR_KEY_MIME_DATABASE_CODEPAGE   REGSTR_PATH_MIME_DATABASE TEXT("\\CodePage")
#define REGSTR_KEY_MIME_DATABASE_RFC1766    REGSTR_PATH_MIME_DATABASE TEXT("\\Rfc1766")

#define REGSTR_VAL_CODEPAGE                 TEXT("CodePage")
#define REGSTR_VAL_CODEPAGE_TYPE            REG_DWORD

#define REGSTR_VAL_INETENCODING             TEXT("InternetEncoding")
#define REGSTR_VAL_INETENCODING_TYPE        REG_DWORD

#define REGSTR_VAL_FAMILY                   TEXT("Family")
#define REGSTR_VAL_FAMILY_TYPE              REG_DWORD

#define REGSTR_VAL_LEVEL                    TEXT("Level")
#define REGSTR_VAL_LEVEL_TYPE               REG_DWORD

#define REGSTR_VAL_ALIASTO                  TEXT("AliasForCharset")
#define REGSTR_VAL_ALIASTO_TYPE             REG_SZ

#define REGSTR_VAL_ENCODENAME               TEXT("EncodingName")
#define REGSTR_VAL_ENCODENAME_TYPE          REG_SZ

#define REGSTR_VAL_DESCRIPTION              TEXT("Description")
#define REGSTR_VAL_DESCRIPTION_TYPE         REG_SZ

#define REGSTR_VAL_WEBCHARSET               TEXT("WebCharset")
#define REGSTR_VAL_WEBCHARSET_TYPE          REG_SZ

#define REGSTR_VAL_BODYCHARSET              TEXT("BodyCharset")
#define REGSTR_VAL_BODYCHARSET_TYPE         REG_SZ

#define REGSTR_VAL_HEADERCHARSET            TEXT("HeaderCharset")
#define REGSTR_VAL_HEADERCHARSET_TYPE       REG_SZ

#define REGSTR_VAL_FIXEDWIDTHFONT           TEXT("FixedWidthFont")
#define REGSTR_VAL_FIXEDWIDTHFONT_TYPE      REG_SZ

#define REGSTR_VAL_PROPORTIONALFONT         TEXT("ProportionalFont")
#define REGSTR_VAL_PROPOPRTIONALFONT_TYPE   REG_SZ

#define REGSTR_VAL_PRIVCONVERTER            TEXT("PrivConverter")
#define REGSTR_VAL_PRIVCONVERTER_TYPE       REG_SZ

#endif // _INETREGSTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\Instance.h ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//  Instance.h
//
//  Purpose: Definition of CInstance class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INSTANCE_H_
#define _INSTANCE_H_

#define WBEMINT64 CHString
#define WBEMINT16 short

///////////////////////////////////////////
//
// CLASS CInstance
//
// base instance class
// encapsulation of IWbemClassObject
///////////////////////////////////////////
class
__declspec(uuid("3402945E-D19A-11d2-B35E-00104BC97924"))
POLARITY CInstance
{
    public:
        CInstance(IWbemClassObject *piClassObject, MethodContext *pMethodContext);
        virtual ~CInstance();

        // AddRef/Release
        LONG   AddRef( void );
        LONG   Release( void );

        // Get and Set for various data types
        bool SetNull(LPCWSTR name );
        bool SetStringArray(LPCWSTR name, const SAFEARRAY &strArray);
        bool SetWORD(LPCWSTR name,  WORD w);
        bool SetDWORD(LPCWSTR name,  DWORD d);
        bool Setbool(LPCWSTR name,  bool  b);
        bool SetVariant(LPCWSTR name,  const VARIANT& variant );
        bool SetCharSplat(LPCWSTR name,  DWORD dwResID);
        bool SetCharSplat(LPCWSTR name,  LPCWSTR pStr);
        bool SetCharSplat( LPCWSTR name,  LPCSTR pStr);
        bool SetWCHARSplat(LPCWSTR name,  LPCWSTR pStr);
        bool SetDateTime(LPCWSTR name,  const WBEMTime& wbemtime );
        bool SetTimeSpan(LPCWSTR name,  const WBEMTimeSpan& wbemtimespan );
        bool SetWBEMINT64(LPCWSTR name, const WBEMINT64& wbemint64 );
        bool SetWBEMINT64(LPCWSTR name, const LONGLONG i64Value );
        bool SetWBEMINT64( LPCWSTR name, const ULONGLONG i64Value );
        bool SetWBEMINT16(LPCWSTR name, const WBEMINT16& wbemint16 );
        bool SetByte(LPCWSTR name, BYTE b );
        bool SetEmbeddedObject (LPCWSTR name, CInstance& cInstance ) ;
        bool SetDOUBLE(LPCWSTR name, DOUBLE dub );
        bool SetCHString(LPCWSTR name, LPCWSTR str);
        bool SetCHString(LPCWSTR name,  const CHString& str);
        bool SetCHString(LPCWSTR name, LPCSTR str);

        bool GetStringArray(LPCWSTR name,  SAFEARRAY *& strArray)     const;
        bool GetCHString(LPCWSTR name, CHString& str) const;
        bool GetWCHAR(LPCWSTR name,  WCHAR **pW) const;
        bool GetWORD(LPCWSTR name,  WORD& w) const;
        bool GetDWORD(LPCWSTR name,  DWORD& d) const;
        bool Getbool(LPCWSTR name,  bool&  b) const;
        bool GetVariant(LPCWSTR name, VARIANT& variant ) const;
        bool GetDateTime(LPCWSTR name,  WBEMTime& wbemtime ) const;
        bool GetTimeSpan(LPCWSTR name,  WBEMTimeSpan& wbemtimespan ) const;
        bool GetWBEMINT64(LPCWSTR name, WBEMINT64& wbemint64 ) const;
        bool GetWBEMINT64(LPCWSTR name, LONGLONG& i64Value ) const;
        bool GetWBEMINT64( LPCWSTR name, ULONGLONG& i64Value) const;
        bool GetWBEMINT16(LPCWSTR name, WBEMINT16& wbemint16 ) const;
        bool GetByte(LPCWSTR name, BYTE& b ) const;
        bool GetEmbeddedObject(LPCWSTR name, CInstance** pInstance,  MethodContext *pMethodContext) const;
        bool GetDOUBLE(LPCWSTR name, DOUBLE& dub) const;
        bool IsNull(LPCWSTR name) const;
        bool GetStatus(LPCWSTR name, bool &a_Exists , VARTYPE &a_VarType ) const ;

        HRESULT Commit(void);
        IWbemClassObject *GetClassObjectInterface();
        MethodContext *GetMethodContext() const;

    protected:
        // All items in this section intended for Microsoft internal use only
        // use by third parties is unsupported and unrecommended
        void LogError(LPCWSTR errorStr, LPCWSTR pFunctionName, LPCWSTR pArgs = NULL, HRESULT hError = -1) const;

        IWbemClassObject *m_piClassObject;
        MethodContext*   m_pMethodContext;
        LONG             m_nRefCount;

        friend class CWbemProviderGlue;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\inetsdk.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for inetsdk.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __inetsdk_h__
#define __inetsdk_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "comcat.h"
#include "ocidl.h"
#include "docobj.h"
#include "hlink.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_inetsdk_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// INetSDK.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// ActiveX SDK Merged IDL.



extern RPC_IF_HANDLE __MIDL_itf_inetsdk_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_inetsdk_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\invkprxy.h ===
/***
* invkprxy.h - Native C++ compiler COM support - IDispatch::Invoke helpers
*
*   Copyright (C) 1996-2000 Microsoft Corporation
*   All rights reserved.
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_INC_INVKPRXY)
#define _INC_INVKPRXY 1

HRESULT __stdcall _com_handle_excepinfo(EXCEPINFO& excepInfo, IErrorInfo** pperrinfo);
HRESULT __cdecl _com_invoke_helper(IDispatch* pDispatch,
                                DISPID dwDispID,
                                WORD wFlags,
                                VARTYPE vtRet,
                                void* pvRet,
                                const wchar_t* pwParamInfo,
                                va_list argList,
                                IErrorInfo** pperrinfo);
HRESULT __cdecl _com_dispatch_raw_method(IDispatch* pDispatch,
                                DISPID dwDispID,
                                WORD wFlags,
                                VARTYPE vtRet,
                                void* pvRet,
                                const wchar_t* pwParamInfo,
                                ...);
HRESULT __stdcall _com_dispatch_raw_propget(IDispatch* pDispatch,
                                DISPID dwDispID,
                                VARTYPE vtProp,
                                void* pvProp);
HRESULT __cdecl _com_dispatch_raw_propput(IDispatch* pDispatch,
                                DISPID dwDispID,
                                VARTYPE vtProp,
                                ...);

#endif // _INC_INVKPRXY
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\imagehlp.h ===
/*++ BUILD Version: 0001     Increment this if a change has global effects

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    imagehlp.h

Abstract:

    This module defines the prototypes and constants required for the image
    help routines.

Revision History:

--*/

#ifndef _IMAGEHLP_
#define _IMAGEHLP_

#if _MSC_VER > 1020
#pragma once
#endif


#ifdef _WIN64
#ifndef _IMAGEHLP64
#define _IMAGEHLP64
#endif
#endif


#ifndef WINTRUST_H
#include <wintrust.h>
#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _IMAGEHLP_SOURCE_
#define IMAGEAPI __stdcall
#else
#define IMAGEAPI DECLSPEC_IMPORT __stdcall
#endif

#define IMAGE_SEPARATION (64*1024)

typedef struct _LOADED_IMAGE {
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
#ifdef _IMAGEHLP64
    PIMAGE_NT_HEADERS64   FileHeader;
#else
    PIMAGE_NT_HEADERS32   FileHeader;
#endif
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;



BOOL
IMAGEAPI
BindImage(
    IN PSTR ImageName,
    IN PSTR DllPath,
    IN PSTR SymbolPath
    );

typedef enum _IMAGEHLP_STATUS_REASON {
    BindOutOfMemory,
    BindRvaToVaFailed,
    BindNoRoomInImage,
    BindImportModuleFailed,
    BindImportProcedureFailed,
    BindImportModule,
    BindImportProcedure,
    BindForwarder,
    BindForwarderNOT,
    BindImageModified,
    BindExpandFileHeaders,
    BindImageComplete,
    BindMismatchedSymbols,
    BindSymbolsNotUpdated
} IMAGEHLP_STATUS_REASON;

typedef
BOOL
(__stdcall *PIMAGEHLP_STATUS_ROUTINE)(
    IMAGEHLP_STATUS_REASON Reason,
    PSTR ImageName,
    PSTR DllName,
    ULONG_PTR Va,
    ULONG_PTR Parameter
    );


BOOL
IMAGEAPI
BindImageEx(
    IN DWORD Flags,
    IN PSTR ImageName,
    IN PSTR DllPath,
    IN PSTR SymbolPath,
    IN PIMAGEHLP_STATUS_ROUTINE StatusRoutine
    );

#define BIND_NO_BOUND_IMPORTS  0x00000001
#define BIND_NO_UPDATE         0x00000002
#define BIND_ALL_IMAGES        0x00000004
#define BIND_CACHE_IMPORT_DLLS 0x00000008       // Cache dll's across
                                                //  calls to BindImageEx
                                                //  (same as NT 3.1->NT 4.0)

BOOL
IMAGEAPI
ReBaseImage(
    IN     PSTR CurrentImageName,
    IN     PSTR SymbolPath,
    IN     BOOL  fReBase,           // TRUE if actually rebasing, false if only summing
    IN     BOOL  fRebaseSysfileOk,  // TRUE is system images s/b rebased
    IN     BOOL  fGoingDown,        // TRUE if the image s/b rebased below the given base
    IN     ULONG CheckImageSize,    // Max size allowed  (0 if don't care)
    OUT    ULONG *OldImageSize,     // Returned from the header
    OUT    ULONG_PTR *OldImageBase, // Returned from the header
    OUT    ULONG *NewImageSize,     // Image size rounded to next separation boundary
    IN OUT ULONG_PTR *NewImageBase, // (in) Desired new address.
                                    // (out) Next address (actual if going down)
    IN     ULONG TimeStamp          // new timestamp for image, if non-zero
    );

BOOL
IMAGEAPI
ReBaseImage64(
    IN     PSTR CurrentImageName,
    IN     PSTR SymbolPath,
    IN     BOOL  fReBase,          // TRUE if actually rebasing, false if only summing
    IN     BOOL  fRebaseSysfileOk, // TRUE is system images s/b rebased
    IN     BOOL  fGoingDown,       // TRUE if the image s/b rebased below the given base
    IN     ULONG CheckImageSize,   // Max size allowed  (0 if don't care)
    OUT    ULONG *OldImageSize,    // Returned from the header
    OUT    ULONG64 *OldImageBase,  // Returned from the header
    OUT    ULONG *NewImageSize,    // Image size rounded to next separation boundary
    IN OUT ULONG64 *NewImageBase,  // (in) Desired new address.
                                   // (out) Next address (actual if going down)
    IN     ULONG TimeStamp         // new timestamp for image, if non-zero
    );

//
// Define checksum return codes.
//

#define CHECKSUM_SUCCESS            0
#define CHECKSUM_OPEN_FAILURE       1
#define CHECKSUM_MAP_FAILURE        2
#define CHECKSUM_MAPVIEW_FAILURE    3
#define CHECKSUM_UNICODE_FAILURE    4

// Define Splitsym flags.

#define SPLITSYM_REMOVE_PRIVATE     0x00000001      // Remove CV types/symbols and Fixup debug
                                                    //  Used for creating .dbg files that ship
                                                    //  as part of the product.

#define SPLITSYM_EXTRACT_ALL        0x00000002      // Extract all debug info from image.
                                                    //  Normally, FPO is left in the image
                                                    //  to allow stack traces through the code.
                                                    //  Using this switch is similar to linking
                                                    //  with -debug:none except the .dbg file
                                                    //  exists...

#define SPLITSYM_SYMBOLPATH_IS_SRC  0x00000004      // The SymbolFilePath contains an alternate
                                                    //  path to locate the pdb.


//
// Define checksum function prototypes.
//

PIMAGE_NT_HEADERS
IMAGEAPI
CheckSumMappedFile (
    PVOID BaseAddress,
    DWORD FileLength,
    PDWORD HeaderSum,
    PDWORD CheckSum
    );

DWORD
IMAGEAPI
MapFileAndCheckSumA (
    PSTR Filename,
    PDWORD HeaderSum,
    PDWORD CheckSum
    );

DWORD
IMAGEAPI
MapFileAndCheckSumW (
    PWSTR Filename,
    PDWORD HeaderSum,
    PDWORD CheckSum
    );

#ifdef UNICODE
#define MapFileAndCheckSum  MapFileAndCheckSumW
#else
#define MapFileAndCheckSum  MapFileAndCheckSumA
#endif // !UNICODE

BOOL
IMAGEAPI
GetImageConfigInformation(
    PLOADED_IMAGE LoadedImage,
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigInformation
    );

DWORD
IMAGEAPI
GetImageUnusedHeaderBytes(
    PLOADED_IMAGE LoadedImage,
    PDWORD SizeUnusedHeaderBytes
    );

BOOL
IMAGEAPI
SetImageConfigInformation(
    PLOADED_IMAGE LoadedImage,
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigInformation
    );

// Image Integrity API's

#define CERT_PE_IMAGE_DIGEST_DEBUG_INFO         0x01
#define CERT_PE_IMAGE_DIGEST_RESOURCES          0x02
#define CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO    0x04
#define CERT_PE_IMAGE_DIGEST_NON_PE_INFO        0x08      // include data outside the PE image

#define CERT_SECTION_TYPE_ANY                   0xFF      // Any Certificate type

typedef PVOID DIGEST_HANDLE;

typedef BOOL (WINAPI *DIGEST_FUNCTION) (DIGEST_HANDLE refdata, PBYTE pData, DWORD dwLength);

BOOL
IMAGEAPI
ImageGetDigestStream(
    IN      HANDLE  FileHandle,
    IN      DWORD   DigestLevel,
    IN      DIGEST_FUNCTION DigestFunction,
    IN      DIGEST_HANDLE   DigestHandle
    );

BOOL
IMAGEAPI
ImageAddCertificate(
    IN      HANDLE  FileHandle,
    IN      LPWIN_CERTIFICATE   Certificate,
    OUT     PDWORD  Index
    );

BOOL
IMAGEAPI
ImageRemoveCertificate(
    IN      HANDLE   FileHandle,
    IN      DWORD    Index
    );

BOOL
IMAGEAPI
ImageEnumerateCertificates(
    IN      HANDLE  FileHandle,
    IN      WORD    TypeFilter,
    OUT     PDWORD  CertificateCount,
    IN OUT  PDWORD  Indices OPTIONAL,
    IN OUT  DWORD   IndexCount  OPTIONAL
    );

BOOL
IMAGEAPI
ImageGetCertificateData(
    IN      HANDLE  FileHandle,
    IN      DWORD   CertificateIndex,
    OUT     LPWIN_CERTIFICATE Certificate,
    IN OUT  PDWORD  RequiredLength
    );

BOOL
IMAGEAPI
ImageGetCertificateHeader(
    IN      HANDLE  FileHandle,
    IN      DWORD   CertificateIndex,
    IN OUT  LPWIN_CERTIFICATE Certificateheader
    );

PLOADED_IMAGE
IMAGEAPI
ImageLoad(
    PSTR DllName,
    PSTR DllPath
    );

BOOL
IMAGEAPI
ImageUnload(
    PLOADED_IMAGE LoadedImage
    );

BOOL
IMAGEAPI
MapAndLoad(
    PSTR ImageName,
    PSTR DllPath,
    PLOADED_IMAGE LoadedImage,
    BOOL DotDll,
    BOOL ReadOnly
    );

BOOL
IMAGEAPI
UnMapAndLoad(
    PLOADED_IMAGE LoadedImage
    );

BOOL
IMAGEAPI
TouchFileTimes (
    HANDLE FileHandle,
    PSYSTEMTIME pSystemTime
    );

BOOL
IMAGEAPI
SplitSymbols (
    PSTR ImageName,
    PSTR SymbolsPath,
    PSTR SymbolFilePath,
    DWORD Flags                 // Combination of flags above
    );

BOOL
IMAGEAPI
UpdateDebugInfoFile(
    PSTR ImageFileName,
    PSTR SymbolPath,
    PSTR DebugFilePath,
    PIMAGE_NT_HEADERS32 NtHeaders
    );

BOOL
IMAGEAPI
UpdateDebugInfoFileEx(
    PSTR ImageFileName,
    PSTR SymbolPath,
    PSTR DebugFilePath,
    PIMAGE_NT_HEADERS32 NtHeaders,
    DWORD OldChecksum
    );


HANDLE
IMAGEAPI
FindDebugInfoFile (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath
    );

typedef BOOL
(CALLBACK *PFIND_DEBUG_FILE_CALLBACK)(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

HANDLE
IMAGEAPI
FindDebugInfoFileEx (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath,
    PFIND_DEBUG_FILE_CALLBACK Callback,
    PVOID CallerData
    );

BOOL
IMAGEAPI
FindFileInSearchPath(
    HANDLE hprocess,
    LPSTR SearchPath,
    LPSTR FileName,
    DWORD one,
    DWORD two,
    DWORD three,
    LPSTR FilePath
    );

HANDLE
IMAGEAPI
FindExecutableImage(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath
    );

typedef BOOL
(CALLBACK *PFIND_EXE_FILE_CALLBACK)(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

HANDLE
IMAGEAPI
FindExecutableImageEx(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData
    );

PIMAGE_NT_HEADERS
IMAGEAPI
ImageNtHeader (
    IN PVOID Base
    );

PVOID
IMAGEAPI
ImageDirectoryEntryToDataEx (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundHeader OPTIONAL
    );

PVOID
IMAGEAPI
ImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );

PIMAGE_SECTION_HEADER
IMAGEAPI
ImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    );

PVOID
IMAGEAPI
ImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection
    );

// Symbol server exports

typedef BOOL (*PSYMBOLSERVERPROC)(LPCSTR, LPCSTR, DWORD, DWORD, DWORD, LPSTR);
typedef BOOL (*PSYMBOLSERVEROPENPROC)(VOID);
typedef BOOL (*PSYMBOLSERVERCLOSEPROC)(VOID);
typedef BOOL (*PSYMBOLSERVERSETOPTIONSPROC)(UINT_PTR, ULONG64);
typedef BOOL (CALLBACK *PSYMBOLSERVERCALLBACKPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);
typedef UINT_PTR (*PSYMBOLSERVERGETOPTIONSPROC)();

#define SSRVOPT_CALLBACK 1
#define SSRVOPT_RESET    ((ULONG_PTR)-1)

#define SSRVACTION_TRACE 1


#ifndef _WIN64
// This api won't be ported to Win64 - Fix your code.

typedef struct _IMAGE_DEBUG_INFORMATION {
    LIST_ENTRY List;
    DWORD ReservedSize;
    PVOID ReservedMappedBase;
    USHORT ReservedMachine;
    USHORT ReservedCharacteristics;
    DWORD ReservedCheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;

    DWORD ReservedNumberOfSections;
    PIMAGE_SECTION_HEADER ReservedSections;

    DWORD ReservedExportedNamesSize;
    PSTR ReservedExportedNames;

    DWORD ReservedNumberOfFunctionTableEntries;
    PIMAGE_FUNCTION_ENTRY ReservedFunctionTableEntries;
    DWORD ReservedLowestFunctionStartingAddress;
    DWORD ReservedHighestFunctionEndingAddress;

    DWORD ReservedNumberOfFpoTableEntries;
    PFPO_DATA ReservedFpoTableEntries;

    DWORD SizeOfCoffSymbols;
    PIMAGE_COFF_SYMBOLS_HEADER CoffSymbols;

    DWORD ReservedSizeOfCodeViewSymbols;
    PVOID ReservedCodeViewSymbols;

    PSTR ImageFilePath;
    PSTR ImageFileName;
    PSTR ReservedDebugFilePath;

    DWORD ReservedTimeDateStamp;

    BOOL  ReservedRomImage;
    PIMAGE_DEBUG_DIRECTORY ReservedDebugDirectory;
    DWORD ReservedNumberOfDebugDirectories;

    DWORD ReservedOriginalFunctionTableBaseAddress;

    DWORD Reserved[ 2 ];

} IMAGE_DEBUG_INFORMATION, *PIMAGE_DEBUG_INFORMATION;


PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    HANDLE FileHandle,
    PSTR FileName,
    PSTR SymbolPath,
    DWORD ImageBase
    );

BOOL
IMAGEAPI
UnmapDebugInformation(
    PIMAGE_DEBUG_INFORMATION DebugInfo
    );

#endif

BOOL
IMAGEAPI
SearchTreeForFile(
    PSTR RootPath,
    PSTR InputPathName,
    PSTR OutputPathBuffer
    );

BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    PCSTR DirPath
    );

//
// UnDecorateSymbolName Flags
//

#define UNDNAME_COMPLETE                 (0x0000)  // Enable full undecoration
#define UNDNAME_NO_LEADING_UNDERSCORES   (0x0001)  // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS           (0x0002)  // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS      (0x0004)  // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL      (0x0008)  // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE   (0x0010)  // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE           (0x0020)  // NYI Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE           (0x0040)  // NYI Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE              (0x0060)  // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS     (0x0080)  // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES      (0x0100)  // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE           (0x0200)  // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL      (0x0400)  // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE            (0x0800)  // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY                (0x1000)  // Crack only the name for primary declaration;
                                                                                                   //  return just [scope::]name.  Does expand template params
#define UNDNAME_NO_ARGUMENTS             (0x2000)  // Don't undecorate arguments to function
#define UNDNAME_NO_SPECIAL_SYMS          (0x4000)  // Don't undecorate special names (v-table, vcall, vector xxx, metatype, etc)

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    PCSTR   DecoratedName,         // Name to undecorate
    PSTR    UnDecoratedName,       // If NULL, it will be allocated
    DWORD    UndecoratedLength,     // The maximym length
    DWORD    Flags                  // See above.
    );

//
// StackWalking API
//

typedef enum {
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64 {
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define ADDRESS ADDRESS64
#define LPADDRESS LPADDRESS64
#else
typedef struct _tagADDRESS {
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

__inline
void
Address32To64(
    LPADDRESS a32,
    LPADDRESS64 a64
    )
{
    a64->Offset = (ULONG64)(LONG64)(LONG)a32->Offset;
    a64->Segment = a32->Segment;
    a64->Mode = a32->Mode;
}

__inline
void
Address64To32(
    LPADDRESS64 a64,
    LPADDRESS a32
    )
{
    a32->Offset = (ULONG)a64->Offset;
    a32->Segment = a64->Segment;
    a32->Mode = a64->Mode;
}
#endif

//
// This structure is included in the STACKFRAME structure,
// and is used to trace through usermode callbacks in a thread's
// kernel stack.  The values must be copied by the kernel debugger
// from the DBGKD_GET_VERSION and WAIT_STATE_CHANGE packets.
//

//
// New KDHELP structure for 64 bit system support.
// This structure is preferred in new code.
//
typedef struct _KDHELP64 {

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD64   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;


    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD64   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD64   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD64   SystemRangeStart;

    DWORD64  Reserved[8];

} KDHELP64, *PKDHELP64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define KDHELP KDHELP64
#define PKDHELP PKDHELP64
#else
typedef struct _KDHELP {

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;

    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD   SystemRangeStart;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    DWORD  Reserved[8];

} KDHELP, *PKDHELP;

__inline
void
KdHelp32To64(
    PKDHELP p32,
    PKDHELP64 p64
    )
{
    p64->Thread = p32->Thread;
    p64->ThCallbackStack = p32->ThCallbackStack;
    p64->NextCallback = p32->NextCallback;
    p64->FramePointer = p32->FramePointer;
    p64->KiCallUserMode = p32->KiCallUserMode;
    p64->KeUserCallbackDispatcher = p32->KeUserCallbackDispatcher;
    p64->SystemRangeStart = p32->SystemRangeStart;
}
#endif

typedef struct _tagSTACKFRAME64 {
    ADDRESS64   AddrPC;               // program counter
    ADDRESS64   AddrReturn;           // return address
    ADDRESS64   AddrFrame;            // frame pointer
    ADDRESS64   AddrStack;            // stack pointer
    ADDRESS64   AddrBStore;           // backing store pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD64     Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD64     Reserved[3];
    KDHELP64    KdHelp;
} STACKFRAME64, *LPSTACKFRAME64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define STACKFRAME STACKFRAME64
#define LPSTACKFRAME LPSTACKFRAME64
#else
typedef struct _tagSTACKFRAME {
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;
#endif


typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE64)(
    HANDLE      hProcess,
    DWORD64     qwBaseAddress,
    PVOID       lpBuffer,
    DWORD       nSize,
    LPDWORD     lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE64)(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

typedef
DWORD64
(__stdcall *PGET_MODULE_BASE_ROUTINE64)(
    HANDLE  hProcess,
    DWORD64 Address
    );

typedef
DWORD64
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE64)(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 lpaddr
    );

BOOL
IMAGEAPI
StackWalk64(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PREAD_PROCESS_MEMORY_ROUTINE PREAD_PROCESS_MEMORY_ROUTINE64
#define PFUNCTION_TABLE_ACCESS_ROUTINE PFUNCTION_TABLE_ACCESS_ROUTINE64
#define PGET_MODULE_BASE_ROUTINE PGET_MODULE_BASE_ROUTINE64
#define PTRANSLATE_ADDRESS_ROUTINE PTRANSLATE_ADDRESS_ROUTINE64

#define StackWalk StackWalk64

#else

typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE)(
    HANDLE  hProcess,
    DWORD   lpBaseAddress,
    PVOID   lpBuffer,
    DWORD   nSize,
    PDWORD  lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE)(
    HANDLE  hProcess,
    DWORD   AddrBase
    );

typedef
DWORD
(__stdcall *PGET_MODULE_BASE_ROUTINE)(
    HANDLE  hProcess,
    DWORD   Address
    );

typedef
DWORD
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE)(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS lpaddr
    );

BOOL
IMAGEAPI
StackWalk(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    );

#endif


#define API_VERSION_NUMBER 9

typedef struct API_VERSION {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} API_VERSION, *LPAPI_VERSION;

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
    );

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    LPAPI_VERSION AppVersion
    );

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    HMODULE Module
    );

//
// typedefs for function pointers
//
typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACK64)(
    PSTR ModuleName,
    DWORD64 BaseOfDll,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK64)(
    PSTR SymbolName,
    DWORD64 SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK64W)(
    PWSTR SymbolName,
    DWORD64 SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACK64)(
    PSTR ModuleName,
    DWORD64 ModuleBase,
    ULONG ModuleSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYMBOL_REGISTERED_CALLBACK64)(
    HANDLE  hProcess,
    ULONG   ActionCode,
    ULONG64 CallbackData,
    ULONG64 UserContext
    );

typedef
PVOID
(CALLBACK *PSYMBOL_FUNCENTRY_CALLBACK)(
    HANDLE  hProcess,
    DWORD   AddrBase,
    PVOID   UserContext
    );

typedef
PVOID
(CALLBACK *PSYMBOL_FUNCENTRY_CALLBACK64)(
    HANDLE  hProcess,
    ULONG64 AddrBase,
    ULONG64 UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PSYM_ENUMMODULES_CALLBACK PSYM_ENUMMODULES_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACK PSYM_ENUMSYMBOLS_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACKW PSYM_ENUMSYMBOLS_CALLBACK64W
#define PENUMLOADED_MODULES_CALLBACK PENUMLOADED_MODULES_CALLBACK64
#define PSYMBOL_REGISTERED_CALLBACK PSYMBOL_REGISTERED_CALLBACK64
#define PSYMBOL_FUNCENTRY_CALLBACK PSYMBOL_FUNCENTRY_CALLBACK64

#else

typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACK)(
    PSTR  ModuleName,
    ULONG BaseOfDll,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK)(
    PSTR  SymbolName,
    ULONG SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACKW)(
    PWSTR  SymbolName,
    ULONG SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACK)(
    PSTR  ModuleName,
    ULONG ModuleBase,
    ULONG ModuleSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYMBOL_REGISTERED_CALLBACK)(
    HANDLE  hProcess,
    ULONG   ActionCode,
    PVOID   CallbackData,
    PVOID   UserContext
    );

#endif


//
// symbol flags
//

#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002
#ifndef _DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED
#define SYMF_USER_GENERATED   0x00000004
#endif // !_DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED
#define SYMF_REGISTER         0x00000008
#define SYMF_REGREL           0x00000010
#define SYMF_FRAMEREL         0x00000020

//
// symbol type enumeration
//
typedef enum {
    SymNone = 0,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym,       // .sym file
    NumSymTypes
} SYM_TYPE;

//
// symbol data structure
//

typedef struct _IMAGEHLP_SYMBOL64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL64)
    DWORD64                     Address;                // virtual address including dll base address
    DWORD                       Size;                   // estimated size of symbol, can be zero
    DWORD                       Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL64, *PIMAGEHLP_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_SYMBOL IMAGEHLP_SYMBOL64
#define PIMAGEHLP_SYMBOL PIMAGEHLP_SYMBOL64
#else
typedef struct _IMAGEHLP_SYMBOL {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
    DWORD                       Address;                // virtual address including dll base address
    DWORD                       Size;                   // estimated size of symbol, can be zero
    DWORD                       Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;
#endif

//
// module data structure
//

typedef struct _IMAGEHLP_MODULE64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    CHAR                        ModuleName[32];         // module name
    CHAR                        ImageName[256];         // image name
    CHAR                        LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE64, *PIMAGEHLP_MODULE64;

typedef struct _IMAGEHLP_MODULE64W {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    WCHAR                       ModuleName[32];         // module name
    WCHAR                       ImageName[256];         // image name
    WCHAR                       LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW64, *PIMAGEHLP_MODULEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_MODULE IMAGEHLP_MODULE64
#define PIMAGEHLP_MODULE PIMAGEHLP_MODULE64
#define IMAGEHLP_MODULEW IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULEW PIMAGEHLP_MODULEW64
#else
typedef struct _IMAGEHLP_MODULE {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    CHAR                        ModuleName[32];         // module name
    CHAR                        ImageName[256];         // image name
    CHAR                        LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE, *PIMAGEHLP_MODULE;

typedef struct _IMAGEHLP_MODULEW {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    WCHAR                       ModuleName[32];         // module name
    WCHAR                       ImageName[256];         // image name
    WCHAR                       LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW, *PIMAGEHLP_MODULEW;
#endif

//
// source file line data structure
//

typedef struct _IMAGEHLP_LINE64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID                       Key;                    // internal
    DWORD                       LineNumber;             // line number in file
    PCHAR                       FileName;               // full filename
    DWORD64                     Address;                // first instruction of line
} IMAGEHLP_LINE64, *PIMAGEHLP_LINE64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_LINE IMAGEHLP_LINE64
#define PIMAGEHLP_LINE PIMAGEHLP_LINE64
#else
typedef struct _IMAGEHLP_LINE {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE)
    PVOID                       Key;                    // internal
    DWORD                       LineNumber;             // line number in file
    PCHAR                       FileName;               // full filename
    DWORD                       Address;                // first instruction of line
} IMAGEHLP_LINE, *PIMAGEHLP_LINE;
#endif

//
// data structures used for registered symbol callbacks
//

#define CBA_DEFERRED_SYMBOL_LOAD_START          0x00000001
#define CBA_DEFERRED_SYMBOL_LOAD_COMPLETE       0x00000002
#define CBA_DEFERRED_SYMBOL_LOAD_FAILURE        0x00000003
#define CBA_SYMBOLS_UNLOADED                    0x00000004
#define CBA_DUPLICATE_SYMBOL                    0x00000005
#define CBA_READ_MEMORY                         0x00000006
#define CBA_DEFERRED_SYMBOL_LOAD_CANCEL         0x00000007
#define CBA_DEBUG_INFO                          0x10000000

typedef struct _IMAGEHLP_CBA_READ_MEMORY {
    DWORD64   addr;                                     // address to read from
    PVOID     buf;                                      // buffer to read to
    DWORD     bytes;                                    // amount of bytes to read
    DWORD    *bytesread;                                // pointer to store amount of bytes read
} IMAGEHLP_CBA_READ_MEMORY, *PIMAGEHLP_CBA_READ_MEMORY;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    CHAR                        FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN                     Reparse;                // load failure reparse
} IMAGEHLP_DEFERRED_SYMBOL_LOAD64, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD IMAGEHLP_DEFERRED_SYMBOL_LOAD64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD PIMAGEHLP_DEFERRED_SYMBOL_LOAD64
#else
typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    CHAR                        FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN                     Reparse;                // load failure reparse
} IMAGEHLP_DEFERRED_SYMBOL_LOAD, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD;
#endif

typedef struct _IMAGEHLP_DUPLICATE_SYMBOL64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL64)
    DWORD                       NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL64          Symbol;                 // array of duplicate symbols
    DWORD                       SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL64, *PIMAGEHLP_DUPLICATE_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DUPLICATE_SYMBOL IMAGEHLP_DUPLICATE_SYMBOL64
#define PIMAGEHLP_DUPLICATE_SYMBOL PIMAGEHLP_DUPLICATE_SYMBOL64
#else
typedef struct _IMAGEHLP_DUPLICATE_SYMBOL {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL)
    DWORD                       NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL            Symbol;                 // array of duplicate symbols
    DWORD                       SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL, *PIMAGEHLP_DUPLICATE_SYMBOL;
#endif


//
// options that are set/returned by SymSetOptions() & SymGetOptions()
// these are used as a mask
//
#define SYMOPT_CASE_INSENSITIVE  0x00000001
#define SYMOPT_UNDNAME           0x00000002
#define SYMOPT_DEFERRED_LOADS    0x00000004
#define SYMOPT_NO_CPP            0x00000008
#define SYMOPT_LOAD_LINES        0x00000010
#define SYMOPT_OMAP_FIND_NEAREST 0x00000020
#define SYMOPT_LOAD_ANYTHING     0x00000040
#define SYMOPT_DEBUG             0x80000000


DWORD
IMAGEAPI
SymSetOptions(
    IN DWORD   SymOptions
    );

DWORD
IMAGEAPI
SymGetOptions(
    VOID
    );

BOOL
IMAGEAPI
SymCleanup(
    IN HANDLE hProcess
    );

BOOL
IMAGEAPI
SymEnumerateModules64(
    IN HANDLE                       hProcess,
    IN PSYM_ENUMMODULES_CALLBACK64  EnumModulesCallback,
    IN PVOID                        UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateModules SymEnumerateModules64
#else
BOOL
IMAGEAPI
SymEnumerateModules(
    IN HANDLE                     hProcess,
    IN PSYM_ENUMMODULES_CALLBACK  EnumModulesCallback,
    IN PVOID                      UserContext
    );
#endif

BOOL
IMAGEAPI
SymEnumerateSymbols64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64  EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateSymbols SymEnumerateSymbols64
#define SymEnumerateSymbolsW SymEnumerateSymbolsW64
#else
BOOL
IMAGEAPI
SymEnumerateSymbols(
    IN HANDLE                     hProcess,
    IN DWORD                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK  EnumSymbolsCallback,
    IN PVOID                      UserContext
    );

BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    IN HANDLE                       hProcess,
    IN DWORD                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACKW   EnumSymbolsCallback,
    IN PVOID                        UserContext
    );
#endif

BOOL
IMAGEAPI
EnumerateLoadedModules64(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK64   EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define EnumerateLoadedModules EnumerateLoadedModules64
#else
BOOL
IMAGEAPI
EnumerateLoadedModules(
    IN HANDLE                         hProcess,
    IN PENUMLOADED_MODULES_CALLBACK   EnumLoadedModulesCallback,
    IN PVOID                          UserContext
    );
#endif

PVOID
IMAGEAPI
SymFunctionTableAccess64(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymFunctionTableAccess SymFunctionTableAccess64
#else
PVOID
IMAGEAPI
SymFunctionTableAccess(
    HANDLE  hProcess,
    DWORD   AddrBase
    );
#endif

BOOL
IMAGEAPI
SymGetModuleInfo64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULE64      ModuleInfo
    );

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULEW64     ModuleInfo
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfo   SymGetModuleInfo64
#define SymGetModuleInfoW  SymGetModuleInfoW64
#else
BOOL
IMAGEAPI
SymGetModuleInfo(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE  ModuleInfo
    );

BOOL
IMAGEAPI
SymGetModuleInfoW(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULEW  ModuleInfo
    );
#endif

DWORD64
IMAGEAPI
SymGetModuleBase64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleBase SymGetModuleBase64
#else
DWORD
IMAGEAPI
SymGetModuleBase(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr
    );
#endif

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr,
    OUT PDWORD64            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromAddr SymGetSymFromAddr64
#else
BOOL
IMAGEAPI
SymGetSymFromAddr(
    IN  HANDLE            hProcess,
    IN  DWORD             dwAddr,
    OUT PDWORD            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymFromName64(
    IN  HANDLE              hProcess,
    IN  PSTR                Name,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromName SymGetSymFromName64
#else
BOOL
IMAGEAPI
SymGetSymFromName(
    IN  HANDLE            hProcess,
    IN  PSTR              Name,
    OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymNext64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymNext SymGetSymNext64
#else
BOOL
IMAGEAPI
SymGetSymNext(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymPrev64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymPrev SymGetSymPrev64
#else
BOOL
IMAGEAPI
SymGetSymPrev(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE64        Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromAddr SymGetLineFromAddr64
#else
BOOL
IMAGEAPI
SymGetLineFromAddr(
    IN  HANDLE                hProcess,
    IN  DWORD                 dwAddr,
    OUT PDWORD                pdwDisplacement,
    OUT PIMAGEHLP_LINE        Line
    );
#endif

BOOL
IMAGEAPI
SymGetLineFromName64(
    IN     HANDLE               hProcess,
    IN     PSTR                 ModuleName,
    IN     PSTR                 FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromName SymGetLineFromName64
#else
BOOL
IMAGEAPI
SymGetLineFromName(
    IN     HANDLE             hProcess,
    IN     PSTR               ModuleName,
    IN     PSTR               FileName,
    IN     DWORD              dwLineNumber,
       OUT PLONG              plDisplacement,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymGetLineNext64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineNext SymGetLineNext64
#else
BOOL
IMAGEAPI
SymGetLineNext(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymGetLinePrev64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLinePrev SymGetLinePrev64
#else
BOOL
IMAGEAPI
SymGetLinePrev(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymMatchFileName(
    IN  PSTR  FileName,
    IN  PSTR  Match,
    OUT PSTR *FileNameStop,
    OUT PSTR *MatchStop
    );

BOOL
IMAGEAPI
SymInitialize(
    IN HANDLE   hProcess,
    IN PSTR     UserSearchPath,
    IN BOOL     fInvadeProcess
    );

BOOL
IMAGEAPI
SymGetSearchPath(
    IN  HANDLE          hProcess,
    OUT PSTR            SearchPath,
    IN  DWORD           SearchPathLength
    );

BOOL
IMAGEAPI
SymSetSearchPath(
    IN HANDLE           hProcess,
    IN PSTR             SearchPath
    );

DWORD64
IMAGEAPI
SymLoadModule64(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           SizeOfDll
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymLoadModule SymLoadModule64
#else
DWORD
IMAGEAPI
SymLoadModule(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           SizeOfDll
    );
#endif

BOOL
IMAGEAPI
SymUnloadModule64(
    IN  HANDLE          hProcess,
    IN  DWORD64         BaseOfDll
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnloadModule SymUnloadModule64
#else
BOOL
IMAGEAPI
SymUnloadModule(
    IN  HANDLE          hProcess,
    IN  DWORD           BaseOfDll
    );
#endif

BOOL
IMAGEAPI
SymUnDName64(
    IN  PIMAGEHLP_SYMBOL64 sym,               // Symbol to undecorate
    OUT PSTR               UnDecName,         // Buffer to store undecorated name in
    IN  DWORD              UnDecNameLength    // Size of the buffer
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnDName SymUnDName64
#else
BOOL
IMAGEAPI
SymUnDName(
    IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
    OUT PSTR             UnDecName,         // Buffer to store undecorated name in
    IN  DWORD            UnDecNameLength    // Size of the buffer
    );
#endif

BOOL
IMAGEAPI
SymRegisterCallback64(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    IN ULONG64                       UserContext
    );

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    IN HANDLE                       hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    IN ULONG64                      UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymRegisterCallback SymRegisterCallback64
#define SymRegisterFunctionEntryCallback SymRegisterFunctionEntryCallback64
#else
BOOL
IMAGEAPI
SymRegisterCallback(
    IN HANDLE                      hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    IN PVOID                       UserContext
    );

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    IN HANDLE                     hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    IN PVOID                      UserContext
    );
#endif


// Structure types
typedef enum IMAGEHLP_TYPES {
   IMAGEHLP_TYPEID_INDEX = 1,
   IMAGEHLP_TYPEID_NAME,
   IMAGEHLP_TYPEID_IMAGEHLP_SYMBOL,
   IMAGEHLP_TYPEID_IMAGEHLP_SYMBOL64,
   IMAGEHLP_TYPEID_MODULE_TYPE_INFO,
   IMAGEHLP_TYPEID_TYPE_ENUM_INFO,
   IMAGEHLP_TYPEID_ADDR,
   IMAGEHLP_TYPEID_ADDR_ENUM,
} IMAGEHLP_TYPES;

typedef struct _MODULE_TYPE_INFO { // AKA TYPTYP
    USHORT      dataLength;
    USHORT      leaf;
    BYTE        data[1];
} MODULE_TYPE_INFO, *PMODULE_TYPE_INFO;

#define IMAGEHLP_SYMBOL_INFO_VALUEPRESENT          1
#define IMAGEHLP_SYMBOL_INFO_REGISTER              SYMF_REGISTER        // 0x08
#define IMAGEHLP_SYMBOL_INFO_REGRELATIVE           SYMF_REGREL          // 0x10
#define IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE         SYMF_FRAMEREL        // 0x20

typedef struct _SYMBOL_INFO {
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Reserved2;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    CHAR        Name[1];          // Name of symbol
} SYMBOL_INFO, *PSYMBOL_INFO;

typedef BOOL
(CALLBACK *PSYMBOL_TYPE_NAME_CALLBACK)(
    PSTR  MatchedName,
    ULONG typeIndex,
    PVOID CallerData
    );

typedef BOOL
(CALLBACK *PSYMBOL_TYPE_NAME_ADDR_CALLBACK)(
    PSTR    MatchedName,
    ULONG   typeIndex,
    ULONG64 symAddress,
    PVOID   CallerData
    );

typedef struct _TYPE_ENUM_INFO {
   PVOID   CallerData;
   PSYMBOL_TYPE_NAME_CALLBACK CallbackRoutine;
} TYPE_ENUM_INFO, *PTYPE_ENUM_INFO;

typedef struct _TYPE_ADDR_ENUM_INFO {
   PVOID   CallerData;
   PSYMBOL_TYPE_NAME_ADDR_CALLBACK CallbackRoutine;
} TYPE_ENUM_ADDR_INFO, *PTYPE_ENUM_ADDR_INFO;

BOOL
IMAGEAPI
SymGetModuleInfoEx64(
    IN  HANDLE          hProcess,
    IN  DWORD64         Address,
    IN  IMAGEHLP_TYPES  TypeIn,
    IN  PBYTE           DataIn,
    IN  IMAGEHLP_TYPES  TypeOut,
    IN  OUT PULONG      SizeOut,
    IN  OUT PBYTE       DataOut
    );
#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfoEx SymGetModuleInfoEx64
#else
BOOL
IMAGEAPI
SymGetModuleInfoEx(
    IN  HANDLE          hProcess,
    IN  DWORD           Address,
    IN  IMAGEHLP_TYPES  TypeIn,
    IN  PBYTE           DataIn,
    IN  IMAGEHLP_TYPES  TypeOut,
    IN  OUT PULONG      SizeOut,
    IN  OUT PBYTE       DataOut
    );
#endif

BOOL
IMAGEAPI
SymGetSymbolInfo64(
    IN  HANDLE          hProcess,
    IN  DWORD64         Address,
    IN  IMAGEHLP_TYPES  TypeIn,
    IN  PBYTE           DataIn,
    IN  IMAGEHLP_TYPES  TypeOut,
    IN  OUT PULONG      SizeOut,
    IN  OUT PBYTE       DataOut
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymbolInfo SymGetSymbolInfo64
#else
BOOL
IMAGEAPI
SymGetSymbolInfo(
    IN  HANDLE          hProcess,
    IN  DWORD           Address,
    IN  IMAGEHLP_TYPES  TypeIn,
    IN  PBYTE           DataIn,
    IN  IMAGEHLP_TYPES  TypeOut,
    IN  PULONG          SizeOut,
    IN  OUT PBYTE       DataOut
    );
#endif

typedef struct _IMAGEHLP_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 BackingStoreOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[5];
    BOOL    Virtual;
    ULONG   Reserved2;
} IMAGEHLP_STACK_FRAME, *PIMAGEHLP_STACK_FRAME;

typedef VOID IMAGEHLP_CONTEXT, *PIMAGEHLP_CONTEXT;


ULONG
SymSetContext(
    HANDLE hProcess,
    PIMAGEHLP_STACK_FRAME StackFrame,
    PIMAGEHLP_CONTEXT Context
    );

//
// Full user-mode dump creation.
//

typedef BOOL (WINAPI *PDBGHELP_CREATE_USER_DUMP_CALLBACK)(
    DWORD       DataType,
    PVOID*      Data,
    LPDWORD     DataLength,
    PVOID       UserData
    );

BOOL
WINAPI
DbgHelpCreateUserDump(
    IN LPSTR                              FileName,
    IN PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    IN PVOID                              UserData
    );

BOOL
WINAPI
DbgHelpCreateUserDumpW(
    IN LPWSTR                             FileName,
    IN PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    IN PVOID                              UserData
    );

typedef BOOL
(CALLBACK *PSYM_ENUMERATESYMBOLS_CALLBACK)(
    PSYMBOL_INFO  pSymInfo,
    ULONG         SymbolSize,
    PVOID         UserContext
    );
BOOL
IMAGEAPI
SymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement,
    IN OUT PSYMBOL_INFO     Symbol
    );

BOOL
IMAGEAPI
SymFromName(
    IN  HANDLE              hProcess,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    );

BOOL
IMAGEAPI
SymEnumSym(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    );




#include <pshpack4.h>

#pragma warning(disable:4200) // Zero length array

#ifndef _MINIDUMP_H_
#define _MINIDUMP_H_
#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef DWORD RVA;

C_ASSERT (sizeof (UINT16) == 2);

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR {
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR {
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;


typedef struct _MINIDUMP_HEADER {
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    ULONG32 Reserved;
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to 
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY {
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING {
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE {

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
// 
    
typedef struct _MINIDUMP_SYSTEM_INFO {

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //
    
    UINT16 ProcessorArchitecture;
    UINT16 ProcessorLevel;
    UINT16 ProcessorRevision;

    UINT16 Reserved0;              // Reserved for future use. Must be zero.

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //
    
    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //
    
    RVA CSDVersionRva;

    ULONG32 Reserved1;             // Reserved for future use.

    //
    // CPU information is obtained from one of two places.
    //
    //  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
    //     instruction. You must use the X86 portion of the union for X86
    //     computers.
    //
    //  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
    //     IsProcessorFeatureSupported().
    //
    
    union _CPU_INFORMATION {

        //
        // X86 platforms use CPUID function to obtain processor information.
        //
        
        struct {

            //
            // CPUID Subfunction 0, register EAX (VendorId [0]),
            // EBX (VendorId [1]) and ECX (VendorId [2]).
            //
            
            ULONG32 VendorId [ 3 ];
            
            //
            // CPUID Subfunction 1, register EAX
            //
            
            ULONG32 VersionInformation;

            //
            // CPUID Subfunction 1, register EDX
            //
            
            ULONG32 FeatureInformation;
            

            //
            // CPUID, Subfunction 80000001, register EBX. This will only
            // be obtained if the vendor id is "AuthenticAMD".
            //
            
            ULONG32 AMDExtendedCpuFeatures;
    
        } X86CpuInfo;

        //
        // Non-x86 platforms use processor feature flags.
        //
        
        struct {

            ULONG64 ProcessorFeatures [ 2 ];
            
        } OtherCpuInfo;
        
    } Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;

typedef union _CPU_INFORMATION CPU_INFORMATION, *PCPU_INFORMATION;


//
// The minidump thread contains standard thread
// information plus an RVA to the stack for this 
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT (sizeof ( ((PPROCESS_INFORMATION)0)->dwThreadId ) == 4);

typedef struct _MINIDUMP_THREAD {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION  {
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM {
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE {
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;   


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST {
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST {
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION {
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;


//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD {
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM {
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION {
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE {
    ModuleCallback,
    ThreadCallback
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS {
    ThreadWriteThread           = 0x0001,
    ThreadWriteStack            = 0x0002,
    ThreadWriteContext          = 0x0004
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK {
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord; 
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS {
    ModuleWriteModule       = 0x0001,
    ModuleWriteDataSeg      = 0x0002,
    ModuleWriteMiscRecord   = 0x0004
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_CALLBACK_INPUT {
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union {
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_MODULE_CALLBACK Module;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT {
    union {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;

        

typedef enum _MINIDUMP_TYPE {
    MiniDumpNormal,
    MiniDumpWithDataSegs
} MINIDUMP_TYPE;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI * MINIDUMP_CALLBACK_ROUTINE) (
    IN PVOID CallbackParam,
    IN CONST PMINIDUMP_CALLBACK_INPUT CallbackInput,
    IN OUT PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
    );

typedef struct _MINIDUMP_CALLBACK_INFORMATION {
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    );

BOOL
WINAPI
MiniDumpReadDumpStream(
    IN PVOID BaseOfDump,
    IN ULONG StreamNumber,
    OUT PMINIDUMP_DIRECTORY * Dir, OPTIONAL
    OUT PVOID * StreamPointer, OPTIONAL
    OUT ULONG * StreamSize OPTIONAL
    );

#endif // _MINIDUMP_H_

#include <poppack.h>

#ifdef __cplusplus
}
#endif


#endif // _IMAGEHLP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\inilib.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1993-1999. All rights reserved.
//
//  MODULE: nminilib.h
//
//  These files are used to read a parsers ini file and generate the 
//  appropriate handoff set. Ini_path gets the path to the ini file given the
//  parser dll s name and buildhs reads the ini file and builds the parsers 
//  handoff set.
//=============================================================================

#include <nmsupp.h>

#ifndef _NMINILIB_
#define _NMINILIB_

#ifdef __cplusplus
extern "C"
{
#endif

#define INI_PATH_LENGTH             256                 // Maximum path tha can be specified
#define MAX_HANDOFF_ENTRY_LENGTH    80                  // Longest entry that can be specified ie.. 0x451 = NCP
#define MAX_PROTOCOL_NAME           40                  // Longest name for a protoocl
#define NUMALLOCENTRIES             10
#define RAW_INI_STR_LEN             200

#define PARSERS_SUBDIR              "PARSERS"
#define INI_EXTENSION               "INI"
#define BASE10_FORMAT_STR           "%ld=%s %ld"           
#define BASE16_FORMAT_STR           "%lx=%s %lx"           


// Given "XNS" or "TCP" or whatever BuildINIPath will return fully qual. path to "XNS.INI" or "TCP.INI"
extern LPSTR _cdecl BuildINIPath( char     *FullPath,          // Buffer that will contain fully qual. path to ini file
                                  char     *IniFileName );     // DLL name


// Builds Handoff Set

extern DWORD     WINAPI CreateHandoffTable(LPSTR               secName,
                                           LPSTR               iniFile,
                                           LPHANDOFFTABLE *    hTable,
                                           DWORD               nMaxProtocolEntries,
                                           DWORD               base);

extern HPROTOCOL WINAPI GetProtocolFromTable(LPHANDOFFTABLE  hTable, // lp to Handoff Table...
                                             DWORD           ItemToFind,       // port number etc...
                                             PDWORD_PTR      lpInstData );   // inst data to give to next protocol

extern VOID      WINAPI DestroyHandoffTable( LPHANDOFFTABLE hTable );

extern BOOLEAN WINAPI IsRawIPXEnabled(LPSTR               secName,
                                      LPSTR               iniFile,
                                      LPSTR               CurProtocol );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\iomanip.h ===
/***
*iomanip.h - definitions/declarations for iostream's parameterized manipulators
*
*       Copyright (c) 1991-2000, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes' paramterized manipulators.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOMANIP
#define _INC_IOMANIP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

#include <iostream.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

// #define __MKMANIP(X) \#define X##(T) __##X##_ \#\# T
// __MKMANIP(SMANIP);
// __MKMANIP(SAPP);
// __MKMANIP(IMANIP);
// __MKMANIP(IAPP);
// __MKMANIP(OMANIP);
// __MKMANIP(OAPP);
// __MKMANIP(IOMANIP);
// __MKMANIP(IOAPP);

#define SMANIP(T) __SMANIP_##T
#define SAPP(T) __SAPP_##T
#define IMANIP(T) __IMANIP_##T
#define IAPP(T) __IAPP_##T
#define OMANIP(T) __OMANIP_##T
#define OAPP(T) __OAPP_##T
#define IOMANIP(T) __IOMANIP_##T
#define IOAPP(T) __IOAPP_##T

#define IOMANIPdeclare(T)  \
class SMANIP(T) { \
public: \
        SMANIP(T)(ios& (*f)(ios&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
        friend ostream& operator<<(ostream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
private:        \
        ios& (* _fp)(ios&,T); \
        T _tp; \
};      \
class SAPP(T) { \
public: \
        SAPP(T)( ios& (*f)(ios&,T)) : _fp(f) {} \
        SMANIP(T) operator()(T t) { return SMANIP(T)(_fp,t); }  \
private:        \
        ios& (* _fp)(ios&,T); \
};      \
class IMANIP(T) { \
public: \
        IMANIP(T)(istream& (*f)(istream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, IMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        istream& (* _fp)(istream&,T); \
        T _tp;  \
};      \
class IAPP(T) { \
public: \
        IAPP(T)( istream& (*f)(istream&,T)) : _fp(f) {} \
        IMANIP(T) operator()(T t) { return IMANIP(T)(_fp,t); }  \
private:        \
        istream& (* _fp)(istream&,T); \
};      \
class OMANIP(T) { \
public: \
        OMANIP(T)(ostream& (*f)(ostream&,T), T t) : _fp(f), _tp(t) {} \
        friend ostream& operator<<(ostream& s, OMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        ostream& (* _fp)(ostream&,T); \
        T _tp; \
};      \
class OAPP(T) { \
public: \
        OAPP(T)(ostream& (*f)(ostream&,T)) : _fp(f) {}  \
        OMANIP(T) operator()(T t) { return OMANIP(T)(_fp,t); } \
private:        \
        ostream& (* _fp)(ostream&,T); \
};      \
\
class IOMANIP(T) { \
public: \
        IOMANIP(T)(iostream& (*f)(iostream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
        friend ostream& operator<<(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        iostream& (* _fp)(iostream&,T); \
        T _tp; \
};      \
class IOAPP(T) {        \
public: \
        IOAPP(T)( iostream& (*f)(iostream&,T)) : _fp(f) {}      \
        IOMANIP(T) operator()(T t) { return IOMANIP(T)(_fp,t); }        \
private:        \
        iostream& (* _fp)(iostream&,T); \
}; \

        
IOMANIPdeclare(int)

IOMANIPdeclare(long)

inline ios& __resetiosflags(ios& s, long _flg) { s.setf(0,_flg); return s; }
inline ios& __setfill(ios& s, int _fc) { s.fill((char)_fc); return s; }
inline ios& __setiosflags(ios& s, long _flg) { s.setf(_flg); return s; }
inline ios& __setprecision(ios& s, int _pre) { s.precision(_pre); return s; }
inline ios& __setw(ios& s, int _wid) { s.width(_wid); return s; }

inline SMANIP(long)     resetiosflags(long _l) { return SMANIP(long)(__resetiosflags, _l); }
inline SMANIP(int)      setfill(int _m) {return SMANIP(int)(__setfill, _m); }
inline SMANIP(long)     setiosflags(long _l) {return SMANIP(long)(__setiosflags, _l); }
inline SMANIP(int)      setprecision(int _p) {return SMANIP(int)(__setprecision, _p); }
inline SMANIP(int)      setw(int _w) { return SMANIP(int)(__setw, _w); }

// Restore previous packing
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOMANIP

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\iostream.h ===
/***
*iostream.h - definitions/declarations for iostream classes
*
*       Copyright (c) 1990-2000, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


typedef long streamoff, streampos;

#include <ios.h>                // Define ios.

#include <streamb.h>            // Define streambuf.

#include <istream.h>            // Define istream.

#include <ostream.h>            // Define ostream.

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP iostream : public istream, public ostream {
public:
        iostream(streambuf*);
        virtual ~iostream();
protected:
        iostream();
        iostream(const iostream&);
inline iostream& operator=(streambuf*);
inline iostream& operator=(iostream&);
private:
        iostream(ios&);
        iostream(istream&);
        iostream(ostream&);
};

inline iostream& iostream::operator=(streambuf* _sb) { istream::operator=(_sb); ostream::operator=(_sb); return *this; }

inline iostream& iostream::operator=(iostream& _strm) { return operator=(_strm.rdbuf()); }

class _CRTIMP Iostream_init {
public:
        Iostream_init();
        Iostream_init(ios &, int =0);   // treat as private
        ~Iostream_init();
};

// used internally
// static Iostream_init __iostreaminit; // initializes cin/cout/cerr/clog

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\intshcut.h ===
/*
 * intshcut.h - Internet Shortcut interface definitions.
 *
 * Copyright (c) 1995-1998, Microsoft Corporation.  All rights reserved.
 */


#ifndef __INTSHCUT_H__
#define __INTSHCUT_H__

/* Headers
 **********/

#include <isguids.h>


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* Define API decoration for direct import of DLL functions. */

#ifdef _INTSHCUT_
#define INTSHCUTAPI
#else
#define INTSHCUTAPI                 DECLSPEC_IMPORT
#endif

/* HRESULTs */

//
// MessageId: E_FLAGS
//
// MessageText:
//
//  The flag combination is invalid.
//
#define E_FLAGS                     MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1000)

//
// MessageId: IS_E_EXEC_FAILED
//
// MessageText:
//
//  The URL's protocol handler failed to run.
//
#define IS_E_EXEC_FAILED            MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x2002)

//
// MessageId: URL_E_INVALID_SYNTAX
//
// MessageText:
//
//  The URL's syntax is invalid.
//
#define URL_E_INVALID_SYNTAX        MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1001)

//
// MessageId: URL_E_UNREGISTERED_PROTOCOL
//
// MessageText:
//
//  The URL's protocol does not have a registered protocol handler.
//
#define URL_E_UNREGISTERED_PROTOCOL MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1002)


/* Interfaces
 *************/

//
// Input flags for IUniformResourceLocator::SetURL().
//
typedef enum iurl_seturl_flags
{
   IURL_SETURL_FL_GUESS_PROTOCOL        = 0x0001,     // Guess protocol if missing
   IURL_SETURL_FL_USE_DEFAULT_PROTOCOL  = 0x0002,     // Use default protocol if missing
}
IURL_SETURL_FLAGS;


//
// Input flags for IUniformResourceLocator()::InvokeCommand().
//
typedef enum iurl_invokecommand_flags
{
   IURL_INVOKECOMMAND_FL_ALLOW_UI                  = 0x0001,
   IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB          = 0x0002,    // Ignore pcszVerb
   IURL_INVOKECOMMAND_FL_DDEWAIT                   = 0x0004,    // pass DDEWAIT to ShellExec
}
IURL_INVOKECOMMAND_FLAGS;


//
// Command info for IUniformResourceLocator::InvokeCommand().
//

typedef struct urlinvokecommandinfoA
{
   DWORD  dwcbSize;          // Size of structure
   DWORD  dwFlags;           // Bit field of IURL_INVOKECOMMAND_FLAGS
   HWND   hwndParent;        // Parent window.  Valid only if IURL_INVOKECOMMAND_FL_ALLOW_UI is set.
   LPCSTR pcszVerb;          // Verb to invoke.  Ignored if IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB is set.
}
URLINVOKECOMMANDINFOA;
typedef URLINVOKECOMMANDINFOA *PURLINVOKECOMMANDINFOA;
typedef const URLINVOKECOMMANDINFOA CURLINVOKECOMMANDINFOA;
typedef const URLINVOKECOMMANDINFOA *PCURLINVOKECOMMANDINFOA;

typedef struct urlinvokecommandinfoW
{
   DWORD   dwcbSize;          // Size of structure
   DWORD   dwFlags;           // Bit field of IURL_INVOKECOMMAND_FLAGS
   HWND    hwndParent;        // Parent window.  Valid only if IURL_INVOKECOMMAND_FL_ALLOW_UI is set.
   LPCWSTR pcszVerb;          // Verb to invoke.  Ignored if IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB is set.
}
URLINVOKECOMMANDINFOW;
typedef URLINVOKECOMMANDINFOW *PURLINVOKECOMMANDINFOW;
typedef const URLINVOKECOMMANDINFOW CURLINVOKECOMMANDINFOW;
typedef const URLINVOKECOMMANDINFOW *PCURLINVOKECOMMANDINFOW;

#ifdef UNICODE
#define URLINVOKECOMMANDINFO            URLINVOKECOMMANDINFOW
#define PURLINVOKECOMMANDINFO           PURLINVOKECOMMANDINFOW
#define CURLINVOKECOMMANDINFO           CURLINVOKECOMMANDINFOW
#define PCURLINVOKECOMMANDINFO          PCURLINVOKECOMMANDINFOW
#else
#define URLINVOKECOMMANDINFO            URLINVOKECOMMANDINFOA
#define PURLINVOKECOMMANDINFO           PURLINVOKECOMMANDINFOA
#define CURLINVOKECOMMANDINFO           CURLINVOKECOMMANDINFOA
#define PCURLINVOKECOMMANDINFO          PCURLINVOKECOMMANDINFOA
#endif


//===========================================================================
//
// IUniformResourceLocator interface
//
// [OverView]
//
//  Provides access to Internet Shortcuts.
//
// [Member functions]
//
// IUniformResourceLocator::SetURL
//
//   This member function sets an object's URL.
//
//   The dwInFlags parameter specifies the behavior:
//
//  IURL_SETURL_FL_GUESS_PROTOCOL: The protocol scheme is guessed and added
//   to the URL, if it is not specified in pcszURL.
//
//  IURL_SETURL_FL_USE_DEFAULT_PROTOCOL: The default protocol scheme is added
//   to the URL, if it is not specified in pcszURL.
//
//   The function returns S_OK if the object's URL is set successfully.
//  Otherwise, an error code is returned:
//
//  E_OUTOFMEMORY:  There is not enough memory to complete the operation.
//
//  IS_E_EXEC_FAILED:  The URL's protocol handler failed to run.
//
//  URL_E_INVALID_SYNTAX:  The URL's syntax is invalid.
//
//  URL_E_UNREGISTERED_PROTOCOL:  The URL's protocol does not have a
//   registered protocol handler.
//
//
// IUniformResourceLocator::GetURL
//
//   This member function retrieves an object's URL.  The ppszURL is a
//  pointer to a PSTR to be filled in which a pointer to the object's
//  URL.  When finished, this string should be freed using IMalloc::Free().
//
//   The function returns S_OK if the object's URL was retrieved
//  successfully.  If the object does not have a URL associated with it,
//  then S_FALSE is returned and *ppszURL is set to NULL.  Otherwise, an
//  error code is returned:
//
//  E_OUTOFMEMORY:  There is not enough memory to complete the operation.
//
//  IS_E_EXEC_FAILED:  The URL's protocol handler failed to run.
//
//  URL_E_INVALID_SYNTAX:  The URL's syntax is invalid.
//
//  URL_E_UNREGISTERED_PROTOCOL:  The URL's protocol does not have a
//   registered protocol handler.
//
//
// IUniformResourceLocator::InvokeCommand
//
//   This member function invokes a command on an object's URL.  The purlici
//  parameter is a pointer to a URLINVOKECOMMANDINFO structure which
//  describes the command to be invoked.
//
//   The function returns S_OK if the object's URL was opened successfully.
//  If the object does not have a URL associated with it, the function
//  returns S_FALSE.  Otherwise, an error code is returned:
//
//  E_OUTOFMEMORY:  There is not enough memory to complete the operation.
//
//  IS_E_EXEC_FAILED:  The URL's protocol handler failed to run.
//
//  URL_E_INVALID_SYNTAX:  The URL's syntax is invalid.
//
//  URL_E_UNREGISTERED_PROTOCOL:  The URL's protocol does not have a
//   registered protocol handler.
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE IUniformResourceLocatorA

DECLARE_INTERFACE_(IUniformResourceLocatorA, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;
   STDMETHOD_(ULONG, AddRef)(THIS) PURE;
   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IUniformResourceLocator methods */

   STDMETHOD(SetURL)(THIS_
                     LPCSTR pcszURL,
                     DWORD dwInFlags) PURE;

   STDMETHOD(GetURL)(THIS_
                     LPSTR *ppszURL) PURE;

   STDMETHOD(InvokeCommand)(THIS_
                            PURLINVOKECOMMANDINFOA purlici) PURE;
};

#undef  INTERFACE
#define INTERFACE IUniformResourceLocatorW

DECLARE_INTERFACE_(IUniformResourceLocatorW, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;
   STDMETHOD_(ULONG, AddRef)(THIS) PURE;
   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IUniformResourceLocator methods */

   STDMETHOD(SetURL)(THIS_
                     LPCWSTR pcszURL,
                     DWORD dwInFlags) PURE;

   STDMETHOD(GetURL)(THIS_
                     LPWSTR *ppszURL) PURE;

   STDMETHOD(InvokeCommand)(THIS_
                            PURLINVOKECOMMANDINFOW purlici) PURE;
};

#ifdef UNICODE
#define IUniformResourceLocator         IUniformResourceLocatorW
#define IUniformResourceLocatorVtbl     IUniformResourceLocatorWVtbl
#else
#define IUniformResourceLocator         IUniformResourceLocatorA
#define IUniformResourceLocatorVtbl     IUniformResourceLocatorAVtbl
#endif

typedef IUniformResourceLocator *PIUniformResourceLocator;
typedef const IUniformResourceLocator CIUniformResourceLocator;
typedef const IUniformResourceLocator *PCIUniformResourceLocator;


/* Prototypes
 *************/

//
// Input flags for TranslateURL().
//
typedef enum translateurl_in_flags
{
   TRANSLATEURL_FL_GUESS_PROTOCOL         = 0x0001,     // Guess protocol if missing
   TRANSLATEURL_FL_USE_DEFAULT_PROTOCOL   = 0x0002,     // Use default protocol if missing
}
TRANSLATEURL_IN_FLAGS;


//
//   TranslateURL().  This function applies common translations to a URL
//  string, creating a new URL string.
//
//   This function does not perform any validation on the syntax of the input
//  URL string.  A successful return value does not indicate that the input
//  or output URL strings are valid URLS.
//
//   The function returns S_OK if the URL string is translated successfully
//  and *ppszTranslatedURL points to the translated URL string.  S_FALSE
//  is returned if the URL string did not require translation.  An error
//  code is returned if an error occurs.
//
//  Parameters:
//   pcszURL -- A pointer to the URL string to be translated.
//   dwInFlags -- A bit field of TRANSLATEURL_IN_FLAGS.
//   ppszTranslatedURL -- A pointer to the newly created, translated URL
//     string, if any.  *ppszTranslatedURL is only valid if S_OK is returned.
//     If valid, *ppszTranslatedURL should be freed by calling LocalFree().
//     *ppszTranslatedURL is NULL on error.
//

INTSHCUTAPI HRESULT WINAPI TranslateURLA(PCSTR pcszURL,
                                         DWORD dwInFlags,
                                         PSTR *ppszTranslatedURL);
INTSHCUTAPI HRESULT WINAPI TranslateURLW(PCWSTR pcszURL,
                                         DWORD dwInFlags,
                                         PWSTR UNALIGNED *ppszTranslatedURL);
#ifdef UNICODE
#define TranslateURL             TranslateURLW
#else
#define TranslateURL             TranslateURLA
#endif   /* UNICODE */


//
// Input flags for URLAssociationDialog().
//
typedef enum urlassociationdialog_in_flags
{
   URLASSOCDLG_FL_USE_DEFAULT_NAME        = 0x0001,
   URLASSOCDLG_FL_REGISTER_ASSOC          = 0x0002
}
URLASSOCIATIONDIALOG_IN_FLAGS;


//
//   URLAssocationDialog().  This function invokes the unregistered URL
//  protocol dialog box, providing a standard ui for choosing the handler for
//  an unregistered URL protocol.
//
//  The functions returns S_OK if the application is registered with the
//  URL protocol.  S_FALSE is returned if nothing is registered (a one-time
//  execution via the selected application is requested).
//
//  Parameters:
//   hwndParent -- A handle to the window to be used as the parent
//   dwInFlags -- A bit field of URLASSOCIATIONDIALOG_IN_FLAGS.  The
//                flags are:
//
//                  URLASSOCDLG_FL_USE_DEFAULT_NAME: Use the default Internet
//                   Shortcut file name.  Ignore pcszFile.
//
//                  URLASSOCDLG_FL_REGISTER_ASSOC: The application
//                   selected is to be registered as the handler for URLs
//                   of pcszURL's protocol.  An application is only
//                   registered if this flag is set, and the user indicates
//                   that a persistent association is to be made.
//
//   pcszFile -- The name of the Internet Shortcut file whose URL's protocol
//               requires a protocol handler.  Before a verb, like "open", can
//               be invoked on an Internet Shortcut, a protocol handler must be
//               registered for its URL protocol.  If
//               URLASSOCDLG_FL_USE_DEFAULT_NAME is set in dwInFlags, pcszFile
//               is ignored, and a default Internet Shortcut file name is used.
//               pcszFile is only used for ui.
//   pcszURL -- The URL whose unregistered protocol requires a handler.
//   pszAppBuf -- A buffer to be filled in on success with the path
//                of the application selected by the user.  pszAppBuf's
//                buffer is filled in with the empty string on failure.
//   ucAppBufLen -- The length of pszAppBuf's buffer in characters.
//

INTSHCUTAPI HRESULT WINAPI URLAssociationDialogA(HWND hwndParent,
                                                 DWORD dwInFlags,
                                                 PCSTR pcszFile,
                                                 PCSTR pcszURL,
                                                 PSTR pszAppBuf,
                                                 UINT ucAppBufLen);
INTSHCUTAPI HRESULT WINAPI URLAssociationDialogW(HWND hwndParent,
                                                 DWORD dwInFlags,
                                                 PCWSTR pcszFile,
                                                 PCWSTR pcszURL,
                                                 PWSTR pszAppBuf,
                                                 UINT ucAppBufLen);
#ifdef UNICODE
#define URLAssociationDialog     URLAssociationDialogW
#else
#define URLAssociationDialog     URLAssociationDialogA
#endif  /* UNICODE */


//
// Input flags for MIMEAssocationDialog().
//
typedef enum mimeassociationdialog_in_flags
{
   MIMEASSOCDLG_FL_REGISTER_ASSOC         = 0x0001
}
MIMEASSOCIATIONDIALOG_IN_FLAGS;


//
//   MIMEAssociationDialog().  Invokes the unregistered MIME content
//  type dialog box.
//
//   This function does not perform any validation on the syntax of the
//  input content type string.  A successful return value does not indicate
//  that the input MIME content type string is a valid content type.
//
//   The function returns S_OK if the MIME content type is associated
//  with the extension.  The extension is associated as the default
//  extension for the content type.  S_FALSE is returned if nothing is
//  registered.  Otherwise, the function returns one of the following
//  errors:
//
//  E_ABORT -- The user cancelled the operation.
//  E_FLAGS -- The flag combination passed in dwFlags is invalid.
//  E_OUTOFMEMORY -- Not enough memory to complete the operation.
//  E_POINTER -- One of the input pointers is invalid.
//
//  Parameters:
//   hwndParent -- A handle to the window to be used as the parent
//                 window of any posted child windows.
//   dwInFlags -- A bit field of MIMEASSOCIATIONDIALOG_IN_FLAGS.  The
//                flags are:
//
//              MIMEASSOCDLG_FL_REGISTER_ASSOC: If set, the application
//               selected is to be registered as the handler for files of
//               the given MIME type.  If clear, no association is to be
//               registered.  An application is only registered if this
//               flag is set, and the user indicates that a persistent
//               association is to be made.  Registration is only possible
//               if pcszFile contains an extension.
//
//   pcszFile -- A pointer to a string indicating the name of the file
//               containing data of pcszMIMEContentType's content type.
//   pcszMIMEContentType -- A pointer to a string indicating the content
//                          type for which an application is sought.
//   pszAppBuf -- A buffer to be filled in on success with the path of
//                the application selected by the user.  pszAppBuf's buffer
//                is filled in with the empty string on failure.
//   ucAppBufLen -- The length of pszAppBuf's buffer in characters.
//

INTSHCUTAPI HRESULT WINAPI MIMEAssociationDialogA(HWND hwndParent,
                                                  DWORD dwInFlags,
                                                  PCSTR pcszFile,
                                                  PCSTR pcszMIMEContentType,
                                                  PSTR pszAppBuf,
                                                  UINT ucAppBufLen);
INTSHCUTAPI HRESULT WINAPI MIMEAssociationDialogW(HWND hwndParent,
                                                  DWORD dwInFlags,
                                                  PCWSTR pcszFile,
                                                  PCWSTR pcszMIMEContentType,
                                                  PWSTR pszAppBuf,
                                                  UINT ucAppBufLen);
#ifdef UNICODE
#define MIMEAssociationDialog    MIMEAssociationDialogW
#else
#define MIMEAssociationDialog    MIMEAssociationDialogA
#endif  /* UNICODE */


//
//   InetIsOffline().  This function determines if the user wants to be
//  "offline" (get all information from the cache).  The dwFlags must be
//  0.
//
//   The function returns TRUE to indicate that the local system is not
//  currently connected to the Internet.  The function returns FALSE to
//  indicate that either the local system is connected to the Internet,
//  or no attempt has yet been made to connect the local system to the
//  Internet.  Applications that wish to support an off-line mode should
//  do so if InetIsOffline() returns TRUE.
//
//   Off-line mode begins when the user has been prompted to dial-in to
//  an Internet providor, but canceled the attempt.
//
INTSHCUTAPI
BOOL
WINAPI
InetIsOffline(
    DWORD dwFlags);


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __INTSHCUT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ios.h ===
/***
*ios.h - definitions/declarations for the ios class.
*
*       Copyright (c) 1990-2000, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the ios class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOS
#define _INC_IOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#ifdef  _MT

typedef struct __CRT_LIST_ENTRY {
   struct __CRT_LIST_ENTRY *Flink;
   struct __CRT_LIST_ENTRY *Blink;
} _CRT_LIST_ENTRY;

typedef struct _CRT_CRITICAL_SECTION_DEBUG {
    unsigned short Type;
    unsigned short CreatorBackTraceIndex;
    struct _CRT_CRITICAL_SECTION *CriticalSection;
    _CRT_LIST_ENTRY ProcessLocksList;
    unsigned long EntryCount;
    unsigned long ContentionCount;
    unsigned long Depth;
    void * OwnerBackTrace[ 5 ];
} _CRT_CRITICAL_SECTION_DEBUG, *_PCRT_CRITICAL_SECTION_DEBUG;

typedef struct _CRT_CRITICAL_SECTION {
    _PCRT_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    long LockCount;
    long RecursionCount;
    void * OwningThread;        // from the thread's ClientId->UniqueThread
    void * LockSemaphore;
    unsigned long Reserved;
} _CRT_CRITICAL_SECTION, *_PCRT_CRITICAL_SECTION;

extern "C" {
_CRTIMP void __cdecl _mtlock(_PCRT_CRITICAL_SECTION);
_CRTIMP void __cdecl _mtunlock(_PCRT_CRITICAL_SECTION);
}

#endif  /* _MT */

#ifndef NULL
#define NULL    0
#endif

#ifndef EOF
#define EOF     (-1)
#endif

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP streambuf;
class _CRTIMP ostream;

class _CRTIMP ios {

public:
    enum io_state {  goodbit = 0x00,
                     eofbit  = 0x01,
                     failbit = 0x02,
                     badbit  = 0x04 };

    enum open_mode { in        = 0x01,
                     out       = 0x02,
                     ate       = 0x04,
                     app       = 0x08,
                     trunc     = 0x10,
                     nocreate  = 0x20,
                     noreplace = 0x40,
                     binary    = 0x80 };

    enum seek_dir { beg=0, cur=1, end=2 };

    enum {  skipws     = 0x0001,
            left       = 0x0002,
            right      = 0x0004,
            internal   = 0x0008,
            dec        = 0x0010,
            oct        = 0x0020,
            hex        = 0x0040,
            showbase   = 0x0080,
            showpoint  = 0x0100,
            uppercase  = 0x0200,
            showpos    = 0x0400,
            scientific = 0x0800,
            fixed      = 0x1000,
            unitbuf    = 0x2000,
            stdio      = 0x4000
                                 };

    static const long basefield;        // dec | oct | hex
    static const long adjustfield;      // left | right | internal
    static const long floatfield;       // scientific | fixed

    ios(streambuf*);                    // differs from ANSI
    virtual ~ios();

    inline long flags() const;
    inline long flags(long _l);

    inline long setf(long _f,long _m);
    inline long setf(long _l);
    inline long unsetf(long _l);

    inline int width() const;
    inline int width(int _i);

    inline ostream* tie(ostream* _os);
    inline ostream* tie() const;

    inline char fill() const;
    inline char fill(char _c);

    inline int precision(int _i);
    inline int precision() const;

    inline int rdstate() const;
    inline void clear(int _i = 0);

//  inline operator void*() const;
    operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
    inline int operator!() const;

    inline int  good() const;
    inline int  eof() const;
    inline int  fail() const;
    inline int  bad() const;

    inline streambuf* rdbuf() const;

    inline long & iword(int) const;
    inline void * & pword(int) const;

    static long bitalloc();
    static int xalloc();
    static void sync_with_stdio();

#ifdef  _MT
    inline void __cdecl setlock();
    inline void __cdecl clrlock();
    void __cdecl lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void __cdecl unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
    inline void __cdecl lockbuf();
    inline void __cdecl unlockbuf();
#else
    void __cdecl lock() { }
    void __cdecl unlock() { }
    void __cdecl lockbuf() { }
    void __cdecl unlockbuf() { }
#endif

protected:
    ios();
    ios(const ios&);                    // treat as private
    ios& operator=(const ios&);
    void init(streambuf*);

    enum { skipping, tied };
    streambuf*  bp;

    int     state;
    int     ispecial;                   // not used
    int     ospecial;                   // not used
    int     isfx_special;               // not used
    int     osfx_special;               // not used
    int     x_delbuf;                   // if set, rdbuf() deleted by ~ios

    ostream* x_tie;
    long    x_flags;
    int     x_precision;
    char    x_fill;
    int     x_width;

    static void (*stdioflush)();        // not used

#ifdef  _MT
    static void lockc() { _mtlock(& x_lockc); }
    static void unlockc() { _mtunlock( & x_lockc); }
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#else
    static void lockc() { }
    static void unlockc() { }
#endif

public:
    int delbuf() const { return x_delbuf; }
    void    delbuf(int _i) { x_delbuf = _i; }

private:
    static long x_maxbit;
    static int x_curindex;
    static int sunk_with_stdio;         // make sure sync_with done only once
#ifdef  _MT
#define MAXINDEX 7
    static long x_statebuf[MAXINDEX+1];  // used by xalloc()
    static int fLockcInit;              // used to see if x_lockc initialized
    static _CRT_CRITICAL_SECTION x_lockc; // used to lock static (class) data members
    int LockFlg;                        // enable locking flag
    _CRT_CRITICAL_SECTION x_lock;       // used for multi-thread lock on object
#else
    static long * x_statebuf;  // used by xalloc()
#endif
};

#include <streamb.h>

inline _CRTIMP ios& __cdecl dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }

inline long ios::flags() const { return x_flags; }
inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }

inline long ios::setf(long _l,long _m){ long _lO; lock(); _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); unlock(); return _lO; }
inline long ios::setf(long _l){ long _lO; lock(); _lO = x_flags; x_flags |= _l; unlock(); return _lO; }
inline long ios::unsetf(long _l){ long _lO; lock(); _lO = x_flags; x_flags &= (~_l); unlock(); return _lO; }

inline int ios::width() const { return x_width; }
inline int ios::width(int _i){ int _iO; _iO = (int)x_width; x_width = _i; return _iO; }

inline ostream* ios::tie(ostream* _os){ ostream* _osO; _osO = x_tie; x_tie = _os; return _osO; }
inline ostream* ios::tie() const { return x_tie; }
inline char ios::fill() const { return x_fill; }
inline char ios::fill(char _c){ char _cO; _cO = x_fill; x_fill = _c; return _cO; }
inline int ios::precision(int _i){ int _iO; _iO = (int)x_precision; x_precision = _i; return _iO; }
inline int ios::precision() const { return x_precision; }

inline int ios::rdstate() const { return state; }

// inline ios::operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
inline int ios::operator!() const { return state&(badbit|failbit); }

inline int  ios::bad() const { return state & badbit; }
inline void ios::clear(int _i){ lock(); state = _i; unlock(); }
inline int  ios::eof() const { return state & eofbit; }
inline int  ios::fail() const { return state & (badbit | failbit); }
inline int  ios::good() const { return state == 0; }

inline streambuf* ios::rdbuf() const { return bp; }

inline long & ios::iword(int _i) const { return x_statebuf[_i] ; }
inline void * & ios::pword(int _i) const { return (void * &)x_statebuf[_i]; }

#ifdef  _MT
    inline void ios::setlock() { LockFlg--; if (bp) bp->setlock(); }
    inline void ios::clrlock() { if (LockFlg <= 0) LockFlg++; if (bp) bp->clrlock(); }
    inline void ios::lockbuf() { bp->lock(); }
    inline void ios::unlockbuf() { bp->unlock(); }
#endif

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOS

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\IPExport.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** IPEXPORT.H - IP public definitions.
//
//  This file contains public definitions exported to transport layer and
//  application software.
//

#ifndef IP_EXPORT_INCLUDED
#define IP_EXPORT_INCLUDED  1

#if _MSC_VER > 1000
#pragma once
#endif

//
// IP type definitions.
//
typedef ULONG IPAddr;       // An IP address.
typedef ULONG IPMask;       // An IP subnet mask.
typedef ULONG IP_STATUS;    // Status code returned from IP APIs.

#ifndef s6_addr
//
// Duplicate these definitions here so that this file can be included by
// kernel-mode components which cannot include ws2tcpip.h, as well as
// by user-mode components which do.
//

struct in6_addr {
    union {
        UCHAR       Byte[16];
        USHORT      Word[8];
    } u;
};

#define in_addr6 in6_addr

//
// Defines to match RFC 2553.
//
#define _S6_un      u
#define _S6_u8      Byte
#define s6_addr     _S6_un._S6_u8

//
// Defines for our implementation.
//
#define s6_bytes    u.Byte
#define s6_words    u.Word

#endif

typedef struct in6_addr IPv6Addr;

/*INC*/

//
// The ip_option_information structure describes the options to be
// included in the header of an IP packet. The TTL, TOS, and Flags
// values are carried in specific fields in the header. The OptionsData
// bytes are carried in the options area following the standard IP header.
// With the exception of source route options, this data must be in the
// format to be transmitted on the wire as specified in RFC 791. A source
// route option should contain the full route - first hop thru final
// destination - in the route data. The first hop will be pulled out of the
// data and the option will be reformatted accordingly. Otherwise, the route
// option should be formatted as specified in RFC 791.
//

typedef struct ip_option_information {
    UCHAR   Ttl;                // Time To Live
    UCHAR   Tos;                // Type Of Service
    UCHAR   Flags;              // IP header flags
    UCHAR   OptionsSize;        // Size in bytes of options data
    PUCHAR  OptionsData;        // Pointer to options data
} IP_OPTION_INFORMATION, *PIP_OPTION_INFORMATION;

#if defined(_WIN64)

typedef struct ip_option_information32 {
    UCHAR   Ttl;
    UCHAR   Tos;
    UCHAR   Flags;
    UCHAR   OptionsSize;
    UCHAR * POINTER_32 OptionsData;
} IP_OPTION_INFORMATION32, *PIP_OPTION_INFORMATION32;

#endif // _WIN64

//
// The icmp_echo_reply structure describes the data returned in response
// to an echo request.
//

typedef struct icmp_echo_reply {
    IPAddr  Address;            // Replying address
    ULONG   Status;             // Reply IP_STATUS
    ULONG   RoundTripTime;      // RTT in milliseconds
    USHORT  DataSize;           // Reply data size in bytes
    USHORT  Reserved;           // Reserved for system use
    PVOID   Data;               // Pointer to the reply data
    struct ip_option_information Options; // Reply options
} ICMP_ECHO_REPLY, *PICMP_ECHO_REPLY;

#if defined(_WIN64)

typedef struct icmp_echo_reply32 {
    IPAddr  Address;
    ULONG   Status;
    ULONG   RoundTripTime;
    USHORT  DataSize;
    USHORT  Reserved;
    VOID * POINTER_32 Data;
    struct ip_option_information32 Options;
} ICMP_ECHO_REPLY32, *PICMP_ECHO_REPLY32;

#endif // _WIN64

typedef struct arp_send_reply {
    IPAddr  DestAddress;
    IPAddr  SrcAddress;
} ARP_SEND_REPLY, *PARP_SEND_REPLY;

typedef struct tcp_reserve_port_range {
    USHORT  UpperRange;
    USHORT  LowerRange;
} TCP_RESERVE_PORT_RANGE, *PTCP_RESERVE_PORT_RANGE;

#define MAX_ADAPTER_NAME 128

typedef struct _IP_ADAPTER_INDEX_MAP {
    ULONG   Index;
    WCHAR   Name[MAX_ADAPTER_NAME];
} IP_ADAPTER_INDEX_MAP, *PIP_ADAPTER_INDEX_MAP;

typedef struct _IP_INTERFACE_INFO {
    LONG    NumAdapters;
    IP_ADAPTER_INDEX_MAP Adapter[1];
} IP_INTERFACE_INFO,*PIP_INTERFACE_INFO;

typedef struct _IP_UNIDIRECTIONAL_ADAPTER_ADDRESS {
    ULONG   NumAdapters;
    IPAddr  Address[1];
} IP_UNIDIRECTIONAL_ADAPTER_ADDRESS, *PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS;

typedef struct _IP_ADAPTER_ORDER_MAP {
    ULONG   NumAdapters;
    ULONG   AdapterOrder[1];
} IP_ADAPTER_ORDER_MAP, *PIP_ADAPTER_ORDER_MAP;

typedef struct _IP_MCAST_COUNTER_INFO {
    ULONG64 InMcastOctets;
    ULONG64 OutMcastOctets;
    ULONG64 InMcastPkts;
    ULONG64 OutMcastPkts;
} IP_MCAST_COUNTER_INFO, *PIP_MCAST_COUNTER_INFO;

//
// IP_STATUS codes returned from IP APIs
//

#define IP_STATUS_BASE              11000

#define IP_SUCCESS                  0
#define IP_BUF_TOO_SMALL            (IP_STATUS_BASE + 1)
#define IP_DEST_NET_UNREACHABLE     (IP_STATUS_BASE + 2)
#define IP_DEST_HOST_UNREACHABLE    (IP_STATUS_BASE + 3)
#define IP_DEST_PROT_UNREACHABLE    (IP_STATUS_BASE + 4)
#define IP_DEST_PORT_UNREACHABLE    (IP_STATUS_BASE + 5)
#define IP_NO_RESOURCES             (IP_STATUS_BASE + 6)
#define IP_BAD_OPTION               (IP_STATUS_BASE + 7)
#define IP_HW_ERROR                 (IP_STATUS_BASE + 8)
#define IP_PACKET_TOO_BIG           (IP_STATUS_BASE + 9)
#define IP_REQ_TIMED_OUT            (IP_STATUS_BASE + 10)
#define IP_BAD_REQ                  (IP_STATUS_BASE + 11)
#define IP_BAD_ROUTE                (IP_STATUS_BASE + 12)
#define IP_TTL_EXPIRED_TRANSIT      (IP_STATUS_BASE + 13)
#define IP_TTL_EXPIRED_REASSEM      (IP_STATUS_BASE + 14)
#define IP_PARAM_PROBLEM            (IP_STATUS_BASE + 15)
#define IP_SOURCE_QUENCH            (IP_STATUS_BASE + 16)
#define IP_OPTION_TOO_BIG           (IP_STATUS_BASE + 17)
#define IP_BAD_DESTINATION          (IP_STATUS_BASE + 18)

//
// Variants of the above using IPv6 terminology, where different
//

#define IP_DEST_NO_ROUTE            (IP_STATUS_BASE + 2)
#define IP_DEST_ADDR_UNREACHABLE    (IP_STATUS_BASE + 3)
#define IP_DEST_PROHIBITED          (IP_STATUS_BASE + 4)
#define IP_DEST_PORT_UNREACHABLE    (IP_STATUS_BASE + 5)
#define IP_HOP_LIMIT_EXCEEDED       (IP_STATUS_BASE + 13)
#define IP_REASSEMBLY_TIME_EXCEEDED (IP_STATUS_BASE + 14)
#define IP_PARAMETER_PROBLEM        (IP_STATUS_BASE + 15)

//
// IPv6-only status codes
//

#define IP_DEST_UNREACHABLE         (IP_STATUS_BASE + 40)
#define IP_TIME_EXCEEDED            (IP_STATUS_BASE + 41)
#define IP_BAD_HEADER               (IP_STATUS_BASE + 42)
#define IP_UNRECOGNIZED_NEXT_HEADER (IP_STATUS_BASE + 43)
#define IP_ICMP_ERROR               (IP_STATUS_BASE + 44)

//
// The next group are status codes passed up on status indications to
// transport layer protocols.
//
#define IP_ADDR_DELETED             (IP_STATUS_BASE + 19)
#define IP_SPEC_MTU_CHANGE          (IP_STATUS_BASE + 20)
#define IP_MTU_CHANGE               (IP_STATUS_BASE + 21)
#define IP_UNLOAD                   (IP_STATUS_BASE + 22)
#define IP_ADDR_ADDED               (IP_STATUS_BASE + 23)
#define IP_MEDIA_CONNECT            (IP_STATUS_BASE + 24)
#define IP_MEDIA_DISCONNECT         (IP_STATUS_BASE + 25)
#define IP_BIND_ADAPTER             (IP_STATUS_BASE + 26)
#define IP_UNBIND_ADAPTER           (IP_STATUS_BASE + 27)
#define IP_DEVICE_DOES_NOT_EXIST    (IP_STATUS_BASE + 28)
#define IP_DUPLICATE_ADDRESS        (IP_STATUS_BASE + 29)
#define IP_INTERFACE_METRIC_CHANGE  (IP_STATUS_BASE + 30)
#define IP_RECONFIG_SECFLTR         (IP_STATUS_BASE + 31)
#define IP_NEGOTIATING_IPSEC        (IP_STATUS_BASE + 32)
#define IP_INTERFACE_WOL_CAPABILITY_CHANGE  (IP_STATUS_BASE + 33)
#define IP_DUPLICATE_IPADD          (IP_STATUS_BASE + 34)

#define IP_GENERAL_FAILURE          (IP_STATUS_BASE + 50)
#define MAX_IP_STATUS               IP_GENERAL_FAILURE
#define IP_PENDING                  (IP_STATUS_BASE + 255)


//
// Values used in the IP header Flags field.
//
#define IP_FLAG_DF      0x2         // Don't fragment this packet.

//
// Supported IP Option Types.
//
// These types define the options which may be used in the OptionsData field
// of the ip_option_information structure.  See RFC 791 for a complete
// description of each.
//
#define IP_OPT_EOL      0          // End of list option
#define IP_OPT_NOP      1          // No operation
#define IP_OPT_SECURITY 0x82       // Security option
#define IP_OPT_LSRR     0x83       // Loose source route
#define IP_OPT_SSRR     0x89       // Strict source route
#define IP_OPT_RR       0x7        // Record route
#define IP_OPT_TS       0x44       // Timestamp
#define IP_OPT_SID      0x88       // Stream ID (obsolete)
#define IP_OPT_ROUTER_ALERT 0x94  // Router Alert Option

#define MAX_OPT_SIZE    40         // Maximum length of IP options in bytes

#ifdef CHICAGO

// Ioctls code exposed by Memphis tcpip stack.
// For NT these ioctls are define in ntddip.h  (private\inc)

#define IOCTL_IP_RTCHANGE_NOTIFY_REQUEST   101
#define IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST  102
#define IOCTL_ARP_SEND_REQUEST             103
#define IOCTL_IP_INTERFACE_INFO            104
#define IOCTL_IP_GET_BEST_INTERFACE        105
#define IOCTL_IP_UNIDIRECTIONAL_ADAPTER_ADDRESS        106

#endif


#endif // IP_EXPORT_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\Ioevent.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ioevent.h

Abstract:

    This module contains the GUIDS and event structures for io system
    initiated events.  These events are reported in kernel mode and are
    available to both user mode and kernel mode clients.

Author:

    Mark Zbikowski (markz) 3/18/98


Revision History:


--*/

//
//  Label change event.  This event is signalled upon successful completion
//  of a label change.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_CHANGE, 0x7373654aL, 0x812a, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );

//
//  Volume dismount event.  This event is signalled when an attempt is made to
//  dismount a volume.  There is no additional data.  Note that this will not
//  necessarily be preceded by a GUID_IO_VOLUME_LOCK notification.
//

DEFINE_GUID( GUID_IO_VOLUME_DISMOUNT, 0xd16a55e8L, 0x1059, 0x11d2, 0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume dismount failed event.  This event is signalled when a volume dismount fails.
//  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_DISMOUNT_FAILED, 0xe3c5b178L, 0x105d, 0x11d2, 0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume mount event.  This event is signalled when a volume mount occurs.
//  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_MOUNT, 0xb5804878L, 0x1a96, 0x11d2, 0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume lock event.  This event is signalled when an attempt is made to
//  lock a volume.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_LOCK, 0x50708874L, 0xc9af, 0x11d1, 0x8f, 0xef, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume lock failed event.  This event is signalled when an attempt is made to
//  lock a volume, but it fails.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_LOCK_FAILED, 0xae2eed10L, 0x0ba8, 0x11d2, 0x8f, 0xfb, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );


//
//  Volume unlock event.  This event is signalled when an attempt is made to
//  unlock a volume.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_UNLOCK, 0x9a8c3d68L, 0xd0cb, 0x11d1, 0x8f, 0xef, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );


//
//  Volume name change.  This event is signalled when the list of persistent
//  names (like drive letters) for a volume changes.  There is no additional
//  data.
//

DEFINE_GUID( GUID_IO_VOLUME_NAME_CHANGE, 0x2de97f83, 0x4c06, 0x11d2, 0xa5, 0x32, 0x0, 0x60, 0x97, 0x13, 0x5, 0x5a);


//
//  Volume physical configuration change.  This event is signalled when the
//  physical makeup or current physical state of the volume changes.
//

DEFINE_GUID( GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE, 0x2de97f84, 0x4c06, 0x11d2, 0xa5, 0x32, 0x0, 0x60, 0x97, 0x13, 0x5, 0x5a);


//
//  Volume device interface.  This is a device interface GUID that appears
//  when the device object associated with a volume is created and disappears
//  when the device object associated with the volume is destroyed.
//

DEFINE_GUID( GUID_IO_VOLUME_DEVICE_INTERFACE, 0x53f5630d, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);



//
//  Sent when the removable media is changed (added, removed) from a device
//  (such as a CDROM, tape, changer, etc).
//
//  The additional data is a DWORD representing the data event.
//

DEFINE_GUID( GUID_IO_MEDIA_ARRIVAL,         0xd07433c0, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);
DEFINE_GUID( GUID_IO_MEDIA_REMOVAL,         0xd07433c1, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

//
// Sent when the media is returning that it is not ready right now, but will
// be ready soon. This can be because the drive has spun down to save power
// or because new media has been inserted but is not ready for access yet.
//

DEFINE_GUID( GUID_IO_DEVICE_BECOMING_READY, 0xd07433f0, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

typedef struct _DEVICE_EVENT_BECOMING_READY {
    UCHAR  BusyEvent : 4;
    UCHAR  Reserved1 : 4;
    UCHAR  BusyStatus;
    USHORT Estimated100msToReady;
} DEVICE_EVENT_BECOMING_READY, *PDEVICE_EVENT_BECOMING_READY;

//
// Sent when the user presses the eject button on the front of the drive,
// or when other buttons on the front are pressed via GESN command polling
// (GESN support to be added) 
//

DEFINE_GUID( GUID_IO_DEVICE_EXTERNAL_REQUEST, 0xd07433d0, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);
DEFINE_GUID( GUID_IO_MEDIA_EJECT_REQUEST,     0xd07433d1, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

typedef struct _DEVICE_EVENT_EXTERNAL_REQUEST {
    UCHAR Event     : 4;
    UCHAR Reserved1 : 4;
    UCHAR Status    : 4;
    UCHAR Reserved2 : 3;
    UCHAR PersistantPrevent : 1;
    SHORT Request; // native byte ordering
} DEVICE_EVENT_EXTERNAL_REQUEST, *PDEVICE_EVENT_EXTERNAL_REQUEST;

//
// Sent when a tape drive requires cleaning
//
DEFINE_GUID(GUID_IO_DRIVE_REQUIRES_CLEANING, 0x7207877c, 0x90ed, 0x44e5, 0xa0, 0x0, 0x81, 0x42, 0x8d, 0x4c, 0x79, 0xbb);

// 
// Sent when a tape is erased
//
DEFINE_GUID(GUID_IO_TAPE_ERASE, 0x852d11eb, 0x4bb8, 0x4507, 0x9d, 0x9b, 0x41, 0x7c, 0xc2, 0xb1, 0xb4, 0x38);

typedef struct _DEVICE_EVENT_GENERIC_DATA {
    ULONG EventNumber;
} DEVICE_EVENT_GENERIC_DATA, *PDEVICE_EVENT_GENERIC_DATA;


//
//  Represents any asynchronous notification coming from a device driver whose
//  notification protocol is RBC
//  Additional data is provided

DEFINE_GUID( GUID_DEVICE_EVENT_RBC, 0xd0744792, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

typedef struct _DEVICE_EVENT_RBC_DATA {
    ULONG EventNumber;
    UCHAR SenseQualifier;
    UCHAR SenseCode;
    UCHAR SenseKey;
    UCHAR Reserved;
    ULONG Information;
} DEVICE_EVENT_RBC_DATA, *PDEVICE_EVENT_RBC_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*       Copyright (c) 1985-2000, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the low-level
*       file handling and I/O functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_IO
#define _INC_IO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifndef _POSIX_

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _FINDDATA_T_DEFINED

struct _finddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        char        name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _finddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        char        name[260];
};

struct __finddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        char        name[260];
};

#endif

#define _FINDDATA_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _wfinddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        wchar_t     name[260];
};

struct __wfinddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* File attribute constants for _findfirst() */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* function prototypes */

_CRTIMP int __cdecl _access(const char *, int);
_CRTIMP int __cdecl _chmod(const char *, int);
_CRTIMP int __cdecl _chsize(int, long);
_CRTIMP int __cdecl _close(int);
_CRTIMP int __cdecl _commit(int);
_CRTIMP int __cdecl _creat(const char *, int);
_CRTIMP int __cdecl _dup(int);
_CRTIMP int __cdecl _dup2(int, int);
_CRTIMP int __cdecl _eof(int);
_CRTIMP long __cdecl _filelength(int);
_CRTIMP intptr_t __cdecl _findfirst(const char *, struct _finddata_t *);
_CRTIMP int __cdecl _findnext(intptr_t, struct _finddata_t *);
_CRTIMP int __cdecl _findclose(intptr_t);
_CRTIMP int __cdecl _isatty(int);
_CRTIMP int __cdecl _locking(int, int, long);
_CRTIMP long __cdecl _lseek(int, long, int);
_CRTIMP char * __cdecl _mktemp(char *);
_CRTIMP int __cdecl _open(const char *, int, ...);
_CRTIMP int __cdecl _pipe(int *, unsigned int, int);
_CRTIMP int __cdecl _read(int, void *, unsigned int);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP int __cdecl _setmode(int, int);
_CRTIMP int __cdecl _sopen(const char *, int, int, ...);
_CRTIMP long __cdecl _tell(int);
_CRTIMP int __cdecl _umask(int);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl _write(int, const void *, unsigned int);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP __int64 __cdecl _filelengthi64(int);
_CRTIMP intptr_t __cdecl _findfirsti64(const char *, struct _finddatai64_t *);
_CRTIMP intptr_t __cdecl _findfirst64(const char *, struct __finddata64_t *);
_CRTIMP int __cdecl _findnexti64(intptr_t, struct _finddatai64_t *);
_CRTIMP int __cdecl _findnext64(intptr_t, struct __finddata64_t *);
_CRTIMP __int64 __cdecl _lseeki64(int, __int64, int);
_CRTIMP __int64 __cdecl _telli64(int);
#endif

#ifndef _WIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(const wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP intptr_t __cdecl _wfindfirsti64(const wchar_t *, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(const wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif


_CRTIMP intptr_t __cdecl _get_osfhandle(int);
_CRTIMP int __cdecl _open_osfhandle(intptr_t, int);

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl access(const char *, int);
_CRTIMP int __cdecl chmod(const char *, int);
_CRTIMP int __cdecl chsize(int, long);
_CRTIMP int __cdecl close(int);
_CRTIMP int __cdecl creat(const char *, int);
_CRTIMP int __cdecl dup(int);
_CRTIMP int __cdecl dup2(int, int);
_CRTIMP int __cdecl eof(int);
_CRTIMP long __cdecl filelength(int);
_CRTIMP int __cdecl isatty(int);
_CRTIMP int __cdecl locking(int, int, long);
_CRTIMP long __cdecl lseek(int, long, int);
_CRTIMP char * __cdecl mktemp(char *);
_CRTIMP int __cdecl open(const char *, int, ...);
_CRTIMP int __cdecl read(int, void *, unsigned int);
_CRTIMP int __cdecl setmode(int, int);
_CRTIMP int __cdecl sopen(const char *, int, int, ...);
_CRTIMP long __cdecl tell(int);
_CRTIMP int __cdecl umask(int);
_CRTIMP int __cdecl unlink(const char *);
_CRTIMP int __cdecl write(int, const void *, unsigned int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_IO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\IPHlpApi.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    iphlpapi.h

Abstract:
    Header file for functions to interact with the IP Stack for MIB-II and
    related functionality

--*/

#ifndef __IPHLPAPI_H__
#define __IPHLPAPI_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// IPRTRMIB.H has the definitions of the strcutures used to set and get     //
// information                                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#include <iprtrmib.h>
#include <ipexport.h>
#include <iptypes.h>

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The GetXXXTable APIs take a buffer and a size of buffer.  If the buffer  //
// is not large enough, the APIs return ERROR_INSUFFICIENT_BUFFER  and      //
// *pdwSize is the required buffer size                                     //
// The bOrder is a BOOLEAN, which if TRUE sorts the table according to      //
// MIB-II (RFC XXXX)                                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Retrieves the number of interfaces in the system. These include LAN and  //
// WAN interfaces                                                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


DWORD
WINAPI
GetNumberOfInterfaces(
    OUT PDWORD  pdwNumIf
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the MIB-II ifEntry                                                  //
// The dwIndex field of the MIB_IFROW should be set to the index of the     //
// interface being queried                                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIfEntry(
    IN OUT PMIB_IFROW   pIfRow
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the MIB-II IfTable                                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIfTable(
    OUT    PMIB_IFTABLE pIfTable,
    IN OUT PULONG       pdwSize,
    IN     BOOL         bOrder
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the Interface to IP Address mapping                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIpAddrTable(
    OUT    PMIB_IPADDRTABLE pIpAddrTable,
    IN OUT PULONG           pdwSize,
    IN     BOOL             bOrder
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the current IP Address to Physical Address (ARP) mapping            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIpNetTable(
    OUT    PMIB_IPNETTABLE pIpNetTable,
    IN OUT PULONG          pdwSize,
    IN     BOOL            bOrder
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the IP Routing Table  (RFX XXXX)                                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIpForwardTable(
    OUT    PMIB_IPFORWARDTABLE pIpForwardTable,
    IN OUT PULONG              pdwSize,
    IN     BOOL                bOrder
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets TCP Connection/UDP Listener Table                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetTcpTable(
    OUT    PMIB_TCPTABLE pTcpTable,
    IN OUT PDWORD        pdwSize,
    IN     BOOL          bOrder
    );

DWORD
WINAPI
GetUdpTable(
    OUT    PMIB_UDPTABLE pUdpTable,
    IN OUT PDWORD        pdwSize,
    IN     BOOL          bOrder
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets IP/ICMP/TCP/UDP Statistics                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIpStatistics(
    OUT  PMIB_IPSTATS   pStats
    );

DWORD
WINAPI
GetIcmpStatistics(
    OUT PMIB_ICMP   pStats
    );


DWORD
WINAPI
GetTcpStatistics(
    OUT PMIB_TCPSTATS   pStats
    );

DWORD
WINAPI
GetUdpStatistics(
    OUT PMIB_UDPSTATS   pStats
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the ifAdminStatus on an interface.  The only fields of the   //
// MIB_IFROW that are relevant are the dwIndex (index of the interface      //
// whose status needs to be set) and the dwAdminStatus which can be either  //
// MIB_IF_ADMIN_STATUS_UP or MIB_IF_ADMIN_STATUS_DOWN                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
SetIfEntry(
    IN PMIB_IFROW pIfRow
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to create, modify or delete a route.  In all cases the              //
// dwForwardIfIndex, dwForwardDest, dwForwardMask, dwForwardNextHop and     //
// dwForwardPolicy MUST BE SPECIFIED. Currently dwForwardPolicy is unused   //
// and MUST BE 0.                                                           //
// For a set, the complete MIB_IPFORWARDROW structure must be specified     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
CreateIpForwardEntry(
    IN PMIB_IPFORWARDROW pRoute
    );

DWORD
WINAPI
SetIpForwardEntry(
    IN PMIB_IPFORWARDROW pRoute
    );

DWORD
WINAPI
DeleteIpForwardEntry(
    IN PMIB_IPFORWARDROW pRoute
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the ipForwarding to ON or OFF (currently only ON->OFF is     //
// allowed) and to set the defaultTTL.  If only one of the fields needs to  //
// be modified and the other needs to be the same as before the other field //
// needs to be set to MIB_USE_CURRENT_TTL or MIB_USE_CURRENT_FORWARDING as  //
// the case may be                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


DWORD
WINAPI
SetIpStatistics(
    IN PMIB_IPSTATS pIpStats
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the defaultTTL.                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
SetIpTTL(
    UINT nTTL
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to create, modify or delete an ARP entry.  In all cases the dwIndex //
// dwAddr field MUST BE SPECIFIED.                                          //
// For a set, the complete MIB_IPNETROW structure must be specified         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
CreateIpNetEntry(
    IN PMIB_IPNETROW    pArpEntry
    );

DWORD
WINAPI
SetIpNetEntry(
    IN PMIB_IPNETROW    pArpEntry
    );

DWORD
WINAPI
DeleteIpNetEntry(
    IN PMIB_IPNETROW    pArpEntry
    );

DWORD
WINAPI
FlushIpNetTable(
    IN DWORD   dwIfIndex
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to create or delete a Proxy ARP entry. The dwIndex is the index of  //
// the interface on which to PARP for the dwAddress.  If the interface is   //
// of a type that doesnt support ARP, e.g. PPP, then the call will fail     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
CreateProxyArpEntry(
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask,
    IN  DWORD   dwIfIndex
    );

DWORD
WINAPI
DeleteProxyArpEntry(
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask,
    IN  DWORD   dwIfIndex
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the state of a TCP Connection. The only state that it can be //
// set to is MIB_TCP_STATE_DELETE_TCB.  The complete MIB_TCPROW structure   //
// MUST BE SPECIFIED                                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
SetTcpEntry(
    IN PMIB_TCPROW pTcpRow
    );


DWORD
WINAPI
GetInterfaceInfo(
    IN PIP_INTERFACE_INFO pIfTable,
    OUT PULONG            dwOutBufLen
    );

DWORD
WINAPI
GetUniDirectionalAdapterInfo(OUT PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS pIPIfInfo,
                 OUT PULONG dwOutBufLen
                 );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the "best" outgoing interface for the specified destination address //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetBestInterface(
    IN  IPAddr  dwDestAddr,
    OUT PDWORD  pdwBestIfIndex
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the best (longest matching prefix) route for the given destination  //
// If the source address is also specified (i.e. is not 0x00000000), and    //
// there are multiple "best" routes to the given destination, the returned  //
// route will be one that goes out over the interface which has an address  //
// that matches the source address                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetBestRoute(
    IN  DWORD               dwDestAddr,
    IN  DWORD               dwSourceAddr, OPTIONAL
    OUT PMIB_IPFORWARDROW   pBestRoute
    );

DWORD
WINAPI
NotifyAddrChange(
    OUT PHANDLE      Handle,
    IN  LPOVERLAPPED overlapped
    );


DWORD
WINAPI
NotifyRouteChange(
    OUT PHANDLE      Handle,
    IN  LPOVERLAPPED overlapped
    );


DWORD
WINAPI
GetAdapterIndex(
    IN LPWSTR  AdapterName,
    OUT PULONG IfIndex
    );

DWORD
WINAPI
AddIPAddress(
    IPAddr  Address,
    IPMask  IpMask,
    DWORD   IfIndex,
    PULONG  NTEContext,
    PULONG  NTEInstance
    );

DWORD
WINAPI
DeleteIPAddress(
    ULONG NTEContext
    );

DWORD
WINAPI
GetNetworkParams(
    PFIXED_INFO pFixedInfo, PULONG pOutBufLen
    );

DWORD
WINAPI
GetAdaptersInfo(
    PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen
    );

#ifdef _WINSOCK2API_

//
// The following functions require Winsock2.
//

DWORD
WINAPI
GetAdaptersAddresses(
    PIP_ADAPTER_ADDRESSES pAdapterAddresses, PULONG pOutBufLen
    );

#endif

DWORD
WINAPI
GetPerAdapterInfo(
    ULONG IfIndex, PIP_PER_ADAPTER_INFO pPerAdapterInfo, PULONG pOutBufLen
    );

DWORD
WINAPI
IpReleaseAddress(
    PIP_ADAPTER_INDEX_MAP  AdapterInfo
    );


DWORD
WINAPI
IpRenewAddress(
    PIP_ADAPTER_INDEX_MAP  AdapterInfo
    );

DWORD
WINAPI
SendARP(
    IPAddr DestIP,
    IPAddr SrcIP,
    PULONG pMacAddr,
    PULONG  PhyAddrLen
    );

BOOL
WINAPI
GetRTTAndHopCount(
    IPAddr DestIpAddress,
    PULONG HopCount,
    ULONG  MaxHops,
    PULONG RTT
    );

DWORD
WINAPI
GetFriendlyIfIndex(
    DWORD IfIndex
    );

DWORD
WINAPI
EnableRouter(
    HANDLE* pHandle,
    OVERLAPPED* pOverlapped
    );

DWORD
WINAPI
UnenableRouter(
    OVERLAPPED* pOverlapped,
    LPDWORD lpdwEnableCount OPTIONAL
    );
DWORD
WINAPI
DisableMediaSense(
    HANDLE *pHandle,
    OVERLAPPED *pOverLapped
    );

DWORD
WINAPI
RestoreMediaSense(
    OVERLAPPED* pOverlapped,
    LPDWORD lpdwEnableCount OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif //__IPHLPAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ipmcdefs.h ===
// --ipmdefs.h-----------------------------------------------------------------
//
// Common definitions for the IPM Inbound and Outbound conversion
// DLLs.
//
// Copyright (C) Microsoft Corp., 1986-1999.  All rights reserved.
//
// ----------------------------------------------------------------------------

#ifndef _IPMCDEFS_H
#define _IPMCDEFS_H

#ifdef __cplusplus
extern "C" {
#endif

// Constants used for TNEFed messages:

// associated TNEFed file name
LPCSTR     szTnefFileName  = "MAPIMAIL.DAT";

// TNEF "unique" key
const WORD wTnefKey        = 0x01AF;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ipmconv.h ===
// --ipmconv.h----------------------------------------------------------------
//
// API entry points for the inbound and outbound sample gateway
// message conversion DLLs.
//
// The ipm_out DLL converts MAPI messages to an 822-style header.
// This is the "Outbound IPM Converter". 
//
// The ipm_in DLL converts an 822-style header to a MAPI message.
// This is the "Inbound IPM Converter".
//
// Copyright (C) Microsoft Corp., 1986-1999.  All rights reserved.
//
// ---------------------------------------------------------------------------

#ifndef _IPMCONV_H
#define _IPMCONV_H

#ifdef __cplusplus
extern "C" {
#endif

// Supported conversion message class prefixes.
#define IPMENVELOPECLASS    L"ENVELOPE.IPM"
#define IPMREPORTCLASS      L"REPORT.IPM"

// $--CONV_OPTIONS-------------------------------------------------------------
//
// Conversion options for the IPM Inbound and Outbound conversion
// DLLs.  This structure is passed to the conversion DLL via the 
// pGatewayDefined field of the EDKCNVENV conversion environment
// structure (defined in convstrc.h).
//
// ----------------------------------------------------------------------------
typedef struct _CONV_OPTIONS
{
    BOOL    fTnefEncode;            // TRUE if want Tnef encoding/decoding
    LPCSTR  lpszAddressType;        // Address type string

} CONV_OPTIONS;

// $--HrGetExportVector--------------------------------------------------------
//
// DESCRIPTION: Gets pointer to exported functions/vectors structures
//              for either the inbound or outbound converter.
//
// INPUT:       dwVersion   --  version requested
//
// OUTPUT:      ppExportVectors --  pointer to export vector structure pointer
//
// RETURNS:     HRESULT     --  NOERROR if successful,
//                              E_INVALIDARG if invalid parameter,
//
// ---------------------------------------------------------------------------

HRESULT HrGetExportVector(
        IN DWORD dwVersion,         // version requested
        OUT PCONVDLLVECT * ppExportVectors);  // pointer to exported functions structure

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\iprtrmib.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    iprtrmib.h

Abstract:
    This file contains:
        o Definitions of the MIB_XX structures passed to and from the IP Router Manager
            to query and set MIB variables handled by the IP Router Manager
        o The #defines for the MIB variables IDs  handled by the IP Router Manager
            and made accessible by the MprAdminMIBXXX APIs
        o The Routing PID of the IP Router Manager (as mentioned in ipinfoid.h)

--*/

#ifndef __ROUTING_IPRTRMIB_H__
#define __ROUTING_IPRTRMIB_H__

#if _MSC_VER > 1000
#pragma once
#endif

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Included to get the value of MAX_INTERFACE_NAME_LEN                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#include <mprapi.h>

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Included to get the necessary constants                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#include <ipifcons.h>

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This is the Id for IP Router Manager.  The Router Manager handles        //
// MIB-II, Forwarding MIB and some enterprise specific information.         //
// Calls made with any other ID are passed on to the corresponding protocol //
// For example, an MprAdminMIBXXX call with a protocol ID of PID_IP and    //
// a routing Id of 0xD will be sent to the IP Router Manager and then       //
// forwarded to OSPF                                                        //
// This lives in the same number space as the protocol Ids of RIP, OSPF     //
// etc, so any change made to it should be done keeping this in mind        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define IPRTRMGR_PID 10000

#ifndef ANY_SIZE

#define ANY_SIZE 1

#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following #defines are the Ids of the MIB variables made accessible  //
// to the user via MprAdminMIBXXX Apis.  It will be noticed that these are  //
// not the same as RFC 1213, since the MprAdminMIBXXX APIs work on rows and //
// groups instead of scalar variables                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define IF_NUMBER           0
#define IF_TABLE            (IF_NUMBER          + 1)
#define IF_ROW              (IF_TABLE           + 1)
#define IP_STATS            (IF_ROW             + 1)
#define IP_ADDRTABLE        (IP_STATS           + 1)
#define IP_ADDRROW          (IP_ADDRTABLE       + 1)
#define IP_FORWARDNUMBER    (IP_ADDRROW         + 1)
#define IP_FORWARDTABLE     (IP_FORWARDNUMBER   + 1)
#define IP_FORWARDROW       (IP_FORWARDTABLE    + 1)
#define IP_NETTABLE         (IP_FORWARDROW      + 1)
#define IP_NETROW           (IP_NETTABLE        + 1)
#define ICMP_STATS          (IP_NETROW          + 1)
#define TCP_STATS           (ICMP_STATS         + 1)
#define TCP_TABLE           (TCP_STATS          + 1)
#define TCP_ROW             (TCP_TABLE          + 1)
#define UDP_STATS           (TCP_ROW            + 1)
#define UDP_TABLE           (UDP_STATS          + 1)
#define UDP_ROW             (UDP_TABLE          + 1)
#define MCAST_MFE           (UDP_ROW            + 1)
#define MCAST_MFE_STATS     (MCAST_MFE          + 1)
#define BEST_IF             (MCAST_MFE_STATS    + 1)
#define BEST_ROUTE          (BEST_IF            + 1)
#define PROXY_ARP           (BEST_ROUTE         + 1)
#define MCAST_IF_ENTRY      (PROXY_ARP          + 1)
#define MCAST_GLOBAL        (MCAST_IF_ENTRY     + 1)
#define IF_STATUS           (MCAST_GLOBAL       + 1)
#define MCAST_BOUNDARY      (IF_STATUS          + 1)
#define MCAST_SCOPE         (MCAST_BOUNDARY     + 1)
#define DEST_MATCHING       (MCAST_SCOPE        + 1)
#define DEST_LONGER         (DEST_MATCHING      + 1)
#define DEST_SHORTER        (DEST_LONGER        + 1)
#define ROUTE_MATCHING      (DEST_SHORTER       + 1)
#define ROUTE_LONGER        (ROUTE_MATCHING     + 1)
#define ROUTE_SHORTER       (ROUTE_LONGER       + 1)
#define ROUTE_STATE         (ROUTE_SHORTER      + 1)

#define NUMBER_OF_EXPORTED_VARIABLES    (ROUTE_STATE + 1)


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// MIB_OPAQUE_QUERY is the structure filled in by the user to identify a    //
// MIB variable                                                             //
//                                                                          //
//  dwVarId     ID of MIB Variable (One of the Ids #defined above)          //
//  dwVarIndex  Variable sized array containing the indices needed to       //
//              identify a variable. NOTE: Unlike SNMP we dont require that //
//              a scalar variable be indexed by 0                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef struct _MIB_OPAQUE_QUERY
{
    DWORD  dwVarId;
    DWORD  rgdwVarIndex[ANY_SIZE];
}MIB_OPAQUE_QUERY, *PMIB_OPAQUE_QUERY;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following are the structures which are filled in and returned to the //
// user when a query is made, OR  are filled in BY THE USER when a set is   //
// done                                                                     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef struct _MIB_IFNUMBER
{
    DWORD    dwValue;
} MIB_IFNUMBER, *PMIB_IFNUMBER;


#define MAXLEN_IFDESCR 256
#define MAXLEN_PHYSADDR 8

typedef struct _MIB_IFROW
{
    WCHAR   wszName[MAX_INTERFACE_NAME_LEN];
    DWORD    dwIndex;
    DWORD    dwType;
    DWORD    dwMtu;
    DWORD    dwSpeed;
    DWORD    dwPhysAddrLen;
    BYTE    bPhysAddr[MAXLEN_PHYSADDR];
    DWORD    dwAdminStatus;
    DWORD    dwOperStatus;
    DWORD    dwLastChange;
    DWORD    dwInOctets;
    DWORD    dwInUcastPkts;
    DWORD    dwInNUcastPkts;
    DWORD    dwInDiscards;
    DWORD    dwInErrors;
    DWORD    dwInUnknownProtos;
    DWORD    dwOutOctets;
    DWORD    dwOutUcastPkts;
    DWORD    dwOutNUcastPkts;
    DWORD    dwOutDiscards;
    DWORD    dwOutErrors;
    DWORD    dwOutQLen;
    DWORD    dwDescrLen;
    BYTE    bDescr[MAXLEN_IFDESCR];
} MIB_IFROW,*PMIB_IFROW;

typedef struct _MIB_IFTABLE
{
    DWORD     dwNumEntries;
    MIB_IFROW table[ANY_SIZE];
} MIB_IFTABLE, *PMIB_IFTABLE;

#define SIZEOF_IFTABLE(X) (FIELD_OFFSET(MIB_IFTABLE,table[0]) + ((X) * sizeof(MIB_IFROW)) + ALIGN_SIZE)

typedef struct _MIBICMPSTATS
{
    DWORD        dwMsgs;
    DWORD        dwErrors;
    DWORD        dwDestUnreachs;
    DWORD        dwTimeExcds;
    DWORD        dwParmProbs;
    DWORD        dwSrcQuenchs;
    DWORD        dwRedirects;
    DWORD        dwEchos;
    DWORD        dwEchoReps;
    DWORD        dwTimestamps;
    DWORD        dwTimestampReps;
    DWORD        dwAddrMasks;
    DWORD        dwAddrMaskReps;
} MIBICMPSTATS;

typedef    struct _MIBICMPINFO
{
    MIBICMPSTATS    icmpInStats;
    MIBICMPSTATS    icmpOutStats;
} MIBICMPINFO;

typedef struct _MIB_ICMP
{
    MIBICMPINFO stats;
} MIB_ICMP,*PMIB_ICMP;

typedef struct _MIB_UDPSTATS
{
    DWORD       dwInDatagrams;
    DWORD       dwNoPorts;
    DWORD       dwInErrors;
    DWORD       dwOutDatagrams;
    DWORD       dwNumAddrs;
} MIB_UDPSTATS,*PMIB_UDPSTATS;

typedef struct _MIB_UDPROW
{
    DWORD       dwLocalAddr;
    DWORD       dwLocalPort;
} MIB_UDPROW, *PMIB_UDPROW;

typedef struct _MIB_UDPTABLE
{
    DWORD       dwNumEntries;
    MIB_UDPROW  table[ANY_SIZE];
} MIB_UDPTABLE, *PMIB_UDPTABLE;

#define SIZEOF_UDPTABLE(X) (FIELD_OFFSET(MIB_UDPTABLE, table[0]) + ((X) * sizeof(MIB_UDPROW)) + ALIGN_SIZE)

typedef struct _MIB_TCPSTATS
{
    DWORD       dwRtoAlgorithm;
    DWORD       dwRtoMin;
    DWORD       dwRtoMax;
    DWORD       dwMaxConn;
    DWORD       dwActiveOpens;
    DWORD       dwPassiveOpens;
    DWORD       dwAttemptFails;
    DWORD       dwEstabResets;
    DWORD       dwCurrEstab;
    DWORD       dwInSegs;
    DWORD       dwOutSegs;
    DWORD       dwRetransSegs;
    DWORD       dwInErrs;
    DWORD       dwOutRsts;
    DWORD       dwNumConns;
} MIB_TCPSTATS, *PMIB_TCPSTATS;

#define MIB_TCP_RTO_OTHER       1
#define MIB_TCP_RTO_CONSTANT    2
#define MIB_TCP_RTO_RSRE        3
#define MIB_TCP_RTO_VANJ        4

#define MIB_TCP_MAXCONN_DYNAMIC (DWORD)-1

typedef struct _MIB_TCPROW
{
    DWORD       dwState;
    DWORD       dwLocalAddr;
    DWORD       dwLocalPort;
    DWORD       dwRemoteAddr;
    DWORD       dwRemotePort;
} MIB_TCPROW, *PMIB_TCPROW;

#define MIB_TCP_STATE_CLOSED            1
#define MIB_TCP_STATE_LISTEN            2
#define MIB_TCP_STATE_SYN_SENT          3
#define MIB_TCP_STATE_SYN_RCVD          4
#define MIB_TCP_STATE_ESTAB             5
#define MIB_TCP_STATE_FIN_WAIT1         6
#define MIB_TCP_STATE_FIN_WAIT2         7
#define MIB_TCP_STATE_CLOSE_WAIT        8
#define MIB_TCP_STATE_CLOSING           9
#define MIB_TCP_STATE_LAST_ACK         10
#define MIB_TCP_STATE_TIME_WAIT        11
#define MIB_TCP_STATE_DELETE_TCB       12

typedef struct _MIB_TCPTABLE
{
    DWORD      dwNumEntries;
    MIB_TCPROW table[ANY_SIZE];
} MIB_TCPTABLE, *PMIB_TCPTABLE;

#define SIZEOF_TCPTABLE(X) (FIELD_OFFSET(MIB_TCPTABLE,table[0]) + ((X) * sizeof(MIB_TCPROW)) + ALIGN_SIZE)

#define MIB_USE_CURRENT_TTL         ((DWORD)-1)
#define MIB_USE_CURRENT_FORWARDING  ((DWORD)-1)

typedef struct _MIB_IPSTATS
{
    DWORD        dwForwarding;
    DWORD        dwDefaultTTL;
    DWORD        dwInReceives;
    DWORD        dwInHdrErrors;
    DWORD        dwInAddrErrors;
    DWORD        dwForwDatagrams;
    DWORD        dwInUnknownProtos;
    DWORD        dwInDiscards;
    DWORD        dwInDelivers;
    DWORD        dwOutRequests;
    DWORD        dwRoutingDiscards;
    DWORD        dwOutDiscards;
    DWORD        dwOutNoRoutes;
    DWORD        dwReasmTimeout;
    DWORD        dwReasmReqds;
    DWORD        dwReasmOks;
    DWORD        dwReasmFails;
    DWORD        dwFragOks;
    DWORD        dwFragFails;
    DWORD        dwFragCreates;
    DWORD        dwNumIf;
    DWORD        dwNumAddr;
    DWORD        dwNumRoutes;
} MIB_IPSTATS, *PMIB_IPSTATS;

#define    MIB_IP_FORWARDING               1
#define    MIB_IP_NOT_FORWARDING           2


typedef struct _MIB_IPADDRROW
{
    DWORD        dwAddr;
    DWORD        dwIndex;
    DWORD        dwMask;
    DWORD        dwBCastAddr;
    DWORD        dwReasmSize;
    unsigned short    unused1;
    unsigned short    unused2;
} MIB_IPADDRROW, *PMIB_IPADDRROW;

typedef struct _MIB_IPADDRTABLE
{
    DWORD         dwNumEntries;
    MIB_IPADDRROW table[ANY_SIZE];
} MIB_IPADDRTABLE, *PMIB_IPADDRTABLE;


#define SIZEOF_IPADDRTABLE(X) (FIELD_OFFSET(MIB_IPADDRTABLE,table[0]) + ((X) * sizeof(MIB_IPADDRROW)) + ALIGN_SIZE)


typedef struct _MIB_IPFORWARDNUMBER
{
    DWORD      dwValue;
}MIB_IPFORWARDNUMBER,*PMIB_IPFORWARDNUMBER;

typedef struct _MIB_IPFORWARDROW
{
    DWORD        dwForwardDest;
    DWORD        dwForwardMask;
    DWORD        dwForwardPolicy;
    DWORD        dwForwardNextHop;
    DWORD        dwForwardIfIndex;
    DWORD        dwForwardType;
    DWORD        dwForwardProto;
    DWORD        dwForwardAge;
    DWORD       dwForwardNextHopAS;
    DWORD        dwForwardMetric1;
    DWORD        dwForwardMetric2;
    DWORD        dwForwardMetric3;
    DWORD        dwForwardMetric4;
    DWORD        dwForwardMetric5;
}MIB_IPFORWARDROW, *PMIB_IPFORWARDROW;

#define    MIB_IPROUTE_TYPE_OTHER        1
#define    MIB_IPROUTE_TYPE_INVALID    2
#define    MIB_IPROUTE_TYPE_DIRECT        3
#define    MIB_IPROUTE_TYPE_INDIRECT    4

#define    MIB_IPROUTE_METRIC_UNUSED    (DWORD)-1

//
// THESE MUST MATCH the ids in routprot.h
//

#define MIB_IPPROTO_OTHER                1
#define MIB_IPPROTO_LOCAL                2
#define MIB_IPPROTO_NETMGMT                3
#define MIB_IPPROTO_ICMP                4
#define MIB_IPPROTO_EGP                    5
#define MIB_IPPROTO_GGP                    6
#define MIB_IPPROTO_HELLO                7
#define MIB_IPPROTO_RIP                    8
#define MIB_IPPROTO_IS_IS                9
#define MIB_IPPROTO_ES_IS                10
#define MIB_IPPROTO_CISCO                11
#define MIB_IPPROTO_BBN                    12
#define MIB_IPPROTO_OSPF                13
#define MIB_IPPROTO_BGP                    14

#define MIB_IPPROTO_NT_AUTOSTATIC       10002
#define MIB_IPPROTO_NT_STATIC           10006
#define MIB_IPPROTO_NT_STATIC_NON_DOD   10007

typedef struct _MIB_IPFORWARDTABLE
{
    DWORD               dwNumEntries;
    MIB_IPFORWARDROW    table[ANY_SIZE];
}MIB_IPFORWARDTABLE, *PMIB_IPFORWARDTABLE;




#define SIZEOF_IPFORWARDTABLE(X) (FIELD_OFFSET(MIB_IPFORWARDTABLE,table[0]) + ((X) * sizeof(MIB_IPFORWARDROW)) + ALIGN_SIZE)


typedef struct _MIB_IPNETROW
{
    DWORD        dwIndex;
    DWORD        dwPhysAddrLen;
    BYTE        bPhysAddr[MAXLEN_PHYSADDR];
    DWORD        dwAddr;
    DWORD        dwType;
} MIB_IPNETROW, *PMIB_IPNETROW;

#define    MIB_IPNET_TYPE_OTHER        1
#define    MIB_IPNET_TYPE_INVALID        2
#define    MIB_IPNET_TYPE_DYNAMIC        3
#define    MIB_IPNET_TYPE_STATIC        4

typedef struct _MIB_IPNETTABLE
{
    DWORD             dwNumEntries;
    MIB_IPNETROW      table[ANY_SIZE];
} MIB_IPNETTABLE, *PMIB_IPNETTABLE;

#define SIZEOF_IPNETTABLE(X) (FIELD_OFFSET(MIB_IPNETTABLE, table[0]) + ((X) * sizeof(MIB_IPNETROW)) + ALIGN_SIZE)

typedef struct _MIB_IPMCAST_OIF
{
    DWORD   dwOutIfIndex;
    DWORD   dwNextHopAddr;
    PVOID   pvReserved;
    DWORD   dwReserved;
}MIB_IPMCAST_OIF, *PMIB_IPMCAST_OIF;

typedef struct _MIB_IPMCAST_MFE
{
    DWORD   dwGroup;
    DWORD   dwSource;
    DWORD   dwSrcMask;
    DWORD   dwUpStrmNgbr;
    DWORD   dwInIfIndex;
    DWORD   dwInIfProtocol;
    DWORD   dwRouteProtocol;
    DWORD   dwRouteNetwork;
    DWORD   dwRouteMask;
    ULONG   ulUpTime;
    ULONG   ulExpiryTime;
    ULONG   ulTimeOut;
    ULONG   ulNumOutIf;
    DWORD   fFlags;
    DWORD   dwReserved;
    MIB_IPMCAST_OIF rgmioOutInfo[ANY_SIZE];
}MIB_IPMCAST_MFE, *PMIB_IPMCAST_MFE;

typedef struct _MIB_MFE_TABLE
{
    DWORD           dwNumEntries;
    MIB_IPMCAST_MFE table[ANY_SIZE];
}MIB_MFE_TABLE, *PMIB_MFE_TABLE;


#define SIZEOF_BASIC_MIB_MFE          \
    (ULONG)(FIELD_OFFSET(MIB_IPMCAST_MFE, rgmioOutInfo[0]))

#define SIZEOF_MIB_MFE(X)             \
    (SIZEOF_BASIC_MIB_MFE + ((X) * sizeof(MIB_IPMCAST_OIF)))


typedef struct _MIB_IPMCAST_OIF_STATS
{
    DWORD   dwOutIfIndex;
    DWORD   dwNextHopAddr;
    PVOID   pvDialContext;
    ULONG   ulTtlTooLow;
    ULONG   ulFragNeeded;
    ULONG   ulOutPackets;
    ULONG   ulOutDiscards;
}MIB_IPMCAST_OIF_STATS, *PMIB_IPMCAST_OIF_STATS;

typedef struct _MIB_IPMCAST_MFE_STATS
{
    DWORD   dwGroup;
    DWORD   dwSource;
    DWORD   dwSrcMask;
    DWORD   dwUpStrmNgbr;
    DWORD   dwInIfIndex;
    DWORD   dwInIfProtocol;
    DWORD   dwRouteProtocol;
    DWORD   dwRouteNetwork;
    DWORD   dwRouteMask;
    ULONG   ulUpTime;
    ULONG   ulExpiryTime;
    ULONG   ulNumOutIf;
    ULONG   ulInPkts;
    ULONG   ulInOctets;
    ULONG   ulPktsDifferentIf;
    ULONG   ulQueueOverflow;
    ULONG   ulUninitMfe;
    ULONG   ulNegativeMfe;
    ULONG   ulInDiscards;
    ULONG   ulInHdrErrors;
    ULONG   ulTotalOutPackets;

    MIB_IPMCAST_OIF_STATS   rgmiosOutStats[ANY_SIZE];
}MIB_IPMCAST_MFE_STATS, *PMIB_IPMCAST_MFE_STATS;

typedef struct _MIB_MFE_STATS_TABLE
{
    DWORD       dwNumEntries;
    MIB_IPMCAST_MFE_STATS   table[ANY_SIZE];
}MIB_MFE_STATS_TABLE, *PMIB_MFE_STATS_TABLE;

#define SIZEOF_BASIC_MIB_MFE_STATS    \
    (ULONG)(FIELD_OFFSET(MIB_IPMCAST_MFE_STATS, rgmiosOutStats[0]))

#define SIZEOF_MIB_MFE_STATS(X)       \
    (SIZEOF_BASIC_MIB_MFE_STATS + ((X) * sizeof(MIB_IPMCAST_OIF_STATS)))

typedef struct _MIB_IPMCAST_GLOBAL {
    DWORD   dwEnable;
}MIB_IPMCAST_GLOBAL, *PMIB_IPMCAST_GLOBAL;

typedef struct _MIB_IPMCAST_IF_ENTRY
{
    DWORD   dwIfIndex;
    DWORD   dwTtl;
    DWORD   dwProtocol;
    DWORD   dwRateLimit;
    ULONG   ulInMcastOctets;
    ULONG   ulOutMcastOctets;
}MIB_IPMCAST_IF_ENTRY, *PMIB_IPMCAST_IF_ENTRY;

typedef struct _MIB_IPMCAST_IF_TABLE
{
    DWORD       dwNumEntries;
    MIB_IPMCAST_IF_ENTRY   table[ANY_SIZE];
}MIB_IPMCAST_IF_TABLE, *PMIB_IPMCAST_IF_TABLE;

#define SIZEOF_MCAST_IF_TABLE(X) (FIELD_OFFSET(MIB_IPMCAST_IF_TABLE,table[0]) + ((X) * sizeof(MIB_IPMCAST_IF_ENTRY)) + ALIGN_SIZE)

typedef struct _MIB_IPMCAST_BOUNDARY
{
    DWORD   dwIfIndex;
    DWORD   dwGroupAddress;
    DWORD   dwGroupMask;
    DWORD   dwStatus;
}MIB_IPMCAST_BOUNDARY, *PMIB_IPMCAST_BOUNDARY;

typedef struct _MIB_IPMCAST_BOUNDARY_TABLE
{
    DWORD       dwNumEntries;
    MIB_IPMCAST_BOUNDARY   table[ANY_SIZE];
}MIB_IPMCAST_BOUNDARY_TABLE, *PMIB_IPMCAST_BOUNDARY_TABLE;

#define SIZEOF_BOUNDARY_TABLE(X) (FIELD_OFFSET(MIB_IPMCAST_BOUNDARY_TABLE,table[0]) + ((X) * sizeof(MIB_IPMCAST_BOUNDARY)) + ALIGN_SIZE)

typedef struct {
    DWORD    dwGroupAddress;
    DWORD    dwGroupMask;
} MIB_BOUNDARYROW, *PMIB_BOUNDARYROW;

// Structure matching what goes in the registry in a block of type
// IP_MCAST_LIMIT_INFO.  This contains the fields of
// MIB_IPMCAST_IF_ENTRY which are configurable.

typedef struct {
    DWORD    dwTtl;
    DWORD    dwRateLimit;
} MIB_MCAST_LIMIT_ROW, *PMIB_MCAST_LIMIT_ROW;

#define MAX_SCOPE_NAME_LEN 255

//
// Scope names are unicode.  SNMP and MZAP use UTF-8 encoding.
//

#define SN_UNICODE
typedef WCHAR   SN_CHAR;
typedef SN_CHAR SCOPE_NAME_BUFFER[MAX_SCOPE_NAME_LEN+1], *SCOPE_NAME;

typedef struct _MIB_IPMCAST_SCOPE
{
    DWORD             dwGroupAddress;
    DWORD             dwGroupMask;
    SCOPE_NAME_BUFFER snNameBuffer;
    DWORD             dwStatus;
}MIB_IPMCAST_SCOPE, *PMIB_IPMCAST_SCOPE;

typedef struct _MIB_IPDESTROW
{
#ifdef __cplusplus
    MIB_IPFORWARDROW  ForwardRow;
#else
    MIB_IPFORWARDROW;
#endif

    DWORD             dwForwardPreference;
    DWORD             dwForwardViewSet;
}MIB_IPDESTROW, *PMIB_IPDESTROW;

typedef struct _MIB_IPDESTTABLE
{
    DWORD             dwNumEntries;
    MIB_IPDESTROW     table[ANY_SIZE];
}MIB_IPDESTTABLE, *PMIB_IPDESTTABLE;

typedef struct _MIB_BEST_IF
{
    DWORD       dwDestAddr;
    DWORD       dwIfIndex;
}MIB_BEST_IF, *PMIB_BEST_IF;

typedef struct _MIB_PROXYARP
{
    DWORD       dwAddress;
    DWORD       dwMask;
    DWORD       dwIfIndex;
}MIB_PROXYARP, *PMIB_PROXYARP;

typedef struct _MIB_IFSTATUS
{
    DWORD       dwIfIndex;
    DWORD       dwAdminStatus;
    DWORD       dwOperationalStatus;
    BOOL        bMHbeatActive;
    BOOL        bMHbeatAlive;
}MIB_IFSTATUS, *PMIB_IFSTATUS;

typedef struct _MIB_ROUTESTATE
{
    BOOL        bRoutesSetToStack;

}MIB_ROUTESTATE, *PMIB_ROUTESTATE;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// All the info passed to (SET/CREATE) and from (GET/GETNEXT/GETFIRST)      //
// IP Router Manager is encapsulated in the following "discriminated"       //
// union.  To pass, say MIB_IFROW, use the following code                   //
//                                                                          //
//  PMIB_OPAQUE_INFO    pInfo;                                              //
//  PMIB_IFROW          pIfRow;                                             //
//  DWORD rgdwBuff[(MAX_MIB_OFFSET + sizeof(MIB_IFROW))/sizeof(DWORD) + 1]; //
//                                                                          //
//  pInfo   = (PMIB_OPAQUE_INFO)rgdwBuffer;                                 //
//  pIfRow  = (MIB_IFROW *)(pInfo->rgbyData);                               //
//                                                                          //
//  This can also be accomplished by using the following macro              //
//                                                                          //
//  DEFINE_MIB_BUFFER(pInfo,MIB_IFROW, pIfRow);                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


typedef struct _MIB_OPAQUE_INFO
{
    DWORD  dwId;

    union
    {
        ULONGLONG   ullAlign;
        BYTE        rgbyData[1];
    };

}MIB_OPAQUE_INFO, *PMIB_OPAQUE_INFO;

#define MAX_MIB_OFFSET      8

#define MIB_INFO_SIZE(S)                \
    (MAX_MIB_OFFSET + sizeof(S))

#define MIB_INFO_SIZE_IN_DWORDS(S)      \
    ((MIB_INFO_SIZE(S))/sizeof(DWORD) + 1)

#define DEFINE_MIB_BUFFER(X,Y,Z)                                        \
    DWORD        __rgdwBuff[MIB_INFO_SIZE_IN_DWORDS(Y)]; \
    PMIB_OPAQUE_INFO    X = (PMIB_OPAQUE_INFO)__rgdwBuff;               \
    Y *                 Z = (Y *)(X->rgbyData)


#define CAST_MIB_INFO(X,Y,Z)    Z = (Y)(X->rgbyData)

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif //__ROUTING_IPRTRMIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ipxrip.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    ipxrip.h

Abstract:

    This module contains the definitions of the:

    interface management APIs structures
    rip MIB management APIs structures

Author:

    Stefan Solomon  06/30/1995

Revision History:


--*/

#ifndef _IPXRIP_
#define _IPXRIP_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ipxconst.h>

typedef struct _RIP_GLOBAL_INFO {
    DWORD       EventLogMask;
} RIP_GLOBAL_INFO, *PRIP_GLOBAL_INFO;

//********************************************************************
//								     *
//		    RIP Configuration Information		     *
//								     *
//********************************************************************


//*** RIP Interface Only Information ***

typedef struct _RIP_IF_INFO {

    ULONG	    AdminState;  // The desired state of the interface
    ULONG	    UpdateMode;	// RIP update mechanism used on this interface
    ULONG	    PacketType;  // The RIP packet type used on this interface
    ULONG	    Supply; // Send RIP updates on this interface
    ULONG	    Listen; // Listen to RIP updates on this interface
    ULONG	    PeriodicUpdateInterval; // in seconds - default 60
    ULONG	    AgeIntervalMultiplier; // default - 3

    } RIP_IF_INFO, *PRIP_IF_INFO;

// UpdateMode Values:
//
// This parameter controls the RIP	database update on this interface.
//
// If this is a LAN interface, use IPX_PERIODIC_UPDATE as default.
// If this is a WAN router interface with static routes, use IPX_NO_UPDATE as default.
// If you want to trigger an update on this interface and to keep the data
// as static data, use IPX_AUTO_STATIC value.
// IPX_AUTO_STATIC update can be set only on a WAN interface
//
// PacketType Default Values:
//
// If UpdateMode is set to IPX_NO_UPDATE, this field is meaningless.
// If this is a LAN interface, use IPX_STANDARD_PACKET_TYPE as default.
// If you want reliable delivery of the update data in a triggered update,
// use IPX_RELIABLE_DELIVERY_PACKET_TYPE (this can be set only in combination with
// IPX_AUTO_STATIC_UPDATE in the UpdateMode).

// RIP Route Filter Info
//
// These filters apply to routes accepted or advertised by RIP on each interface.

typedef struct _RIP_ROUTE_FILTER_INFO {

    UCHAR	    Network[4];
    UCHAR	    Mask[4];

    } RIP_ROUTE_FILTER_INFO, *PRIP_ROUTE_FILTER_INFO;

//*** RIP Filters Only Information ***
//
//  This header is followed by RIP_ROUTE_FILTER_STRUCTURES in order:
//  First Supply filters
//  Next Listen filters

typedef struct _RIP_IF_FILTERS {

    ULONG		    SupplyFilterAction;
    ULONG		    SupplyFilterCount;
    ULONG		    ListenFilterAction;
    ULONG		    ListenFilterCount;
    RIP_ROUTE_FILTER_INFO   RouteFilter[1];

    } RIP_IF_FILTERS, *PRIP_IF_FILTERS;

// FilterAction -

#define IPX_ROUTE_FILTER_PERMIT	    1
#define IPX_ROUTE_FILTER_DENY	    2

//
//*** RIP Interface Configuration Information ***
//
// This structure is passed in AddInterface and SetInterface Entry Points
//

typedef struct _RIP_IF_CONFIG {

    RIP_IF_INFO     RipIfInfo;
    RIP_IF_FILTERS  RipIfFilters;

    } RIP_IF_CONFIG, *PRIP_IF_CONFIG;

// ***********************************************************
// ***							   ***
// ***		RIP MIB Table Identifiers		   ***
// ***							   ***
// ***********************************************************


#define RIP_BASE_ENTRY			    0
#define RIP_INTERFACE_TABLE		    1

//************************************************************
//							     *
//		RIP MIB Basic Structures		     *
//							     *
//************************************************************

//
// RIP MIB Base Entry
//

typedef struct _RIPMIB_BASE {

    ULONG	    RIPOperState;

    } RIPMIB_BASE, *PRIPMIB_BASE;


//
// RIP MIB Interface Table Entry
//

typedef struct _RIP_IF_STATS {

    ULONG		    RipIfOperState;   // up, down or sleeping
    ULONG		    RipIfInputPackets;
    ULONG		    RipIfOutputPackets;

    } RIP_IF_STATS, *PRIP_IF_STATS;



typedef struct _RIP_INTERFACE {

    ULONG	    InterfaceIndex;
    RIP_IF_INFO	    RipIfInfo;
    RIP_IF_STATS    RipIfStats;

    } RIP_INTERFACE, *PRIP_INTERFACE;

//***************************************************************
//								*
//	     INPUT DATA For: Get, GetFirst, GetNext		*
//								*
//***************************************************************

typedef struct _RIP_MIB_GET_INPUT_DATA {

    ULONG		TableId;
    ULONG		InterfaceIndex;

    } RIP_MIB_GET_INPUT_DATA, *PRIP_MIB_GET_INPUT_DATA;

//***************************************************************
//								*
//	     INPUT DATA For: Create, Delete, Set		*
//								*
//***************************************************************

typedef struct _RIP_MIB_SET_INPUT_DATA {

    ULONG		 TableId;
    RIP_INTERFACE	 RipInterface;

    } RIP_MIB_SET_INPUT_DATA, *PRIP_MIB_SET_INPUT_DATA;

//
// ***			RIP Base Entry					***
//

// MIB Functions: Get

// INPUT DATA: RIP_MIB_GET_INPUT_DATA and Index is not used

// OUTPUT DATA: RIP_INTERFACE

//
// ***			RIP Interface Table				    ***
//

// MIB Functions: Get, GetFirst, GetNext, Set

// INPUT DATA: RIP_MIB_GET_INPUT_DATA for Get, GetFirst and GetNext
//	       RIP_MIB_SET_INPUT_DATA for Set

//
// OUTPUT DATA: RIP_INTERFACE
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\IPTypes.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    iptypes.h

--*/

#ifndef IP_TYPES_INCLUDED
#define IP_TYPES_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning(disable:4201)

#include <time.h>

// Definitions and structures used by getnetworkparams and getadaptersinfo apis

#define MAX_ADAPTER_DESCRIPTION_LENGTH  128 // arb.
#define MAX_ADAPTER_NAME_LENGTH         256 // arb.
#define MAX_ADAPTER_ADDRESS_LENGTH      8   // arb.
#define DEFAULT_MINIMUM_ENTITIES        32  // arb.
#define MAX_HOSTNAME_LEN                128 // arb.
#define MAX_DOMAIN_NAME_LEN             128 // arb.
#define MAX_SCOPE_ID_LEN                256 // arb.

//
// types
//

// Node Type

#define BROADCAST_NODETYPE              1
#define PEER_TO_PEER_NODETYPE           2
#define MIXED_NODETYPE                  4
#define HYBRID_NODETYPE                 8

//
// IP_ADDRESS_STRING - store an IP address as a dotted decimal string
//

typedef struct {
    char String[4 * 4];
} IP_ADDRESS_STRING, *PIP_ADDRESS_STRING, IP_MASK_STRING, *PIP_MASK_STRING;

//
// IP_ADDR_STRING - store an IP address with its corresponding subnet mask,
// both as dotted decimal strings
//

typedef struct _IP_ADDR_STRING {
    struct _IP_ADDR_STRING* Next;
    IP_ADDRESS_STRING IpAddress;
    IP_MASK_STRING IpMask;
    DWORD Context;
} IP_ADDR_STRING, *PIP_ADDR_STRING;

//
// ADAPTER_INFO - per-adapter information. All IP addresses are stored as
// strings
//

typedef struct _IP_ADAPTER_INFO {
    struct _IP_ADAPTER_INFO* Next;
    DWORD ComboIndex;
    char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];
    char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];
    UINT AddressLength;
    BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];
    DWORD Index;
    UINT Type;
    UINT DhcpEnabled;
    PIP_ADDR_STRING CurrentIpAddress;
    IP_ADDR_STRING IpAddressList;
    IP_ADDR_STRING GatewayList;
    IP_ADDR_STRING DhcpServer;
    BOOL HaveWins;
    IP_ADDR_STRING PrimaryWinsServer;
    IP_ADDR_STRING SecondaryWinsServer;
    time_t LeaseObtained;
    time_t LeaseExpires;
} IP_ADAPTER_INFO, *PIP_ADAPTER_INFO;

#ifdef _WINSOCK2API_

//
// The following types require Winsock2.
//

typedef struct _IP_ADAPTER_ADDRESS {
    union {
        ULONGLONG _temp;
        struct { 
            ULONG Length;
            ULONG Lifetime;
        };
    };
    struct _IP_ADAPTER_ADDRESS *Next;
    DWORD Flags;
    SOCKET_ADDRESS Address;
} IP_ADAPTER_ADDRESS, *PIP_ADAPTER_ADDRESS;

typedef struct _IP_ADAPTER_ADDRESSES {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD IfIndex;
        };
    };
    struct _IP_ADAPTER_ADDRESSES *Next;
    char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];
    PIP_ADAPTER_ADDRESS FirstAddress;
} IP_ADAPTER_ADDRESSES, *PIP_ADAPTER_ADDRESSES;

// Flags

#define IP_ADAPTER_ADDRESS_USE_DDNS 0x01

#endif /* _WINSOCK2API_ */

//
// IP_PER_ADAPTER_INFO - per-adapter IP information such as DNS server list.
//

typedef struct _IP_PER_ADAPTER_INFO {
    UINT AutoconfigEnabled;
    UINT AutoconfigActive;
    PIP_ADDR_STRING CurrentDnsServer;
    IP_ADDR_STRING DnsServerList;
} IP_PER_ADAPTER_INFO, *PIP_PER_ADAPTER_INFO;

//
// FIXED_INFO - the set of IP-related information which does not depend on DHCP
//

typedef struct {
    char HostName[MAX_HOSTNAME_LEN + 4] ;
    char DomainName[MAX_DOMAIN_NAME_LEN + 4];
    PIP_ADDR_STRING CurrentDnsServer;
    IP_ADDR_STRING DnsServerList;
    UINT NodeType;
    char ScopeId[MAX_SCOPE_ID_LEN + 4];
    UINT EnableRouting;
    UINT EnableProxy;
    UINT EnableDns;
} FIXED_INFO, *PFIXED_INFO;

#pragma warning(default:4201)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ipifcons.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    ipifcons.h

Abstract:
    Constants needed for the Interface Object

--*/

#ifndef __IPIFCONS_H__
#define __IPIFCONS_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Media types                                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define MIN_IF_TYPE                     1

#define IF_TYPE_OTHER                   1   // None of the below
#define IF_TYPE_REGULAR_1822            2
#define IF_TYPE_HDH_1822                3
#define IF_TYPE_DDN_X25                 4
#define IF_TYPE_RFC877_X25              5
#define IF_TYPE_ETHERNET_CSMACD         6
#define IF_TYPE_IS088023_CSMACD         7
#define IF_TYPE_ISO88024_TOKENBUS       8
#define IF_TYPE_ISO88025_TOKENRING      9
#define IF_TYPE_ISO88026_MAN            10
#define IF_TYPE_STARLAN                 11
#define IF_TYPE_PROTEON_10MBIT          12
#define IF_TYPE_PROTEON_80MBIT          13
#define IF_TYPE_HYPERCHANNEL            14
#define IF_TYPE_FDDI                    15
#define IF_TYPE_LAP_B                   16
#define IF_TYPE_SDLC                    17
#define IF_TYPE_DS1                     18  // DS1-MIB
#define IF_TYPE_E1                      19  // Obsolete; see DS1-MIB
#define IF_TYPE_BASIC_ISDN              20
#define IF_TYPE_PRIMARY_ISDN            21
#define IF_TYPE_PROP_POINT2POINT_SERIAL 22  // proprietary serial
#define IF_TYPE_PPP                     23
#define IF_TYPE_SOFTWARE_LOOPBACK       24
#define IF_TYPE_EON                     25  // CLNP over IP
#define IF_TYPE_ETHERNET_3MBIT          26
#define IF_TYPE_NSIP                    27  // XNS over IP
#define IF_TYPE_SLIP                    28  // Generic Slip
#define IF_TYPE_ULTRA                   29  // ULTRA Technologies
#define IF_TYPE_DS3                     30  // DS3-MIB
#define IF_TYPE_SIP                     31  // SMDS, coffee
#define IF_TYPE_FRAMERELAY              32  // DTE only
#define IF_TYPE_RS232                   33
#define IF_TYPE_PARA                    34  // Parallel port
#define IF_TYPE_ARCNET                  35
#define IF_TYPE_ARCNET_PLUS             36
#define IF_TYPE_ATM                     37  // ATM cells
#define IF_TYPE_MIO_X25                 38
#define IF_TYPE_SONET                   39  // SONET or SDH
#define IF_TYPE_X25_PLE                 40
#define IF_TYPE_ISO88022_LLC            41
#define IF_TYPE_LOCALTALK               42
#define IF_TYPE_SMDS_DXI                43
#define IF_TYPE_FRAMERELAY_SERVICE      44  // FRNETSERV-MIB
#define IF_TYPE_V35                     45
#define IF_TYPE_HSSI                    46
#define IF_TYPE_HIPPI                   47
#define IF_TYPE_MODEM                   48  // Generic Modem
#define IF_TYPE_AAL5                    49  // AAL5 over ATM
#define IF_TYPE_SONET_PATH              50
#define IF_TYPE_SONET_VT                51
#define IF_TYPE_SMDS_ICIP               52  // SMDS InterCarrier Interface
#define IF_TYPE_PROP_VIRTUAL            53  // Proprietary virtual/internal
#define IF_TYPE_PROP_MULTIPLEXOR        54  // Proprietary multiplexing
#define IF_TYPE_IEEE80212               55  // 100BaseVG
#define IF_TYPE_FIBRECHANNEL            56
#define IF_TYPE_HIPPIINTERFACE          57
#define IF_TYPE_FRAMERELAY_INTERCONNECT 58  // Obsolete, use 32 or 44
#define IF_TYPE_AFLANE_8023             59  // ATM Emulated LAN for 802.3
#define IF_TYPE_AFLANE_8025             60  // ATM Emulated LAN for 802.5
#define IF_TYPE_CCTEMUL                 61  // ATM Emulated circuit
#define IF_TYPE_FASTETHER               62  // Fast Ethernet (100BaseT)
#define IF_TYPE_ISDN                    63  // ISDN and X.25
#define IF_TYPE_V11                     64  // CCITT V.11/X.21
#define IF_TYPE_V36                     65  // CCITT V.36
#define IF_TYPE_G703_64K                66  // CCITT G703 at 64Kbps
#define IF_TYPE_G703_2MB                67  // Obsolete; see DS1-MIB
#define IF_TYPE_QLLC                    68  // SNA QLLC
#define IF_TYPE_FASTETHER_FX            69  // Fast Ethernet (100BaseFX)
#define IF_TYPE_CHANNEL                 70
#define IF_TYPE_IEEE80211               71  // Radio spread spectrum
#define IF_TYPE_IBM370PARCHAN           72  // IBM System 360/370 OEMI Channel
#define IF_TYPE_ESCON                   73  // IBM Enterprise Systems Connection
#define IF_TYPE_DLSW                    74  // Data Link Switching
#define IF_TYPE_ISDN_S                  75  // ISDN S/T interface
#define IF_TYPE_ISDN_U                  76  // ISDN U interface
#define IF_TYPE_LAP_D                   77  // Link Access Protocol D
#define IF_TYPE_IPSWITCH                78  // IP Switching Objects
#define IF_TYPE_RSRB                    79  // Remote Source Route Bridging
#define IF_TYPE_ATM_LOGICAL             80  // ATM Logical Port
#define IF_TYPE_DS0                     81  // Digital Signal Level 0
#define IF_TYPE_DS0_BUNDLE              82  // Group of ds0s on the same ds1
#define IF_TYPE_BSC                     83  // Bisynchronous Protocol
#define IF_TYPE_ASYNC                   84  // Asynchronous Protocol
#define IF_TYPE_CNR                     85  // Combat Net Radio
#define IF_TYPE_ISO88025R_DTR           86  // ISO 802.5r DTR
#define IF_TYPE_EPLRS                   87  // Ext Pos Loc Report Sys
#define IF_TYPE_ARAP                    88  // Appletalk Remote Access Protocol
#define IF_TYPE_PROP_CNLS               89  // Proprietary Connectionless Proto
#define IF_TYPE_HOSTPAD                 90  // CCITT-ITU X.29 PAD Protocol
#define IF_TYPE_TERMPAD                 91  // CCITT-ITU X.3 PAD Facility
#define IF_TYPE_FRAMERELAY_MPI          92  // Multiproto Interconnect over FR
#define IF_TYPE_X213                    93  // CCITT-ITU X213
#define IF_TYPE_ADSL                    94  // Asymmetric Digital Subscrbr Loop
#define IF_TYPE_RADSL                   95  // Rate-Adapt Digital Subscrbr Loop
#define IF_TYPE_SDSL                    96  // Symmetric Digital Subscriber Loop
#define IF_TYPE_VDSL                    97  // Very H-Speed Digital Subscrb Loop
#define IF_TYPE_ISO88025_CRFPRINT       98  // ISO 802.5 CRFP
#define IF_TYPE_MYRINET                 99  // Myricom Myrinet
#define IF_TYPE_VOICE_EM                100 // Voice recEive and transMit
#define IF_TYPE_VOICE_FXO               101 // Voice Foreign Exchange Office
#define IF_TYPE_VOICE_FXS               102 // Voice Foreign Exchange Station
#define IF_TYPE_VOICE_ENCAP             103 // Voice encapsulation
#define IF_TYPE_VOICE_OVERIP            104 // Voice over IP encapsulation
#define IF_TYPE_ATM_DXI                 105 // ATM DXI
#define IF_TYPE_ATM_FUNI                106 // ATM FUNI
#define IF_TYPE_ATM_IMA                 107 // ATM IMA
#define IF_TYPE_PPPMULTILINKBUNDLE      108 // PPP Multilink Bundle
#define IF_TYPE_IPOVER_CDLC             109 // IBM ipOverCdlc
#define IF_TYPE_IPOVER_CLAW             110 // IBM Common Link Access to Workstn
#define IF_TYPE_STACKTOSTACK            111 // IBM stackToStack
#define IF_TYPE_VIRTUALIPADDRESS        112 // IBM VIPA
#define IF_TYPE_MPC                     113 // IBM multi-proto channel support
#define IF_TYPE_IPOVER_ATM              114 // IBM ipOverAtm
#define IF_TYPE_ISO88025_FIBER          115 // ISO 802.5j Fiber Token Ring
#define IF_TYPE_TDLC                    116 // IBM twinaxial data link control
#define IF_TYPE_GIGABITETHERNET         117
#define IF_TYPE_HDLC                    118
#define IF_TYPE_LAP_F                   119
#define IF_TYPE_V37                     120
#define IF_TYPE_X25_MLP                 121 // Multi-Link Protocol
#define IF_TYPE_X25_HUNTGROUP           122 // X.25 Hunt Group
#define IF_TYPE_TRANSPHDLC              123
#define IF_TYPE_INTERLEAVE              124 // Interleave channel
#define IF_TYPE_FAST                    125 // Fast channel
#define IF_TYPE_IP                      126 // IP (for APPN HPR in IP networks)
#define IF_TYPE_DOCSCABLE_MACLAYER      127 // CATV Mac Layer
#define IF_TYPE_DOCSCABLE_DOWNSTREAM    128 // CATV Downstream interface
#define IF_TYPE_DOCSCABLE_UPSTREAM      129 // CATV Upstream interface
#define IF_TYPE_A12MPPSWITCH            130 // Avalon Parallel Processor
#define IF_TYPE_TUNNEL                  131 // Encapsulation interface
#define IF_TYPE_COFFEE                  132 // Coffee pot
#define IF_TYPE_CES                     133 // Circuit Emulation Service
#define IF_TYPE_ATM_SUBINTERFACE        134 // ATM Sub Interface
#define IF_TYPE_L2_VLAN                 135 // Layer 2 Virtual LAN using 802.1Q
#define IF_TYPE_L3_IPVLAN               136 // Layer 3 Virtual LAN using IP
#define IF_TYPE_L3_IPXVLAN              137 // Layer 3 Virtual LAN using IPX
#define IF_TYPE_DIGITALPOWERLINE        138 // IP over Power Lines
#define IF_TYPE_MEDIAMAILOVERIP         139 // Multimedia Mail over IP
#define IF_TYPE_DTM                     140 // Dynamic syncronous Transfer Mode
#define IF_TYPE_DCN                     141 // Data Communications Network
#define IF_TYPE_IPFORWARD               142 // IP Forwarding Interface
#define IF_TYPE_MSDSL                   143 // Multi-rate Symmetric DSL
#define IF_TYPE_IEEE1394                144 // IEEE1394 High Perf Serial Bus

#define MAX_IF_TYPE                     144

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Access types                                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IF_ACCESS_LOOPBACK              1
#define IF_ACCESS_BROADCAST             2
#define IF_ACCESS_POINTTOPOINT          3
#define IF_ACCESS_POINTTOMULTIPOINT     4

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Connection Types                                                         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IF_CONNECTION_DEDICATED         1
#define IF_CONNECTION_PASSIVE           2
#define IF_CONNECTION_DEMAND            3


#define IF_ADMIN_STATUS_UP              1
#define IF_ADMIN_STATUS_DOWN            2
#define IF_ADMIN_STATUS_TESTING         3

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following are the the operational states for WAN and LAN interfaces. //
// The order of the states seems weird, but is done for a purpose. All      //
// states >= CONNECTED can transmit data right away. States >= DISCONNECTED //
// can tx data but some set up might be needed. States < DISCONNECTED can   //
// not transmit data.                                                       //
// A card is marked UNREACHABLE if DIM calls InterfaceUnreachable for       //
// reasons other than failure to connect.                                   //
//                                                                          //
// NON_OPERATIONAL -- Valid for LAN Interfaces. Means the card is not       //
//                      working or not plugged in or has no address.        //
// UNREACHABLE     -- Valid for WAN Interfaces. Means the remote site is    //
//                      not reachable at this time.                         //
// DISCONNECTED    -- Valid for WAN Interfaces. Means the remote site is    //
//                      not connected at this time.                         //
// CONNECTING      -- Valid for WAN Interfaces. Means a connection attempt  //
//                      has been initiated to the remote site.              //
// CONNECTED       -- Valid for WAN Interfaces. Means the remote site is    //
//                      connected.                                          //
// OPERATIONAL     -- Valid for LAN Interfaces. Means the card is plugged   //
//                      in and working.                                     //
//                                                                          //
// It is the users duty to convert these values to MIB-II values if they    //
// are to be used by a subagent                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IF_OPER_STATUS_NON_OPERATIONAL  0
#define IF_OPER_STATUS_UNREACHABLE      1
#define IF_OPER_STATUS_DISCONNECTED     2
#define IF_OPER_STATUS_CONNECTING       3
#define IF_OPER_STATUS_CONNECTED        4
#define IF_OPER_STATUS_OPERATIONAL      5

#define MIB_IF_TYPE_OTHER               1
#define MIB_IF_TYPE_ETHERNET            6
#define MIB_IF_TYPE_TOKENRING           9
#define MIB_IF_TYPE_FDDI                15
#define MIB_IF_TYPE_PPP                 23
#define MIB_IF_TYPE_LOOPBACK            24
#define MIB_IF_TYPE_SLIP                28

#define MIB_IF_ADMIN_STATUS_UP          1
#define MIB_IF_ADMIN_STATUS_DOWN        2
#define MIB_IF_ADMIN_STATUS_TESTING     3

#define MIB_IF_OPER_STATUS_NON_OPERATIONAL      0
#define MIB_IF_OPER_STATUS_UNREACHABLE          1
#define MIB_IF_OPER_STATUS_DISCONNECTED         2
#define MIB_IF_OPER_STATUS_CONNECTING           3
#define MIB_IF_OPER_STATUS_CONNECTED            4
#define MIB_IF_OPER_STATUS_OPERATIONAL          5

#ifdef __cplusplus
}
#endif

#endif //__ROUTING_IPIFCONS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ipinfoid.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    ipinfoid.h

Abstract:
    Defines the IDs needed for specifying various types of information
    to the router manager. Protocols use their ProtocolId for tagging
    information

--*/

#ifndef __ROUTING_IPINFOID_H__
#define __ROUTING_IPINFOID_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define IP_ROUTER_MANAGER_VERSION 1

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// These are the ids used for different information types supported by      //
// IP Router Manager. These ids live in the same space as the IP Routing    //
// Protocol IDs, so any addition to them must be done with care             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IP_GENERAL_INFO_BASE            0xffff0000

#define IP_IN_FILTER_INFO               IP_GENERAL_INFO_BASE + 1
#define IP_OUT_FILTER_INFO              IP_GENERAL_INFO_BASE + 2
#define IP_GLOBAL_INFO                  IP_GENERAL_INFO_BASE + 3
#define IP_INTERFACE_STATUS_INFO        IP_GENERAL_INFO_BASE + 4
#define IP_ROUTE_INFO                   IP_GENERAL_INFO_BASE + 5
#define IP_PROT_PRIORITY_INFO           IP_GENERAL_INFO_BASE + 6
#define IP_ROUTER_DISC_INFO             IP_GENERAL_INFO_BASE + 7
// N.B. Unused ID available at IP_GENERAL_INFO_BASE + 8.
#define IP_DEMAND_DIAL_FILTER_INFO      IP_GENERAL_INFO_BASE + 9
#define IP_MCAST_HEARBEAT_INFO          IP_GENERAL_INFO_BASE + 10
#define IP_MCAST_BOUNDARY_INFO          IP_GENERAL_INFO_BASE + 11
#define IP_IPINIP_CFG_INFO              IP_GENERAL_INFO_BASE + 12
#define IP_IFFILTER_INFO                IP_GENERAL_INFO_BASE + 13
#define IP_MCAST_LIMIT_INFO             IP_GENERAL_INFO_BASE + 14


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following IDS are defined in routprot.h and given here for           //
// informational purposes only                                              //
//                                                                          //
// #define IP_OTHER         1                                               //
// #define IP_LOCAL         2                                               //
// #define IP_NETMGMT       3                                               //
// #define IP_ICMP          4                                               //
// #define IP_EGP           5                                               //
// #define IP_GGP           6                                               //
// #define IP_HELLO         7                                               //
// #define IP_RIP           8                                               //
// #define IP_IS_IS         9                                               //
// #define IP_ES_IS         10                                              //
// #define IP_CISCO         11                                              //
// #define IP_BBN           12                                              //
// #define IP_OSPF          13                                              //
// #define IP_BGP           14                                              //
//                                                                          //
// #define IP_BOOTP         9999                                            //
// #define IPRTRMGR_PID     10000                                           //
// #define IP_NT_AUTOSTATIC 10002                                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif

#endif //__ROUTING_IPINFOID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ipxsap.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    ipxsap.h

Abstract:

    This module contains the definitions of the:

    interface management APIs structures
    sap global management APIs structures
    sap MIB management APIs structures

Author:

    Stefan Solomon  06/30/1995

Revision History:


--*/

#ifndef _IPXSAP_
#define _IPXSAP_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ipxconst.h>

typedef struct _SAP_GLOBAL_INFO {
    DWORD       EventLogMask;
} SAP_GLOBAL_INFO, *PSAP_GLOBAL_INFO;

//********************************************************************
//								     *
//		    SAP Configuration Information		     *
//								     *
//********************************************************************

//*** SAP Interface Configuration Information ***

typedef struct _SAP_IF_INFO {

    ULONG	    AdminState;  // The desired state of the interface
    ULONG	    UpdateMode;	// SAP update mechanism used on this interface
    ULONG	    PacketType;  // The SAP packet type used on this interface
    ULONG	    Supply; // Send SAP updates on this interface
    ULONG	    Listen; // Listen to SAP updates on this interface
    ULONG	    GetNearestServerReply; // Reply to GetNearestServer
    ULONG	    PeriodicUpdateInterval; // in seconds - default 60
    ULONG	    AgeIntervalMultiplier; // default 3

    } SAP_IF_INFO, *PSAP_IF_INFO;

// UpdateMode Values:
//
// This parameter controls the SAP	database update on this interface.
//
// If this is a LAN interface, use IPX_PERIODIC_UPDATE as default.
// If this is a WAN router interface with static routes, use IPX_NO_UPDATE as default.
// If you want to trigger an update on this interface and to keep the data
// as static data, use IPX_AUTO_STATIC value.
// IPX_AUTO_STATIC update can be set only on a WAN interface
//
// PacketType Default Values:
//
// If UpdateMode is set to IPX_NO_UPDATE, this field is meaningless.
// If this is a LAN interface, use IPX_STANDARD_PACKET_TYPE as default.
// If you want reliable delivery of the update data in a triggered update,
// use IPX_RELIABLE_DELIVERY_PACKET_TYPE (this can be set only in combination with
// IPX_AUTO_STATIC_UPDATE in the UpdateMode).


// IPX Service Filter Info
//

typedef struct _SAP_SERVICE_FILTER_INFO {
    union {
        USHORT	    ServiceType;
        ULONG       ServiceType_align;  // Ensures aligment
        };
    UCHAR	    ServiceName[48];
    } SAP_SERVICE_FILTER_INFO, *PSAP_SERVICE_FILTER_INFO;

// ServiceType - a wildcard (0xFFFF) means any type.

// ServiceName - (1-47)chars service name. A null byte as the first byte
// signifies ANY server of this type

//*** SAP Filters Only Information ***

typedef struct _SAP_IF_FILTERS {

    ULONG		    SupplyFilterAction;
    ULONG		    SupplyFilterCount;
    ULONG		    ListenFilterAction;
    ULONG		    ListenFilterCount;
    SAP_SERVICE_FILTER_INFO ServiceFilter[1];

    } SAP_IF_FILTERS, *PSAP_IF_FILTERS;

// FilterAction -

#define IPX_SERVICE_FILTER_PERMIT	    1
#define IPX_SERVICE_FILTER_DENY 	    2

//
//*** SAP Interface Configuration Information ***
//
// This structure is passed in AddInterface and SetInterface Entry Points
//

typedef struct _SAP_IF_CONFIG {

    SAP_IF_INFO	    SapIfInfo;
    SAP_IF_FILTERS  SapIfFilters;

    } SAP_IF_CONFIG, *PSAP_IF_CONFIG;


// ***********************************************************
// ***							   ***
// ***		SAP MIB Table Identifiers		   ***
// ***							   ***
// ***********************************************************


#define SAP_BASE_ENTRY			    0
#define SAP_INTERFACE_TABLE		    1

//************************************************************
//							     *
//		SAP MIB Basic Structures		     *
//							     *
//************************************************************

//
// SAP MIB Base Entry
//

typedef struct _SAP_MIB_BASE {

    ULONG	    SapOperState;

    } SAP_MIB_BASE, *PSAP_MIB_BASE;


//
// SAP MIB Interface Table Entry
//

typedef struct _SAP_IF_STATS {

    ULONG		    SapIfOperState;   // up, down or sleeping
    ULONG		    SapIfInputPackets;
    ULONG		    SapIfOutputPackets;

    } SAP_IF_STATS, *PSAP_IF_STATS;


typedef struct _SAP_INTERFACE {

    ULONG	    InterfaceIndex;
    SAP_IF_INFO	    SapIfInfo;
    SAP_IF_STATS    SapIfStats;

    } SAP_INTERFACE, *PSAP_INTERFACE;

//***************************************************************
//								*
//	     INPUT DATA For: Get, GetFirst, GetNext		*
//								*
//***************************************************************

typedef struct _SAP_MIB_GET_INPUT_DATA {

    ULONG		TableId;
    ULONG		InterfaceIndex;

    } SAP_MIB_GET_INPUT_DATA, *PSAP_MIB_GET_INPUT_DATA;

//***************************************************************
//								*
//	     INPUT DATA For: Create, Delete, Set		*
//								*
//***************************************************************

typedef struct _SAP_MIB_SET_INPUT_DATA {

    ULONG				TableId;
	SAP_INTERFACE		SapInterface;
    } SAP_MIB_SET_INPUT_DATA, *PSAP_MIB_SET_INPUT_DATA;

//
// ***			SAP Base Entry					***
//

// MIB Functions: Get

// INPUT DATA: SAP_MIB_GET_INPUT_DATA and Index is not used

// OUTPUT DATA: SAP_INTERFACE

//
// ***			SAP Interface Table				    ***
//

// MIB Functions: Get, GetFirst, GetNext, Set

// INPUT DATA: SAP_MIB_GET_INPUT_DATA for Get, GetFirst and GetNext
//	       SAP_MIB_SET_INPUT_DATA for Set

//
// OUTPUT DATA: SAP_INTERFACE
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ipxconst.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    ipxconst.h

Abstract:

    This module contains the common constants and macros used
    by the IPX Routing Protocols

Author:

    Stefan Solomon  07/10/1995

Revision History:


--*/

#ifndef _IPXCONST_
#define _IPXCONST_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Administrative States Definitions
//
// Note: these states correspond to the MIB admin states of ENABLED and DISABLED

#define ADMIN_STATE_DISABLED		    1
#define ADMIN_STATE_ENABLED		    2

// additional admin states used for netbios delivery.
//
// Note: these states correspond to the MIB states of:
//
// ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING and
// ENABLED_ONLY_FOR_OPER_STATE_UP

#define ADMIN_STATE_ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING	3
#define ADMIN_STATE_ENABLED_ONLY_FOR_OPER_STATE_UP		4

//
// Interface Operational States Definitions
//
// Note 1: applies to the IPX, RIP and SAP operational states
// Note 2: these states correspond to the MIB operational states of
//	   UP, DOWN and SLEEPING
//

#define OPER_STATE_DOWN			   1 // not operational
#define OPER_STATE_UP			   2 // operational & can pass packets
#define OPER_STATE_SLEEPING		   3 // operational but has to connect to pass packets

//
// Additional operational states in starting/stopping the router
//

#define OPER_STATE_STARTING		    4
#define OPER_STATE_STOPPING		    5

//
// Definitions and default values for the RIP and SAP Interface Info
//

// UpdateMode definitions
//

#define IPX_STANDARD_UPDATE		1 // Periodic update, every UpdateInterval
#define IPX_NO_UPDATE			2 // No update, used for static routes config
#define IPX_AUTO_STATIC_UPDATE		3 // AutoStatic triggered update

// PacketType definitions
//

#define IPX_STANDARD_PACKET_TYPE		1
#define IPX_RELIABLE_DELIVERY_PACKET_TYPE	2

// Pace definitions

#define IPX_PACE_DEFVAL 	18 // This corresponds to a 55 ms interpacketgap

// UpdateInterval definitions

#define IPX_UPDATE_INTERVAL_DEFVAL  60

//*********************************************************
//							  *
//		 IPX Route Entry Definitions		  *
//							  *
//*********************************************************

//
// IPX route entry defs for RTM mapping
//

#define   R_Interface		       RR_InterfaceID
#define   R_Protocol		       RR_RoutingProtocol

#define   R_Network		       RR_Network.N_NetNumber
#define   R_TickCount		       RR_FamilySpecificData.FSD_TickCount
#define   R_HopCount		       RR_FamilySpecificData.FSD_HopCount
#define   R_NextHopMacAddress	       RR_NextHopAddress.NHA_Mac

#define   R_Flags		       RR_FamilySpecificData.FSD_Flags

//
// Some particular interface indices values
//

#define MAX_INTERFACE_INDEX		0xFFFFFFFE
#define GLOBAL_INTERFACE_INDEX		0xFFFFFFFF

//
// Flags definitions
//

#define GLOBAL_WAN_ROUTE		0x00000001
#define DO_NOT_ADVERTISE_ROUTE		0x00000002

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\isguids.h ===
/*
 * isguids.h - Internet Shortcut GUID definitions.
 *
 * Copyright (c) 1995-1998, Microsoft Corporation.  All rights reserved.
 */


/* GUIDs
 ********/

#ifndef _ISGUIDS_H_
#define _ISGUIDS_H_

DEFINE_GUID(CLSID_InternetShortcut,       0xFBF23B40L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);

DEFINE_GUID(IID_IUniformResourceLocatorA, 0xFBF23B80L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);
DEFINE_GUID(IID_IUniformResourceLocatorW, 0xCABB0DA0L, 0xDA57, 0x11CF, 0x99, 0x74, 0x00, 0x20, 0xAF, 0xD7, 0x97, 0x62);

#ifdef UNICODE
#define IID_IUniformResourceLocator     IID_IUniformResourceLocatorW
#else
#define IID_IUniformResourceLocator     IID_IUniformResourceLocatorA
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ipxtfflt.h ===
/*
Copyright (c) 1995-1999 Microsoft Corporation
    File  ipxfltdf.h

    Defines structures used with the ipx filter driver.
*/

#ifndef __ipxfltdf_h
#define __ipxfltdf_h

#if _MSC_VER > 1000
#pragma once
#endif

//*** IPX Traffic Filters ***
typedef struct _IPX_TRAFFIC_FILTER_GLOBAL_INFO {
	ULONG	FilterAction;	// Action if there is a match with
					// any filter on the interface
} IPX_TRAFFIC_FILTER_GLOBAL_INFO, *PIPX_TRAFFIC_FILTER_GLOBAL_INFO;

// FilterAction

#define IPX_TRAFFIC_FILTER_ACTION_PERMIT	1
#define IPX_TRAFFIC_FILTER_ACTION_DENY	    2

// general traffic filter info structure

typedef struct _IPX_TRAFFIC_FILTER_INFO {

    ULONG	FilterDefinition;
    UCHAR	DestinationNetwork[4];
    UCHAR	DestinationNetworkMask[4];
    UCHAR	DestinationNode[6];
    UCHAR	DestinationSocket[2];
    UCHAR	SourceNetwork[4];
    UCHAR	SourceNetworkMask[4];
    UCHAR	SourceNode[6];
    UCHAR	SourceSocket[2];
	UCHAR	PacketType;
    } IPX_TRAFFIC_FILTER_INFO, *PIPX_TRAFFIC_FILTER_INFO;

// FilterDefinition - Flags to specify relevant IPX address fields to filter on
#define IPX_TRAFFIC_FILTER_ON_SRCNET	0x00000001
#define IPX_TRAFFIC_FILTER_ON_SRCNODE	0x00000002
#define IPX_TRAFFIC_FILTER_ON_SRCSOCKET	0x00000004

#define IPX_TRAFFIC_FILTER_ON_DSTNET	0x00000010
#define IPX_TRAFFIC_FILTER_ON_DSTNODE	0x00000020
#define IPX_TRAFFIC_FILTER_ON_DSTSOCKET	0x00000040

#define IPX_TRAFFIC_FILTER_ON_PKTTYPE	0x00000100
#define IPX_TRAFFIC_FILTER_LOG_MATCHES	0x80000000

typedef struct _FLT_IF_SET_PARAMS {
	ULONG			InterfaceIndex;	// Index of the interface
	ULONG			FilterAction;	// Filter action
	ULONG			FilterSize;	// sizeof (IPX_TRAFFIC_FILTER_INFO)
} FLT_IF_SET_PARAMS, *PFLT_IF_SET_PARAMS;

typedef struct _FLT_IF_GET_PARAMS {
	ULONG			FilterAction;	// Filter action
	ULONG			FilterSize;	// sizeof (IPX_TRAFFIC_FILTER_INFO)
	ULONG			TotalSize;	// Total size of filter description
						// array
} FLT_IF_GET_PARAMS, *PFLT_IF_GET_PARAMS;

typedef struct _FLT_PACKET_LOG {
	ULONG			SrcIfIdx;	// Index of source if (-1 - unknown)
	ULONG			DstIfIdx;	// Index of dest if (-1 - unknown)
	USHORT			DataSize;	// Total size of the data (at least 30)
	USHORT			SeqNum;		// Sequence number to account for
						// packets lost to lack of buffer space
	UCHAR			Header[30];	// IPX packet header followed by the
						// data if any
} FLT_PACKET_LOG, *PFLT_PACKET_LOG;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\iso646.h ===
/* iso646.h standard header */
#pragma once
#ifndef _ISO646
#define _ISO646

#if !defined(__cplusplus) || defined(_MSC_EXTENSIONS)
 #define and	&&
 #define and_eq	&=
 #define bitand	&
 #define bitor	|
 #define compl	~
 #define not	!
 #define not_eq	!=
 #define or		||
 #define or_eq	|=
 #define xor	^
 #define xor_eq	^=
#endif /* !__cplusplus || _MSC_EXTENSIONS */

#endif /* _ISO646 */

/*
* Copyright (c) 1992-2000 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.09:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ipxrtdef.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    ipxrtdef.h

Abstract:

    This module contains the definitions of the:

    interface management APIs structures
    ipx global router management APIs structures
    ipx router MIB management APIs structures

Author:

    Stefan Solomon  03/03/1995

Revision History:


--*/

#ifndef _IPXRTDEF_
#define _IPXRTDEF_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ipxconst.h>
#include <ipxsap.h>
#include <ipxrip.h>
#include <stm.h>
#include <ipxtfflt.h>

//****************************************************************
//***							       ***
//***			Global Definitions		       ***
//***							       ***
//****************************************************************

//
//  Version of this router
//

#define IPX_ROUTER_VERSION_1		    RTR_INFO_BLOCK_VERSION

//
//  IPX Protocols
//

#define IPX_PROTOCOL_LOCAL		    1
#define IPX_PROTOCOL_STATIC		    2

//
// Interface Type Definitions for MIB reporting - these are mapped from the
// DDM interface type
//

#define IF_TYPE_OTHER				1
#define IF_TYPE_LAN				2
#define IF_TYPE_WAN_ROUTER			3
#define IF_TYPE_WAN_WORKSTATION			4  // remote workstation dialing in
#define IF_TYPE_INTERNAL			5  // the internal (virtual) interface
#define IF_TYPE_PERSONAL_WAN_ROUTER		6
#define IF_TYPE_ROUTER_WORKSTATION_DIALOUT	7  // local workstation dialing out
#define IF_TYPE_STANDALONE_WORKSTATION_DIALOUT	8

//
// Definitions for Table of Contents Entries Info Types
//

#define IPX_INTERFACE_INFO_TYPE			1
#define IPX_STATIC_ROUTE_INFO_TYPE		2
#define IPX_STATIC_SERVICE_INFO_TYPE		3
#define IPX_SERVICE_FILTER_INFO_TYPE		4
#define IPX_ROUTE_FILTER_INFO_TYPE		5
#define IPX_IN_TRAFFIC_FILTER_INFO_TYPE		6
#define IPX_ADAPTER_INFO_TYPE			7
#define IPXWAN_INTERFACE_INFO_TYPE		8
#define IPX_GLOBAL_INFO_TYPE			9
#define IPX_STATIC_NETBIOS_NAME_INFO_TYPE	10
#define IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE	11
#define IPX_OUT_TRAFFIC_FILTER_INFO_TYPE		12
#define IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE	13

//****************************************************************
//***							       ***
//***	Specific Info Structures In The Information Block      ***
//***							       ***
//****************************************************************

//*** IPX Router Manager Global Info ***

#define     IPX_SMALL_ROUTING_TABLE_HASH_SIZE	    31
#define     IPX_MEDIUM_ROUTING_TABLE_HASH_SIZE	    257
#define     IPX_LARGE_ROUTING_TABLE_HASH_SIZE	    2047

typedef struct _IPX_GLOBAL_INFO {

    ULONG	    RoutingTableHashSize;
    ULONG       EventLogMask;
    } IPX_GLOBAL_INFO, *PIPX_GLOBAL_INFO;


//*** IPX Interface Info ***

typedef struct _IPX_IF_INFO {

    ULONG	    AdminState;        // The desired state of the interface
    ULONG	    NetbiosAccept;     // Accept Netbios broadcast packets
    ULONG	    NetbiosDeliver;    // Deliver Netbios broadcast packets

    } IPX_IF_INFO, *PIPX_IF_INFO;


// Interface Device Type Definitions

#define IPX_DEDICATED_LINK	    1	// includes LAN, leased lines, frame-relay
#define IPX_DIALED_LINK 	    2	// dial on demand links

// Default values:
//
// AdminState: enabled - disabling it disables also RIP, SAP and anything else
// NetbiosAccept: enabled
// NetbiosDeliver: enabled on LAN interface, disabled on WAN interface
// IpxWanNegotiation: disabled.

// The interface name corresponds to the local adapter name in the case the
// interface is the local LAN. If the adapter is multiplexed with different
// packet types, there is a unique net number assigned to each pseudo-adapter.
// In this case the NetNumber is used to differentiate which pseudo-adapter gets
// this interface info.

//*** IPXWAN Interface Info ***

typedef struct _IPXWAN_IF_INFO {

    ULONG	    AdminState;  // Enable/Disable IPXWAN negotiation

    } IPXWAN_IF_INFO, *PIPXWAN_IF_INFO;

//*** Static Route Entry ***

typedef struct _IPX_STATIC_ROUTE_INFO {

    union {

    ULONG	DwordAlign;
    UCHAR	Network[4];  };
    USHORT	TickCount;
    USHORT	HopCount;
    UCHAR	NextHopMacAddress[6];

    } IPX_STATIC_ROUTE_INFO, *PIPX_STATIC_ROUTE_INFO;


//*** Static Service Entry ***

typedef IPX_SERVER_ENTRY IPX_STATIC_SERVICE_INFO, *PIPX_STATIC_SERVICE_INFO;


//*** Static Netbios Name Entry ***

typedef struct	_IPX_STATIC_NETBIOS_NAME_INFO {

    union {

    ULONG	DwordAlign;
    UCHAR	Name[16];     };

    } IPX_STATIC_NETBIOS_NAME_INFO, *PIPX_STATIC_NETBIOS_NAME_INFO;


//
// *** IPX LAN ADAPTER INFO ***
//

#define MAX_ADAPTER_NAME_LEN		    48

typedef struct _IPX_ADAPTER_INFO {

    ULONG	PacketType;
    WCHAR	AdapterName[MAX_ADAPTER_NAME_LEN];

    } IPX_ADAPTER_INFO, *PIPX_ADAPTER_INFO;

#define AUTO_DETECT_PACKET_TYPE 	    0xFFFFFFFF



// ***********************************************************
// ***							   ***
// ***		IPX MIB Table Identifiers		   ***
// ***							   ***
// ***********************************************************


#define IPX_BASE_ENTRY			    0
#define IPX_INTERFACE_TABLE		    1
#define IPX_DEST_TABLE			    2	 // IPX Best Routes Table
#define IPX_STATIC_ROUTE_TABLE		    3	 // IPX Static Routes Table
#define IPX_SERV_TABLE			    4	 // IPX Services Table
#define IPX_STATIC_SERV_TABLE		    5	 // IPX Static Services Table

#define MAX_IPX_MIB_TABLES		    6


//
// Some Global MIB Constants
//

// max size of the interface readable name

#define IPX_INTERFACE_ANSI_NAME_LEN	    48

// ***************************************************************************
//
// ***	     IPX MIB APIs Input/Output Structures For Each Table	   ***
//
//****************************************************************************

// Global definition of the MIB Identifier (locates the table and the row index)

typedef struct	_IF_TABLE_INDEX {

    ULONG	InterfaceIndex;

    } IF_TABLE_INDEX, *PIF_TABLE_INDEX;

typedef struct _ROUTING_TABLE_INDEX {

    UCHAR	Network[4];

    } ROUTING_TABLE_INDEX, *PROUTING_TABLE_INDEX;

typedef struct _STATIC_ROUTES_TABLE_INDEX {

    ULONG	InterfaceIndex;
    UCHAR	Network[4];

    } STATIC_ROUTES_TABLE_INDEX, *PSTATIC_ROUTES_TABLE_INDEX;

typedef struct _SERVICES_TABLE_INDEX {

    USHORT	ServiceType;
    UCHAR	ServiceName[48];

    } SERVICES_TABLE_INDEX, *PSERVICES_TABLE_INDEX;

typedef struct _STATIC_SERVICES_TABLE_INDEX {

    ULONG	InterfaceIndex;
    USHORT	ServiceType;
    UCHAR	ServiceName[48];

    } STATIC_SERVICES_TABLE_INDEX, *PSTATIC_SERVICES_TABLE_INDEX;

typedef union _IPX_MIB_INDEX {

    IF_TABLE_INDEX		InterfaceTableIndex;
    ROUTING_TABLE_INDEX		RoutingTableIndex;
    STATIC_ROUTES_TABLE_INDEX	StaticRoutesTableIndex;
    SERVICES_TABLE_INDEX	ServicesTableIndex;
    STATIC_SERVICES_TABLE_INDEX StaticServicesTableIndex;

    } IPX_MIB_INDEX, *PIPX_MIB_INDEX;

//**********************************************************************
//								       *
//	     INPUT DATA For: Get, GetFirst, GetNext		       *
//								       *
//**********************************************************************

typedef struct _IPX_MIB_GET_INPUT_DATA {

    ULONG		TableId;
    IPX_MIB_INDEX	MibIndex;

    } IPX_MIB_GET_INPUT_DATA, *PIPX_MIB_GET_INPUT_DATA;

typedef struct _IPXMIB_BASE {

    ULONG	    OperState;
    UCHAR	    PrimaryNetNumber[4];
    UCHAR	    Node[6];
    UCHAR	    SysName[IPX_INTERFACE_ANSI_NAME_LEN];
    ULONG	    MaxPathSplits;
    ULONG	    IfCount;
    ULONG	    DestCount;
    ULONG	    ServCount;

    } IPXMIB_BASE, *PIPXMIB_BASE;

// structure used to gather interface statistics

typedef struct _IPX_IF_STATS {

	ULONG		IfOperState;
	ULONG		MaxPacketSize;
	ULONG		InHdrErrors;
	ULONG		InFiltered;
	ULONG		InNoRoutes;
	ULONG		InDiscards;
	ULONG		InDelivers;
	ULONG		OutFiltered;
	ULONG		OutDiscards;
	ULONG		OutDelivers;
	ULONG		NetbiosReceived;
	ULONG		NetbiosSent;

	} IPX_IF_STATS, *PIPX_IF_STATS;

// structure describing the MIB Row for the IPX_INTERFACE_TABLE in the
// IPX_INTERFACE_GROUP

typedef struct _IPX_INTERFACE {

    ULONG	    InterfaceIndex;
    ULONG	    AdminState;
    ULONG	    AdapterIndex;
    UCHAR	    InterfaceName[IPX_INTERFACE_ANSI_NAME_LEN];
    ULONG	    InterfaceType;
    ULONG	    MediaType;
    UCHAR	    NetNumber[4];
    UCHAR	    MacAddress[6];
    ULONG	    Delay;
    ULONG	    Throughput;
    ULONG	    NetbiosAccept;
    ULONG	    NetbiosDeliver;
    ULONG	    EnableIpxWanNegotiation;
    IPX_IF_STATS    IfStats;

    } IPX_INTERFACE, *PIPX_INTERFACE;


typedef struct _IPX_ROUTE {

    ULONG	InterfaceIndex; // see ipxconst.h for specific indices definitions
    ULONG	Protocol;
    UCHAR	Network[4];
    USHORT	TickCount;
    USHORT	HopCount;
    UCHAR	NextHopMacAddress[6];
    ULONG	Flags;

    }  IPX_ROUTE, *PIPX_ROUTE;

//
// INPUT DATA For: Create, Delete, Set
//

typedef	union _IPX_MIB_ROW {

	IPX_INTERFACE	 Interface;
	IPX_ROUTE	 Route;
	IPX_SERVICE	 Service;

	} IPX_MIB_ROW, *PIPX_MIB_ROW;


typedef struct _IPX_MIB_SET_INPUT_DATA {

    ULONG		 TableId;
    IPX_MIB_ROW 	 MibRow;

    } IPX_MIB_SET_INPUT_DATA, *PIPX_MIB_SET_INPUT_DATA;

//
// ***			IPX Base Entry					***
//

// MIB Functions: Get

// INPUT DATA: IPX_MIB_GET_INPUT_DATA and Index is not used

// OUTPUT DATA:

//
// ***			IPX Interface Table				    ***
//

// MIB Functions: Get, GetFirst, GetNext, Set

// INPUT DATA: IPX_MIB_GET_INPUT_DATA and Index is IF_TABLE_INDEX for Get, GetFirst and GetNext
//	       IPX_MIB_SET_INPUT_DATA and MibRow is IPX_INTERFACE for Set

//
// OUTPUT DATA: described by the IPX_INTERFACE structure below
//

//
// ***			IPX Routes Table				   ***
//

// MIB Functions:  Get, GetFirst, GetNext

// INPUT DATA: IPX_MIB_INPUT_DATA with Index ROUTES_TABLE_INDEX

// OUTPUT DATA: IPX_ROUTE
//


//
// ***			IPX Static Routes Table				   ***
//

// MIB Functions:  Create, Delete, Get, GetFirst, GetNext, Set

// INPUT DATA: IPX_MIB_GET_INPUT_DATA with Index STATIC_ROUTES_TABLE_INDEX for Get, GetFirst, GetNext
//	       IPX_MIB_SET_INPUT_DATA and MibRow is IPX_ROUTE for Create, Delete, Set

// OUTPUT DATA: IPX_ROUTE
//

//
// ***			 IPX Services Table				   ***
//

// MIB Functions: Get, GetFirst, GetNext

// INPUT DATA: IPX_MIB_INPUT_DATA with Index SERVICES_TABLE_INDEX

// OUTPUT DATA: The output data is the structure IPX_SERVICE

//
// ***			 IPX Static Services Table			   ***
//

// MIB Functions: Create, Delete, Get, GetFirst, GetNext

// INPUT DATA: IPX_MIB_GET_INPUT_DATA with Index STATIC_SERVICES_TABLE_INDEX for Get, GetFirst, GetNext
//	       IPX_MIB_SET_INPUT_DATA and MibRow is IPX_SERVICE for Create, Delete and Set.

// OUTPUT DATA: IPX_SERVICE

#endif	 // _IPXRTDEF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\irtc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Mon Sep 20 16:32:19 1999
 */
/* Compiler settings for irtc.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __irtc_h__
#define __irtc_h__

/* Forward Declarations */ 

#ifndef __IRTC_FWD_DEFINED__
#define __IRTC_FWD_DEFINED__
typedef interface IRTC IRTC;
#endif 	/* __IRTC_FWD_DEFINED__ */


/* header files for imported files */
#include "nmFinder.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_irtc_0000 */
/* [local] */ 

#define	DEFAULT_RTC_BUFFER_SIZE	( 0x100000 )

#define	RTC_FRAME_SIZE_FULL	( 0 )



extern RPC_IF_HANDLE __MIDL_itf_irtc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_irtc_0000_v0_0_s_ifspec;

#ifndef __IRTC_INTERFACE_DEFINED__
#define __IRTC_INTERFACE_DEFINED__

/* interface IRTC */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IRTC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4811EA40-B582-11ce-B5AF-00AA006CB37D")
    IRTC : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID FramesCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ NETWORKSTATUS __RPC_FAR *pNetworkStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [out] */ BOOL __RPC_FAR *IsRunnning,
            /* [out] */ BOOL __RPC_FAR *IsPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalStatistics( 
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversationStatistics( 
            /* [out] */ DWORD __RPC_FAR *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD __RPC_FAR *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpecialFrame( 
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ LPBYTE pUserData,
            /* [in] */ DWORD UserDataLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStations( 
            /* [out][in] */ QUERYTABLE __RPC_FAR *lpQueryTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRTC __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRTC __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRTC __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IRTC __RPC_FAR * This,
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID FramesCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IRTC __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryStatus )( 
            IRTC __RPC_FAR * This,
            /* [out] */ NETWORKSTATUS __RPC_FAR *pNetworkStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IRTC __RPC_FAR * This,
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IRTC __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IRTC __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IRTC __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IRTC __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetControlState )( 
            IRTC __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *IsRunnning,
            /* [out] */ BOOL __RPC_FAR *IsPaused);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalStatistics )( 
            IRTC __RPC_FAR * This,
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversationStatistics )( 
            IRTC __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD __RPC_FAR *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertSpecialFrame )( 
            IRTC __RPC_FAR * This,
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ LPBYTE pUserData,
            /* [in] */ DWORD UserDataLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryStations )( 
            IRTC __RPC_FAR * This,
            /* [out][in] */ QUERYTABLE __RPC_FAR *lpQueryTable);
        
        END_INTERFACE
    } IRTCVtbl;

    interface IRTC
    {
        CONST_VTBL struct IRTCVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTC_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRTC_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRTC_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRTC_Connect(This,hInputBlob,StatusCallbackProc,FramesCallbackProc,UserContext,hErrorBlob)	\
    (This)->lpVtbl -> Connect(This,hInputBlob,StatusCallbackProc,FramesCallbackProc,UserContext,hErrorBlob)

#define IRTC_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IRTC_QueryStatus(This,pNetworkStatus)	\
    (This)->lpVtbl -> QueryStatus(This,pNetworkStatus)

#define IRTC_Configure(This,hConfigurationBlob,hErrorBlob)	\
    (This)->lpVtbl -> Configure(This,hConfigurationBlob,hErrorBlob)

#define IRTC_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IRTC_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IRTC_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IRTC_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IRTC_GetControlState(This,IsRunnning,IsPaused)	\
    (This)->lpVtbl -> GetControlState(This,IsRunnning,IsPaused)

#define IRTC_GetTotalStatistics(This,lpStats,fClearAfterReading)	\
    (This)->lpVtbl -> GetTotalStatistics(This,lpStats,fClearAfterReading)

#define IRTC_GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)	\
    (This)->lpVtbl -> GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)

#define IRTC_InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)	\
    (This)->lpVtbl -> InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)

#define IRTC_QueryStations(This,lpQueryTable)	\
    (This)->lpVtbl -> QueryStations(This,lpQueryTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRTC_Connect_Proxy( 
    IRTC __RPC_FAR * This,
    /* [in] */ HBLOB hInputBlob,
    /* [in] */ LPVOID StatusCallbackProc,
    /* [in] */ LPVOID FramesCallbackProc,
    /* [in] */ LPVOID UserContext,
    /* [out] */ HBLOB hErrorBlob);


void __RPC_STUB IRTC_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_Disconnect_Proxy( 
    IRTC __RPC_FAR * This);


void __RPC_STUB IRTC_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_QueryStatus_Proxy( 
    IRTC __RPC_FAR * This,
    /* [out] */ NETWORKSTATUS __RPC_FAR *pNetworkStatus);


void __RPC_STUB IRTC_QueryStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_Configure_Proxy( 
    IRTC __RPC_FAR * This,
    /* [in] */ HBLOB hConfigurationBlob,
    /* [out] */ HBLOB hErrorBlob);


void __RPC_STUB IRTC_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_Start_Proxy( 
    IRTC __RPC_FAR * This);


void __RPC_STUB IRTC_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_Pause_Proxy( 
    IRTC __RPC_FAR * This);


void __RPC_STUB IRTC_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_Resume_Proxy( 
    IRTC __RPC_FAR * This);


void __RPC_STUB IRTC_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_Stop_Proxy( 
    IRTC __RPC_FAR * This);


void __RPC_STUB IRTC_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_GetControlState_Proxy( 
    IRTC __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *IsRunnning,
    /* [out] */ BOOL __RPC_FAR *IsPaused);


void __RPC_STUB IRTC_GetControlState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_GetTotalStatistics_Proxy( 
    IRTC __RPC_FAR * This,
    /* [out] */ LPSTATISTICS lpStats,
    /* [in] */ BOOL fClearAfterReading);


void __RPC_STUB IRTC_GetTotalStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_GetConversationStatistics_Proxy( 
    IRTC __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *nSessions,
    /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
    /* [out] */ DWORD __RPC_FAR *nStations,
    /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
    /* [in] */ BOOL fClearAfterReading);


void __RPC_STUB IRTC_GetConversationStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_InsertSpecialFrame_Proxy( 
    IRTC __RPC_FAR * This,
    /* [in] */ DWORD FrameType,
    /* [in] */ DWORD Flags,
    /* [in] */ LPBYTE pUserData,
    /* [in] */ DWORD UserDataLength);


void __RPC_STUB IRTC_InsertSpecialFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRTC_QueryStations_Proxy( 
    IRTC __RPC_FAR * This,
    /* [out][in] */ QUERYTABLE __RPC_FAR *lpQueryTable);


void __RPC_STUB IRTC_QueryStations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRTC_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\irtpsph.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Sat Jul 31 00:49:55 1999
 */
/* Compiler settings for irtpsph.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __irtpsph_h__
#define __irtpsph_h__

/* Forward Declarations */ 

#ifndef __IRTPSPHFilter_FWD_DEFINED__
#define __IRTPSPHFilter_FWD_DEFINED__
typedef interface IRTPSPHFilter IRTPSPHFilter;
#endif 	/* __IRTPSPHFilter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IRTPSPHFilter_INTERFACE_DEFINED__
#define __IRTPSPHFilter_INTERFACE_DEFINED__

/* interface IRTPSPHFilter */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IRTPSPHFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D5284681-B680-11d0-9643-00AA00A89C1D")
    IRTPSPHFilter : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE OverridePayloadType( 
            /* [in] */ BYTE bPayloadType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetPayloadType( 
            /* [out] */ BYTE __RPC_FAR *lpbPayloadType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetMaxPacketSize( 
            /* [in] */ DWORD dwMaxPacketSize) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMaxPacketSize( 
            /* [out] */ LPDWORD lpdwMaxPacketSize) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetOutputPinMinorType( 
            /* [in] */ GUID gMinorType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetOutputPinMinorType( 
            /* [out] */ GUID __RPC_FAR *lpgMinorType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetInputPinMediaType( 
            /* [in] */ AM_MEDIA_TYPE __RPC_FAR *lpMediaPinType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetInputPinMediaType( 
            /* [out] */ AM_MEDIA_TYPE __RPC_FAR *__RPC_FAR *ppMediaPinType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTPSPHFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRTPSPHFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRTPSPHFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRTPSPHFilter __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OverridePayloadType )( 
            IRTPSPHFilter __RPC_FAR * This,
            /* [in] */ BYTE bPayloadType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPayloadType )( 
            IRTPSPHFilter __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *lpbPayloadType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaxPacketSize )( 
            IRTPSPHFilter __RPC_FAR * This,
            /* [in] */ DWORD dwMaxPacketSize);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxPacketSize )( 
            IRTPSPHFilter __RPC_FAR * This,
            /* [out] */ LPDWORD lpdwMaxPacketSize);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputPinMinorType )( 
            IRTPSPHFilter __RPC_FAR * This,
            /* [in] */ GUID gMinorType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputPinMinorType )( 
            IRTPSPHFilter __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *lpgMinorType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInputPinMediaType )( 
            IRTPSPHFilter __RPC_FAR * This,
            /* [in] */ AM_MEDIA_TYPE __RPC_FAR *lpMediaPinType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputPinMediaType )( 
            IRTPSPHFilter __RPC_FAR * This,
            /* [out] */ AM_MEDIA_TYPE __RPC_FAR *__RPC_FAR *ppMediaPinType);
        
        END_INTERFACE
    } IRTPSPHFilterVtbl;

    interface IRTPSPHFilter
    {
        CONST_VTBL struct IRTPSPHFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTPSPHFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRTPSPHFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRTPSPHFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRTPSPHFilter_OverridePayloadType(This,bPayloadType)	\
    (This)->lpVtbl -> OverridePayloadType(This,bPayloadType)

#define IRTPSPHFilter_GetPayloadType(This,lpbPayloadType)	\
    (This)->lpVtbl -> GetPayloadType(This,lpbPayloadType)

#define IRTPSPHFilter_SetMaxPacketSize(This,dwMaxPacketSize)	\
    (This)->lpVtbl -> SetMaxPacketSize(This,dwMaxPacketSize)

#define IRTPSPHFilter_GetMaxPacketSize(This,lpdwMaxPacketSize)	\
    (This)->lpVtbl -> GetMaxPacketSize(This,lpdwMaxPacketSize)

#define IRTPSPHFilter_SetOutputPinMinorType(This,gMinorType)	\
    (This)->lpVtbl -> SetOutputPinMinorType(This,gMinorType)

#define IRTPSPHFilter_GetOutputPinMinorType(This,lpgMinorType)	\
    (This)->lpVtbl -> GetOutputPinMinorType(This,lpgMinorType)

#define IRTPSPHFilter_SetInputPinMediaType(This,lpMediaPinType)	\
    (This)->lpVtbl -> SetInputPinMediaType(This,lpMediaPinType)

#define IRTPSPHFilter_GetInputPinMediaType(This,ppMediaPinType)	\
    (This)->lpVtbl -> GetInputPinMediaType(This,ppMediaPinType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IRTPSPHFilter_OverridePayloadType_Proxy( 
    IRTPSPHFilter __RPC_FAR * This,
    /* [in] */ BYTE bPayloadType);


void __RPC_STUB IRTPSPHFilter_OverridePayloadType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRTPSPHFilter_GetPayloadType_Proxy( 
    IRTPSPHFilter __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *lpbPayloadType);


void __RPC_STUB IRTPSPHFilter_GetPayloadType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRTPSPHFilter_SetMaxPacketSize_Proxy( 
    IRTPSPHFilter __RPC_FAR * This,
    /* [in] */ DWORD dwMaxPacketSize);


void __RPC_STUB IRTPSPHFilter_SetMaxPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRTPSPHFilter_GetMaxPacketSize_Proxy( 
    IRTPSPHFilter __RPC_FAR * This,
    /* [out] */ LPDWORD lpdwMaxPacketSize);


void __RPC_STUB IRTPSPHFilter_GetMaxPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRTPSPHFilter_SetOutputPinMinorType_Proxy( 
    IRTPSPHFilter __RPC_FAR * This,
    /* [in] */ GUID gMinorType);


void __RPC_STUB IRTPSPHFilter_SetOutputPinMinorType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRTPSPHFilter_GetOutputPinMinorType_Proxy( 
    IRTPSPHFilter __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *lpgMinorType);


void __RPC_STUB IRTPSPHFilter_GetOutputPinMinorType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRTPSPHFilter_SetInputPinMediaType_Proxy( 
    IRTPSPHFilter __RPC_FAR * This,
    /* [in] */ AM_MEDIA_TYPE __RPC_FAR *lpMediaPinType);


void __RPC_STUB IRTPSPHFilter_SetInputPinMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRTPSPHFilter_GetInputPinMediaType_Proxy( 
    IRTPSPHFilter __RPC_FAR * This,
    /* [out] */ AM_MEDIA_TYPE __RPC_FAR *__RPC_FAR *ppMediaPinType);


void __RPC_STUB IRTPSPHFilter_GetInputPinMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRTPSPHFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_irtpsph_0348 */
/* [local] */ 

EXTERN_C const CLSID CLSID_INTEL_SPHH26X;
EXTERN_C const CLSID CLSID_INTEL_SPHAUD;
EXTERN_C const CLSID CLSID_INTEL_SPHGENA;
EXTERN_C const CLSID CLSID_INTEL_SPHAUD_PROPPAGE;
EXTERN_C const CLSID CLSID_INTEL_SPHGENA_PROPPAGE;
EXTERN_C const CLSID CLSID_INTEL_SPHH26X_PROPPAGE;


extern RPC_IF_HANDLE __MIDL_itf_irtpsph_0348_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_irtpsph_0348_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\itvx.h ===
////////////////////
// TVExplorer Interface Definition
//
//

#ifndef __ITVX_H__
#define __ITVX_H__

#include "mstv.h"
#include "tvdisp.h"
#include "tvdispid.h"
#include "epgdisp.h"
#include "epgdspid.h"

// {3F8A2EA2-C171-11cf-868C-00805F2C11CE}
DEFINE_GUID(IID_IEnumChannel, 
0x3f8a2ea2, 0xc171, 0x11cf, 0x86, 0x8c, 0x0, 0x80, 0x5f, 0x2c, 0x11, 0xce);

interface IEnumChannel : public IUnknown
{
public:
    virtual /* [local] */ HRESULT __stdcall Next( 
        /* [in] */ ULONG celt,
        /* [out] */ CHANNEL_INFO __RPC_FAR *rgelt,
        /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    virtual /* [local] */ HRESULT __stdcall Skip( 
        /* [in] */ ULONG celt) = 0;
    
    virtual /* [local] */ HRESULT __stdcall Reset( void) = 0;
    
    virtual /* [local] */ HRESULT __stdcall Clone( 
        /* [out] */ IEnumChannel __RPC_FAR *__RPC_FAR *ppenum) = 0;
    
};

// {3F8A2EA6-C171-11cf-868C-00805F2C11CE}
DEFINE_GUID(IID_IEPGOptions, 
0x3f8a2ea6, 0xc171, 0x11cf, 0x86, 0x8c, 0x0, 0x80, 0x5f, 0x2c, 0x11, 0xce);

interface IEPGOptions : public IUnknown
{
public:
	virtual HRESULT __stdcall DefaultAction( void) = 0;
};

// {3F8A2EA7-C171-11cf-868C-00805F2C11CE}
DEFINE_GUID(IID_IEPGItem, 
0x3f8a2ea7, 0xc171, 0x11cf, 0x86, 0x8c, 0x0, 0x80, 0x5f, 0x2c, 0x11, 0xce);

interface IEPGItem : public IUnknown
{
	virtual HRESULT __stdcall TuningInfo (LONG* plTuningSpace, LONG* plChannelNumber) = 0;
	virtual HRESULT __stdcall StartTime (DATE* pStartTime) = 0;
	virtual HRESULT __stdcall EndTime(DATE* pEndTime) = 0;
	virtual HRESULT __stdcall Length (long* pLength) = 0; 
	virtual HRESULT __stdcall OnNow (VARIANT_BOOL* pOnNow) = 0; 
	virtual HRESULT __stdcall Title (BSTR* pstrTitle) = 0;
	virtual HRESULT __stdcall BodyText (BSTR* pstrBodyText) = 0;
	virtual HRESULT __stdcall PreviewGraphic (BSTR* pstrPreviewGraphic) = 0;
	virtual HRESULT __stdcall NumIcons (long* pNumIcon) = 0;
	virtual HRESULT __stdcall GetIcon (long iIconNumber, BSTR* pstrIconName) = 0;
	virtual HRESULT __stdcall NumOptions (long* pNumOptions) = 0;
	virtual HRESULT __stdcall OptionPrompt (BSTR* pstrPrompt) = 0;
	virtual HRESULT __stdcall GetOption (long iOptionNumber, long* plID, BSTR* pstrText) = 0;
};

// {3F8A2EA8-C171-11cf-868C-00805F2C11CE}
DEFINE_GUID(IID_IEPGEpisode, 
0x3f8a2ea8, 0xc171, 0x11cf, 0x86, 0x8c, 0x0, 0x80, 0x5f, 0x2c, 0x11, 0xce);

interface IEPGEpisode : public IEPGItem
{
	virtual HRESULT __stdcall TimeSlotID(long* lTimeSlotID) = 0;
	virtual HRESULT __stdcall ChannelID(long* lChannelID) = 0;
	virtual HRESULT __stdcall EpisodeID(long* lEpisodeID) = 0;

	virtual HRESULT __stdcall PayPerView(VARIANT_BOOL *pf) = 0;

	virtual HRESULT __stdcall RatingID(long* lRatingID) = 0;

	virtual HRESULT __stdcall CallLetters(BSTR* ppszCallLetters) = 0;

	virtual HRESULT __stdcall PPVViewCost(CURRENCY* cy) = 0;
	virtual HRESULT __stdcall PPVTapeCost(CURRENCY* cy) = 0;

	virtual HRESULT __stdcall IsRemindItem(VARIANT_BOOL *pf) = 0;
	virtual HRESULT __stdcall IsRecordItem(VARIANT_BOOL *pf) = 0;
	virtual HRESULT __stdcall Repetition(int* iRep) = 0;
	virtual HRESULT __stdcall RemindRecordIdx(long* idxRR) = 0;
	virtual HRESULT __stdcall IsContinuous(VARIANT_BOOL *pf) = 0;
	virtual HRESULT __stdcall IsOnLater(VARIANT_BOOL *pf) = 0;
	virtual HRESULT __stdcall IsOnSoon(VARIANT_BOOL *pf) = 0;

	virtual HRESULT __stdcall IsPurchaseItem(VARIANT_BOOL *pf) = 0;
	virtual HRESULT __stdcall IsListGuideItem(VARIANT_BOOL *pf) = 0;
	virtual HRESULT __stdcall PurchaseIdx(long* idxPur) = 0;

	virtual HRESULT __stdcall ThemeID(long* lThemeID) = 0;

	virtual HRESULT __stdcall PPVCanBeCancelled(VARIANT_BOOL *pf) = 0;
	virtual HRESULT __stdcall PPVTokenAddress(long *lPaymentToken, long *lPaymentAddress) = 0;
	virtual HRESULT __stdcall IsPurchasable(IDispatch** ppOutDetails) = 0;

	virtual HRESULT __stdcall AbbreviatedTitle(BSTR* pstrAbbrevTitle) = 0;

	virtual HRESULT __stdcall HasEnhancement(VARIANT_BOOL *pf, long *lTSEnhMappingID, long *lEpiEnhMappingID) = 0;
	virtual HRESULT __stdcall Layout(long lEnhMappingID, BSTR* EnhTitle, BSTR* EnhLayout, BSTR* EnhAddress) = 0;
};

// {3F8A2EA9-C171-11cf-868C-00805F2C11CE}
DEFINE_GUID(IID_IEPGCategory, 
0x3f8a2ea9, 0xc171, 0x11cf, 0x86, 0x8c, 0x0, 0x80, 0x5f, 0x2c, 0x11, 0xce);

interface IEPGCategory : public IEPGItem
{
	virtual HRESULT __stdcall IsOtherTimes(VARIANT_BOOL *pf) = 0;
	virtual HRESULT __stdcall TimeSlotID(long* lTimeSlotID) = 0;
	virtual HRESULT __stdcall SearchText(BSTR* bsText) = 0;
};

// {3F8A2EAA-C171-11cf-868C-00805F2C11CE}
DEFINE_GUID(IID_IEPGDSSMailItem, 
0x3f8a2eaa, 0xc171, 0x11cf, 0x86, 0x8c, 0x0, 0x80, 0x5f, 0x2c, 0x11, 0xce);

interface IEPGDSSMailItem : public IEPGItem
{
	virtual HRESULT __stdcall MarkRead() = 0;
	virtual HRESULT __stdcall DeleteMail() = 0;
	virtual HRESULT __stdcall IsRead(VARIANT_BOOL* pIsRead) = 0;
};

#endif // __ITVX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\irtprph.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Sat Jul 31 00:49:50 1999
 */
/* Compiler settings for irtprph.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __irtprph_h__
#define __irtprph_h__

/* Forward Declarations */ 

#ifndef __IRTPRPHFilter_FWD_DEFINED__
#define __IRTPRPHFilter_FWD_DEFINED__
typedef interface IRTPRPHFilter IRTPRPHFilter;
#endif 	/* __IRTPRPHFilter_FWD_DEFINED__ */


#ifndef __IRPHH26XSettings_FWD_DEFINED__
#define __IRPHH26XSettings_FWD_DEFINED__
typedef interface IRPHH26XSettings IRPHH26XSettings;
#endif 	/* __IRPHH26XSettings_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IRTPRPHFilter_INTERFACE_DEFINED__
#define __IRTPRPHFilter_INTERFACE_DEFINED__

/* interface IRTPRPHFilter */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IRTPRPHFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D5284680-B680-11d0-9643-00AA00A89C1D")
    IRTPRPHFilter : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE OverridePayloadType( 
            /* [in] */ BYTE bPayloadType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetPayloadType( 
            /* [out] */ BYTE __RPC_FAR *lpbPayloadType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetMediaBufferSize( 
            /* [in] */ DWORD dwMaxMediaBufferSize) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMediaBufferSize( 
            /* [out] */ LPDWORD lpdwMaxMediaBufferSize) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetOutputPinMediaType( 
            /* [in] */ AM_MEDIA_TYPE __RPC_FAR *lpMediaPinType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetOutputPinMediaType( 
            /* [out] */ AM_MEDIA_TYPE __RPC_FAR *__RPC_FAR *ppMediaPinType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetTimeoutDuration( 
            /* [in] */ DWORD dwDejitterTime,
            /* [in] */ DWORD dwLostPacketTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetTimeoutDuration( 
            /* [out] */ LPDWORD lpdwDejitterTime,
            /* [out] */ LPDWORD lpdwLostPacketTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTPRPHFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRTPRPHFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRTPRPHFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRTPRPHFilter __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OverridePayloadType )( 
            IRTPRPHFilter __RPC_FAR * This,
            /* [in] */ BYTE bPayloadType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPayloadType )( 
            IRTPRPHFilter __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *lpbPayloadType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaBufferSize )( 
            IRTPRPHFilter __RPC_FAR * This,
            /* [in] */ DWORD dwMaxMediaBufferSize);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaBufferSize )( 
            IRTPRPHFilter __RPC_FAR * This,
            /* [out] */ LPDWORD lpdwMaxMediaBufferSize);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputPinMediaType )( 
            IRTPRPHFilter __RPC_FAR * This,
            /* [in] */ AM_MEDIA_TYPE __RPC_FAR *lpMediaPinType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputPinMediaType )( 
            IRTPRPHFilter __RPC_FAR * This,
            /* [out] */ AM_MEDIA_TYPE __RPC_FAR *__RPC_FAR *ppMediaPinType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTimeoutDuration )( 
            IRTPRPHFilter __RPC_FAR * This,
            /* [in] */ DWORD dwDejitterTime,
            /* [in] */ DWORD dwLostPacketTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTimeoutDuration )( 
            IRTPRPHFilter __RPC_FAR * This,
            /* [out] */ LPDWORD lpdwDejitterTime,
            /* [out] */ LPDWORD lpdwLostPacketTime);
        
        END_INTERFACE
    } IRTPRPHFilterVtbl;

    interface IRTPRPHFilter
    {
        CONST_VTBL struct IRTPRPHFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTPRPHFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRTPRPHFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRTPRPHFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRTPRPHFilter_OverridePayloadType(This,bPayloadType)	\
    (This)->lpVtbl -> OverridePayloadType(This,bPayloadType)

#define IRTPRPHFilter_GetPayloadType(This,lpbPayloadType)	\
    (This)->lpVtbl -> GetPayloadType(This,lpbPayloadType)

#define IRTPRPHFilter_SetMediaBufferSize(This,dwMaxMediaBufferSize)	\
    (This)->lpVtbl -> SetMediaBufferSize(This,dwMaxMediaBufferSize)

#define IRTPRPHFilter_GetMediaBufferSize(This,lpdwMaxMediaBufferSize)	\
    (This)->lpVtbl -> GetMediaBufferSize(This,lpdwMaxMediaBufferSize)

#define IRTPRPHFilter_SetOutputPinMediaType(This,lpMediaPinType)	\
    (This)->lpVtbl -> SetOutputPinMediaType(This,lpMediaPinType)

#define IRTPRPHFilter_GetOutputPinMediaType(This,ppMediaPinType)	\
    (This)->lpVtbl -> GetOutputPinMediaType(This,ppMediaPinType)

#define IRTPRPHFilter_SetTimeoutDuration(This,dwDejitterTime,dwLostPacketTime)	\
    (This)->lpVtbl -> SetTimeoutDuration(This,dwDejitterTime,dwLostPacketTime)

#define IRTPRPHFilter_GetTimeoutDuration(This,lpdwDejitterTime,lpdwLostPacketTime)	\
    (This)->lpVtbl -> GetTimeoutDuration(This,lpdwDejitterTime,lpdwLostPacketTime)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IRTPRPHFilter_OverridePayloadType_Proxy( 
    IRTPRPHFilter __RPC_FAR * This,
    /* [in] */ BYTE bPayloadType);


void __RPC_STUB IRTPRPHFilter_OverridePayloadType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRTPRPHFilter_GetPayloadType_Proxy( 
    IRTPRPHFilter __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *lpbPayloadType);


void __RPC_STUB IRTPRPHFilter_GetPayloadType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRTPRPHFilter_SetMediaBufferSize_Proxy( 
    IRTPRPHFilter __RPC_FAR * This,
    /* [in] */ DWORD dwMaxMediaBufferSize);


void __RPC_STUB IRTPRPHFilter_SetMediaBufferSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRTPRPHFilter_GetMediaBufferSize_Proxy( 
    IRTPRPHFilter __RPC_FAR * This,
    /* [out] */ LPDWORD lpdwMaxMediaBufferSize);


void __RPC_STUB IRTPRPHFilter_GetMediaBufferSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRTPRPHFilter_SetOutputPinMediaType_Proxy( 
    IRTPRPHFilter __RPC_FAR * This,
    /* [in] */ AM_MEDIA_TYPE __RPC_FAR *lpMediaPinType);


void __RPC_STUB IRTPRPHFilter_SetOutputPinMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRTPRPHFilter_GetOutputPinMediaType_Proxy( 
    IRTPRPHFilter __RPC_FAR * This,
    /* [out] */ AM_MEDIA_TYPE __RPC_FAR *__RPC_FAR *ppMediaPinType);


void __RPC_STUB IRTPRPHFilter_GetOutputPinMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRTPRPHFilter_SetTimeoutDuration_Proxy( 
    IRTPRPHFilter __RPC_FAR * This,
    /* [in] */ DWORD dwDejitterTime,
    /* [in] */ DWORD dwLostPacketTime);


void __RPC_STUB IRTPRPHFilter_SetTimeoutDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRTPRPHFilter_GetTimeoutDuration_Proxy( 
    IRTPRPHFilter __RPC_FAR * This,
    /* [out] */ LPDWORD lpdwDejitterTime,
    /* [out] */ LPDWORD lpdwLostPacketTime);


void __RPC_STUB IRTPRPHFilter_GetTimeoutDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRTPRPHFilter_INTERFACE_DEFINED__ */


#ifndef __IRPHH26XSettings_INTERFACE_DEFINED__
#define __IRPHH26XSettings_INTERFACE_DEFINED__

/* interface IRPHH26XSettings */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IRPHH26XSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("835A6361-9547-11d0-9643-00AA00A89C1D")
    IRPHH26XSettings : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetCIF( 
            /* [in] */ BOOL bCIF) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetCIF( 
            /* [out] */ BOOL __RPC_FAR *lpbCIF) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRPHH26XSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRPHH26XSettings __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRPHH26XSettings __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRPHH26XSettings __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCIF )( 
            IRPHH26XSettings __RPC_FAR * This,
            /* [in] */ BOOL bCIF);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCIF )( 
            IRPHH26XSettings __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *lpbCIF);
        
        END_INTERFACE
    } IRPHH26XSettingsVtbl;

    interface IRPHH26XSettings
    {
        CONST_VTBL struct IRPHH26XSettingsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRPHH26XSettings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRPHH26XSettings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRPHH26XSettings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRPHH26XSettings_SetCIF(This,bCIF)	\
    (This)->lpVtbl -> SetCIF(This,bCIF)

#define IRPHH26XSettings_GetCIF(This,lpbCIF)	\
    (This)->lpVtbl -> GetCIF(This,lpbCIF)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IRPHH26XSettings_SetCIF_Proxy( 
    IRPHH26XSettings __RPC_FAR * This,
    /* [in] */ BOOL bCIF);


void __RPC_STUB IRPHH26XSettings_SetCIF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRPHH26XSettings_GetCIF_Proxy( 
    IRPHH26XSettings __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *lpbCIF);


void __RPC_STUB IRPHH26XSettings_GetCIF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRPHH26XSettings_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_irtprph_0349 */
/* [local] */ 

EXTERN_C const CLSID CLSID_INTEL_RPHH26X;
EXTERN_C const CLSID CLSID_INTEL_RPHAUD;
EXTERN_C const CLSID CLSID_INTEL_RPHGENA;
EXTERN_C const CLSID CLSID_INTEL_RPHAUD_PROPPAGE;
EXTERN_C const CLSID CLSID_INTEL_RPHGENA_PROPPAGE;
EXTERN_C const CLSID CLSID_INTEL_RPHH26X_PROPPAGE;
EXTERN_C const CLSID CLSID_INTEL_RPHH26X1_PROPPAGE;


extern RPC_IF_HANDLE __MIDL_itf_irtprph_0349_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_irtprph_0349_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\issperr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:      issperr.h
//
//  Contents:  Constant definitions for OLE HRESULT values.
//
//  History:   dd-mmm-yy Author    Comment
//
//--------------------------------------------------------------------------

#pragma message("WARNING: issperr.h is an obsolete header file")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\issper16.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:      issperr.h
//
//  Contents:  Constant definitions for OLE HRESULT values.
//
//  History:   dd-mmm-yy Author    Comment
//             20-Sep-93 richardw  genesis
//
//  Notes:
//     This is a generated file. Do not modify directly.
//     The MC tool generates this file from dsyserr.mc
//
//--------------------------------------------------------------------------
#ifndef _ISSPERR_H_
#define _ISSPERR_H_
#if _MSC_VER > 1000
#pragma once
#endif

// Define the status type.

#ifdef FACILITY_SECURITY
#undef FACILITY_SECURITY
#endif

#ifdef STATUS_SEVERITY_SUCCESS
#undef STATUS_SEVERITY_SUCCESS
#endif
//#ifdef STATUS_SEVERITY_ERROR
//#undef STATUS_SEVERITY_ERROR
//#endif

// Define the severities
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SECURITY                0x9
#define FACILITY_NULL                    0


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_COERROR          0x2


//
// MessageId: SEC_E_INSUFFICIENT_MEMORY
//
// MessageText:
//
//  Not enough memory is available to complete this request
//
#define SEC_E_INSUFFICIENT_MEMORY        ((SECURITY_STATUS)0x1300)

//
// MessageId: SEC_E_INVALID_HANDLE
//
// MessageText:
//
//  The handle specified is invalid
//
#define SEC_E_INVALID_HANDLE             ((SECURITY_STATUS)0x1301)

//
// MessageId: SEC_E_UNSUPPORTED_FUNCTION
//
// MessageText:
//
//  The function requested is not supported
//
#define SEC_E_UNSUPPORTED_FUNCTION       ((SECURITY_STATUS)0x1302)


//
// MessageId: SEC_E_TARGET_UNKNOWN
//
// MessageText:
//
//  The specified target is unknown or unreachable
//
#define SEC_E_TARGET_UNKNOWN             ((SECURITY_STATUS)0x1303)

//
// MessageId: SEC_E_INTERNAL_ERROR
//
// MessageText:
//
//  The Local Security Authority cannot be contacted
//
#define SEC_E_INTERNAL_ERROR             ((SECURITY_STATUS)0x1304)

//
// MessageId: SEC_E_SECPKG_NOT_FOUND
//
// MessageText:
//
//  The requested security package does not exist
//
#define SEC_E_SECPKG_NOT_FOUND           ((SECURITY_STATUS)0x1305)


//
// MessageId: SEC_E_NOT_OWNER
//
// MessageText:
//
//  The caller is not the owner of the desired credentials
//
#define SEC_E_NOT_OWNER                  ((SECURITY_STATUS)0x1306)

//
// MessageId: SEC_E_CANNOT_INSTALL
//
// MessageText:
//
//  The security package failed to initialize, and cannot be installed
//
#define SEC_E_CANNOT_INSTALL             ((SECURITY_STATUS)0x1307)

//
// MessageId: SEC_E_INVALID_TOKEN
//
// MessageText:
//
//  The token supplied to the function is invalid
//
#define SEC_E_INVALID_TOKEN              ((SECURITY_STATUS)0x1308)

//
// MessageId: SEC_E_CANNOT_PACK
//
// MessageText:
//
//  The security package is not able to marshall the logon buffer,
//  so the logon attempt has failed
//
#define SEC_E_CANNOT_PACK                ((SECURITY_STATUS)0x1309)

//
// MessageId: SEC_E_QOP_NOT_SUPPORTED
//
// MessageText:
//
//  The per-message Quality of Protection is not supported by the
//  security package
//
#define SEC_E_QOP_NOT_SUPPORTED          ((SECURITY_STATUS)0x130A)

//
// MessageId: SEC_E_NO_IMPERSONATION
//
// MessageText:
//
//  The security context does not allow impersonation of the client
//
#define SEC_E_NO_IMPERSONATION           ((SECURITY_STATUS)0x130B)

//
// MessageId: SEC_E_LOGON_DENIED
//
// MessageText:
//
//  The logon attempt failed
//
#define SEC_E_LOGON_DENIED               ((SECURITY_STATUS)0x130C)

//
// MessageId: SEC_E_UNKNOWN_CREDENTIALS
//
// MessageText:
//
//  The credentials supplied to the package were not
//  recognized
//
#define SEC_E_UNKNOWN_CREDENTIALS        ((SECURITY_STATUS)0x130D)

//
// MessageId: SEC_E_NO_CREDENTIALS
//
// MessageText:
//
//  No credentials are available in the security package
//
#define SEC_E_NO_CREDENTIALS             ((SECURITY_STATUS)0x130E)

//
// MessageId: SEC_E_MESSAGE_ALTERED
//
// MessageText:
//
//  The message supplied for verification has been altered
//
#define SEC_E_MESSAGE_ALTERED            ((SECURITY_STATUS)0x130F)

//
// MessageId: SEC_E_OUT_OF_SEQUENCE
//
// MessageText:
//
//  The message supplied for verification is out of sequence
//
#define SEC_E_OUT_OF_SEQUENCE            ((SECURITY_STATUS)0x1310)

//
// MessageId: SEC_E_NO_AUTHENTICATING_AUTHORITY
//
// MessageText:
//
//  No authority could be contacted for authentication.
//
#define SEC_E_NO_AUTHENTICATING_AUTHORITY ((SECURITY_STATUS)0x1311)

// MessageId: SEC_E_CONTEXT_EXPIRED
//
// MessageText:
//
//  The context has expired and can no longer be used.
//
#define SEC_E_CONTEXT_EXPIRED            ((SECURITY_STATUS)0x1312)

//
// MessageId: SEC_E_INCOMPLETE_MESSAGE
//
// MessageText:
//
//  The supplied message is incomplete.  The signature was not verified.
//
#define SEC_E_INCOMPLETE_MESSAGE         ((SECURITY_STATUS)0x1313)

//
// MessageId: SEC_I_CONTINUE_NEEDED
//
// MessageText:
//
//  The function completed successfully, but must be called
//  again to complete the context
//
#define SEC_I_CONTINUE_NEEDED            ((SECURITY_STATUS)0x1012)

//
// MessageId: SEC_I_COMPLETE_NEEDED
//
// MessageText:
//
//  The function completed successfully, but CompleteToken
//  must be called
//
#define SEC_I_COMPLETE_NEEDED            ((SECURITY_STATUS)0x1013)

//
// MessageId: SEC_I_COMPLETE_AND_CONTINUE
//
// MessageText:
//
//  The function completed successfully, but both CompleteToken
//  and this function must be called to complete the context
//
#define SEC_I_COMPLETE_AND_CONTINUE      ((SECURITY_STATUS)0x1014)

//
// MessageId: SEC_I_LOCAL_LOGON
//
// MessageText:
//
//  The logon was completed, but no network authority was
//  available.  The logon was made using locally known information
//
#define SEC_I_LOCAL_LOGON                ((SECURITY_STATUS)0x1015)

//
// MessageId: SEC_E_OK
//
// MessageText:
//
//  Call completed successfully
//
#define SEC_E_OK                         ((SECURITY_STATUS)0x0000)

//
// Older error names for backwards compatibility
//


#define SEC_E_NOT_SUPPORTED              SEC_E_UNSUPPORTED_FUNCTION
#define SEC_E_NO_SPM                     SEC_E_INTERNAL_ERROR
#define SEC_E_BAD_PKGID                  SEC_E_SECPKG_NOT_FOUND


#endif // _ISSPERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\istats.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Mon Sep 20 16:32:20 1999
 */
/* Compiler settings for istats.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __istats_h__
#define __istats_h__

/* Forward Declarations */ 

#ifndef __IStats_FWD_DEFINED__
#define __IStats_FWD_DEFINED__
typedef interface IStats IStats;
#endif 	/* __IStats_FWD_DEFINED__ */


/* header files for imported files */
#include "NPPTypes.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IStats_INTERFACE_DEFINED__
#define __IStats_INTERFACE_DEFINED__

/* interface IStats */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IStats;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("944AD530-B09D-11ce-B59C-00AA006CB37D")
    IStats : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ NETWORKSTATUS __RPC_FAR *pNetworkStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [out] */ BOOL __RPC_FAR *IsRunnning,
            /* [out] */ BOOL __RPC_FAR *IsPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalStatistics( 
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversationStatistics( 
            /* [out] */ DWORD __RPC_FAR *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD __RPC_FAR *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpecialFrame( 
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ LPBYTE pUserData,
            /* [in] */ DWORD UserDataLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStations( 
            /* [out][in] */ QUERYTABLE __RPC_FAR *lpQueryTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStats __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStats __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStats __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IStats __RPC_FAR * This,
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IStats __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryStatus )( 
            IStats __RPC_FAR * This,
            /* [out] */ NETWORKSTATUS __RPC_FAR *pNetworkStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IStats __RPC_FAR * This,
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IStats __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IStats __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IStats __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IStats __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetControlState )( 
            IStats __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *IsRunnning,
            /* [out] */ BOOL __RPC_FAR *IsPaused);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalStatistics )( 
            IStats __RPC_FAR * This,
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversationStatistics )( 
            IStats __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD __RPC_FAR *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertSpecialFrame )( 
            IStats __RPC_FAR * This,
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ LPBYTE pUserData,
            /* [in] */ DWORD UserDataLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryStations )( 
            IStats __RPC_FAR * This,
            /* [out][in] */ QUERYTABLE __RPC_FAR *lpQueryTable);
        
        END_INTERFACE
    } IStatsVtbl;

    interface IStats
    {
        CONST_VTBL struct IStatsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStats_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStats_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStats_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStats_Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob)	\
    (This)->lpVtbl -> Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob)

#define IStats_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IStats_QueryStatus(This,pNetworkStatus)	\
    (This)->lpVtbl -> QueryStatus(This,pNetworkStatus)

#define IStats_Configure(This,hConfigurationBlob,hErrorBlob)	\
    (This)->lpVtbl -> Configure(This,hConfigurationBlob,hErrorBlob)

#define IStats_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IStats_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IStats_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IStats_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IStats_GetControlState(This,IsRunnning,IsPaused)	\
    (This)->lpVtbl -> GetControlState(This,IsRunnning,IsPaused)

#define IStats_GetTotalStatistics(This,lpStats,fClearAfterReading)	\
    (This)->lpVtbl -> GetTotalStatistics(This,lpStats,fClearAfterReading)

#define IStats_GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)	\
    (This)->lpVtbl -> GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)

#define IStats_InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)	\
    (This)->lpVtbl -> InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)

#define IStats_QueryStations(This,lpQueryTable)	\
    (This)->lpVtbl -> QueryStations(This,lpQueryTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStats_Connect_Proxy( 
    IStats __RPC_FAR * This,
    /* [in] */ HBLOB hInputBlob,
    /* [in] */ LPVOID StatusCallbackProc,
    /* [in] */ LPVOID UserContext,
    /* [out] */ HBLOB hErrorBlob);


void __RPC_STUB IStats_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_Disconnect_Proxy( 
    IStats __RPC_FAR * This);


void __RPC_STUB IStats_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_QueryStatus_Proxy( 
    IStats __RPC_FAR * This,
    /* [out] */ NETWORKSTATUS __RPC_FAR *pNetworkStatus);


void __RPC_STUB IStats_QueryStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_Configure_Proxy( 
    IStats __RPC_FAR * This,
    /* [in] */ HBLOB hConfigurationBlob,
    /* [out] */ HBLOB hErrorBlob);


void __RPC_STUB IStats_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_Start_Proxy( 
    IStats __RPC_FAR * This);


void __RPC_STUB IStats_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_Pause_Proxy( 
    IStats __RPC_FAR * This);


void __RPC_STUB IStats_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_Resume_Proxy( 
    IStats __RPC_FAR * This);


void __RPC_STUB IStats_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_Stop_Proxy( 
    IStats __RPC_FAR * This);


void __RPC_STUB IStats_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_GetControlState_Proxy( 
    IStats __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *IsRunnning,
    /* [out] */ BOOL __RPC_FAR *IsPaused);


void __RPC_STUB IStats_GetControlState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_GetTotalStatistics_Proxy( 
    IStats __RPC_FAR * This,
    /* [out] */ LPSTATISTICS lpStats,
    /* [in] */ BOOL fClearAfterReading);


void __RPC_STUB IStats_GetTotalStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_GetConversationStatistics_Proxy( 
    IStats __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *nSessions,
    /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
    /* [out] */ DWORD __RPC_FAR *nStations,
    /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
    /* [in] */ BOOL fClearAfterReading);


void __RPC_STUB IStats_GetConversationStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_InsertSpecialFrame_Proxy( 
    IStats __RPC_FAR * This,
    /* [in] */ DWORD FrameType,
    /* [in] */ DWORD Flags,
    /* [in] */ LPBYTE pUserData,
    /* [in] */ DWORD UserDataLength);


void __RPC_STUB IStats_InsertSpecialFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStats_QueryStations_Proxy( 
    IStats __RPC_FAR * This,
    /* [out][in] */ QUERYTABLE __RPC_FAR *lpQueryTable);


void __RPC_STUB IStats_QueryStations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStats_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\kerberos.h ===
//+-----------------------------------------------------------------------
//
// File:        KERBEROS.H
//
// Contents:    Public Kerberos Security Package structures for use
//              with APIs from SECURITY.H
//
//
// History:     26 Feb 92,  RichardW    Compiled from other files
//
//------------------------------------------------------------------------

#ifndef __KERBEROS_H__
#define __KERBEROS_H__
#include <ntmsv1_0.h>
#include <kerbcon.h>

#define MICROSOFT_KERBEROS_NAME_A   "Kerberos"
#define MICROSOFT_KERBEROS_NAME_W   L"Kerberos"
#ifdef WIN32_CHICAGO
#define MICROSOFT_KERBEROS_NAME MICROSOFT_KERBEROS_NAME_A
#else
#define MICROSOFT_KERBEROS_NAME MICROSOFT_KERBEROS_NAME_W
#endif


typedef struct _KERB_INIT_CONTEXT_DATA {
    TimeStamp StartTime;            // Start time
    TimeStamp EndTime;              // End time
    TimeStamp RenewUntilTime;       // Renew until time
    ULONG TicketOptions;            // From krb5.h
    ULONG RequestOptions;           // Options on what to return
} KERB_INIT_CONTEXT_DATA, *PKERB_INIT_CONTEXT_DATA;

#define KERB_INIT_RETURN_TICKET             0x1     // return raw ticket
#define KERB_INIT_RETURN_MIT_AP_REQ         0x2     // return MIT style AP request




typedef enum _KERB_LOGON_SUBMIT_TYPE {
    KerbInteractiveLogon = 2
} KERB_LOGON_SUBMIT_TYPE, *PKERB_LOGON_SUBMIT_TYPE;


typedef struct _KERB_INTERACTIVE_LOGON {
    KERB_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;
    UNICODE_STRING SubAuthData;
    ULONG Flags;
} KERB_INTERACTIVE_LOGON, *PKERB_INTERACTIVE_LOGON;


#define KERB_LOGON_SUBUATH               0x1
#define KERB_LOGON_EMAIL_NAMES           0x2
#define KERB_LOGON_UPDATE_STATISTICS     0x4

//
// Use the same profile structure as MSV1_0
//

typedef MSV1_0_INTERACTIVE_PROFILE KERB_INTERACTIVE_PROFILE, *PKERB_INTERACTIVE_PROFILE;



typedef enum _KERB_PROTOCOL_MESSAGE_TYPE {
    KerbDebugRequestMessage = 0,
    KerbQueryTicketCacheMessage,
    KerbChangeMachinePasswordMessage,
    KerbVerifyPacMessage,
    KerbRetrieveTicketMessage
} KERB_PROTOCOL_MESSAGE_TYPE, *PKERB_PROTOCOL_MESSAGE_TYPE;

//
// Structure for a debuggin requequest
//

#define KERB_DEBUG_REQ_BREAKPOINT       0x1
#define KERB_DEBUG_REQ_CALL_PACK        0x2
#define KERB_DEBUG_REQ_DATAGRAM         0x3

typedef struct _KERB_DEBUG_REQUEST {
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG DebugRequest;
} KERB_DEBUG_REQUEST, *PKERB_DEBUG_REQUEST;

//
// Used both for retrieving tickets and for querying ticket cache
//

typedef struct _KERB_QUERY_TKT_CACHE_REQUEST {
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID LogonId;
} KERB_QUERY_TKT_CACHE_REQUEST, *PKERB_QUERY_TKT_CACHE_REQUEST;

typedef struct _KERB_TICKET_CACHE_INFO {
    UNICODE_STRING ServerName;
    TimeStamp EndTime;
    TimeStamp RenewTime;
} KERB_TICKET_CACHE_INFO, *PKERB_TICKET_CACHE_INFO;

typedef struct _KERB_QUERY_TKT_CACHE_RESPONSE {
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG CountOfTickets;
    KERB_TICKET_CACHE_INFO Tickets[ANYSIZE_ARRAY];
} KERB_QUERY_TKT_CACHE_RESPONSE, *PKERB_QUERY_TKT_CACHE_RESPONSE;



//
// This must match NT_OWF_PASSWORD_LENGTH
//

#define KERB_MACH_PWD_LENGTH 16

typedef struct _KERB_CHANGE_MACH_PWD_REQUEST {
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    UCHAR NewPassword[KERB_MACH_PWD_LENGTH];
} KERB_CHANGE_MACH_PWD_REQUEST, *PKERB_CHANGE_MACH_PWD_REQUEST;

//
// These messages are used by the kerberos package to verify that the PAC in a
// ticket is valid. It is remoted from a workstation to a DC in the workstation's
// domain. On failure there is no response message. On success there may be no
// message or the same message may be used to send back a PAC updated with
// local groups from the domain controller. The checksum is placed in the
// final buffer first, followed by the signature.
//

#include <pshpack1.h>
typedef struct _KERB_VERIFY_PAC_REQUEST {
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG ChecksumLength;
    ULONG SignatureType;
    ULONG SignatureLength;
    UCHAR ChecksumAndSignature[ANYSIZE_ARRAY];
} KERB_VERIFY_PAC_REQUEST, *PKERB_VERIFY_PAC_REQUEST;
#include <poppack.h>


#endif  // __KERBEROS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\key.c ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 1999  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and distribute
// the Sample Application Files (including modified versions) in any way 
// you determine to be useful, provided that you agree that Microsoft 
// Corporation provides no warrant or support, and has no obligation or
// liability resulting from the use of any Sample Application Files. 
//

//
// Note: This certificate is only meant to allow the project to compile.
// To interact with the WMDM, you need to obtain a valid certificate from Microsoft.
//

#include <wtypes.h>

BYTE abPVK[] = {
        0x00
};
BYTE abCert[] = {
        0x00
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\iwamreg.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for wamreg.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iwamreg_h__
#define __iwamreg_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWamAdmin_FWD_DEFINED__
#define __IWamAdmin_FWD_DEFINED__
typedef interface IWamAdmin IWamAdmin;
#endif 	/* __IWamAdmin_FWD_DEFINED__ */


#ifndef __IWamAdmin2_FWD_DEFINED__
#define __IWamAdmin2_FWD_DEFINED__
typedef interface IWamAdmin2 IWamAdmin2;
#endif 	/* __IWamAdmin2_FWD_DEFINED__ */


#ifndef __WamAdmin_FWD_DEFINED__
#define __WamAdmin_FWD_DEFINED__

#ifdef __cplusplus
typedef class WamAdmin WamAdmin;
#else
typedef struct WamAdmin WamAdmin;
#endif /* __cplusplus */

#endif 	/* __WamAdmin_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wamreg_0000 */
/* [local] */ 

/*++
                                                                                
Copyright (c) 1997-1999 Microsoft Corporation
                                                                                
Module Name: iwamreg.h
                                                                                
    WAM (Web Application Manager) Interfaces
                                                                                
--*/
#ifndef __WAMREG_IADM__IID
#define __WAMREG_IADM__IID
DEFINE_GUID(IID_IWamAdmin, 0x29822AB7, 0xF302, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1);
DEFINE_GUID(IID_IWamAdmin2, 0x29822AB8, 0xF302, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1);
DEFINE_GUID(LIBID_WAMREGLib, 0x29822AA8, 0xF302, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1);
DEFINE_GUID(CLSID_WamAdmin, 0x61738644, 0xF196, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1);
#endif //__WAMREG_IADM__IID
#define APPSTATUS_STOPPED	0
#define APPSTATUS_RUNNING	1
#define APPSTATUS_NOTDEFINED	2
typedef /* [public] */ 
enum __MIDL___MIDL_itf_wamreg_0000_0001
    {	eAppRunInProc	= 0,
	eAppRunOutProcIsolated	= eAppRunInProc + 1,
	eAppRunOutProcInDefaultPool	= eAppRunOutProcIsolated + 1
    } 	EAppMode;



extern RPC_IF_HANDLE __MIDL_itf_wamreg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wamreg_0000_v0_0_s_ifspec;

#ifndef __IWamAdmin_INTERFACE_DEFINED__
#define __IWamAdmin_INTERFACE_DEFINED__

/* interface IWamAdmin */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IWamAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("29822AB7-F302-11D0-9953-00C04FD919C1")
    IWamAdmin : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppCreate( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fInProc) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppDelete( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppUnLoad( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppGetStatus( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [out] */ DWORD *pdwAppStatus) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppDeleteRecoverable( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppRecover( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWamAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWamAdmin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWamAdmin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWamAdmin * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppCreate )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fInProc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppDelete )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppUnLoad )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppGetStatus )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [out] */ DWORD *pdwAppStatus);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppDeleteRecoverable )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppRecover )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        END_INTERFACE
    } IWamAdminVtbl;

    interface IWamAdmin
    {
        CONST_VTBL struct IWamAdminVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWamAdmin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWamAdmin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWamAdmin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWamAdmin_AppCreate(This,szMDPath,fInProc)	\
    (This)->lpVtbl -> AppCreate(This,szMDPath,fInProc)

#define IWamAdmin_AppDelete(This,szMDPath,fRecursive)	\
    (This)->lpVtbl -> AppDelete(This,szMDPath,fRecursive)

#define IWamAdmin_AppUnLoad(This,szMDPath,fRecursive)	\
    (This)->lpVtbl -> AppUnLoad(This,szMDPath,fRecursive)

#define IWamAdmin_AppGetStatus(This,szMDPath,pdwAppStatus)	\
    (This)->lpVtbl -> AppGetStatus(This,szMDPath,pdwAppStatus)

#define IWamAdmin_AppDeleteRecoverable(This,szMDPath,fRecursive)	\
    (This)->lpVtbl -> AppDeleteRecoverable(This,szMDPath,fRecursive)

#define IWamAdmin_AppRecover(This,szMDPath,fRecursive)	\
    (This)->lpVtbl -> AppRecover(This,szMDPath,fRecursive)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWamAdmin_AppCreate_Proxy( 
    IWamAdmin * This,
    /* [string][unique][in] */ LPCWSTR szMDPath,
    /* [in] */ BOOL fInProc);


void __RPC_STUB IWamAdmin_AppCreate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWamAdmin_AppDelete_Proxy( 
    IWamAdmin * This,
    /* [string][unique][in] */ LPCWSTR szMDPath,
    /* [in] */ BOOL fRecursive);


void __RPC_STUB IWamAdmin_AppDelete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWamAdmin_AppUnLoad_Proxy( 
    IWamAdmin * This,
    /* [string][unique][in] */ LPCWSTR szMDPath,
    /* [in] */ BOOL fRecursive);


void __RPC_STUB IWamAdmin_AppUnLoad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWamAdmin_AppGetStatus_Proxy( 
    IWamAdmin * This,
    /* [string][unique][in] */ LPCWSTR szMDPath,
    /* [out] */ DWORD *pdwAppStatus);


void __RPC_STUB IWamAdmin_AppGetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWamAdmin_AppDeleteRecoverable_Proxy( 
    IWamAdmin * This,
    /* [string][unique][in] */ LPCWSTR szMDPath,
    /* [in] */ BOOL fRecursive);


void __RPC_STUB IWamAdmin_AppDeleteRecoverable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWamAdmin_AppRecover_Proxy( 
    IWamAdmin * This,
    /* [string][unique][in] */ LPCWSTR szMDPath,
    /* [in] */ BOOL fRecursive);


void __RPC_STUB IWamAdmin_AppRecover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWamAdmin_INTERFACE_DEFINED__ */


#ifndef __IWamAdmin2_INTERFACE_DEFINED__
#define __IWamAdmin2_INTERFACE_DEFINED__

/* interface IWamAdmin2 */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IWamAdmin2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("29822AB8-F302-11D0-9953-00C04FD919C1")
    IWamAdmin2 : public IWamAdmin
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppCreate2( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ DWORD dwAppMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWamAdmin2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWamAdmin2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWamAdmin2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWamAdmin2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppCreate )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fInProc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppDelete )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppUnLoad )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppGetStatus )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [out] */ DWORD *pdwAppStatus);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppDeleteRecoverable )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppRecover )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppCreate2 )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ DWORD dwAppMode);
        
        END_INTERFACE
    } IWamAdmin2Vtbl;

    interface IWamAdmin2
    {
        CONST_VTBL struct IWamAdmin2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWamAdmin2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWamAdmin2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWamAdmin2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWamAdmin2_AppCreate(This,szMDPath,fInProc)	\
    (This)->lpVtbl -> AppCreate(This,szMDPath,fInProc)

#define IWamAdmin2_AppDelete(This,szMDPath,fRecursive)	\
    (This)->lpVtbl -> AppDelete(This,szMDPath,fRecursive)

#define IWamAdmin2_AppUnLoad(This,szMDPath,fRecursive)	\
    (This)->lpVtbl -> AppUnLoad(This,szMDPath,fRecursive)

#define IWamAdmin2_AppGetStatus(This,szMDPath,pdwAppStatus)	\
    (This)->lpVtbl -> AppGetStatus(This,szMDPath,pdwAppStatus)

#define IWamAdmin2_AppDeleteRecoverable(This,szMDPath,fRecursive)	\
    (This)->lpVtbl -> AppDeleteRecoverable(This,szMDPath,fRecursive)

#define IWamAdmin2_AppRecover(This,szMDPath,fRecursive)	\
    (This)->lpVtbl -> AppRecover(This,szMDPath,fRecursive)


#define IWamAdmin2_AppCreate2(This,szMDPath,dwAppMode)	\
    (This)->lpVtbl -> AppCreate2(This,szMDPath,dwAppMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWamAdmin2_AppCreate2_Proxy( 
    IWamAdmin2 * This,
    /* [string][unique][in] */ LPCWSTR szMDPath,
    /* [in] */ DWORD dwAppMode);


void __RPC_STUB IWamAdmin2_AppCreate2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWamAdmin2_INTERFACE_DEFINED__ */



#ifndef __WAMREGLib_LIBRARY_DEFINED__
#define __WAMREGLib_LIBRARY_DEFINED__

/* library WAMREGLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WAMREGLib;

EXTERN_C const CLSID CLSID_WamAdmin;

#ifdef __cplusplus

class DECLSPEC_UUID("61738644-F196-11D0-9953-00C04FD919C1")
WamAdmin;
#endif
#endif /* __WAMREGLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ivec.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
*** @(#)ivec.h	1.6 02/11/99 11:11:59
**/
/*
 *  Definition of a C++ class interface to MMX(TM) instruction intrinsics.
 *
 */

#ifndef IVEC_H_INCLUDED
#define IVEC_H_INCLUDED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#include <mmintrin.h>
#include <assert.h>
#include <iostream.h>

/* If using MSVC5.0, explicit keyword should be used */
#if (_MSC_VER >= 1100)
        #define EXPLICIT explicit
#else
   #if (__ICL)
        #define EXPLICIT __explicit /* If MSVC4.x & ICL, use __explicit */
   #else
        #define EXPLICIT /* nothing */
        #pragma message( "explicit keyword not recognized") 
   #endif
#endif

class I8vec8;			/* 8 elements, each element a signed or unsigned char data type */
class Is8vec8;			/* 8 elements, each element a signed char data type */
class Iu8vec8;			/* 8 elements, each element an unsigned char data type */	
class I16vec4;			/* 4 elements, each element a signed or unsigned short */
class Is16vec4;			/* 4 elements, each element a signed short */
class Iu16vec4;			/* 4 elements, each element an unsigned short */
class I32vec2;			/* 2 elements, each element a signed or unsigned long */
class Is32vec2;			/* 2 elements, each element a signed long */
class Iu32vec2;			/* 2 elements, each element a unsigned long */
class I64vec1;			/* 1 element, a __m64 data type - Base I64vec1 class  */

#define _MM_8UB(element,vector) (*((unsigned char*)&##vector + ##element))
#define _MM_8B(element,vector) (*((signed char*)&##vector + ##element))

#define _MM_4UW(element,vector) (*((unsigned short*)&##vector + ##element))
#define _MM_4W(element,vector) (*((short*)&##vector + ##element))

#define _MM_2UDW(element,vector) (*((unsigned int*)&##vector + ##element))
#define _MM_2DW(element,vector) (*((int*)&##vector + ##element))

#define _MM_QW (*((__int64*)&vec))

/* M64 Class:
 * 1 element, a __m64 data type  
 * Contructors & Logical Operations 
 */
class M64  
{
protected:
		__m64 vec;

public:
	M64()									{ } 
	M64(__m64 mm)							{ vec = mm; }
	M64(__int64 mm)							{ _MM_QW = mm; }
	M64(int i)								{ vec = _m_from_int(i); }

	operator __m64() const					{ return vec; }

	/* Logical Operations */
	M64& operator&=(const M64 &a)					{ return *this = (M64) _m_pand(vec,a); }
	M64& operator|=(const M64 &a)					{ return *this = (M64) _m_por(vec,a); }
	M64& operator^=(const M64 &a)					{ return *this = (M64) _m_pxor(vec,a); }

};

inline M64 operator&(const M64 &a, const M64 &b)	{ return _m_pand( a,b); }
inline M64 operator|(const M64 &a, const M64 &b)	{ return _m_por(a,b); }
inline M64 operator^(const M64 &a, const M64 &b)	{ return _m_pxor(a,b); }
inline M64 andnot(const M64 &a, const M64 &b)		{ return _m_pandn(a,b); }

/* I64vec1 Class:
 * 1 element, a __m64 data type  
 * Contains Operations which can operate on any __m64 data type
 */

class I64vec1 : public M64  
{
public:
	I64vec1()								{ }
	I64vec1(__m64 mm) : M64(mm)				{ }
	EXPLICIT I64vec1(int i) : M64(i)		{ } 
	EXPLICIT I64vec1(__int64 mm) : M64(mm)	{ } 

	I64vec1& operator= (const M64 &a) { return *this = (I64vec1) a; }
	I64vec1& operator&=(const M64 &a) { return *this = (I64vec1) _m_pand(vec,a); }
	I64vec1& operator|=(const M64 &a) { return *this = (I64vec1) _m_por(vec,a); }
	I64vec1& operator^=(const M64 &a) { return *this = (I64vec1) _m_pxor(vec,a); }

	/* Shift Logical Operations */
	I64vec1 operator<<(const M64 &a)				{ return _m_psllq(vec, a); }
	I64vec1 operator<<(int count) 				    { return _m_psllqi(vec, count); }
	I64vec1& operator<<=(const M64 &a)				{ return *this = (I64vec1) _m_psllq(vec, a); }
	I64vec1& operator<<=(int count) 				{ return *this = (I64vec1) _m_psllqi(vec, count); }
	I64vec1 operator>>(const M64 &a)				{ return _m_psrlq(vec, a); }
	I64vec1 operator>>(int count) 					{ return _m_psrlqi(vec, count); }
	I64vec1& operator>>=(const M64 &a)				{ return *this = (I64vec1) _m_psrlq(vec, a); }
	I64vec1& operator>>=(int count) 				{ return *this = (I64vec1) _m_psrlqi(vec, count); }
};

/* I32vec2 Class: 
 * 2 elements, each element either a signed or unsigned int 
 */
class I32vec2 : public M64  
{
public:
	I32vec2() { }
	I32vec2(__m64 mm) : M64(mm) { }
	EXPLICIT I32vec2(int i) : M64 (i) { }  
	EXPLICIT I32vec2(__int64 i): M64(i) {} 

	/* Assignment Operator */
	I32vec2& operator= (const M64 &a) { return *this = (I32vec2) a; }

	/* Logical Assignment Operators */
	I32vec2& operator&=(const M64 &a) { return *this = (I32vec2) _m_pand(vec,a); }
	I32vec2& operator|=(const M64 &a) { return *this = (I32vec2) _m_por(vec,a); }
	I32vec2& operator^=(const M64 &a) { return *this = (I32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I32vec2& operator +=(const I32vec2 &a)			{ return *this = (I32vec2) _m_paddd(vec,a); }
	I32vec2& operator -=(const I32vec2 &a)			{ return *this = (I32vec2) _m_psubd(vec,a); }   

	/* Shift Logical Operators */
	I32vec2 operator<<(const I32vec2 &a) 			{ return _m_pslld(vec,a); }
	I32vec2 operator<<(int count) 				    { return _m_pslldi(vec,count); }
	I32vec2& operator<<=(const I32vec2 &a)			{ return *this = (I32vec2) _m_pslld(vec,a); }
	I32vec2& operator<<=(int count) 				{ return *this = (I32vec2) _m_pslldi(vec,count); }

};

/* Compare For Equality */
inline I32vec2 cmpeq(const I32vec2 &a, const I32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline I32vec2 cmpneq(const I32vec2 &a, const I32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline I32vec2 unpack_low(const I32vec2 &a, const I32vec2 &b) 	{return _m_punpckldq(a,b); }
inline I32vec2 unpack_high(const I32vec2 &a, const I32vec2 &b) 	{return _m_punpckhdq(a,b); }

/* Is32vec2 Class: 
 * 2 elements, each element a signed int 
 */
class Is32vec2 : public I32vec2  
{
public:
	Is32vec2() { }
	Is32vec2(__m64 mm) : I32vec2(mm) { }
	Is32vec2(signed int i0, signed int i1)
	{ 
		_MM_2DW(0,vec) = i1;
		_MM_2DW(1,vec) = i0;
	}
	EXPLICIT Is32vec2(int i) : I32vec2 (i)		{} 
	EXPLICIT Is32vec2(__int64 i): I32vec2(i)	{} 

	/* Assignment Operator */
	Is32vec2& operator= (const M64 &a)		{ return *this = (Is32vec2) a; }

	/* Logical Assignment Operators */
	Is32vec2& operator&=(const M64 &a)		{ return *this = (Is32vec2) _m_pand(vec,a); }
	Is32vec2& operator|=(const M64 &a)		{ return *this = (Is32vec2) _m_por(vec,a); }
	Is32vec2& operator^=(const M64 &a)		{ return *this = (Is32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is32vec2& operator +=(const I32vec2 &a)	{ return *this = (Is32vec2) _m_paddd(vec,a); }
	Is32vec2& operator -=(const I32vec2 &a)	{ return *this = (Is32vec2) _m_psubd(vec,a); }   

	/* Shift Logical Operators */
	Is32vec2 operator<<(const M64 &a) 		{ return _m_pslld(vec,a); }
	Is32vec2 operator<<(int count) 			{ return _m_pslldi(vec,count); }
	Is32vec2& operator<<=(const M64 &a)		{ return *this = (Is32vec2) _m_pslld(vec,a); }
	Is32vec2& operator<<=(int count) 		{ return *this = (Is32vec2) _m_pslldi(vec,count); }
	/* Shift Arithmetic Operations */
	Is32vec2 operator>>(const M64 &a) 		{ return _m_psrad(vec, a); }
	Is32vec2 operator>>(int count) 	  		{ return _m_psradi(vec, count); }
	Is32vec2& operator>>=(const M64 &a)		{ return *this = (Is32vec2) _m_psrad(vec, a); }
	Is32vec2& operator>>=(int count) 		{ return *this = (Is32vec2) _m_psradi(vec, count); }

	/* Output for Debug */
	friend ostream& operator<< (ostream &os, const Is32vec2 &a)
	{
		os << " [1]:" << _MM_2DW(1,a) 
		<< " [0]:" << _MM_2DW(0,a);
		return os;
	}

	/* Element Access for Debug, No data modified */
	const int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2DW(i,vec);
	} 

	/* Element Access and Assignment for Debug */
	int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2DW(i,vec);
	} 
};

/* Compares */
inline Is32vec2 cmpeq(const Is32vec2 &a, const Is32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline Is32vec2 cmpneq(const Is32vec2 &a, const Is32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
inline Is32vec2 cmpgt(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pcmpgtd(a,b); }
inline Is32vec2 cmplt(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pcmpgtd(b,a); }
inline Is32vec2 cmple(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pandn(_m_pcmpgtd(a,b), M64(0xffffffffffffffffi64)); }
inline Is32vec2 cmpge(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pandn(_m_pcmpgtd(b,a), M64(0xffffffffffffffffi64)); }
/* Unpacks & Pack */
inline Is32vec2 unpack_low(const Is32vec2 &a, const Is32vec2 &b) 	{ return _m_punpckldq(a,b); }
inline Is32vec2 unpack_high(const Is32vec2 &a, const Is32vec2 &b) 	{ return _m_punpckhdq(a,b); }

/* Iu32vec2 Class: 
 * 2 elements, each element unsigned int 
 */
class Iu32vec2 : public I32vec2  
{
public:
	Iu32vec2() { }
	Iu32vec2(__m64 mm) : I32vec2(mm) { }
	Iu32vec2(unsigned int ui0, unsigned int ui1) 
	{ 
		_MM_2UDW(0,vec) = ui1;
		_MM_2UDW(1,vec) = ui0;
	}

	EXPLICIT Iu32vec2(int i) : I32vec2 (i)		{ } 
	EXPLICIT Iu32vec2(__int64 i) : I32vec2 (i)	{ } 

	/* Assignment Operator */
	Iu32vec2& operator= (const M64 &a)		{ return *this = (Iu32vec2) a; }

	/* Logical Assignment Operators */
	Iu32vec2& operator&=(const M64 &a)		{ return *this = (Iu32vec2) _m_pand(vec,a); }
	Iu32vec2& operator|=(const M64 &a)		{ return *this = (Iu32vec2) _m_por(vec,a); }
	Iu32vec2& operator^=(const M64 &a)		{ return *this = (Iu32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu32vec2& operator +=(const I32vec2 &a)	{ return *this = (Iu32vec2) _m_paddd(vec,a); }
	Iu32vec2& operator -=(const I32vec2 &a)	{ return *this = (Iu32vec2) _m_psubd(vec,a); }   

	/* Shift Logical Operators */
	Iu32vec2 operator<<(const M64 &a) 		{ return _m_pslld(vec,a); }
	Iu32vec2 operator<<(int count) 			{ return _m_pslldi(vec,count); }
	Iu32vec2& operator<<=(const M64 &a)		{ return *this = (Iu32vec2) _m_pslld(vec,a); }
	Iu32vec2& operator<<=(int count) 		{ return *this = (Iu32vec2) _m_pslldi(vec,count); }
	Iu32vec2 operator>>(const M64 &a) 		{ return _m_psrld(vec,a); }
	Iu32vec2 operator>>(int count) 			{ return _m_psrldi(vec,count); }
	Iu32vec2& operator>>=(const M64 &a)		{ return *this = (Iu32vec2) _m_psrld(vec,a); }
	Iu32vec2& operator>>=(int count) 		{ return *this = (Iu32vec2) _m_psrldi(vec,count); }

	/* Output for Debug */
	friend ostream& operator<< (ostream &os, const Iu32vec2 &a)
	{
		os << " [1]:" << _MM_2UDW(1,a) 
		<< " [0]:" << _MM_2UDW(0,a);
		return os;
	}

	/* Element Access for Debug, No data modified */
	const unsigned int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2UDW(i,vec);
	} 

	/* Element Access and Assignment for Debug */
	unsigned int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2UDW(i,vec);
	}
};

/* Compares For Equality / Inequality */
inline Iu32vec2 cmpeq(const Iu32vec2 &a, const Iu32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline Iu32vec2 cmpneq(const Iu32vec2 &a, const Iu32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline Iu32vec2 unpack_low(const Iu32vec2 &a, const Iu32vec2 &b) 	{return _m_punpckldq(a,b); }
inline Iu32vec2 unpack_high(const Iu32vec2 &a, const Iu32vec2 &b) 	{return _m_punpckhdq(a,b); }

/* I16vec4 Class: 
 * 4 elements, each element either a signed or unsigned short 
 */
class I16vec4 : public M64  
{
public:
	I16vec4() { }
	I16vec4(__m64 mm) : M64(mm) { }
	EXPLICIT I16vec4(__int64 i) : M64 (i) { }	
	EXPLICIT I16vec4(int i) : M64 (i) { }		

	/* Assignment Operator */
	I16vec4& operator= (const M64 &a)				{ return *this = (I16vec4) a; }

	/* Addition & Subtraction Assignment Operators */
	I16vec4& operator&=(const M64 &a)				{ return *this = (I16vec4) _m_pand(vec,a); }
	I16vec4& operator|=(const M64 &a)				{ return *this = (I16vec4) _m_por(vec,a); }
	I16vec4& operator^=(const M64 &a)				{ return *this = (I16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I16vec4& operator +=(const I16vec4 &a)			{ return *this = (I16vec4)_m_paddw(vec,a); }
	I16vec4& operator -=(const I16vec4 &a)			{ return *this = (I16vec4)_m_psubw(vec,a); }   
	I16vec4& operator *=(const I16vec4 &a)			{ return *this = (I16vec4)_m_pmullw(vec,a); }   

	/* Shift Logical Operators */
	I16vec4 operator<<(const I16vec4 &a) 			{ return _m_psllw(vec,a); }
	I16vec4 operator<<(int count) 				    { return _m_psllwi(vec,count); }
	I16vec4& operator<<=(const I16vec4 &a)			{ return *this = (I16vec4)_m_psllw(vec,a); }
	I16vec4& operator<<=(int count) 				{ return *this = (I16vec4)_m_psllwi(vec,count); }
};

inline I16vec4 operator*(const I16vec4 &a, const I16vec4 &b) 	{ return _m_pmullw(a,b); }
inline I16vec4 cmpeq(const I16vec4 &a, const I16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline I16vec4 cmpneq(const I16vec4 &a, const I16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }

inline I16vec4 unpack_low(const I16vec4 &a, const I16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline I16vec4 unpack_high(const I16vec4 &a, const I16vec4 &b) 	{ return _m_punpckhwd(a,b); }

/* Is16vec4 Class: 
 * 4 elements, each element signed short 
 */
class Is16vec4 : public I16vec4  
{
public:
	Is16vec4() { }
	Is16vec4(__m64 mm) : I16vec4(mm) { }
	Is16vec4(short i0, short i1, short i2, short i3)
	{ 
		_MM_4W(0,vec) = i3;
		_MM_4W(1,vec) = i2;
		_MM_4W(2,vec) = i1;
		_MM_4W(3,vec) = i0;
	}	

	EXPLICIT Is16vec4(__int64 i) : I16vec4 (i)	{ }	
	EXPLICIT Is16vec4(int i) : I16vec4 (i)		{ }		

	/* Assignment Operator */
	Is16vec4& operator= (const M64 &a)		{ return *this = (Is16vec4) a; }

	/* Addition & Subtraction Assignment Operators */
	Is16vec4& operator&=(const M64 &a)		{ return *this = (Is16vec4) _m_pand(vec,a); }
	Is16vec4& operator|=(const M64 &a)		{ return *this = (Is16vec4) _m_por(vec,a); }
	Is16vec4& operator^=(const M64 &a)		{ return *this = (Is16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is16vec4& operator +=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_paddw(vec,a); }
	Is16vec4& operator -=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_psubw(vec,a); }   
	Is16vec4& operator *=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_pmullw(vec,a); }   

	/* Shift Logical Operators */
	Is16vec4 operator<<(const M64 &a) 		{ return _m_psllw(vec,a); }
	Is16vec4 operator<<(int count) 			{ return _m_psllwi(vec,count); }
	Is16vec4& operator<<=(const M64 &a)		{ return *this = (Is16vec4)_m_psllw(vec,a); }
	Is16vec4& operator<<=(int count) 		{ return *this = (Is16vec4)_m_psllwi(vec,count); }
	/* Shift Arithmetic Operations */
	Is16vec4 operator>>(const M64 &a) 		{ return _m_psraw(vec,a); } 
	Is16vec4 operator>>(int count) 			{ return _m_psrawi(vec,count); }
	Is16vec4& operator>>=(const M64 &a)		{ return *this = (Is16vec4) _m_psraw(vec,a); } 
	Is16vec4& operator>>=(int count) 		{ return *this = (Is16vec4) _m_psrawi(vec,count); }

	/* Output for Debug */
	friend ostream& operator<< (ostream &os, const Is16vec4 &a)
	{
		os << "[3]:" << _MM_4W(3,a) 
			<< " [2]:" << _MM_4W(2,a) 
			<< " [1]:" << _MM_4W(1,a) 
			<< " [0]:" << _MM_4W(0,a);
		return os;
	}

	/* Element Access for Debug, No data modified */
	const short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4W(i,vec);
	} 

	/* Element Access for Debug */
	short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4W(i,vec);
	} 
};

inline Is16vec4 operator*(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_pmullw(a,b); }

/* Compares */
inline Is16vec4 cmpeq(const Is16vec4 &a, const Is16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline Is16vec4 cmpneq(const Is16vec4 &a, const Is16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }
inline Is16vec4 cmpgt(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pcmpgtw(a,b); }
inline Is16vec4 cmplt(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pcmpgtw(b,a); }
inline Is16vec4 cmple(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pandn(_m_pcmpgtw(a,b), M64(0xffffffffffffffffi64)); }
inline Is16vec4 cmpge(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pandn(_m_pcmpgtw(b,a), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline Is16vec4 unpack_low(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline Is16vec4 unpack_high(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_punpckhwd(a,b); }

inline Is16vec4 sat_add(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_paddsw(a,b); }
inline Is16vec4 sat_sub(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_psubsw(a,b); }
inline Is16vec4 mul_high(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmulhw(a,b); }
inline Is32vec2 mul_add(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmaddwd(a,b);}


/* Iu16vec4 Class: 
 * 4 elements, each element unsigned short 
 */
class Iu16vec4 : public I16vec4  
{
public:
	Iu16vec4() { }
	Iu16vec4(__m64 mm) : I16vec4(mm) { }
	Iu16vec4(unsigned short ui0, unsigned short ui1, unsigned short ui2, unsigned short ui3)
	{ 
		_MM_4UW(0,vec) = ui3;
		_MM_4UW(1,vec) = ui2;
		_MM_4UW(2,vec) = ui1;
		_MM_4UW(3,vec) = ui0;
	}
	EXPLICIT Iu16vec4(__int64 i) : I16vec4 (i) { }	
	EXPLICIT Iu16vec4(int i) : I16vec4 (i) { }		

	/* Assignment Operator */
	Iu16vec4& operator= (const M64 &a)		{ return *this = (Iu16vec4) a; }

	/* Logical Assignment Operators */
	Iu16vec4& operator&=(const M64 &a)		{ return *this = (Iu16vec4) _m_pand(vec,a); }
	Iu16vec4& operator|=(const M64 &a)		{ return *this = (Iu16vec4) _m_por(vec,a); }
	Iu16vec4& operator^=(const M64 &a)		{ return *this = (Iu16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu16vec4& operator +=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_paddw(vec,a); }
	Iu16vec4& operator -=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_psubw(vec,a); }   
	Iu16vec4& operator *=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_pmullw(vec,a); }   

	/* Shift Logical Operators */
	Iu16vec4 operator<<(const M64 &a) 				{ return _m_psllw(vec,a); }
	Iu16vec4 operator<<(int count) 				    { return _m_psllwi(vec,count); }
	Iu16vec4& operator<<=(const M64 &a)				{ return *this = (Iu16vec4)_m_psllw(vec,a); }
	Iu16vec4& operator<<=(int count) 				{ return *this = (Iu16vec4)_m_psllwi(vec,count); }
	Iu16vec4 operator>>(const M64 &a) 				{ return _m_psrlw(vec,a); }
	Iu16vec4 operator>>(int count) 				    { return _m_psrlwi(vec,count); }
	Iu16vec4& operator>>=(const M64 &a)				{ return *this = (Iu16vec4) _m_psrlw(vec,a); }
	Iu16vec4& operator>>=(int count) 				{ return *this = (Iu16vec4) _m_psrlwi(vec,count); }

	/* Output for Debug */
	friend ostream& operator<< (ostream &os, const Iu16vec4 &a)
	{
		os << "[3]:" << _MM_4UW(3,a) 
			<< " [2]:" << _MM_4UW(2,a) 
			<< " [1]:" << _MM_4UW(1,a) 
			<< " [0]:" << _MM_4UW(0,a);
		return os;
	}

	/* Element Access for Debug, No data modified */
	const unsigned short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UW(i,vec);
	} 

	/* Element Access and Assignment for Debug */
	unsigned short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UW(i,vec);
	} 
};

inline Iu16vec4 operator*(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_pmullw(a,b); }
inline Iu16vec4 cmpeq(const Iu16vec4 &a, const Iu16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline Iu16vec4 cmpneq(const Iu16vec4 &a, const Iu16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }

inline Iu16vec4 sat_add(const Iu16vec4 &a, const Iu16vec4 &b)	{ return _m_paddusw(a,b); }
inline Iu16vec4 sat_sub(const Iu16vec4 &a, const Iu16vec4 &b)	{ return _m_psubusw(a,b); }

inline Iu16vec4 unpack_low(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline Iu16vec4 unpack_high(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_punpckhwd(a,b); }

/* I8vec8 Class: 
 * 8 elements, each element either unsigned or signed char
 */
class I8vec8 : public M64  
{
public:
	I8vec8() { }
	I8vec8(__m64 mm) : M64(mm) { }
	EXPLICIT I8vec8(__int64 i) : M64 (i) { }	
	EXPLICIT I8vec8(int i) : M64 (i) { }		

	/* Assignment Operator */
	I8vec8& operator= (const M64 &a)		{ return *this = (I8vec8) a; }

	/* Logical Assignment Operators */
	I8vec8& operator&=(const M64 &a)		{ return *this = (I8vec8) _m_pand(vec,a); }
	I8vec8& operator|=(const M64 &a)		{ return *this = (I8vec8) _m_por(vec,a); }
	I8vec8& operator^=(const M64 &a)		{ return *this = (I8vec8) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I8vec8& operator +=(const I8vec8 &a)	{ return *this = (I8vec8) _m_paddb(vec,a); }
	I8vec8& operator -=(const I8vec8 &a)	{ return *this = (I8vec8) _m_psubb(vec,a); }   
};


inline I8vec8 cmpeq(const I8vec8 &a, const I8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline I8vec8 cmpneq(const I8vec8 &a, const I8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }

inline I8vec8 unpack_low(const I8vec8 &a, const I8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline I8vec8 unpack_high(const I8vec8 &a, const I8vec8 &b) { return _m_punpckhbw(a,b); }

/* Is8vec8 Class: 
 * 8 elements, each element signed char
 */
class Is8vec8 : public I8vec8  
{
public:
	Is8vec8() { }
	Is8vec8(__m64 mm) : I8vec8(mm) { }
	Is8vec8(signed char s0,signed char s1,signed char s2,signed char s3,signed char s4,signed char s5,signed char s6,signed char s7)
	 { 
		_MM_8B(0,vec) = s7;
		_MM_8B(1,vec) = s6;
		_MM_8B(2,vec) = s5;
		_MM_8B(3,vec) = s4;
		_MM_8B(4,vec) = s3;
		_MM_8B(5,vec) = s2;
		_MM_8B(6,vec) = s1;
		_MM_8B(7,vec) = s0;
	}

	EXPLICIT Is8vec8(__int64 i) : I8vec8 (i) { }	
	EXPLICIT Is8vec8(int i) : I8vec8 (i) { }		

	/* Assignment Operator */
	Is8vec8& operator= (const M64 &a)		{ return *this = (Is8vec8) a; }

	/* Logical Assignment Operators */
	Is8vec8& operator&=(const M64 &a)		{ return *this = (Is8vec8) _m_pand(vec,a); }
	Is8vec8& operator|=(const M64 &a)		{ return *this = (Is8vec8) _m_por(vec,a); }
	Is8vec8& operator^=(const M64 &a)		{ return *this = (Is8vec8) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is8vec8& operator +=(const I8vec8 &a)	{ return *this = (Is8vec8) _m_paddb(vec,a); }
	Is8vec8& operator -=(const I8vec8 &a)	{ return *this = (Is8vec8) _m_psubb(vec,a); }   

	/* Output for Debug */
	friend ostream& operator<< (ostream &os, const Is8vec8 &a)
	{
		os << "[7]:" << short(_MM_8B(7,a)) 
			<< " [6]:" << short(_MM_8B(6,a)) 
			<< " [5]:" << short(_MM_8B(5,a)) 
			<< " [4]:" << short(_MM_8B(4,a)) 
			<< " [3]:" << short(_MM_8B(3,a)) 
			<< " [2]:" << short(_MM_8B(2,a)) 
			<< " [1]:" << short(_MM_8B(1,a)) 
			<< " [0]:" << short(_MM_8B(0,a));
		return os;
	}

	/* Element Access for Debug, No data modified */
	const signed char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8B(i,vec);
	} 

	/* Element Access and Assignment for Debug */
	signed char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8B(i,vec);
	} 
};

/* Additional Is8vec8 functions: compares, unpacks, sat add/sub */
inline Is8vec8 cmpeq(const Is8vec8 &a, const Is8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline Is8vec8 cmpneq(const Is8vec8 &a, const Is8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }
inline Is8vec8 cmpgt(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pcmpgtb(a,b); }
inline Is8vec8 cmplt(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pcmpgtb(b,a); }
inline Is8vec8 cmple(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pandn(_m_pcmpgtb(a,b), M64(0xffffffffffffffffi64)); }
inline Is8vec8 cmpge(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pandn(_m_pcmpgtb(b,a), M64(0xffffffffffffffffi64)); }

inline Is8vec8 unpack_low(const Is8vec8 &a, const Is8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline Is8vec8 unpack_high(const Is8vec8 &a, const Is8vec8 &b) 	{ return _m_punpckhbw(a,b); }

inline Is8vec8 sat_add(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_paddsb(a,b); }
inline Is8vec8 sat_sub(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_psubsb(a,b); }

/* Iu8vec8 Class: 
 * 8 elements, each element unsigned char
 */
class Iu8vec8 : public I8vec8  
{
public:
	Iu8vec8() { }
	Iu8vec8(__m64 mm) : I8vec8(mm) { }
	Iu8vec8(unsigned char s0,unsigned char s1,unsigned char s2,unsigned char s3,unsigned char s4,unsigned char s5,unsigned char s6,unsigned char s7)
	{ 
		_MM_8UB(0,vec) = s7;
		_MM_8UB(1,vec) = s6;
		_MM_8UB(2,vec) = s5;
		_MM_8UB(3,vec) = s4;
		_MM_8UB(4,vec) = s3;
		_MM_8UB(5,vec) = s2;
		_MM_8UB(6,vec) = s1;
		_MM_8UB(7,vec) = s0;
	}
	EXPLICIT Iu8vec8(__int64 i) : I8vec8 (i) { }	
	EXPLICIT Iu8vec8(int i) : I8vec8 (i) { }		

	/* Assignment Operator */
	Iu8vec8& operator= (const M64 &a)		{ return *this = (Iu8vec8) a; }
	/* Logical Assignment Operators */
	Iu8vec8& operator&=(const M64 &a)		{ return *this = (Iu8vec8) _m_pand(vec,a); }
	Iu8vec8& operator|=(const M64 &a)		{ return *this = (Iu8vec8) _m_por(vec,a); }
	Iu8vec8& operator^=(const M64 &a)		{ return *this = (Iu8vec8) _m_pxor(vec,a); }
	/* Addition & Subtraction Assignment Operators */
	Iu8vec8& operator +=(const I8vec8 &a)	{ return *this = (Iu8vec8) _m_paddb(vec,a); }
	Iu8vec8& operator -=(const I8vec8 &a)	{ return *this = (Iu8vec8) _m_psubb(vec,a); }   

	/* Output for Debug */
	friend ostream& operator << (ostream &os, const Iu8vec8 &a)
	{
		 os << "[7]:"  << unsigned short(_MM_8UB(7,a)) 
			<< " [6]:" << unsigned short(_MM_8UB(6,a)) 
			<< " [5]:" << unsigned short(_MM_8UB(5,a)) 
			<< " [4]:" << unsigned short(_MM_8UB(4,a)) 
			<< " [3]:" << unsigned short(_MM_8UB(3,a)) 
			<< " [2]:" << unsigned short(_MM_8UB(2,a)) 
			<< " [1]:" << unsigned short(_MM_8UB(1,a)) 
			<< " [0]:" << unsigned short(_MM_8UB(0,a));
		return os;
	}

	/* Element Access for Debug, No data modified */
	const unsigned char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UB(i,vec);
	} 

	/* Element Access for Debug */
	unsigned char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UB(i,vec);
	} 
};

/* Additional Iu8vec8 functions: cmpeq,cmpneq, unpacks, sat add/sub */
inline Iu8vec8 cmpeq(const Iu8vec8 &a, const Iu8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline Iu8vec8 cmpneq(const Iu8vec8 &a, const Iu8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }

inline Iu8vec8 unpack_low(const Iu8vec8 &a, const Iu8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline Iu8vec8 unpack_high(const Iu8vec8 &a, const Iu8vec8 &b) 	{ return _m_punpckhbw(a,b); }

inline Iu8vec8 sat_add(const Iu8vec8 &a, const Iu8vec8 &b)		{ return _m_paddusb(a,b); }
inline Iu8vec8 sat_sub(const Iu8vec8 &a, const Iu8vec8 &b)		{ return _m_psubusb(a,b); }

inline Is16vec4 pack_sat(const Is32vec2 &a, const Is32vec2 &b)		{ return _m_packssdw(a,b); }
inline Is8vec8 pack_sat(const Is16vec4 &a, const Is16vec4 &b) 		{ return _m_packsswb(a,b); }
inline Iu8vec8 packu_sat(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_packuswb(a,b); }

/********************************* Logicals ****************************************/
#define IVEC_LOGICALS(vect,element) \
inline I##vect##vec##element operator& (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pand( a,b); } \
inline I##vect##vec##element operator| (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_por( a,b); } \
inline I##vect##vec##element operator^ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pxor( a,b); } \
inline I##vect##vec##element andnot (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pandn( a,b); } 

IVEC_LOGICALS(8,8)
IVEC_LOGICALS(u8,8)
IVEC_LOGICALS(s8,8)
IVEC_LOGICALS(16,4)
IVEC_LOGICALS(u16,4)
IVEC_LOGICALS(s16,4)
IVEC_LOGICALS(32,2)
IVEC_LOGICALS(u32,2)
IVEC_LOGICALS(s32,2)
IVEC_LOGICALS(64,1)
#undef IVEC_LOGICALS

/********************************* Add & Sub ****************************************/
#define IVEC_ADD_SUB(vect,element,opsize) \
inline I##vect##vec##element operator+ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_padd##opsize( a,b); } \
inline I##vect##vec##element operator- (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_psub##opsize( a,b); }

IVEC_ADD_SUB(8,8, b)
IVEC_ADD_SUB(u8,8, b)
IVEC_ADD_SUB(s8,8, b)
IVEC_ADD_SUB(16,4, w)
IVEC_ADD_SUB(u16,4, w)
IVEC_ADD_SUB(s16,4, w)
IVEC_ADD_SUB(32,2, d)
IVEC_ADD_SUB(u32,2, d)
IVEC_ADD_SUB(s32,2, d)
#undef IVEC_ADD_SUB

/********************************* Conditional Select ****************************************/
/*	version of: retval = (a OP b)? c : d;													 *
 *	Where OP is one of the possible comparision operators.									 *
 *	Example: r = select_eq(a,b,c,d);														 *
 *	if "member at position x of the vector a" == "member at position x of vector b" 		 *
 *	assign the corresponding member in r from c, else assign from d.							 *
 ********************************* Conditional Select ****************************************/

#define IVEC_SELECT(vect12,vect34,element,selop,arg1,arg2) \
	inline I##vect34##vec##element select_##selop (const I##vect12##vec##element &a, const I##vect12##vec##element &b, const I##vect34##vec##element &c, const I##vect34##vec##element &d) 	   \
{																\
	I##vect12##vec##element mask = cmp##selop(a,b);						\
	return( (mask & arg1 ) | I##vect12##vec##element ((_m_pandn(mask, arg2 ))));	\
}												
IVEC_SELECT(8,s8,8,eq,c,d)
IVEC_SELECT(8,u8,8,eq,c,d)
IVEC_SELECT(8,8,8,eq,c,d)
IVEC_SELECT(8,s8,8,neq,c,d)
IVEC_SELECT(8,u8,8,neq,c,d)
IVEC_SELECT(8,8,8,neq,c,d)

IVEC_SELECT(16,s16,4,eq,c,d)
IVEC_SELECT(16,u16,4,eq,c,d)
IVEC_SELECT(16,16,4,eq,c,d)
IVEC_SELECT(16,s16,4,neq,c,d)
IVEC_SELECT(16,u16,4,neq,c,d)
IVEC_SELECT(16,16,4,neq,c,d)

IVEC_SELECT(32,s32,2,eq,c,d)
IVEC_SELECT(32,u32,2,eq,c,d)
IVEC_SELECT(32,32,2,eq,c,d)
IVEC_SELECT(32,s32,2,neq,c,d)
IVEC_SELECT(32,u32,2,neq,c,d)
IVEC_SELECT(32,32,2,neq,c,d)


IVEC_SELECT(s8,s8,8,gt,c,d)
IVEC_SELECT(s8,u8,8,gt,c,d)
IVEC_SELECT(s8,8,8,gt,c,d)
IVEC_SELECT(s8,s8,8,lt,c,d)
IVEC_SELECT(s8,u8,8,lt,c,d)
IVEC_SELECT(s8,8,8,lt,c,d)
IVEC_SELECT(s8,s8,8,le,c,d)
IVEC_SELECT(s8,u8,8,le,c,d)
IVEC_SELECT(s8,8,8,le,c,d)
IVEC_SELECT(s8,s8,8,ge,c,d)
IVEC_SELECT(s8,u8,8,ge,c,d)
IVEC_SELECT(s8,8,8,ge,c,d)

IVEC_SELECT(s16,s16,4,gt,c,d)
IVEC_SELECT(s16,u16,4,gt,c,d)
IVEC_SELECT(s16,16,4,gt,c,d)
IVEC_SELECT(s16,s16,4,lt,c,d)
IVEC_SELECT(s16,u16,4,lt,c,d)
IVEC_SELECT(s16,16,4,lt,c,d)
IVEC_SELECT(s16,s16,4,le,c,d)
IVEC_SELECT(s16,u16,4,le,c,d)
IVEC_SELECT(s16,16,4,le,c,d)
IVEC_SELECT(s16,s16,4,ge,c,d)
IVEC_SELECT(s16,u16,4,ge,c,d)
IVEC_SELECT(s16,16,4,ge,c,d)
			
IVEC_SELECT(s32,s32,2,gt,c,d)
IVEC_SELECT(s32,u32,2,gt,c,d)
IVEC_SELECT(s32,32,2,gt,c,d)
IVEC_SELECT(s32,s32,2,lt,c,d)
IVEC_SELECT(s32,u32,2,lt,c,d)
IVEC_SELECT(s32,32,2,lt,c,d)
IVEC_SELECT(s32,s32,2,le,c,d)
IVEC_SELECT(s32,u32,2,le,c,d)
IVEC_SELECT(s32,32,2,le,c,d)
IVEC_SELECT(s32,s32,2,ge,c,d)
IVEC_SELECT(s32,u32,2,ge,c,d)
IVEC_SELECT(s32,32,2,ge,c,d)

			
#undef IVEC_SELECT

inline static void empty(void) 		{ _m_empty(); }			

#endif // IVEC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\key.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 1999  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and distribute
// the Sample Application Files (including modified versions) in any way 
// you determine to be useful, provided that you agree that Microsoft 
// Corporation provides no warrant or support, and has no obligation or
// liability resulting from the use of any Sample Application Files. 
//

#include <wtypes.h>

extern BYTE abPVK[];
extern BYTE abCert[];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\jetoledb.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Sat Mar 06 00:29:02 1999
 */
/* Compiler settings for r:\JOLT\lib\jetoledb.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __jetoledb_h__
#define __jetoledb_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDBUserAttributes_FWD_DEFINED__
#define __IDBUserAttributes_FWD_DEFINED__
typedef interface IDBUserAttributes IDBUserAttributes;
#endif 	/* __IDBUserAttributes_FWD_DEFINED__ */


#ifndef __IJetCompact_FWD_DEFINED__
#define __IJetCompact_FWD_DEFINED__
typedef interface IJetCompact IJetCompact;
#endif 	/* __IJetCompact_FWD_DEFINED__ */


#ifndef __IIdle_FWD_DEFINED__
#define __IIdle_FWD_DEFINED__
typedef interface IIdle IIdle;
#endif 	/* __IIdle_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "oaidl.h"
#include "oledb.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_jetoledb_0000
 * at Sat Mar 06 00:29:02 1999
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


typedef DWORD DBOBJTYPE;


enum DBTYPE_ENUM
    {	DBJETOBJECT_TABLE	= 0x1,
	DBJETOBJECT_INDEX	= 0x2,
	DBJETOBJECT_VIEWS	= 0x4
    };
typedef DWORD USERATTRIBUTESFLAGS;


enum USERATTRIBUTESFLAGS_ENUM
    {	DBJETOLEDB_USERATTRIBUTES_ALLCOLLECTIONS	= 1,
	DBJETOLEDB_USERATTRIBUTES_INHERITED	= 2
    };


extern RPC_IF_HANDLE __MIDL_itf_jetoledb_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_jetoledb_0000_v0_0_s_ifspec;

#ifndef __IDBUserAttributes_INTERFACE_DEFINED__
#define __IDBUserAttributes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBUserAttributes
 * at Sat Mar 06 00:29:02 1999
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDBUserAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("cb9497b0-20b8-11d2-a4dc-00c04f991c78")
    IDBUserAttributes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ DBID __RPC_FAR *pParentID,
            /* [in] */ DBID __RPC_FAR *pObjectID,
            /* [in] */ DBOBJTYPE dwType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteObject( 
            /* [in] */ DBID __RPC_FAR *pParentID,
            /* [in] */ DBID __RPC_FAR *pObjectID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenameObject( 
            /* [in] */ DBID __RPC_FAR *pParentID,
            /* [in] */ DBID __RPC_FAR *pObjectID,
            /* [in] */ LPWSTR pwszNewName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAttribute( 
            /* [in] */ DBID __RPC_FAR *pParentID,
            /* [in] */ DBID __RPC_FAR *pObjectID,
            /* [in] */ DBID __RPC_FAR *pSubObjectID,
            /* [in] */ DBID __RPC_FAR *pAttributeID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttributeValue( 
            /* [in] */ DBID __RPC_FAR *pParentID,
            /* [in] */ DBID __RPC_FAR *pObjectID,
            /* [in] */ DBID __RPC_FAR *pSubObjectID,
            /* [in] */ DBID __RPC_FAR *pAttributeID,
            /* [in] */ VARIANT vValue,
            /* [in] */ ULONG grbit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeValue( 
            /* [in] */ DBID __RPC_FAR *pParentID,
            /* [in] */ DBID __RPC_FAR *pObjectID,
            /* [in] */ DBID __RPC_FAR *pSubObjectID,
            /* [in] */ DBID __RPC_FAR *pAttributeID,
            /* [out][in] */ VARIANT __RPC_FAR *pvValue,
            /* [in] */ ULONG grbit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeRowset( 
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ WCHAR __RPC_FAR *pwszParentID,
            /* [in] */ WCHAR __RPC_FAR *pwszObjectID,
            /* [in] */ WCHAR __RPC_FAR *pwszSubObjectID,
            /* [in] */ WCHAR __RPC_FAR *pwszAttributeID,
            /* [in] */ ULONG dwFlags,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET __RPC_FAR *rgPropertySets,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBUserAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDBUserAttributes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDBUserAttributes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDBUserAttributes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateObject )( 
            IDBUserAttributes __RPC_FAR * This,
            /* [in] */ DBID __RPC_FAR *pParentID,
            /* [in] */ DBID __RPC_FAR *pObjectID,
            /* [in] */ DBOBJTYPE dwType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteObject )( 
            IDBUserAttributes __RPC_FAR * This,
            /* [in] */ DBID __RPC_FAR *pParentID,
            /* [in] */ DBID __RPC_FAR *pObjectID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RenameObject )( 
            IDBUserAttributes __RPC_FAR * This,
            /* [in] */ DBID __RPC_FAR *pParentID,
            /* [in] */ DBID __RPC_FAR *pObjectID,
            /* [in] */ LPWSTR pwszNewName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAttribute )( 
            IDBUserAttributes __RPC_FAR * This,
            /* [in] */ DBID __RPC_FAR *pParentID,
            /* [in] */ DBID __RPC_FAR *pObjectID,
            /* [in] */ DBID __RPC_FAR *pSubObjectID,
            /* [in] */ DBID __RPC_FAR *pAttributeID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttributeValue )( 
            IDBUserAttributes __RPC_FAR * This,
            /* [in] */ DBID __RPC_FAR *pParentID,
            /* [in] */ DBID __RPC_FAR *pObjectID,
            /* [in] */ DBID __RPC_FAR *pSubObjectID,
            /* [in] */ DBID __RPC_FAR *pAttributeID,
            /* [in] */ VARIANT vValue,
            /* [in] */ ULONG grbit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeValue )( 
            IDBUserAttributes __RPC_FAR * This,
            /* [in] */ DBID __RPC_FAR *pParentID,
            /* [in] */ DBID __RPC_FAR *pObjectID,
            /* [in] */ DBID __RPC_FAR *pSubObjectID,
            /* [in] */ DBID __RPC_FAR *pAttributeID,
            /* [out][in] */ VARIANT __RPC_FAR *pvValue,
            /* [in] */ ULONG grbit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeRowset )( 
            IDBUserAttributes __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ WCHAR __RPC_FAR *pwszParentID,
            /* [in] */ WCHAR __RPC_FAR *pwszObjectID,
            /* [in] */ WCHAR __RPC_FAR *pwszSubObjectID,
            /* [in] */ WCHAR __RPC_FAR *pwszAttributeID,
            /* [in] */ ULONG dwFlags,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET __RPC_FAR *rgPropertySets,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowset);
        
        END_INTERFACE
    } IDBUserAttributesVtbl;

    interface IDBUserAttributes
    {
        CONST_VTBL struct IDBUserAttributesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBUserAttributes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBUserAttributes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBUserAttributes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBUserAttributes_CreateObject(This,pParentID,pObjectID,dwType)	\
    (This)->lpVtbl -> CreateObject(This,pParentID,pObjectID,dwType)

#define IDBUserAttributes_DeleteObject(This,pParentID,pObjectID)	\
    (This)->lpVtbl -> DeleteObject(This,pParentID,pObjectID)

#define IDBUserAttributes_RenameObject(This,pParentID,pObjectID,pwszNewName)	\
    (This)->lpVtbl -> RenameObject(This,pParentID,pObjectID,pwszNewName)

#define IDBUserAttributes_DeleteAttribute(This,pParentID,pObjectID,pSubObjectID,pAttributeID)	\
    (This)->lpVtbl -> DeleteAttribute(This,pParentID,pObjectID,pSubObjectID,pAttributeID)

#define IDBUserAttributes_SetAttributeValue(This,pParentID,pObjectID,pSubObjectID,pAttributeID,vValue,grbit)	\
    (This)->lpVtbl -> SetAttributeValue(This,pParentID,pObjectID,pSubObjectID,pAttributeID,vValue,grbit)

#define IDBUserAttributes_GetAttributeValue(This,pParentID,pObjectID,pSubObjectID,pAttributeID,pvValue,grbit)	\
    (This)->lpVtbl -> GetAttributeValue(This,pParentID,pObjectID,pSubObjectID,pAttributeID,pvValue,grbit)

#define IDBUserAttributes_GetAttributeRowset(This,pUnkOuter,pwszParentID,pwszObjectID,pwszSubObjectID,pwszAttributeID,dwFlags,cPropertySets,rgPropertySets,riid,ppRowset)	\
    (This)->lpVtbl -> GetAttributeRowset(This,pUnkOuter,pwszParentID,pwszObjectID,pwszSubObjectID,pwszAttributeID,dwFlags,cPropertySets,rgPropertySets,riid,ppRowset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDBUserAttributes_CreateObject_Proxy( 
    IDBUserAttributes __RPC_FAR * This,
    /* [in] */ DBID __RPC_FAR *pParentID,
    /* [in] */ DBID __RPC_FAR *pObjectID,
    /* [in] */ DBOBJTYPE dwType);


void __RPC_STUB IDBUserAttributes_CreateObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDBUserAttributes_DeleteObject_Proxy( 
    IDBUserAttributes __RPC_FAR * This,
    /* [in] */ DBID __RPC_FAR *pParentID,
    /* [in] */ DBID __RPC_FAR *pObjectID);


void __RPC_STUB IDBUserAttributes_DeleteObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDBUserAttributes_RenameObject_Proxy( 
    IDBUserAttributes __RPC_FAR * This,
    /* [in] */ DBID __RPC_FAR *pParentID,
    /* [in] */ DBID __RPC_FAR *pObjectID,
    /* [in] */ LPWSTR pwszNewName);


void __RPC_STUB IDBUserAttributes_RenameObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDBUserAttributes_DeleteAttribute_Proxy( 
    IDBUserAttributes __RPC_FAR * This,
    /* [in] */ DBID __RPC_FAR *pParentID,
    /* [in] */ DBID __RPC_FAR *pObjectID,
    /* [in] */ DBID __RPC_FAR *pSubObjectID,
    /* [in] */ DBID __RPC_FAR *pAttributeID);


void __RPC_STUB IDBUserAttributes_DeleteAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDBUserAttributes_SetAttributeValue_Proxy( 
    IDBUserAttributes __RPC_FAR * This,
    /* [in] */ DBID __RPC_FAR *pParentID,
    /* [in] */ DBID __RPC_FAR *pObjectID,
    /* [in] */ DBID __RPC_FAR *pSubObjectID,
    /* [in] */ DBID __RPC_FAR *pAttributeID,
    /* [in] */ VARIANT vValue,
    /* [in] */ ULONG grbit);


void __RPC_STUB IDBUserAttributes_SetAttributeValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDBUserAttributes_GetAttributeValue_Proxy( 
    IDBUserAttributes __RPC_FAR * This,
    /* [in] */ DBID __RPC_FAR *pParentID,
    /* [in] */ DBID __RPC_FAR *pObjectID,
    /* [in] */ DBID __RPC_FAR *pSubObjectID,
    /* [in] */ DBID __RPC_FAR *pAttributeID,
    /* [out][in] */ VARIANT __RPC_FAR *pvValue,
    /* [in] */ ULONG grbit);


void __RPC_STUB IDBUserAttributes_GetAttributeValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDBUserAttributes_GetAttributeRowset_Proxy( 
    IDBUserAttributes __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ WCHAR __RPC_FAR *pwszParentID,
    /* [in] */ WCHAR __RPC_FAR *pwszObjectID,
    /* [in] */ WCHAR __RPC_FAR *pwszSubObjectID,
    /* [in] */ WCHAR __RPC_FAR *pwszAttributeID,
    /* [in] */ ULONG dwFlags,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET __RPC_FAR *rgPropertySets,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowset);


void __RPC_STUB IDBUserAttributes_GetAttributeRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBUserAttributes_INTERFACE_DEFINED__ */


#ifndef __IJetCompact_INTERFACE_DEFINED__
#define __IJetCompact_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJetCompact
 * at Sat Mar 06 00:29:02 1999
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IJetCompact;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2a4b6284-eeb4-11d1-a4d9-00c04f991c78")
    IJetCompact : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Compact( 
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET __RPC_FAR rgPropertySets[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJetCompactVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJetCompact __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJetCompact __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJetCompact __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Compact )( 
            IJetCompact __RPC_FAR * This,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][out][in] */ DBPROPSET __RPC_FAR rgPropertySets[  ]);
        
        END_INTERFACE
    } IJetCompactVtbl;

    interface IJetCompact
    {
        CONST_VTBL struct IJetCompactVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJetCompact_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJetCompact_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJetCompact_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJetCompact_Compact(This,cPropertySets,rgPropertySets)	\
    (This)->lpVtbl -> Compact(This,cPropertySets,rgPropertySets)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJetCompact_Compact_Proxy( 
    IJetCompact __RPC_FAR * This,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][out][in] */ DBPROPSET __RPC_FAR rgPropertySets[  ]);


void __RPC_STUB IJetCompact_Compact_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJetCompact_INTERFACE_DEFINED__ */


#ifndef __IIdle_INTERFACE_DEFINED__
#define __IIdle_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IIdle
 * at Sat Mar 06 00:29:02 1999
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IIdle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("f497cfc8-8ed8-11d1-9f09-00c04fc2c2e0")
    IIdle : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Idle( 
            /* [in] */ ULONG dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIdleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IIdle __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IIdle __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IIdle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Idle )( 
            IIdle __RPC_FAR * This,
            /* [in] */ ULONG dwFlags);
        
        END_INTERFACE
    } IIdleVtbl;

    interface IIdle
    {
        CONST_VTBL struct IIdleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIdle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIdle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIdle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIdle_Idle(This,dwFlags)	\
    (This)->lpVtbl -> Idle(This,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIdle_Idle_Proxy( 
    IIdle __RPC_FAR * This,
    /* [in] */ ULONG dwFlags);


void __RPC_STUB IIdle_Idle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIdle_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ksalpha.h ===
#if defined(_AXP64_)
#include "kspaxp64.h"
#else
#include "kspalpha.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\KsGuid.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ksguid.h

Abstract:

    Define guids for non-C++.

--*/

#define INITGUID
#include <guiddef.h>

#if defined( DEFINE_GUIDEX )
    #undef DEFINE_GUIDEX
#endif
#define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID __declspec(selectany) name = { STATICGUIDOF(name) }

#ifndef STATICGUIDOF
    #define STATICGUIDOF(guid) STATIC_##guid
#endif // !defined(STATICGUIDOF)

#if !defined( DEFINE_WAVEFORMATEX_GUID )
#define DEFINE_WAVEFORMATEX_GUID(x) (USHORT)(x), 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\istream.h ===
/***
*istream.h - definitions/declarations for the istream class
*
*       Copyright (c) 1990-2000, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the istream class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_ISTREAM
#define _INC_ISTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>

#ifdef  _MSC_VER
// C4069: "long double != double"
#pragma warning(disable:4069)   // disable C4069 warning
// #pragma warning(default:4069)    // use this to reenable, if desired

// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)    // use this to reenable, if desired
#endif  // _MSC_VER


typedef long streamoff, streampos;

class _CRTIMP istream : virtual public ios {

public:
    istream(streambuf*);
    virtual ~istream();

    int  ipfx(int =0);
    void isfx() { unlockbuf(); unlock(); }

    inline istream& operator>>(istream& (__cdecl * _f)(istream&));
    inline istream& operator>>(ios& (__cdecl * _f)(ios&));
    istream& operator>>(char *);
    inline istream& operator>>(unsigned char *);
    inline istream& operator>>(signed char *);
    istream& operator>>(char &);
    inline istream& operator>>(unsigned char &);
    inline istream& operator>>(signed char &);
    istream& operator>>(short &);
    istream& operator>>(unsigned short &);
    istream& operator>>(int &);
    istream& operator>>(unsigned int &);
    istream& operator>>(long &);
    istream& operator>>(unsigned long &);
    istream& operator>>(float &);
    istream& operator>>(double &);
    istream& operator>>(long double &);
    istream& operator>>(streambuf*);

    int get();

    inline istream& get(         char *,int,char ='\n');
    inline istream& get(unsigned char *,int,char ='\n');
    inline istream& get(  signed char *,int,char ='\n');

    istream& get(char &);
    inline istream& get(unsigned char &);
    inline istream& get(  signed char &);

    istream& get(streambuf&,char ='\n');
    inline istream& getline(         char *,int,char ='\n');
    inline istream& getline(unsigned char *,int,char ='\n');
    inline istream& getline(  signed char *,int,char ='\n');

    inline istream& ignore(int =1,int =EOF);
    istream& read(char *,int);
    inline istream& read(unsigned char *,int);
    inline istream& read(signed char *,int);

    int gcount() const { return x_gcount; }
    int peek();
    istream& putback(char);
    int sync();

    istream& seekg(streampos);
    istream& seekg(streamoff,ios::seek_dir);
    streampos tellg();

    void eatwhite();

protected:
    istream();
    istream(const istream&);    // treat as private
    istream& operator=(streambuf* _isb); // treat as private
    istream& operator=(const istream& _is) { return operator=(_is.rdbuf()); }
    istream& get(char *, int, int);
     int do_ipfx(int);

private:
    istream(ios&);
    int getint(char *);
    int getdouble(char *, int);
    int _fGline;
    int x_gcount;
};

    inline istream& istream::operator>>(istream& (__cdecl * _f)(istream&)) { (*_f)(*this); return *this; }
    inline istream& istream::operator>>(ios& (__cdecl * _f)(ios&)) { (*_f)(*this); return *this; }

    inline istream& istream::operator>>(unsigned char * _s) { return operator>>((char *)_s); }
    inline istream& istream::operator>>(  signed char * _s) { return operator>>((char *)_s); }

    inline istream& istream::operator>>(unsigned char & _c) { return operator>>((char &) _c); }
    inline istream& istream::operator>>(  signed char & _c) { return operator>>((char &) _c); }

    inline istream& istream::get(         char * _b, int _lim, char _delim) { return get(        _b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(unsigned char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(signed   char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }

    inline istream& istream::get(unsigned char & _c) { return get((char &)_c); }
    inline istream& istream::get(  signed char & _c) { return get((char &)_c); }

    inline istream& istream::getline(         char * _b,int _lim,char _delim) { lock(); _fGline++; get(        _b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(unsigned char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(  signed char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }

    inline istream& istream::ignore(int _n,int _delim) { lock(); _fGline++; get((char *)0, _n+1, _delim); unlock(); return *this; }

    inline istream& istream::read(unsigned char * _ptr, int _n) { return read((char *) _ptr, _n); }
    inline istream& istream::read(  signed char * _ptr, int _n) { return read((char *) _ptr, _n); }

class _CRTIMP istream_withassign : public istream {
        public:
            istream_withassign();
            istream_withassign(streambuf*);
            ~istream_withassign();
    istream& operator=(const istream& _is) { return istream::operator=(_is); }
    istream& operator=(streambuf* _isb) { return istream::operator=(_isb); }
};

extern _CRTIMP istream_withassign cin;

inline _CRTIMP istream& __cdecl ws(istream& _ins) { _ins.eatwhite(); return _ins; }

_CRTIMP ios&        __cdecl dec(ios&);
_CRTIMP ios&        __cdecl hex(ios&);
_CRTIMP ios&        __cdecl oct(ios&);

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_ISTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\kerbcon.h ===
//+-----------------------------------------------------------------------
//
// File:        KERBCON.H
//
// Contents:    Microsoft Kerberos constants
//
//
// History:     25 Feb 92   RichardW    Compiled from other files
//
//------------------------------------------------------------------------

#ifndef __KERBCON_H__
#define __KERBCON_H__


// Revision of the Kerberos Protocol.  MS uses Version 5, Revision 6

#define KERBEROS_VERSION    5
#define KERBEROS_REVISION   6



// Encryption Types:
// These encryption types are supported by the default MS KERBSUPP DLL
// as crypto systems.  Values over 127 are local values, and may be changed
// without notice.

#define KERB_ETYPE_NULL             0
#define KERB_ETYPE_DES_CBC_CRC      1
#define KERB_ETYPE_DES_CBC_MD4      2
#define KERB_ETYPE_DES_CBC_MD5      3

#define KERB_ETYPE_OLD_RC4_MD4          128
#define KERB_ETYPE_OLD_RC4_PLAIN        129
#define KERB_ETYPE_OLD_RC4_LM           130
#define KERB_ETYPE_OLD_RC4_SHA          131
#define KERB_ETYPE_OLD_DES_PLAIN        132

#define KERB_ETYPE_RC4_MD4          -128
#define KERB_ETYPE_RC4_PLAIN        -129
#define KERB_ETYPE_RC4_LM           -130
#define KERB_ETYPE_RC4_SHA          -131
#define KERB_ETYPE_DES_PLAIN        -132


// Checksum algorithms.
// These algorithms are keyed internally for our use.

#define KERB_CHECKSUM_NONE  0
#define KERB_CHECKSUM_CRC32         1
#define KERB_CHECKSUM_MD4           2
#define KERB_CHECKSUM_KRB_DES_MAC   4
#define KERB_CHECKSUM_MD5           7
#define KERB_CHECKSUM_MD5_DES       8


#define KERB_CHECKSUM_OLD_LM            130
#define KERB_CHECKSUM_OLD_SHA1          131
#define KERB_CHECKSUM_OLD_REAL_CRC32    132
#define KERB_CHECKSUM_OLD_DES_MAC       133
#define KERB_CHECKSUM_OLD_DES_MAC_MD5   134
#define KERB_CHECKSUM_OLD_MD25          135
#define KERB_CHECKSUM_OLD_RC4_MD5       136


#define KERB_CHECKSUM_LM            -130
#define KERB_CHECKSUM_SHA1          -131
#define KERB_CHECKSUM_REAL_CRC32    -132
#define KERB_CHECKSUM_DES_MAC       -133
#define KERB_CHECKSUM_DES_MAC_MD5   -134
#define KERB_CHECKSUM_MD25          -135
#define KERB_CHECKSUM_RC4_MD5       -136


#define AUTH_REQ_ALLOW_FORWARDABLE      0x00000001
#define AUTH_REQ_ALLOW_PROXIABLE        0x00000002
#define AUTH_REQ_ALLOW_POSTDATE         0x00000004
#define AUTH_REQ_ALLOW_RENEWABLE        0x00000008
#define AUTH_REQ_ALLOW_NOADDRESS        0x00000010
#define AUTH_REQ_ALLOW_ENC_TKT_IN_SKEY  0x00000020
#define AUTH_REQ_ALLOW_VALIDATE         0x00000040
#define AUTH_REQ_VALIDATE_CLIENT        0x00000080
#define AUTH_REQ_OK_AS_DELEGATE         0x00000100


//
// KDC auditing flags. these do not belong here for long
//

#define KDC_AUDIT_AS_SUCCESS            0x1
#define KDC_AUDIT_AS_FAILURE            0x2
#define KDC_AUDIT_TGS_SUCCESS           0x4
#define KDC_AUDIT_TGS_FAILURE           0x8

//
// macro for converting auth flags & audit flags to state which may
// be set through the debug function KdcSetState
//

#define KDC_MAKE_STATE(AuthFlag, AuditFlag) (((AuditFlag) << 16) | ((AuthFlag) & 0xffff))
#define KDC_AUTH_STATE(StateFlags) ((StateFlags) & 0xffff)
#define KDC_AUDIT_STATE(StateFlags) ((StateFlags) >> 16)

#endif // __KERBCON_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\KsProxy.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ksproxy.h

Abstract:

    Interface definitions for WDM-CSA proxy filters.

--*/

#ifndef __KSPROXY__
#define __KSPROXY__

#ifdef __cplusplus
extern "C" {
#endif

#undef KSDDKAPI
#ifdef _KSDDK_
#define KSDDKAPI
#else // !_KSDDK_
#define KSDDKAPI DECLSPEC_IMPORT
#endif // _KSDDK_

#define STATIC_IID_IKsObject\
    0x423c13a2L, 0x2070, 0x11d0, 0x9e, 0xf7, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1

#define STATIC_IID_IKsPinEx\
    0x7bb38260L, 0xd19c, 0x11d2, 0xb3, 0x8a, 0x00, 0xa0, 0xc9, 0x5e, 0xc2, 0x2e

#define STATIC_IID_IKsPin\
    0xb61178d1L, 0xa2d9, 0x11cf, 0x9e, 0x53, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1
    
#define STATIC_IID_IKsPinPipe\
    0xe539cd90L, 0xa8b4, 0x11d1, 0x81, 0x89, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02

#define STATIC_IID_IKsDataTypeHandler\
    0x5ffbaa02L, 0x49a3, 0x11d0, 0x9f, 0x36, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1

#define STATIC_IID_IKsDataTypeCompletion\
    0x827D1A0EL, 0x0F73, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_IID_IKsInterfaceHandler\
    0xD3ABC7E0L, 0x9A61, 0x11D0, 0xA4, 0x0D, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_IID_IKsClockPropertySet\
    0x5C5CBD84L, 0xE755, 0x11D0, 0xAC, 0x18, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_IID_IKsAllocator\
    0x8da64899L, 0xc0d9, 0x11d0, 0x84, 0x13, 0x00, 0x00, 0xf8, 0x22, 0xfe, 0x8a
    
#define STATIC_IID_IKsAllocatorEx\
    0x091bb63aL, 0x603f, 0x11d1, 0xb0, 0x67, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
    

#ifndef STATIC_IID_IKsPropertySet
#define STATIC_IID_IKsPropertySet\
    0x31EFAC30L, 0x515C, 0x11d0, 0xA9, 0xAA, 0x00, 0xAA, 0x00, 0x61, 0xBE, 0x93
#endif // STATIC_IID_IKsPropertySet

#define STATIC_IID_IKsTopology\
    0x28F54683L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#ifndef STATIC_IID_IKsControl
#define STATIC_IID_IKsControl\
    0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
#endif // STATIC_IID_IKsControl

#define STATIC_IID_IKsAggregateControl\
    0x7F40EAC0L, 0x3947, 0x11D2, 0x87, 0x4E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_CLSID_Proxy \
    0x17CCA71BL, 0xECD7, 0x11D0, 0xB9, 0x08, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#ifdef _KS_

#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsObject);

DEFINE_GUIDEX(IID_IKsPin);

DEFINE_GUIDEX(IID_IKsPinEx);

DEFINE_GUIDEX(IID_IKsPinPipe);

DEFINE_GUIDEX(IID_IKsDataTypeHandler);

DEFINE_GUIDEX(IID_IKsDataTypeCompletion);

DEFINE_GUIDEX(IID_IKsInterfaceHandler);

DEFINE_GUIDEX(IID_IKsClockPropertySet);

DEFINE_GUIDEX(IID_IKsAllocator);

DEFINE_GUIDEX(IID_IKsAllocatorEx);

#define IID_IKsQualityForwarder KSCATEGORY_QUALITY
#endif // !defined(__cplusplus) || _MSC_VER < 1100

#define STATIC_IID_IKsQualityForwarder STATIC_KSCATEGORY_QUALITY

typedef enum {
    KsAllocatorMode_User,
    KsAllocatorMode_Kernel
} KSALLOCATORMODE;


typedef enum {
    FramingProp_Uninitialized,
    FramingProp_None,
    FramingProp_Old,
    FramingProp_Ex
} FRAMING_PROP;

typedef FRAMING_PROP *PFRAMING_PROP;


typedef enum {
    Framing_Cache_Update,     // request to bypass cache when read/write
    Framing_Cache_ReadLast,
    Framing_Cache_ReadOrig,
    Framing_Cache_Write
} FRAMING_CACHE_OPS;


typedef struct {
    LONGLONG     MinTotalNominator;  
    LONGLONG     MaxTotalNominator;
    LONGLONG     TotalDenominator;
} OPTIMAL_WEIGHT_TOTALS;

// forward declaration
typedef struct IPin IPin;
typedef struct IKsPin IKsPin;
typedef struct IKsAllocator IKsAllocator;
typedef struct IKsAllocatorEx IKsAllocatorEx;

                      
//
// allocators strategy is defined by graph manager
//
#define AllocatorStrategy_DontCare                      0

//
// what to optimize
//
#define AllocatorStrategy_MinimizeNumberOfFrames        0x00000001
#define AllocatorStrategy_MinimizeFrameSize             0x00000002
#define AllocatorStrategy_MinimizeNumberOfAllocators    0x00000004
#define AllocatorStrategy_MaximizeSpeed                 0x00000008 

//
// factors (flags) defining the Pipes properties
//
#define PipeFactor_None                   0
#define PipeFactor_UserModeUpstream       0x00000001
#define PipeFactor_UserModeDownstream     0x00000002
#define PipeFactor_MemoryTypes            0x00000004
#define PipeFactor_Flags                  0x00000008
#define PipeFactor_PhysicalRanges         0x00000010
#define PipeFactor_OptimalRanges          0x00000020
#define PipeFactor_FixedCompression       0x00000040
#define PipeFactor_UnknownCompression     0x00000080

#define PipeFactor_Buffers                0x00000100
#define PipeFactor_Align                  0x00000200

#define PipeFactor_PhysicalEnd            0x00000400
#define PipeFactor_LogicalEnd             0x00000800



typedef enum {
    PipeState_DontCare,
    PipeState_RangeNotFixed,
    PipeState_RangeFixed,
    PipeState_CompressionUnknown,
    PipeState_Finalized
} PIPE_STATE;


//
// pipe dimensions relative to BeginPin.
//

typedef struct _PIPE_DIMENSIONS {
    KS_COMPRESSION    AllocatorPin;
    KS_COMPRESSION    MaxExpansionPin;
    KS_COMPRESSION    EndPin;
} PIPE_DIMENSIONS, *PPIPE_DIMENSIONS;


typedef enum {
    Pipe_Allocator_None,
    Pipe_Allocator_FirstPin,
    Pipe_Allocator_LastPin,
    Pipe_Allocator_MiddlePin
} PIPE_ALLOCATOR_PLACE;

typedef PIPE_ALLOCATOR_PLACE  *PPIPE_ALLOCATOR_PLACE;


typedef enum {
    KS_MemoryTypeDontCare = 0,
    KS_MemoryTypeKernelPaged,
    KS_MemoryTypeKernelNonPaged,
    KS_MemoryTypeDeviceHostMapped,
    KS_MemoryTypeDeviceSpecific,
    KS_MemoryTypeUser,
    KS_MemoryTypeAnyHost
} KS_LogicalMemoryType;

typedef KS_LogicalMemoryType  *PKS_LogicalMemoryType;



typedef struct _PIPE_TERMINATION {
    ULONG                       Flags;
    ULONG                       OutsideFactors;
    ULONG                       Weigth;            // outside weight
    KS_FRAMING_RANGE            PhysicalRange;
    KS_FRAMING_RANGE_WEIGHTED   OptimalRange;      
    KS_COMPRESSION              Compression;       // relative to the connected pin on a neighboring filter.
} PIPE_TERMINATION;


//
// extended allocator properties 
//
typedef struct _ALLOCATOR_PROPERTIES_EX
    {
    long cBuffers;
    long cbBuffer;
    long cbAlign;
    long cbPrefix;
// new part
    GUID                       MemoryType;         
    GUID                       BusType;            // one of the buses this pipe is using
    PIPE_STATE                 State;                        
    PIPE_TERMINATION           Input;                        
    PIPE_TERMINATION           Output;                       
    ULONG                      Strategy;
    ULONG                      Flags;              
    ULONG                      Weight;
    KS_LogicalMemoryType       LogicalMemoryType;
    PIPE_ALLOCATOR_PLACE       AllocatorPlace;
    PIPE_DIMENSIONS            Dimensions;
    KS_FRAMING_RANGE           PhysicalRange;      // on allocator pin
    IKsAllocatorEx*            PrevSegment;        // doubly-linked list of KS allocators
    ULONG                      CountNextSegments;  // possible multiple dependent pipes
    IKsAllocatorEx**           NextSegments;
    ULONG                      InsideFactors;      // existing factors (different from "don't care")
    ULONG                      NumberPins;                   
} ALLOCATOR_PROPERTIES_EX;

typedef ALLOCATOR_PROPERTIES_EX *PALLOCATOR_PROPERTIES_EX;


#ifdef __STREAMS__

struct DECLSPEC_UUID("5C5CBD84-E755-11D0-AC18-00A0C9223196") IKsClockPropertySet;
#undef INTERFACE
#define INTERFACE IKsClockPropertySet
DECLARE_INTERFACE_(IKsClockPropertySet, IUnknown)
{
    STDMETHOD(KsGetTime)(
        THIS_
        LONGLONG* Time
    ) PURE;
    STDMETHOD(KsSetTime)(
        THIS_
        LONGLONG Time
    ) PURE;
    STDMETHOD(KsGetPhysicalTime)(
        THIS_
        LONGLONG* Time
    ) PURE;
    STDMETHOD(KsSetPhysicalTime)(
        THIS_
        LONGLONG Time
    ) PURE;
    STDMETHOD(KsGetCorrelatedTime)(
        THIS_
        KSCORRELATED_TIME* CorrelatedTime
    ) PURE;
    STDMETHOD(KsSetCorrelatedTime)(
        THIS_
        KSCORRELATED_TIME* CorrelatedTime
    ) PURE;
    STDMETHOD(KsGetCorrelatedPhysicalTime)(
        THIS_
        KSCORRELATED_TIME* CorrelatedTime
    ) PURE;
    STDMETHOD(KsSetCorrelatedPhysicalTime)(
        THIS_
        KSCORRELATED_TIME* CorrelatedTime
    ) PURE;
    STDMETHOD(KsGetResolution)(
        THIS_
        KSRESOLUTION* Resolution
    ) PURE;
    STDMETHOD(KsGetState)(
        THIS_
        KSSTATE* State
    ) PURE;
};


interface DECLSPEC_UUID("8da64899-c0d9-11d0-8413-0000f822fe8a") IKsAllocator;
#undef INTERFACE
#define INTERFACE IKsAllocator
DECLARE_INTERFACE_(IKsAllocator, IUnknown)
{
    STDMETHOD_(HANDLE, KsGetAllocatorHandle)(
        THIS
    ) PURE;
    STDMETHOD_(KSALLOCATORMODE, KsGetAllocatorMode)(
        THIS
    ) PURE;
    STDMETHOD(KsGetAllocatorStatus)(
        THIS_
        PKSSTREAMALLOCATOR_STATUS AllocatorStatus
    ) PURE;
    STDMETHOD_(VOID, KsSetAllocatorMode)(
        THIS_
        KSALLOCATORMODE Mode
    ) PURE;
};

interface DECLSPEC_UUID("091bb63a-603f-11d1-b067-00a0c9062802") IKsAllocatorEx;
#undef INTERFACE
#define INTERFACE IKsAllocatorEx
DECLARE_INTERFACE_(IKsAllocatorEx, IKsAllocator)
{
    STDMETHOD_(PALLOCATOR_PROPERTIES_EX, KsGetProperties)(
        THIS
    ) PURE;
    STDMETHOD_(VOID, KsSetProperties)(
        THIS_
        PALLOCATOR_PROPERTIES_EX 
    ) PURE;
    STDMETHOD_(VOID, KsSetAllocatorHandle)(
        THIS_
        HANDLE AllocatorHandle
    ) PURE;
    STDMETHOD_(HANDLE, KsCreateAllocatorAndGetHandle)(
        THIS_
        IKsPin*   KsPin
    ) PURE;
};  

typedef enum {
    KsPeekOperation_PeekOnly,
    KsPeekOperation_AddRef
} KSPEEKOPERATION;

typedef struct _KSSTREAM_SEGMENT *PKSSTREAM_SEGMENT;

interface DECLSPEC_UUID("b61178d1-a2d9-11cf-9e53-00aa00a216a1") IKsPin;

#undef INTERFACE
#define INTERFACE IKsPin
DECLARE_INTERFACE_(IKsPin, IUnknown)
{
    STDMETHOD(KsQueryMediums)(
        THIS_
        PKSMULTIPLE_ITEM* MediumList
    ) PURE;
    STDMETHOD(KsQueryInterfaces)(
        THIS_
        PKSMULTIPLE_ITEM* InterfaceList
    ) PURE;
    STDMETHOD(KsCreateSinkPinHandle)(
        THIS_
        KSPIN_INTERFACE& Interface,
        KSPIN_MEDIUM& Medium
    ) PURE;
    STDMETHOD(KsGetCurrentCommunication)(
        THIS_
        KSPIN_COMMUNICATION *Communication,
        KSPIN_INTERFACE *Interface,
        KSPIN_MEDIUM *Medium
    ) PURE;
    STDMETHOD(KsPropagateAcquire)(
        THIS
    ) PURE;
    STDMETHOD(KsDeliver)(
        THIS_
        IMediaSample* Sample,
        ULONG Flags
    ) PURE;
    STDMETHOD(KsMediaSamplesCompleted)(
        THIS_
        PKSSTREAM_SEGMENT StreamSegment
    ) PURE;
    STDMETHOD_(IMemAllocator *, KsPeekAllocator)(
        THIS_
        KSPEEKOPERATION Operation
    ) PURE;
    STDMETHOD(KsReceiveAllocator)(
        THIS_
        IMemAllocator *MemAllocator
    ) PURE;
    STDMETHOD(KsRenegotiateAllocator)(
        THIS
    ) PURE;
    STDMETHOD_(LONG, KsIncrementPendingIoCount)(
        THIS
    ) PURE;
    STDMETHOD_(LONG, KsDecrementPendingIoCount)(
        THIS
    ) PURE;
    STDMETHOD(KsQualityNotify)(
        THIS_
        ULONG Proportion,
        REFERENCE_TIME TimeDelta
    ) PURE;
};

interface DECLSPEC_UUID("7bb38260-d19c-11d2-b38a-00a0c95ec22e") IKsPinEx;
#undef INTERFACE
#define INTERFACE IKsPinEx
DECLARE_INTERFACE_(IKsPinEx, IKsPin)
{
    STDMETHOD_(VOID, KsNotifyError)(
        THIS_
        IMediaSample* Sample,
        HRESULT hr
    ) PURE;        
};
                         
interface DECLSPEC_UUID("e539cd90-a8b4-11d1-8189-00a0c9062802") IKsPinPipe;
#undef INTERFACE
#define INTERFACE IKsPinPipe
DECLARE_INTERFACE_(IKsPinPipe, IUnknown)
{
    STDMETHOD(KsGetPinFramingCache)(
        THIS_
        PKSALLOCATOR_FRAMING_EX *FramingEx,
        PFRAMING_PROP FramingProp,
        FRAMING_CACHE_OPS Option
    ) PURE;
    STDMETHOD(KsSetPinFramingCache)(
        THIS_
        PKSALLOCATOR_FRAMING_EX FramingEx,
        PFRAMING_PROP FramingProp,
        FRAMING_CACHE_OPS Option
    ) PURE;
    STDMETHOD_(IPin*, KsGetConnectedPin)(
        THIS
    ) PURE;
    STDMETHOD_(IKsAllocatorEx*, KsGetPipe)(
        THIS_
        KSPEEKOPERATION Operation
    ) PURE;
    STDMETHOD(KsSetPipe)(
        THIS_
        IKsAllocatorEx *KsAllocator
    ) PURE;
    STDMETHOD_(ULONG, KsGetPipeAllocatorFlag)(
        THIS
    ) PURE;
    STDMETHOD(KsSetPipeAllocatorFlag)(
        THIS_
        ULONG Flag
    ) PURE;
    STDMETHOD_(GUID, KsGetPinBusCache)(
        THIS
    ) PURE;
    STDMETHOD(KsSetPinBusCache)(
        THIS_
        GUID Bus
    ) PURE;
//
// very useful methods for tracing.
//
    STDMETHOD_(PWCHAR, KsGetPinName)(
        THIS
    ) PURE;
    STDMETHOD_(PWCHAR, KsGetFilterName)(
        THIS
    ) PURE;
};


interface DECLSPEC_UUID("CD5EBE6B-8B6E-11D1-8AE0-00A0C9223196") IKsPinFactory;
#undef INTERFACE
#define INTERFACE IKsPinFactory
DECLARE_INTERFACE_(IKsPinFactory, IUnknown)
{
    STDMETHOD(KsPinFactory)(
        THIS_
        ULONG* PinFactory
    ) PURE;
};

typedef enum {
    KsIoOperation_Write,
    KsIoOperation_Read
} KSIOOPERATION;

interface DECLSPEC_UUID("5ffbaa02-49a3-11d0-9f36-00aa00a216a1") IKsDataTypeHandler;
#undef INTERFACE
#define INTERFACE IKsDataTypeHandler
DECLARE_INTERFACE_(IKsDataTypeHandler, IUnknown)
{
    STDMETHOD(KsCompleteIoOperation)(
        THIS_
        IMediaSample *Sample,
        PVOID StreamHeader,
        KSIOOPERATION IoOperation,
        BOOL Cancelled
    ) PURE;
    STDMETHOD(KsIsMediaTypeInRanges)(
        THIS_
        PVOID DataRanges
        ) PURE;
    STDMETHOD(KsPrepareIoOperation)(
        THIS_
        IMediaSample *Sample,
        PVOID StreamHeader,
        KSIOOPERATION IoOperation
    ) PURE;
    STDMETHOD(KsQueryExtendedSize)(
        THIS_
        ULONG* ExtendedSize
    ) PURE;
    STDMETHOD(KsSetMediaType)(
        THIS_
        const AM_MEDIA_TYPE* AmMediaType
    ) PURE;
};

interface DECLSPEC_UUID("827D1A0E-0F73-11D2-B27A-00A0C9223196") IKsDataTypeCompletion;
#undef INTERFACE
#define INTERFACE IKsDataTypeCompletion
DECLARE_INTERFACE_(IKsDataTypeCompletion, IUnknown)
{
    STDMETHOD(KsCompleteMediaType)(
        THIS_
        HANDLE FilterHandle,
        ULONG PinFactoryId,
        AM_MEDIA_TYPE* AmMediaType
    ) PURE;
};

interface DECLSPEC_UUID("D3ABC7E0-9A61-11d0-A40D-00A0C9223196") IKsInterfaceHandler;
#undef INTERFACE
#define INTERFACE IKsInterfaceHandler
DECLARE_INTERFACE_(IKsInterfaceHandler, IUnknown)
{
    STDMETHOD(KsSetPin)(
        THIS_
        IKsPin *KsPin
    ) PURE;
    STDMETHOD(KsProcessMediaSamples)(
        THIS_
        IKsDataTypeHandler *KsDataTypeHandler,
        IMediaSample** SampleList,
        PLONG SampleCount,
        KSIOOPERATION IoOperation,
        PKSSTREAM_SEGMENT *StreamSegment
    ) PURE;
    STDMETHOD(KsCompleteIo)(
        THIS_
        PKSSTREAM_SEGMENT StreamSegment
    ) PURE;
};


//
// This structure definition is the common header required by the proxy to 
// dispatch the stream segment to the interface handler.  Interface handlers 
// will create extended structures to include other information such as 
// media samples, extended header size and so on.
//

typedef struct _KSSTREAM_SEGMENT {
    IKsInterfaceHandler     *KsInterfaceHandler;
    IKsDataTypeHandler      *KsDataTypeHandler;
    KSIOOPERATION           IoOperation;
    HANDLE                  CompletionEvent;
    
} KSSTREAM_SEGMENT;

interface DECLSPEC_UUID("423c13a2-2070-11d0-9ef7-00aa00a216a1") IKsObject;
#undef INTERFACE
#define INTERFACE IKsObject
DECLARE_INTERFACE_(IKsObject, IUnknown)
{
    STDMETHOD_(HANDLE, KsGetObjectHandle)(
        THIS
    ) PURE;
};

interface DECLSPEC_UUID("97ebaacb-95bd-11d0-a3ea-00a0c9223196") IKsQualityForwarder;
#undef INTERFACE
#define INTERFACE IKsQualityForwarder
DECLARE_INTERFACE_(IKsQualityForwarder, IKsObject)
{
    STDMETHOD_(VOID, KsFlushClient)(
        THIS_
        IKsPin* Pin
    ) PURE;
};

KSDDKAPI
HRESULT
WINAPI
KsResolveRequiredAttributes(
    PKSDATARANGE DataRange,
    PKSMULTIPLE_ITEM Attributes OPTIONAL
    );

KSDDKAPI
HRESULT
WINAPI
KsOpenDefaultDevice(
    REFGUID Category,
    ACCESS_MASK Access,
    PHANDLE DeviceHandle
    );
KSDDKAPI
HRESULT
WINAPI
KsSynchronousDeviceControl(
    HANDLE      Handle,
    ULONG       IoControl,
    PVOID       InBuffer,
    ULONG       InLength,
    PVOID       OutBuffer,
    ULONG       OutLength,
    PULONG      BytesReturned
    );
KSDDKAPI
HRESULT
WINAPI
KsGetMultiplePinFactoryItems(
    HANDLE  FilterHandle,
    ULONG   PinFactoryId,
    ULONG   PropertyId,
    PVOID*  Items
    );
KSDDKAPI
HRESULT
WINAPI
KsGetMediaTypeCount(
    HANDLE      FilterHandle,
    ULONG       PinFactoryId,
    ULONG*      MediaTypeCount
    );
KSDDKAPI
HRESULT
WINAPI
KsGetMediaType(
    int         Position,
    AM_MEDIA_TYPE* AmMediaType,
    HANDLE      FilterHandle,
    ULONG       PinFactoryId
    );

#endif // __STREAMS__

#ifndef _IKsPropertySet_
#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsPropertySet);
#endif // !defined(__cplusplus) || _MSC_VER < 1100
#endif // _IKsPropertySet_

#ifndef _IKsControl_
#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsControl);
#endif // !defined(__cplusplus) || _MSC_VER < 1100
#endif // _IKsControl_

#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsAggregateControl);
#endif // !defined(__cplusplus) || _MSC_VER < 1100

#ifndef _IKsTopology_
#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsTopology);
#endif // !defined(__cplusplus) || _MSC_VER < 1100
#endif // _IKsTopology_

DEFINE_GUIDSTRUCT("17CCA71B-ECD7-11D0-B908-00A0C9223196", CLSID_Proxy);
#define CLSID_Proxy DEFINE_GUIDNAMED(CLSID_Proxy)

#else // !_KS_

#ifndef _IKsPropertySet_
#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUID(IID_IKsPropertySet, STATIC_IID_IKsPropertySet);
#endif // !defined(__cplusplus) || _MSC_VER < 1100
#endif // _IKsPropertySet_

#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUID(CLSID_Proxy, STATIC_CLSID_Proxy);
#else  // defined(__cplusplus) && _MSC_VER >= 1100
DECLSPEC_UUID("17CCA71B-ECD7-11D0-B908-00A0C9223196") CLSID_Proxy;
#endif  // defined(__cplusplus) && _MSC_VER >= 1100

#endif // !_KS_

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#define KSPROPERTY_SUPPORT_GET 1
#define KSPROPERTY_SUPPORT_SET 2

#ifdef DECLARE_INTERFACE_

interface DECLSPEC_UUID("31EFAC30-515C-11d0-A9AA-00aa0061be93") IKsPropertySet;
#undef INTERFACE
#define INTERFACE IKsPropertySet
DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    STDMETHOD(Set)(
        THIS_
        IN REFGUID PropSet,
        IN ULONG Id,
        IN LPVOID InstanceData,
        IN ULONG InstanceLength,
        IN LPVOID PropertyData,
        IN ULONG DataLength
    ) PURE;

    STDMETHOD(Get)(
        THIS_
        IN REFGUID PropSet,
        IN ULONG Id,
        IN LPVOID InstanceData,
        IN ULONG InstanceLength,
        OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;

    STDMETHOD(QuerySupported)(
        THIS_
        IN REFGUID PropSet,
        IN ULONG Id,
        OUT ULONG* TypeSupport
    ) PURE;
};

#endif // DECLARE_INTERFACE_

#endif // _IKsPropertySet_

#ifndef _IKsControl_
#define _IKsControl_

#ifdef DECLARE_INTERFACE_

interface DECLSPEC_UUID("28F54685-06FD-11D2-B27A-00A0C9223196") IKsControl;
#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl, IUnknown)
{
    STDMETHOD(KsProperty)(
        THIS_
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsMethod)(
        THIS_
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsEvent)(
        THIS_
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
};

#endif // DECLARE_INTERFACE_

#endif // _IKsControl_


#ifdef DECLARE_INTERFACE_

interface DECLSPEC_UUID("7F40EAC0-3947-11D2-874E-00A0C9223196") IKsAggregateControl;
#undef INTERFACE
#define INTERFACE IKsAggregateControl
DECLARE_INTERFACE_(IKsAggregateControl, IUnknown)
{
    STDMETHOD(KsAddAggregate)(
        THIS_
        IN REFGUID AggregateClass
    ) PURE;
    STDMETHOD(KsRemoveAggregate)(
        THIS_
        IN REFGUID AggregateClass
    ) PURE;
};

#endif // DECLARE_INTERFACE_

#ifndef _IKsTopology_
#define _IKsTopology_

#ifdef DECLARE_INTERFACE_

interface DECLSPEC_UUID("28F54683-06FD-11D2-B27A-00A0C9223196") IKsTopology;
#undef INTERFACE
#define INTERFACE IKsTopology
DECLARE_INTERFACE_(IKsTopology, IUnknown)
{
    STDMETHOD(CreateNodeInstance)(
        THIS_
        IN ULONG NodeId,
        IN ULONG Flags,
        IN ACCESS_MASK DesiredAccess,
        IN IUnknown* UnkOuter OPTIONAL,
        IN REFGUID InterfaceId,
        OUT LPVOID* Interface
    ) PURE;
};

#endif // DECLARE_INTERFACE_

#endif // _IKsTopology_

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __KSPROXY__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\kspaxp64.h ===
#include "kxalpha.h"

//
// Pointer size in bytes
//

#define SizeofPointer 0x8

//
// Process State Enumerated Type Values
//

#define ProcessInMemory 0x0
#define ProcessOutOfMemory 0x1
#define ProcessInTransition 0x2

//
// Thread State Enumerated Type Values
//

#define Initialized 0x0
#define Ready 0x1
#define Running 0x2
#define Standby 0x3
#define Terminated 0x4
#define Waiting 0x5

//
// Wait Reason and Wait Type Enumerated Type Values
//

#define WrExecutive 0x0
#define WrEventPair 0xe
#define WaitAny 0x1
#define WaitAll 0x0

//
// Apc State Structure Offset Definitions
//

#define AsApcListHead 0x0
#define AsProcess 0x20
#define AsKernelApcInProgress 0x28
#define AsKernelApcPending 0x29
#define AsUserApcPending 0x2a

//
// Bug Check Code Definitions
//

#define APC_INDEX_MISMATCH 0x1
#define ATTEMPTED_SWITCH_FROM_DPC 0xb8
#define DATA_BUS_ERROR 0x2e
#define DATA_COHERENCY_EXCEPTION 0x55
#define HAL1_INITIALIZATION_FAILED 0x61
#define INSTRUCTION_BUS_ERROR 0x2f
#define INSTRUCTION_COHERENCY_EXCEPTION 0x56
#define INTERRUPT_EXCEPTION_NOT_HANDLED 0x3d
#define INTERRUPT_UNWIND_ATTEMPTED 0x3c
#define INVALID_AFFINITY_SET 0x3
#define INVALID_DATA_ACCESS_TRAP 0x4
#define IRQL_GT_ZERO_AT_SYSTEM_SERVICE 0x4a
#define IRQL_NOT_LESS_OR_EQUAL 0xa
#define KMODE_EXCEPTION_NOT_HANDLED 0x1e
#define NMI_HARDWARE_FAILURE 0x80
#define NO_USER_MODE_CONTEXT 0xe
#define PAGE_FAULT_WITH_INTERRUPTS_OFF 0x49
#define PANIC_STACK_SWITCH 0x2b
#define SPIN_LOCK_INIT_FAILURE 0x81
#define SYSTEM_EXIT_OWNED_MUTEX 0x39
#define SYSTEM_SERVICE_EXCEPTION 0x3b
#define SYSTEM_UNWIND_PREVIOUS_USER 0x3a
#define TRAP_CAUSE_UNKNOWN 0x12
#define UNEXPECTED_KERNEL_MODE_TRAP 0x7f

//
// Breakpoint type definitions
//

#define DBG_STATUS_CONTROL_C 0x1

//
// Client Id Structure Offset Definitions
//

#define CidUniqueProcess 0x0
#define CidUniqueThread 0x8

//
// Critical Section Structure Offset Definitions
//

#define CsDebugInfo 0x0
#define CsLockCount 0x8
#define CsRecursionCount 0xc
#define CsOwningThread 0x10
#define CsLockSemaphore 0x18
#define CsSpinCount 0x20

//
// Critical Section Debug Information Structure Offset Definitions
//

#define CsType 0x0
#define CsCreatorBackTraceIndex 0x2
#define CsCriticalSection 0x8
#define CsProcessLocksList 0x10
#define CsEntryCount 0x20
#define CsContentionCount 0x24

//
// Dispatcher Context Structure Offset Definitions
//

#define DcControlPc 0x0
#define DcFunctionEntry 0x8
#define DcEstablisherFrame 0x10
#define DcContextRecord 0x18

//
// Exception Record Offset, Flag, and Enumerated Type Definitions
//

#define EXCEPTION_NONCONTINUABLE 0x1
#define EXCEPTION_UNWINDING 0x2
#define EXCEPTION_EXIT_UNWIND 0x4
#define EXCEPTION_STACK_INVALID 0x8
#define EXCEPTION_NESTED_CALL 0x10
#define EXCEPTION_TARGET_UNWIND 0x20
#define EXCEPTION_COLLIDED_UNWIND 0x40
#define EXCEPTION_UNWIND 0x66
#define EXCEPTION_EXECUTE_HANDLER 0x1
#define EXCEPTION_CONTINUE_SEARCH 0x0
#define EXCEPTION_CONTINUE_EXECUTION 0xffffffff

#define ExceptionContinueExecution 0x0
#define ExceptionContinueSearch 0x1
#define ExceptionNestedException 0x2
#define ExceptionCollidedUnwind 0x3

#define ErExceptionCode 0x0
#define ErExceptionFlags 0x4
#define ErExceptionRecord 0x8
#define ErExceptionAddress 0x10
#define ErNumberParameters 0x18
#define ErExceptionInformation 0x20
#define ExceptionRecordLength 0xa0

//
// Fast Mutex Structure Offset Definitions
//

#define FmCount 0x0
#define FmOwner 0x8
#define FmContention 0x10
#define FmEvent 0x18
#define FmOldIrql 0x30

//
// Interrupt Priority Request Level Definitions
//

#define APC_LEVEL 0x1
#define DISPATCH_LEVEL 0x2
#define IPI_LEVEL 0x6
#define POWER_LEVEL 0x7
#define PROFILE_LEVEL 0x3
#define HIGH_LEVEL 0x7
#define SYNCH_LEVEL 0x5

//
// Large Integer Structure Offset Definitions
//

#define LiLowPart 0x0
#define LiHighPart 0x4

//
// List Entry Structure Offset Definitions
//

#define LsFlink 0x0
#define LsBlink 0x8

//
// String Structure Offset Definitions
//

#define StrLength 0x0
#define StrMaximumLength 0x2
#define StrBuffer 0x8

//
// Time Structure Offset Definitions
//

#define TmLowTime 0x0
#define TmHighTime 0x4

//
// Thread Switch Counter Offset Definitions
//

#define TwFindAny 0x0
#define TwFindIdeal 0x4
#define TwFindLast 0x8
#define TwIdleAny 0xc
#define TwIdleCurrent 0x10
#define TwIdleIdeal 0x14
#define TwIdleLast 0x18
#define TwPreemptAny 0x1c
#define TwPreemptCurrent 0x20
#define TwPreemptLast 0x24
#define TwSwitchToIdle 0x28

//
// Status Code Definitions
//

#define STATUS_ALPHA_ARITHMETIC_EXCEPTION 0xc0000092
#define STATUS_ALPHA_BAD_VIRTUAL_ADDRESS 0xc0000005
#define STATUS_ALPHA_FLOATING_NOT_IMPLEMENTED 0xc000014a
#define STATUS_ALPHA_GENTRAP 0xc00000aa
#define STATUS_ALPHA_MACHINE_CHECK 0xdfff002e
#define STATUS_ILLEGAL_VLM_REFERENCE 0xc00002c0
#define STATUS_ACCESS_VIOLATION 0xc0000005
#define STATUS_ARRAY_BOUNDS_EXCEEDED 0xc000008c
#define STATUS_BAD_COMPRESSION_BUFFER 0xc0000242
#define STATUS_BREAKPOINT 0x80000003
#define STATUS_DATATYPE_MISALIGNMENT 0x80000002
#define STATUS_FLOAT_DENORMAL_OPERAND 0xc000008d
#define STATUS_FLOAT_DIVIDE_BY_ZERO 0xc000008e
#define STATUS_FLOAT_INEXACT_RESULT 0xc000008f
#define STATUS_FLOAT_INVALID_OPERATION 0xc0000090
#define STATUS_FLOAT_OVERFLOW 0xc0000091
#define STATUS_FLOAT_STACK_CHECK 0xc0000092
#define STATUS_FLOAT_UNDERFLOW 0xc0000093
#define STATUS_FLOAT_MULTIPLE_FAULTS 0xc00002b4
#define STATUS_FLOAT_MULTIPLE_TRAPS 0xc00002b5
#define STATUS_GUARD_PAGE_VIOLATION 0x80000001
#define STATUS_ILLEGAL_FLOAT_CONTEXT 0xc000014a
#define STATUS_ILLEGAL_INSTRUCTION 0xc000001d
#define STATUS_INSTRUCTION_MISALIGNMENT 0xc00000aa
#define STATUS_INVALID_HANDLE 0xc0000008
#define STATUS_INVALID_LOCK_SEQUENCE 0xc000001e
#define STATUS_INVALID_OWNER 0xc000005a
#define STATUS_INVALID_PARAMETER_1 0xc00000ef
#define STATUS_INVALID_SYSTEM_SERVICE 0xc000001c
#define STATUS_INTEGER_DIVIDE_BY_ZERO 0xc0000094
#define STATUS_INTEGER_OVERFLOW 0xc0000095
#define STATUS_IN_PAGE_ERROR 0xc0000006
#define STATUS_KERNEL_APC 0x100
#define STATUS_LONGJUMP 0x80000026
#define STATUS_NO_CALLBACK_ACTIVE 0xc0000258
#define STATUS_NO_EVENT_PAIR 0xc000014e
#define STATUS_PRIVILEGED_INSTRUCTION 0xc0000096
#define STATUS_SINGLE_STEP 0x80000004
#define STATUS_STACK_OVERFLOW 0xc00000fd
#define STATUS_SUCCESS 0x0
#define STATUS_THREAD_IS_TERMINATING 0xc000004b
#define STATUS_TIMEOUT 0x102
#define STATUS_UNWIND 0xc0000027
#define STATUS_WAKE_SYSTEM_DEBUGGER 0x80000007

//
// APC Object Structure Offset Definitions
//

#define ApType 0x0
#define ApSize 0x2
#define ApThread 0x8
#define ApApcListEntry 0x10
#define ApKernelRoutine 0x20
#define ApRundownRoutine 0x28
#define ApNormalRoutine 0x30
#define ApNormalContext 0x38
#define ApSystemArgument1 0x40
#define ApSystemArgument2 0x48
#define ApApcStateIndex 0x50
#define ApApcMode 0x51
#define ApInserted 0x52
#define ApcObjectLength 0x58

//
// DPC object Structure Offset Definitions
//

#define DpType 0x0
#define DpNumber 0x2
#define DpImportance 0x3
#define DpDpcListEntry 0x8
#define DpDeferredRoutine 0x18
#define DpDeferredContext 0x20
#define DpSystemArgument1 0x28
#define DpSystemArgument2 0x30
#define DpLock 0x38
#define DpcObjectLength 0x40

//
// Device Queue Object Structure Offset Definitions
//

#define DvType 0x0
#define DvSize 0x2
#define DvDeviceListHead 0x8
#define DvSpinLock 0x18
#define DvBusy 0x20
#define DeviceQueueObjectLength 0x28

//
// Device Queue Entry Structure Offset Definitions
//

#define DeDeviceListEntry 0x0
#define DeSortKey 0x10
#define DeInserted 0x14
#define DeviceQueueEntryLength 0x18

//
// Event Object Structure Offset Definitions
//

#define EvType 0x0
#define EvSize 0x2
#define EvSignalState 0x4
#define EvWaitListHead 0x8
#define EventObjectLength 0x18

//
// Event Pair Object Structure Offset Definitions
//

#define EpType 0x0
#define EpSize 0x2
#define EpEventLow 0x8
#define EpEventHigh 0x20

//
// Interrupt Object Structure Offset Definitions
//

#define InLevelSensitive 0x0
#define InLatched 0x1

#define InType 0x0
#define InSize 0x2
#define InInterruptListEntry 0x8
#define InServiceRoutine 0x18
#define InServiceContext 0x20
#define InSpinLock 0x28
#define InActualLock 0x38
#define InDispatchAddress 0x40
#define InVector 0x48
#define InIrql 0x4c
#define InSynchronizeIrql 0x4d
#define InFloatingSave 0x4e
#define InConnected 0x4f
#define InNumber 0x50
#define InMode 0x54
#define InShareVector 0x51
#define InDispatchCode 0x60
#define InterruptObjectLength 0x70

//
// Process Object Structure Offset Definitions
//

#define PrType 0x0
#define PrSize 0x2
#define PrSignalState 0x4
#define PrProfileListHead 0x18
#define PrDirectoryTableBase 0x28
#define PrActiveProcessors 0x38
#define PrRunOnProcessors 0x3c
#define PrProcessSequence 0x40
#define PrProcessAsn 0x48
#define PrKernelTime 0x4c
#define PrUserTime 0x50
#define PrReadyListHead 0x58
#define PrSwapListEntry 0x68
#define PrThreadListHead 0x78
#define PrProcessLock 0x88
#define PrAffinity 0x90
#define PrStackCount 0x94
#define PrBasePriority 0x96
#define PrThreadQuantum 0x97
#define PrAutoAlignment 0x98
#define PrState 0x99
#define ProcessObjectLength 0xa0
#define ExtendedProcessObjectLength 0x400

//
// Profile Object Structure Offset Definitions
//

#define PfType 0x0
#define PfSize 0x2
#define PfProfileListEntry 0x8
#define PfProcess 0x18
#define PfRangeBase 0x20
#define PfRangeLimit 0x28
#define PfBucketShift 0x30
#define PfBuffer 0x38
#define PfSegment 0x40
#define PfAffinity 0x44
#define PfSource 0x48
#define PfStarted 0x4a
#define ProfileObjectLength 0x50

//
// Queue Object Structure Offset Definitions
//

#define QuType 0x0
#define QuSize 0x2
#define QuSignalState 0x4
#define QuEntryListHead 0x18
#define QuCurrentCount 0x28
#define QuMaximumCount 0x2c
#define QuThreadListHead 0x30
#define QueueObjectLength 0x40

//
// Thread Object Structure Offset Definitions
//

#define EeKernelEventPair 0x0
#define EtCid 0x368
#define EtPerformanceCountLow 0x3a4
#define EtPerformanceCountHigh 0x3fc
#define EtEthreadLength 0x410

#define ThType 0x0
#define ThSize 0x2
#define ThSignalState 0x4
#define ThMutantListHead 0x18
#define ThInitialStack 0x28
#define ThStackLimit 0x30
#define ThTeb 0x38
#define ThTlsArray 0x40
#define ThKernelStack 0x48
#define ThDebugActive 0x50
#define ThState 0x51
#define ThAlerted 0x52
#define ThIopl 0x54
#define ThNpxState 0x55
#define ThSaturation 0x56
#define ThPriority 0x57
#define ThApcState 0x58
#define ThContextSwitches 0x88
#define ThWaitStatus 0x90
#define ThWaitIrql 0x98
#define ThWaitMode 0x99
#define ThWaitNext 0x9a
#define ThWaitReason 0x9b
#define ThWaitBlockList 0xa0
#define ThWaitListEntry 0xa8
#define ThWaitTime 0xb8
#define ThBasePriority 0xbc
#define ThDecrementCount 0xbd
#define ThPriorityDecrement 0xbe
#define ThQuantum 0xbf
#define ThWaitBlock 0xc0
#define ThKernelApcDisable 0x188
#define ThUserAffinity 0x18c
#define ThSystemAffinityActive 0x190
#define ThServiceTable 0x198
#define ThQueue 0x1a0
#define ThApcQueueLock 0x1a8
#define ThTimer 0x1b0
#define ThQueueListEntry 0x1f0
#define ThAffinity 0x200
#define ThPreempted 0x204
#define ThProcessReadyQueue 0x205
#define ThKernelStackResident 0x206
#define ThNextProcessor 0x207
#define ThCallbackStack 0x208
#define ThWin32Thread 0x210
#define ThTrapFrame 0x218
#define ThApcStatePointer 0x220
#define ThPreviousMode 0x230
#define ThEnableStackSwap 0x231
#define ThLargeStack 0x232
#define ThKernelTime 0x234
#define ThUserTime 0x238
#define ThSavedApcState 0x240
#define ThAlertable 0x270
#define ThApcStateIndex 0x271
#define ThApcQueueable 0x272
#define ThAutoAlignment 0x273
#define ThStackBase 0x278
#define ThSuspendApc 0x280
#define ThSuspendSemaphore 0x2d8
#define ThThreadListEntry 0x2f8
#define ThFreezeCount 0x308
#define ThSuspendCount 0x309
#define ThIdealProcessor 0x30a
#define ThDisableBoost 0x30b
#define ThreadObjectLength 0x310
#define ExtendedThreadObjectLength 0x410

#define EVENT_WAIT_BLOCK_OFFSET 0x120

//
// Timer object Structure Offset Definitions
//

#define TiType 0x0
#define TiSize 0x2
#define TiInserted 0x3
#define TiSignalState 0x4
#define TiDueTime 0x18
#define TiTimerListEntry 0x20
#define TiDpc 0x30
#define TiPeriod 0x38
#define TimerObjectLength 0x40

#define TIMER_TABLE_SIZE 0x80

//
// Wait Block Structure Offset Definitions
//

#define WbWaitListEntry 0x0
#define WbThread 0x10
#define WbObject 0x18
#define WbNextWaitBlock 0x20
#define WbWaitKey 0x28
#define WbWaitType 0x2a

//
// Fiber Structure Offset Definitions
//

#define FbFiberData 0x0
#define FbExceptionList 0x8
#define FbStackBase 0x10
#define FbStackLimit 0x18
#define FbDeallocationStack 0x20
#define FbFiberContext 0x28
#define FbWx86Tib 0x258

//
// Process Environment Block Structure Offset Definitions
//

#define PeKernelCallbackTable 0x58

//
// System Service Descriptor Table Structure Definitions
//

#define NUMBER_SERVICE_TABLES 0x4
#define SERVICE_NUMBER_MASK 0xfff
#define SERVICE_TABLE_SHIFT 0x7
#define SERVICE_TABLE_MASK 0x60
#define SERVICE_TABLE_TEST 0x20

#define SdBase 0x0
#define SdCount 0x8
#define SdLimit 0x10
#define SdNumber 0x18

//
// Thread Environment Block Structure Offset Definitions
//

#define TeStackBase 0x8
#define TeStackLimit 0x10
#define TeFiberData 0x20
#define TeEnvironmentPointer 0x38
#define TeClientId 0x40
#define TeActiveRpcHandle 0x50
#define TeThreadLocalStoragePointer 0x58
#define TeCountOfOwnedCriticalSections 0x6c
#define TePeb 0x60
#define TeCsrClientThread 0x70
#define TeWOW32Reserved 0x100
#define TeSoftFpcr 0x10c
#define TeGdiClientPID 0x7f0
#define TeGdiClientTID 0x7f4
#define TeGdiThreadLocalInfo 0x7f8
#define TeglDispatchTable 0x9f0
#define TeglReserved1 0x1138
#define TeglReserved2 0x1220
#define TeglSectionInfo 0x1228
#define TeglSection 0x1230
#define TeglTable 0x1238
#define TeglCurrentRC 0x1240
#define TeglContext 0x1248
#define TeDeallocationStack 0x1478
#define TeTlsSlots 0x1480
#define TeVdm 0x1690
#define TeGdiBatchCount 0x1740
#define TeInstrumentation 0x16b8
#define ThreadEnvironmentBlockLength 0x1798

//
// Lock Queue Structure Offset Definitions
//

#define LOCK_QUEUE_WAIT 0x1
#define LOCK_QUEUE_OWNER 0x2
#define LOCK_QUEUE_HEADER_SIZE 0x10

#define LockQueueDispatcherLock 0x0
#define LockQueueContextSwapLock 0x1
#define LockQueuePfnLock 0x2

#define LqNext 0x0
#define LqLock 0x8

//
// Processor Control Registers Structure Offset Definitions
//

#define PCR_MINOR_VERSION 0x1
#define PCR_MAJOR_VERSION 0x1
#define PcMinorVersion 0x0
#define PcMajorVersion 0x4
#define PcPalBaseAddress 0x8
#define PcPalMajorVersion 0x10
#define PcPalMinorVersion 0x14
#define PcPalSequenceVersion 0x18
#define PcPalMajorSpecification 0x1c
#define PcPalMinorSpecification 0x20
#define PcFirmwareRestartAddress 0x28
#define PcRestartBlock 0x30
#define PcPalReserved 0x38
#define PcPalAlignmentFixupCount 0xc30
#define PcPanicStack 0xc38
#define PcProcessorType 0xc40
#define PcProcessorRevision 0xc44
#define PcPhysicalAddressBits 0xc48
#define PcMaximumAddressSpaceNumber 0xc4c
#define PcPageSize 0xc50
#define PcFirstLevelDcacheSize 0xc54
#define PcFirstLevelDcacheFillSize 0xc58
#define PcFirstLevelIcacheSize 0xc5c
#define PcFirstLevelIcacheFillSize 0xc60
#define PcFirmwareRevisionId 0xc64
#define PcSystemType 0xc68
#define PcSystemVariant 0xc70
#define PcSystemRevision 0xc74
#define PcSystemSerialNumber 0xc78
#define PcCycleClockPeriod 0xc88
#define PcSecondLevelCacheSize 0xc8c
#define PcSecondLevelCacheFillSize 0xc90
#define PcThirdLevelCacheSize 0xc94
#define PcThirdLevelCacheFillSize 0xc98
#define PcFourthLevelCacheSize 0xc9c
#define PcFourthLevelCacheFillSize 0xca0
#define PcPrcb 0xca8
#define PcNumber 0xcb0
#define PcSetMember 0xcb4
#define PcHalReserved 0xcb8
#define PcIrqlTable 0xeb8
#define PcIrqlMask 0xed8
#define PcInterruptRoutine 0x10e8
#define PcReservedVectors 0x18e8
#define PcMachineCheckError 0x18f8
#define PcDpcStack 0x1900
#define PcNotMember 0x18ec
#define PcCurrentPid 0x190c
#define PcSystemServiceDispatchStart 0x1918
#define PcSystemServiceDispatchEnd 0x1920
#define PcIdleThread 0x1928
#define ProcessorControlRegisterLength 0x1930
#define SharedUserData 0xffffffffff000000
#define UsTickCountLow 0x0
#define UsTickCountMultiplier 0x4
#define UsInterruptTime 0x8
#define UsSystemTime 0x10

//
// Processor Block Structure Offset Definitions
//

#define PRCB_MINOR_VERSION 0x1
#define PRCB_MAJOR_VERSION 0x2
#define PbMinorVersion 0x0
#define PbMajorVersion 0x2
#define PbCurrentThread 0x8
#define PbNextThread 0x10
#define PbIdleThread 0x18
#define PbNumber 0x20
#define PbBuildType 0x22
#define PbSetMember 0x24
#define PbRestartBlock 0x28
#define PbInterruptCount 0x30
#define PbDpcTime 0x34
#define PbInterruptTime 0x38
#define PbKernelTime 0x3c
#define PbUserTime 0x40
#define PbQuantumEndDpc 0x48
#define PbIpiFrozen 0xa0
#define PbIpiCounts 0x348
#define PbProcessorState 0xa8
#define PbAlignmentFixupCount 0x378
#define PbContextSwitches 0x37c
#define PbDcacheFlushCount 0x380
#define PbExceptionDispatchCount 0x384
#define PbFirstLevelTbFills 0x388
#define PbFloatingEmulationCount 0x38c
#define PbIcacheFlushCount 0x390
#define PbSecondLevelTbFills 0x394
#define PbSystemCalls 0x398
#define PbLockQueue 0x5e8
#define PbCurrentPacket 0x6e8
#define PbTargetSet 0x700
#define PbWorkerRoutine 0x708
#define PbRequestSummary 0x740
#define PbDpcListHead 0x7e8
#define PbDpcLock 0x7f8
#define PbDpcCount 0x800
#define PbLastDpcCount 0x2d8
#define PbQuantumEnd 0x804
#define PbStartCount 0x7e0
#define PbSoftwareInterrupts 0x2e0
#define PbInterruptTrapFrame 0x2e8
#define PbDpcRoutineActive 0x808
#define PbDpcQueueDepth 0x80c
#define PbDpcRequestRate 0x7dc
#define PbDpcBypassCount 0x2dc
#define PbApcBypassCount 0x2f0
#define PbDispatchInterruptCount 0x2f4
#define PbDebugDpcTime 0x2f8
#define PbDpcInterruptRequested 0x780
#define PbMaximumDpcQueueDepth 0x7d0
#define PbMinimumDpcRate 0x7d4
#define PbAdjustDpcThreshold 0x7d8
#define PbPowerState 0x818
#define ProcessorBlockLength 0x8b0

//
// Processor Power State Offset Definitions
//

#define PpIdleFunction 0x0

//
// Immediate Interprocessor Command Definitions
//

#define IPI_APC 0x1
#define IPI_DPC 0x2
#define IPI_FREEZE 0x4
#define IPI_PACKET_READY 0x8

//
// Interprocessor Interrupt Count Structure Offset Definitions
//

#define IcFreeze 0x0
#define IcPacket 0x4
#define IcDPC 0x8
#define IcAPC 0xc
#define IcFlushSingleTb 0x10
#define IcFlushEntireTb 0x18
#define IcChangeColor 0x20
#define IcSweepDcache 0x24
#define IcSweepIcache 0x28
#define IcSweepIcacheRange 0x2c
#define IcFlushIoBuffers 0x30

//
// LPC Structure Offset Definitions
//

#define PmLength 0x0
#define PmClientId 0x8
#define PmProcess 0x8
#define PmThread 0x10
#define PmMessageId 0x18
#define PmClientViewSize 0x20
#define PortMessageLength 0x28

//
// Client Id Structure Offset Definitions
//

#define CidUniqueProcess 0x0
#define CidUniqueThread 0x8

//
// Context Frame Offset and Flag Definitions
//

#define CONTEXT_FULL 0x20007
#define CONTEXT_CONTROL 0x20001
#define CONTEXT_FLOATING_POINT 0x20002
#define CONTEXT_INTEGER 0x20004

#define CxFltF0 0x0
#define CxFltF1 0x8
#define CxFltF2 0x10
#define CxFltF3 0x18
#define CxFltF4 0x20
#define CxFltF5 0x28
#define CxFltF6 0x30
#define CxFltF7 0x38
#define CxFltF8 0x40
#define CxFltF9 0x48
#define CxFltF10 0x50
#define CxFltF11 0x58
#define CxFltF12 0x60
#define CxFltF13 0x68
#define CxFltF14 0x70
#define CxFltF15 0x78
#define CxFltF16 0x80
#define CxFltF17 0x88
#define CxFltF18 0x90
#define CxFltF19 0x98
#define CxFltF20 0xa0
#define CxFltF21 0xa8
#define CxFltF22 0xb0
#define CxFltF23 0xb8
#define CxFltF24 0xc0
#define CxFltF25 0xc8
#define CxFltF26 0xd0
#define CxFltF27 0xd8
#define CxFltF28 0xe0
#define CxFltF29 0xe8
#define CxFltF30 0xf0
#define CxFltF31 0xf8
#define CxIntV0 0x100
#define CxIntT0 0x108
#define CxIntT1 0x110
#define CxIntT2 0x118
#define CxIntT3 0x120
#define CxIntT4 0x128
#define CxIntT5 0x130
#define CxIntT6 0x138
#define CxIntT7 0x140
#define CxIntS0 0x148
#define CxIntS1 0x150
#define CxIntS2 0x158
#define CxIntS3 0x160
#define CxIntS4 0x168
#define CxIntS5 0x170
#define CxIntFp 0x178
#define CxIntA0 0x180
#define CxIntA1 0x188
#define CxIntA2 0x190
#define CxIntA3 0x198
#define CxIntA4 0x1a0
#define CxIntA5 0x1a8
#define CxIntT8 0x1b0
#define CxIntT9 0x1b8
#define CxIntT10 0x1c0
#define CxIntT11 0x1c8
#define CxIntRa 0x1d0
#define CxIntT12 0x1d8
#define CxIntAt 0x1e0
#define CxIntGp 0x1e8
#define CxIntSp 0x1f0
#define CxIntZero 0x1f8
#define CxFpcr 0x200
#define CxSoftFpcr 0x208
#define CxFir 0x210
#define CxPsr 0x218
#define CxContextFlags 0x21c
#define ContextFrameLength 0x230

//
// Exception Frame Offset Definitions and Length
//

#define ExFltF2 0x8
#define ExFltF3 0x10
#define ExFltF4 0x18
#define ExFltF5 0x20
#define ExFltF6 0x28
#define ExFltF7 0x30
#define ExFltF8 0x38
#define ExFltF9 0x40
#define ExIntS0 0x48
#define ExIntS1 0x50
#define ExIntS2 0x58
#define ExIntS3 0x60
#define ExIntS4 0x68
#define ExIntS5 0x70
#define ExIntFp 0x78
#define ExPsr 0x88
#define ExSwapReturn 0x80
#define ExIntRa 0x0
#define ExceptionFrameLength 0xa0

//
// Jump Offset Definitions and Length
//

#define JbFp 0x0
#define JbPc 0x8
#define JbSeb 0x10
#define JbType 0x18
#define JbFltF2 0x20
#define JbFltF3 0x28
#define JbFltF4 0x30
#define JbFltF5 0x38
#define JbFltF6 0x40
#define JbFltF7 0x48
#define JbFltF8 0x50
#define JbFltF9 0x58
#define JbIntS0 0x60
#define JbIntS1 0x68
#define JbIntS2 0x70
#define JbIntS3 0x78
#define JbIntS4 0x80
#define JbIntS5 0x88
#define JbIntS6 0x90
#define JbIntSp 0x98
#define JbFir 0xa0

//
// Trap Frame Offset Definitions and Length
//

#define TrFltF0 0x178
#define TrFltF1 0x188
#define TrFltF10 0x190
#define TrFltF11 0x198
#define TrFltF12 0x1a0
#define TrFltF13 0x1a8
#define TrFltF14 0x1b0
#define TrFltF15 0x1b8
#define TrFltF16 0x1c0
#define TrFltF17 0x1c8
#define TrFltF18 0x1d0
#define TrFltF19 0x1d8
#define TrFltF20 0x1e0
#define TrFltF21 0x1e8
#define TrFltF22 0x1f0
#define TrFltF23 0x1f8
#define TrFltF24 0x200
#define TrFltF25 0x208
#define TrFltF26 0x210
#define TrFltF27 0x218
#define TrFltF28 0x220
#define TrFltF29 0x228
#define TrFltF30 0x230
#define TrIntV0 0xf0
#define TrIntT0 0xf8
#define TrIntT1 0x100
#define TrIntT2 0x108
#define TrIntT3 0x110
#define TrIntT4 0x118
#define TrIntT5 0x120
#define TrIntT6 0x128
#define TrIntT7 0x130
#define TrIntFp 0x18
#define TrIntA0 0x20
#define TrIntA1 0x28
#define TrIntA2 0x30
#define TrIntA3 0x38
#define TrIntA4 0x168
#define TrIntA5 0x170
#define TrIntT8 0x138
#define TrIntT9 0x140
#define TrIntT10 0x148
#define TrIntT11 0x150
#define TrIntT12 0x158
#define TrIntAt 0x160
#define TrIntGp 0x48
#define TrIntSp 0x0
#define TrFpcr 0x180
#define TrPsr 0x10
#define TrFir 0x8
#define TrExceptionRecord 0x50
#define TrOldIrql 0x238
#define TrPreviousMode 0x23c
#define TrIntRa 0x40
#define TrTrapFrame 0x240
#define TrapFrameLength 0x260

//
// Firmware frame offset defintions and length
//

#define FW_EXC_MCHK 0xdec0
#define FW_EXC_ARITH 0xdec1
#define FW_EXC_INTERRUPT 0xdec2
#define FW_EXC_DFAULT 0xdec3
#define FW_EXC_ITBMISS 0xdec4
#define FW_EXC_ITBACV 0xdec5
#define FW_EXC_NDTBMISS 0xdec6
#define FW_EXC_PDTBMISS 0xdec7
#define FW_EXC_UNALIGNED 0xdec8
#define FW_EXC_OPCDEC 0xdec9
#define FW_EXC_FEN 0xdeca
#define FW_EXC_HALT 0xdecb
#define FW_EXC_BPT 0xdecc
#define FW_EXC_GENTRAP 0xdecd
#define FW_EXC_HALT_INTERRUPT 0xdece
#define FwType 0x0
#define FwParam1 0x8
#define FwParam2 0x10
#define FwParam3 0x18
#define FwParam4 0x20
#define FwParam5 0x28
#define FwPsr 0x30
#define FwMmcsr 0x38
#define FwVa 0x40
#define FwFir 0x48
#define FwIntV0 0x50
#define FwIntT0 0x58
#define FwIntT1 0x60
#define FwIntT2 0x68
#define FwIntT3 0x70
#define FwIntT4 0x78
#define FwIntT5 0x80
#define FwIntT6 0x88
#define FwIntT7 0x90
#define FwIntS0 0x98
#define FwIntS1 0xa0
#define FwIntS2 0xa8
#define FwIntS3 0xb0
#define FwIntS4 0xb8
#define FwIntS5 0xc0
#define FwIntFp 0xc8
#define FwIntA0 0xd0
#define FwIntA1 0xd8
#define FwIntA2 0xe0
#define FwIntA3 0xe8
#define FwIntA4 0xf0
#define FwIntA5 0xf8
#define FwIntT8 0x100
#define FwIntT9 0x108
#define FwIntT10 0x110
#define FwIntT11 0x118
#define FwIntRa 0x120
#define FwIntT12 0x128
#define FwIntAt 0x130
#define FwIntGp 0x138
#define FwIntSp 0x140
#define FwIntZero 0x148
#define FwFltF0 0x150
#define FwFltF1 0x158
#define FwFltF2 0x160
#define FwFltF3 0x168
#define FwFltF4 0x170
#define FwFltF5 0x178
#define FwFltF6 0x180
#define FwFltF7 0x188
#define FwFltF8 0x190
#define FwFltF9 0x198
#define FwFltF10 0x1a0
#define FwFltF11 0x1a8
#define FwFltF12 0x1b0
#define FwFltF13 0x1b8
#define FwFltF14 0x1c0
#define FwFltF15 0x1c8
#define FwFltF16 0x1d0
#define FwFltF17 0x1d8
#define FwFltF18 0x1e0
#define FwFltF19 0x1e8
#define FwFltF20 0x1f0
#define FwFltF21 0x1f8
#define FwFltF22 0x200
#define FwFltF23 0x208
#define FwFltF24 0x210
#define FwFltF25 0x218
#define FwFltF26 0x220
#define FwFltF27 0x228
#define FwFltF28 0x230
#define FwFltF29 0x238
#define FwFltF30 0x240
#define FwFltF31 0x248
#define FirmwareFrameLength 0x250

//
// Usermode callout frame definitions
//

#define CuF2 0x0
#define CuF3 0x8
#define CuF4 0x10
#define CuF5 0x18
#define CuF6 0x20
#define CuF7 0x28
#define CuF8 0x30
#define CuF9 0x38
#define CuS0 0x40
#define CuS1 0x48
#define CuS2 0x50
#define CuS3 0x58
#define CuS4 0x60
#define CuS5 0x68
#define CuFP 0x70
#define CuCbStk 0x78
#define CuInStk 0x80
#define CuTrFr 0x88
#define CuTrFir 0x90
#define CuRa 0x98
#define CuA0 0xa0
#define CuA1 0xa8
#define CuFrameLength 0xb0

//
// Usermode callout user frame definitions
//

#define CkBuffer 0x0
#define CkLength 0x8
#define CkApiNumber 0xc
#define CkSp 0x18
#define CkRa 0x20

//
// KFLOATING_SAVE definitions
//

#define KfsFpcr 0x0
#define KfsSoftFpcr 0x8
#define KfsReserved1 0x10
#define KfsReserved2 0x14
#define KfsReserved3 0x18
#define KfsReserved4 0x1c

//
// Loader Parameter Block Offset Definitions
//

#define LpbLoadOrderListHead 0x0
#define LpbMemoryDescriptorListHead 0x10
#define LpbKernelStack 0x30
#define LpbPrcb 0x38
#define LpbProcess 0x40
#define LpbThread 0x48
#define LpbRegistryLength 0x50
#define LpbRegistryBase 0x58
#define LpbDpcStack 0xb8
#define LpbFirstLevelDcacheSize 0xc0
#define LpbFirstLevelDcacheFillSize 0xc4
#define LpbFirstLevelIcacheSize 0xc8
#define LpbFirstLevelIcacheFillSize 0xcc
#define LpbGpBase 0xd0
#define LpbPanicStack 0xd8
#define LpbPcrPage 0xe0
#define LpbPdrPage 0xe4
#define LpbSecondLevelDcacheSize 0xe8
#define LpbSecondLevelDcacheFillSize 0xec
#define LpbSecondLevelIcacheSize 0xf0
#define LpbSecondLevelIcacheFillSize 0xf4
#define LpbPhysicalAddressBits 0xf8
#define LpbMaximumAddressSpaceNumber 0xfc
#define LpbSystemSerialNumber 0x100
#define LpbSystemType 0x110
#define LpbSystemVariant 0x118
#define LpbSystemRevision 0x11c
#define LpbProcessorType 0x120
#define LpbProcessorRevision 0x124
#define LpbCycleClockPeriod 0x128
#define LpbPageSize 0x12c
#define LpbRestartBlock 0x130
#define LpbFirmwareRestartAddress 0x138
#define LpbFirmwareRevisionId 0x140
#define LpbPalBaseAddress 0x148

//
// Restart Block Structure Definitions
//

#define RbSignature 0x0
#define RbLength 0x4
#define RbVersion 0x8
#define RbRevision 0xa
#define RbNextRestartBlock 0xc
#define RbRestartAddress 0x10
#define RbBootMasterId 0x14
#define RbProcessorId 0x18
#define RbBootStatus 0x1c
#define RbCheckSum 0x20
#define RbSaveAreaLength 0x24
#define RbSaveArea 0x28
#define RbHaltReason 0x28
#define RbLogoutFrame 0x2c
#define RbPalBase 0x30
#define RbIntV0 0x38
#define RbIntT0 0x40
#define RbIntT1 0x48
#define RbIntT2 0x50
#define RbIntT3 0x58
#define RbIntT4 0x60
#define RbIntT5 0x68
#define RbIntT6 0x70
#define RbIntT7 0x78
#define RbIntS0 0x80
#define RbIntS1 0x88
#define RbIntS2 0x90
#define RbIntS3 0x98
#define RbIntS4 0xa0
#define RbIntS5 0xa8
#define RbIntFp 0xb0
#define RbIntA0 0xb8
#define RbIntA1 0xc0
#define RbIntA2 0xc8
#define RbIntA3 0xd0
#define RbIntA4 0xd8
#define RbIntA5 0xe0
#define RbIntT8 0xe8
#define RbIntT9 0xf0
#define RbIntT10 0xf8
#define RbIntT11 0x100
#define RbIntRa 0x108
#define RbIntT12 0x110
#define RbIntAT 0x118
#define RbIntGp 0x120
#define RbIntSp 0x128
#define RbIntZero 0x130
#define RbFpcr 0x138
#define RbFltF0 0x140
#define RbFltF1 0x148
#define RbFltF2 0x150
#define RbFltF3 0x158
#define RbFltF4 0x160
#define RbFltF5 0x168
#define RbFltF6 0x170
#define RbFltF7 0x178
#define RbFltF8 0x180
#define RbFltF9 0x188
#define RbFltF10 0x190
#define RbFltF11 0x198
#define RbFltF12 0x1a0
#define RbFltF13 0x1a8
#define RbFltF14 0x1b0
#define RbFltF15 0x1b8
#define RbFltF16 0x1c0
#define RbFltF17 0x1c8
#define RbFltF18 0x1d0
#define RbFltF19 0x1d8
#define RbFltF20 0x1e0
#define RbFltF21 0x1e8
#define RbFltF22 0x1f0
#define RbFltF23 0x1f8
#define RbFltF24 0x200
#define RbFltF25 0x208
#define RbFltF26 0x210
#define RbFltF27 0x218
#define RbFltF28 0x220
#define RbFltF29 0x228
#define RbFltF30 0x230
#define RbFltF31 0x238
#define RbAsn 0x240
#define RbGeneralEntry 0x244
#define RbIksp 0x248
#define RbInterruptEntry 0x24c
#define RbKgp 0x250
#define RbMces 0x254
#define RbMemMgmtEntry 0x258
#define RbPanicEntry 0x25c
#define RbPcr 0x260
#define RbPdr 0x264
#define RbPsr 0x268
#define RbReiRestartAddress 0x26c
#define RbSirr 0x270
#define RbSyscallEntry 0x274
#define RbTeb 0x278
#define RbThread 0x27c
#define RbPerProcessorState 0x280

//
// Address Space Layout Definitions
//

#define KSEG0_BASE 0xffffffff80000000
#define KSEG2_BASE 0xffffffffc0000000
#define SYSTEM_BASE 0xfffffe0200000000
#define PDE_BASE 0xfffffe01807fe000
#define PTE_BASE 0xfffffe0000000000
#define PDE64_BASE 0xfffffe0180600000
#define PTE64_BASE 0xfffffe0000000000

//
// Page Table and Directory Entry Definitions
//

#define PAGE_SIZE 0x2000
#define PAGE_SHIFT 0xd
#define PDI_SHIFT 0x17
#define PTI_SHIFT 0xd

//
// Breakpoint Definitions
//

#define USER_BREAKPOINT 0x0
#define KERNEL_BREAKPOINT 0x1
#define BREAKIN_BREAKPOINT 0x19
#define DEBUG_PRINT_BREAKPOINT 0x14
#define DEBUG_PROMPT_BREAKPOINT 0x15
#define DEBUG_STOP_BREAKPOINT 0x16
#define DEBUG_LOAD_SYMBOLS_BREAKPOINT 0x17
#define DEBUG_UNLOAD_SYMBOLS_BREAKPOINT 0x18

//
// Trap Code Definitions
//

#define GENTRAP_INTEGER_OVERFLOW 0xffffffff
#define GENTRAP_INTEGER_DIVIDE_BY_ZERO 0xfffffffe
#define GENTRAP_FLOATING_OVERFLOW 0xfffffffd
#define GENTRAP_FLOATING_DIVIDE_BY_ZERO 0xfffffffc
#define GENTRAP_FLOATING_UNDERFLOW 0xfffffffb
#define GENTRAP_FLOATING_INVALID_OPERAND 0xfffffffa
#define GENTRAP_FLOATING_INEXACT_RESULT 0xfffffff9

//
// Miscellaneous Definitions
//

#define Executive 0x0
#define KernelMode 0x0
#define FALSE 0x0
#define TRUE 0x1
#define BASE_PRIORITY_THRESHOLD 0x8
#define EVENT_PAIR_INCREMENT 0x1
#define LOW_REALTIME_PRIORITY 0x10
#define MM_USER_PROBE_ADDRESS 0x000003ffffff0000
#define KERNEL_STACK_SIZE 0x6000
#define KERNEL_LARGE_STACK_COMMIT 0x4000
#define SET_LOW_WAIT_HIGH 0xfffffffe
#define SET_HIGH_WAIT_LOW 0xffffffff
#define CLOCK_QUANTUM_DECREMENT 0x3
#define READY_SKIP_QUANTUM 0x2
#define THREAD_QUANTUM 0x6
#define WAIT_QUANTUM_DECREMENT 0x1
#define ROUND_TRIP_DECREMENT_COUNT 0x10
#define PROCESSOR_ALPHA_21064 0x5248
#define PROCESSOR_ALPHA_21164 0x52ac
#define PROCESSOR_ALPHA_21066 0x524a
#define PROCESSOR_ALPHA_21068 0x524c
#define PROCESSOR_ALPHA_21164PC 0x52ad
#define PROCESSOR_ALPHA_21264 0x5310
#define PTE_VALID_MASK 0x1
#define PTE_VALID 0x0
#define PTE_FOW_MASK 0x4
#define PTE_FOW 0x2
#define PTE_GLOBAL_MASK 0x10
#define PTE_GLOBAL 0x4
#define PTE_GH_MASK 0x60
#define PTE_GH 0x5
#define PTE_KRE_MASK 0x100
#define PTE_KRE 0x8
#define PTE_URE_MASK 0x200
#define PTE_URE 0x9
#define PTE_KWE_MASK 0x1000
#define PTE_KWE 0xc
#define PTE_UWE_MASK 0x2000
#define PTE_UWE 0xd
#define PTE_WRITE_MASK 0x10000
#define PTE_WRITE 0x10
#define PTE_COPY_ON_WRITE_MASK 0x20000
#define PTE_COPY_ON_WRITE 0x11
#define PTE_SOFTWARE_MASK 0xfffc0000
#define PTE_SOFTWARE 0x12
#define PTE_PFN_MASK 0xffffffff00000000
#define PTE_PFN 0x20
#define PSR_MODE_MASK 0x1
#define PSR_MODE 0x0
#define PSR_USER_MODE 0x1
#define PSR_IE_MASK 0x2
#define PSR_IE 0x1
#define PSR_IRQL_MASK 0x1c
#define PSR_IRQL 0x2
#define IE_SFW_MASK 0x3
#define IE_SFW 0x0
#define IE_HDW_MASK 0xfc
#define IE_HDW 0x2
#define MCHK_CORRECTABLE_MASK 0x1
#define MCHK_CORRECTABLE 0x0
#define MCHK_RETRYABLE_MASK 0x2
#define MCHK_RETRYABLE 0x1
#define MCES_MCK_MASK 0x1
#define MCES_MCK 0x0
#define MCES_SCE_MASK 0x2
#define MCES_SCE 0x1
#define MCES_PCE_MASK 0x4
#define MCES_PCE 0x2
#define MCES_DPC_MASK 0x8
#define MCES_DPC 0x3
#define MCES_DSC_MASK 0x10
#define MCES_DSC 0x4
#define MCES_DMCK_MASK 0x20
#define MCES_DMCK 0x5
#define EXCSUM_SWC_MASK 0x1
#define EXCSUM_SWC 0x0
#define EXCSUM_INV_MASK 0x2
#define EXCSUM_INV 0x1
#define EXCSUM_DZE_MASK 0x4
#define EXCSUM_DZE 0x2
#define EXCSUM_OVF_MASK 0x8
#define EXCSUM_OVF 0x3
#define EXCSUM_UNF_MASK 0x10
#define EXCSUM_UNF 0x4
#define EXCSUM_INE_MASK 0x20
#define EXCSUM_INE 0x5
#define EXCSUM_IOV_MASK 0x40
#define EXCSUM_IOV 0x6

//
// Call PAL Mnemonics
//

// begin callpal

#define bpt 0x80
#define callsys 0x83
#define imb 0x86
#define gentrap 0xaa
#define rdteb 0xab
#define kbpt 0xac
#define callkd 0xad
#define rdteb64 0xae
#define halt 0x0
#define restart 0x1
#define draina 0x2
#define reboot 0x3
#define initpal 0x4
#define wrentry 0x5
#define swpirql 0x6
#define rdirql 0x7
#define di 0x8
#define ei 0x9
#define swppal 0xa
#define ssir 0xc
#define csir 0xd
#define rfe 0xe
#define retsys 0xf
#define swpctx 0x10
#define swpprocess 0x11
#define rdmces 0x12
#define wrmces 0x13
#define tbia 0x14
#define tbis 0x15
#define tbisasn 0x17
#define dtbis 0x16
#define rdksp 0x18
#define swpksp 0x19
#define rdpsr 0x1a
#define rdpcr 0x1c
#define rdthread 0x1e
#define tbim 0x20
#define tbimasn 0x21
#define tbim64 0x22
#define tbis64 0x23
#define ealnfix 0x24
#define dalnfix 0x25
#define rdcounters 0x30
#define rdstate 0x31
#define wrperfmon 0x32
#define cp_sleep 0x39
#define initpcr 0x38

// end callpal


//
// Bios Argument Structure Definitions
//

#define BaEax 0x0
#define BaEbx 0x4
#define BaEcx 0x8
#define BaEdx 0xc
#define BaEsi 0x10
#define BaEdi 0x14
#define BaEbp 0x18
#define BiosArgumentLength 0x1c

//
// Define Vendor Callback Read/Write Error Frame Operation Types
//

#define ReadFrame 0x1
#define WriteFrame 0x2

//
// Define Vendor Callback Vector Base Address
//

#define SYSTEM_VECTOR_BASE 0xffffffff806fe028

//
// Define Vendor Callback Offsets
//

#define VnCallBiosRoutine 0x38
#define VnReadWriteErrorFrameRoutine 0x98
#define VnVideoDisplayInitializeRoutine 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\KsMedia.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ksmedia.h

Abstract:

    WDM-CSA Multimedia Definitions.

--*/

#if !defined(_KS_)
#error KS.H must be included before KSMEDIA.H
#endif // !defined(_KS_)

#if !defined(_KSMEDIA_)
#define _KSMEDIA_

typedef struct {
    KSPROPERTY      Property;
    KSMULTIPLE_ITEM MultipleItem;
} KSMULTIPLE_DATA_PROP, *PKSMULTIPLE_DATA_PROP;

#define STATIC_KSMEDIUMSETID_MidiBus \
    0x05908040L, 0x3246, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("05908040-3246-11D0-A5D6-28DB04C10000", KSMEDIUMSETID_MidiBus);
#define KSMEDIUMSETID_MidiBus DEFINE_GUIDNAMED(KSMEDIUMSETID_MidiBus)

#define STATIC_KSMEDIUMSETID_VPBus \
    0xA18C15ECL, 0xCE43, 0x11D0, 0xAB, 0xE7, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("A18C15EC-CE43-11D0-ABE7-00A0C9223196", KSMEDIUMSETID_VPBus);
#define KSMEDIUMSETID_VPBus DEFINE_GUIDNAMED(KSMEDIUMSETID_VPBus)

#define STATIC_KSINTERFACESETID_Media \
    0x3A13EB40L, 0x30A7, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("3A13EB40-30A7-11D0-A5D6-28DB04C10000", KSINTERFACESETID_Media);
#define KSINTERFACESETID_Media DEFINE_GUIDNAMED(KSINTERFACESETID_Media)

typedef enum {
    KSINTERFACE_MEDIA_MUSIC,
    KSINTERFACE_MEDIA_WAVE_BUFFERED,
    KSINTERFACE_MEDIA_WAVE_QUEUED
} KSINTERFACE_MEDIA;


// USB Terminals
#define INIT_USB_TERMINAL(guid, id)\
{\
    (guid)->Data1 = 0xDFF219E0 + (USHORT)(id);\
    (guid)->Data2 = 0xF70F;\
    (guid)->Data3 = 0x11D0;\
    (guid)->Data4[0] = 0xb9;\
    (guid)->Data4[1] = 0x17;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_USB_TERMINAL(guid)\
    (USHORT)((guid)->Data1 - 0xDFF219E0)
#define DEFINE_USB_TERMINAL_GUID(id)\
    0xDFF219E0+(USHORT)(id), 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_KSNODETYPE_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0201)
DEFINE_GUIDSTRUCT("DFF21BE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MICROPHONE);
#define KSNODETYPE_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_MICROPHONE)

#define STATIC_KSNODETYPE_DESKTOP_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0202)
DEFINE_GUIDSTRUCT("DFF21BE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DESKTOP_MICROPHONE);
#define KSNODETYPE_DESKTOP_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_DESKTOP_MICROPHONE)

#define STATIC_KSNODETYPE_PERSONAL_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0203)
DEFINE_GUIDSTRUCT("DFF21BE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PERSONAL_MICROPHONE);
#define KSNODETYPE_PERSONAL_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_PERSONAL_MICROPHONE)

#define STATIC_KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0204)
DEFINE_GUIDSTRUCT("DFF21BE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE);
#define KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE)

#define STATIC_KSNODETYPE_MICROPHONE_ARRAY\
    DEFINE_USB_TERMINAL_GUID(0x0205)
DEFINE_GUIDSTRUCT("DFF21BE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MICROPHONE_ARRAY);
#define KSNODETYPE_MICROPHONE_ARRAY DEFINE_GUIDNAMED(KSNODETYPE_MICROPHONE_ARRAY)

#define STATIC_KSNODETYPE_PROCESSING_MICROPHONE_ARRAY\
    DEFINE_USB_TERMINAL_GUID(0x0206)
DEFINE_GUIDSTRUCT("DFF21BE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PROCESSING_MICROPHONE_ARRAY);
#define KSNODETYPE_PROCESSING_MICROPHONE_ARRAY DEFINE_GUIDNAMED(KSNODETYPE_PROCESSING_MICROPHONE_ARRAY)

#define STATIC_KSNODETYPE_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0301)
DEFINE_GUIDSTRUCT("DFF21CE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPEAKER);
#define KSNODETYPE_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_SPEAKER)

#define STATIC_KSNODETYPE_HEADPHONES\
    DEFINE_USB_TERMINAL_GUID(0x0302)
DEFINE_GUIDSTRUCT("DFF21CE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEADPHONES);
#define KSNODETYPE_HEADPHONES DEFINE_GUIDNAMED(KSNODETYPE_HEADPHONES)

#define STATIC_KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x0303)
DEFINE_GUIDSTRUCT("DFF21CE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO);
#define KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO)

#define STATIC_KSNODETYPE_DESKTOP_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0304)
DEFINE_GUIDSTRUCT("DFF21CE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DESKTOP_SPEAKER);
#define KSNODETYPE_DESKTOP_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_DESKTOP_SPEAKER)

#define STATIC_KSNODETYPE_ROOM_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0305)
DEFINE_GUIDSTRUCT("DFF21CE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ROOM_SPEAKER);
#define KSNODETYPE_ROOM_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_ROOM_SPEAKER)

#define STATIC_KSNODETYPE_COMMUNICATION_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0306)
DEFINE_GUIDSTRUCT("DFF21CE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_COMMUNICATION_SPEAKER);
#define KSNODETYPE_COMMUNICATION_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_COMMUNICATION_SPEAKER)

#define STATIC_KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0307)
DEFINE_GUIDSTRUCT("DFF21CE7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER);
#define KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER)

#define STATIC_KSNODETYPE_HANDSET\
    DEFINE_USB_TERMINAL_GUID(0x0401)
DEFINE_GUIDSTRUCT("DFF21DE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HANDSET);
#define KSNODETYPE_HANDSET DEFINE_GUIDNAMED(KSNODETYPE_HANDSET)

#define STATIC_KSNODETYPE_HEADSET\
    DEFINE_USB_TERMINAL_GUID(0x0402)
DEFINE_GUIDSTRUCT("DFF21DE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEADSET);
#define KSNODETYPE_HEADSET DEFINE_GUIDNAMED(KSNODETYPE_HEADSET)

#define STATIC_KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION\
    DEFINE_USB_TERMINAL_GUID(0x0403)
DEFINE_GUIDSTRUCT("DFF21DE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION);
#define KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION DEFINE_GUIDNAMED(KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION)

#define STATIC_KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0404)
DEFINE_GUIDSTRUCT("DFF21DE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE);
#define KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE DEFINE_GUIDNAMED(KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE)

#define STATIC_KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0405)
DEFINE_GUIDSTRUCT("DFF21DE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE);
#define KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE DEFINE_GUIDNAMED(KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE)

#define STATIC_KSNODETYPE_PHONE_LINE\
    DEFINE_USB_TERMINAL_GUID(0x0501)
DEFINE_GUIDSTRUCT("DFF21EE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PHONE_LINE);
#define KSNODETYPE_PHONE_LINE DEFINE_GUIDNAMED(KSNODETYPE_PHONE_LINE)

#define STATIC_KSNODETYPE_TELEPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0502)
DEFINE_GUIDSTRUCT("DFF21EE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_TELEPHONE);
#define KSNODETYPE_TELEPHONE DEFINE_GUIDNAMED(KSNODETYPE_TELEPHONE)

#define STATIC_KSNODETYPE_DOWN_LINE_PHONE\
    DEFINE_USB_TERMINAL_GUID(0x0503)
DEFINE_GUIDSTRUCT("DFF21EE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DOWN_LINE_PHONE);
#define KSNODETYPE_DOWN_LINE_PHONE DEFINE_GUIDNAMED(KSNODETYPE_DOWN_LINE_PHONE)

#define STATIC_KSNODETYPE_ANALOG_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x601)
DEFINE_GUIDSTRUCT("DFF21FE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ANALOG_CONNECTOR);
#define KSNODETYPE_ANALOG_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_ANALOG_CONNECTOR)

#define STATIC_KSNODETYPE_DIGITAL_AUDIO_INTERFACE\
    DEFINE_USB_TERMINAL_GUID(0x0602)
DEFINE_GUIDSTRUCT("DFF21FE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DIGITAL_AUDIO_INTERFACE);
#define KSNODETYPE_DIGITAL_AUDIO_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_DIGITAL_AUDIO_INTERFACE)

#define STATIC_KSNODETYPE_LINE_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x0603)
DEFINE_GUIDSTRUCT("DFF21FE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LINE_CONNECTOR);
#define KSNODETYPE_LINE_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_LINE_CONNECTOR)

#define STATIC_KSNODETYPE_LEGACY_AUDIO_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x0604)
DEFINE_GUIDSTRUCT("DFF21FE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LEGACY_AUDIO_CONNECTOR);
#define KSNODETYPE_LEGACY_AUDIO_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_LEGACY_AUDIO_CONNECTOR)

#define STATIC_KSNODETYPE_SPDIF_INTERFACE\
    DEFINE_USB_TERMINAL_GUID(0x0605)
DEFINE_GUIDSTRUCT("DFF21FE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPDIF_INTERFACE);
#define KSNODETYPE_SPDIF_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_SPDIF_INTERFACE)

#define STATIC_KSNODETYPE_1394_DA_STREAM\
    DEFINE_USB_TERMINAL_GUID(0x0606)
DEFINE_GUIDSTRUCT("DFF21FE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_1394_DA_STREAM);
#define KSNODETYPE_1394_DA_STREAM DEFINE_GUIDNAMED(KSNODETYPE_1394_DA_STREAM)

#define STATIC_KSNODETYPE_1394_DV_STREAM_SOUNDTRACK\
    DEFINE_USB_TERMINAL_GUID(0x0607)
DEFINE_GUIDSTRUCT("DFF21FE7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_1394_DV_STREAM_SOUNDTRACK);
#define KSNODETYPE_1394_DV_STREAM_SOUNDTRACK DEFINE_GUIDNAMED(KSNODETYPE_1394_DV_STREAM_SOUNDTRACK)

#define STATIC_KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE\
    DEFINE_USB_TERMINAL_GUID(0x0701)
DEFINE_GUIDSTRUCT("DFF220E1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE);
#define KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE DEFINE_GUIDNAMED(KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE)

#define STATIC_KSNODETYPE_EQUALIZATION_NOISE\
    DEFINE_USB_TERMINAL_GUID(0x0702)
DEFINE_GUIDSTRUCT("DFF220E2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_EQUALIZATION_NOISE);
#define KSNODETYPE_EQUALIZATION_NOISE DEFINE_GUIDNAMED(KSNODETYPE_EQUALIZATION_NOISE)

#define STATIC_KSNODETYPE_CD_PLAYER\
    DEFINE_USB_TERMINAL_GUID(0x0703)
DEFINE_GUIDSTRUCT("DFF220E3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_CD_PLAYER);
#define KSNODETYPE_CD_PLAYER DEFINE_GUIDNAMED(KSNODETYPE_CD_PLAYER)

#define STATIC_KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE\
    DEFINE_USB_TERMINAL_GUID(0x0704)
DEFINE_GUIDSTRUCT("DFF220E4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE);
#define KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE DEFINE_GUIDNAMED(KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE)

#define STATIC_KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE\
    DEFINE_USB_TERMINAL_GUID(0x0705)
DEFINE_GUIDSTRUCT("DFF220E5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE);
#define KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE DEFINE_GUIDNAMED(KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE)

#define STATIC_KSNODETYPE_MINIDISK\
    DEFINE_USB_TERMINAL_GUID(0x0706)
DEFINE_GUIDSTRUCT("DFF220E6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MINIDISK);
#define KSNODETYPE_MINIDISK DEFINE_GUIDNAMED(KSNODETYPE_MINIDISK)

#define STATIC_KSNODETYPE_ANALOG_TAPE\
    DEFINE_USB_TERMINAL_GUID(0x0707)
DEFINE_GUIDSTRUCT("DFF220E7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ANALOG_TAPE);
#define KSNODETYPE_ANALOG_TAPE DEFINE_GUIDNAMED(KSNODETYPE_ANALOG_TAPE)

#define STATIC_KSNODETYPE_PHONOGRAPH\
    DEFINE_USB_TERMINAL_GUID(0x0708)
DEFINE_GUIDSTRUCT("DFF220E8-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PHONOGRAPH);
#define KSNODETYPE_PHONOGRAPH DEFINE_GUIDNAMED(KSNODETYPE_PHONOGRAPH)

#define STATIC_KSNODETYPE_VCR_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x0708)
DEFINE_GUIDSTRUCT("DFF220E9-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VCR_AUDIO);
#define KSNODETYPE_VCR_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_VCR_AUDIO)

#define STATIC_KSNODETYPE_VIDEO_DISC_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070A)
DEFINE_GUIDSTRUCT("DFF220EA-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_DISC_AUDIO);
#define KSNODETYPE_VIDEO_DISC_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_DISC_AUDIO)

#define STATIC_KSNODETYPE_DVD_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070B)
DEFINE_GUIDSTRUCT("DFF220EB-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DVD_AUDIO);
#define KSNODETYPE_DVD_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_DVD_AUDIO)

#define STATIC_KSNODETYPE_TV_TUNER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070C)
DEFINE_GUIDSTRUCT("DFF220EC-F70F-11D0-B917-00A0C9223196", KSNODETYPE_TV_TUNER_AUDIO);
#define KSNODETYPE_TV_TUNER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_TV_TUNER_AUDIO)

#define STATIC_KSNODETYPE_SATELLITE_RECEIVER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070D)
DEFINE_GUIDSTRUCT("DFF220ED-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SATELLITE_RECEIVER_AUDIO);
#define KSNODETYPE_SATELLITE_RECEIVER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_SATELLITE_RECEIVER_AUDIO)

#define STATIC_KSNODETYPE_CABLE_TUNER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070E)
DEFINE_GUIDSTRUCT("DFF220EE-F70F-11D0-B917-00A0C9223196", KSNODETYPE_CABLE_TUNER_AUDIO);
#define KSNODETYPE_CABLE_TUNER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_CABLE_TUNER_AUDIO)

#define STATIC_KSNODETYPE_DSS_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070F)
DEFINE_GUIDSTRUCT("DFF220EF-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DSS_AUDIO);
#define KSNODETYPE_DSS_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_DSS_AUDIO)

#define STATIC_KSNODETYPE_RADIO_RECEIVER\
    DEFINE_USB_TERMINAL_GUID(0x0710)
DEFINE_GUIDSTRUCT("DFF220F0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_RADIO_RECEIVER);
#define KSNODETYPE_RADIO_RECEIVER DEFINE_GUIDNAMED(KSNODETYPE_RADIO_RECEIVER)

#define STATIC_KSNODETYPE_RADIO_TRANSMITTER\
    DEFINE_USB_TERMINAL_GUID(0x0711)
DEFINE_GUIDSTRUCT("DFF220F1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_RADIO_TRANSMITTER);
#define KSNODETYPE_RADIO_TRANSMITTER DEFINE_GUIDNAMED(KSNODETYPE_RADIO_TRANSMITTER)

#define STATIC_KSNODETYPE_MULTITRACK_RECORDER\
    DEFINE_USB_TERMINAL_GUID(0x0712)
DEFINE_GUIDSTRUCT("DFF220F2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MULTITRACK_RECORDER);
#define KSNODETYPE_MULTITRACK_RECORDER DEFINE_GUIDNAMED(KSNODETYPE_MULTITRACK_RECORDER)

#define STATIC_KSNODETYPE_SYNTHESIZER\
    DEFINE_USB_TERMINAL_GUID(0x0713)
DEFINE_GUIDSTRUCT("DFF220F3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SYNTHESIZER);
#define KSNODETYPE_SYNTHESIZER DEFINE_GUIDNAMED(KSNODETYPE_SYNTHESIZER)

// Microsoft's WDMAUD virtual swsynth pin name guid

#define STATIC_KSNODETYPE_SWSYNTH\
    0x423274A0L, 0x8B81, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("423274A0-8B81-11D1-A050-0000F8004788", KSNODETYPE_SWSYNTH);
#define KSNODETYPE_SWSYNTH DEFINE_GUIDNAMED(KSNODETYPE_SWSYNTH)

// Microsoft's SWMIDI midi pin and node name guid

#define STATIC_KSNODETYPE_SWMIDI\
    0xCB9BEFA0L, 0xA251, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("CB9BEFA0-A251-11D1-A050-0000F8004788", KSNODETYPE_SWMIDI);
#define KSNODETYPE_SWMIDI DEFINE_GUIDNAMED(KSNODETYPE_SWMIDI)

#define STATIC_KSNODETYPE_DRM_DESCRAMBLE\
    0xFFBB6E3FL, 0xCCFE, 0x4D84, 0x90, 0xD9, 0x42, 0x14, 0x18, 0xB0, 0x3A, 0x8E
DEFINE_GUIDSTRUCT("FFBB6E3F-CCFE-4D84-90D9-421418B03A8E", KSNODETYPE_DRM_DESCRAMBLE);
#define KSNODETYPE_DRM_DESCRAMBLE DEFINE_GUIDNAMED(KSNODETYPE_DRM_DESCRAMBLE)

// General categories
#define STATIC_KSCATEGORY_AUDIO \
    0x6994AD04L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD04-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_AUDIO);
#define KSCATEGORY_AUDIO DEFINE_GUIDNAMED(KSCATEGORY_AUDIO)

#define STATIC_KSCATEGORY_VIDEO \
    0x6994AD05L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD05-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_VIDEO);
#define KSCATEGORY_VIDEO DEFINE_GUIDNAMED(KSCATEGORY_VIDEO)

#define STATIC_KSCATEGORY_TEXT \
    0x6994AD06L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD06-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_TEXT);
#define KSCATEGORY_TEXT DEFINE_GUIDNAMED(KSCATEGORY_TEXT)

#define STATIC_KSCATEGORY_NETWORK \
    0x67C9CC3CL, 0x69C4, 0x11D2, 0x87, 0x59, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("67C9CC3C-69C4-11D2-8759-00A0C9223196", KSCATEGORY_NETWORK);
#define KSCATEGORY_NETWORK DEFINE_GUIDNAMED(KSCATEGORY_NETWORK)

#define STATIC_KSCATEGORY_TOPOLOGY \
    0xDDA54A40L, 0x1E4C, 0x11D1, 0xA0, 0x50, 0x40, 0x57, 0x05, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("DDA54A40-1E4C-11D1-A050-405705C10000", KSCATEGORY_TOPOLOGY);
#define KSCATEGORY_TOPOLOGY DEFINE_GUIDNAMED(KSCATEGORY_TOPOLOGY)

#define STATIC_KSCATEGORY_VIRTUAL \
    0x3503EAC4L, 0x1F26, 0x11D1, 0x8A, 0xB0, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("3503EAC4-1F26-11D1-8AB0-00A0C9223196", KSCATEGORY_VIRTUAL);
#define KSCATEGORY_VIRTUAL DEFINE_GUIDNAMED(KSCATEGORY_VIRTUAL)

#define STATIC_KSCATEGORY_ACOUSTIC_ECHO_CANCEL \
    0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("BF963D80-C559-11D0-8A2B-00A0C9255AC1", KSCATEGORY_ACOUSTIC_ECHO_CANCEL);
#define KSCATEGORY_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(KSCATEGORY_ACOUSTIC_ECHO_CANCEL)

#define STATIC_KSCATEGORY_SYSAUDIO \
    0xA7C7A5B1L, 0x5AF3, 0x11D1, 0x9C, 0xED, 0x00, 0xA0, 0x24, 0xBF, 0x04, 0x07
DEFINE_GUIDSTRUCT("A7C7A5B1-5AF3-11D1-9CED-00A024BF0407", KSCATEGORY_SYSAUDIO);
#define KSCATEGORY_SYSAUDIO DEFINE_GUIDNAMED(KSCATEGORY_SYSAUDIO)

#define STATIC_KSCATEGORY_WDMAUD \
    0x3E227E76L, 0x690D, 0x11D2, 0x81, 0x61, 0x00, 0x00, 0xF8, 0x77, 0x5B, 0xF1
DEFINE_GUIDSTRUCT("3E227E76-690D-11D2-8161-0000F8775BF1", KSCATEGORY_WDMAUD);
#define KSCATEGORY_WDMAUD DEFINE_GUIDNAMED(KSCATEGORY_WDMAUD)

#define STATIC_KSCATEGORY_AUDIO_GFX \
    0x9BAF9572L, 0x340C, 0x11D3, 0xAB, 0xDC, 0x00, 0xA0, 0xC9, 0x0A, 0xB1, 0x6F
DEFINE_GUIDSTRUCT("9BAF9572-340C-11D3-ABDC-00A0C90AB16F", KSCATEGORY_AUDIO_GFX);
#define KSCATEGORY_AUDIO_GFX DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_GFX)

#define STATIC_KSCATEGORY_AUDIO_SPLITTER \
    0x9EA331FAL, 0xB91B, 0x45F8, 0x92, 0x85, 0xBD, 0x2B, 0xC7, 0x7A, 0xFC, 0xDE
DEFINE_GUIDSTRUCT("9EA331FA-B91B-45F8-9285-BD2BC77AFCDE", KSCATEGORY_AUDIO_SPLITTER);
#define KSCATEGORY_AUDIO_SPLITTER DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_SPLITTER)

#define STATIC_KSCATEGORY_SYNTHESIZER STATIC_KSNODETYPE_SYNTHESIZER
#define KSCATEGORY_SYNTHESIZER KSNODETYPE_SYNTHESIZER

#define STATIC_KSCATEGORY_DRM_DESCRAMBLE STATIC_KSNODETYPE_DRM_DESCRAMBLE
#define KSCATEGORY_DRM_DESCRAMBLE KSNODETYPE_DRM_DESCRAMBLE

#define STATIC_KSCATEGORY_AUDIO_DEVICE \
    0xFBF6F530L, 0x07B9, 0x11D2, 0xA7, 0x1E, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("FBF6F530-07B9-11D2-A71E-0000F8004788", KSCATEGORY_AUDIO_DEVICE);
#define KSCATEGORY_AUDIO_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_WAVEOUT_DEVICE \
    0xD6C5066EL, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C5066E-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_WAVEOUT_DEVICE);
#define KSCATEGORY_PREFERRED_WAVEOUT_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_WAVEOUT_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_WAVEIN_DEVICE \
    0xD6C50671L, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C50671-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_WAVEIN_DEVICE);
#define KSCATEGORY_PREFERRED_WAVEIN_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_WAVEIN_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_MIDIOUT_DEVICE \
    0xD6C50674L, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C50674-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_MIDIOUT_DEVICE);
#define KSCATEGORY_PREFERRED_MIDIOUT_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_MIDIOUT_DEVICE)

// Special pin category for wdmaud

#define STATIC_KSCATEGORY_WDMAUD_USE_PIN_NAME \
    0x47A4FA20L, 0xA251, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("47A4FA20-A251-11D1-A050-0000F8004788", KSCATEGORY_WDMAUD_USE_PIN_NAME);
#define KSCATEGORY_WDMAUD_USE_PIN_NAME DEFINE_GUIDNAMED(KSCATEGORY_WDMAUD_USE_PIN_NAME)

// Escalante Platform Interface

#define STATIC_KSCATEGORY_ESCALANTE_PLATFORM_DRIVER \
    0x74f3aea8L, 0x9768, 0x11d1, 0x8e, 0x07, 0x00, 0xa0, 0xc9, 0x5e, 0xc2, 0x2e
DEFINE_GUIDSTRUCT("74f3aea8-9768-11d1-8e07-00a0c95ec22e", KSCATEGORY_ESCALANTE_PLATFORM_DRIVER);
#define KSCATEGORY_ESCALANTE_PLATFORM_DRIVER DEFINE_GUIDNAMED(KSCATEGORY_ESCALANTE_PLATFORM_DRIVER)

// -- major types ---

// 'vids' == MEDIATYPE_Video,
#define STATIC_KSDATAFORMAT_TYPE_VIDEO\
    0x73646976L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73646976-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_VIDEO);
#define KSDATAFORMAT_TYPE_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_VIDEO)

// 'auds' == MEDIATYPE_Audio
#define STATIC_KSDATAFORMAT_TYPE_AUDIO\
    0x73647561L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73647561-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_AUDIO);
#define KSDATAFORMAT_TYPE_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_AUDIO)

// 'txts' == MEDIATYPE_Text
#define STATIC_KSDATAFORMAT_TYPE_TEXT\
    0x73747874L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73747874-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_TEXT);
#define KSDATAFORMAT_TYPE_TEXT DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_TEXT)

#if !defined( DEFINE_WAVEFORMATEX_GUID )
#define DEFINE_WAVEFORMATEX_GUID(x) (USHORT)(x), 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
#endif

#define STATIC_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX\
    0x00000000L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000000-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_WAVEFORMATEX);
#define KSDATAFORMAT_SUBTYPE_WAVEFORMATEX DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_WAVEFORMATEX)

#define INIT_WAVEFORMATEX_GUID(Guid, x)\
{\
    *(Guid) = KSDATAFORMAT_SUBTYPE_WAVEFORMATEX;\
    (Guid)->Data1 = (USHORT)(x);\
}

#define EXTRACT_WAVEFORMATEX_ID(Guid)\
    (USHORT)((Guid)->Data1)

#define IS_VALID_WAVEFORMATEX_GUID(Guid)\
    (!memcmp(((PUSHORT)&KSDATAFORMAT_SUBTYPE_WAVEFORMATEX) + 1, ((PUSHORT)(Guid)) + 1, sizeof(GUID) - sizeof(USHORT)))

#if !defined(INIT_MMREG_MID)
//{d5a47fa7-6d98-11d1-a21a-00a0c9223196}
#define INIT_MMREG_MID(guid, id)\
{\
    (guid)->Data1 = 0xd5a47fa7 + (USHORT)(id);\
    (guid)->Data2 = 0x6d98;\
    (guid)->Data3 = 0x11d1;\
    (guid)->Data4[0] = 0xa2;\
    (guid)->Data4[1] = 0x1a;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_MMREG_MID(guid)\
    (USHORT)((guid)->Data1 - 0xd5a47fa7)
#define DEFINE_MMREG_MID_GUID(id)\
    0xd5a47fa7+(USHORT)(id), 0x6d98, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96

#define IS_COMPATIBLE_MMREG_MID(guid)\
    (((guid)->Data1 >= 0xd5a47fa7) &&\
    ((guid)->Data1 < 0xd5a47fa7 + 0xffff) &&\
    ((guid)->Data2 == 0x6d98) &&\
    ((guid)->Data3 == 0x11d1) &&\
    ((guid)->Data4[0] == 0xa2) &&\
    ((guid)->Data4[1] == 0x1a) &&\
    ((guid)->Data4[2] == 0x00) &&\
    ((guid)->Data4[3] == 0xa0) &&\
    ((guid)->Data4[4] == 0xc9) &&\
    ((guid)->Data4[5] == 0x22) &&\
    ((guid)->Data4[6] == 0x31) &&\
    ((guid)->Data4[7] == 0x96))
#endif // !defined(INIT_MMREG_MID)

#if !defined(INIT_MMREG_PID)
//{e36dc2ac-6d9a-11d1-a21a-00a0c9223196}
#define INIT_MMREG_PID(guid, id)\
{\
    (guid)->Data1 = 0xe36dc2ac + (USHORT)(id);\
    (guid)->Data2 = 0x6d9a;\
    (guid)->Data3 = 0x11d1;\
    (guid)->Data4[0] = 0xa2;\
    (guid)->Data4[1] = 0x1a;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_MMREG_PID(guid)\
    (USHORT)((guid)->Data1 - 0xe36dc2ac)
#define DEFINE_MMREG_PID_GUID(id)\
    0xe36dc2ac+(USHORT)(id), 0x6d9a, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96

#define IS_COMPATIBLE_MMREG_PID(guid)\
    (((guid)->Data1 >= 0xe36dc2ac) &&\
    ((guid)->Data1 < 0xe36dc2ac + 0xffff) &&\
    ((guid)->Data2 == 0x6d9a) &&\
    ((guid)->Data3 == 0x11d1) &&\
    ((guid)->Data4[0] == 0xa2) &&\
    ((guid)->Data4[1] == 0x1a) &&\
    ((guid)->Data4[2] == 0x00) &&\
    ((guid)->Data4[3] == 0xa0) &&\
    ((guid)->Data4[4] == 0xc9) &&\
    ((guid)->Data4[5] == 0x22) &&\
    ((guid)->Data4[6] == 0x31) &&\
    ((guid)->Data4[7] == 0x96))
#endif // !defined(INIT_MMREG_PID)

#define STATIC_KSDATAFORMAT_SUBTYPE_ANALOG\
    0x6dba3190L, 0x67bd, 0x11cf, 0xa0, 0xf7, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("6dba3190-67bd-11cf-a0f7-0020afd156e4", KSDATAFORMAT_SUBTYPE_ANALOG);
#define KSDATAFORMAT_SUBTYPE_ANALOG DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ANALOG)

#define STATIC_KSDATAFORMAT_SUBTYPE_PCM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_PCM)
DEFINE_GUIDSTRUCT("00000001-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_PCM);
#define KSDATAFORMAT_SUBTYPE_PCM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_PCM)

#if defined(_INC_MMREG)
#define STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_IEEE_FLOAT)
DEFINE_GUIDSTRUCT("00000003-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEEE_FLOAT);
#define KSDATAFORMAT_SUBTYPE_IEEE_FLOAT DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)

#define STATIC_KSDATAFORMAT_SUBTYPE_DRM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_DRM)
DEFINE_GUIDSTRUCT("00000009-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_DRM);
#define KSDATAFORMAT_SUBTYPE_DRM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DRM)

#define STATIC_KSDATAFORMAT_SUBTYPE_ALAW\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ALAW)
DEFINE_GUIDSTRUCT("00000006-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_ALAW);
#define KSDATAFORMAT_SUBTYPE_ALAW DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ALAW)

#define STATIC_KSDATAFORMAT_SUBTYPE_MULAW\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MULAW)
DEFINE_GUIDSTRUCT("00000007-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_MULAW);
#define KSDATAFORMAT_SUBTYPE_MULAW DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MULAW)

#define STATIC_KSDATAFORMAT_SUBTYPE_ADPCM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ADPCM)
DEFINE_GUIDSTRUCT("00000002-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_ADPCM);
#define KSDATAFORMAT_SUBTYPE_ADPCM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ADPCM)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MPEG)
DEFINE_GUIDSTRUCT("00000050-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_MPEG);
#define KSDATAFORMAT_SUBTYPE_MPEG DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG)
#endif // defined(_INC_MMREG)

#define STATIC_KSDATAFORMAT_SPECIFIER_VC_ID\
    0xAD98D184L, 0xAAC3, 0x11D0, 0xA4, 0x1C, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("AD98D184-AAC3-11D0-A41C-00A0C9223196", KSDATAFORMAT_SPECIFIER_VC_ID);
#define KSDATAFORMAT_SPECIFIER_VC_ID DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VC_ID)

#define STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX\
    0x05589f81L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f81-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_WAVEFORMATEX);
#define KSDATAFORMAT_SPECIFIER_WAVEFORMATEX DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)

#define STATIC_KSDATAFORMAT_SPECIFIER_DSOUND\
    0x518590a2L, 0xa184, 0x11d0, 0x85, 0x22, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("518590a2-a184-11d0-8522-00c04fd9baf3", KSDATAFORMAT_SPECIFIER_DSOUND);
#define KSDATAFORMAT_SPECIFIER_DSOUND DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DSOUND)

#if defined(_INC_MMSYSTEM) || defined(_INC_MMREG)
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif
typedef struct {
    KSDATAFORMAT    DataFormat;
    WAVEFORMATEX    WaveFormatEx;
} KSDATAFORMAT_WAVEFORMATEX, *PKSDATAFORMAT_WAVEFORMATEX;

#ifndef _WAVEFORMATEXTENSIBLE_
#define _WAVEFORMATEXTENSIBLE_
typedef struct {
    WAVEFORMATEX    Format;
    union {
        WORD wValidBitsPerSample;       /* bits of precision  */
        WORD wSamplesPerBlock;          /* valid if wBitsPerSample==0 */
        WORD wReserved;                 /* If neither applies, set to zero. */
    } Samples;
    DWORD           dwChannelMask;      /* which channels are */
                                        /* present in stream  */
    GUID            SubFormat;
} WAVEFORMATEXTENSIBLE, *PWAVEFORMATEXTENSIBLE;
#endif // !_WAVEFORMATEXTENSIBLE_

#if !defined(WAVE_FORMAT_EXTENSIBLE)
#define  WAVE_FORMAT_EXTENSIBLE                 0xFFFE
#endif // !defined(WAVE_FORMAT_EXTENSIBLE)

// DirectSound buffer description
typedef struct {
    ULONG               Flags;
    ULONG               Control;
    WAVEFORMATEX        WaveFormatEx;
} KSDSOUND_BUFFERDESC, *PKSDSOUND_BUFFERDESC;

// DirectSound format
typedef struct {
    KSDATAFORMAT        DataFormat;
    KSDSOUND_BUFFERDESC BufferDesc;
} KSDATAFORMAT_DSOUND, *PKSDATAFORMAT_DSOUND;

#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif
#endif // defined(_INC_MMSYSTEM) || defined(_INC_MMREG)



// DirectSound buffer flags
#define KSDSOUND_BUFFER_PRIMARY             0x00000001
#define KSDSOUND_BUFFER_STATIC              0x00000002
#define KSDSOUND_BUFFER_LOCHARDWARE         0x00000004
#define KSDSOUND_BUFFER_LOCSOFTWARE         0x00000008

// DirectSound buffer control flags
#define KSDSOUND_BUFFER_CTRL_3D             0x00000001
#define KSDSOUND_BUFFER_CTRL_FREQUENCY      0x00000002
#define KSDSOUND_BUFFER_CTRL_PAN            0x00000004
#define KSDSOUND_BUFFER_CTRL_VOLUME         0x00000008
#define KSDSOUND_BUFFER_CTRL_POSITIONNOTIFY 0x00000010

#define KSDSOUND_BUFFER_CTRL_HRTF_3D        0x40000000

typedef struct {
#if defined(_NTDDK_)
    ULONGLONG        PlayOffset;
    ULONGLONG        WriteOffset;
#else // !_NTDDK_
    DWORDLONG        PlayOffset;
    DWORDLONG        WriteOffset;
#endif // !_NTDDK_
} KSAUDIO_POSITION, *PKSAUDIO_POSITION;

// DirectSound3D FIR context
typedef struct {
    LONG                Channel;
    FLOAT               VolSmoothScale;
    FLOAT               TotalDryAttenuation;
    FLOAT               TotalWetAttenuation;
    LONG                SmoothFrequency;
    LONG                Delay;
} KSDS3D_ITD_PARAMS, *PKSDS3D_ITD_PARAMS;

typedef struct {
    ULONG                 Enabled;
    KSDS3D_ITD_PARAMS     LeftParams;
    KSDS3D_ITD_PARAMS     RightParams;
    ULONG                 Reserved;
} KSDS3D_ITD_PARAMS_MSG, *PKSDS3D_ITD_PARAMS_MSG;

// DirectSound3D HRTF messages

typedef struct {
    ULONG                   Size;           // This is the size of the struct in bytes
    ULONG                   Enabled;
    BOOL                    SwapChannels;
    BOOL                    ZeroAzimuth;
    BOOL                    CrossFadeOutput;
    ULONG                   FilterSize;     // This is the additional size of the filter coeff in bytes
} KSDS3D_HRTF_PARAMS_MSG, *PKSDS3D_HRTF_PARAMS_MSG;


// HRTF filter quality levels
typedef enum {
    FULL_FILTER,
    LIGHT_FILTER,
    KSDS3D_FILTER_QUALITY_COUNT
} KSDS3D_HRTF_FILTER_QUALITY;

typedef struct {
    ULONG                       Size;       // This is the size of the struct in bytes
    KSDS3D_HRTF_FILTER_QUALITY  Quality;
    FLOAT                       SampleRate;
    ULONG                       MaxFilterSize;
    ULONG                       FilterTransientMuteLength;
    ULONG                       FilterOverlapBufferLength;
    ULONG                       OutputOverlapBufferLength;
    ULONG                       Reserved;
} KSDS3D_HRTF_INIT_MSG, *PKSDS3D_HRTF_INIT_MSG;

// Coefficient formats
typedef enum {
    FLOAT_COEFF,
    SHORT_COEFF,
    KSDS3D_COEFF_COUNT
} KSDS3D_HRTF_COEFF_FORMAT;

// Filter methods
typedef enum {
    DIRECT_FORM,
    CASCADE_FORM,
    KSDS3D_FILTER_METHOD_COUNT
} KSDS3D_HRTF_FILTER_METHOD;

// Filter methods
typedef enum {
    DS3D_HRTF_VERSION_1
} KSDS3D_HRTF_FILTER_VERSION;

typedef struct {
    KSDS3D_HRTF_FILTER_METHOD    FilterMethod;
    KSDS3D_HRTF_COEFF_FORMAT     CoeffFormat;
    KSDS3D_HRTF_FILTER_VERSION   Version;
    ULONG                        Reserved;
} KSDS3D_HRTF_FILTER_FORMAT_MSG, *PKSDS3D_HRTF_FILTER_FORMAT_MSG;

//===========================================================================
// DirectSound3D HAL


typedef struct _DS3DVECTOR {
    union {
        FLOAT x;
        FLOAT dvX;
    };
    union {
        FLOAT y;
        FLOAT dvY;
    };
    union {
        FLOAT z;
        FLOAT dvZ;
    };
} DS3DVECTOR, *PDS3DVECTOR;


//===========================================================================
//===========================================================================

// KSPROPSETID_DirectSound3DListener : {437B3414-D060-11d0-8583-00C04FD9BAF3}

#define STATIC_KSPROPSETID_DirectSound3DListener\
    0x437b3414L, 0xd060, 0x11d0, 0x85, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("437b3414-d060-11d0-8583-00c04fd9baf3",KSPROPSETID_DirectSound3DListener);
#define KSPROPSETID_DirectSound3DListener DEFINE_GUIDNAMED(KSPROPSETID_DirectSound3DListener)

typedef enum {
    KSPROPERTY_DIRECTSOUND3DLISTENER_ALL,
    KSPROPERTY_DIRECTSOUND3DLISTENER_POSITION,
    KSPROPERTY_DIRECTSOUND3DLISTENER_VELOCITY,
    KSPROPERTY_DIRECTSOUND3DLISTENER_ORIENTATION,
    KSPROPERTY_DIRECTSOUND3DLISTENER_DISTANCEFACTOR,
    KSPROPERTY_DIRECTSOUND3DLISTENER_ROLLOFFFACTOR,
    KSPROPERTY_DIRECTSOUND3DLISTENER_DOPPLERFACTOR,
    KSPROPERTY_DIRECTSOUND3DLISTENER_BATCH,
    KSPROPERTY_DIRECTSOUND3DLISTENER_ALLOCATION
} KSPROPERTY_DIRECTSOUND3DLISTENER;

typedef struct {
    DS3DVECTOR  Position;
    DS3DVECTOR  Velocity;
    DS3DVECTOR  OrientFront;
    DS3DVECTOR  OrientTop;
    FLOAT       DistanceFactor;
    FLOAT       RolloffFactor;
    FLOAT       DopplerFactor;
} KSDS3D_LISTENER_ALL, *PKSDS3D_LISTENER_ALL;

typedef struct {
    DS3DVECTOR  Front;
    DS3DVECTOR  Top;
} KSDS3D_LISTENER_ORIENTATION, *PKSDS3D_LISTENER_ORIENTATION;


//===========================================================================
//===========================================================================
// KSPROPSETID_DirectSound3DBuffer : {437B3411-D060-11d0-8583-00C04FD9BAF3}

#define STATIC_KSPROPSETID_DirectSound3DBuffer\
    0x437b3411L, 0xd060, 0x11d0, 0x85, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("437b3411-d060-11d0-8583-00c04fd9baf3", KSPROPSETID_DirectSound3DBuffer);
#define KSPROPSETID_DirectSound3DBuffer DEFINE_GUIDNAMED(KSPROPSETID_DirectSound3DBuffer)


typedef enum {
    KSPROPERTY_DIRECTSOUND3DBUFFER_ALL,
    KSPROPERTY_DIRECTSOUND3DBUFFER_POSITION,
    KSPROPERTY_DIRECTSOUND3DBUFFER_VELOCITY,
    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEANGLES,
    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEORIENTATION,
    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEOUTSIDEVOLUME,
    KSPROPERTY_DIRECTSOUND3DBUFFER_MINDISTANCE,
    KSPROPERTY_DIRECTSOUND3DBUFFER_MAXDISTANCE,
    KSPROPERTY_DIRECTSOUND3DBUFFER_MODE
} KSPROPERTY_DIRECTSOUND3DBUFFER;


typedef struct {
    DS3DVECTOR  Position;
    DS3DVECTOR  Velocity;
    ULONG       InsideConeAngle;
    ULONG       OutsideConeAngle;
    DS3DVECTOR  ConeOrientation;
    LONG        ConeOutsideVolume;
    FLOAT       MinDistance;
    FLOAT       MaxDistance;
    ULONG       Mode;
} KSDS3D_BUFFER_ALL, *PKSDS3D_BUFFER_ALL;

typedef struct {
    ULONG  InsideConeAngle;
    ULONG  OutsideConeAngle;
} KSDS3D_BUFFER_CONE_ANGLES, *PKSDS3D_BUFFER_CONE_ANGLES;

#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_HEADPHONE   (-1)
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_MIN         5
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_NARROW      10
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_WIDE        20
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_MAX         180

#define KSDSOUND_3D_MODE_NORMAL          0x00000000
#define KSDSOUND_3D_MODE_HEADRELATIVE    0x00000001
#define KSDSOUND_3D_MODE_DISABLE         0x00000002

typedef struct {
   KSDATARANGE              DataRange;
   ULONG                    MaximumChannels;
   ULONG                    MinimumBitsPerSample;
   ULONG                    MaximumBitsPerSample;
   ULONG                    MinimumSampleFrequency;
   ULONG                    MaximumSampleFrequency;
} KSDATARANGE_AUDIO, *PKSDATARANGE_AUDIO;

//---------------------------------------------------------------------------

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFF\
    0x4995DAEEL, 0x9EE6, 0x11D0, 0xA4, 0x0E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4995DAEE-9EE6-11D0-A40E-00A0C9223196", KSDATAFORMAT_SUBTYPE_RIFF);
#define KSDATAFORMAT_SUBTYPE_RIFF DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFF)

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFFWAVE\
    0xe436eb8bL, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb8b-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_RIFFWAVE);
#define KSDATAFORMAT_SUBTYPE_RIFFWAVE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFFWAVE)

//===========================================================================
//===========================================================================

#define STATIC_KSPROPSETID_Bibliographic \
    0x07BA150EL, 0xE2B1, 0x11D0, 0xAC, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("07BA150E-E2B1-11D0-AC17-00A0C9223196", KSPROPSETID_Bibliographic);
#define KSPROPSETID_Bibliographic DEFINE_GUIDNAMED(KSPROPSETID_Bibliographic)

//Repeatable tags contain all entries within the property, each preceeded by length
typedef enum {
    KSPROPERTY_BIBLIOGRAPHIC_LEADER = 'RDL ',
    KSPROPERTY_BIBLIOGRAPHIC_LCCN = '010 ',
    KSPROPERTY_BIBLIOGRAPHIC_ISBN = '020 ',
    KSPROPERTY_BIBLIOGRAPHIC_ISSN = '220 ',
    KSPROPERTY_BIBLIOGRAPHIC_CATALOGINGSOURCE = '040 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINPERSONALNAME = '001 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINCORPORATEBODY = '011 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINMEETINGNAME = '111 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINUNIFORMTITLE = '031 ',
    KSPROPERTY_BIBLIOGRAPHIC_UNIFORMTITLE = '042 ',
    KSPROPERTY_BIBLIOGRAPHIC_TITLESTATEMENT = '542 ',
    KSPROPERTY_BIBLIOGRAPHIC_VARYINGFORMTITLE = '642 ',
    KSPROPERTY_BIBLIOGRAPHIC_PUBLICATION = '062 ',
    KSPROPERTY_BIBLIOGRAPHIC_PHYSICALDESCRIPTION = '003 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTITLE = '044 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENT = '094 ',
    KSPROPERTY_BIBLIOGRAPHIC_GENERALNOTE = '005 ',
    KSPROPERTY_BIBLIOGRAPHIC_BIBLIOGRAPHYNOTE = '405 ',
    KSPROPERTY_BIBLIOGRAPHIC_CONTENTSNOTE = '505 ',
    KSPROPERTY_BIBLIOGRAPHIC_CREATIONCREDIT = '805 ',
    KSPROPERTY_BIBLIOGRAPHIC_CITATION = '015 ',
    KSPROPERTY_BIBLIOGRAPHIC_PARTICIPANT = '115 ',
    KSPROPERTY_BIBLIOGRAPHIC_SUMMARY = '025 ',
    KSPROPERTY_BIBLIOGRAPHIC_TARGETAUDIENCE = '125 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDFORMAVAILABLE = '035 ',
    KSPROPERTY_BIBLIOGRAPHIC_SYSTEMDETAILS = '835 ',
    KSPROPERTY_BIBLIOGRAPHIC_AWARDS = '685 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYPERSONALNAME = '006 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTOPICALTERM = '056 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYGEOGRAPHIC = '156 ',
    KSPROPERTY_BIBLIOGRAPHIC_INDEXTERMGENRE = '556 ',
    KSPROPERTY_BIBLIOGRAPHIC_INDEXTERMCURRICULUM = '856 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYUNIFORMTITLE = '037 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYRELATED = '047 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTPERSONALNAME = '008 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTUNIFORMTITLE = '038 '
} KSPROPERTY_BIBLIOGRAPHIC;

#define STATIC_KSPROPSETID_TopologyNode\
    0x45FFAAA1L, 0x6E1B, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("45FFAAA1-6E1B-11D0-BCF2-444553540000", KSPROPSETID_TopologyNode);
#define KSPROPSETID_TopologyNode DEFINE_GUIDNAMED(KSPROPSETID_TopologyNode)

typedef enum {
    KSPROPERTY_TOPOLOGYNODE_ENABLE = 1
} KSPROPERTY_TOPOLOGYNODE;

//===========================================================================
#define STATIC_KSPROPSETID_DrmAudioStream\
    0x2f2c8ddd, 0x4198, 0x4fac, 0xba, 0x29, 0x61, 0xbb, 0x5, 0xb7, 0xde, 0x6
DEFINE_GUIDSTRUCT("2F2C8DDD-4198-4fac-BA29-61BB05B7DE06", KSPROPSETID_DrmAudioStream);
#define KSPROPSETID_DrmAudioStream DEFINE_GUIDNAMED(KSPROPSETID_DrmAudioStream)

typedef enum {
    KSPROPERTY_DRMAUDIOSTREAM_CONTENTID,
    KSPROPERTY_DRMAUDIOSTREAM_AUTHENTICATEFUNCTION
} KSPROPERTY_DRMAUDIOSTREAM;

//===========================================================================
#define STATIC_KSPROPSETID_Audio\
    0x45FFAAA0L, 0x6E1B, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("45FFAAA0-6E1B-11D0-BCF2-444553540000", KSPROPSETID_Audio);
#define KSPROPSETID_Audio DEFINE_GUIDNAMED(KSPROPSETID_Audio)

typedef enum {
    KSPROPERTY_AUDIO_LATENCY = 1,
    KSPROPERTY_AUDIO_COPY_PROTECTION,
    KSPROPERTY_AUDIO_CHANNEL_CONFIG,
    KSPROPERTY_AUDIO_VOLUMELEVEL,
    KSPROPERTY_AUDIO_POSITION,
    KSPROPERTY_AUDIO_DYNAMIC_RANGE,
    KSPROPERTY_AUDIO_QUALITY,
    KSPROPERTY_AUDIO_SAMPLING_RATE,
    KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE,
    KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
    KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
    KSPROPERTY_AUDIO_MUX_SOURCE,
    KSPROPERTY_AUDIO_MUTE,
    KSPROPERTY_AUDIO_BASS,
    KSPROPERTY_AUDIO_MID,
    KSPROPERTY_AUDIO_TREBLE,
    KSPROPERTY_AUDIO_BASS_BOOST,
    KSPROPERTY_AUDIO_EQ_LEVEL,
    KSPROPERTY_AUDIO_NUM_EQ_BANDS,
    KSPROPERTY_AUDIO_EQ_BANDS,
    KSPROPERTY_AUDIO_AGC,
    KSPROPERTY_AUDIO_DELAY,
    KSPROPERTY_AUDIO_LOUDNESS,
    KSPROPERTY_AUDIO_WIDE_MODE,
    KSPROPERTY_AUDIO_WIDENESS,
    KSPROPERTY_AUDIO_REVERB_LEVEL,
    KSPROPERTY_AUDIO_CHORUS_LEVEL,
    KSPROPERTY_AUDIO_DEV_SPECIFIC,
    KSPROPERTY_AUDIO_DEMUX_DEST,
    KSPROPERTY_AUDIO_STEREO_ENHANCE,
    KSPROPERTY_AUDIO_MANUFACTURE_GUID,
    KSPROPERTY_AUDIO_PRODUCT_GUID,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY,
    KSPROPERTY_AUDIO_SURROUND_ENCODE,
    KSPROPERTY_AUDIO_3D_INTERFACE,
    KSPROPERTY_AUDIO_PEAKMETER,
    KSPROPERTY_AUDIO_ALGORITHM_INSTANCE
} KSPROPERTY_AUDIO;

// Audio quality constants
#define KSAUDIO_QUALITY_WORST               0x0
#define KSAUDIO_QUALITY_PC                  0x1
#define KSAUDIO_QUALITY_BASIC               0x2
#define KSAUDIO_QUALITY_ADVANCED            0x3

// Audio CPU resource constants
#define KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU  0x00000000
#define KSAUDIO_CPU_RESOURCES_HOST_CPU      0x7FFFFFFF

typedef struct {
    BOOL    fCopyrighted;
    BOOL    fOriginal;
} KSAUDIO_COPY_PROTECTION, *PKSAUDIO_COPY_PROTECTION;

typedef struct {
    LONG    ActiveSpeakerPositions;
} KSAUDIO_CHANNEL_CONFIG, *PKSAUDIO_CHANNEL_CONFIG;

// Speaker Positions:
#define SPEAKER_FRONT_LEFT              0x1
#define SPEAKER_FRONT_RIGHT             0x2
#define SPEAKER_FRONT_CENTER            0x4
#define SPEAKER_LOW_FREQUENCY           0x8
#define SPEAKER_BACK_LEFT               0x10
#define SPEAKER_BACK_RIGHT              0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER    0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER   0x80
#define SPEAKER_BACK_CENTER             0x100
#define SPEAKER_SIDE_LEFT               0x200
#define SPEAKER_SIDE_RIGHT              0x400
#define SPEAKER_TOP_CENTER              0x800
#define SPEAKER_TOP_FRONT_LEFT          0x1000
#define SPEAKER_TOP_FRONT_CENTER        0x2000
#define SPEAKER_TOP_FRONT_RIGHT         0x4000
#define SPEAKER_TOP_BACK_LEFT           0x8000
#define SPEAKER_TOP_BACK_CENTER         0x10000
#define SPEAKER_TOP_BACK_RIGHT          0x20000

// Bit mask locations reserved for future use
#define SPEAKER_RESERVED                0x7FFC0000

// Used to specify that any possible permutation of speaker configurations
#define SPEAKER_ALL                     0x80000000

// DirectSound Speaker Config
#define KSAUDIO_SPEAKER_MONO            (SPEAKER_FRONT_CENTER)
#define KSAUDIO_SPEAKER_STEREO          (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT)
#define KSAUDIO_SPEAKER_QUAD            (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_BACK_LEFT  | SPEAKER_BACK_RIGHT)
#define KSAUDIO_SPEAKER_SURROUND        (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_BACK_CENTER)
#define KSAUDIO_SPEAKER_5POINT1         (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_BACK_LEFT  | SPEAKER_BACK_RIGHT)
#define KSAUDIO_SPEAKER_7POINT1         (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | \
                                         SPEAKER_FRONT_LEFT_OF_CENTER | SPEAKER_FRONT_RIGHT_OF_CENTER)

// DVD Speaker Positions
#define KSAUDIO_SPEAKER_GROUND_FRONT_LEFT   SPEAKER_FRONT_LEFT
#define KSAUDIO_SPEAKER_GROUND_FRONT_CENTER SPEAKER_FRONT_CENTER
#define KSAUDIO_SPEAKER_GROUND_FRONT_RIGHT  SPEAKER_FRONT_RIGHT
#define KSAUDIO_SPEAKER_GROUND_REAR_LEFT    SPEAKER_BACK_LEFT
#define KSAUDIO_SPEAKER_GROUND_REAR_RIGHT   SPEAKER_BACK_RIGHT
#define KSAUDIO_SPEAKER_TOP_MIDDLE          SPEAKER_TOP_CENTER
#define KSAUDIO_SPEAKER_SUPER_WOOFER        SPEAKER_LOW_FREQUENCY

typedef struct {
    ULONG   QuietCompression;
    ULONG   LoudCompression;
} KSAUDIO_DYNAMIC_RANGE, *PKSAUDIO_DYNAMIC_RANGE;

typedef struct {
    BOOL    Mute;
    LONG    Level;
} KSAUDIO_MIXLEVEL, *PKSAUDIO_MIXLEVEL;

typedef struct {
    BOOL    Mute;
    LONG    Minimum;
    LONG    Maximum;
    LONG    Reset;
} KSAUDIO_MIX_CAPS, *PKSAUDIO_MIX_CAPS;

typedef struct {
    ULONG               InputChannels;
    ULONG               OutputChannels;
    KSAUDIO_MIX_CAPS    Capabilities[1];
} KSAUDIO_MIXCAP_TABLE, *PKSAUDIO_MIXCAP_TABLE;

typedef enum {
    SE_TECH_NONE,
    SE_TECH_ANALOG_DEVICES_PHAT,
    SE_TECH_CREATIVE,
    SE_TECH_NATIONAL_SEMI,
    SE_TECH_YAMAHA_YMERSION,
    SE_TECH_BBE,
    SE_TECH_CRYSTAL_SEMI,
    SE_TECH_QSOUND_QXPANDER,
    SE_TECH_SPATIALIZER,
    SE_TECH_SRS,
    SE_TECH_PLATFORM_TECH,
    SE_TECH_AKM,
    SE_TECH_AUREAL,
    SE_TECH_AZTECH,
    SE_TECH_BINAURA,
    SE_TECH_ESS_TECH,
    SE_TECH_HARMAN_VMAX,
    SE_TECH_NVIDEA,
    SE_TECH_PHILIPS_INCREDIBLE,
    SE_TECH_TEXAS_INST,
    SE_TECH_VLSI_TECH
} SE_TECHNIQUE;

typedef struct {
    SE_TECHNIQUE    Technique;
    ULONG   Center;
    ULONG   Depth;
    ULONG   Reserved;
} KSAUDIO_STEREO_ENHANCE, *PKSAUDIO_STEREO_ENHANCE;

//===========================================================================
// Topology Node Type GUIDs

#define STATIC_KSNODETYPE_DAC\
    0x507AE360L, 0xC554, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("507AE360-C554-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DAC);
#define KSNODETYPE_DAC DEFINE_GUIDNAMED(KSNODETYPE_DAC)

#define STATIC_KSNODETYPE_ADC\
    0x4D837FE0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("4D837FE0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_ADC);
#define KSNODETYPE_ADC DEFINE_GUIDNAMED(KSNODETYPE_ADC)

#define STATIC_KSNODETYPE_SRC\
    0x9DB7B9E0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("9DB7B9E0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SRC);
#define KSNODETYPE_SRC DEFINE_GUIDNAMED(KSNODETYPE_SRC)

#define STATIC_KSNODETYPE_SUPERMIX\
    0xE573ADC0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("E573ADC0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SUPERMIX);
#define KSNODETYPE_SUPERMIX DEFINE_GUIDNAMED(KSNODETYPE_SUPERMIX)

#define STATIC_KSNODETYPE_MUX\
    0x2CEAF780L, 0xC556, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("2CEAF780-C556-11D0-8A2B-00A0C9255AC1", KSNODETYPE_MUX);
#define KSNODETYPE_MUX DEFINE_GUIDNAMED(KSNODETYPE_MUX)

#define STATIC_KSNODETYPE_DEMUX\
    0xC0EB67D4L, 0xE807, 0x11D0, 0x95, 0x8A, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("C0EB67D4-E807-11D0-958A-00C04FB925D3", KSNODETYPE_DEMUX);
#define KSNODETYPE_DEMUX DEFINE_GUIDNAMED(KSNODETYPE_DEMUX)

#define STATIC_KSNODETYPE_SUM\
    0xDA441A60L, 0xC556, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("DA441A60-C556-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SUM);
#define KSNODETYPE_SUM DEFINE_GUIDNAMED(KSNODETYPE_SUM)

#define STATIC_KSNODETYPE_MUTE\
    0x02B223C0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("02B223C0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_MUTE);
#define KSNODETYPE_MUTE DEFINE_GUIDNAMED(KSNODETYPE_MUTE)

#define STATIC_KSNODETYPE_VOLUME\
    0x3A5ACC00L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("3A5ACC00-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_VOLUME);
#define KSNODETYPE_VOLUME DEFINE_GUIDNAMED(KSNODETYPE_VOLUME)

#define STATIC_KSNODETYPE_TONE\
    0x7607E580L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("7607E580-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_TONE);
#define KSNODETYPE_TONE DEFINE_GUIDNAMED(KSNODETYPE_TONE)

#define STATIC_KSNODETYPE_EQUALIZER\
    0x9D41B4A0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("9D41B4A0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_EQUALIZER);
#define KSNODETYPE_EQUALIZER DEFINE_GUIDNAMED(KSNODETYPE_EQUALIZER)

#define STATIC_KSNODETYPE_AGC\
    0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("E88C9BA0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_AGC);
#define KSNODETYPE_AGC DEFINE_GUIDNAMED(KSNODETYPE_AGC)

#define STATIC_KSNODETYPE_NOISE_SUPPRESS\
    0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5
DEFINE_GUIDSTRUCT("E07F903F-62FD-4e60-8CDD-DEA7236665B5", KSNODETYPE_NOISE_SUPPRESS);
#define KSNODETYPE_NOISE_SUPPRESS DEFINE_GUIDNAMED(KSNODETYPE_NOISE_SUPPRESS)

#define STATIC_KSNODETYPE_DELAY\
    0x144981E0L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("144981E0-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DELAY);
#define KSNODETYPE_DELAY DEFINE_GUIDNAMED(KSNODETYPE_DELAY)

#define STATIC_KSNODETYPE_LOUDNESS\
    0x41887440L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("41887440-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_LOUDNESS);
#define KSNODETYPE_LOUDNESS DEFINE_GUIDNAMED(KSNODETYPE_LOUDNESS)

#define STATIC_KSNODETYPE_PROLOGIC_DECODER\
    0x831C2C80L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("831C2C80-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_PROLOGIC_DECODER);
#define KSNODETYPE_PROLOGIC_DECODER DEFINE_GUIDNAMED(KSNODETYPE_PROLOGIC_DECODER)

#define STATIC_KSNODETYPE_STEREO_WIDE\
    0xA9E69800L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("A9E69800-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_STEREO_WIDE);
#define KSNODETYPE_STEREO_WIDE DEFINE_GUIDNAMED(KSNODETYPE_STEREO_WIDE)

#define STATIC_KSNODETYPE_STEREO_ENHANCE\
    0xAF6878ACL, 0xE83F, 0x11D0, 0x95, 0x8A, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("AF6878AC-E83F-11D0-958A-00C04FB925D3", KSNODETYPE_STEREO_ENHANCE);
#define KSNODETYPE_STEREO_ENHANCE DEFINE_GUIDNAMED(KSNODETYPE_STEREO_ENHANCE)

#define STATIC_KSNODETYPE_REVERB\
    0xEF0328E0L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("EF0328E0-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_REVERB);
#define KSNODETYPE_REVERB DEFINE_GUIDNAMED(KSNODETYPE_REVERB)

#define STATIC_KSNODETYPE_CHORUS\
    0x20173F20L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("20173F20-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_CHORUS);
#define KSNODETYPE_CHORUS DEFINE_GUIDNAMED(KSNODETYPE_CHORUS)

#define STATIC_KSNODETYPE_3D_EFFECTS\
    0x55515860L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("55515860-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_3D_EFFECTS);
#define KSNODETYPE_3D_EFFECTS DEFINE_GUIDNAMED(KSNODETYPE_3D_EFFECTS)

#define STATIC_KSNODETYPE_ACOUSTIC_ECHO_CANCEL STATIC_KSCATEGORY_ACOUSTIC_ECHO_CANCEL
#define KSNODETYPE_ACOUSTIC_ECHO_CANCEL KSCATEGORY_ACOUSTIC_ECHO_CANCEL

#define STATIC_KSNODETYPE_DEV_SPECIFIC\
    0x941C7AC0L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("941C7AC0-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DEV_SPECIFIC);
#define KSNODETYPE_DEV_SPECIFIC DEFINE_GUIDNAMED(KSNODETYPE_DEV_SPECIFIC)

#define STATIC_KSNODETYPE_SURROUND_ENCODER\
    0x8074C5B2L, 0x3C66, 0x11D2, 0xB4, 0x5A, 0x30, 0x78, 0x30, 0x2C, 0x20, 0x30
DEFINE_GUIDSTRUCT("8074C5B2-3C66-11D2-B45A-3078302C2030", KSNODETYPE_SURROUND_ENCODER);
#define KSNODETYPE_SURROUND_ENCODER DEFINE_GUIDNAMED(KSNODETYPE_SURROUND_ENCODER)

#define STATIC_KSNODETYPE_PEAKMETER\
    0xa085651eL, 0x5f0d, 0x4b36, 0xa8, 0x69, 0xd1, 0x95, 0xd6, 0xab, 0x4b, 0x9e
DEFINE_GUIDSTRUCT("A085651E-5F0D-4b36-A869-D195D6AB4B9E", KSNODETYPE_PEAKMETER);
#define KSNODETYPE_PEAKMETER DEFINE_GUIDNAMED(KSNODETYPE_PEAKMETER)

//===========================================================================
// Topology Node Name GUIDs for common audio nodes
#define STATIC_KSAUDFNAME_BASS\
    0x185FEDE0L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE0-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_BASS);
#define KSAUDFNAME_BASS DEFINE_GUIDNAMED(KSAUDFNAME_BASS)

#define STATIC_KSAUDFNAME_TREBLE\
    0x185FEDE1L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE1-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_TREBLE);
#define KSAUDFNAME_TREBLE DEFINE_GUIDNAMED(KSAUDFNAME_TREBLE)

#define STATIC_KSAUDFNAME_3D_STEREO\
    0x185FEDE2L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE2-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_3D_STEREO);
#define KSAUDFNAME_3D_STEREO DEFINE_GUIDNAMED(KSAUDFNAME_3D_STEREO)

#define STATIC_KSAUDFNAME_MASTER_VOLUME\
    0x185FEDE3L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE3-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MASTER_VOLUME);
#define KSAUDFNAME_MASTER_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MASTER_VOLUME)

#define STATIC_KSAUDFNAME_MASTER_MUTE\
    0x185FEDE4L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE4-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MASTER_MUTE);
#define KSAUDFNAME_MASTER_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MASTER_MUTE)

#define STATIC_KSAUDFNAME_WAVE_VOLUME\
    0x185FEDE5L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE5-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_VOLUME);
#define KSAUDFNAME_WAVE_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_VOLUME)

#define STATIC_KSAUDFNAME_WAVE_MUTE\
    0x185FEDE6L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE6-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_MUTE);
#define KSAUDFNAME_WAVE_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_MUTE)

#define STATIC_KSAUDFNAME_MIDI_VOLUME\
    0x185FEDE7L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE7-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_VOLUME);
#define KSAUDFNAME_MIDI_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_VOLUME)

#define STATIC_KSAUDFNAME_MIDI_MUTE\
    0x185FEDE8L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE8-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_MUTE);
#define KSAUDFNAME_MIDI_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_MUTE)

#define STATIC_KSAUDFNAME_CD_VOLUME\
    0x185FEDE9L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE9-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_VOLUME);
#define KSAUDFNAME_CD_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_CD_VOLUME)

#define STATIC_KSAUDFNAME_CD_MUTE\
    0x185FEDEAL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEA-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_MUTE);
#define KSAUDFNAME_CD_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_CD_MUTE)

#define STATIC_KSAUDFNAME_LINE_VOLUME\
    0x185FEDEBL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEB-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_VOLUME);
#define KSAUDFNAME_LINE_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_LINE_VOLUME)

#define STATIC_KSAUDFNAME_LINE_MUTE\
    0x185FEDECL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEC-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_MUTE);
#define KSAUDFNAME_LINE_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_LINE_MUTE)

#define STATIC_KSAUDFNAME_MIC_VOLUME\
    0x185FEDEDL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDED-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_VOLUME);
#define KSAUDFNAME_MIC_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIC_VOLUME)

#define STATIC_KSAUDFNAME_MIC_MUTE\
    0x185FEDEEL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEE-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_MUTE);
#define KSAUDFNAME_MIC_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MIC_MUTE)

#define STATIC_KSAUDFNAME_RECORDING_SOURCE\
    0x185FEDEFL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEF-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_RECORDING_SOURCE);
#define KSAUDFNAME_RECORDING_SOURCE DEFINE_GUIDNAMED(KSAUDFNAME_RECORDING_SOURCE)

#define STATIC_KSAUDFNAME_PC_SPEAKER_VOLUME\
    0x185FEDF0L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF0-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER_VOLUME);
#define KSAUDFNAME_PC_SPEAKER_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER_VOLUME)

#define STATIC_KSAUDFNAME_PC_SPEAKER_MUTE\
    0x185FEDF1L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF1-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER_MUTE);
#define KSAUDFNAME_PC_SPEAKER_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER_MUTE)

#define STATIC_KSAUDFNAME_MIDI_IN_VOLUME\
    0x185FEDF2L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF2-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_IN_VOLUME);
#define KSAUDFNAME_MIDI_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_IN_VOLUME)

#define STATIC_KSAUDFNAME_CD_IN_VOLUME\
    0x185FEDF3L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF3-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_IN_VOLUME);
#define KSAUDFNAME_CD_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_CD_IN_VOLUME)

#define STATIC_KSAUDFNAME_LINE_IN_VOLUME\
    0x185FEDF4L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF4-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_IN_VOLUME);
#define KSAUDFNAME_LINE_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_LINE_IN_VOLUME)

#define STATIC_KSAUDFNAME_MIC_IN_VOLUME\
    0x185FEDF5L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF5-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_IN_VOLUME);
#define KSAUDFNAME_MIC_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIC_IN_VOLUME)

#define STATIC_KSAUDFNAME_WAVE_IN_VOLUME\
    0x185FEDF6L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF6-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_IN_VOLUME);
#define KSAUDFNAME_WAVE_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_IN_VOLUME)

#define STATIC_KSAUDFNAME_VOLUME_CONTROL\
    0x185FEDF7L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF7-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_VOLUME_CONTROL);
#define KSAUDFNAME_VOLUME_CONTROL DEFINE_GUIDNAMED(KSAUDFNAME_VOLUME_CONTROL)

#define STATIC_KSAUDFNAME_MIDI\
    0x185FEDF8L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF8-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI);
#define KSAUDFNAME_MIDI DEFINE_GUIDNAMED(KSAUDFNAME_MIDI)

#define STATIC_KSAUDFNAME_LINE_IN\
    0x185FEDF9L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF9-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_IN);
#define KSAUDFNAME_LINE_IN DEFINE_GUIDNAMED(KSAUDFNAME_LINE_IN)

#define STATIC_KSAUDFNAME_RECORDING_CONTROL\
    0x185FEDFAL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFA-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_RECORDING_CONTROL);
#define KSAUDFNAME_RECORDING_CONTROL DEFINE_GUIDNAMED(KSAUDFNAME_RECORDING_CONTROL)

#define STATIC_KSAUDFNAME_CD_AUDIO\
    0x185FEDFBL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFB-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_AUDIO);
#define KSAUDFNAME_CD_AUDIO DEFINE_GUIDNAMED(KSAUDFNAME_CD_AUDIO)

#define STATIC_KSAUDFNAME_AUX_VOLUME\
    0x185FEDFCL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFC-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX_VOLUME);
#define KSAUDFNAME_AUX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_AUX_VOLUME)

#define STATIC_KSAUDFNAME_AUX_MUTE\
    0x185FEDFDL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFD-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX_MUTE);
#define KSAUDFNAME_AUX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_AUX_MUTE)

#define STATIC_KSAUDFNAME_AUX\
    0x185FEDFEL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFE-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX);
#define KSAUDFNAME_AUX DEFINE_GUIDNAMED(KSAUDFNAME_AUX)

#define STATIC_KSAUDFNAME_PC_SPEAKER\
    0x185FEDFFL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFF-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER);
#define KSAUDFNAME_PC_SPEAKER DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER)

#define STATIC_KSAUDFNAME_WAVE_OUT_MIX\
    0x185FEE00L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEE00-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_OUT_MIX);
#define KSAUDFNAME_WAVE_OUT_MIX DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_OUT_MIX)

#define STATIC_KSAUDFNAME_MONO_OUT\
    0xf9b41dc3L, 0x96e2, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("F9B41DC3-96E2-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT);
#define KSAUDFNAME_MONO_OUT DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT)

#define STATIC_KSAUDFNAME_STEREO_MIX\
    0xdff077L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("00DFF077-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX);
#define KSAUDFNAME_STEREO_MIX DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX)

#define STATIC_KSAUDFNAME_MONO_MIX\
    0xdff078L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("00DFF078-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX);
#define KSAUDFNAME_MONO_MIX DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX)

#define STATIC_KSAUDFNAME_MONO_OUT_VOLUME\
    0x1ad247ebL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247EB-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT_VOLUME);
#define KSAUDFNAME_MONO_OUT_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT_VOLUME)

#define STATIC_KSAUDFNAME_MONO_OUT_MUTE\
    0x1ad247ecL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247EC-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT_MUTE);
#define KSAUDFNAME_MONO_OUT_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT_MUTE)

#define STATIC_KSAUDFNAME_STEREO_MIX_VOLUME\
    0x1ad247edL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247ED-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX_VOLUME);
#define KSAUDFNAME_STEREO_MIX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX_VOLUME)

#define STATIC_KSAUDFNAME_STEREO_MIX_MUTE\
    0x22b0eafdL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("22B0EAFD-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX_MUTE);
#define KSAUDFNAME_STEREO_MIX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX_MUTE)

#define STATIC_KSAUDFNAME_MONO_MIX_VOLUME\
    0x22b0eafeL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("22B0EAFE-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX_VOLUME);
#define KSAUDFNAME_MONO_MIX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX_VOLUME)

#define STATIC_KSAUDFNAME_MONO_MIX_MUTE\
    0x2bc31d69L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D69-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX_MUTE);
#define KSAUDFNAME_MONO_MIX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX_MUTE)

#define STATIC_KSAUDFNAME_MICROPHONE_BOOST\
    0x2bc31d6aL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D6A-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MICROPHONE_BOOST);
#define KSAUDFNAME_MICROPHONE_BOOST DEFINE_GUIDNAMED(KSAUDFNAME_MICROPHONE_BOOST)

#define STATIC_KSAUDFNAME_ALTERNATE_MICROPHONE\
    0x2bc31d6bL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D6B-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_ALTERNATE_MICROPHONE);
#define KSAUDFNAME_ALTERNATE_MICROPHONE DEFINE_GUIDNAMED(KSAUDFNAME_ALTERNATE_MICROPHONE)

#define STATIC_KSAUDFNAME_3D_DEPTH\
    0x63ff5747L, 0x991f, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("63FF5747-991F-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_3D_DEPTH);
#define KSAUDFNAME_3D_DEPTH DEFINE_GUIDNAMED(KSAUDFNAME_3D_DEPTH)

#define STATIC_KSAUDFNAME_3D_CENTER\
    0x9f0670b4L, 0x991f, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9F0670B4-991F-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_3D_CENTER);
#define KSAUDFNAME_3D_CENTER DEFINE_GUIDNAMED(KSAUDFNAME_3D_CENTER)

#define STATIC_KSAUDFNAME_VIDEO_VOLUME\
    0x9b46e708L, 0x992a, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9B46E708-992A-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_VIDEO_VOLUME);
#define KSAUDFNAME_VIDEO_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO_VOLUME)

#define STATIC_KSAUDFNAME_VIDEO_MUTE\
    0x9b46e709L, 0x992a, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9B46E709-992A-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_VIDEO_MUTE);
#define KSAUDFNAME_VIDEO_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO_MUTE)

#define STATIC_KSAUDFNAME_VIDEO\
    0x915daec4L, 0xa434, 0x11d2, 0xac, 0x52, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("915DAEC4-A434-11d2-AC52-00C04F8EFB68", KSAUDFNAME_VIDEO);
#define KSAUDFNAME_VIDEO DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO)

#define STATIC_KSAUDFNAME_PEAKMETER\
    0x57e24340L, 0xfc5b, 0x4612, 0xa5, 0x62, 0x72, 0xb1, 0x1a, 0x29, 0xdf, 0xae
DEFINE_GUIDSTRUCT("57E24340-FC5B-4612-A562-72B11A29DFAE", KSAUDFNAME_PEAKMETER);
#define KSAUDFNAME_PEAKMETER DEFINE_GUIDNAMED(KSAUDFNAME_PEAKMETER)

// Internal topology node pin definitions

#define KSNODEPIN_STANDARD_IN       1
#define KSNODEPIN_STANDARD_OUT      0

#define KSNODEPIN_SUM_MUX_IN        1   // can be >= 1
#define KSNODEPIN_SUM_MUX_OUT       0

#define KSNODEPIN_DEMUX_IN          0
#define KSNODEPIN_DEMUX_OUT         1   // can be >= 1

#define KSNODEPIN_AEC_RENDER_IN     1
#define KSNODEPIN_AEC_RENDER_OUT    0
#define KSNODEPIN_AEC_CAPTURE_IN    2
#define KSNODEPIN_AEC_CAPTURE_OUT   3

//===========================================================================
//===========================================================================

#define STATIC_KSMETHODSETID_Wavetable\
    0xDCEF31EBL, 0xD907, 0x11D0, 0x95, 0x83, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("DCEF31EB-D907-11D0-9583-00C04FB925D3", KSMETHODSETID_Wavetable);
#define KSMETHODSETID_Wavetable DEFINE_GUIDNAMED(KSMETHODSETID_Wavetable)

typedef enum {
    KSMETHOD_WAVETABLE_WAVE_ALLOC,
    KSMETHOD_WAVETABLE_WAVE_FREE,
    KSMETHOD_WAVETABLE_WAVE_FIND,
    KSMETHOD_WAVETABLE_WAVE_WRITE
} KSMETHOD_WAVETABLE;

typedef struct {
    KSIDENTIFIER        Identifier;                     // wave identifier
    ULONG               Size;                           // wave size
    BOOL                Looped;                         // wave looped flag
    ULONG               LoopPoint;                      // wave loop point
    BOOL                InROM;                          // wave InROM flag
    KSDATAFORMAT        Format;                         // wave format
} KSWAVETABLE_WAVE_DESC, *PKSWAVETABLE_WAVE_DESC;


//===========================================================================
//===========================================================================

/*
    Property sets and items
*/

//===========================================================================
//===========================================================================

#define STATIC_KSPROPSETID_Itd3d\
    0x6429f090L, 0x9fd9, 0x11d0, 0xa7, 0x5b, 0x00, 0xa0, 0xc9, 0x03, 0x65, 0xe3
DEFINE_GUIDSTRUCT("6429f090-9fd9-11d0-a75b-00a0c90365e3", KSPROPSETID_Itd3d);
#define KSPROPSETID_Itd3d DEFINE_GUIDNAMED(KSPROPSETID_Itd3d)

typedef enum {
    KSPROPERTY_ITD3D_PARAMS = 0
} KSPROPERTY_ITD3D;

//===========================================================================
//===========================================================================

#define STATIC_KSPROPSETID_Hrtf3d\
    0xb66decb0L, 0xa083, 0x11d0, 0x85, 0x1e, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("b66decb0-a083-11d0-851e-00c04fd9baf3", KSPROPSETID_Hrtf3d);
#define KSPROPSETID_Hrtf3d DEFINE_GUIDNAMED(KSPROPSETID_Hrtf3d)

typedef enum {
    KSPROPERTY_HRTF3D_PARAMS = 0,
    KSPROPERTY_HRTF3D_INITIALIZE,
    KSPROPERTY_HRTF3D_FILTER_FORMAT
} KSPROPERTY_HRTF3D;


//===========================================================================
//===========================================================================

#define STATIC_KSPROPSETID_Wave_Queued\
    0x16a15b10L, 0x16f0, 0x11d0, 0xa1, 0x95, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("16a15b10-16f0-11d0-a195-0020afd156e4", KSPROPSETID_Wave_Queued);
#define KSPROPSETID_Wave_Queued DEFINE_GUIDNAMED(KSPROPSETID_Wave_Queued)

#define KSPROPERTY_WAVE_QUEUED_POSITION                 0x00000001

#define STATIC_KSMETHODSETID_Wave_Queued\
    0x7432c160L, 0x8827, 0x11cf, 0xa1, 0x02, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("7432c160-8827-11cf-a102-0020afd156e4", KSMETHODSETID_Wave_Queued);
#define KSMETHODSETID_Wave_Queued DEFINE_GUIDNAMED(KSMETHODSETID_Wave_Queued)

#define KSMETHOD_WAVE_QUEUED_BREAKLOOP                  0x00000001

#define STATIC_KSPROPSETID_Wave\
    0x924e54b0L, 0x630f, 0x11cf, 0xad, 0xa7, 0x08, 0x00, 0x3e, 0x30, 0x49, 0x4a
DEFINE_GUIDSTRUCT("924e54b0-630f-11cf-ada7-08003e30494a", KSPROPSETID_Wave);
#define KSPROPSETID_Wave DEFINE_GUIDNAMED(KSPROPSETID_Wave)

typedef enum {
    KSPROPERTY_WAVE_COMPATIBLE_CAPABILITIES,
    KSPROPERTY_WAVE_INPUT_CAPABILITIES,
    KSPROPERTY_WAVE_OUTPUT_CAPABILITIES,
    KSPROPERTY_WAVE_BUFFER,
    KSPROPERTY_WAVE_FREQUENCY,
    KSPROPERTY_WAVE_VOLUME,
    KSPROPERTY_WAVE_PAN
} KSPROPERTY_WAVE;

typedef struct {
    ULONG        ulDeviceType;
} KSWAVE_COMPATCAPS, *PKSWAVE_COMPATCAPS;

#define KSWAVE_COMPATCAPS_INPUT                 0x00000000
#define KSWAVE_COMPATCAPS_OUTPUT                0x00000001

typedef struct {
    ULONG  MaximumChannelsPerConnection;
    ULONG  MinimumBitsPerSample;
    ULONG  MaximumBitsPerSample;
    ULONG  MinimumSampleFrequency;
    ULONG  MaximumSampleFrequency;
    ULONG  TotalConnections;
    ULONG  ActiveConnections;
} KSWAVE_INPUT_CAPABILITIES, *PKSWAVE_INPUT_CAPABILITIES;

typedef struct {
    ULONG  MaximumChannelsPerConnection;
    ULONG  MinimumBitsPerSample;
    ULONG  MaximumBitsPerSample;
    ULONG  MinimumSampleFrequency;
    ULONG  MaximumSampleFrequency;
    ULONG  TotalConnections;
    ULONG  StaticConnections;
    ULONG  StreamingConnections;
    ULONG  ActiveConnections;
    ULONG  ActiveStaticConnections;
    ULONG  ActiveStreamingConnections;
    ULONG  Total3DConnections;
    ULONG  Static3DConnections;
    ULONG  Streaming3DConnections;
    ULONG  Active3DConnections;
    ULONG  ActiveStatic3DConnections;
    ULONG  ActiveStreaming3DConnections;
    ULONG  TotalSampleMemory;
    ULONG  FreeSampleMemory;
    ULONG  LargestFreeContiguousSampleMemory;
} KSWAVE_OUTPUT_CAPABILITIES, *PKSWAVE_OUTPUT_CAPABILITIES;

typedef struct {
    LONG  LeftAttenuation;
    LONG  RightAttenuation;
} KSWAVE_VOLUME, *PKSWAVE_VOLUME;

#define KSWAVE_BUFFER_ATTRIBUTEF_LOOPING   0x00000001
#define KSWAVE_BUFFER_ATTRIBUTEF_STATIC    0x00000002

typedef struct {
    ULONG   Attributes;
    ULONG   BufferSize;
    PVOID   BufferAddress;
} KSWAVE_BUFFER, *PKSWAVE_BUFFER;

//===========================================================================
//===========================================================================

#define STATIC_KSMUSIC_TECHNOLOGY_PORT\
    0x86C92E60L, 0x62E8, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("86C92E60-62E8-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_PORT);
#define KSMUSIC_TECHNOLOGY_PORT DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_PORT)

#define STATIC_KSMUSIC_TECHNOLOGY_SQSYNTH\
    0x0ECF4380L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("0ECF4380-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_SQSYNTH);
#define KSMUSIC_TECHNOLOGY_SQSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_SQSYNTH)

#define STATIC_KSMUSIC_TECHNOLOGY_FMSYNTH\
    0x252C5C80L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("252C5C80-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_FMSYNTH);
#define KSMUSIC_TECHNOLOGY_FMSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_FMSYNTH)

#define STATIC_KSMUSIC_TECHNOLOGY_WAVETABLE\
    0x394EC7C0L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("394EC7C0-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_WAVETABLE);
#define KSMUSIC_TECHNOLOGY_WAVETABLE DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_WAVETABLE)

#define STATIC_KSMUSIC_TECHNOLOGY_SWSYNTH\
    0x37407736L, 0x3620, 0x11D1, 0x85, 0xD3, 0x00, 0x00, 0xF8, 0x75, 0x43, 0x80
DEFINE_GUIDSTRUCT("37407736-3620-11D1-85D3-0000F8754380", KSMUSIC_TECHNOLOGY_SWSYNTH);
#define KSMUSIC_TECHNOLOGY_SWSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_SWSYNTH)

#define STATIC_KSPROPSETID_WaveTable\
    0x8539E660L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("8539E660-62E9-11CF-A5D6-28DB04C10000", KSPROPSETID_WaveTable);
#define KSPROPSETID_WaveTable DEFINE_GUIDNAMED(KSPROPSETID_WaveTable)

typedef enum {
    KSPROPERTY_WAVETABLE_LOAD_SAMPLE,
    KSPROPERTY_WAVETABLE_UNLOAD_SAMPLE,
    KSPROPERTY_WAVETABLE_MEMORY,
    KSPROPERTY_WAVETABLE_VERSION
} KSPROPERTY_WAVETABLE;

typedef struct {
   KSDATARANGE              DataRange;
   GUID                     Technology;
   ULONG                    Channels;
   ULONG                    Notes;
   ULONG                    ChannelMask;
} KSDATARANGE_MUSIC, *PKSDATARANGE_MUSIC;

//===========================================================================

#define STATIC_KSEVENTSETID_Cyclic\
    0x142C1AC0L, 0x072A, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("142C1AC0-072A-11D0-A5D6-28DB04C10000", KSEVENTSETID_Cyclic);
#define KSEVENTSETID_Cyclic DEFINE_GUIDNAMED(KSEVENTSETID_Cyclic)

typedef enum {
    KSEVENT_CYCLIC_TIME_INTERVAL,
} KSEVENT_CYCLIC_TIME;

#define STATIC_KSPROPSETID_Cyclic\
    0x3FFEAEA0L, 0x2BEE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("3FFEAEA0-2BEE-11CF-A5D6-28DB04C10000", KSPROPSETID_Cyclic);
#define KSPROPSETID_Cyclic DEFINE_GUIDNAMED(KSPROPSETID_Cyclic)

typedef enum {
    KSPROPERTY_CYCLIC_POSITION,
} KSPROPERTY_CYCLIC;

//===========================================================================
#define STATIC_KSEVENTSETID_AudioControlChange\
    0xE85E9698L, 0xFA2F, 0x11D1, 0x95, 0xBD, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("E85E9698-FA2F-11D1-95BD-00C04FB925D3", KSEVENTSETID_AudioControlChange);
#define KSEVENTSETID_AudioControlChange DEFINE_GUIDNAMED(KSEVENTSETID_AudioControlChange)

typedef enum {
    KSEVENT_CONTROL_CHANGE,
} KSEVENT_AUDIO_CONTROL_CHANGE;

//===========================================================================

#define STATIC_KSEVENTSETID_LoopedStreaming\
    0x4682B940L, 0xC6EF, 0x11D0, 0x96, 0xD8, 0x00, 0xAA, 0x00, 0x51, 0xE5, 0x1D
DEFINE_GUIDSTRUCT("4682B940-C6EF-11D0-96D8-00AA0051E51D", KSEVENTSETID_LoopedStreaming);
#define KSEVENTSETID_LoopedStreaming DEFINE_GUIDNAMED(KSEVENTSETID_LoopedStreaming)

typedef enum {
    KSEVENT_LOOPEDSTREAMING_POSITION,
} KSEVENT_LOOPEDSTREAMING;

typedef struct {
    KSEVENTDATA KsEventData;
#if defined(_NTDDK_)
    ULONGLONG   Position;
#else // !_NTDDK_
    DWORDLONG   Position;
#endif // !_NTDDK_
} LOOPEDSTREAMING_POSITION_EVENT_DATA, *PLOOPEDSTREAMING_POSITION_EVENT_DATA ;

#define STATIC_KSEVENTSETID_Sysaudio \
    0x04800320L, 0x4491, 0x11D1, 0xA0, 0x50, 0x40, 0x57, 0x05, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("04800320-4491-11D1-A050-405705C10000", KSEVENTSETID_Sysaudio);
#define KSEVENTSETID_Sysaudio DEFINE_GUIDNAMED(KSEVENTSETID_Sysaudio)

typedef enum {
    KSEVENT_SYSAUDIO_ADDREMOVE_DEVICE,
    KSEVENT_SYSAUDIO_CHANGE_DEVICE
} KSEVENT_SYSAUDIO;

#define STATIC_KSPROPSETID_Sysaudio\
    0xCBE3FAA0L, 0xCC75, 0x11D0, 0xB4, 0x65, 0x00, 0x00, 0x1A, 0x18, 0x18, 0xE6
DEFINE_GUIDSTRUCT("CBE3FAA0-CC75-11D0-B465-00001A1818E6", KSPROPSETID_Sysaudio);
#define KSPROPSETID_Sysaudio DEFINE_GUIDNAMED(KSPROPSETID_Sysaudio)

typedef enum {
    KSPROPERTY_SYSAUDIO_DEVICE_COUNT = 1,
    KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME,
    KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
    KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME,
    KSPROPERTY_SYSAUDIO_SELECT_GRAPH,
    KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE,
    KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT,
    KSPROPERTY_SYSAUDIO_ALWAYS_CREATE_VIRTUAL_SOURCE,
    KSPROPERTY_SYSAUDIO_ADDREMOVE_LOCK,
    KSPROPERTY_SYSAUDIO_ADDREMOVE_UNLOCK,
    KSPROPERTY_SYSAUDIO_RENDER_PIN_INSTANCES,
    KSPROPERTY_SYSAUDIO_RENDER_CONNECTION_INDEX,
    KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE_ONLY,
    KSPROPERTY_SYSAUDIO_INSTANCE_INFO,
    KSPROPERTY_SYSAUDIO_PREFERRED_DEVICE
} KSPROPERTY_SYSAUDIO;

typedef struct {
    KSPROPERTY Property;
    GUID PinCategory;
    GUID PinName;
} SYSAUDIO_CREATE_VIRTUAL_SOURCE, *PSYSAUDIO_CREATE_VIRTUAL_SOURCE;

typedef struct {
    KSPROPERTY Property;
    ULONG PinId;
    ULONG NodeId;
    ULONG Flags;
    ULONG Reserved;
} SYSAUDIO_SELECT_GRAPH, *PSYSAUDIO_SELECT_GRAPH;

typedef struct {
    KSPROPERTY Property;
    ULONG Flags;
    ULONG DeviceNumber;
} SYSAUDIO_INSTANCE_INFO, *PSYSAUDIO_INSTANCE_INFO;

#define SYSAUDIO_FLAGS_DONT_COMBINE_PINS        0x00000001

typedef struct {
    KSPROPERTY Property;
    ULONG Flags;
    ULONG Index;            // KSPROPERTY_SYSAUDIO_DEFAULT_TYPE
} SYSAUDIO_PREFERRED_DEVICE, *PSYSAUDIO_PREFERRED_DEVICE;

#define SYSAUDIO_FLAGS_CLEAR_PREFERRED          0x00000002

typedef enum {              // preferred device index
    KSPROPERTY_SYSAUDIO_NORMAL_DEFAULT = 0,
    KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT,
    KSPROPERTY_SYSAUDIO_RECORD_DEFAULT,
    KSPROPERTY_SYSAUDIO_MIDI_DEFAULT,
    KSPROPERTY_SYSAUDIO_MIXER_DEFAULT
} KSPROPERTY_SYSAUDIO_DEFAULT_TYPE;

#define STATIC_KSPROPSETID_Sysaudio_Pin \
    0xA3A53220L, 0xC6E4, 0x11D0, 0xB4, 0x65, 0x00, 0x00, 0x1A, 0x18, 0x18, 0xE6
DEFINE_GUIDSTRUCT("A3A53220-C6E4-11D0-B465-00001A1818E6", KSPROPSETID_Sysaudio_Pin);
#define KSPROPSETID_Sysaudio_Pin DEFINE_GUIDNAMED(KSPROPSETID_Sysaudio_Pin)

typedef enum {
    KSPROPERTY_SYSAUDIO_TOPOLOGY_CONNECTION_INDEX,
    KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE,
    KSPROPERTY_SYSAUDIO_PIN_VOLUME_NODE
} KSPROPERTY_SYSAUDIO_PIN;

typedef struct {
    KSPROPERTY  Property;
    ULONG       MixerPinId;
    ULONG       Reserved;
} SYSAUDIO_ATTACH_VIRTUAL_SOURCE, *PSYSAUDIO_ATTACH_VIRTUAL_SOURCE;

typedef struct {
    KSPROPERTY  Property;
    ULONG       NodeId;
    ULONG       Reserved;
} KSNODEPROPERTY, *PKSNODEPROPERTY;

typedef struct {
    KSNODEPROPERTY NodeProperty;
    LONG           Channel;                   // value to get or set
    ULONG          Reserved;
} KSNODEPROPERTY_AUDIO_CHANNEL, *PKSNODEPROPERTY_AUDIO_CHANNEL;

typedef struct {
    KSNODEPROPERTY NodeProperty;
    ULONG   DevSpecificId;
    ULONG   DeviceInfo;
    ULONG   Length;
} KSNODEPROPERTY_AUDIO_DEV_SPECIFIC, *PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC;

typedef struct {
    KSNODEPROPERTY   NodeProperty;
    PVOID            ListenerId;
#ifndef _WIN64
    ULONG            Reserved;
#endif // _WIN64
} KSNODEPROPERTY_AUDIO_3D_LISTENER, *PKSNODEPROPERTY_AUDIO_3D_LISTENER;

typedef struct {
    KSNODEPROPERTY   NodeProperty;
    PVOID            AppContext;
    ULONG            Length;
#ifndef _WIN64
    ULONG            Reserved;
#endif // _WIN64
} KSNODEPROPERTY_AUDIO_PROPERTY, *PKSNODEPROPERTY_AUDIO_PROPERTY;

//===========================================================================

#define STATIC_KSPROPSETID_Linear\
    0x5A2FFE80L, 0x16B9, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("5A2FFE80-16B9-11D0-A5D6-28DB04C10000", KSPROPSETID_Linear);
#define KSPROPSETID_Linear DEFINE_GUIDNAMED(KSPROPSETID_Linear)

typedef enum {
    KSPROPERTY_LINEAR_POSITION,
} KSPROPERTY_LINEAR;

//===========================================================================

//
// Midi definitions
//

/*
    Formats
*/

#define STATIC_KSDATAFORMAT_TYPE_MUSIC\
    0xE725D360L, 0x62CC, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("E725D360-62CC-11CF-A5D6-28DB04C10000", KSDATAFORMAT_TYPE_MUSIC);
#define KSDATAFORMAT_TYPE_MUSIC DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MUSIC)

// 'mids' == MEDIATYPE_Midi
#define STATIC_KSDATAFORMAT_TYPE_MIDI\
    0x7364696DL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("7364696D-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_MIDI);
#define KSDATAFORMAT_TYPE_MIDI DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MIDI)

#define STATIC_KSDATAFORMAT_SUBTYPE_MIDI\
    0x1D262760L, 0xE957, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1D262760-E957-11CF-A5D6-28DB04C10000", KSDATAFORMAT_SUBTYPE_MIDI);
#define KSDATAFORMAT_SUBTYPE_MIDI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MIDI)

#define STATIC_KSDATAFORMAT_SUBTYPE_MIDI_BUS\
    0x2CA15FA0L, 0x6CFE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("2CA15FA0-6CFE-11CF-A5D6-28DB04C10000", KSDATAFORMAT_SUBTYPE_MIDI_BUS);
#define KSDATAFORMAT_SUBTYPE_MIDI_BUS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MIDI_BUS)

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFFMIDI\
    0x4995DAF0L, 0x9EE6, 0x11D0, 0xA4, 0x0E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4995DAF0-9EE6-11D0-A40E-00A0C9223196", KSDATAFORMAT_SUBTYPE_RIFFMIDI);
#define KSDATAFORMAT_SUBTYPE_RIFFMIDI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFFMIDI)

/*
    KSDATAFORMAT_SUBTYPE_DIRECTMUSIC
    see DMusicKS.h
*/

// WARNING! This structure MUST be dword aligned
// regardless of the number of data bytes.

typedef struct {
    ULONG   TimeDeltaMs;        // Delta Milliseconds from the previous midiformat
                                // in the packet. The first midiformat in the packet
                                // is a delta from the PTS in the KSSTREAM_HEADER.
    ULONG   ByteCount;          // Number of bytes of data that follow this struct.
} KSMUSICFORMAT, *PKSMUSICFORMAT;

//
// This entire set of MPEG Standard/Dialect Guids are obsolete. Do not use them.
//
//====================================================================================================
//====================================================================================================
// The following official MPEG Formats, Subtypes and Specifiers are listed as required or optional
// These official MPEG GUIDs are the preferred method of supporting MPEG/AC-3 media types in new code.
// Older MPEG GUIDs should also be supported for compatibilty, but these new modes are still required.
//====================================================================================================
//====================================================================================================

/*
This is a summary of what media types/specifiers will be required for all DVD+DSS+DVB+DTV MPEG decoders.
These media types are what the decoder driver must accept, hardware support for all of these media types
may or may not actually be provided by the decoder natively.  These media types are intended to define
the "officially" supported MPEG/AC-3 media types that all WHQL certified decoders must implement.  This
specifically includes driver and/or hardware support for all the required standards and dialects.

All MPEG video decoders must support all of the MPEG video modes shown as [required] below.
All MPEG audio decoders must support all of the MPEG audio modes shown as [required] below.
All AC-3 audio decoders must support all of the AC-3 audio modes shown as [required] below.
The line items shown as [optional] need not be implemented, but are possible formats that might be implemented.

Note that the input/output pin formats are defined by 2 or 3 GUIDs: TYPE, SUBTYPE, and maybe SPECIFIER.
The specifiers are included if the data format is a "dialect" that needs to be differentiated during decoding.
The decoder MUST be prepared to deal with ALL requests for _required_ "Standard" formats OR _required_ "Dialects".

STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM         [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]
STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET                [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO            [optional]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO            [optional]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]
STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER               [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]

Note that the SPECIFIER GUIDs normally identify particular versions of MPEG such as DSS and DVD.
This approach was taken to minimize the number of DSS/DVB/DVD/DTV etc. media SUBTYPES.
These specifiers are currently required to disambiguate MPEG syntax _parsing_ by the decoder
using alternate parsing routines or downloadable firmware or hardware decode settings.

In the future these specifiers will be extended to cover new KS MPEG flavors such as DVB and DTV.
Thus, the optional specifiers will be subject to clarification and/or definition as they are needed.

Important note: Per the ITU MPEG specs, MPEG 2 media may contain pure MPEG 1 syntax and
any "MPEG 2" PES packets may actually contain MPEG 1 payloads and MPEG 1 syntax.  Some MPEG
broadcasts can revert from MPEG2 to MPEG1 format data at their discretion, without warning.

CAUTION: Decoders MUST attempt to process MPEG data AS SOON AS POSSIBLE after reception.
In particular, elementary MPEG or MPEG PES packet streams should not be aggregated into DVD
"pack headers" internally before submission to the codec hardware if AT ALL POSSIBLE.  The
reason is that mpeg data may need to be processed immediately but there may be no additional
MPEG data forthcoming to fill up the PES packet OR DVD "pack" in a timely fashion.  This is
particularly true of MPEG dialects that utilize "repeat field signally" to reuse the last
decoded MPEG video field.

*/

/////////////////////////////////////////////////////////////////////////
// The major data type GUIDs that define the data packet encapsulation //
/////////////////////////////////////////////////////////////////////////

// STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM
#define STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM \
    0x36523b11L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B11-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM );
#define KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM)

// STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET
#define STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET \
    0x36523b12L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B12-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_PES_PACKET );
#define KSDATAFORMAT_TYPE_STANDARD_PES_PACKET DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_PES_PACKET)

// STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER
#define STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER \
    0x36523b13L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B13-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER );
#define KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER)

///////////////////////////////////////////////////////////////////////////////
// The minor data subtype GUIDs that define the exact class of the data type.//
///////////////////////////////////////////////////////////////////////////////

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO \
    0x36523b21L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B21-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO \
    0x36523b22L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B22-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO \
    0x36523b23L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B23-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO \
    0x36523b24L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B24-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO \
    0x36523b25L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B25-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO)

///////////////////////////////////////////////////////////////////////////////
// The low-level specifier GUIDs that define the flavor of the data subtype. //
// Some SUBTYPES, notably MPEG2_VIDEO, MPEG2_AUDIO have different dialects.  //
// These specifiers are intended to be accompanied by a specifier structure. //
///////////////////////////////////////////////////////////////////////////////

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO \
    0x36523b31L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B31-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO \
    0x36523b32L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B32-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO    Associated with KS_MPEGVIDEOINFO2 defined later
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO \
    0x36523b33L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B33-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO    Associated with KS_MPEGAUDIOINFO defined later
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO \
    0x36523b34L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B34-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO \
    0x36523b35L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B35-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO)

//====================================================================================================
//====================================================================================================
//                              *** COMPATIBILITY WARNING ***
// The *following* older DSS, MPEG, DVD & AC-3 GUID definitions are retained for backward compability.
// These MPEG GUIDs should also be supported for compatibilty, but the above newer modes are still required.
//====================================================================================================
//====================================================================================================

//
// DSS definitions
//

#define STATIC_KSDATAFORMAT_SUBTYPE_DSS_VIDEO\
    0xa0af4f81L, 0xe163, 0x11d0, 0xba, 0xd9, 0x00, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("a0af4f81-e163-11d0-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_DSS_VIDEO);
#define KSDATAFORMAT_SUBTYPE_DSS_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DSS_VIDEO)

#define STATIC_KSDATAFORMAT_SUBTYPE_DSS_AUDIO\
    0xa0af4f82L, 0xe163, 0x11d0, 0xba, 0xd9, 0x00, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("a0af4f82-e163-11d0-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_DSS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_DSS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DSS_AUDIO)

//
// End of obsolete MPEG definitions.
//

//
// mpeg 1 definitions
//
#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Packet\
    0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb80-524f-11ce-9F53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Packet);
#define KSDATAFORMAT_SUBTYPE_MPEG1Packet DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Packet)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Payload\
    0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb81-524f-11ce-9F53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Payload);
#define KSDATAFORMAT_SUBTYPE_MPEG1Payload DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Payload)

// MEDIASUBTYPE_MPEG1Video
#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Video\
    0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb86-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Video);
#define KSDATAFORMAT_SUBTYPE_MPEG1Video DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Video)

//FORMAT_MPEGVideo
#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO\
    0x05589f82L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f82-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO);
#define KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO)

//
// mpeg 2 definitions
//
#define STATIC_KSDATAFORMAT_TYPE_MPEG2_PES\
    0xe06d8020L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8020-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_PES);
#define KSDATAFORMAT_TYPE_MPEG2_PES DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_PES)

#define STATIC_KSDATAFORMAT_TYPE_MPEG2_PROGRAM\
    0xe06d8022L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8022-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_PROGRAM);
#define KSDATAFORMAT_TYPE_MPEG2_PROGRAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_PROGRAM)

#define STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT\
    0xe06d8023L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8023-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_TRANSPORT);
#define KSDATAFORMAT_TYPE_MPEG2_TRANSPORT DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_TRANSPORT)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO\
    0xe06d8026L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8026-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO);
#define KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO)

// use MPEGVIDEOINFO2 (defined below) with KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO
#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO\
    0xe06d80e3L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e3-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO);
#define KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO)


//
// Mpeg2 video properties
//


#define STATIC_KSPROPSETID_Mpeg2Vid\
    0xC8E11B60L, 0x0CC9, 0x11D0, 0xBD, 0x69, 0x00, 0x35, 0x05, 0xC1, 0x03, 0xA9
DEFINE_GUIDSTRUCT("C8E11B60-0CC9-11D0-BD69-003505C103A9", KSPROPSETID_Mpeg2Vid);
#define  KSPROPSETID_Mpeg2Vid DEFINE_GUIDNAMED( KSPROPSETID_Mpeg2Vid )


typedef enum {
    KSPROPERTY_MPEG2VID_MODES,          // available output modes of decoder
    KSPROPERTY_MPEG2VID_CUR_MODE,       // current mode of the decoder
    KSPROPERTY_MPEG2VID_4_3_RECT,       // output coordinates for 4:3 source
    KSPROPERTY_MPEG2VID_16_9_RECT,      // output coordinates for 16:9 source
    KSPROPERTY_MPEG2VID_16_9_PANSCAN,   // pan and scan vectors
} KSPROPERTY_MPEG2VID;

//
// bit field definitions for MPEG2 VIDEO mode
//

#define KSMPEGVIDMODE_PANSCAN   0x0001
#define KSMPEGVIDMODE_LTRBOX    0x0002
#define KSMPEGVIDMODE_SCALE     0x0004

//
// rectangle definitions for the 4/3 and 16/9 cropping properties of
// the MPEG2Video decoder
//

typedef struct _KSMPEGVID_RECT {
    ULONG StartX;
    ULONG StartY;
    ULONG EndX;
    ULONG EndY;
} KSMPEGVID_RECT, *PKSMPEGVID_RECT;

//
// Params for pan / scan
//


//
// MPEG2 Audio definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO\
    0xe06d802bL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802b-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO);
#define KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO\
    0xe06d80e5L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e5-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO);
#define KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO)

//
// DVD LPCM Audio definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_LPCM_AUDIO\
    0xe06d8032L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8032-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_LPCM_AUDIO);
#define KSDATAFORMAT_SUBTYPE_LPCM_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_LPCM_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_LPCM_AUDIO\
    0xe06d80e6L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e6-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_LPCM_AUDIO);
#define KSDATAFORMAT_SPECIFIER_LPCM_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_LPCM_AUDIO)

//
// AC-3 definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_AC3_AUDIO\
    0xe06d802cL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802c-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_AC3_AUDIO);
#define KSDATAFORMAT_SUBTYPE_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_AC3_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_AC3_AUDIO\
    0xe06d80e4L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e4-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_AC3_AUDIO);
#define KSDATAFORMAT_SPECIFIER_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_AC3_AUDIO)

#define STATIC_KSPROPSETID_AC3\
    0xBFABE720L, 0x6E1F, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("BFABE720-6E1F-11D0-BCF2-444553540000", KSPROPSETID_AC3);
#define KSPROPSETID_AC3 DEFINE_GUIDNAMED(KSPROPSETID_AC3)

typedef enum {
    KSPROPERTY_AC3_ERROR_CONCEALMENT = 1,
    KSPROPERTY_AC3_ALTERNATE_AUDIO,
    KSPROPERTY_AC3_DOWNMIX,
    KSPROPERTY_AC3_BIT_STREAM_MODE,
    KSPROPERTY_AC3_DIALOGUE_LEVEL,
    KSPROPERTY_AC3_LANGUAGE_CODE,
    KSPROPERTY_AC3_ROOM_TYPE
} KSPROPERTY_AC3;

typedef struct  {
    BOOL        fRepeatPreviousBlock;
    BOOL        fErrorInCurrentBlock;
} KSAC3_ERROR_CONCEALMENT, *PKSAC3_ERROR_CONCEALMENT;

typedef struct {
    BOOL    fStereo;
    ULONG   DualMode;
} KSAC3_ALTERNATE_AUDIO, *PKSAC3_ALTERNATE_AUDIO;

#define KSAC3_ALTERNATE_AUDIO_1     1
#define KSAC3_ALTERNATE_AUDIO_2     2
#define KSAC3_ALTERNATE_AUDIO_BOTH  3

typedef struct {
    BOOL        fDownMix;
    BOOL        fDolbySurround;
} KSAC3_DOWNMIX, *PKSAC3_DOWNMIX;

typedef struct {
    LONG        BitStreamMode;
} KSAC3_BIT_STREAM_MODE, *PKSAC3_BIT_STREAM_MODE;

#define KSAC3_SERVICE_MAIN_AUDIO            0
#define KSAC3_SERVICE_NO_DIALOG             1
#define KSAC3_SERVICE_VISUALLY_IMPAIRED     2
#define KSAC3_SERVICE_HEARING_IMPAIRED      3
#define KSAC3_SERVICE_DIALOG_ONLY           4
#define KSAC3_SERVICE_COMMENTARY            5
#define KSAC3_SERVICE_EMERGENCY_FLASH       6
#define KSAC3_SERVICE_VOICE_OVER            7

typedef struct {
    ULONG   DialogueLevel;
} KSAC3_DIALOGUE_LEVEL, *PKSAC3_DIALOGUE_LEVEL;

typedef struct {
    BOOL    fLargeRoom;
} KSAC3_ROOM_TYPE, *PKSAC3_ROOM_TYPE;


//
// DTS and SDDS definitions (media subtype GUIDs)
//
#define STATIC_KSDATAFORMAT_SUBTYPE_DTS_AUDIO\
    0xe06d8033L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8033-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_DTS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_DTS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DTS_AUDIO)

#define STATIC_KSDATAFORMAT_SUBTYPE_SDDS_AUDIO\
    0xe06d8034L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8034-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_SDDS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_SDDS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_SDDS_AUDIO)


//
// audio decoder output properties
//

#define STATIC_KSPROPSETID_AudioDecoderOut\
    0x6ca6e020L, 0x43bd, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9
DEFINE_GUIDSTRUCT("6ca6e020-43bd-11d0-bd6a-003505c103a9", KSPROPSETID_AudioDecoderOut);
#define KSPROPSETID_AudioDecoderOut DEFINE_GUIDNAMED(KSPROPSETID_AudioDecoderOut)

typedef enum {
    KSPROPERTY_AUDDECOUT_MODES,         // available output modes of decoder
    KSPROPERTY_AUDDECOUT_CUR_MODE,      // current mode of the decoder
} KSPROPERTY_AUDDECOUT;

#define KSAUDDECOUTMODE_STEREO_ANALOG   0x0001
#define KSAUDDECOUTMODE_PCM_51          0x0002
#define KSAUDDECOUTMODE_SPDIFF          0x0004



//
// subpicture definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_SUBPICTURE\
    0xe06d802dL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802d-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_SUBPICTURE);
#define KSDATAFORMAT_SUBTYPE_SUBPICTURE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_SUBPICTURE)


#define STATIC_KSPROPSETID_DvdSubPic\
    0xac390460L, 0x43af, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9
DEFINE_GUIDSTRUCT("ac390460-43af-11d0-bd6a-003505c103a9", KSPROPSETID_DvdSubPic);
#define KSPROPSETID_DvdSubPic DEFINE_GUIDNAMED(KSPROPSETID_DvdSubPic)

typedef enum {
    KSPROPERTY_DVDSUBPIC_PALETTE,
    KSPROPERTY_DVDSUBPIC_HLI,
    KSPROPERTY_DVDSUBPIC_COMPOSIT_ON,  // TRUE for subpicture is displayed
} KSPROPERTY_DVDSUBPIC;

typedef struct _KS_DVD_YCrCb {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   Cr;
    UCHAR   Cb;
} KS_DVD_YCrCb, *PKS_DVD_YCrCb;

/* The KS_DVD_YUV structure is now superseded by KS_DVD_YCrCb above and is
   here for backward compatibility only */

typedef struct _KS_DVD_YUV {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   V;
    UCHAR   U;
} KS_DVD_YUV, *PKS_DVD_YUV;

typedef struct _KSPROPERTY_SPPAL {
    KS_DVD_YUV sppal[16];
} KSPROPERTY_SPPAL, *PKSPROPERTY_SPPAL;

typedef struct _KS_COLCON {
    UCHAR emph1col:4;
    UCHAR emph2col:4;
    UCHAR backcol:4;
    UCHAR patcol:4;
    UCHAR emph1con:4;
    UCHAR emph2con:4;
    UCHAR backcon:4;
    UCHAR patcon:4;

} KS_COLCON, *PKS_COLCON;

typedef struct _KSPROPERTY_SPHLI {
    USHORT      HLISS;
    USHORT      Reserved;
    ULONG       StartPTM;   // start presentation time in x/90000
    ULONG       EndPTM;     // end PTM in x/90000
    USHORT      StartX;
    USHORT      StartY;
    USHORT      StopX;
    USHORT      StopY;
    KS_COLCON   ColCon;     // color contrast description (4 bytes as given in HLI)
} KSPROPERTY_SPHLI, *PKSPROPERTY_SPHLI;

typedef BOOL KSPROPERTY_COMPOSIT_ON, *PKSPROPERTY_COMPOSIT_ON;

#define STATIC_KSPROPSETID_CopyProt \
    0x0E8A0A40L, 0x6AEF, 0x11D0, 0x9E, 0xD0, 0x00, 0xA0, 0x24, 0xCA, 0x19, 0xB3
DEFINE_GUIDSTRUCT("0E8A0A40-6AEF-11D0-9ED0-00A024CA19B3", KSPROPSETID_CopyProt);
#define KSPROPSETID_CopyProt DEFINE_GUIDNAMED(KSPROPSETID_CopyProt)

typedef enum {

    KSPROPERTY_DVDCOPY_CHLG_KEY = 0x01,
    KSPROPERTY_DVDCOPY_DVD_KEY1,
    KSPROPERTY_DVDCOPY_DEC_KEY2,
    KSPROPERTY_DVDCOPY_TITLE_KEY,
    KSPROPERTY_COPY_MACROVISION,
    KSPROPERTY_DVDCOPY_REGION,
    KSPROPERTY_DVDCOPY_SET_COPY_STATE,
    KSPROPERTY_DVDCOPY_DISC_KEY = 0x80

} KSPROPERTY_COPYPROT;

typedef struct _KS_DVDCOPY_CHLGKEY {
    BYTE ChlgKey[10];
    BYTE Reserved[2];
} KS_DVDCOPY_CHLGKEY, *PKS_DVDCOPY_CHLGKEY;

typedef struct _KS_DVDCOPY_BUSKEY {
    BYTE BusKey[5];
    BYTE Reserved[1];
} KS_DVDCOPY_BUSKEY, *PKS_DVDCOPY_BUSKEY;


typedef struct _KS_DVDCOPY_DISCKEY {
    BYTE DiscKey[2048];
} KS_DVDCOPY_DISCKEY, *PKS_DVDCOPY_DISCKEY;

typedef struct _KS_DVDCOPY_REGION {
    UCHAR   Reserved;
    UCHAR   RegionData;
    UCHAR   Reserved2[2];
} KS_DVDCOPY_REGION, *PKS_DVDCOPY_REGION;

typedef struct _KS_DVDCOPY_TITLEKEY {
    ULONG KeyFlags;
    ULONG ReservedNT[2];
    UCHAR TitleKey[6];
    UCHAR Reserved[2];
} KS_DVDCOPY_TITLEKEY, *PKS_DVDCOPY_TITLEKEY;

typedef struct _KS_COPY_MACROVISION {
    ULONG MACROVISIONLevel;
} KS_COPY_MACROVISION, *PKS_COPY_MACROVISION;

typedef struct _KS_DVDCOPY_SET_COPY_STATE {
    ULONG DVDCopyState;
} KS_DVDCOPY_SET_COPY_STATE, *PKS_DVDCOPY_SET_COPY_STATE;

typedef enum {
    KS_DVDCOPYSTATE_INITIALIZE,         // indicates we are starting a full
                                        // copy protection sequence.
    KS_DVDCOPYSTATE_INITIALIZE_TITLE,   // indicates we are starting a title
                                        // key copy protection sequence
    KS_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED,
    KS_DVDCOPYSTATE_AUTHENTICATION_REQUIRED,
    KS_DVDCOPYSTATE_DONE,
} KS_DVDCOPYSTATE;

typedef enum {
    KS_MACROVISION_DISABLED,
    KS_MACROVISION_LEVEL1,
    KS_MACROVISION_LEVEL2,
    KS_MACROVISION_LEVEL3
} KS_COPY_MACROVISION_LEVEL, *PKS_COPY_MACROVISION_LEVEL;

//
// CGMS Copy Protection Flags
//

#define KS_DVD_CGMS_RESERVED_MASK      0x00000078

#define KS_DVD_CGMS_COPY_PROTECT_MASK  0x00000018
#define KS_DVD_CGMS_COPY_PERMITTED     0x00000000
#define KS_DVD_CGMS_COPY_ONCE          0x00000010
#define KS_DVD_CGMS_NO_COPY            0x00000018

#define KS_DVD_COPYRIGHT_MASK          0x00000040
#define KS_DVD_NOT_COPYRIGHTED         0x00000000
#define KS_DVD_COPYRIGHTED             0x00000040

#define KS_DVD_SECTOR_PROTECT_MASK     0x00000020
#define KS_DVD_SECTOR_NOT_PROTECTED    0x00000000
#define KS_DVD_SECTOR_PROTECTED        0x00000020


//===========================================================================
// The following MUST match the structures in WinGDI.h and AMVideo.h
//===========================================================================

#define STATIC_KSCATEGORY_TVTUNER \
    0xa799a800L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a800-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_TVTUNER);
#define KSCATEGORY_TVTUNER DEFINE_GUIDNAMED(KSCATEGORY_TVTUNER)

#define STATIC_KSCATEGORY_CROSSBAR \
    0xa799a801L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a801-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_CROSSBAR);
#define KSCATEGORY_CROSSBAR DEFINE_GUIDNAMED(KSCATEGORY_CROSSBAR)

#define STATIC_KSCATEGORY_TVAUDIO \
    0xa799a802L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a802-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_TVAUDIO);
#define KSCATEGORY_TVAUDIO DEFINE_GUIDNAMED(KSCATEGORY_TVAUDIO)

#define STATIC_KSCATEGORY_VPMUX \
    0xa799a803L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a803-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_VPMUX);
#define KSCATEGORY_VPMUX DEFINE_GUIDNAMED(KSCATEGORY_VPMUX)

#define STATIC_KSCATEGORY_VBICODEC \
    0x07dad660L, 0x22f1, 0x11d1, 0xa9, 0xf4, 0x00, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("07dad660-22f1-11d1-a9f4-00c04fbbde8f", KSCATEGORY_VBICODEC);
#define KSCATEGORY_VBICODEC DEFINE_GUIDNAMED(KSCATEGORY_VBICODEC)

// SUBTYPE_VPVideo
#define STATIC_KSDATAFORMAT_SUBTYPE_VPVideo\
    0x5a9b6a40L, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("5a9b6a40-1a22-11d1-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_VPVideo);
#define KSDATAFORMAT_SUBTYPE_VPVideo DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_VPVideo)

// SUBTYPE_VPVBI
#define STATIC_KSDATAFORMAT_SUBTYPE_VPVBI\
    0x5a9b6a41L, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("5a9b6a41-1a22-11d1-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_VPVBI);
#define KSDATAFORMAT_SUBTYPE_VPVBI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_VPVBI)


// FORMAT_VideoInfo
#define STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO\
    0x05589f80L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f80-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_VIDEOINFO);
#define KSDATAFORMAT_SPECIFIER_VIDEOINFO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VIDEOINFO)

// FORMAT_VideoInfo2
#define STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO2\
    0xf72a76A0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76A0-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SPECIFIER_VIDEOINFO2);
#define KSDATAFORMAT_SPECIFIER_VIDEOINFO2 DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VIDEOINFO2)

// MEDIATYPE_AnalogVideo
#define STATIC_KSDATAFORMAT_TYPE_ANALOGVIDEO\
    0x0482dde1L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482dde1-7817-11cf-8a03-00aa006ecb65", KSDATAFORMAT_TYPE_ANALOGVIDEO);
#define KSDATAFORMAT_TYPE_ANALOGVIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_ANALOGVIDEO)

// FORMAT_AnalogVideo
#define STATIC_KSDATAFORMAT_SPECIFIER_ANALOGVIDEO\
    0x0482dde0L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482dde0-7817-11cf-8a03-00aa006ecb65", KSDATAFORMAT_SPECIFIER_ANALOGVIDEO);
#define KSDATAFORMAT_SPECIFIER_ANALOGVIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)

// FORMAT_VBI
#define STATIC_KSDATAFORMAT_SPECIFIER_VBI\
    0xf72a76e0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e0-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SPECIFIER_VBI);
#define KSDATAFORMAT_SPECIFIER_VBI DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VBI)

// MEDIATYPE_VBI
#define STATIC_KSDATAFORMAT_TYPE_VBI\
    0xf72a76e1L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e1-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_TYPE_VBI);
#define KSDATAFORMAT_TYPE_VBI DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_VBI)

// SUBTYPE_RAW8
#define STATIC_KSDATAFORMAT_SUBTYPE_RAW8\
    0xca20d9a0, 0x3e3e, 0x11d1, 0x9b, 0xf9, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0xbf
DEFINE_GUIDSTRUCT("ca20d9a0-3e3e-11d1-9bf9-00c04fbbdebf", KSDATAFORMAT_SUBTYPE_RAW8);
#define KSDATAFORMAT_SUBTYPE_RAW8 DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RAW8)

// MEDIASUBTYPE_CC
#define STATIC_KSDATAFORMAT_SUBTYPE_CC\
    0x33214cc1, 0x11f, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
DEFINE_GUIDSTRUCT("33214CC1-011F-11D2-B4B1-00A0D102CFBE", KSDATAFORMAT_SUBTYPE_CC);
#define KSDATAFORMAT_SUBTYPE_CC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_CC)

// MEDIASUBTYPE_NABTS
#define STATIC_KSDATAFORMAT_SUBTYPE_NABTS\
    0xf72a76e2L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e2-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SUBTYPE_NABTS);
#define KSDATAFORMAT_SUBTYPE_NABTS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NABTS)

// MEDIASUBTYPE_TELETEXT
#define STATIC_KSDATAFORMAT_SUBTYPE_TELETEXT\
    0xf72a76e3L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e3-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SUBTYPE_TELETEXT);
#define KSDATAFORMAT_SUBTYPE_TELETEXT DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_TELETEXT)



/* constants for the biCompression field */
#define KS_BI_RGB        0L
#define KS_BI_RLE8       1L
#define KS_BI_RLE4       2L
#define KS_BI_BITFIELDS  3L

typedef struct tagKS_RGBQUAD { // rgbq
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} KS_RGBQUAD, *PKS_RGBQUAD;

/* constants for palettes */
#define KS_iPALETTE_COLORS 256     // Maximum colours in palette
#define KS_iEGA_COLORS 16          // Number colours in EGA palette
#define KS_iMASK_COLORS 3          // Maximum three components
#define KS_iTRUECOLOR 16           // Minimum true colour device
#define KS_iRED 0                  // Index position for RED mask
#define KS_iGREEN 1                // Index position for GREEN mask
#define KS_iBLUE 2                 // Index position for BLUE mask
#define KS_iPALETTE 8              // Maximum colour depth using a palette
#define KS_iMAXBITS 8              // Maximum bits per colour component
#define KS_SIZE_EGA_PALETTE (KS_iEGA_COLORS * sizeof(KS_RGBQUAD))
#define KS_SIZE_PALETTE (KS_iPALETTE_COLORS * sizeof(KS_RGBQUAD))

typedef struct tagKS_BITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} KS_BITMAPINFOHEADER, *PKS_BITMAPINFOHEADER;

// Used for true colour images that also have a palette

typedef struct tag_KS_TRUECOLORINFO {
    DWORD   dwBitMasks[KS_iMASK_COLORS];
    KS_RGBQUAD bmiColors[KS_iPALETTE_COLORS];
} KS_TRUECOLORINFO, *PKS_TRUECOLORINFO;


#define KS_WIDTHBYTES(bits) ((DWORD)(((bits)+31) & (~31)) / 8)
#define KS_DIBWIDTHBYTES(bi) (DWORD)KS_WIDTHBYTES((DWORD)(bi).biWidth * (DWORD)(bi).biBitCount)
#define KS__DIBSIZE(bi) (KS_DIBWIDTHBYTES(bi) * (DWORD)(bi).biHeight)
#define KS_DIBSIZE(bi) ((bi).biHeight < 0 ? (-1)*(KS__DIBSIZE(bi)) : KS__DIBSIZE(bi))

typedef LONGLONG REFERENCE_TIME;

// The BITMAPINFOHEADER contains all the details about the video stream such
// as the actual image dimensions and their pixel depth. A source filter may
// also request that the sink take only a section of the video by providing a
// clipping rectangle in rcSource. In the worst case where the sink filter
// forgets to check this on connection it will simply render the whole thing
// which isn't a disaster. Ideally a sink filter will check the rcSource and
// if it doesn't support image extraction and the rectangle is not empty then
// it will reject the connection. A filter should use SetRectEmpty to reset a
// rectangle to all zeroes (and IsRectEmpty to later check the rectangle).
// The rcTarget specifies the destination rectangle for the video, for most
// source filters they will set this to all zeroes, a downstream filter may
// request that the video be placed in a particular area of the buffers it
// supplies in which case it will call QueryAccept with a non empty target

typedef struct tagKS_VIDEOINFOHEADER {

    RECT                rcSource;          // The bit we really want to use
    RECT                rcTarget;          // Where the video should go
    DWORD               dwBitRate;         // Approximate bit data rate
    DWORD               dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME      AvgTimePerFrame;   // Average time per frame (100ns units)

    KS_BITMAPINFOHEADER bmiHeader;

} KS_VIDEOINFOHEADER, *PKS_VIDEOINFOHEADER;

// !!! WARNING !!!
// DO NOT use the following structure unless you are sure that the BITMAPINFOHEADER
// has a normal biSize == sizeof(BITMAPINFOHEADER) !
// !!! WARNING !!!

typedef struct tagKS_VIDEOINFO {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    KS_BITMAPINFOHEADER bmiHeader;

    union {
        KS_RGBQUAD          bmiColors[KS_iPALETTE_COLORS];     // Colour palette
        DWORD               dwBitMasks[KS_iMASK_COLORS];       // True colour masks
        KS_TRUECOLORINFO    TrueColorInfo;                     // Both of the above
    };

} KS_VIDEOINFO, *PKS_VIDEOINFO;


#define KS_SIZE_MASKS (KS_iMASK_COLORS * sizeof(DWORD))
#define KS_SIZE_PREHEADER (FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader))

// For normal size
// #define KS_SIZE_VIDEOHEADER (sizeof(KS_BITMAPINFOHEADER) + KS_SIZE_PREHEADER)
// !!! for abnormal biSizes
#define KS_SIZE_VIDEOHEADER(pbmi) ((pbmi)->bmiHeader.biSize + KS_SIZE_PREHEADER)

// VBI
// Used for NABTS, CC, Intercast,
typedef struct tagKS_VBIINFOHEADER {
    ULONG       StartLine;              // inclusive
    ULONG       EndLine;                // inclusive
    ULONG       SamplingFrequency;      // Hz.
    ULONG       MinLineStartTime;       // microSec * 100 from HSync LE
    ULONG       MaxLineStartTime;       // microSec * 100 from HSync LE
    ULONG       ActualLineStartTime;    // microSec * 100 from HSync LE
    ULONG       ActualLineEndTime;      // microSec * 100 from HSync LE
    ULONG       VideoStandard;          // KS_AnalogVideoStandard*
    ULONG       SamplesPerLine;
    ULONG       StrideInBytes;          // May be > SamplesPerLine
    ULONG       BufferSize;             // Bytes
} KS_VBIINFOHEADER, *PKS_VBIINFOHEADER;

// VBI Sampling Rates
#define KS_VBIDATARATE_NABTS            (5727272L)
#define KS_VBIDATARATE_CC               ( 503493L)    // ~= 1/1.986125e-6
#define KS_VBISAMPLINGRATE_4X_NABTS     ((long)(4*KS_VBIDATARATE_NABTS))
#define KS_VBISAMPLINGRATE_47X_NABTS    ((long)(27000000))
#define KS_VBISAMPLINGRATE_5X_NABTS     ((long)(5*KS_VBIDATARATE_NABTS))

#define KS_47NABTS_SCALER (KS_VBISAMPLINGRATE_47X_NABTS/(double)KS_VBIDATARATE_NABTS)

// Analog video variant - Use this when the format is FORMAT_AnalogVideo
//
// rcSource defines the portion of the active video signal to use
// rcTarget defines the destination rectangle
//    both of the above are relative to the dwActiveWidth and dwActiveHeight fields
// dwActiveWidth is currently set to 720 for all formats (but could change for HDTV)
// dwActiveHeight is 483 for NTSC and 575 for PAL/SECAM  (but could change for HDTV)

typedef struct tagKS_AnalogVideoInfo {
    RECT            rcSource;           // Width max is 720, height varies w/ TransmissionStd
    RECT            rcTarget;           // Where the video should go
    DWORD           dwActiveWidth;      // Always 720 (CCIR-601 active samples per line)
    DWORD           dwActiveHeight;     // 483 for NTSC, 575 for PAL/SECAM
    REFERENCE_TIME  AvgTimePerFrame;    // Normal ActiveMovie units (100 nS)
} KS_ANALOGVIDEOINFO, *PKS_ANALOGVIDEOINFO;

//===========================================================================
// Data packet passed on Analog video stream channel change
//===========================================================================

#define KS_TVTUNER_CHANGE_BEGIN_TUNE    0x0001L  // Starting a tuning operation
#define KS_TVTUNER_CHANGE_END_TUNE      0x0002L  // Ending a tuning operation

typedef struct tagKS_TVTUNER_CHANGE_INFO {
   DWORD                    dwFlags;                // KS_TVTUNER_CHANGE_*
   DWORD                    dwCountryCode;
   DWORD                    dwAnalogVideoStandard;  // KS_AnalogVideoStandard
   DWORD                    dwChannel;
} KS_TVTUNER_CHANGE_INFO, *PKS_TVTUNER_CHANGE_INFO;

//===========================================================================
// Video format blocks
//===========================================================================

typedef enum {
    KS_MPEG2Level_Low,
    KS_MPEG2Level_Main,
    KS_MPEG2Level_High1440,
    KS_MPEG2Level_High
} KS_MPEG2Level;

typedef enum {
    KS_MPEG2Profile_Simple,
    KS_MPEG2Profile_Main,
    KS_MPEG2Profile_SNRScalable,
    KS_MPEG2Profile_SpatiallyScalable,
    KS_MPEG2Profile_High
} KS_MPEG2Profile;

#define KS_INTERLACE_IsInterlaced            0x00000001  // if 0, other interlace bits are irrelevent
#define KS_INTERLACE_1FieldPerSample         0x00000002  // else 2 fields per media sample
#define KS_INTERLACE_Field1First             0x00000004  // else Field 2 is first;  top field in PAL is field 1, top field in NTSC is field 2?
#define KS_INTERLACE_UNUSED                  0x00000008  //
#define KS_INTERLACE_FieldPatternMask        0x00000030  // use this mask with AMINTERLACE_FieldPat*
#define KS_INTERLACE_FieldPatField1Only      0x00000000  // Data never contains a Field2
#define KS_INTERLACE_FieldPatField2Only      0x00000010  // Data never contains a Field1
#define KS_INTERLACE_FieldPatBothRegular     0x00000020  // There will be a Field2 for every Field1 (required for Weave?)
#define KS_INTERLACE_FieldPatBothIrregular   0x00000030  // Random pattern of Field1s and Field2s
#define KS_INTERLACE_DisplayModeMask         0x000000c0
#define KS_INTERLACE_DisplayModeBobOnly      0x00000000
#define KS_INTERLACE_DisplayModeWeaveOnly    0x00000040
#define KS_INTERLACE_DisplayModeBobOrWeave   0x00000080



#define KS_MPEG2_DoPanScan           0x00000001  //if set, the MPEG-2 video decoder should crop output image
                                                //  based on pan-scan vectors in picture_display_extension
                                                //  and change the picture aspect ratio accordingly.
#define KS_MPEG2_DVDLine21Field1     0x00000002  //if set, the MPEG-2 decoder must be able to produce an output
                                                //  pin for DVD style closed caption data found in GOP layer of field 1
#define KS_MPEG2_DVDLine21Field2     0x00000004  //if set, the MPEG-2 decoder must be able to produce an output
                                                //  pin for DVD style closed caption data found in GOP layer of field 2
#define KS_MPEG2_SourceIsLetterboxed 0x00000008  //if set, indicates that black bars have been encoded in the top
                                                //  and bottom of the video.
#define KS_MPEG2_FilmCameraMode      0x00000010  //if set, indicates "film mode" used for 625/50 content.  If cleared,
                                                //  indicates that "camera mode" was used.
#define KS_MPEG2_LetterboxAnalogOut  0x00000020  //if set and this stream is sent to an analog output, it should
                        //  be letterboxed.  Streams sent to VGA should be letterboxed only by renderers.
#define KS_MPEG2_DSS_UserData        0x00000040  //if set, the MPEG-2 decoder must process DSS style user data
#define KS_MPEG2_DVB_UserData        0x00000080  //if set, the MPEG-2 decoder must process DVB style user data
#define KS_MPEG2_27MhzTimebase       0x00000100  //if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz

typedef struct tagKS_VIDEOINFOHEADER2 {
    RECT                rcSource;
    RECT                rcTarget;
    DWORD               dwBitRate;
    DWORD               dwBitErrorRate;
    REFERENCE_TIME      AvgTimePerFrame;
    DWORD               dwInterlaceFlags;   // use AMINTERLACE_* defines. Reject connection if undefined bits are not 0
    DWORD               dwCopyProtectFlags; // use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0
    DWORD               dwPictAspectRatioX; // X dimension of picture aspect ratio, e.g. 16 for 16x9 display
    DWORD               dwPictAspectRatioY; // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
    DWORD               dwReserved1;        // must be 0; reject connection otherwise
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    KS_BITMAPINFOHEADER bmiHeader;
} KS_VIDEOINFOHEADER2, *PKS_VIDEOINFOHEADER2;

typedef struct tagKS_MPEG1VIDEOINFO {
    KS_VIDEOINFOHEADER hdr; // Compatible with VIDEOINFO
    DWORD dwStartTimeCode; // 25-bit Group of pictures time code at start of data
    DWORD cbSequenceHeader; // Length in bytes of bSequenceHeader
    BYTE bSequenceHeader[1]; // Sequence header including quantization matrices if any
} KS_MPEG1VIDEOINFO, *PKS_MPEG1VIDEOINFO;

#define KS_MAX_SIZE_MPEG1_SEQUENCE_INFO 140
#define KS_SIZE_MPEG1VIDEOINFO(pv) (FIELD_OFFSET(KS_MPEG1VIDEOINFO, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define KS_MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

typedef struct tagKS_MPEGVIDEOINFO2 {
    KS_VIDEOINFOHEADER2 hdr;
    DWORD               dwStartTimeCode;        //  ?? not used for DVD ??
    DWORD               cbSequenceHeader;       // is 0 for DVD (no sequence header)
    DWORD               dwProfile;              // use enum MPEG2Profile
    DWORD               dwLevel;                // use enum MPEG2Level
    DWORD               dwFlags;                // use AMMPEG2_* defines.  Reject connection if undefined bits are not 0
    DWORD               bSequenceHeader[1];     // DWORD instead of Byte for alignment purposes
                                                //   For MPEG-2, if a sequence_header is included, the sequence_extension
                                                //   should also be included
} KS_MPEGVIDEOINFO2, *PKS_MPEGVIDEOINFO2;


#define KS_SIZE_MPEGVIDEOINFO2(pv) (FIELD_OFFSET(KS_MPEGVIDEOINFO2, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define KS_MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

//===========================================================================
// Audio format blocks
//===========================================================================

//if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz
#define KS_MPEGAUDIOINFO_27MhzTimebase      0x00000001

typedef struct tagKS_MPEAUDIOINFO {
    DWORD               dwFlags;            // use KS_MPEGAUDIOINFO_* defines.  Reject connection if undefined bits are not 0
    DWORD               dwReserved1;        // must be 0; reject connection otherwise
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    DWORD               dwReserved3;        // must be 0; reject connection otherwise
} KS_MPEGAUDIOINFO, *PKS_MPEGAUDIOINFO;

//===========================================================================
// Video DATAFORMATs
//===========================================================================

typedef struct tagKS_DATAFORMAT_VIDEOINFOHEADER {
    KSDATAFORMAT            DataFormat;
    KS_VIDEOINFOHEADER      VideoInfoHeader;
} KS_DATAFORMAT_VIDEOINFOHEADER, *PKS_DATAFORMAT_VIDEOINFOHEADER;

typedef struct tagKS_DATAFORMAT_VIDEOINFOHEADER2 {
    KSDATAFORMAT            DataFormat;
    KS_VIDEOINFOHEADER2     VideoInfoHeader2;
} KS_DATAFORMAT_VIDEOINFOHEADER2, *PKS_DATAFORMAT_VIDEOINFOHEADER2;

typedef struct tagKS_DATAFORMAT_VIDEOINFO_PALETTE {
    KSDATAFORMAT            DataFormat;
    KS_VIDEOINFO            VideoInfo;
} KS_DATAFORMAT_VIDEOINFO_PALETTE, *PKS_DATAFORMAT_VIDEOINFO_PALETTE;

typedef struct tagKS_DATAFORMAT_VBIINFOHEADER {
    KSDATAFORMAT            DataFormat;
    KS_VBIINFOHEADER        VBIInfoHeader;
} KS_DATAFORMAT_VBIINFOHEADER, *PKS_DATAFORMAT_VBIINFOHEADER;

typedef struct  _KS_VIDEO_STREAM_CONFIG_CAPS  {
    GUID guid;                  // will be MEDIATYPE_Video
    ULONG VideoStandard;        // logical OR of all AnalogVideoStandards
                                // supported
    SIZE InputSize;             // the inherent size of the incoming signal
                                // (every pixel unique)
    SIZE MinCroppingSize;       // smallest rcSrc cropping rect allowed
    SIZE MaxCroppingSize;       // largest rcSrc cropping rect allowed
    int CropGranularityX;       // granularity of cropping size
    int CropGranularityY;
    int CropAlignX;             // alignment of cropping rect
    int CropAlignY;
    SIZE MinOutputSize;         // smallest bitmap stream can produce
    SIZE MaxOutputSize;         // largest  bitmap stream can produce
    int OutputGranularityX;     // granularity of output bitmap size
    int OutputGranularityY;
    int StretchTapsX;           // 0, no stretch, 1 pix dup, 2 interp, ...
    int StretchTapsY;           //    Describes quality of hardware scaler
    int ShrinkTapsX;            //
    int ShrinkTapsY;            //
    LONGLONG MinFrameInterval;  // 100 nS units
    LONGLONG MaxFrameInterval;
    LONG MinBitsPerSecond;
    LONG MaxBitsPerSecond;
} KS_VIDEO_STREAM_CONFIG_CAPS, *PKS_VIDEO_STREAM_CONFIG_CAPS;

//===========================================================================
// Video DATARANGEs
//===========================================================================

typedef struct tagKS_DATARANGE_VIDEO {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VIDEOINFOHEADER           VideoInfoHeader;        // default format
} KS_DATARANGE_VIDEO, *PKS_DATARANGE_VIDEO;

typedef struct tagKS_DATARANGE_VIDEO2 {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VIDEOINFOHEADER2          VideoInfoHeader;        // default format
} KS_DATARANGE_VIDEO2, *PKS_DATARANGE_VIDEO2;

typedef struct tagKS_DATARANGE_MPEG1_VIDEO {
    KSDATARANGE DataRange;
    BOOL bFixedSizeSamples; // all samples same size?
    BOOL bTemporalCompression; // all I frames?
    DWORD StreamDescriptionFlags; // KS_VIDEO_DESC_*
    DWORD MemoryAllocationFlags; // KS_VIDEO_ALLOC_*
    KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
    KS_MPEG1VIDEOINFO VideoInfoHeader; // default format
} KS_DATARANGE_MPEG1_VIDEO, *PKS_DATARANGE_MPEG1_VIDEO;

typedef struct tagKS_DATARANGE_MPEG2_VIDEO {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_MPEGVIDEOINFO2            VideoInfoHeader;        // default format
} KS_DATARANGE_MPEG2_VIDEO, *PKS_DATARANGE_MPEG2_VIDEO;

typedef struct tagKS_DATARANGE_VIDEO_PALETTE {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VIDEOINFO                 VideoInfo;              // default format
} KS_DATARANGE_VIDEO_PALETTE, *PKS_DATARANGE_VIDEO_PALETTE;

typedef struct tagKS_DATARANGE_VIDEO_VBI {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VBIINFOHEADER             VBIInfoHeader;          // default format
} KS_DATARANGE_VIDEO_VBI, *PKS_DATARANGE_VIDEO_VBI;

typedef struct tagKS_DATARANGE_ANALOGVIDEO {
   KSDATARANGE                  DataRange;
   KS_ANALOGVIDEOINFO           AnalogVideoInfo;
} KS_DATARANGE_ANALOGVIDEO, *PKS_DATARANGE_ANALOGVIDEO;

//===========================================================================
// StreamDescriptionFlags
//
// These define the "purpose" of each video stream
//===========================================================================

#define KS_VIDEOSTREAM_PREVIEW          0x0001  // Preview stream
#define KS_VIDEOSTREAM_CAPTURE          0x0002  // Capture stream
#define KS_VIDEOSTREAM_VBI              0x0010  // Field1 VBI
#define KS_VIDEOSTREAM_NABTS            0x0020  // Field1 NABTS
#define KS_VIDEOSTREAM_CC               0x0100  // Closed Captioning
#define KS_VIDEOSTREAM_EDS              0x0200  // Extended Data Services
#define KS_VIDEOSTREAM_TELETEXT         0x0400  // Field1 Teletext only
#define KS_VIDEOSTREAM_STILL            0x1000  // Still image input
#define KS_VIDEOSTREAM_IS_VPE           0x8000  // Is a VPE based stream?

// MemoryAllocationFlags
#define KS_VIDEO_ALLOC_VPE_SYSTEM       0x0001  // VPE surface in system memory
#define KS_VIDEO_ALLOC_VPE_DISPLAY      0x0002  // VPE surface in display memory
#define KS_VIDEO_ALLOC_VPE_AGP          0x0004  // VPE surface in AGP memory

//////////////////////////////////////////////////////////////
// Capture driver VBI property sets
//////////////////////////////////////////////////////////////

// {F162C607-7B35-496f-AD7F-2DCA3B46B718}
#define STATIC_KSPROPSETID_VBICAP_PROPERTIES\
    0xf162c607, 0x7b35, 0x496f, 0xad, 0x7f, 0x2d, 0xca, 0x3b, 0x46, 0xb7, 0x18
DEFINE_GUIDSTRUCT("F162C607-7B35-496f-AD7F-2DCA3B46B718", KSPROPSETID_VBICAP_PROPERTIES);
#define KSPROPSETID_VBICAP_PROPERTIES DEFINE_GUIDNAMED(KSPROPSETID_VBICAP_PROPERTIES)

typedef enum {
    KSPROPERTY_VBICAP_PROPERTIES_PROTECTION = 0x01,
} KSPROPERTY_VBICAP;

typedef struct _VBICAP_PROPERTIES_PROTECTION_S {
    KSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      Status;
} VBICAP_PROPERTIES_PROTECTION_S, *PVBICAP_PROPERTIES_PROTECTION_S;
#define KS_VBICAP_PROTECTION_MV_PRESENT     0x0001L
#define KS_VBICAP_PROTECTION_MV_HARDWARE    0x0002L
#define KS_VBICAP_PROTECTION_MV_DETECTED    0x0004L


/***************************************************************************/
/* VBI Related GUIDs, structs and properties for codecs(generic, cc, nabts)*/
/***************************************************************************/

///////////////////////////////////////////////////////////////////////////////////////
// IP/NABTS Protocol Reserved Group IDs - Overall Range 0x800-0x8FF [Decimal 2048-2079]
// Intervening values(0-F) are used if there are multiple providers at a particular tier
///////////////////////////////////////////////////////////////////////////////////////

// Used by individual content creators in show footage/data
#define KS_NABTS_GROUPID_ORIGINAL_CONTENT_BASE                 0x800
#define KS_NABTS_GROUPID_ORIGINAL_CONTENT_ADVERTISER_BASE      0x810

// Used by production company in finished show data
#define KS_NABTS_GROUPID_PRODUCTION_COMPANY_CONTENT_BASE       0x820
#define KS_NABTS_GROUPID_PRODUCTION_COMPANY_ADVERTISER_BASE    0x830

// Used by broadcast syndicates in syndicated show data
#define KS_NABTS_GROUPID_SYNDICATED_SHOW_CONTENT_BASE          0x840
#define KS_NABTS_GROUPID_SYNDICATED_SHOW_ADVERTISER_BASE       0x850

// Used by tv networks in network television data
#define KS_NABTS_GROUPID_NETWORK_WIDE_CONTENT_BASE             0x860
#define KS_NABTS_GROUPID_NETWORK_WIDE_ADVERTISER_BASE          0x870

// Used by telvision stations in local programming data
#define KS_NABTS_GROUPID_TELEVISION_STATION_CONTENT_BASE       0x880
#define KS_NABTS_GROUPID_TELEVISION_STATION_ADVERTISER_BASE    0x890

// Used by cable system in cable head-end originated data
#define KS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_CONTENT_BASE       0x8A0
#define KS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_ADVERTISER_BASE    0x8B0

// The values between 0x8C0 - 0x8EF are reserved for future expansion

// Used by Microsoft for Testing purposes (0x8F0 - 0x8FF)
#define KS_NABTS_GROUPID_MICROSOFT_RESERVED_TEST_DATA_BASE     0x8F0

//////////////////////////////////////////////////////////////
// Stream Format FEC-corrected NABTS bundles
//////////////////////////////////////////////////////////////

#define STATIC_KSDATAFORMAT_TYPE_NABTS \
 0xe757bca0, 0x39ac, 0x11d1, 0xa9, 0xf5, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("E757BCA0-39AC-11d1-A9F5-00C04FBBDE8F", KSDATAFORMAT_TYPE_NABTS);
#define KSDATAFORMAT_TYPE_NABTS DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_NABTS)

#define STATIC_KSDATAFORMAT_SUBTYPE_NABTS_FEC \
 0xe757bca1, 0x39ac, 0x11d1, 0xa9, 0xf5, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("E757BCA1-39AC-11d1-A9F5-00C04FBBDE8F", KSDATAFORMAT_SUBTYPE_NABTS_FEC);
#define KSDATAFORMAT_SUBTYPE_NABTS_FEC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NABTS_FEC)


//////////////////////////////////////////////////////////////
// NABTS Bundle data structure definition
//////////////////////////////////////////////////////////////

#define MAX_NABTS_VBI_LINES_PER_FIELD   11
#define NABTS_LINES_PER_BUNDLE          16
#define NABTS_PAYLOAD_PER_LINE          28
#define NABTS_BYTES_PER_LINE            36

typedef struct _NABTSFEC_BUFFER {
    ULONG       dataSize;
    USHORT      groupID;
    USHORT      Reserved;
    UCHAR       data[NABTS_LINES_PER_BUNDLE * NABTS_PAYLOAD_PER_LINE];
} NABTSFEC_BUFFER, *PNABTSFEC_BUFFER;

//////////////////////////////////////////////////////////////
// vbi codec filtering pin properties
//////////////////////////////////////////////////////////////

#define STATIC_KSPROPSETID_VBICodecFiltering \
    0xcafeb0caL, 0x8715, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0xc0, 0xed, 0xba, 0xbe
DEFINE_GUIDSTRUCT("cafeb0ca-8715-11d0-bd6a-0035c0edbabe", KSPROPSETID_VBICodecFiltering);
#define KSPROPSETID_VBICodecFiltering DEFINE_GUIDNAMED(KSPROPSETID_VBICodecFiltering)

typedef enum {
    KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY = 0x01,
    KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
    KSPROPERTY_VBICODECFILTERING_STATISTICS,
} KSPROPERTY_VBICODECFILTERING;

typedef struct _VBICODECFILTERING_SCANLINES {
    DWORD   DwordBitArray[32];      // An array of scanline bits 0..1024(32*32)
} VBICODECFILTERING_SCANLINES, *PVBICODECFILTERING_SCANLINES;

typedef struct _VBICODECFILTERING_NABTS_SUBSTREAMS {
    DWORD   SubstreamMask[128];   // An array of 4096 bits (one for each NABTS GroupID)
} VBICODECFILTERING_NABTS_SUBSTREAMS, *PVBICODECFILTERING_NABTS_SUBSTREAMS;

typedef struct _VBICODECFILTERING_CC_SUBSTREAMS {
    DWORD   SubstreamMask;        // An array of 32 bits (see KS_CC_SUBSTREAM *)
} VBICODECFILTERING_CC_SUBSTREAMS, *PVBICODECFILTERING_CC_SUBSTREAMS;

#define KS_CC_SUBSTREAM_ODD               0x0001L
#define KS_CC_SUBSTREAM_EVEN              0x0002L
#define KS_CC_SUBSTREAM_SERVICE_MASK_DC1  0x00F0L // DataChannel1: CC1,CC3,T1,T3
#define KS_CC_SUBSTREAM_SERVICE_CC1       0x0010L
#define KS_CC_SUBSTREAM_SERVICE_CC3       0x0020L
#define KS_CC_SUBSTREAM_SERVICE_T1        0x0040L
#define KS_CC_SUBSTREAM_SERVICE_T3        0x0080L
#define KS_CC_SUBSTREAM_SERVICE_MASK_DC2  0x0F00L // DataChannel2: CC2,CC4,T2,T4
#define KS_CC_SUBSTREAM_SERVICE_CC2       0x0100L
#define KS_CC_SUBSTREAM_SERVICE_CC4       0x0200L
#define KS_CC_SUBSTREAM_SERVICE_T2        0x0400L
#define KS_CC_SUBSTREAM_SERVICE_T4        0x0800L
#define KS_CC_SUBSTREAM_SERVICE_XDS       0x1000L

///////////////////////////////////////////////////////////////////
// Hardware decoded CC stream format
///////////////////////////////////////////////////////////////////

#define CC_MAX_HW_DECODE_LINES 12
typedef struct _CC_BYTE_PAIR {
    BYTE        Decoded[2];
    USHORT      Reserved;
} CC_BYTE_PAIR, *PCC_BYTE_PAIR;

typedef struct _CC_HW_FIELD {
    VBICODECFILTERING_SCANLINES  ScanlinesRequested;
    ULONG                        fieldFlags;    // KS_VBI_FLAG_FIELD1,2
    LONGLONG                     PictureNumber;
    CC_BYTE_PAIR                 Lines[CC_MAX_HW_DECODE_LINES];
} CC_HW_FIELD, *PCC_HW_FIELD;

///////////////////////////////////////////////////////////////////
// Raw NABTS stream format (TYPE_NABTS, SUBTYPE_NABTS)
///////////////////////////////////////////////////////////////////

// These low-level structures are byte packed( -Zp1 )
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif
typedef struct _NABTS_BUFFER_LINE {
    BYTE                            Confidence;
    BYTE                            Bytes[NABTS_BYTES_PER_LINE];
} NABTS_BUFFER_LINE, *PNABTS_BUFFER_LINE;

#define NABTS_BUFFER_PICTURENUMBER_SUPPORT 1
typedef struct _NABTS_BUFFER {
    VBICODECFILTERING_SCANLINES     ScanlinesRequested;
    LONGLONG                        PictureNumber;
    NABTS_BUFFER_LINE               NabtsLines[MAX_NABTS_VBI_LINES_PER_FIELD];
} NABTS_BUFFER, *PNABTS_BUFFER;
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif

//
// Common codec statistics
//

typedef struct _VBICODECFILTERING_STATISTICS_COMMON {
    DWORD   InputSRBsProcessed;         // upstream SRBs received
    DWORD   OutputSRBsProcessed;        // downstream SRBs sent
    DWORD   SRBsIgnored;                // SRBs ignored due to no requests
    DWORD   InputSRBsMissing;           // SRBs dropped upstream
    DWORD   OutputSRBsMissing;          // Output dropped because no SRB pending
    DWORD   OutputFailures;             // dropped because of other failure
    DWORD   InternalErrors;             // could not process due to int. failure
    DWORD   ExternalErrors;             // could not process due to ext. failure
    DWORD   InputDiscontinuities;       // discontinuities received
    DWORD   DSPFailures;                // DSP confidence failure
    DWORD   TvTunerChanges;             // number of received KS_TVTUNER_CHANGE_BEGIN_TUNE and KS_TVTUNER_CHANGE_END_TUNE pairs.
    DWORD   VBIHeaderChanges;           // number of received KS_VBI_FLAG_VBIINFOHEADER_CHANGE
    DWORD   LineConfidenceAvg;          // Average of all DSP confidence results
    DWORD   BytesOutput;                // Bytes sent downstream
} VBICODECFILTERING_STATISTICS_COMMON, *PVBICODECFILTERING_STATISTICS_COMMON;

typedef struct _VBICODECFILTERING_STATISTICS_COMMON_PIN {
    DWORD   SRBsProcessed;              // SRBs sent/received
    DWORD   SRBsIgnored;                // SRBs ignored due to filtering
    DWORD   SRBsMissing;                // SRBs not sent/received
    DWORD   InternalErrors;             // could not send/receive due to int. failure
    DWORD   ExternalErrors;             // could not send/receive due to ext. failure
    DWORD   Discontinuities;            // discontinuities received/sent
    DWORD   LineConfidenceAvg;          // Average of all DSP confidence results for this pin
    DWORD   BytesOutput;                // Bytes sent downstream
} VBICODECFILTERING_STATISTICS_COMMON_PIN, *PVBICODECFILTERING_STATISTICS_COMMON_PIN;

//
// Codec-specific statistics - NABTS
//

typedef struct _VBICODECFILTERING_STATISTICS_NABTS {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
    DWORD   FECBundleBadLines;          // Un-FEC-correctable lines
    DWORD   FECQueueOverflows;          // Number of times FEC queue overflowed
    DWORD   FECCorrectedLines;          // Lines CSUM corrected by FEC
    DWORD   FECUncorrectableLines;      // FEC input lines not CSUM correctable
    DWORD   BundlesProcessed;           // Bundles received from FEC
    DWORD   BundlesSent2IP;             // Bundles sent to IP driver
    DWORD   FilteredLines;              // Lines processed and then dropped
                                        // because no one was interested
} VBICODECFILTERING_STATISTICS_NABTS, *PVBICODECFILTERING_STATISTICS_NABTS;

typedef struct _VBICODECFILTERING_STATISTICS_NABTS_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_NABTS_PIN, *PVBICODECFILTERING_STATISTICS_NABTS_PIN;

//
// Codec-specific statistics - Closed Caption
//

typedef struct _VBICODECFILTERING_STATISTICS_CC {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
} VBICODECFILTERING_STATISTICS_CC, *PVBICODECFILTERING_STATISTICS_CC;


typedef struct _VBICODECFILTERING_STATISTICS_CC_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_CC_PIN, *PVBICODECFILTERING_STATISTICS_CC_PIN;

////////////////////////////////////////////////////////////////////////////
// VBI codec property structures(based on KSPROPERTY_VBICODECFILTERING enum)
////////////////////////////////////////////////////////////////////////////

// *** Most codecs support this property
//    KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY
//    KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
typedef struct {
    KSPROPERTY                          Property;
    VBICODECFILTERING_SCANLINES         Scanlines;
} KSPROPERTY_VBICODECFILTERING_SCANLINES_S, *PKSPROPERTY_VBICODECFILTERING_SCANLINES_S;

// *** NABTS codecs support this property
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
typedef struct {
    KSPROPERTY                          Property;
    VBICODECFILTERING_NABTS_SUBSTREAMS  Substreams;
} KSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S, *PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S;

// *** Closed captioning codecs support this property
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_CC_SUBSTREAMS         Substreams;
} KSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S, *PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S;

// *** Most codecs support these versions of the global and pin properties
//    KSPROPERTY_VBICODECFILTERING_STATISTICS
typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_COMMON     Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_COMMON_PIN Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S;

// *** NABTS codecs support this version of the global and pin properties
//    KSPROPERTY_VBICODECFILTERING_STATISTICS
typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_NABTS      Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_NABTS_PIN  Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S;

// *** Closed captioning codecs support this version of the global and pin properties
//    KSPROPERTY_VBICODECFILTERING_STATISTICS

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_CC         Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_CC_PIN     Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S;

// Standard Pin Names for the video capture filter
//===========================================================================

#define STATIC_PINNAME_VIDEO_CAPTURE \
    0xfb6c4281, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define STATIC_PINNAME_CAPTURE STATIC_PINNAME_VIDEO_CAPTURE
DEFINE_GUIDSTRUCT("FB6C4281-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_CAPTURE);
#define PINNAME_VIDEO_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CAPTURE)
#define PINNAME_CAPTURE PINNAME_VIDEO_CAPTURE

#define STATIC_PINNAME_VIDEO_CC_CAPTURE \
    0x1aad8061, 0x12d, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
#define STATIC_PINNAME_CC_CAPTURE STATIC_PINNAME_VIDEO_CC_CAPTURE
DEFINE_GUIDSTRUCT("1AAD8061-012D-11d2-B4B1-00A0D102CFBE", PINNAME_VIDEO_CC_CAPTURE);
#define PINNAME_VIDEO_CC_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CC_CAPTURE)

#define STATIC_PINNAME_VIDEO_NABTS_CAPTURE \
    0x29703660, 0x498a, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
#define STATIC_PINNAME_NABTS_CAPTURE STATIC_PINNAME_VIDEO_NABTS_CAPTURE
DEFINE_GUIDSTRUCT("29703660-498A-11d2-B4B1-00A0D102CFBE", PINNAME_VIDEO_NABTS_CAPTURE);
#define PINNAME_VIDEO_NABTS_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS_CAPTURE)

#define STATIC_PINNAME_VIDEO_PREVIEW \
    0xfb6c4282, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define STATIC_PINNAME_PREVIEW STATIC_PINNAME_VIDEO_PREVIEW
DEFINE_GUIDSTRUCT("FB6C4282-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_PREVIEW);
#define PINNAME_VIDEO_PREVIEW DEFINE_GUIDNAMED(PINNAME_VIDEO_PREVIEW)
#define PINNAME_PREVIEW PINNAME_VIDEO_PREVIEW

#define STATIC_PINNAME_VIDEO_ANALOGVIDEOIN \
    0xfb6c4283, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4283-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_ANALOGVIDEOIN);
#define PINNAME_VIDEO_ANALOGVIDEOIN DEFINE_GUIDNAMED(PINNAME_VIDEO_ANALOGVIDEOIN)

#define STATIC_PINNAME_VIDEO_VBI \
    0xfb6c4284, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4284-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VBI);
#define PINNAME_VIDEO_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VBI)

#define STATIC_PINNAME_VIDEO_VIDEOPORT \
    0xfb6c4285, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4285-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VIDEOPORT);
#define PINNAME_VIDEO_VIDEOPORT DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT)

#define STATIC_PINNAME_VIDEO_NABTS \
    0xfb6c4286, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4286-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_NABTS);
#define PINNAME_VIDEO_NABTS DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS)

#define STATIC_PINNAME_VIDEO_EDS \
    0xfb6c4287, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4287-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_EDS);
#define PINNAME_VIDEO_EDS DEFINE_GUIDNAMED(PINNAME_VIDEO_EDS)

#define STATIC_PINNAME_VIDEO_TELETEXT \
    0xfb6c4288, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4288-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_TELETEXT);
#define PINNAME_VIDEO_TELETEXT DEFINE_GUIDNAMED(PINNAME_VIDEO_TELETEXT)

#define STATIC_PINNAME_VIDEO_CC \
    0xfb6c4289, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4289-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_CC);
#define PINNAME_VIDEO_CC DEFINE_GUIDNAMED(PINNAME_VIDEO_CC)

#define STATIC_PINNAME_VIDEO_STILL \
    0xfb6c428A, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428A-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_STILL);
#define PINNAME_VIDEO_STILL DEFINE_GUIDNAMED(PINNAME_VIDEO_STILL)

#define STATIC_PINNAME_VIDEO_TIMECODE \
    0xfb6c428B, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428B-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_TIMECODE);
#define PINNAME_VIDEO_TIMECODE DEFINE_GUIDNAMED(PINNAME_VIDEO_TIMECODE)

#define STATIC_PINNAME_VIDEO_VIDEOPORT_VBI \
    0xfb6c428C, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428C-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VIDEOPORT_VBI);
#define PINNAME_VIDEO_VIDEOPORT_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT_VBI)

//===========================================================================
// KSSTREAM_HEADER extensions for digital video
//===========================================================================

#define KS_VIDEO_FLAG_FRAME      0x0000L        // Frame or Field (default is frame)
#define KS_VIDEO_FLAG_FIELD1     0x0001L
#define KS_VIDEO_FLAG_FIELD2     0x0002L

#define KS_VIDEO_FLAG_I_FRAME    0x0000L        // I, B, or P (default is I)
#define KS_VIDEO_FLAG_P_FRAME    0x0010L
#define KS_VIDEO_FLAG_B_FRAME    0x0020L

typedef struct tagKS_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;       // Field1, Field2, or Frame
    LONGLONG                PictureNumber;
    LONGLONG                DropCount;

    // The following are only set when using OverlayMixer
    HANDLE                  hDirectDraw;        // user mode DDraw handle
    HANDLE                  hSurfaceHandle;     // user mode surface handle
    RECT                    DirectDrawRect;     // portion of surface locked
    // Reserved fields, never reference these
    DWORD                   Reserved1;
    DWORD                   Reserved2;
    DWORD                   Reserved3;
    DWORD                   Reserved4;
} KS_FRAME_INFO, *PKS_FRAME_INFO;

//===========================================================================
// KSSTREAM_HEADER extensions for VBI
//===========================================================================

#define KS_VBI_FLAG_FIELD1               0x0001L
#define KS_VBI_FLAG_FIELD2               0x0002L

#define KS_VBI_FLAG_MV_PRESENT           0x0100L
#define KS_VBI_FLAG_MV_HARDWARE          0x0200L
#define KS_VBI_FLAG_MV_DETECTED          0x0400L

#define KS_VBI_FLAG_TVTUNER_CHANGE       0x0010L // TvTunerChangeInfo is valid
#define KS_VBI_FLAG_VBIINFOHEADER_CHANGE 0x0020L // VBIInfoHeader is valid

typedef struct tagKS_VBI_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;  // Field1, Field2, or Frame; & etc
    LONGLONG                PictureNumber; // Test only?
    LONGLONG                DropCount;     // Test only?
    DWORD                   dwSamplingFrequency;
    KS_TVTUNER_CHANGE_INFO  TvTunerChangeInfo;
    KS_VBIINFOHEADER        VBIInfoHeader;
} KS_VBI_FRAME_INFO, *PKS_VBI_FRAME_INFO;


//===========================================================================
// Analog video formats, used with:
//      Analog Video Decoders
//      TVTuners
//      Analog Video Encoders
//
// XXX_STANDARDS_SUPPORTED returns a bitmask
//===========================================================================

typedef enum
{
    KS_AnalogVideo_None     = 0x00000000,  // This is a digital sensor
    KS_AnalogVideo_NTSC_M   = 0x00000001,  //        75 IRE Setup
    KS_AnalogVideo_NTSC_M_J = 0x00000002,  // Japan,  0 IRE Setup
    KS_AnalogVideo_NTSC_433 = 0x00000004,

    KS_AnalogVideo_PAL_B    = 0x00000010,
    KS_AnalogVideo_PAL_D    = 0x00000020,
    KS_AnalogVideo_PAL_G    = 0x00000040,
    KS_AnalogVideo_PAL_H    = 0x00000080,
    KS_AnalogVideo_PAL_I    = 0x00000100,
    KS_AnalogVideo_PAL_M    = 0x00000200,
    KS_AnalogVideo_PAL_N    = 0x00000400,

    KS_AnalogVideo_PAL_60   = 0x00000800,

    KS_AnalogVideo_SECAM_B  = 0x00001000,
    KS_AnalogVideo_SECAM_D  = 0x00002000,
    KS_AnalogVideo_SECAM_G  = 0x00004000,
    KS_AnalogVideo_SECAM_H  = 0x00008000,
    KS_AnalogVideo_SECAM_K  = 0x00010000,
    KS_AnalogVideo_SECAM_K1 = 0x00020000,
    KS_AnalogVideo_SECAM_L  = 0x00040000,
    KS_AnalogVideo_SECAM_L1 = 0x00080000,

    KS_AnalogVideo_PAL_N_COMBO
                            = 0x00100000
} KS_AnalogVideoStandard;

#define KS_AnalogVideo_NTSC_Mask  0x00000007
#define KS_AnalogVideo_PAL_Mask   0x00100FF0
#define KS_AnalogVideo_SECAM_Mask 0x000FF000

//===========================================================================
// Property set definitions
// The comments show whether a given property is:
//      R  : READ only
//      w  : WRITE only
//      RW : READ / WRITE
//      O  : Optional (return E_UNSUPPORTED if you don't handle this)
//===========================================================================

#define STATIC_PROPSETID_ALLOCATOR_CONTROL\
    0x53171960, 0x148e, 0x11d2, 0x99, 0x79, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("53171960-148E-11d2-9979-0000C0CC16BA", PROPSETID_ALLOCATOR_CONTROL);
#define PROPSETID_ALLOCATOR_CONTROL DEFINE_GUIDNAMED(PROPSETID_ALLOCATOR_CONTROL)
typedef enum {
    KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT,      // R O (will allocate exactly this number of buffers)
    KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE,     // R O (return 2 DWORDs specifying surface size)
} KSPROPERTY_ALLOCATOR_CONTROL;


//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEOPROCAMP\
    0xC6E13360L, 0x30AC, 0x11d0, 0xa1, 0x8c, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13360-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEOPROCAMP);
#define PROPSETID_VIDCAP_VIDEOPROCAMP DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOPROCAMP)

typedef enum {
    KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,            // RW O
    KSPROPERTY_VIDEOPROCAMP_CONTRAST,              // RW O
    KSPROPERTY_VIDEOPROCAMP_HUE,                   // RW O
    KSPROPERTY_VIDEOPROCAMP_SATURATION,            // RW O
    KSPROPERTY_VIDEOPROCAMP_SHARPNESS,             // RW O
    KSPROPERTY_VIDEOPROCAMP_GAMMA,                 // RW O
    KSPROPERTY_VIDEOPROCAMP_COLORENABLE,           // RW O
    KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE,          // RW O
    KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION,// RW O
} KSPROPERTY_VIDCAP_VIDEOPROCAMP;

typedef struct {
    KSPROPERTY Property;
    LONG   Value;                       // Value to set or get
    ULONG  Flags;                       // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
    ULONG  Capabilities;                // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
} KSPROPERTY_VIDEOPROCAMP_S, *PKSPROPERTY_VIDEOPROCAMP_S;

#define KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO        0X0001L
#define KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL      0X0002L

//===========================================================================

#define STATIC_PROPSETID_TUNER\
    0x6a2e0605L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0605-28e4-11d0-a18c-00a0c9118956", PROPSETID_TUNER);
#define PROPSETID_TUNER DEFINE_GUIDNAMED(PROPSETID_TUNER)

typedef enum {
    KSPROPERTY_TUNER_CAPS,              // R  -overall device capabilities
    KSPROPERTY_TUNER_MODE_CAPS,         // R  -capabilities in this mode
    KSPROPERTY_TUNER_MODE,              // RW -set a mode (TV, FM, AM, DSS)
    KSPROPERTY_TUNER_STANDARD,          // R  -get TV standard (only if TV mode)
    KSPROPERTY_TUNER_FREQUENCY,         // RW -set/get frequency
    KSPROPERTY_TUNER_INPUT,             // RW -select an input
    KSPROPERTY_TUNER_STATUS,            // R  -tuning status
    KSPROPERTY_TUNER_IF_MEDIUM          // R O-Medium for IF or Transport Pin
} KSPROPERTY_TUNER;

typedef enum {
    KSPROPERTY_TUNER_MODE_TV            = 0X0001,
    KSPROPERTY_TUNER_MODE_FM_RADIO      = 0X0002,
    KSPROPERTY_TUNER_MODE_AM_RADIO      = 0X0004,
    KSPROPERTY_TUNER_MODE_DSS           = 0X0008,
    KSPROPERTY_TUNER_MODE_ATSC          = 0X0010,  // also used for DVB-T, DVB-C
} KSPROPERTY_TUNER_MODES;

// Describes how the device tunes.  Only one of these flags may be set
// in KSPROPERTY_TUNER_MODE_CAPS_S.Strategy

// Describe how the driver should attempt to tune:
// EXACT:   just go to the frequency specified (no fine tuning)
// FINE:    (slow) do an exhaustive search for the best signal
// COARSE:  (fast) use larger frequency jumps to just determine if any signal

typedef enum {
    KS_TUNER_TUNING_EXACT = 1,        // No fine tuning
    KS_TUNER_TUNING_FINE,             // Fine grained search
    KS_TUNER_TUNING_COARSE,           // Coarse search
}KS_TUNER_TUNING_FLAGS;

typedef enum {
    KS_TUNER_STRATEGY_PLL             = 0X01, // Tune by PLL offset
    KS_TUNER_STRATEGY_SIGNAL_STRENGTH = 0X02, // Tune by signal strength
    KS_TUNER_STRATEGY_DRIVER_TUNES    = 0X04, // Driver does fine tuning
}KS_TUNER_STRATEGY;

typedef struct {
    KSPROPERTY Property;
    ULONG  ModesSupported;              // KS_PROPERTY_TUNER_MODES_*
    KSPIN_MEDIUM VideoMedium;           // GUID_NULL (no pin), or GUID
    KSPIN_MEDIUM TVAudioMedium;         // GUID_NULL (no pin), or GUID
    KSPIN_MEDIUM RadioAudioMedium;      // GUID_NULL (no pin), or GUID
} KSPROPERTY_TUNER_CAPS_S, *PKSPROPERTY_TUNER_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    KSPIN_MEDIUM IFMedium;              // GUID_NULL (no pin), or GUID
} KSPROPERTY_TUNER_IF_MEDIUM_S, *PKSPROPERTY_TUNER_IF_MEDIUM_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Mode;                        // IN: KSPROPERTY_TUNER_MODE
    ULONG  StandardsSupported;          // KS_AnalogVideo_* (if TV or DSS)
    ULONG  MinFrequency;                // Hz
    ULONG  MaxFrequency;                // Hz
    ULONG  TuningGranularity;           // Hz
    ULONG  NumberOfInputs;              // count of inputs
    ULONG  SettlingTime;                // milliSeconds
    ULONG  Strategy;                    // KS_TUNER_STRATEGY
} KSPROPERTY_TUNER_MODE_CAPS_S, *PKSPROPERTY_TUNER_MODE_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Mode;                        // IN: KSPROPERTY_TUNER_MODE
} KSPROPERTY_TUNER_MODE_S, *PKSPROPERTY_TUNER_MODE_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Frequency;                   // Hz
    ULONG  LastFrequency;               // Hz (last known good)
    ULONG  TuningFlags;                 // KS_TUNER_TUNING_FLAGS
    ULONG  VideoSubChannel;             // DSS
    ULONG  AudioSubChannel;             // DSS
    ULONG  Channel;                     // VBI decoders
    ULONG  Country;                     // VBI decoders
} KSPROPERTY_TUNER_FREQUENCY_S, *PKSPROPERTY_TUNER_FREQUENCY_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Standard;                    // KS_AnalogVideo_*
} KSPROPERTY_TUNER_STANDARD_S, *PKSPROPERTY_TUNER_STANDARD_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  InputIndex;                  // 0 to (n-1) inputs
} KSPROPERTY_TUNER_INPUT_S, *PKSPROPERTY_TUNER_INPUT_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  CurrentFrequency;            // Hz
    ULONG  PLLOffset;                   // if Strategy.KS_TUNER_STRATEGY_PLL
    ULONG  SignalStrength;              // if Stretegy.KS_TUNER_STRATEGY_SIGNAL_STRENGTH
    ULONG  Busy;                        // TRUE if in the process of tuning
} KSPROPERTY_TUNER_STATUS_S, *PKSPROPERTY_TUNER_STATUS_S;

#define STATIC_EVENTSETID_TUNER\
    0x6a2e0606L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0606-28e4-11d0-a18c-00a0c9118956", EVENTSETID_TUNER);
#define EVENTSETID_TUNER DEFINE_GUIDNAMED(EVENTSETID_TUNER)

typedef enum {
    KSEVENT_TUNER_CHANGED
} KSEVENT_TUNER;


//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEOENCODER\
    0x6a2e0610L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0610-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_VIDEOENCODER);
#define PROPSETID_VIDCAP_VIDEOENCODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOENCODER)

typedef enum {
    KSPROPERTY_VIDEOENCODER_CAPS,                       // R
    KSPROPERTY_VIDEOENCODER_STANDARD,                   // RW
    KSPROPERTY_VIDEOENCODER_COPYPROTECTION,             // RW O
    KSPROPERTY_VIDEOENCODER_CC_ENABLE,                  // RW O
} KSPROPERTY_VIDCAP_VIDEOENCODER;

typedef struct {
    KSPROPERTY Property;
    LONG       Value;                   // value to get or set
    ULONG      Flags;                   //
    ULONG      Capabilities;            //
} KSPROPERTY_VIDEOENCODER_S, *PKSPROPERTY_VIDEOENCODER_S;

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEODECODER\
    0xC6E13350L, 0x30AC, 0x11d0, 0xA1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13350-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEODECODER);
#define PROPSETID_VIDCAP_VIDEODECODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEODECODER)

typedef enum {
    KSPROPERTY_VIDEODECODER_CAPS,                       // R
    KSPROPERTY_VIDEODECODER_STANDARD,                   // RW
    KSPROPERTY_VIDEODECODER_STATUS,                     // R
    KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE,              // Rw O
    KSPROPERTY_VIDEODECODER_VCR_TIMING,                 // RW O
} KSPROPERTY_VIDCAP_VIDEODECODER;

typedef enum {
    KS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT  = 0X0001, // VP Output can tri-stae
    KS_VIDEODECODER_FLAGS_CAN_USE_VCR_LOCKING = 0X0002, // VCR PLL timings
    KS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED = 0X0004, // Can indicate valid signal
}KS_VIDEODECODER_FLAGS;

typedef struct {
    KSPROPERTY Property;
    ULONG      StandardsSupported;      // KS_AnalogVideo_*
    ULONG      Capabilities;            // KS_VIDEODECODER_FLAGS_*
    ULONG      SettlingTime;            // milliseconds
    ULONG      HSyncPerVSync;           // Number of HSync Pulses per VSync
} KSPROPERTY_VIDEODECODER_CAPS_S, *PKSPROPERTY_VIDEODECODER_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      NumberOfLines;           // 525 or 625 lines detected
    ULONG      SignalLocked;            // TRUE if signal is locked
} KSPROPERTY_VIDEODECODER_STATUS_S, *PKSPROPERTY_VIDEODECODER_STATUS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      Value;                   // Get or set a value
} KSPROPERTY_VIDEODECODER_S, *PKSPROPERTY_VIDEODECODER_S;

#define STATIC_EVENTSETID_VIDEODECODER\
    0x6a2e0621L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0621-28e4-11d0-a18c-00a0c9118956", EVENTSETID_VIDEODECODER);
#define EVENTSETID_VIDEODECODER DEFINE_GUIDNAMED(EVENTSETID_VIDEODECODER)

typedef enum {
    KSEVENT_VIDEODECODER_CHANGED
} KSEVENT_VIDEODECODER;

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_CAMERACONTROL\
    0xC6E13370L, 0x30AC, 0x11d0, 0xa1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13370-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_CAMERACONTROL);
#define PROPSETID_VIDCAP_CAMERACONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CAMERACONTROL)

typedef enum {
    KSPROPERTY_CAMERACONTROL_PAN,                       // RW O
    KSPROPERTY_CAMERACONTROL_TILT,                      // RW O
    KSPROPERTY_CAMERACONTROL_ROLL,                      // RW O
    KSPROPERTY_CAMERACONTROL_ZOOM,                      // RW O
    KSPROPERTY_CAMERACONTROL_EXPOSURE,                  // RW O
    KSPROPERTY_CAMERACONTROL_IRIS,                      // RW O
    KSPROPERTY_CAMERACONTROL_FOCUS,                     // RW O
} KSPROPERTY_VIDCAP_CAMERACONTROL;

typedef struct {
    KSPROPERTY Property;
    LONG       Value;                   // value to get or set
    ULONG      Flags;                   // KSPROPERTY_CAMERACONTROL_FLAGS_*
    ULONG      Capabilities;            // KSPROPERTY_CAMERACONTROL_FLAGS_*
} KSPROPERTY_CAMERACONTROL_S, *PKSPROPERTY_CAMERACONTROL_S;

#define KSPROPERTY_CAMERACONTROL_FLAGS_AUTO        0X0001L
#define KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL      0X0002L

#define KSPROPERTY_CAMERACONTROL_FLAGS_ABSOLUTE    0X0000L
#define KSPROPERTY_CAMERACONTROL_FLAGS_RELATIVE    0X0010L


//===========================================================================

#define STATIC_PROPSETID_VIDCAP_CROSSBAR\
    0x6a2e0640L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0640-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_CROSSBAR);
#define PROPSETID_VIDCAP_CROSSBAR DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CROSSBAR)

typedef enum {
    KSPROPERTY_CROSSBAR_CAPS,                     // R
    KSPROPERTY_CROSSBAR_PININFO,                  // R
    KSPROPERTY_CROSSBAR_CAN_ROUTE,                // R
    KSPROPERTY_CROSSBAR_ROUTE,                    // RW
} KSPROPERTY_VIDCAP_CROSSBAR;

typedef struct {
    KSPROPERTY Property;
    ULONG  NumberOfInputs;      // the number of audio and video input pins
    ULONG  NumberOfOutputs;     // the number of audio and video output pins
} KSPROPERTY_CROSSBAR_CAPS_S, *PKSPROPERTY_CROSSBAR_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    KSPIN_DATAFLOW Direction;     // KSPIN_DATAFLOW_IN or KSPIN_DATAFLOW_OUT?
    ULONG  Index;                 // Which pin to return data for?
    ULONG  PinType;               // KS_PhysConn_Video_* or KS_PhysConn_Audio_*
    ULONG  RelatedPinIndex;       // For video pins, this is the related audio pin
    KSPIN_MEDIUM  Medium;         // Identifies the hardware connection
} KSPROPERTY_CROSSBAR_PININFO_S, *PKSPROPERTY_CROSSBAR_PININFO_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  IndexInputPin;        // Zero based index of the input pin
    ULONG  IndexOutputPin;       // Zero based index of the output pin
    ULONG  CanRoute;             // returns non-zero on CAN_ROUTE if routing is possible
} KSPROPERTY_CROSSBAR_ROUTE_S, *PKSPROPERTY_CROSSBAR_ROUTE_S;

#define STATIC_EVENTSETID_CROSSBAR\
    0x6a2e0641L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0641-28e4-11d0-a18c-00a0c9118956", EVENTSETID_CROSSBAR);
#define EVENTSETID_CROSSBAR DEFINE_GUIDNAMED(EVENTSETID_CROSSBAR)

typedef enum {
    KSEVENT_CROSSBAR_CHANGED
} KSEVENT_CROSSBAR;

// The following IDs should match the AM equivalents
typedef enum {
    KS_PhysConn_Video_Tuner = 1,
    KS_PhysConn_Video_Composite,
    KS_PhysConn_Video_SVideo,
    KS_PhysConn_Video_RGB,
    KS_PhysConn_Video_YRYBY,
    KS_PhysConn_Video_SerialDigital,
    KS_PhysConn_Video_ParallelDigital,
    KS_PhysConn_Video_SCSI,
    KS_PhysConn_Video_AUX,
    KS_PhysConn_Video_1394,
    KS_PhysConn_Video_USB,
    KS_PhysConn_Video_VideoDecoder,
    KS_PhysConn_Video_VideoEncoder,
    KS_PhysConn_Video_SCART,

    KS_PhysConn_Audio_Tuner = 4096,
    KS_PhysConn_Audio_Line,
    KS_PhysConn_Audio_Mic,
    KS_PhysConn_Audio_AESDigital,
    KS_PhysConn_Audio_SPDIFDigital,
    KS_PhysConn_Audio_SCSI,
    KS_PhysConn_Audio_AUX,
    KS_PhysConn_Audio_1394,
    KS_PhysConn_Audio_USB,
    KS_PhysConn_Audio_AudioDecoder,
} KS_PhysicalConnectorType;


//===========================================================================

#define STATIC_PROPSETID_VIDCAP_TVAUDIO\
    0x6a2e0650L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0650-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_TVAUDIO);
#define PROPSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(PROPSETID_VIDCAP_TVAUDIO)

typedef enum {
    KSPROPERTY_TVAUDIO_CAPS,                            // R
    KSPROPERTY_TVAUDIO_MODE,                            // RW
    KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES        // R
} KSPROPERTY_VIDCAP_TVAUDIO;

#define KS_TVAUDIO_MODE_MONO           0x0001          // Mono
#define KS_TVAUDIO_MODE_STEREO         0x0002          // Stereo
#define KS_TVAUDIO_MODE_LANG_A         0x0010          // Primary language
#define KS_TVAUDIO_MODE_LANG_B         0x0020          // 2nd avail language
#define KS_TVAUDIO_MODE_LANG_C         0x0040          // 3rd avail language

typedef struct {
    KSPROPERTY Property;
    ULONG      Capabilities;             // Bitmask of KS_TVAUDIO_MODE_*
    KSPIN_MEDIUM InputMedium;
    KSPIN_MEDIUM OutputMedium;
} KSPROPERTY_TVAUDIO_CAPS_S, *PKSPROPERTY_TVAUDIO_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      Mode;                     // KS_TVAUDIO_MODE_*
} KSPROPERTY_TVAUDIO_S, *PKSPROPERTY_TVAUDIO_S;


#define STATIC_KSEVENTSETID_VIDCAP_TVAUDIO\
    0x6a2e0651L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0651-28e4-11d0-a18c-00a0c9118956", KSEVENTSETID_VIDCAP_TVAUDIO);
#define KSEVENTSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(KSEVENTSETID_VIDCAP_TVAUDIO)

typedef enum {
    KSEVENT_TVAUDIO_CHANGED,
} KSEVENT_TVAUDIO;

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_VIDEOCOMPRESSION\
    0xC6E13343L, 0x30AC, 0x11d0, 0xA1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13343-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEOCOMPRESSION);
#define PROPSETID_VIDCAP_VIDEOCOMPRESSION DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCOMPRESSION)

typedef enum {
    KSPROPERTY_VIDEOCOMPRESSION_GETINFO,              // R
    KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE,        // RW
    KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME, // RW
    KSPROPERTY_VIDEOCOMPRESSION_QUALITY,              // RW
    KSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_KEYFRAME,    // W
    KSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_FRAME_SIZE,  // W
    KSPROPERTY_VIDEOCOMPRESSION_WINDOWSIZE,           // RW
} KSPROPERTY_VIDCAP_VIDEOCOMPRESSION;

typedef enum {
    KS_CompressionCaps_CanQuality = 1,
    KS_CompressionCaps_CanCrunch = 2,
    KS_CompressionCaps_CanKeyFrame = 4,
    KS_CompressionCaps_CanBFrame = 8,
    KS_CompressionCaps_CanWindow = 0x10,
} KS_CompressionCaps;

typedef struct {
    KSPROPERTY Property;
    // Note, no VersionString!
    // Note, no DescriptionString!
    ULONG      StreamIndex;             // zero based index of stream
    LONG       DefaultKeyFrameRate;     // Key frame rate
    LONG       DefaultPFrameRate;       // Predeicted frames per Key frame
    LONG       DefaultQuality;          // 0 to 10000
    LONG       NumberOfQualitySettings; // How many discreet quality settings?
    LONG       Capabilities;            // KS_CompressionCaps_*
} KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S, *PKSPROPERTY_VIDEOCOMPRESSION_GETINFO_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;             // zero based index of stream
    LONG       Value;                   // value to get or set
} KSPROPERTY_VIDEOCOMPRESSION_S, *PKSPROPERTY_VIDEOCOMPRESSION_S;

//===========================================================================
// MEDIASUBTYPE_Overlay
#define STATIC_KSDATAFORMAT_SUBTYPE_OVERLAY\
    0xe436eb7fL, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb7f-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_OVERLAY);
#define KSDATAFORMAT_SUBTYPE_OVERLAY DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_OVERLAY)

#define STATIC_KSPROPSETID_OverlayUpdate\
    0x490EA5CFL, 0x7681, 0x11D1, 0xA2, 0x1C, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("490EA5CF-7681-11D1-A21C-00A0C9223196", KSPROPSETID_OverlayUpdate);
#define KSPROPSETID_OverlayUpdate DEFINE_GUIDNAMED(KSPROPSETID_OverlayUpdate)

typedef enum {
    KSPROPERTY_OVERLAYUPDATE_INTERESTS,
    KSPROPERTY_OVERLAYUPDATE_CLIPLIST = 0x1,
    KSPROPERTY_OVERLAYUPDATE_PALETTE = 0x2,
    KSPROPERTY_OVERLAYUPDATE_COLORKEY = 0x4,
    KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION = 0x8,
    KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE = 0x10,
    KSPROPERTY_OVERLAYUPDATE_COLORREF = 0x10000000
} KSPROPERTY_OVERLAYUPDATE;

typedef struct {
    ULONG   PelsWidth;
    ULONG   PelsHeight;
    ULONG   BitsPerPel;
    WCHAR   DeviceID[1];
} KSDISPLAYCHANGE, *PKSDISPLAYCHANGE;

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_INTERESTS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_INTERESTS,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_PALETTE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_PALETTE,\
        NULL,\
        sizeof(KSPROPERTY),\
        0,\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_COLORKEY(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_COLORKEY,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(COLORKEY),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_CLIPLIST(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_CLIPLIST,\
        NULL,\
        sizeof(KSPROPERTY),\
        2 * sizeof(RECT) + sizeof(RGNDATAHEADER),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_VIDEOPOSITION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION,\
        NULL,\
        sizeof(KSPROPERTY),\
        2 * sizeof(RECT),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_DISPLAYCHANGE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(KSDISPLAYCHANGE),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_COLORREF(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_COLORREF,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(COLORREF),\
        NULL,\
        NULL, 0, NULL, NULL, 0)

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_VIDEOCONTROL\
    0x6a2e0670L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0670-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_VIDEOCONTROL);
#define PROPSETID_VIDCAP_VIDEOCONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCONTROL)

typedef enum {
    KSPROPERTY_VIDEOCONTROL_CAPS,               // R
    KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE,  // R O
    KSPROPERTY_VIDEOCONTROL_FRAME_RATES,        // R O
    KSPROPERTY_VIDEOCONTROL_MODE,               // RWO
} KSPROPERTY_VIDCAP_VIDEOCONTROL;

typedef enum {
    KS_VideoControlFlag_FlipHorizontal        = 0x0001,
    KS_VideoControlFlag_FlipVertical          = 0x0002,
    KS_Obsolete_VideoControlFlag_ExternalTriggerEnable = 0x0010,    // ***WARNING *** Flag msimatch with DSHOW.
    KS_Obsolete_VideoControlFlag_Trigger               = 0x0020,  // ***WARNING *** Flag msimatch with DSHOW.
    KS_VideoControlFlag_ExternalTriggerEnable = 0x0004,
    KS_VideoControlFlag_Trigger                      = 0x0008,
} KS_VideoControlFlags;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;
    ULONG      VideoControlCaps;                // KS_VideoControlFlags_*
} KSPROPERTY_VIDEOCONTROL_CAPS_S, *PKSPROPERTY_VIDEOCONTROL_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;
    LONG       Mode;                            // KS_VideoControlFlags_*
} KSPROPERTY_VIDEOCONTROL_MODE_S, *PKSPROPERTY_VIDEOCONTROL_MODE_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      RangeIndex;                      // Index of range
    SIZE       Dimensions;                      // Size of image
    LONGLONG   CurrentActualFrameRate;          // Only correct if pin is open
    LONGLONG   CurrentMaxAvailableFrameRate;    // Max Rate temporarily limited on USB or 1394?
} KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S, *PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S;

// KSPROPERTY_VIDEOCONTROL_FRAME_RATES returns a list of available frame rates in 100 nS units
typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      RangeIndex;                      // Index of range
    SIZE       Dimensions;                      // Size of image
} KSPROPERTY_VIDEOCONTROL_FRAME_RATES_S, *PKSPROPERTY_VIDEOCONTROL_FRAME_RATES_S;

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_DROPPEDFRAMES\
    0xC6E13344L, 0x30AC, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13344-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_DROPPEDFRAMES);
#define PROPSETID_VIDCAP_DROPPEDFRAMES DEFINE_GUIDNAMED(PROPSETID_VIDCAP_DROPPEDFRAMES)

typedef enum {
    KSPROPERTY_DROPPEDFRAMES_CURRENT            // R
} KSPROPERTY_VIDCAP_DROPPEDFRAMES;

typedef struct {
    KSPROPERTY Property;
    LONGLONG   PictureNumber;                   // Current Picture Number
    LONGLONG   DropCount;                       // Count of frames dropped
    ULONG      AverageFrameSize;                // Average size of frames captured
} KSPROPERTY_DROPPEDFRAMES_CURRENT_S, *PKSPROPERTY_DROPPEDFRAMES_CURRENT_S;

//===========================================================================
// VPE

#define STATIC_KSPROPSETID_VPConfig\
    0xbc29a660L, 0x30e3, 0x11d0, 0x9e, 0x69, 0x00, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b
DEFINE_GUIDSTRUCT("bc29a660-30e3-11d0-9e69-00c04fd7c15b", KSPROPSETID_VPConfig);
#define KSPROPSETID_VPConfig DEFINE_GUIDNAMED(KSPROPSETID_VPConfig)

#define STATIC_KSPROPSETID_VPVBIConfig\
    0xec529b00L, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("ec529b00-1a1f-11d1-bad9-00609744111a", KSPROPSETID_VPVBIConfig);
#define KSPROPSETID_VPVBIConfig DEFINE_GUIDNAMED(KSPROPSETID_VPVBIConfig)

// Both of the above property sets use the same list of properties below

typedef enum {
    KSPROPERTY_VPCONFIG_NUMCONNECTINFO,
    KSPROPERTY_VPCONFIG_GETCONNECTINFO,
    KSPROPERTY_VPCONFIG_SETCONNECTINFO,
    KSPROPERTY_VPCONFIG_VPDATAINFO,
    KSPROPERTY_VPCONFIG_MAXPIXELRATE,
    KSPROPERTY_VPCONFIG_INFORMVPINPUT,
    KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
    KSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
    KSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
    KSPROPERTY_VPCONFIG_INVERTPOLARITY,
    KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,   // E_NOTIMPL for VBI
    KSPROPERTY_VPCONFIG_SCALEFACTOR,            // E_NOTIMPL for VBI
    KSPROPERTY_VPCONFIG_DDRAWHANDLE,
    KSPROPERTY_VPCONFIG_VIDEOPORTID,
    KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
    KSPROPERTY_VPCONFIG_SURFACEPARAMS
} KSPROPERTY_VPCONFIG;

//=========================
// IBasicAudio
//
#define STATIC_CLSID_KsIBasicAudioInterfaceHandler\
    0xb9f8ac3e, 0x0f71, 0x11d2, 0xb7, 0x2c, 0x00, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d
DEFINE_GUIDSTRUCT("b9f8ac3e-0f71-11d2-b72c-00c04fb6bd3d", CLSID_KsIBasicAudioInterfaceHandler);
#define CLSID_KsIBasicAudioInterfaceHandler DEFINE_GUIDNAMED(CLSID_KsIBasicAudioInterfaceHandler)


#if defined(__IVPType__)

typedef struct {
    AMVPSIZE    Size;
    DWORD       MaxPixelsPerSecond;
    DWORD       Reserved;
} KSVPMAXPIXELRATE, *PKSVPMAXPIXELRATE;

typedef struct {
    KSPROPERTY      Property;
    AMVPSIZE        Size;
} KSVPSIZE_PROP, *PKSVPSIZE_PROP;

typedef struct {
    DWORD   dwPitch;
    DWORD   dwXOrigin;
    DWORD   dwYOrigin;
} KSVPSURFACEPARAMS, *PKSVPSURFACEPARAMS;

#else  // !defined(__IVPType__)

#if !defined(__DDRAW_INCLUDED__)

//==========================================================================
// The following definitions must be in sync with DDraw.h in DirectX SDK
//==========================================================================

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC                             0x00000004l


typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DWORD       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
    union
    {
    DWORD   dwRGBBitCount;          // how many bits per pixel (BD_1,2,4,8,16,24,32)
    DWORD   dwYUVBitCount;          // how many bits per pixel (BD_4,8,16,24,32)
    DWORD   dwZBufferBitDepth;      // how many bits for z buffers (BD_8,16,24,32)
    DWORD   dwAlphaBitDepth;        // how many bits for alpha channels (BD_1,2,4,8)
    };
    union
    {
    DWORD   dwRBitMask;             // mask for red bit
    DWORD   dwYBitMask;             // mask for Y bits
    };
    union
    {
    DWORD   dwGBitMask;             // mask for green bits
    DWORD   dwUBitMask;             // mask for U bits
    };
    union
    {
    DWORD   dwBBitMask;             // mask for blue bits
    DWORD   dwVBitMask;             // mask for V bits
    };
    union
    {
    DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
    DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
    DWORD   dwRGBZBitMask;          // mask for Z channel
    DWORD   dwYUVZBitMask;          // mask for Z channel
    };
} DDPIXELFORMAT, * LPDDPIXELFORMAT;

#endif // !defined(__DDRAW_INCLUDED__)

//==========================================================================
// End of DDraw.h header info
//==========================================================================

//==========================================================================
// The following definitions must be in sync with DVP.h in DirectX SDK
//==========================================================================

#if !defined(__DVP_INCLUDED__)

typedef struct _DDVIDEOPORTCONNECT {
    DWORD dwSize;           // size of the DDVIDEOPORTCONNECT structure
    DWORD dwPortWidth;      // Width of the video port
    GUID  guidTypeID;       // Description of video port connection
    DWORD dwFlags;          // Connection flags
    DWORD dwReserved1;      // Reserved, set to zero.
} DDVIDEOPORTCONNECT, * LPDDVIDEOPORTCONNECT;

#define DDVPTYPE_E_HREFH_VREFH  \
    0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#define DDVPTYPE_E_HREFL_VREFL  \
    0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#endif // !defined(__DVP_INCLUDED__)

//==========================================================================
// End of DVP.h header info
//==========================================================================


//==========================================================================
// The following definitions must be in sync with VPType.h in AM 2.0 SDK
//==========================================================================

// pixel aspect ratios corresponding to a 720x480 NTSC image or a 720x576 image
typedef enum // AMPixAspectRatio
{
    KS_PixAspectRatio_NTSC4x3,
    KS_PixAspectRatio_NTSC16x9,
    KS_PixAspectRatio_PAL4x3,
    KS_PixAspectRatio_PAL16x9,
} KS_AMPixAspectRatio ;

typedef enum // AMVP_SELECTFORMATBY
{
    KS_AMVP_DO_NOT_CARE,
    KS_AMVP_BEST_BANDWIDTH,
    KS_AMVP_INPUT_SAME_AS_OUTPUT
} KS_AMVP_SELECTFORMATBY;

typedef enum // AMVP_MODE
{
    KS_AMVP_MODE_WEAVE,
    KS_AMVP_MODE_BOBINTERLEAVED,
    KS_AMVP_MODE_BOBNONINTERLEAVED,
    KS_AMVP_MODE_SKIPEVEN,
    KS_AMVP_MODE_SKIPODD
} KS_AMVP_MODE ;

typedef struct tagKS_AMVPDIMINFO      // AMVPDIMINFO
{
    DWORD dwFieldWidth ;            // [out] field width
    DWORD dwFieldHeight ;           // [out] field height
    DWORD dwVBIWidth ;              // [out] VBI data width
    DWORD dwVBIHeight ;             // [out] VBI data height
    RECT  rcValidRegion ;           // [out] valid rect for data cropping
} KS_AMVPDIMINFO, *PKS_AMVPDIMINFO ;

typedef struct tagKS_AMVPDATAINFO   // AMVPDATAINFO
{
    DWORD           dwSize;                 // Size of the struct
    DWORD           dwMicrosecondsPerField; // Time taken by each field
    KS_AMVPDIMINFO  amvpDimInfo;            // Dimensional Information
    DWORD           dwPictAspectRatioX;     // Pict aspect ratio in X dimn
    DWORD           dwPictAspectRatioY;     // Pict aspect ratio in Y dimn
    BOOL            bEnableDoubleClock;     // Videoport should enable double clocking
    BOOL            bEnableVACT;            // Videoport should use an external VACT signal
    BOOL            bDataIsInterlaced;      // Indicates that the signal is interlaced
    LONG            lHalfLinesOdd;          // number of halflines in the odd field
    BOOL            bFieldPolarityInverted; // Device inverts the polarity by default
    DWORD           dwNumLinesInVREF;       // Number of lines of data in VREF
    LONG            lHalfLinesEven;         // number of halflines in the even field
    DWORD           dwReserved1;            // Reserved for future use
} KS_AMVPDATAINFO, *PKS_AMVPDATAINFO;

typedef struct tagKS_AMVPSIZE   // AMVPSIZE
{
    DWORD dwWidth ;                  // [in] width in pixels
    DWORD dwHeight ;                 // [in] height in pixels
} KS_AMVPSIZE, *PKS_AMVPSIZE ;

//==========================================================================
// End of VPType.h header info
//==========================================================================

typedef struct {
    KS_AMVPSIZE     Size;
    DWORD           MaxPixelsPerSecond;
    DWORD           Reserved;
} KSVPMAXPIXELRATE, *PKSVPMAXPIXELRATE;

typedef struct {
    KSPROPERTY      Property;
    KS_AMVPSIZE     Size;
} KSVPSIZE_PROP, *PKSVPSIZE_PROP;

typedef struct {
    DWORD   dwPitch;
    DWORD   dwXOrigin;
    DWORD   dwYOrigin;
} KSVPSURFACEPARAMS, *PKSVPSURFACEPARAMS;

#endif // !defined(__IVPType__)

//
//  IVPNotify event notification
//
#define STATIC_KSEVENTSETID_VPNotify\
    0x20c5598eL, 0xd3c8, 0x11d0, 0x8d, 0xfc, 0x00, 0xc0, 0x4f, 0xd7, 0xc0, 0x8b
DEFINE_GUIDSTRUCT("20c5598e-d3c8-11d0-8dfc-00c04fd7c08b", KSEVENTSETID_VPNotify);
#define KSEVENTSETID_VPNotify DEFINE_GUIDNAMED(KSEVENTSETID_VPNotify)

typedef enum {
    KSEVENT_VPNOTIFY_FORMATCHANGE,
} KSEVENT_VPNOTIFY;

//
//  VIDCAPTOSTI event notification
//
#define STATIC_KSEVENTSETID_VIDCAPTOSTI\
    0xdb47de20, 0xf628, 0x11d1, 0xba, 0x41, 0x0, 0xa0, 0xc9, 0xd, 0x2b, 0x5
DEFINE_GUIDSTRUCT("DB47DE20-F628-11d1-BA41-00A0C90D2B05", KSEVENTSETID_VIDCAPTOSTI);
#define KSEVENTSETID_VIDCAPNotify DEFINE_GUIDNAMED(KSEVENTSETID_VIDCAPTOSTI)

typedef enum {
    KSEVENT_VIDCAPTOSTI_EXT_TRIGGER,
} KSEVENT_VIDCAPTOSTI;


//
//  IVPVBINotify event notification
//
#define STATIC_KSEVENTSETID_VPVBINotify\
    0xec529b01L, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("ec529b01-1a1f-11d1-bad9-00609744111a", KSEVENTSETID_VPVBINotify);
#define KSEVENTSETID_VPVBINotify DEFINE_GUIDNAMED(KSEVENTSETID_VPVBINotify)

typedef enum {
    KSEVENT_VPVBINOTIFY_FORMATCHANGE,
} KSEVENT_VPVBINOTIFY;


//
// closed caption information
//

#define STATIC_KSDATAFORMAT_TYPE_AUXLine21Data \
0x670aea80L, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("670aea80-3a82-11d0-b79b-00aa003767a7", KSDATAFORMAT_TYPE_AUXLine21Data);
#define KSDATAFORMAT_TYPE_AUXLine21Data DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_AUXLine21Data)

#define STATIC_KSDATAFORMAT_SUBTYPE_Line21_BytePair \
0x6e8d4a22L, 0x310c, 0x11d0, 0xb7, 0x9a, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("6e8d4a22-310c-11d0-b79a-00aa003767a7", KSDATAFORMAT_SUBTYPE_Line21_BytePair);
#define KSDATAFORMAT_SUBTYPE_Line21_BytePair DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_Line21_BytePair)

#define STATIC_KSDATAFORMAT_SUBTYPE_Line21_GOPPacket \
0x6e8d4a23L, 0x310c, 0x11d0, 0xb7, 0x9a, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("6e8d4a23-310c-11d0-b79a-00aa003767a7", KSDATAFORMAT_SUBTYPE_Line21_GOPPacket);
#define KSDATAFORMAT_SUBTYPE_Line21_GOPPacket DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_Line21_GOPPacket)

typedef struct _KSGOP_USERDATA {
    ULONG sc;
    ULONG reserved1;
    BYTE cFields;
    CHAR l21Data[3];
} KSGOP_USERDATA, *PKSGOP_USERDATA;

//
// DVD encrypted PACK format type definition
//

#define STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK\
    0xed0b916a, 0x044d, 0x11d1, 0xaa, 0x78, 0x00, 0xc0, 0x4f, 0xc3, 0x1d, 0x60
DEFINE_GUIDSTRUCT("ed0b916a-044d-11d1-aa78-00c04fc31d60", KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK);
#define KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK)

#define KS_AM_UseNewCSSKey    0x1


// -----------------------------------------------------------------------
// KS_AM_KSPROPSETID_TSRateChange property set definitions for time stamp
// rate changes.
// -----------------------------------------------------------------------


#define STATIC_KSPROPSETID_TSRateChange\
    0xa503c5c0, 0x1d1d, 0x11d1, 0xad, 0x80, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0

DEFINE_GUIDSTRUCT("A503C5C0-1D1D-11D1-AD80-444553540000", KSPROPSETID_TSRateChange);
#define KSPROPSETID_TSRateChange DEFINE_GUIDNAMED(KSPROPSETID_TSRateChange)
typedef enum {
    KS_AM_RATE_SimpleRateChange=1,  // rw, use KS_AM_SimpleRateChange
    KS_AM_RATE_ExactRateChange=2,   // rw, use KS_AM_ExactRateChange
    KS_AM_RATE_MaxFullDataRate=3,   // r, use KS_AM_MaxFullDataRate
    KS_AM_RATE_Step=4               // w, use KS_AM_Step
} KS_AM_PROPERTY_TS_RATE_CHANGE;

typedef struct {
    // this is the simplest mechanism to set a time stamp rate change on
    // a filter (simplest for the person setting the rate change, harder
    // for the filter doing the rate change).
    REFERENCE_TIME  StartTime;  //stream time at which to start this rate
    LONG        Rate;       //new rate * 10000 (decimal)
} KS_AM_SimpleRateChange, *PKS_AM_SimpleRateChange;

typedef struct {
    REFERENCE_TIME  OutputZeroTime; //input TS that maps to zero output TS
    LONG        Rate;       //new rate * 10000 (decimal)
} KS_AM_ExactRateChange, *PKS_AM_ExactRateChange;

typedef LONG KS_AM_MaxFullDataRate; //rate * 10000 (decimal)

typedef DWORD KS_AM_Step; // number of frame to step


#endif // !defined(_KSMEDIA_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\largeint.h ===
/*--

Module Name:

    largeint.h

Abstract:

    Include file for sample Large Integer Arithmetic routines.  
    This file includes all of the prototypes for the routines found in 
    largeint.lib.  For complete descriptions of these functions, see the
    largeint.s source file for MIPS, or the divlarge.c and largeint.asm 
    source files for x86. 

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

//
//Large integer arithmetic routines.
//

//
// Large integer add - 64-bits + 64-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
LargeIntegerAdd (
    LARGE_INTEGER Addend1,
    LARGE_INTEGER Addend2
    );

//
// Enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
EnlargedIntegerMultiply (
    LONG Multiplicand,
    LONG Multiplier
    );

//
// Unsigned enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
EnlargedUnsignedMultiply (
    ULONG Multiplicand,
    ULONG Multiplier
    );

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

ULONG
WINAPI
EnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    );

//
// Extended large integer magic divide - 64-bits / 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
ExtendedMagicDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER MagicDivisor,
    CCHAR ShiftCount
    );

//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
ExtendedLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder
    );

//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
LargeIntegerDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER Divisor,
    PLARGE_INTEGER Remainder
    );

//
// Extended integer multiply - 32-bits * 64-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
ExtendedIntegerMultiply (
    LARGE_INTEGER Multiplicand,
    LONG Multiplier
    );

//
// Large integer negation - -(64-bits)
//

LARGE_INTEGER
WINAPI
LargeIntegerNegate (
    LARGE_INTEGER Subtrahend
    );

//
// Large integer subtract - 64-bits - 64-bits -> 64-bits.
//

LARGE_INTEGER
WINAPI
LargeIntegerSubtract (
    LARGE_INTEGER Minuend,
    LARGE_INTEGER Subtrahend
    );

//
// Large integer and - 64-bite & 64-bits -> 64-bits.
//

#define LargeIntegerAnd(Result, Source, Mask)   \
        {                                           \
            Result.HighPart = Source.HighPart & Mask.HighPart; \
            Result.LowPart = Source.LowPart & Mask.LowPart; \
        }


//
// Large integer conversion routines.
//

//
// Convert signed integer to large integer.
//

LARGE_INTEGER
WINAPI
ConvertLongToLargeInteger (
    LONG SignedInteger
    );

//
// Convert unsigned integer to large integer.
//

LARGE_INTEGER
WINAPI
ConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    );


//
// Large integer shift routines.
//

LARGE_INTEGER
WINAPI
LargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

LARGE_INTEGER
WINAPI
LargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

LARGE_INTEGER
WINAPI
LargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

#define LargeIntegerGreaterThan(X,Y) (                              \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart > (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                      \
)

#define LargeIntegerGreaterThanOrEqualTo(X,Y) (                      \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart >= (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                       \
)

#define LargeIntegerEqualTo(X,Y) (                              \
    !(((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define LargeIntegerNotEqualTo(X,Y) (                          \
    (((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define LargeIntegerLessThan(X,Y) (                                 \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart < (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                      \
)

#define LargeIntegerLessThanOrEqualTo(X,Y) (                         \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart <= (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                       \
)

#define LargeIntegerGreaterThanZero(X) (       \
    (((X).HighPart == 0) && ((X).LowPart > 0)) || \
    ((X).HighPart > 0 )                           \
)

#define LargeIntegerGreaterOrEqualToZero(X) ( \
    (X).HighPart >= 0                            \
)

#define LargeIntegerEqualToZero(X) ( \
    !((X).LowPart | (X).HighPart)       \
)

#define LargeIntegerNotEqualToZero(X) ( \
    ((X).LowPart | (X).HighPart)           \
)

#define LargeIntegerLessThanZero(X) ( \
    ((X).HighPart < 0)                   \
)

#define LargeIntegerLessOrEqualToZero(X) (           \
    ((X).HighPart < 0) || !((X).LowPart | (X).HighPart) \
)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\kspalpha.h ===
#include "kxalpha.h"

//
// Pointer size in bytes
//

#define SizeofPointer 0x4

//
// Process State Enumerated Type Values
//

#define ProcessInMemory 0x0
#define ProcessOutOfMemory 0x1
#define ProcessInTransition 0x2

//
// Thread State Enumerated Type Values
//

#define Initialized 0x0
#define Ready 0x1
#define Running 0x2
#define Standby 0x3
#define Terminated 0x4
#define Waiting 0x5

//
// Wait Reason and Wait Type Enumerated Type Values
//

#define WrExecutive 0x0
#define WrEventPair 0xe
#define WaitAny 0x1
#define WaitAll 0x0

//
// Apc State Structure Offset Definitions
//

#define AsApcListHead 0x0
#define AsProcess 0x10
#define AsKernelApcInProgress 0x14
#define AsKernelApcPending 0x15
#define AsUserApcPending 0x16

//
// Bug Check Code Definitions
//

#define APC_INDEX_MISMATCH 0x1
#define ATTEMPTED_SWITCH_FROM_DPC 0xb8
#define DATA_BUS_ERROR 0x2e
#define DATA_COHERENCY_EXCEPTION 0x55
#define HAL1_INITIALIZATION_FAILED 0x61
#define INSTRUCTION_BUS_ERROR 0x2f
#define INSTRUCTION_COHERENCY_EXCEPTION 0x56
#define INTERRUPT_EXCEPTION_NOT_HANDLED 0x3d
#define INTERRUPT_UNWIND_ATTEMPTED 0x3c
#define INVALID_AFFINITY_SET 0x3
#define INVALID_DATA_ACCESS_TRAP 0x4
#define IRQL_GT_ZERO_AT_SYSTEM_SERVICE 0x4a
#define IRQL_NOT_LESS_OR_EQUAL 0xa
#define KMODE_EXCEPTION_NOT_HANDLED 0x1e
#define NMI_HARDWARE_FAILURE 0x80
#define NO_USER_MODE_CONTEXT 0xe
#define PAGE_FAULT_WITH_INTERRUPTS_OFF 0x49
#define PANIC_STACK_SWITCH 0x2b
#define SPIN_LOCK_INIT_FAILURE 0x81
#define SYSTEM_EXIT_OWNED_MUTEX 0x39
#define SYSTEM_SERVICE_EXCEPTION 0x3b
#define SYSTEM_UNWIND_PREVIOUS_USER 0x3a
#define TRAP_CAUSE_UNKNOWN 0x12
#define UNEXPECTED_KERNEL_MODE_TRAP 0x7f

//
// Breakpoint type definitions
//

#define DBG_STATUS_CONTROL_C 0x1

//
// Client Id Structure Offset Definitions
//

#define CidUniqueProcess 0x0
#define CidUniqueThread 0x4

//
// Critical Section Structure Offset Definitions
//

#define CsDebugInfo 0x0
#define CsLockCount 0x4
#define CsRecursionCount 0x8
#define CsOwningThread 0xc
#define CsLockSemaphore 0x10
#define CsSpinCount 0x14

//
// Critical Section Debug Information Structure Offset Definitions
//

#define CsType 0x0
#define CsCreatorBackTraceIndex 0x2
#define CsCriticalSection 0x4
#define CsProcessLocksList 0x8
#define CsEntryCount 0x10
#define CsContentionCount 0x14

//
// Dispatcher Context Structure Offset Definitions
//

#define DcControlPc 0x0
#define DcFunctionEntry 0x4
#define DcEstablisherFrame 0x8
#define DcContextRecord 0xc

//
// Exception Record Offset, Flag, and Enumerated Type Definitions
//

#define EXCEPTION_NONCONTINUABLE 0x1
#define EXCEPTION_UNWINDING 0x2
#define EXCEPTION_EXIT_UNWIND 0x4
#define EXCEPTION_STACK_INVALID 0x8
#define EXCEPTION_NESTED_CALL 0x10
#define EXCEPTION_TARGET_UNWIND 0x20
#define EXCEPTION_COLLIDED_UNWIND 0x40
#define EXCEPTION_UNWIND 0x66
#define EXCEPTION_EXECUTE_HANDLER 0x1
#define EXCEPTION_CONTINUE_SEARCH 0x0
#define EXCEPTION_CONTINUE_EXECUTION 0xffffffff

#define ExceptionContinueExecution 0x0
#define ExceptionContinueSearch 0x1
#define ExceptionNestedException 0x2
#define ExceptionCollidedUnwind 0x3

#define ErExceptionCode 0x0
#define ErExceptionFlags 0x4
#define ErExceptionRecord 0x8
#define ErExceptionAddress 0xc
#define ErNumberParameters 0x10
#define ErExceptionInformation 0x14
#define ExceptionRecordLength 0x50

//
// Fast Mutex Structure Offset Definitions
//

#define FmCount 0x0
#define FmOwner 0x4
#define FmContention 0x8
#define FmEvent 0xc
#define FmOldIrql 0x1c

//
// Interrupt Priority Request Level Definitions
//

#define APC_LEVEL 0x1
#define DISPATCH_LEVEL 0x2
#define IPI_LEVEL 0x6
#define POWER_LEVEL 0x7
#define PROFILE_LEVEL 0x3
#define HIGH_LEVEL 0x7
#define SYNCH_LEVEL 0x5

//
// Large Integer Structure Offset Definitions
//

#define LiLowPart 0x0
#define LiHighPart 0x4

//
// List Entry Structure Offset Definitions
//

#define LsFlink 0x0
#define LsBlink 0x4

//
// String Structure Offset Definitions
//

#define StrLength 0x0
#define StrMaximumLength 0x2
#define StrBuffer 0x4

//
// Time Structure Offset Definitions
//

#define TmLowTime 0x0
#define TmHighTime 0x4

//
// Thread Switch Counter Offset Definitions
//

#define TwFindAny 0x0
#define TwFindIdeal 0x4
#define TwFindLast 0x8
#define TwIdleAny 0xc
#define TwIdleCurrent 0x10
#define TwIdleIdeal 0x14
#define TwIdleLast 0x18
#define TwPreemptAny 0x1c
#define TwPreemptCurrent 0x20
#define TwPreemptLast 0x24
#define TwSwitchToIdle 0x28

//
// Status Code Definitions
//

#define STATUS_ALPHA_ARITHMETIC_EXCEPTION 0xc0000092
#define STATUS_ALPHA_BAD_VIRTUAL_ADDRESS 0xc0000005
#define STATUS_ALPHA_FLOATING_NOT_IMPLEMENTED 0xc000014a
#define STATUS_ALPHA_GENTRAP 0xc00000aa
#define STATUS_ALPHA_MACHINE_CHECK 0xdfff002e
#define STATUS_ILLEGAL_VLM_REFERENCE 0xc00002c0
#define STATUS_ACCESS_VIOLATION 0xc0000005
#define STATUS_ARRAY_BOUNDS_EXCEEDED 0xc000008c
#define STATUS_BAD_COMPRESSION_BUFFER 0xc0000242
#define STATUS_BREAKPOINT 0x80000003
#define STATUS_DATATYPE_MISALIGNMENT 0x80000002
#define STATUS_FLOAT_DENORMAL_OPERAND 0xc000008d
#define STATUS_FLOAT_DIVIDE_BY_ZERO 0xc000008e
#define STATUS_FLOAT_INEXACT_RESULT 0xc000008f
#define STATUS_FLOAT_INVALID_OPERATION 0xc0000090
#define STATUS_FLOAT_OVERFLOW 0xc0000091
#define STATUS_FLOAT_STACK_CHECK 0xc0000092
#define STATUS_FLOAT_UNDERFLOW 0xc0000093
#define STATUS_FLOAT_MULTIPLE_FAULTS 0xc00002b4
#define STATUS_FLOAT_MULTIPLE_TRAPS 0xc00002b5
#define STATUS_GUARD_PAGE_VIOLATION 0x80000001
#define STATUS_ILLEGAL_FLOAT_CONTEXT 0xc000014a
#define STATUS_ILLEGAL_INSTRUCTION 0xc000001d
#define STATUS_INSTRUCTION_MISALIGNMENT 0xc00000aa
#define STATUS_INVALID_HANDLE 0xc0000008
#define STATUS_INVALID_LOCK_SEQUENCE 0xc000001e
#define STATUS_INVALID_OWNER 0xc000005a
#define STATUS_INVALID_PARAMETER_1 0xc00000ef
#define STATUS_INVALID_SYSTEM_SERVICE 0xc000001c
#define STATUS_INTEGER_DIVIDE_BY_ZERO 0xc0000094
#define STATUS_INTEGER_OVERFLOW 0xc0000095
#define STATUS_IN_PAGE_ERROR 0xc0000006
#define STATUS_KERNEL_APC 0x100
#define STATUS_LONGJUMP 0x80000026
#define STATUS_NO_CALLBACK_ACTIVE 0xc0000258
#define STATUS_NO_EVENT_PAIR 0xc000014e
#define STATUS_PRIVILEGED_INSTRUCTION 0xc0000096
#define STATUS_SINGLE_STEP 0x80000004
#define STATUS_STACK_OVERFLOW 0xc00000fd
#define STATUS_SUCCESS 0x0
#define STATUS_THREAD_IS_TERMINATING 0xc000004b
#define STATUS_TIMEOUT 0x102
#define STATUS_UNWIND 0xc0000027
#define STATUS_WAKE_SYSTEM_DEBUGGER 0x80000007

//
// APC Object Structure Offset Definitions
//

#define ApType 0x0
#define ApSize 0x2
#define ApThread 0x8
#define ApApcListEntry 0xc
#define ApKernelRoutine 0x14
#define ApRundownRoutine 0x18
#define ApNormalRoutine 0x1c
#define ApNormalContext 0x20
#define ApSystemArgument1 0x24
#define ApSystemArgument2 0x28
#define ApApcStateIndex 0x2c
#define ApApcMode 0x2d
#define ApInserted 0x2e
#define ApcObjectLength 0x30

//
// DPC object Structure Offset Definitions
//

#define DpType 0x0
#define DpNumber 0x2
#define DpImportance 0x3
#define DpDpcListEntry 0x4
#define DpDeferredRoutine 0xc
#define DpDeferredContext 0x10
#define DpSystemArgument1 0x14
#define DpSystemArgument2 0x18
#define DpLock 0x1c
#define DpcObjectLength 0x20

//
// Device Queue Object Structure Offset Definitions
//

#define DvType 0x0
#define DvSize 0x2
#define DvDeviceListHead 0x4
#define DvSpinLock 0xc
#define DvBusy 0x10
#define DeviceQueueObjectLength 0x14

//
// Device Queue Entry Structure Offset Definitions
//

#define DeDeviceListEntry 0x0
#define DeSortKey 0x8
#define DeInserted 0xc
#define DeviceQueueEntryLength 0x10

//
// Event Object Structure Offset Definitions
//

#define EvType 0x0
#define EvSize 0x2
#define EvSignalState 0x4
#define EvWaitListHead 0x8
#define EventObjectLength 0x10

//
// Event Pair Object Structure Offset Definitions
//

#define EpType 0x0
#define EpSize 0x2
#define EpEventLow 0x4
#define EpEventHigh 0x14

//
// Interrupt Object Structure Offset Definitions
//

#define InLevelSensitive 0x0
#define InLatched 0x1

#define InType 0x0
#define InSize 0x2
#define InInterruptListEntry 0x4
#define InServiceRoutine 0xc
#define InServiceContext 0x10
#define InSpinLock 0x14
#define InActualLock 0x1c
#define InDispatchAddress 0x20
#define InVector 0x24
#define InIrql 0x28
#define InSynchronizeIrql 0x29
#define InFloatingSave 0x2a
#define InConnected 0x2b
#define InNumber 0x2c
#define InMode 0x30
#define InShareVector 0x2d
#define InDispatchCode 0x3c
#define InterruptObjectLength 0x4c

//
// Process Object Structure Offset Definitions
//

#define PrType 0x0
#define PrSize 0x2
#define PrSignalState 0x4
#define PrProfileListHead 0x10
#define PrDirectoryTableBase 0x18
#define PrActiveProcessors 0x20
#define PrRunOnProcessors 0x24
#define PrProcessSequence 0x28
#define PrProcessAsn 0x30
#define PrKernelTime 0x34
#define PrUserTime 0x38
#define PrReadyListHead 0x3c
#define PrSwapListEntry 0x44
#define PrThreadListHead 0x4c
#define PrProcessLock 0x54
#define PrAffinity 0x58
#define PrStackCount 0x5c
#define PrBasePriority 0x5e
#define PrThreadQuantum 0x5f
#define PrAutoAlignment 0x60
#define PrState 0x61
#define ProcessObjectLength 0x70
#define ExtendedProcessObjectLength 0x280

//
// Profile Object Structure Offset Definitions
//

#define PfType 0x0
#define PfSize 0x2
#define PfProfileListEntry 0x4
#define PfProcess 0xc
#define PfRangeBase 0x10
#define PfRangeLimit 0x14
#define PfBucketShift 0x18
#define PfBuffer 0x1c
#define PfSegment 0x20
#define PfAffinity 0x24
#define PfSource 0x28
#define PfStarted 0x2a
#define ProfileObjectLength 0x2c

//
// Queue Object Structure Offset Definitions
//

#define QuType 0x0
#define QuSize 0x2
#define QuSignalState 0x4
#define QuEntryListHead 0x10
#define QuCurrentCount 0x18
#define QuMaximumCount 0x1c
#define QuThreadListHead 0x20
#define QueueObjectLength 0x28

//
// Thread Object Structure Offset Definitions
//

#define EeKernelEventPair 0x0
#define EtCid 0x1e0
#define EtPerformanceCountLow 0x204
#define EtPerformanceCountHigh 0x23c
#define EtEthreadLength 0x250

#define ThType 0x0
#define ThSize 0x2
#define ThSignalState 0x4
#define ThMutantListHead 0x10
#define ThInitialStack 0x18
#define ThStackLimit 0x1c
#define ThTeb 0x20
#define ThTlsArray 0x24
#define ThKernelStack 0x28
#define ThDebugActive 0x2c
#define ThState 0x2d
#define ThAlerted 0x2e
#define ThIopl 0x30
#define ThNpxState 0x31
#define ThSaturation 0x32
#define ThPriority 0x33
#define ThApcState 0x34
#define ThContextSwitches 0x4c
#define ThWaitStatus 0x50
#define ThWaitIrql 0x54
#define ThWaitMode 0x55
#define ThWaitNext 0x56
#define ThWaitReason 0x57
#define ThWaitBlockList 0x58
#define ThWaitListEntry 0x5c
#define ThWaitTime 0x64
#define ThBasePriority 0x68
#define ThDecrementCount 0x69
#define ThPriorityDecrement 0x6a
#define ThQuantum 0x6b
#define ThWaitBlock 0x6c
#define ThKernelApcDisable 0xd0
#define ThUserAffinity 0xd4
#define ThSystemAffinityActive 0xd8
#define ThServiceTable 0xdc
#define ThQueue 0xe0
#define ThApcQueueLock 0xe4
#define ThTimer 0xe8
#define ThQueueListEntry 0x110
#define ThAffinity 0x118
#define ThPreempted 0x11c
#define ThProcessReadyQueue 0x11d
#define ThKernelStackResident 0x11e
#define ThNextProcessor 0x11f
#define ThCallbackStack 0x120
#define ThWin32Thread 0x124
#define ThTrapFrame 0x128
#define ThApcStatePointer 0x12c
#define ThPreviousMode 0x134
#define ThEnableStackSwap 0x135
#define ThLargeStack 0x136
#define ThKernelTime 0x138
#define ThUserTime 0x13c
#define ThSavedApcState 0x140
#define ThAlertable 0x158
#define ThApcStateIndex 0x159
#define ThApcQueueable 0x15a
#define ThAutoAlignment 0x15b
#define ThStackBase 0x15c
#define ThSuspendApc 0x160
#define ThSuspendSemaphore 0x190
#define ThThreadListEntry 0x1a4
#define ThFreezeCount 0x1ac
#define ThSuspendCount 0x1ad
#define ThIdealProcessor 0x1ae
#define ThDisableBoost 0x1af
#define ThreadObjectLength 0x1b0
#define ExtendedThreadObjectLength 0x250

#define EVENT_WAIT_BLOCK_OFFSET 0x9c

//
// Timer object Structure Offset Definitions
//

#define TiType 0x0
#define TiSize 0x2
#define TiInserted 0x3
#define TiSignalState 0x4
#define TiDueTime 0x10
#define TiTimerListEntry 0x18
#define TiDpc 0x20
#define TiPeriod 0x24
#define TimerObjectLength 0x28

#define TIMER_TABLE_SIZE 0x80

//
// Wait Block Structure Offset Definitions
//

#define WbWaitListEntry 0x0
#define WbThread 0x8
#define WbObject 0xc
#define WbNextWaitBlock 0x10
#define WbWaitKey 0x14
#define WbWaitType 0x16

//
// Fiber Structure Offset Definitions
//

#define FbFiberData 0x0
#define FbExceptionList 0x4
#define FbStackBase 0x8
#define FbStackLimit 0xc
#define FbDeallocationStack 0x10
#define FbFiberContext 0x18
#define FbWx86Tib 0x248

//
// Process Environment Block Structure Offset Definitions
//

#define PeKernelCallbackTable 0x2c

//
// System Service Descriptor Table Structure Definitions
//

#define NUMBER_SERVICE_TABLES 0x4
#define SERVICE_NUMBER_MASK 0xfff
#define SERVICE_TABLE_SHIFT 0x8
#define SERVICE_TABLE_MASK 0x30
#define SERVICE_TABLE_TEST 0x10

#define SdBase 0x0
#define SdCount 0x4
#define SdLimit 0x8
#define SdNumber 0xc

//
// Thread Environment Block Structure Offset Definitions
//

#define TeStackBase 0x4
#define TeStackLimit 0x8
#define TeFiberData 0x10
#define TeEnvironmentPointer 0x1c
#define TeClientId 0x20
#define TeActiveRpcHandle 0x28
#define TeThreadLocalStoragePointer 0x2c
#define TeCountOfOwnedCriticalSections 0x38
#define TePeb 0x30
#define TeCsrClientThread 0x3c
#define TeWOW32Reserved 0xc0
#define TeSoftFpcr 0xc8
#define TeGdiClientPID 0x6c0
#define TeGdiClientTID 0x6c4
#define TeGdiThreadLocalInfo 0x6c8
#define TeglDispatchTable 0x7c4
#define TeglReserved1 0xb68
#define TeglReserved2 0xbdc
#define TeglSectionInfo 0xbe0
#define TeglSection 0xbe4
#define TeglTable 0xbe8
#define TeglCurrentRC 0xbec
#define TeglContext 0xbf0
#define TeDeallocationStack 0xe0c
#define TeTlsSlots 0xe10
#define TeVdm 0xf18
#define TeGdiBatchCount 0xf70
#define TeInstrumentation 0xf2c
#define ThreadEnvironmentBlockLength 0xfa4

//
// Lock Queue Structure Offset Definitions
//

#define LOCK_QUEUE_WAIT 0x1
#define LOCK_QUEUE_OWNER 0x2
#define LOCK_QUEUE_HEADER_SIZE 0x8

#define LockQueueDispatcherLock 0x0
#define LockQueueContextSwapLock 0x1
#define LockQueuePfnLock 0x2

#define LqNext 0x0
#define LqLock 0x4

//
// Processor Control Registers Structure Offset Definitions
//

#define PCR_MINOR_VERSION 0x1
#define PCR_MAJOR_VERSION 0x1
#define PcMinorVersion 0x0
#define PcMajorVersion 0x4
#define PcPalBaseAddress 0x8
#define PcPalMajorVersion 0x10
#define PcPalMinorVersion 0x14
#define PcPalSequenceVersion 0x18
#define PcPalMajorSpecification 0x1c
#define PcPalMinorSpecification 0x20
#define PcFirmwareRestartAddress 0x28
#define PcRestartBlock 0x30
#define PcPalReserved 0x38
#define PcPalAlignmentFixupCount 0xc30
#define PcPanicStack 0xc38
#define PcProcessorType 0xc3c
#define PcProcessorRevision 0xc40
#define PcPhysicalAddressBits 0xc44
#define PcMaximumAddressSpaceNumber 0xc48
#define PcPageSize 0xc4c
#define PcFirstLevelDcacheSize 0xc50
#define PcFirstLevelDcacheFillSize 0xc54
#define PcFirstLevelIcacheSize 0xc58
#define PcFirstLevelIcacheFillSize 0xc5c
#define PcFirmwareRevisionId 0xc60
#define PcSystemType 0xc64
#define PcSystemVariant 0xc6c
#define PcSystemRevision 0xc70
#define PcSystemSerialNumber 0xc74
#define PcCycleClockPeriod 0xc84
#define PcSecondLevelCacheSize 0xc88
#define PcSecondLevelCacheFillSize 0xc8c
#define PcThirdLevelCacheSize 0xc90
#define PcThirdLevelCacheFillSize 0xc94
#define PcFourthLevelCacheSize 0xc98
#define PcFourthLevelCacheFillSize 0xc9c
#define PcPrcb 0xca0
#define PcNumber 0xca4
#define PcSetMember 0xca8
#define PcHalReserved 0xcb0
#define PcIrqlTable 0xeb0
#define PcIrqlMask 0xed0
#define PcInterruptRoutine 0x10e0
#define PcReservedVectors 0x14e0
#define PcMachineCheckError 0x14f0
#define PcDpcStack 0x14f4
#define PcNotMember 0x14e4
#define PcCurrentPid 0x14fc
#define PcSystemServiceDispatchStart 0x1504
#define PcSystemServiceDispatchEnd 0x1508
#define PcIdleThread 0x150c
#define ProcessorControlRegisterLength 0x1510
#define SharedUserData 0xff000000
#define UsTickCountLow 0x0
#define UsTickCountMultiplier 0x4
#define UsInterruptTime 0x8
#define UsSystemTime 0x10

//
// Processor Block Structure Offset Definitions
//

#define PRCB_MINOR_VERSION 0x1
#define PRCB_MAJOR_VERSION 0x2
#define PbMinorVersion 0x0
#define PbMajorVersion 0x2
#define PbCurrentThread 0x4
#define PbNextThread 0x8
#define PbIdleThread 0xc
#define PbNumber 0x10
#define PbBuildType 0x12
#define PbSetMember 0x14
#define PbRestartBlock 0x18
#define PbInterruptCount 0x1c
#define PbDpcTime 0x20
#define PbInterruptTime 0x24
#define PbKernelTime 0x28
#define PbUserTime 0x2c
#define PbQuantumEndDpc 0x30
#define PbIpiFrozen 0x5c
#define PbIpiCounts 0x2d0
#define PbProcessorState 0x60
#define PbAlignmentFixupCount 0x2f4
#define PbContextSwitches 0x2f8
#define PbDcacheFlushCount 0x2fc
#define PbExceptionDispatchCount 0x300
#define PbFirstLevelTbFills 0x304
#define PbFloatingEmulationCount 0x308
#define PbIcacheFlushCount 0x30c
#define PbSecondLevelTbFills 0x310
#define PbSystemCalls 0x314
#define PbLockQueue 0x440
#define PbCurrentPacket 0x540
#define PbTargetSet 0x54c
#define PbWorkerRoutine 0x550
#define PbRequestSummary 0x580
#define PbDpcListHead 0x628
#define PbDpcLock 0x630
#define PbDpcCount 0x634
#define PbLastDpcCount 0x290
#define PbQuantumEnd 0x638
#define PbStartCount 0x620
#define PbSoftwareInterrupts 0x298
#define PbInterruptTrapFrame 0x29c
#define PbDpcRoutineActive 0x63c
#define PbDpcQueueDepth 0x640
#define PbDpcRequestRate 0x61c
#define PbDpcBypassCount 0x294
#define PbApcBypassCount 0x2a0
#define PbDispatchInterruptCount 0x2a4
#define PbDebugDpcTime 0x2a8
#define PbDpcInterruptRequested 0x5c0
#define PbMaximumDpcQueueDepth 0x610
#define PbMinimumDpcRate 0x614
#define PbAdjustDpcThreshold 0x618
#define PbPowerState 0x648
#define ProcessorBlockLength 0x6d0

//
// Processor Power State Offset Definitions
//

#define PpIdleFunction 0x0

//
// Immediate Interprocessor Command Definitions
//

#define IPI_APC 0x1
#define IPI_DPC 0x2
#define IPI_FREEZE 0x4
#define IPI_PACKET_READY 0x8

//
// Interprocessor Interrupt Count Structure Offset Definitions
//

#define IcFreeze 0x0
#define IcPacket 0x4
#define IcDPC 0x8
#define IcAPC 0xc
#define IcFlushSingleTb 0x10
#define IcFlushEntireTb 0x18
#define IcChangeColor 0x20
#define IcSweepDcache 0x24
#define IcSweepIcache 0x28
#define IcSweepIcacheRange 0x2c
#define IcFlushIoBuffers 0x30

//
// LPC Structure Offset Definitions
//

#define PmLength 0x0
#define PmClientId 0x8
#define PmProcess 0x8
#define PmThread 0xc
#define PmMessageId 0x10
#define PmClientViewSize 0x14
#define PortMessageLength 0x18

//
// Client Id Structure Offset Definitions
//

#define CidUniqueProcess 0x0
#define CidUniqueThread 0x4

//
// Context Frame Offset and Flag Definitions
//

#define CONTEXT_FULL 0x20007
#define CONTEXT_CONTROL 0x20001
#define CONTEXT_FLOATING_POINT 0x20002
#define CONTEXT_INTEGER 0x20004

#define CxFltF0 0x0
#define CxFltF1 0x8
#define CxFltF2 0x10
#define CxFltF3 0x18
#define CxFltF4 0x20
#define CxFltF5 0x28
#define CxFltF6 0x30
#define CxFltF7 0x38
#define CxFltF8 0x40
#define CxFltF9 0x48
#define CxFltF10 0x50
#define CxFltF11 0x58
#define CxFltF12 0x60
#define CxFltF13 0x68
#define CxFltF14 0x70
#define CxFltF15 0x78
#define CxFltF16 0x80
#define CxFltF17 0x88
#define CxFltF18 0x90
#define CxFltF19 0x98
#define CxFltF20 0xa0
#define CxFltF21 0xa8
#define CxFltF22 0xb0
#define CxFltF23 0xb8
#define CxFltF24 0xc0
#define CxFltF25 0xc8
#define CxFltF26 0xd0
#define CxFltF27 0xd8
#define CxFltF28 0xe0
#define CxFltF29 0xe8
#define CxFltF30 0xf0
#define CxFltF31 0xf8
#define CxIntV0 0x100
#define CxIntT0 0x108
#define CxIntT1 0x110
#define CxIntT2 0x118
#define CxIntT3 0x120
#define CxIntT4 0x128
#define CxIntT5 0x130
#define CxIntT6 0x138
#define CxIntT7 0x140
#define CxIntS0 0x148
#define CxIntS1 0x150
#define CxIntS2 0x158
#define CxIntS3 0x160
#define CxIntS4 0x168
#define CxIntS5 0x170
#define CxIntFp 0x178
#define CxIntA0 0x180
#define CxIntA1 0x188
#define CxIntA2 0x190
#define CxIntA3 0x198
#define CxIntA4 0x1a0
#define CxIntA5 0x1a8
#define CxIntT8 0x1b0
#define CxIntT9 0x1b8
#define CxIntT10 0x1c0
#define CxIntT11 0x1c8
#define CxIntRa 0x1d0
#define CxIntT12 0x1d8
#define CxIntAt 0x1e0
#define CxIntGp 0x1e8
#define CxIntSp 0x1f0
#define CxIntZero 0x1f8
#define CxFpcr 0x200
#define CxSoftFpcr 0x208
#define CxFir 0x210
#define CxPsr 0x218
#define CxContextFlags 0x21c
#define ContextFrameLength 0x230

//
// Exception Frame Offset Definitions and Length
//

#define ExFltF2 0x8
#define ExFltF3 0x10
#define ExFltF4 0x18
#define ExFltF5 0x20
#define ExFltF6 0x28
#define ExFltF7 0x30
#define ExFltF8 0x38
#define ExFltF9 0x40
#define ExIntS0 0x48
#define ExIntS1 0x50
#define ExIntS2 0x58
#define ExIntS3 0x60
#define ExIntS4 0x68
#define ExIntS5 0x70
#define ExIntFp 0x78
#define ExPsr 0x88
#define ExSwapReturn 0x80
#define ExIntRa 0x0
#define ExceptionFrameLength 0xa0

//
// Jump Offset Definitions and Length
//

#define JbFp 0x0
#define JbPc 0x4
#define JbSeb 0x8
#define JbType 0xc
#define JbFltF2 0x10
#define JbFltF3 0x18
#define JbFltF4 0x20
#define JbFltF5 0x28
#define JbFltF6 0x30
#define JbFltF7 0x38
#define JbFltF8 0x40
#define JbFltF9 0x48
#define JbIntS0 0x50
#define JbIntS1 0x58
#define JbIntS2 0x60
#define JbIntS3 0x68
#define JbIntS4 0x70
#define JbIntS5 0x78
#define JbIntS6 0x80
#define JbIntSp 0x88
#define JbFir 0x90

//
// Trap Frame Offset Definitions and Length
//

#define TrFltF0 0x128
#define TrFltF1 0x138
#define TrFltF10 0x140
#define TrFltF11 0x148
#define TrFltF12 0x150
#define TrFltF13 0x158
#define TrFltF14 0x160
#define TrFltF15 0x168
#define TrFltF16 0x170
#define TrFltF17 0x178
#define TrFltF18 0x180
#define TrFltF19 0x188
#define TrFltF20 0x190
#define TrFltF21 0x198
#define TrFltF22 0x1a0
#define TrFltF23 0x1a8
#define TrFltF24 0x1b0
#define TrFltF25 0x1b8
#define TrFltF26 0x1c0
#define TrFltF27 0x1c8
#define TrFltF28 0x1d0
#define TrFltF29 0x1d8
#define TrFltF30 0x1e0
#define TrIntV0 0xa0
#define TrIntT0 0xa8
#define TrIntT1 0xb0
#define TrIntT2 0xb8
#define TrIntT3 0xc0
#define TrIntT4 0xc8
#define TrIntT5 0xd0
#define TrIntT6 0xd8
#define TrIntT7 0xe0
#define TrIntFp 0x18
#define TrIntA0 0x20
#define TrIntA1 0x28
#define TrIntA2 0x30
#define TrIntA3 0x38
#define TrIntA4 0x118
#define TrIntA5 0x120
#define TrIntT8 0xe8
#define TrIntT9 0xf0
#define TrIntT10 0xf8
#define TrIntT11 0x100
#define TrIntT12 0x108
#define TrIntAt 0x110
#define TrIntGp 0x48
#define TrIntSp 0x0
#define TrFpcr 0x130
#define TrPsr 0x10
#define TrFir 0x8
#define TrExceptionRecord 0x50
#define TrOldIrql 0x1e8
#define TrPreviousMode 0x1ec
#define TrIntRa 0x40
#define TrTrapFrame 0x1f0
#define TrapFrameLength 0x200

//
// Firmware frame offset defintions and length
//

#define FW_EXC_MCHK 0xdec0
#define FW_EXC_ARITH 0xdec1
#define FW_EXC_INTERRUPT 0xdec2
#define FW_EXC_DFAULT 0xdec3
#define FW_EXC_ITBMISS 0xdec4
#define FW_EXC_ITBACV 0xdec5
#define FW_EXC_NDTBMISS 0xdec6
#define FW_EXC_PDTBMISS 0xdec7
#define FW_EXC_UNALIGNED 0xdec8
#define FW_EXC_OPCDEC 0xdec9
#define FW_EXC_FEN 0xdeca
#define FW_EXC_HALT 0xdecb
#define FW_EXC_BPT 0xdecc
#define FW_EXC_GENTRAP 0xdecd
#define FW_EXC_HALT_INTERRUPT 0xdece
#define FwType 0x0
#define FwParam1 0x8
#define FwParam2 0x10
#define FwParam3 0x18
#define FwParam4 0x20
#define FwParam5 0x28
#define FwPsr 0x30
#define FwMmcsr 0x38
#define FwVa 0x40
#define FwFir 0x48
#define FwIntV0 0x50
#define FwIntT0 0x58
#define FwIntT1 0x60
#define FwIntT2 0x68
#define FwIntT3 0x70
#define FwIntT4 0x78
#define FwIntT5 0x80
#define FwIntT6 0x88
#define FwIntT7 0x90
#define FwIntS0 0x98
#define FwIntS1 0xa0
#define FwIntS2 0xa8
#define FwIntS3 0xb0
#define FwIntS4 0xb8
#define FwIntS5 0xc0
#define FwIntFp 0xc8
#define FwIntA0 0xd0
#define FwIntA1 0xd8
#define FwIntA2 0xe0
#define FwIntA3 0xe8
#define FwIntA4 0xf0
#define FwIntA5 0xf8
#define FwIntT8 0x100
#define FwIntT9 0x108
#define FwIntT10 0x110
#define FwIntT11 0x118
#define FwIntRa 0x120
#define FwIntT12 0x128
#define FwIntAt 0x130
#define FwIntGp 0x138
#define FwIntSp 0x140
#define FwIntZero 0x148
#define FwFltF0 0x150
#define FwFltF1 0x158
#define FwFltF2 0x160
#define FwFltF3 0x168
#define FwFltF4 0x170
#define FwFltF5 0x178
#define FwFltF6 0x180
#define FwFltF7 0x188
#define FwFltF8 0x190
#define FwFltF9 0x198
#define FwFltF10 0x1a0
#define FwFltF11 0x1a8
#define FwFltF12 0x1b0
#define FwFltF13 0x1b8
#define FwFltF14 0x1c0
#define FwFltF15 0x1c8
#define FwFltF16 0x1d0
#define FwFltF17 0x1d8
#define FwFltF18 0x1e0
#define FwFltF19 0x1e8
#define FwFltF20 0x1f0
#define FwFltF21 0x1f8
#define FwFltF22 0x200
#define FwFltF23 0x208
#define FwFltF24 0x210
#define FwFltF25 0x218
#define FwFltF26 0x220
#define FwFltF27 0x228
#define FwFltF28 0x230
#define FwFltF29 0x238
#define FwFltF30 0x240
#define FwFltF31 0x248
#define FirmwareFrameLength 0x250

//
// Usermode callout frame definitions
//

#define CuF2 0x0
#define CuF3 0x8
#define CuF4 0x10
#define CuF5 0x18
#define CuF6 0x20
#define CuF7 0x28
#define CuF8 0x30
#define CuF9 0x38
#define CuS0 0x40
#define CuS1 0x48
#define CuS2 0x50
#define CuS3 0x58
#define CuS4 0x60
#define CuS5 0x68
#define CuFP 0x70
#define CuCbStk 0x78
#define CuInStk 0x80
#define CuTrFr 0x88
#define CuTrFir 0x90
#define CuRa 0x98
#define CuA0 0xa0
#define CuA1 0xa8
#define CuFrameLength 0xb0

//
// Usermode callout user frame definitions
//

#define CkBuffer 0x0
#define CkLength 0x4
#define CkApiNumber 0x8
#define CkSp 0x10
#define CkRa 0x18

//
// KFLOATING_SAVE definitions
//

#define KfsFpcr 0x0
#define KfsSoftFpcr 0x8
#define KfsReserved1 0x10
#define KfsReserved2 0x14
#define KfsReserved3 0x18
#define KfsReserved4 0x1c

//
// Loader Parameter Block Offset Definitions
//

#define LpbLoadOrderListHead 0x0
#define LpbMemoryDescriptorListHead 0x8
#define LpbKernelStack 0x18
#define LpbPrcb 0x1c
#define LpbProcess 0x20
#define LpbThread 0x24
#define LpbRegistryLength 0x28
#define LpbRegistryBase 0x2c
#define LpbDpcStack 0x60
#define LpbFirstLevelDcacheSize 0x64
#define LpbFirstLevelDcacheFillSize 0x68
#define LpbFirstLevelIcacheSize 0x6c
#define LpbFirstLevelIcacheFillSize 0x70
#define LpbGpBase 0x74
#define LpbPanicStack 0x78
#define LpbPcrPage 0x7c
#define LpbPdrPage 0x80
#define LpbSecondLevelDcacheSize 0x84
#define LpbSecondLevelDcacheFillSize 0x88
#define LpbSecondLevelIcacheSize 0x8c
#define LpbSecondLevelIcacheFillSize 0x90
#define LpbPhysicalAddressBits 0x94
#define LpbMaximumAddressSpaceNumber 0x98
#define LpbSystemSerialNumber 0x9c
#define LpbSystemType 0xac
#define LpbSystemVariant 0xb4
#define LpbSystemRevision 0xb8
#define LpbProcessorType 0xbc
#define LpbProcessorRevision 0xc0
#define LpbCycleClockPeriod 0xc4
#define LpbPageSize 0xc8
#define LpbRestartBlock 0xcc
#define LpbFirmwareRestartAddress 0xd0
#define LpbFirmwareRevisionId 0xd8
#define LpbPalBaseAddress 0xdc

//
// Restart Block Structure Definitions
//

#define RbSignature 0x0
#define RbLength 0x4
#define RbVersion 0x8
#define RbRevision 0xa
#define RbNextRestartBlock 0xc
#define RbRestartAddress 0x10
#define RbBootMasterId 0x14
#define RbProcessorId 0x18
#define RbBootStatus 0x1c
#define RbCheckSum 0x20
#define RbSaveAreaLength 0x24
#define RbSaveArea 0x28
#define RbHaltReason 0x28
#define RbLogoutFrame 0x2c
#define RbPalBase 0x30
#define RbIntV0 0x38
#define RbIntT0 0x40
#define RbIntT1 0x48
#define RbIntT2 0x50
#define RbIntT3 0x58
#define RbIntT4 0x60
#define RbIntT5 0x68
#define RbIntT6 0x70
#define RbIntT7 0x78
#define RbIntS0 0x80
#define RbIntS1 0x88
#define RbIntS2 0x90
#define RbIntS3 0x98
#define RbIntS4 0xa0
#define RbIntS5 0xa8
#define RbIntFp 0xb0
#define RbIntA0 0xb8
#define RbIntA1 0xc0
#define RbIntA2 0xc8
#define RbIntA3 0xd0
#define RbIntA4 0xd8
#define RbIntA5 0xe0
#define RbIntT8 0xe8
#define RbIntT9 0xf0
#define RbIntT10 0xf8
#define RbIntT11 0x100
#define RbIntRa 0x108
#define RbIntT12 0x110
#define RbIntAT 0x118
#define RbIntGp 0x120
#define RbIntSp 0x128
#define RbIntZero 0x130
#define RbFpcr 0x138
#define RbFltF0 0x140
#define RbFltF1 0x148
#define RbFltF2 0x150
#define RbFltF3 0x158
#define RbFltF4 0x160
#define RbFltF5 0x168
#define RbFltF6 0x170
#define RbFltF7 0x178
#define RbFltF8 0x180
#define RbFltF9 0x188
#define RbFltF10 0x190
#define RbFltF11 0x198
#define RbFltF12 0x1a0
#define RbFltF13 0x1a8
#define RbFltF14 0x1b0
#define RbFltF15 0x1b8
#define RbFltF16 0x1c0
#define RbFltF17 0x1c8
#define RbFltF18 0x1d0
#define RbFltF19 0x1d8
#define RbFltF20 0x1e0
#define RbFltF21 0x1e8
#define RbFltF22 0x1f0
#define RbFltF23 0x1f8
#define RbFltF24 0x200
#define RbFltF25 0x208
#define RbFltF26 0x210
#define RbFltF27 0x218
#define RbFltF28 0x220
#define RbFltF29 0x228
#define RbFltF30 0x230
#define RbFltF31 0x238
#define RbAsn 0x240
#define RbGeneralEntry 0x244
#define RbIksp 0x248
#define RbInterruptEntry 0x24c
#define RbKgp 0x250
#define RbMces 0x254
#define RbMemMgmtEntry 0x258
#define RbPanicEntry 0x25c
#define RbPcr 0x260
#define RbPdr 0x264
#define RbPsr 0x268
#define RbReiRestartAddress 0x26c
#define RbSirr 0x270
#define RbSyscallEntry 0x274
#define RbTeb 0x278
#define RbThread 0x27c
#define RbPerProcessorState 0x280

//
// Address Space Layout Definitions
//

#define KSEG0_BASE 0x80000000
#define KSEG2_BASE 0xc0000000
#define SYSTEM_BASE 0xc0800000
#define PDE_BASE 0xc0180000
#define PTE_BASE 0xc0000000
#define PDE64_BASE 0xc0184000
#define PTE64_BASE 0xc2000000

//
// Page Table and Directory Entry Definitions
//

#define PAGE_SIZE 0x2000
#define PAGE_SHIFT 0xd
#define PDI_SHIFT 0x18
#define PTI_SHIFT 0xd

//
// Breakpoint Definitions
//

#define USER_BREAKPOINT 0x0
#define KERNEL_BREAKPOINT 0x1
#define BREAKIN_BREAKPOINT 0x19
#define DEBUG_PRINT_BREAKPOINT 0x14
#define DEBUG_PROMPT_BREAKPOINT 0x15
#define DEBUG_STOP_BREAKPOINT 0x16
#define DEBUG_LOAD_SYMBOLS_BREAKPOINT 0x17
#define DEBUG_UNLOAD_SYMBOLS_BREAKPOINT 0x18

//
// Trap Code Definitions
//

#define GENTRAP_INTEGER_OVERFLOW 0xffffffff
#define GENTRAP_INTEGER_DIVIDE_BY_ZERO 0xfffffffe
#define GENTRAP_FLOATING_OVERFLOW 0xfffffffd
#define GENTRAP_FLOATING_DIVIDE_BY_ZERO 0xfffffffc
#define GENTRAP_FLOATING_UNDERFLOW 0xfffffffb
#define GENTRAP_FLOATING_INVALID_OPERAND 0xfffffffa
#define GENTRAP_FLOATING_INEXACT_RESULT 0xfffffff9

//
// Miscellaneous Definitions
//

#define Executive 0x0
#define KernelMode 0x0
#define FALSE 0x0
#define TRUE 0x1
#define BASE_PRIORITY_THRESHOLD 0x8
#define EVENT_PAIR_INCREMENT 0x1
#define LOW_REALTIME_PRIORITY 0x10
#define MM_USER_PROBE_ADDRESS 0x7fff0000
#define KERNEL_STACK_SIZE 0x4000
#define KERNEL_LARGE_STACK_COMMIT 0x4000
#define SET_LOW_WAIT_HIGH 0xfffffffe
#define SET_HIGH_WAIT_LOW 0xffffffff
#define CLOCK_QUANTUM_DECREMENT 0x3
#define READY_SKIP_QUANTUM 0x2
#define THREAD_QUANTUM 0x6
#define WAIT_QUANTUM_DECREMENT 0x1
#define ROUND_TRIP_DECREMENT_COUNT 0x10
#define PROCESSOR_ALPHA_21064 0x5248
#define PROCESSOR_ALPHA_21164 0x52ac
#define PROCESSOR_ALPHA_21066 0x524a
#define PROCESSOR_ALPHA_21068 0x524c
#define PROCESSOR_ALPHA_21164PC 0x52ad
#define PROCESSOR_ALPHA_21264 0x5310
#define PTE_VALID_MASK 0x1
#define PTE_VALID 0x0
#define PTE_GLOBAL_MASK 0x10
#define PTE_GLOBAL 0x4
#define PTE_GH_MASK 0x60
#define PTE_GH 0x5
#define PTE_WRITE_MASK 0x80
#define PTE_WRITE 0x7
#define PTE_COPY_ON_WRITE_MASK 0x100
#define PTE_COPY_ON_WRITE 0x8
#define PTE_PFN_MASK 0xfffffe00
#define PTE_PFN 0x9
#define PTE_OWNER_MASK 0x2
#define PTE_OWNER 0x1
#define PTE_DIRTY_MASK 0x4
#define PTE_DIRTY 0x2
#define PSR_MODE_MASK 0x1
#define PSR_MODE 0x0
#define PSR_USER_MODE 0x1
#define PSR_IE_MASK 0x2
#define PSR_IE 0x1
#define PSR_IRQL_MASK 0x1c
#define PSR_IRQL 0x2
#define IE_SFW_MASK 0x3
#define IE_SFW 0x0
#define IE_HDW_MASK 0xfc
#define IE_HDW 0x2
#define MCHK_CORRECTABLE_MASK 0x1
#define MCHK_CORRECTABLE 0x0
#define MCHK_RETRYABLE_MASK 0x2
#define MCHK_RETRYABLE 0x1
#define MCES_MCK_MASK 0x1
#define MCES_MCK 0x0
#define MCES_SCE_MASK 0x2
#define MCES_SCE 0x1
#define MCES_PCE_MASK 0x4
#define MCES_PCE 0x2
#define MCES_DPC_MASK 0x8
#define MCES_DPC 0x3
#define MCES_DSC_MASK 0x10
#define MCES_DSC 0x4
#define MCES_DMCK_MASK 0x20
#define MCES_DMCK 0x5
#define EXCSUM_SWC_MASK 0x1
#define EXCSUM_SWC 0x0
#define EXCSUM_INV_MASK 0x2
#define EXCSUM_INV 0x1
#define EXCSUM_DZE_MASK 0x4
#define EXCSUM_DZE 0x2
#define EXCSUM_OVF_MASK 0x8
#define EXCSUM_OVF 0x3
#define EXCSUM_UNF_MASK 0x10
#define EXCSUM_UNF 0x4
#define EXCSUM_INE_MASK 0x20
#define EXCSUM_INE 0x5
#define EXCSUM_IOV_MASK 0x40
#define EXCSUM_IOV 0x6

//
// Call PAL Mnemonics
//

// begin callpal

#define bpt 0x80
#define callsys 0x83
#define imb 0x86
#define gentrap 0xaa
#define rdteb 0xab
#define kbpt 0xac
#define callkd 0xad
#define halt 0x0
#define restart 0x1
#define draina 0x2
#define reboot 0x3
#define initpal 0x4
#define wrentry 0x5
#define swpirql 0x6
#define rdirql 0x7
#define di 0x8
#define ei 0x9
#define swppal 0xa
#define ssir 0xc
#define csir 0xd
#define rfe 0xe
#define retsys 0xf
#define swpctx 0x10
#define swpprocess 0x11
#define rdmces 0x12
#define wrmces 0x13
#define tbia 0x14
#define tbis 0x15
#define tbisasn 0x17
#define dtbis 0x16
#define rdksp 0x18
#define swpksp 0x19
#define rdpsr 0x1a
#define rdpcr 0x1c
#define rdthread 0x1e
#define tbim 0x20
#define tbimasn 0x21
#define tbim64 0x22
#define tbis64 0x23
#define ealnfix 0x24
#define dalnfix 0x25
#define rdcounters 0x30
#define rdstate 0x31
#define wrperfmon 0x32
#define cp_sleep 0x39
#define initpcr 0x38

// end callpal


//
// Bios Argument Structure Definitions
//

#define BaEax 0x0
#define BaEbx 0x4
#define BaEcx 0x8
#define BaEdx 0xc
#define BaEsi 0x10
#define BaEdi 0x14
#define BaEbp 0x18
#define BiosArgumentLength 0x1c

//
// Define Vendor Callback Read/Write Error Frame Operation Types
//

#define ReadFrame 0x1
#define WriteFrame 0x2

//
// Define Vendor Callback Vector Base Address
//

#define SYSTEM_VECTOR_BASE 0x806fe028

//
// Define Vendor Callback Offsets
//

#define VnCallBiosRoutine 0x38
#define VnReadWriteErrorFrameRoutine 0x98
#define VnVideoDisplayInitializeRoutine 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\listing.inc ===
;; LISTING.INC
;;
;; This file contains assembler macros and is included by the files created
;; with the -FA compiler switch to be assembled by MASM (Microsoft Macro
;; Assembler).
;;
;; Copyright (c) 1993, Microsoft Corporation. All rights reserved.

;; non destructive nops
npad macro size
if size eq 1
  nop
else
 if size eq 2
   mov edi, edi
 else
  if size eq 3
    ; lea ecx, [ecx+00]
    DB 8DH, 49H, 00H
  else
   if size eq 4
     ; lea esp, [esp+00]
     DB 8DH, 64H, 24H, 00H
   else
    if size eq 5
      add eax, DWORD PTR 0
    else
     if size eq 6
       ; lea ebx, [ebx+00000000]
       DB 8DH, 9BH, 00H, 00H, 00H, 00H
     else
      if size eq 7
	; lea esp, [esp+00000000]
	DB 8DH, 0A4H, 24H, 00H, 00H, 00H, 00H 
      else
	%out error: unsupported npad size
	.err
      endif
     endif
    endif
   endif
  endif
 endif
endif
endm

;; destructive nops
dpad macro size, reg
if size eq 1
  inc reg
else
  %out error: unsupported dpad size
  .err
endif
endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ksuuids.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// contains the GUIDs for the MediaType type, subtype fields and format types
// for DVD/MPEG2 media types.


//
// --- MPEG 2 definitions ---
//

// 36523B13-8EE5-11d1-8CA3-0060B057664A
OUR_GUID_ENTRY(MEDIATYPE_MPEG2_PACK,
0x36523B13, 0x8EE5, 0x11d1, 0x8C, 0xA3, 0x00, 0x60, 0xB0, 0x57, 0x66, 0x4A)

// e06d8020-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIATYPE_MPEG2_PES,
0xe06d8020, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)


#if 0
DEFINE_GUID(MEDIATYPE_CONTROL,
0xe06d8021, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
#endif // #if 0


// e06d8026-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_VIDEO,
0xe06d8026, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)

// use MPEG2VIDEOINFO (defined below) with FORMAT_MPEG2_VIDEO
// e06d80e3-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2_VIDEO,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA       (FORMAT_VideoInfo2)
OUR_GUID_ENTRY(FORMAT_VIDEOINFO2,
0xf72a76A0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba)

// MPEG2 Other subtypes
// e06d8022-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_PROGRAM,
0xe06d8022, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8023-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_TRANSPORT,
0xe06d8023, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802b-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_AUDIO,
0xe06d802b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802c-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DOLBY_AC3,
0xe06d802c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802d-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_SUBPICTURE,
0xe06d802d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8032-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_LPCM_AUDIO,
0xe06d8032, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8033-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DTS,
0xe06d8033, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8034-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_SDDS,
0xe06d8034, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// DVD-related mediatypes
// ED0B916A-044D-11d1-AA78-00C04FC31D60
OUR_GUID_ENTRY(MEDIATYPE_DVD_ENCRYPTED_PACK,
0xed0b916a, 0x044d, 0x11d1, 0xaa, 0x78, 0x00, 0xc0, 0x04f, 0xc3, 0x1d, 0x60)

// e06d802e-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIATYPE_DVD_NAVIGATION,
0xe06d802e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802f-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PCI,
0xe06d802f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8030-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_DSI,
0xe06d8030, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8031-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER,
0xe06d8031, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

//
// DVD - MPEG2/AC3-related Formats
//
// e06d80e3-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2Video,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e4-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_DolbyAC3,
0xe06d80e4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e5-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2Audio,
0xe06d80e5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e6-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_DVD_LPCMAudio,
0xe06d80e6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)


//
// KS Property Set Id (to communicate with the WDM Proxy filter) -- from
// ksmedia.h of WDM DDK.
//

// BFABE720-6E1F-11D0-BCF2-444553540000
OUR_GUID_ENTRY(AM_KSPROPSETID_AC3,
0xBFABE720, 0x6E1F, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00)

// ac390460-43af-11d0-bd6a-003505c103a9
OUR_GUID_ENTRY(AM_KSPROPSETID_DvdSubPic,
0xac390460, 0x43af, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9)

// 0E8A0A40L-6AEF-11D0-9ED0-00A024CA19B3
OUR_GUID_ENTRY(AM_KSPROPSETID_CopyProt,
0x0E8A0A40, 0x6AEF, 0x11D0, 0x9E, 0xD0, 0x00, 0xA0, 0x24, 0xCA, 0x19, 0xB3)

// A503C5C0-1D1D-11d1-AD80-444553540000
OUR_GUID_ENTRY(AM_KSPROPSETID_TSRateChange,
0xa503c5c0, 0x1d1d, 0x11d1, 0xad, 0x80, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0)

// 3577EB09-9582-477f-B29C-B0C452A4FF9A
OUR_GUID_ENTRY(AM_KSPROPSETID_DVD_RateChange,
0x3577eb09, 0x9582, 0x477f, 0xb2, 0x9c, 0xb0, 0xc4, 0x52, 0xa4, 0xff, 0x9a)

// ae4720ae-aa71-42d8-b82a-fffdf58b76fd
OUR_GUID_ENTRY(AM_KSPROPSETID_DvdKaraoke,
0xae4720ae, 0xaa71, 0x42d8, 0xb8, 0x2a, 0xff, 0xfd, 0xf5, 0x8b, 0x76, 0xfd)

// c830acbd-ab07-492f-8852-45b6987c2979
OUR_GUID_ENTRY(AM_KSPROPSETID_FrameStep,
0xc830acbd, 0xab07, 0x492f, 0x88, 0x52, 0x45, 0xb6, 0x98, 0x7c, 0x29, 0x79)

//
// KS categories from ks.h and ksmedia.h
//
//

// 65E8773D-8F56-11D0-A3B9-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_CAPTURE,
0x65E8773DL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 65E8773E-8F56-11D0-A3B9-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_RENDER,
0x65E8773EL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 1E84C900-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_KSCATEGORY_DATACOMPRESSOR,
0x1E84C900L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// 6994AD04-93EF-11D0-A3CC-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_AUDIO,
0x6994AD04L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 6994AD05-93EF-11D0-A3CC-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_VIDEO,
0x6994AD05L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// a799a800-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_TVTUNER,
0xa799a800L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)

// a799a801-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_CROSSBAR,
0xa799a801L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)

// a799a802-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_TVAUDIO,
0xa799a802L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)


// 07dad660L-22f1-11d1-a9f4-00c04fbbde8f
OUR_GUID_ENTRY(AM_KSCATEGORY_VBICODEC,
0x07dad660L, 0x22f1, 0x11d1, 0xa9, 0xf4, 0x00, 0xc0, 0x4f, 0xbb, 0xde, 0x8f)


// 0A4252A0L-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_KSCATEGORY_SPLITTER,
0x0A4252A0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)


//
// guids needed to support IKsPin interface
//

// d3abc7e0l-9a61-11d0-a40d00a0c9223196
OUR_GUID_ENTRY(IID_IKsInterfaceHandler,
0xD3ABC7E0L, 0x9A61, 0x11D0, 0xA4, 0x0D, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 5ffbaa02l-49a3-11d0-9f3600aa00a216a1
OUR_GUID_ENTRY(IID_IKsDataTypeHandler,
0x5FFBAA02L, 0x49A3, 0x11D0, 0x9F, 0x36, 0x00, 0xAA, 0x00, 0xA2, 0x16, 0xA1)

// b61178d1-a2d9-11cf-9e53-00aa00a216a1
OUR_GUID_ENTRY(IID_IKsPin,
0xb61178d1L, 0xa2d9, 0x11cf, 0x9e, 0x53, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1)

// 28F54685-06FD-11D2-B27A-00A0C9223196
OUR_GUID_ENTRY(IID_IKsControl,
0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// CD5EBE6B-8B6E-11D1-8AE0-00A0C9223196
OUR_GUID_ENTRY(IID_IKsPinFactory,
0xCD5EBE6BL, 0x8B6E, 0x11D1, 0x8A, 0xE0, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 1A8766A0-62CE-11CF-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_INTERFACESETID_Standard,
0x1A8766A0L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lm.h

Abstract:

    This is the top level include file that includes all the files
    necessary for writing Lan Manager Application.

[Environment:]

    User Mode - Win32

--*/

#ifndef _LM_
#define _LM_

#if _MSC_VER > 1000
#pragma once
#endif

#include <lmcons.h>     // LAN Manager common definitions
#include <lmerr.h>      // LAN Manager network error definitions

#include <lmaccess.h>   // Access, Domain, Group and User classes
#include <lmalert.h>    // Alerter
#include <lmshare.h>    // Connection, File, Session and Share classes
#include <lmmsg.h>      // Message class
#include <lmremutl.h>   // Remote Utility class
#include <lmrepl.h>     // Replicator class
#include <lmserver.h>   // Server class
#include <lmsvc.h>      // Service class
#include <lmuse.h>      // Use class
#include <lmwksta.h>    // Workstation class
#include <lmapibuf.h>   // NetApiBuffer class
#include <lmerrlog.h>   // NetErrorLog class
#include <lmconfig.h>   // NetConfig class
#include <lmstats.h>    // NetStats class
#include <lmaudit.h>    // NetAudit class
#include <lmjoin.h>     // NetJoinDomain class

#endif // _LM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\LAdmin2.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Wed Apr 22 20:01:24 1998
 */
/* Compiler settings for ladmin2.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ladmin2_h__
#define __ladmin2_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __Ildapcfg_FWD_DEFINED__
#define __Ildapcfg_FWD_DEFINED__
typedef interface Ildapcfg Ildapcfg;
#endif 	/* __Ildapcfg_FWD_DEFINED__ */


#ifndef __ldapcfg_FWD_DEFINED__
#define __ldapcfg_FWD_DEFINED__

#ifdef __cplusplus
typedef class ldapcfg ldapcfg;
#else
typedef struct ldapcfg ldapcfg;
#endif /* __cplusplus */

#endif 	/* __ldapcfg_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __Ildapcfg_INTERFACE_DEFINED__
#define __Ildapcfg_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Ildapcfg
 * at Wed Apr 22 20:01:24 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Ildapcfg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("40E9AD63-E2A1-11D0-920F-00C04FB954C7")
    Ildapcfg : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AttachToRemoteMachine( 
            /* [in] */ VARIANT szMachineName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AttachToLocalMachine( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LoadConfig( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SaveConfig( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateConfig( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteConfig( 
            /* [in] */ VARIANT lInstanceId) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Port( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Port( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SecurePort( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_SecurePort( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IP( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_IP( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedIPs( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DNSName( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DNSName( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ReadOnlyMode( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ReadOnlyMode( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EnableAllSub( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_EnableAllSub( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MaxPageSize( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MaxPageSize( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MaxResultSet( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MaxResultSet( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MaxQueryTime( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MaxQueryTime( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MaxConnection( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MaxConnection( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionTimeout( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectionTimeout( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EnableShortTermIPBlacklisting( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_EnableShortTermIPBlacklisting( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EnableShortTermAccountBlacklisting( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_EnableShortTermAccountBlacklisting( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Authorization( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Authorization( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EnableSSL( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_EnableSSL( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EnableSSL128( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_EnableSSL128( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EnableDynamic( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_EnableDynamic( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MinTTL( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MinTTL( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MaxDynamObj( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MaxDynamObj( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EnableRTPerson( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_EnableRTPerson( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EnableReplicate( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_EnableReplicate( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EnableLog( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_EnableLog( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DBType( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DBType( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DBSource( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DBSource( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DBName( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DBName( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DBUsername( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DBUsername( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DBPassword( 
            /* [retval][out] */ VARIANT __RPC_FAR *pData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DBPassword( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetServerState( 
            /* [in] */ VARIANT Instance,
            /* [out] */ VARIANT __RPC_FAR *lState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StartServer( 
            /* [in] */ VARIANT lInstanceId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StopServer( 
            /* [in] */ VARIANT lInstanceId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PauseServer( 
            /* [in] */ VARIANT lInstanceId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ContinueServer( 
            /* [in] */ VARIANT lInstanceId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompactDatabase( 
            /* [in] */ VARIANT lInstanceId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RepairDatabase( 
            /* [in] */ VARIANT lInstanceId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDynamicReplicationList( 
            /* [in] */ VARIANT lInstanceId,
            /* [out] */ VARIANT __RPC_FAR *rgszReplNames,
            /* [out] */ VARIANT __RPC_FAR *rgszReplIDs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDirectoryProperties( 
            /* [in] */ VARIANT lInstanceId,
            /* [out] */ VARIANT __RPC_FAR *szRealm,
            /* [out] */ VARIANT __RPC_FAR *szDnPrefix,
            /* [out] */ VARIANT __RPC_FAR *fIsSQL,
            /* [out] */ VARIANT __RPC_FAR *fExtSec,
            /* [out] */ VARIANT __RPC_FAR *rgszContainerPartitions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDirectoryProperties( 
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szRealm,
            /* [in] */ VARIANT szDnPrefix) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubPartitions( 
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szContainer,
            /* [out] */ VARIANT __RPC_FAR *rgdwSubPartitionNumber) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPartitionDbInfo( 
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szContainerPartition,
            /* [in] */ VARIANT lSubPartitionNumber,
            /* [out] */ VARIANT __RPC_FAR *rgdwServerId,
            /* [out] */ VARIANT __RPC_FAR *rgszServerName,
            /* [out] */ VARIANT __RPC_FAR *rgszDatabaseName,
            /* [out] */ VARIANT __RPC_FAR *rgszLogin,
            /* [out] */ VARIANT __RPC_FAR *rgszPassword,
            /* [out] */ VARIANT __RPC_FAR *rgdwMaxCnx,
            /* [out] */ VARIANT __RPC_FAR *rgdwTimeout,
            /* [out] */ VARIANT __RPC_FAR *rgdwReplicationType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPartitionDbServer( 
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szContainerPartition,
            /* [in] */ VARIANT lSubPartitionNumber,
            /* [in] */ VARIANT dwServerId,
            /* [out] */ VARIANT __RPC_FAR *szServerName,
            /* [out] */ VARIANT __RPC_FAR *szDatabaseName,
            /* [out] */ VARIANT __RPC_FAR *szLogin,
            /* [out] */ VARIANT __RPC_FAR *szPassword,
            /* [out] */ VARIANT __RPC_FAR *dwMaxCnx,
            /* [out] */ VARIANT __RPC_FAR *dwTimeout,
            /* [out] */ VARIANT __RPC_FAR *dwReplicationType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPartitionDbServer( 
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szContainerPartition,
            /* [in] */ VARIANT lSubPartitionNumber,
            /* [out] */ VARIANT __RPC_FAR *dwServerId,
            /* [in] */ VARIANT szServerName,
            /* [in] */ VARIANT szDatabaseName,
            /* [in] */ VARIANT szLogin,
            /* [in] */ VARIANT szPassword,
            /* [in] */ VARIANT dwMaxCnx,
            /* [in] */ VARIANT dwTimeout,
            /* [in] */ VARIANT dwReplicationType,
            /* [in] */ VARIANT lSubrefPartitionID,
            /* [in] */ VARIANT lSubrefObjectID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EditPartitionDbServer( 
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szContainerPartition,
            /* [in] */ VARIANT lSubPartitionNumber,
            /* [in] */ VARIANT dwServerId,
            /* [in] */ VARIANT szServerName,
            /* [in] */ VARIANT szDatabaseName,
            /* [in] */ VARIANT szLogin,
            /* [in] */ VARIANT szPassword,
            /* [in] */ VARIANT dwMaxCnx,
            /* [in] */ VARIANT dwTimeout,
            /* [in] */ VARIANT dwReplicationType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePartitionDbServer( 
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szContainerPartition,
            /* [in] */ VARIANT lSubPartitionNumber,
            /* [in] */ VARIANT dwServerId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateDSPartition( 
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szDn,
            /* [in] */ VARIANT lCount,
            /* [out] */ VARIANT __RPC_FAR *plPartitionID,
            /* [out] */ VARIANT __RPC_FAR *plObjectID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ListAllReplica( 
            /* [out] */ VARIANT __RPC_FAR *rgServerId,
            /* [out] */ VARIANT __RPC_FAR *rgszServerName,
            /* [out] */ VARIANT __RPC_FAR *rgszRpcGuid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddReplica( 
            /* [in] */ long lServerId,
            /* [in] */ BSTR szServerName,
            /* [in] */ BSTR szRpcGuid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DelReplica( 
            /* [in] */ long lServerId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ConfigLocalReplica( 
            /* [in] */ long lNewServerId,
            /* [out] */ VARIANT __RPC_FAR *szRpcGuid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryLocalReplica( 
            /* [out] */ VARIANT __RPC_FAR *lServerId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsAddrInUse( 
            /* [in] */ long lIP,
            /* [in] */ long lPort) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IldapcfgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Ildapcfg __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Ildapcfg __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Ildapcfg __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachToRemoteMachine )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT szMachineName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachToLocalMachine )( 
            Ildapcfg __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadConfig )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveConfig )( 
            Ildapcfg __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateConfig )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteConfig )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Port )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Port )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SecurePort )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SecurePort )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IP )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IP )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SupportedIPs )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DNSName )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DNSName )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReadOnlyMode )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ReadOnlyMode )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableAllSub )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableAllSub )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxPageSize )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxPageSize )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxResultSet )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxResultSet )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxQueryTime )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxQueryTime )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxConnection )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxConnection )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectionTimeout )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectionTimeout )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableShortTermIPBlacklisting )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableShortTermIPBlacklisting )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableShortTermAccountBlacklisting )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableShortTermAccountBlacklisting )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Authorization )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Authorization )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableSSL )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableSSL )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableSSL128 )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableSSL128 )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableDynamic )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableDynamic )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MinTTL )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MinTTL )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxDynamObj )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxDynamObj )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableRTPerson )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableRTPerson )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableReplicate )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableReplicate )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableLog )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableLog )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DBType )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DBType )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DBSource )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DBSource )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DBName )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DBName )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DBUsername )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DBUsername )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DBPassword )( 
            Ildapcfg __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DBPassword )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerState )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT Instance,
            /* [out] */ VARIANT __RPC_FAR *lState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartServer )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopServer )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PauseServer )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ContinueServer )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompactDatabase )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RepairDatabase )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDynamicReplicationList )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId,
            /* [out] */ VARIANT __RPC_FAR *rgszReplNames,
            /* [out] */ VARIANT __RPC_FAR *rgszReplIDs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDirectoryProperties )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId,
            /* [out] */ VARIANT __RPC_FAR *szRealm,
            /* [out] */ VARIANT __RPC_FAR *szDnPrefix,
            /* [out] */ VARIANT __RPC_FAR *fIsSQL,
            /* [out] */ VARIANT __RPC_FAR *fExtSec,
            /* [out] */ VARIANT __RPC_FAR *rgszContainerPartitions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDirectoryProperties )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szRealm,
            /* [in] */ VARIANT szDnPrefix);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubPartitions )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szContainer,
            /* [out] */ VARIANT __RPC_FAR *rgdwSubPartitionNumber);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPartitionDbInfo )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szContainerPartition,
            /* [in] */ VARIANT lSubPartitionNumber,
            /* [out] */ VARIANT __RPC_FAR *rgdwServerId,
            /* [out] */ VARIANT __RPC_FAR *rgszServerName,
            /* [out] */ VARIANT __RPC_FAR *rgszDatabaseName,
            /* [out] */ VARIANT __RPC_FAR *rgszLogin,
            /* [out] */ VARIANT __RPC_FAR *rgszPassword,
            /* [out] */ VARIANT __RPC_FAR *rgdwMaxCnx,
            /* [out] */ VARIANT __RPC_FAR *rgdwTimeout,
            /* [out] */ VARIANT __RPC_FAR *rgdwReplicationType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPartitionDbServer )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szContainerPartition,
            /* [in] */ VARIANT lSubPartitionNumber,
            /* [in] */ VARIANT dwServerId,
            /* [out] */ VARIANT __RPC_FAR *szServerName,
            /* [out] */ VARIANT __RPC_FAR *szDatabaseName,
            /* [out] */ VARIANT __RPC_FAR *szLogin,
            /* [out] */ VARIANT __RPC_FAR *szPassword,
            /* [out] */ VARIANT __RPC_FAR *dwMaxCnx,
            /* [out] */ VARIANT __RPC_FAR *dwTimeout,
            /* [out] */ VARIANT __RPC_FAR *dwReplicationType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPartitionDbServer )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szContainerPartition,
            /* [in] */ VARIANT lSubPartitionNumber,
            /* [out] */ VARIANT __RPC_FAR *dwServerId,
            /* [in] */ VARIANT szServerName,
            /* [in] */ VARIANT szDatabaseName,
            /* [in] */ VARIANT szLogin,
            /* [in] */ VARIANT szPassword,
            /* [in] */ VARIANT dwMaxCnx,
            /* [in] */ VARIANT dwTimeout,
            /* [in] */ VARIANT dwReplicationType,
            /* [in] */ VARIANT lSubrefPartitionID,
            /* [in] */ VARIANT lSubrefObjectID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EditPartitionDbServer )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szContainerPartition,
            /* [in] */ VARIANT lSubPartitionNumber,
            /* [in] */ VARIANT dwServerId,
            /* [in] */ VARIANT szServerName,
            /* [in] */ VARIANT szDatabaseName,
            /* [in] */ VARIANT szLogin,
            /* [in] */ VARIANT szPassword,
            /* [in] */ VARIANT dwMaxCnx,
            /* [in] */ VARIANT dwTimeout,
            /* [in] */ VARIANT dwReplicationType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemovePartitionDbServer )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szContainerPartition,
            /* [in] */ VARIANT lSubPartitionNumber,
            /* [in] */ VARIANT dwServerId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateDSPartition )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ VARIANT lInstanceId,
            /* [in] */ VARIANT szDn,
            /* [in] */ VARIANT lCount,
            /* [out] */ VARIANT __RPC_FAR *plPartitionID,
            /* [out] */ VARIANT __RPC_FAR *plObjectID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ListAllReplica )( 
            Ildapcfg __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *rgServerId,
            /* [out] */ VARIANT __RPC_FAR *rgszServerName,
            /* [out] */ VARIANT __RPC_FAR *rgszRpcGuid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddReplica )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ long lServerId,
            /* [in] */ BSTR szServerName,
            /* [in] */ BSTR szRpcGuid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DelReplica )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ long lServerId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigLocalReplica )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ long lNewServerId,
            /* [out] */ VARIANT __RPC_FAR *szRpcGuid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryLocalReplica )( 
            Ildapcfg __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *lServerId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsAddrInUse )( 
            Ildapcfg __RPC_FAR * This,
            /* [in] */ long lIP,
            /* [in] */ long lPort);
        
        END_INTERFACE
    } IldapcfgVtbl;

    interface Ildapcfg
    {
        CONST_VTBL struct IldapcfgVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Ildapcfg_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Ildapcfg_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Ildapcfg_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Ildapcfg_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Ildapcfg_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Ildapcfg_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Ildapcfg_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Ildapcfg_AttachToRemoteMachine(This,szMachineName)	\
    (This)->lpVtbl -> AttachToRemoteMachine(This,szMachineName)

#define Ildapcfg_AttachToLocalMachine(This)	\
    (This)->lpVtbl -> AttachToLocalMachine(This)

#define Ildapcfg_LoadConfig(This,Data)	\
    (This)->lpVtbl -> LoadConfig(This,Data)

#define Ildapcfg_SaveConfig(This)	\
    (This)->lpVtbl -> SaveConfig(This)

#define Ildapcfg_CreateConfig(This,Data)	\
    (This)->lpVtbl -> CreateConfig(This,Data)

#define Ildapcfg_DeleteConfig(This,lInstanceId)	\
    (This)->lpVtbl -> DeleteConfig(This,lInstanceId)

#define Ildapcfg_get_Port(This,pData)	\
    (This)->lpVtbl -> get_Port(This,pData)

#define Ildapcfg_put_Port(This,Data)	\
    (This)->lpVtbl -> put_Port(This,Data)

#define Ildapcfg_get_SecurePort(This,pData)	\
    (This)->lpVtbl -> get_SecurePort(This,pData)

#define Ildapcfg_put_SecurePort(This,Data)	\
    (This)->lpVtbl -> put_SecurePort(This,Data)

#define Ildapcfg_get_IP(This,pData)	\
    (This)->lpVtbl -> get_IP(This,pData)

#define Ildapcfg_put_IP(This,Data)	\
    (This)->lpVtbl -> put_IP(This,Data)

#define Ildapcfg_get_SupportedIPs(This,pData)	\
    (This)->lpVtbl -> get_SupportedIPs(This,pData)

#define Ildapcfg_get_DNSName(This,pData)	\
    (This)->lpVtbl -> get_DNSName(This,pData)

#define Ildapcfg_put_DNSName(This,Data)	\
    (This)->lpVtbl -> put_DNSName(This,Data)

#define Ildapcfg_get_ReadOnlyMode(This,pData)	\
    (This)->lpVtbl -> get_ReadOnlyMode(This,pData)

#define Ildapcfg_put_ReadOnlyMode(This,Data)	\
    (This)->lpVtbl -> put_ReadOnlyMode(This,Data)

#define Ildapcfg_get_EnableAllSub(This,pData)	\
    (This)->lpVtbl -> get_EnableAllSub(This,pData)

#define Ildapcfg_put_EnableAllSub(This,Data)	\
    (This)->lpVtbl -> put_EnableAllSub(This,Data)

#define Ildapcfg_get_MaxPageSize(This,pData)	\
    (This)->lpVtbl -> get_MaxPageSize(This,pData)

#define Ildapcfg_put_MaxPageSize(This,Data)	\
    (This)->lpVtbl -> put_MaxPageSize(This,Data)

#define Ildapcfg_get_MaxResultSet(This,pData)	\
    (This)->lpVtbl -> get_MaxResultSet(This,pData)

#define Ildapcfg_put_MaxResultSet(This,Data)	\
    (This)->lpVtbl -> put_MaxResultSet(This,Data)

#define Ildapcfg_get_MaxQueryTime(This,pData)	\
    (This)->lpVtbl -> get_MaxQueryTime(This,pData)

#define Ildapcfg_put_MaxQueryTime(This,Data)	\
    (This)->lpVtbl -> put_MaxQueryTime(This,Data)

#define Ildapcfg_get_MaxConnection(This,pData)	\
    (This)->lpVtbl -> get_MaxConnection(This,pData)

#define Ildapcfg_put_MaxConnection(This,Data)	\
    (This)->lpVtbl -> put_MaxConnection(This,Data)

#define Ildapcfg_get_ConnectionTimeout(This,pData)	\
    (This)->lpVtbl -> get_ConnectionTimeout(This,pData)

#define Ildapcfg_put_ConnectionTimeout(This,Data)	\
    (This)->lpVtbl -> put_ConnectionTimeout(This,Data)

#define Ildapcfg_get_EnableShortTermIPBlacklisting(This,pData)	\
    (This)->lpVtbl -> get_EnableShortTermIPBlacklisting(This,pData)

#define Ildapcfg_put_EnableShortTermIPBlacklisting(This,Data)	\
    (This)->lpVtbl -> put_EnableShortTermIPBlacklisting(This,Data)

#define Ildapcfg_get_EnableShortTermAccountBlacklisting(This,pData)	\
    (This)->lpVtbl -> get_EnableShortTermAccountBlacklisting(This,pData)

#define Ildapcfg_put_EnableShortTermAccountBlacklisting(This,Data)	\
    (This)->lpVtbl -> put_EnableShortTermAccountBlacklisting(This,Data)

#define Ildapcfg_get_Authorization(This,pData)	\
    (This)->lpVtbl -> get_Authorization(This,pData)

#define Ildapcfg_put_Authorization(This,Data)	\
    (This)->lpVtbl -> put_Authorization(This,Data)

#define Ildapcfg_get_EnableSSL(This,pData)	\
    (This)->lpVtbl -> get_EnableSSL(This,pData)

#define Ildapcfg_put_EnableSSL(This,Data)	\
    (This)->lpVtbl -> put_EnableSSL(This,Data)

#define Ildapcfg_get_EnableSSL128(This,pData)	\
    (This)->lpVtbl -> get_EnableSSL128(This,pData)

#define Ildapcfg_put_EnableSSL128(This,Data)	\
    (This)->lpVtbl -> put_EnableSSL128(This,Data)

#define Ildapcfg_get_EnableDynamic(This,pData)	\
    (This)->lpVtbl -> get_EnableDynamic(This,pData)

#define Ildapcfg_put_EnableDynamic(This,Data)	\
    (This)->lpVtbl -> put_EnableDynamic(This,Data)

#define Ildapcfg_get_MinTTL(This,pData)	\
    (This)->lpVtbl -> get_MinTTL(This,pData)

#define Ildapcfg_put_MinTTL(This,Data)	\
    (This)->lpVtbl -> put_MinTTL(This,Data)

#define Ildapcfg_get_MaxDynamObj(This,pData)	\
    (This)->lpVtbl -> get_MaxDynamObj(This,pData)

#define Ildapcfg_put_MaxDynamObj(This,Data)	\
    (This)->lpVtbl -> put_MaxDynamObj(This,Data)

#define Ildapcfg_get_EnableRTPerson(This,pData)	\
    (This)->lpVtbl -> get_EnableRTPerson(This,pData)

#define Ildapcfg_put_EnableRTPerson(This,Data)	\
    (This)->lpVtbl -> put_EnableRTPerson(This,Data)

#define Ildapcfg_get_EnableReplicate(This,pData)	\
    (This)->lpVtbl -> get_EnableReplicate(This,pData)

#define Ildapcfg_put_EnableReplicate(This,Data)	\
    (This)->lpVtbl -> put_EnableReplicate(This,Data)

#define Ildapcfg_get_EnableLog(This,pData)	\
    (This)->lpVtbl -> get_EnableLog(This,pData)

#define Ildapcfg_put_EnableLog(This,Data)	\
    (This)->lpVtbl -> put_EnableLog(This,Data)

#define Ildapcfg_get_DBType(This,pData)	\
    (This)->lpVtbl -> get_DBType(This,pData)

#define Ildapcfg_put_DBType(This,Data)	\
    (This)->lpVtbl -> put_DBType(This,Data)

#define Ildapcfg_get_DBSource(This,pData)	\
    (This)->lpVtbl -> get_DBSource(This,pData)

#define Ildapcfg_put_DBSource(This,Data)	\
    (This)->lpVtbl -> put_DBSource(This,Data)

#define Ildapcfg_get_DBName(This,pData)	\
    (This)->lpVtbl -> get_DBName(This,pData)

#define Ildapcfg_put_DBName(This,Data)	\
    (This)->lpVtbl -> put_DBName(This,Data)

#define Ildapcfg_get_DBUsername(This,pData)	\
    (This)->lpVtbl -> get_DBUsername(This,pData)

#define Ildapcfg_put_DBUsername(This,Data)	\
    (This)->lpVtbl -> put_DBUsername(This,Data)

#define Ildapcfg_get_DBPassword(This,pData)	\
    (This)->lpVtbl -> get_DBPassword(This,pData)

#define Ildapcfg_put_DBPassword(This,Data)	\
    (This)->lpVtbl -> put_DBPassword(This,Data)

#define Ildapcfg_GetServerState(This,Instance,lState)	\
    (This)->lpVtbl -> GetServerState(This,Instance,lState)

#define Ildapcfg_StartServer(This,lInstanceId)	\
    (This)->lpVtbl -> StartServer(This,lInstanceId)

#define Ildapcfg_StopServer(This,lInstanceId)	\
    (This)->lpVtbl -> StopServer(This,lInstanceId)

#define Ildapcfg_PauseServer(This,lInstanceId)	\
    (This)->lpVtbl -> PauseServer(This,lInstanceId)

#define Ildapcfg_ContinueServer(This,lInstanceId)	\
    (This)->lpVtbl -> ContinueServer(This,lInstanceId)

#define Ildapcfg_CompactDatabase(This,lInstanceId)	\
    (This)->lpVtbl -> CompactDatabase(This,lInstanceId)

#define Ildapcfg_RepairDatabase(This,lInstanceId)	\
    (This)->lpVtbl -> RepairDatabase(This,lInstanceId)

#define Ildapcfg_GetDynamicReplicationList(This,lInstanceId,rgszReplNames,rgszReplIDs)	\
    (This)->lpVtbl -> GetDynamicReplicationList(This,lInstanceId,rgszReplNames,rgszReplIDs)

#define Ildapcfg_GetDirectoryProperties(This,lInstanceId,szRealm,szDnPrefix,fIsSQL,fExtSec,rgszContainerPartitions)	\
    (This)->lpVtbl -> GetDirectoryProperties(This,lInstanceId,szRealm,szDnPrefix,fIsSQL,fExtSec,rgszContainerPartitions)

#define Ildapcfg_SetDirectoryProperties(This,lInstanceId,szRealm,szDnPrefix)	\
    (This)->lpVtbl -> SetDirectoryProperties(This,lInstanceId,szRealm,szDnPrefix)

#define Ildapcfg_GetSubPartitions(This,lInstanceId,szContainer,rgdwSubPartitionNumber)	\
    (This)->lpVtbl -> GetSubPartitions(This,lInstanceId,szContainer,rgdwSubPartitionNumber)

#define Ildapcfg_GetPartitionDbInfo(This,lInstanceId,szContainerPartition,lSubPartitionNumber,rgdwServerId,rgszServerName,rgszDatabaseName,rgszLogin,rgszPassword,rgdwMaxCnx,rgdwTimeout,rgdwReplicationType)	\
    (This)->lpVtbl -> GetPartitionDbInfo(This,lInstanceId,szContainerPartition,lSubPartitionNumber,rgdwServerId,rgszServerName,rgszDatabaseName,rgszLogin,rgszPassword,rgdwMaxCnx,rgdwTimeout,rgdwReplicationType)

#define Ildapcfg_GetPartitionDbServer(This,lInstanceId,szContainerPartition,lSubPartitionNumber,dwServerId,szServerName,szDatabaseName,szLogin,szPassword,dwMaxCnx,dwTimeout,dwReplicationType)	\
    (This)->lpVtbl -> GetPartitionDbServer(This,lInstanceId,szContainerPartition,lSubPartitionNumber,dwServerId,szServerName,szDatabaseName,szLogin,szPassword,dwMaxCnx,dwTimeout,dwReplicationType)

#define Ildapcfg_AddPartitionDbServer(This,lInstanceId,szContainerPartition,lSubPartitionNumber,dwServerId,szServerName,szDatabaseName,szLogin,szPassword,dwMaxCnx,dwTimeout,dwReplicationType,lSubrefPartitionID,lSubrefObjectID)	\
    (This)->lpVtbl -> AddPartitionDbServer(This,lInstanceId,szContainerPartition,lSubPartitionNumber,dwServerId,szServerName,szDatabaseName,szLogin,szPassword,dwMaxCnx,dwTimeout,dwReplicationType,lSubrefPartitionID,lSubrefObjectID)

#define Ildapcfg_EditPartitionDbServer(This,lInstanceId,szContainerPartition,lSubPartitionNumber,dwServerId,szServerName,szDatabaseName,szLogin,szPassword,dwMaxCnx,dwTimeout,dwReplicationType)	\
    (This)->lpVtbl -> EditPartitionDbServer(This,lInstanceId,szContainerPartition,lSubPartitionNumber,dwServerId,szServerName,szDatabaseName,szLogin,szPassword,dwMaxCnx,dwTimeout,dwReplicationType)

#define Ildapcfg_RemovePartitionDbServer(This,lInstanceId,szContainerPartition,lSubPartitionNumber,dwServerId)	\
    (This)->lpVtbl -> RemovePartitionDbServer(This,lInstanceId,szContainerPartition,lSubPartitionNumber,dwServerId)

#define Ildapcfg_CreateDSPartition(This,lInstanceId,szDn,lCount,plPartitionID,plObjectID)	\
    (This)->lpVtbl -> CreateDSPartition(This,lInstanceId,szDn,lCount,plPartitionID,plObjectID)

#define Ildapcfg_ListAllReplica(This,rgServerId,rgszServerName,rgszRpcGuid)	\
    (This)->lpVtbl -> ListAllReplica(This,rgServerId,rgszServerName,rgszRpcGuid)

#define Ildapcfg_AddReplica(This,lServerId,szServerName,szRpcGuid)	\
    (This)->lpVtbl -> AddReplica(This,lServerId,szServerName,szRpcGuid)

#define Ildapcfg_DelReplica(This,lServerId)	\
    (This)->lpVtbl -> DelReplica(This,lServerId)

#define Ildapcfg_ConfigLocalReplica(This,lNewServerId,szRpcGuid)	\
    (This)->lpVtbl -> ConfigLocalReplica(This,lNewServerId,szRpcGuid)

#define Ildapcfg_QueryLocalReplica(This,lServerId)	\
    (This)->lpVtbl -> QueryLocalReplica(This,lServerId)

#define Ildapcfg_IsAddrInUse(This,lIP,lPort)	\
    (This)->lpVtbl -> IsAddrInUse(This,lIP,lPort)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_AttachToRemoteMachine_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT szMachineName);


void __RPC_STUB Ildapcfg_AttachToRemoteMachine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_AttachToLocalMachine_Proxy( 
    Ildapcfg __RPC_FAR * This);


void __RPC_STUB Ildapcfg_AttachToLocalMachine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_LoadConfig_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_LoadConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_SaveConfig_Proxy( 
    Ildapcfg __RPC_FAR * This);


void __RPC_STUB Ildapcfg_SaveConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_CreateConfig_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_CreateConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_DeleteConfig_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId);


void __RPC_STUB Ildapcfg_DeleteConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_Port_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_Port_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_Port_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_Port_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_SecurePort_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_SecurePort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_SecurePort_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_SecurePort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_IP_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_IP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_IP_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_IP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_SupportedIPs_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_SupportedIPs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_DNSName_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_DNSName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_DNSName_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_DNSName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_ReadOnlyMode_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_ReadOnlyMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_ReadOnlyMode_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_ReadOnlyMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_EnableAllSub_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_EnableAllSub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_EnableAllSub_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_EnableAllSub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_MaxPageSize_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_MaxPageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_MaxPageSize_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_MaxPageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_MaxResultSet_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_MaxResultSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_MaxResultSet_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_MaxResultSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_MaxQueryTime_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_MaxQueryTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_MaxQueryTime_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_MaxQueryTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_MaxConnection_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_MaxConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_MaxConnection_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_MaxConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_ConnectionTimeout_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_ConnectionTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_ConnectionTimeout_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_ConnectionTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_EnableShortTermIPBlacklisting_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_EnableShortTermIPBlacklisting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_EnableShortTermIPBlacklisting_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_EnableShortTermIPBlacklisting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_EnableShortTermAccountBlacklisting_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_EnableShortTermAccountBlacklisting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_EnableShortTermAccountBlacklisting_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_EnableShortTermAccountBlacklisting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_Authorization_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_Authorization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_Authorization_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_Authorization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_EnableSSL_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_EnableSSL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_EnableSSL_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_EnableSSL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_EnableSSL128_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_EnableSSL128_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_EnableSSL128_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_EnableSSL128_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_EnableDynamic_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_EnableDynamic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_EnableDynamic_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_EnableDynamic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_MinTTL_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_MinTTL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_MinTTL_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_MinTTL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_MaxDynamObj_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_MaxDynamObj_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_MaxDynamObj_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_MaxDynamObj_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_EnableRTPerson_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_EnableRTPerson_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_EnableRTPerson_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_EnableRTPerson_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_EnableReplicate_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_EnableReplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_EnableReplicate_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_EnableReplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_EnableLog_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_EnableLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_EnableLog_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_EnableLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_DBType_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_DBType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_DBType_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_DBType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_DBSource_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_DBSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_DBSource_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_DBSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_DBName_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_DBName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_DBName_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_DBName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_DBUsername_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_DBUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_DBUsername_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_DBUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Ildapcfg_get_DBPassword_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pData);


void __RPC_STUB Ildapcfg_get_DBPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE Ildapcfg_put_DBPassword_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Data);


void __RPC_STUB Ildapcfg_put_DBPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_GetServerState_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT Instance,
    /* [out] */ VARIANT __RPC_FAR *lState);


void __RPC_STUB Ildapcfg_GetServerState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_StartServer_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId);


void __RPC_STUB Ildapcfg_StartServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_StopServer_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId);


void __RPC_STUB Ildapcfg_StopServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_PauseServer_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId);


void __RPC_STUB Ildapcfg_PauseServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_ContinueServer_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId);


void __RPC_STUB Ildapcfg_ContinueServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_CompactDatabase_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId);


void __RPC_STUB Ildapcfg_CompactDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_RepairDatabase_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId);


void __RPC_STUB Ildapcfg_RepairDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_GetDynamicReplicationList_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId,
    /* [out] */ VARIANT __RPC_FAR *rgszReplNames,
    /* [out] */ VARIANT __RPC_FAR *rgszReplIDs);


void __RPC_STUB Ildapcfg_GetDynamicReplicationList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_GetDirectoryProperties_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId,
    /* [out] */ VARIANT __RPC_FAR *szRealm,
    /* [out] */ VARIANT __RPC_FAR *szDnPrefix,
    /* [out] */ VARIANT __RPC_FAR *fIsSQL,
    /* [out] */ VARIANT __RPC_FAR *fExtSec,
    /* [out] */ VARIANT __RPC_FAR *rgszContainerPartitions);


void __RPC_STUB Ildapcfg_GetDirectoryProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_SetDirectoryProperties_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId,
    /* [in] */ VARIANT szRealm,
    /* [in] */ VARIANT szDnPrefix);


void __RPC_STUB Ildapcfg_SetDirectoryProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_GetSubPartitions_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId,
    /* [in] */ VARIANT szContainer,
    /* [out] */ VARIANT __RPC_FAR *rgdwSubPartitionNumber);


void __RPC_STUB Ildapcfg_GetSubPartitions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_GetPartitionDbInfo_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId,
    /* [in] */ VARIANT szContainerPartition,
    /* [in] */ VARIANT lSubPartitionNumber,
    /* [out] */ VARIANT __RPC_FAR *rgdwServerId,
    /* [out] */ VARIANT __RPC_FAR *rgszServerName,
    /* [out] */ VARIANT __RPC_FAR *rgszDatabaseName,
    /* [out] */ VARIANT __RPC_FAR *rgszLogin,
    /* [out] */ VARIANT __RPC_FAR *rgszPassword,
    /* [out] */ VARIANT __RPC_FAR *rgdwMaxCnx,
    /* [out] */ VARIANT __RPC_FAR *rgdwTimeout,
    /* [out] */ VARIANT __RPC_FAR *rgdwReplicationType);


void __RPC_STUB Ildapcfg_GetPartitionDbInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_GetPartitionDbServer_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId,
    /* [in] */ VARIANT szContainerPartition,
    /* [in] */ VARIANT lSubPartitionNumber,
    /* [in] */ VARIANT dwServerId,
    /* [out] */ VARIANT __RPC_FAR *szServerName,
    /* [out] */ VARIANT __RPC_FAR *szDatabaseName,
    /* [out] */ VARIANT __RPC_FAR *szLogin,
    /* [out] */ VARIANT __RPC_FAR *szPassword,
    /* [out] */ VARIANT __RPC_FAR *dwMaxCnx,
    /* [out] */ VARIANT __RPC_FAR *dwTimeout,
    /* [out] */ VARIANT __RPC_FAR *dwReplicationType);


void __RPC_STUB Ildapcfg_GetPartitionDbServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_AddPartitionDbServer_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId,
    /* [in] */ VARIANT szContainerPartition,
    /* [in] */ VARIANT lSubPartitionNumber,
    /* [out] */ VARIANT __RPC_FAR *dwServerId,
    /* [in] */ VARIANT szServerName,
    /* [in] */ VARIANT szDatabaseName,
    /* [in] */ VARIANT szLogin,
    /* [in] */ VARIANT szPassword,
    /* [in] */ VARIANT dwMaxCnx,
    /* [in] */ VARIANT dwTimeout,
    /* [in] */ VARIANT dwReplicationType,
    /* [in] */ VARIANT lSubrefPartitionID,
    /* [in] */ VARIANT lSubrefObjectID);


void __RPC_STUB Ildapcfg_AddPartitionDbServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_EditPartitionDbServer_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId,
    /* [in] */ VARIANT szContainerPartition,
    /* [in] */ VARIANT lSubPartitionNumber,
    /* [in] */ VARIANT dwServerId,
    /* [in] */ VARIANT szServerName,
    /* [in] */ VARIANT szDatabaseName,
    /* [in] */ VARIANT szLogin,
    /* [in] */ VARIANT szPassword,
    /* [in] */ VARIANT dwMaxCnx,
    /* [in] */ VARIANT dwTimeout,
    /* [in] */ VARIANT dwReplicationType);


void __RPC_STUB Ildapcfg_EditPartitionDbServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_RemovePartitionDbServer_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId,
    /* [in] */ VARIANT szContainerPartition,
    /* [in] */ VARIANT lSubPartitionNumber,
    /* [in] */ VARIANT dwServerId);


void __RPC_STUB Ildapcfg_RemovePartitionDbServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_CreateDSPartition_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ VARIANT lInstanceId,
    /* [in] */ VARIANT szDn,
    /* [in] */ VARIANT lCount,
    /* [out] */ VARIANT __RPC_FAR *plPartitionID,
    /* [out] */ VARIANT __RPC_FAR *plObjectID);


void __RPC_STUB Ildapcfg_CreateDSPartition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_ListAllReplica_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [out] */ VARIANT __RPC_FAR *rgServerId,
    /* [out] */ VARIANT __RPC_FAR *rgszServerName,
    /* [out] */ VARIANT __RPC_FAR *rgszRpcGuid);


void __RPC_STUB Ildapcfg_ListAllReplica_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_AddReplica_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ long lServerId,
    /* [in] */ BSTR szServerName,
    /* [in] */ BSTR szRpcGuid);


void __RPC_STUB Ildapcfg_AddReplica_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_DelReplica_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ long lServerId);


void __RPC_STUB Ildapcfg_DelReplica_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_ConfigLocalReplica_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ long lNewServerId,
    /* [out] */ VARIANT __RPC_FAR *szRpcGuid);


void __RPC_STUB Ildapcfg_ConfigLocalReplica_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_QueryLocalReplica_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [out] */ VARIANT __RPC_FAR *lServerId);


void __RPC_STUB Ildapcfg_QueryLocalReplica_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Ildapcfg_IsAddrInUse_Proxy( 
    Ildapcfg __RPC_FAR * This,
    /* [in] */ long lIP,
    /* [in] */ long lPort);


void __RPC_STUB Ildapcfg_IsAddrInUse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Ildapcfg_INTERFACE_DEFINED__ */



#ifndef __LADMIN2Lib_LIBRARY_DEFINED__
#define __LADMIN2Lib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: LADMIN2Lib
 * at Wed Apr 22 20:01:24 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_LADMIN2Lib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ldapcfg;

class DECLSPEC_UUID("40E9AD64-E2A1-11D0-920F-00C04FB954C7")
ldapcfg;
#endif
#endif /* __LADMIN2Lib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmalert.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    alert.h

Abstract:

    This file contains structures for communication with the Alerter
    service.

Environment:

    User Mode - Win32

Notes:

    You must include LmCons.H before this file, since this file depends
    on values defined in LmCons.H.

    ALERT.H includes ALERTMSG.H which defines the alert message numbers


--*/


#ifndef _ALERT_
#define _ALERT_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetAlertRaise(
    IN LPCWSTR AlertEventName,
    IN LPVOID  Buffer,
    IN DWORD   BufferSize
    );

NET_API_STATUS NET_API_FUNCTION
NetAlertRaiseEx(
    IN LPCWSTR AlertEventName,
    IN LPVOID  VariableInfo,
    IN DWORD   VariableInfoSize,
    IN LPCWSTR ServiceName
    );


//
//  Data Structures
//

typedef struct _STD_ALERT {
    DWORD  alrt_timestamp;
    WCHAR  alrt_eventname[EVLEN + 1];
    WCHAR  alrt_servicename[SNLEN + 1];
}STD_ALERT, *PSTD_ALERT, *LPSTD_ALERT;

typedef struct _ADMIN_OTHER_INFO {
    DWORD  alrtad_errcode;
    DWORD  alrtad_numstrings;
}ADMIN_OTHER_INFO, *PADMIN_OTHER_INFO, *LPADMIN_OTHER_INFO;

typedef struct _ERRLOG_OTHER_INFO {
    DWORD  alrter_errcode;
    DWORD  alrter_offset;
}ERRLOG_OTHER_INFO, *PERRLOG_OTHER_INFO, *LPERRLOG_OTHER_INFO;

typedef struct _PRINT_OTHER_INFO {
    DWORD  alrtpr_jobid;
    DWORD  alrtpr_status;
    DWORD  alrtpr_submitted;
    DWORD  alrtpr_size;
}PRINT_OTHER_INFO, *PPRINT_OTHER_INFO, *LPPRINT_OTHER_INFO;

typedef struct _USER_OTHER_INFO {
    DWORD  alrtus_errcode;
    DWORD  alrtus_numstrings;
}USER_OTHER_INFO, *PUSER_OTHER_INFO, *LPUSER_OTHER_INFO;

//
// Special Values and Constants
//

//
// Name of mailslot to send alert notifications
//
#define ALERTER_MAILSLOT          L"\\\\.\\MAILSLOT\\Alerter"

//
// The following macro gives a pointer to the other_info data.
// It takes an alert structure and returns a pointer to structure
// beyond the standard portion.
//

#define ALERT_OTHER_INFO(x)    ((LPBYTE)(x) + sizeof(STD_ALERT))

//
// The following macro gives a pointer to the variable-length data.
// It takes a pointer to one of the other-info structs and returns a
// pointer to the variable data portion.
//

#define ALERT_VAR_DATA(p)      ((LPBYTE)(p) + sizeof(*p))

//
//      Names of standard Microsoft-defined alert events.
//

#define ALERT_PRINT_EVENT           L"PRINTING"
#define ALERT_MESSAGE_EVENT         L"MESSAGE"
#define ALERT_ERRORLOG_EVENT        L"ERRORLOG"
#define ALERT_ADMIN_EVENT           L"ADMIN"
#define ALERT_USER_EVENT            L"USER"

//
//      Bitmap masks for prjob_status field of PRINTJOB.
//

// 2-7 bits also used in device status

#define PRJOB_QSTATUS       0x3         // Bits 0,1
#define PRJOB_DEVSTATUS     0x1fc       // 2-8 bits
#define PRJOB_COMPLETE      0x4         // Bit 2
#define PRJOB_INTERV        0x8         // Bit 3
#define PRJOB_ERROR         0x10        // Bit 4
#define PRJOB_DESTOFFLINE   0x20        // Bit 5
#define PRJOB_DESTPAUSED    0x40        // Bit 6
#define PRJOB_NOTIFY        0x80        // BIT 7
#define PRJOB_DESTNOPAPER   0x100       // BIT 8
#define PRJOB_DELETED       0x8000      // BIT 15

//
//      Values of PRJOB_QSTATUS bits in prjob_status field of PRINTJOB.
//

#define PRJOB_QS_QUEUED                 0
#define PRJOB_QS_PAUSED                 1
#define PRJOB_QS_SPOOLING               2
#define PRJOB_QS_PRINTING               3


#ifdef __cplusplus
}
#endif

#endif // _ALERT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmat.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    lmat.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the schedule service API-s.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

--*/

#ifndef _LMAT_
#define _LMAT_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
//  The following bits are used with Flags field in structures below.
//

//
//  Do we exec programs for this job periodically (/EVERY switch)
//  or one time (/NEXT switch).
//
#define JOB_RUN_PERIODICALLY            0x01    //  set if EVERY


//
//  Was there an error last time we tried to exec a program on behalf of
//  this job.
//  This flag is meaningfull on output only!
//
#define JOB_EXEC_ERROR                  0x02    //  set if error

//
//  Will this job run today or tomorrow.
//  This flag is meaningfull on output only!
//
#define JOB_RUNS_TODAY                  0x04    //  set if today

//
//  Add current day of the month to DaysOfMonth input.
//  This flag is meaningfull on input only!
//
#define JOB_ADD_CURRENT_DATE            0x08    // set if to add current date


//
//  Will this job be run interactively or not.  Windows NT 3.1 do not
//  know about this bit, i.e. they submit interactive jobs only.
//
#define JOB_NONINTERACTIVE              0x10    // set for noninteractive


#define JOB_INPUT_FLAGS     (   JOB_RUN_PERIODICALLY        |   \
                                JOB_ADD_CURRENT_DATE        |   \
                                JOB_NONINTERACTIVE  )

#define JOB_OUTPUT_FLAGS    (   JOB_RUN_PERIODICALLY        |   \
                                JOB_EXEC_ERROR              |   \
                                JOB_RUNS_TODAY              |   \
                                JOB_NONINTERACTIVE  )



typedef struct _AT_INFO {
    DWORD_PTR   JobTime;
    DWORD   DaysOfMonth;
    UCHAR   DaysOfWeek;
    UCHAR   Flags;
    LPWSTR  Command;
} AT_INFO, *PAT_INFO, *LPAT_INFO;

typedef struct _AT_ENUM {
    DWORD   JobId;
    DWORD_PTR   JobTime;
    DWORD   DaysOfMonth;
    UCHAR   DaysOfWeek;
    UCHAR   Flags;
    LPWSTR  Command;
} AT_ENUM, *PAT_ENUM, *LPAT_ENUM;

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobAdd(
    IN      LPCWSTR         Servername  OPTIONAL,
    IN      LPBYTE          Buffer,
    OUT     LPDWORD         JobId
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobDel(
    IN      LPCWSTR         Servername  OPTIONAL,
    IN      DWORD           MinJobId,
    IN      DWORD           MaxJobId
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobEnum(
    IN      LPCWSTR         Servername              OPTIONAL,
    OUT     LPBYTE *        PointerToBuffer,
    IN      DWORD           PrefferedMaximumLength,
    OUT     LPDWORD         EntriesRead,
    OUT     LPDWORD         TotalEntries,
    IN OUT  LPDWORD         ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobGetInfo(
    IN      LPCWSTR         Servername              OPTIONAL,
    IN      DWORD           JobId,
    OUT     LPBYTE *        PointerToBuffer
    );

#ifdef __cplusplus
}
#endif

#endif // _LMAT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\ks.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ks.h

Abstract:

    Windows Driver Model/Connection and Streaming Architecture (WDM-CSA)
    core definitions.

--*/

#if !defined(_KS_)
#define _KS_

#if defined(__TCS__)
#define _KS_NO_ANONYMOUS_STRUCTURES_ 1
#endif

#if !defined(_NTRTL_)
    #ifndef DEFINE_GUIDEX
        #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
    #endif // !defined(DEFINE_GUIDEX)

    #ifndef STATICGUIDOF
        #define STATICGUIDOF(guid) STATIC_##guid
    #endif // !defined(STATICGUIDOF)
#endif // !defined(_NTRTL_)

#ifndef SIZEOF_ARRAY
    #define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))
#endif // !defined(SIZEOF_ARRAY)

#if defined(__cplusplus) && _MSC_VER >= 1100
#define DEFINE_GUIDSTRUCT(g, n) struct __declspec(uuid(g)) n
#define DEFINE_GUIDNAMED(n) __uuidof(struct n)
#else // !defined(__cplusplus)
#define DEFINE_GUIDSTRUCT(g, n) DEFINE_GUIDEX(n)
#define DEFINE_GUIDNAMED(n) n
#endif // !defined(__cplusplus)

//===========================================================================

#define STATIC_GUID_NULL \
    0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

DEFINE_GUIDSTRUCT("00000000-0000-0000-0000-000000000000", GUID_NULL);
#define GUID_NULL DEFINE_GUIDNAMED(GUID_NULL)

//===========================================================================

#define IOCTL_KS_PROPERTY              CTL_CODE(FILE_DEVICE_KS, 0x000, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_ENABLE_EVENT          CTL_CODE(FILE_DEVICE_KS, 0x001, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_DISABLE_EVENT         CTL_CODE(FILE_DEVICE_KS, 0x002, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_METHOD                CTL_CODE(FILE_DEVICE_KS, 0x003, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_WRITE_STREAM          CTL_CODE(FILE_DEVICE_KS, 0x004, METHOD_NEITHER, FILE_WRITE_ACCESS)
#define IOCTL_KS_READ_STREAM           CTL_CODE(FILE_DEVICE_KS, 0x005, METHOD_NEITHER, FILE_READ_ACCESS)
#define IOCTL_KS_RESET_STATE           CTL_CODE(FILE_DEVICE_KS, 0x006, METHOD_NEITHER, FILE_ANY_ACCESS)

//===========================================================================

typedef enum {
    KSRESET_BEGIN,
    KSRESET_END
} KSRESET;

typedef enum {
    KSSTATE_STOP,
    KSSTATE_ACQUIRE,
    KSSTATE_PAUSE,
    KSSTATE_RUN
} KSSTATE, *PKSSTATE;

#define KSPRIORITY_LOW        0x00000001
#define KSPRIORITY_NORMAL     0x40000000
#define KSPRIORITY_HIGH       0x80000000
#define KSPRIORITY_EXCLUSIVE  0xFFFFFFFF

typedef struct {
    ULONG   PriorityClass;
    ULONG   PrioritySubClass;
} KSPRIORITY, *PKSPRIORITY;

typedef struct {
    union {
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
        struct _IDENTIFIER {
#else        
        struct {
#endif        
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        };
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;

typedef KSIDENTIFIER KSPROPERTY, *PKSPROPERTY, KSMETHOD, *PKSMETHOD, KSEVENT, *PKSEVENT;

#define KSMETHOD_TYPE_NONE                  0x00000000
#define KSMETHOD_TYPE_READ                  0x00000001
#define KSMETHOD_TYPE_WRITE                 0x00000002
#define KSMETHOD_TYPE_MODIFY                0x00000003
#define KSMETHOD_TYPE_SOURCE                0x00000004

#define KSMETHOD_TYPE_SEND                  0x00000001
#define KSMETHOD_TYPE_SETSUPPORT            0x00000100
#define KSMETHOD_TYPE_BASICSUPPORT          0x00000200

#define KSMETHOD_TYPE_TOPOLOGY 0x10000000

#define KSPROPERTY_TYPE_GET                 0x00000001
#define KSPROPERTY_TYPE_SET                 0x00000002
#define KSPROPERTY_TYPE_SETSUPPORT          0x00000100
#define KSPROPERTY_TYPE_BASICSUPPORT        0x00000200
#define KSPROPERTY_TYPE_RELATIONS           0x00000400
#define KSPROPERTY_TYPE_SERIALIZESET        0x00000800
#define KSPROPERTY_TYPE_UNSERIALIZESET      0x00001000
#define KSPROPERTY_TYPE_SERIALIZERAW        0x00002000
#define KSPROPERTY_TYPE_UNSERIALIZERAW      0x00004000
#define KSPROPERTY_TYPE_SERIALIZESIZE       0x00008000
#define KSPROPERTY_TYPE_DEFAULTVALUES       0x00010000

#define KSPROPERTY_TYPE_TOPOLOGY 0x10000000

typedef struct {
    KSPROPERTY      Property;
    ULONG           NodeId;
    ULONG           Reserved;
} KSP_NODE, *PKSP_NODE;

typedef struct {
    KSMETHOD        Method;
    ULONG           NodeId;
    ULONG           Reserved;
} KSM_NODE, *PKSM_NODE;

typedef struct {
    KSEVENT         Event;
    ULONG           NodeId;
    ULONG           Reserved;
} KSE_NODE, *PKSE_NODE;

#define STATIC_KSPROPTYPESETID_General \
    0x97E99BA0L, 0xBDEA, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("97E99BA0-BDEA-11CF-A5D6-28DB04C10000", KSPROPTYPESETID_General);
#define KSPROPTYPESETID_General DEFINE_GUIDNAMED(KSPROPTYPESETID_General)

#if defined(_NTDDK_) && !defined(__wtypes_h__)
enum VARENUM {
    VT_EMPTY = 0,
    VT_NULL = 1,
    VT_I2 = 2,
    VT_I4 = 3,
    VT_R4 = 4,
    VT_R8 = 5,
    VT_CY = 6,
    VT_DATE = 7,
    VT_BSTR = 8,
    VT_DISPATCH = 9,
    VT_ERROR = 10,
    VT_BOOL = 11,
    VT_VARIANT = 12,
    VT_UNKNOWN = 13,
    VT_DECIMAL = 14,
    VT_I1 = 16,
    VT_UI1 = 17,
    VT_UI2 = 18,
    VT_UI4 = 19,
    VT_I8 = 20,
    VT_UI8 = 21,
    VT_INT = 22,
    VT_UINT = 23,
    VT_VOID = 24,
    VT_HRESULT  = 25,
    VT_PTR = 26,
    VT_SAFEARRAY = 27,
    VT_CARRAY = 28,
    VT_USERDEFINED = 29,
    VT_LPSTR = 30,
    VT_LPWSTR = 31,
    VT_FILETIME = 64,
    VT_BLOB = 65,
    VT_STREAM = 66,
    VT_STORAGE = 67,
    VT_STREAMED_OBJECT = 68,
    VT_STORED_OBJECT = 69,
    VT_BLOB_OBJECT = 70,
    VT_CF = 71,
    VT_CLSID = 72,
    VT_VECTOR = 0x1000,
    VT_ARRAY = 0x2000,
    VT_BYREF = 0x4000,
    VT_RESERVED = 0x8000,
    VT_ILLEGAL = 0xffff,
    VT_ILLEGALMASKED = 0xfff,
    VT_TYPEMASK = 0xfff
};
#endif // _NTDDK_ && !__wtypes_h__

typedef struct {
    ULONG    Size;
    ULONG    Count;
} KSMULTIPLE_ITEM, *PKSMULTIPLE_ITEM;

typedef struct {
    ULONG           AccessFlags;
    ULONG           DescriptionSize;
    KSIDENTIFIER    PropTypeSet;
    ULONG           MembersListCount;
    ULONG           Reserved;
} KSPROPERTY_DESCRIPTION, *PKSPROPERTY_DESCRIPTION;

#define KSPROPERTY_MEMBER_RANGES            0x00000001
#define KSPROPERTY_MEMBER_STEPPEDRANGES     0x00000002
#define KSPROPERTY_MEMBER_VALUES            0x00000003

#define KSPROPERTY_MEMBER_FLAG_DEFAULT      0x00000001

typedef struct {
    ULONG   MembersFlags;
    ULONG   MembersSize;
    ULONG   MembersCount;
    ULONG   Flags;
} KSPROPERTY_MEMBERSHEADER, *PKSPROPERTY_MEMBERSHEADER;

typedef union {
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
    struct _SIGNED {
#else
    struct {
#endif    
        LONG    SignedMinimum;
        LONG    SignedMaximum;
    };
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
    struct _UNSIGNED {
#else
    struct {
#endif    
        ULONG   UnsignedMinimum;
        ULONG   UnsignedMaximum;
    };
} KSPROPERTY_BOUNDS_LONG, *PKSPROPERTY_BOUNDS_LONG;

typedef union {
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
    struct _SIGNED64 {
#else
    struct {
#endif    
        LONGLONG    SignedMinimum;
        LONGLONG    SignedMaximum;
    };
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
    struct _UNSIGNED64 {
#else
    struct {
#endif    
#if defined(_NTDDK_)
        ULONGLONG   UnsignedMinimum;
        ULONGLONG   UnsignedMaximum;
#else // !_NTDDK_
        DWORDLONG   UnsignedMinimum;
        DWORDLONG   UnsignedMaximum;
#endif // !_NTDDK_
    };
} KSPROPERTY_BOUNDS_LONGLONG, *PKSPROPERTY_BOUNDS_LONGLONG;

typedef struct {
    ULONG                       SteppingDelta;
    ULONG                       Reserved;
    KSPROPERTY_BOUNDS_LONG      Bounds;
} KSPROPERTY_STEPPING_LONG, *PKSPROPERTY_STEPPING_LONG;

typedef struct {
#if defined(_NTDDK_)
    ULONGLONG                   SteppingDelta;
#else // !_NTDDK_
    DWORDLONG                   SteppingDelta;
#endif // !_NTDDK_
    KSPROPERTY_BOUNDS_LONGLONG  Bounds;
} KSPROPERTY_STEPPING_LONGLONG, *PKSPROPERTY_STEPPING_LONGLONG;

//===========================================================================

// @@BEGIN_DDKSPLIT
#if defined(_NTDDK_)
//
// Structure forward declarations.
//
typedef struct _KSDEVICE_DESCRIPTOR
KSDEVICE_DESCRIPTOR, *PKSDEVICE_DESCRIPTOR;
typedef struct _KSDEVICE_DISPATCH
KSDEVICE_DISPATCH, *PKSDEVICE_DISPATCH;
typedef struct _KSDEVICE 
KSDEVICE, *PKSDEVICE;
typedef struct _KSFILTERFACTORY 
KSFILTERFACTORY, *PKSFILTERFACTORY;
typedef struct _KSFILTER_DESCRIPTOR
KSFILTER_DESCRIPTOR, *PKSFILTER_DESCRIPTOR;
typedef struct _KSFILTER_DISPATCH
KSFILTER_DISPATCH, *PKSFILTER_DISPATCH;
typedef struct _KSFILTER 
KSFILTER, *PKSFILTER;
typedef struct _KSPIN_DESCRIPTOR_EX
KSPIN_DESCRIPTOR_EX, *PKSPIN_DESCRIPTOR_EX;
typedef struct _KSPIN_DISPATCH
KSPIN_DISPATCH, *PKSPIN_DISPATCH;
typedef struct _KSCLOCK_DISPATCH
KSCLOCK_DISPATCH, *PKSCLOCK_DISPATCH;
typedef struct _KSALLOCATOR_DISPATCH
KSALLOCATOR_DISPATCH, *PKSALLOCATOR_DISPATCH;
typedef struct _KSPIN 
KSPIN, *PKSPIN;
typedef struct _KSNODE_DESCRIPTOR
KSNODE_DESCRIPTOR, *PKSNODE_DESCRIPTOR;
typedef struct _KSSTREAM_POINTER_OFFSET
KSSTREAM_POINTER_OFFSET, *PKSSTREAM_POINTER_OFFSET;
typedef struct _KSSTREAM_POINTER
KSSTREAM_POINTER, *PKSSTREAM_POINTER;
typedef struct _KSMAPPING
KSMAPPING, *PKSMAPPING;
typedef struct _KSPROCESSPIN
KSPROCESSPIN, *PKSPROCESSPIN;
typedef struct _KSPROCESSPIN_INDEXENTRY
KSPROCESSPIN_INDEXENTRY, *PKSPROCESSPIN_INDEXENTRY;
#endif // _NTDDK_
// @@END_DDKSPLIT

typedef PVOID PKSWORKER;

typedef struct {
    ULONG       NotificationType;
    union {
        struct {
            HANDLE              Event;
            ULONG_PTR           Reserved[2];
        } EventHandle;
        struct {
            HANDLE              Semaphore;
            ULONG               Reserved;
            LONG                Adjustment;
        } SemaphoreHandle;
#if defined(_NTDDK_)
        struct {
            PVOID               Event;
            KPRIORITY           Increment;
            ULONG_PTR           Reserved;
        } EventObject;
        struct {
            PVOID               Semaphore;
            KPRIORITY           Increment;
            LONG                Adjustment;
        } SemaphoreObject;
        struct {
            PKDPC               Dpc;
            ULONG               ReferenceCount;
            ULONG_PTR           Reserved;
        } Dpc;
        struct {
            PWORK_QUEUE_ITEM    WorkQueueItem;
            WORK_QUEUE_TYPE     WorkQueueType;
            ULONG_PTR           Reserved;
        } WorkItem;
        struct {
            PWORK_QUEUE_ITEM    WorkQueueItem;
            PKSWORKER           KsWorkerObject;
            ULONG_PTR           Reserved;
        } KsWorkItem;
// @@BEGIN_DDKSPLIT
        struct {
            PKSFILTER           Filter;
            ULONG_PTR           Reserved[2];
        } KsFilterProcessing;
        struct {
            PKSPIN              Pin;
            ULONG_PTR           Reserved[2];
        } KsPinProcessing;
// @@END_DDKSPLIT
#endif // defined(_NTDDK_)
        struct {
            PVOID               Unused;
            LONG_PTR            Alignment[2];
        } Alignment;
    };
} KSEVENTDATA, *PKSEVENTDATA;

#define KSEVENTF_EVENT_HANDLE       0x00000001
#define KSEVENTF_SEMAPHORE_HANDLE   0x00000002
#if defined(_NTDDK_)
#define KSEVENTF_EVENT_OBJECT       0x00000004
#define KSEVENTF_SEMAPHORE_OBJECT   0x00000008
#define KSEVENTF_DPC                0x00000010
#define KSEVENTF_WORKITEM           0x00000020
#define KSEVENTF_KSWORKITEM         0x00000080
// @@BEGIN_DDKSPLIT
#define KSEVENTF_KSFILTERPROCESSING 0x00000100
#define KSEVENTF_KSPINPROCESSING    0x00000200
// @@END_DDKSPLIT
#endif // defined(_NTDDK_)

#define KSEVENT_TYPE_ENABLE         0x00000001
#define KSEVENT_TYPE_ONESHOT        0x00000002
#define KSEVENT_TYPE_ENABLEBUFFERED 0x00000004
#define KSEVENT_TYPE_SETSUPPORT     0x00000100
#define KSEVENT_TYPE_BASICSUPPORT   0x00000200
#define KSEVENT_TYPE_QUERYBUFFER    0x00000400

#define KSEVENT_TYPE_TOPOLOGY 0x10000000

typedef struct {
    KSEVENT         Event;
    PKSEVENTDATA    EventData;
    PVOID           Reserved;
} KSQUERYBUFFER, *PKSQUERYBUFFER;

typedef struct {
    ULONG Size;
    ULONG Flags;
    union {
        HANDLE ObjectHandle;
        PVOID ObjectPointer;
    };
    PVOID Reserved;
    KSEVENT Event;
    KSEVENTDATA EventData;
} KSRELATIVEEVENT;

#define KSRELATIVEEVENT_FLAG_HANDLE 0x00000001
#define KSRELATIVEEVENT_FLAG_POINTER 0x00000002

//===========================================================================

typedef struct {
    KSEVENTDATA     EventData;
    LONGLONG        MarkTime;
} KSEVENT_TIME_MARK, *PKSEVENT_TIME_MARK;

typedef struct {
    KSEVENTDATA     EventData;
    LONGLONG        TimeBase;
    LONGLONG        Interval;
} KSEVENT_TIME_INTERVAL, *PKSEVENT_TIME_INTERVAL;

typedef struct {
    LONGLONG        TimeBase;
    LONGLONG        Interval;
} KSINTERVAL, *PKSINTERVAL;

//===========================================================================

#define STATIC_KSPROPSETID_General\
    0x1464EDA5L, 0x6A8F, 0x11D1, 0x9A, 0xA7, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("1464EDA5-6A8F-11D1-9AA7-00A0C9223196", KSPROPSETID_General);
#define KSPROPSETID_General DEFINE_GUIDNAMED(KSPROPSETID_General)

typedef enum {
    KSPROPERTY_GENERAL_COMPONENTID
} KSPROPERTY_GENERAL;

typedef struct {
    GUID    Manufacturer;
    GUID    Product;
    GUID    Component;
    GUID    Name;
    ULONG   Version;
    ULONG   Revision;
} KSCOMPONENTID, *PKSCOMPONENTID;

#define DEFINE_KSPROPERTY_ITEM_GENERAL_COMPONENTID(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_GENERAL_COMPONENTID,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSCOMPONENTID),\
        NULL, NULL, 0, NULL, NULL, 0)

#define STATIC_KSMETHODSETID_StreamIo\
    0x65D003CAL, 0x1523, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65D003CA-1523-11D2-B27A-00A0C9223196", KSMETHODSETID_StreamIo);
#define KSMETHODSETID_StreamIo DEFINE_GUIDNAMED(KSMETHODSETID_StreamIo)

typedef enum {
    KSMETHOD_STREAMIO_READ,
    KSMETHOD_STREAMIO_WRITE
} KSMETHOD_STREAMIO;

#define DEFINE_KSMETHOD_ITEM_STREAMIO_READ(Handler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_STREAMIO_READ,\
        KSMETHOD_TYPE_WRITE,\
        (Handler),\
        sizeof(KSMETHOD),\
        0,\
        NULL)

#define DEFINE_KSMETHOD_ITEM_STREAMIO_WRITE(Handler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_STREAMIO_WRITE,\
        KSMETHOD_TYPE_READ,\
        (Handler),\
        sizeof(KSMETHOD),\
        0,\
        NULL)

#define STATIC_KSPROPSETID_MediaSeeking\
    0xEE904F0CL, 0xD09B, 0x11D0, 0xAB, 0xE9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("EE904F0C-D09B-11D0-ABE9-00A0C9223196", KSPROPSETID_MediaSeeking);
#define KSPROPSETID_MediaSeeking DEFINE_GUIDNAMED(KSPROPSETID_MediaSeeking)

typedef enum {
    KSPROPERTY_MEDIASEEKING_CAPABILITIES,
    KSPROPERTY_MEDIASEEKING_FORMATS,
    KSPROPERTY_MEDIASEEKING_TIMEFORMAT,
    KSPROPERTY_MEDIASEEKING_POSITION,
    KSPROPERTY_MEDIASEEKING_STOPPOSITION,
    KSPROPERTY_MEDIASEEKING_POSITIONS,
    KSPROPERTY_MEDIASEEKING_DURATION,
    KSPROPERTY_MEDIASEEKING_AVAILABLE,
    KSPROPERTY_MEDIASEEKING_PREROLL,
    KSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT
} KSPROPERTY_MEDIASEEKING;

typedef enum {
    KS_SEEKING_NoPositioning,
    KS_SEEKING_AbsolutePositioning,
    KS_SEEKING_RelativePositioning,
    KS_SEEKING_IncrementalPositioning,
    KS_SEEKING_PositioningBitsMask = 0x3,
    KS_SEEKING_SeekToKeyFrame,
    KS_SEEKING_ReturnTime = 0x8
} KS_SEEKING_FLAGS;

typedef enum {
    KS_SEEKING_CanSeekAbsolute = 0x1,
    KS_SEEKING_CanSeekForwards = 0x2,
    KS_SEEKING_CanSeekBackwards = 0x4,
    KS_SEEKING_CanGetCurrentPos = 0x8,
    KS_SEEKING_CanGetStopPos = 0x10,
    KS_SEEKING_CanGetDuration = 0x20,
    KS_SEEKING_CanPlayBackwards = 0x40
} KS_SEEKING_CAPABILITIES;

typedef struct {
    LONGLONG            Current;
    LONGLONG            Stop;
    KS_SEEKING_FLAGS    CurrentFlags;
    KS_SEEKING_FLAGS    StopFlags;
} KSPROPERTY_POSITIONS, *PKSPROPERTY_POSITIONS;

typedef struct {
    LONGLONG    Earliest;
    LONGLONG    Latest;
} KSPROPERTY_MEDIAAVAILABLE, *PKSPROPERTY_MEDIAAVAILABLE;

typedef struct {
    KSPROPERTY  Property;
    GUID        SourceFormat;
    GUID        TargetFormat;
    LONGLONG    Time;
} KSP_TIMEFORMAT, *PKSP_TIMEFORMAT;

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_CAPABILITIES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_CAPABILITIES,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KS_SEEKING_CAPABILITIES),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_FORMATS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_FORMATS,\
        (Handler),\
        sizeof(KSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_TIMEFORMAT(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_TIMEFORMAT,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(GUID),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_POSITION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_POSITION,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_STOPPOSITION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_STOPPOSITION,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_POSITIONS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_POSITIONS,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(KSPROPERTY_POSITIONS),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_DURATION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_DURATION,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_AVAILABLE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_AVAILABLE,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSPROPERTY_MEDIAAVAILABLE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_PREROLL(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_PREROLL,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_CONVERTTIMEFORMAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT,\
        (Handler),\
        sizeof(KSP_TIMEFORMAT),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

//===========================================================================

#define STATIC_KSPROPSETID_Topology\
    0x720D4AC0L, 0x7533, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("720D4AC0-7533-11D0-A5D6-28DB04C10000", KSPROPSETID_Topology);
#define KSPROPSETID_Topology DEFINE_GUIDNAMED(KSPROPSETID_Topology)

typedef enum {
    KSPROPERTY_TOPOLOGY_CATEGORIES,
    KSPROPERTY_TOPOLOGY_NODES,
    KSPROPERTY_TOPOLOGY_CONNECTIONS,
    KSPROPERTY_TOPOLOGY_NAME
} KSPROPERTY_TOPOLOGY;

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CATEGORIES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_TOPOLOGY_CATEGORIES,\
        (Handler),\
        sizeof(KSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NODES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_TOPOLOGY_NODES,\
        (Handler),\
        sizeof(KSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CONNECTIONS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_TOPOLOGY_CONNECTIONS,\
        (Handler),\
        sizeof(KSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NAME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_TOPOLOGY_NAME,\
        (Handler),\
        sizeof(KSP_NODE),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_TOPOLOGYSET(TopologySet, Handler)\
DEFINE_KSPROPERTY_TABLE(TopologySet) {\
    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CATEGORIES(Handler),\
    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NODES(Handler),\
    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CONNECTIONS(Handler),\
    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NAME(Handler)\
}

//=============================================================================

//
// properties used by graph manager to talk to particular filters
//
#if defined(_NTDDK_)

#define STATIC_KSPROPSETID_GM \
    0xAF627536L, 0xE719, 0x11D2, 0x8A, 0x1D, 0x00, 0x60, 0x97, 0xD2, 0xDF, 0x5D    
DEFINE_GUIDSTRUCT("AF627536-E719-11D2-8A1D-006097D2DF5D", KSPROPSETID_GM);
#define KSPROPSETID_GM DEFINE_GUIDNAMED(KSPROPSETID_GM)

typedef VOID (*PFNKSGRAPHMANAGER_NOTIFY)(IN PFILE_OBJECT GraphManager,
                                         IN ULONG EventId,
                                         IN PVOID Filter,
                                         IN PVOID Pin,
                                         IN PVOID Frame,
                                         IN ULONG Duration);

typedef struct KSGRAPHMANAGER_FUNCTIONTABLE {
    PFNKSGRAPHMANAGER_NOTIFY NotifyEvent;
} KSGRAPHMANAGER_FUNCTIONTABLE, PKSGRAPHMANAGER_FUNCTIONTABLE;

typedef struct _KSPROPERTY_GRAPHMANAGER_INTERFACE {
    PFILE_OBJECT                 GraphManager;
    KSGRAPHMANAGER_FUNCTIONTABLE FunctionTable;
} KSPROPERTY_GRAPHMANAGER_INTERFACE, *PKSPROPERTY_GRAPHMANAGER_INTERFACE;


//
// Commands
//
typedef enum {
    KSPROPERTY_GM_GRAPHMANAGER,    
    KSPROPERTY_GM_TIMESTAMP_CLOCK, 
    KSPROPERTY_GM_RATEMATCH,       
    KSPROPERTY_GM_RENDER_CLOCK,    
} KSPROPERTY_GM;

#endif

//===========================================================================


#define STATIC_KSCATEGORY_BRIDGE \
    0x085AFF00L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("085AFF00-62CE-11CF-A5D6-28DB04C10000", KSCATEGORY_BRIDGE);
#define KSCATEGORY_BRIDGE DEFINE_GUIDNAMED(KSCATEGORY_BRIDGE)

#define STATIC_KSCATEGORY_CAPTURE \
    0x65E8773DL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65E8773D-8F56-11D0-A3B9-00A0C9223196", KSCATEGORY_CAPTURE);
#define KSCATEGORY_CAPTURE DEFINE_GUIDNAMED(KSCATEGORY_CAPTURE)

#define STATIC_KSCATEGORY_RENDER \
    0x65E8773EL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65E8773E-8F56-11D0-A3B9-00A0C9223196", KSCATEGORY_RENDER);
#define KSCATEGORY_RENDER DEFINE_GUIDNAMED(KSCATEGORY_RENDER)

#define STATIC_KSCATEGORY_MIXER \
    0xAD809C00L, 0x7B88, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("AD809C00-7B88-11D0-A5D6-28DB04C10000", KSCATEGORY_MIXER);
#define KSCATEGORY_MIXER DEFINE_GUIDNAMED(KSCATEGORY_MIXER)

#define STATIC_KSCATEGORY_SPLITTER \
    0x0A4252A0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("0A4252A0-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_SPLITTER);
#define KSCATEGORY_SPLITTER DEFINE_GUIDNAMED(KSCATEGORY_SPLITTER)

#define STATIC_KSCATEGORY_DATACOMPRESSOR \
    0x1E84C900L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1E84C900-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_DATACOMPRESSOR);
#define KSCATEGORY_DATACOMPRESSOR DEFINE_GUIDNAMED(KSCATEGORY_DATACOMPRESSOR)

#define STATIC_KSCATEGORY_DATADECOMPRESSOR \
    0x2721AE20L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("2721AE20-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_DATADECOMPRESSOR);
#define KSCATEGORY_DATADECOMPRESSOR DEFINE_GUIDNAMED(KSCATEGORY_DATADECOMPRESSOR)

#define STATIC_KSCATEGORY_DATATRANSFORM \
    0x2EB07EA0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("2EB07EA0-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_DATATRANSFORM);
#define KSCATEGORY_DATATRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_DATATRANSFORM)

#define STATIC_KSCATEGORY_COMMUNICATIONSTRANSFORM \
    0xCF1DDA2CL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("CF1DDA2C-9743-11D0-A3EE-00A0C9223196", KSCATEGORY_COMMUNICATIONSTRANSFORM);
#define KSCATEGORY_COMMUNICATIONSTRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_COMMUNICATIONSTRANSFORM)

#define STATIC_KSCATEGORY_INTERFACETRANSFORM \
    0xCF1DDA2DL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("CF1DDA2D-9743-11D0-A3EE-00A0C9223196", KSCATEGORY_INTERFACETRANSFORM);
#define KSCATEGORY_INTERFACETRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_INTERFACETRANSFORM)

#define STATIC_KSCATEGORY_MEDIUMTRANSFORM \
    0xCF1DDA2EL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("CF1DDA2E-9743-11D0-A3EE-00A0C9223196", KSCATEGORY_MEDIUMTRANSFORM);
#define KSCATEGORY_MEDIUMTRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_MEDIUMTRANSFORM)

#define STATIC_KSCATEGORY_FILESYSTEM \
    0x760FED5EL, 0x9357, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("760FED5E-9357-11D0-A3CC-00A0C9223196", KSCATEGORY_FILESYSTEM);
#define KSCATEGORY_FILESYSTEM DEFINE_GUIDNAMED(KSCATEGORY_FILESYSTEM)

// KSNAME_Clock
#define STATIC_KSCATEGORY_CLOCK \
    0x53172480L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("53172480-4791-11D0-A5D6-28DB04C10000", KSCATEGORY_CLOCK);
#define KSCATEGORY_CLOCK DEFINE_GUIDNAMED(KSCATEGORY_CLOCK)

#define STATIC_KSCATEGORY_PROXY \
    0x97EBAACAL, 0x95BD, 0x11D0, 0xA3, 0xEA, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("97EBAACA-95BD-11D0-A3EA-00A0C9223196", KSCATEGORY_PROXY);
#define KSCATEGORY_PROXY DEFINE_GUIDNAMED(KSCATEGORY_PROXY)

#define STATIC_KSCATEGORY_QUALITY \
    0x97EBAACBL, 0x95BD, 0x11D0, 0xA3, 0xEA, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("97EBAACB-95BD-11D0-A3EA-00A0C9223196", KSCATEGORY_QUALITY);
#define KSCATEGORY_QUALITY DEFINE_GUIDNAMED(KSCATEGORY_QUALITY)

typedef struct {
    ULONG   FromNode;
    ULONG   FromNodePin;
    ULONG   ToNode;
    ULONG   ToNodePin;
} KSTOPOLOGY_CONNECTION, *PKSTOPOLOGY_CONNECTION;

typedef struct {
    ULONG                           CategoriesCount;
    const GUID*                     Categories;
    ULONG                           TopologyNodesCount;
    const GUID*                     TopologyNodes;
    ULONG                           TopologyConnectionsCount;
    const KSTOPOLOGY_CONNECTION*    TopologyConnections;
    const GUID*                     TopologyNodesNames;
    ULONG                           Reserved;
} KSTOPOLOGY, *PKSTOPOLOGY;

#define KSFILTER_NODE   ((ULONG)-1)
#define KSALL_NODES     ((ULONG)-1)

typedef struct {
    ULONG       CreateFlags;
    ULONG       Node;
} KSNODE_CREATE, *PKSNODE_CREATE;

//===========================================================================

// TIME_FORMAT_NONE
#define STATIC_KSTIME_FORMAT_NONE       STATIC_GUID_NULL
#define KSTIME_FORMAT_NONE              GUID_NULL

// TIME_FORMAT_FRAME
#define STATIC_KSTIME_FORMAT_FRAME\
    0x7b785570L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785570-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_FRAME);
#define KSTIME_FORMAT_FRAME DEFINE_GUIDNAMED(KSTIME_FORMAT_FRAME)

// TIME_FORMAT_BYTE             
#define STATIC_KSTIME_FORMAT_BYTE\
    0x7b785571L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785571-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_BYTE);
#define KSTIME_FORMAT_BYTE DEFINE_GUIDNAMED(KSTIME_FORMAT_BYTE)

// TIME_FORMAT_SAMPLE
#define STATIC_KSTIME_FORMAT_SAMPLE\
    0x7b785572L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785572-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_SAMPLE);
#define KSTIME_FORMAT_SAMPLE DEFINE_GUIDNAMED(KSTIME_FORMAT_SAMPLE)

// TIME_FORMAT_FIELD
#define STATIC_KSTIME_FORMAT_FIELD\
    0x7b785573L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785573-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_FIELD);
#define KSTIME_FORMAT_FIELD DEFINE_GUIDNAMED(KSTIME_FORMAT_FIELD)

// TIME_FORMAT_MEDIA_TIME
#define STATIC_KSTIME_FORMAT_MEDIA_TIME\
    0x7b785574L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785574-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_MEDIA_TIME);
#define KSTIME_FORMAT_MEDIA_TIME DEFINE_GUIDNAMED(KSTIME_FORMAT_MEDIA_TIME)

//===========================================================================

typedef KSIDENTIFIER KSPIN_INTERFACE, *PKSPIN_INTERFACE;

#define STATIC_KSINTERFACESETID_Standard \
    0x1A8766A0L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1A8766A0-62CE-11CF-A5D6-28DB04C10000", KSINTERFACESETID_Standard);
#define KSINTERFACESETID_Standard DEFINE_GUIDNAMED(KSINTERFACESETID_Standard)

typedef enum {
    KSINTERFACE_STANDARD_STREAMING,
    KSINTERFACE_STANDARD_LOOPED_STREAMING,
    KSINTERFACE_STANDARD_CONTROL
} KSINTERFACE_STANDARD;

#define STATIC_KSINTERFACESETID_FileIo \
    0x8C6F932CL, 0xE771, 0x11D0, 0xB8, 0xFF, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("8C6F932C-E771-11D0-B8FF-00A0C9223196", KSINTERFACESETID_FileIo);
#define KSINTERFACESETID_FileIo DEFINE_GUIDNAMED(KSINTERFACESETID_FileIo)

typedef enum {
    KSINTERFACE_FILEIO_STREAMING
} KSINTERFACE_FILEIO;

//===========================================================================

#define KSMEDIUM_TYPE_ANYINSTANCE       0

#define STATIC_KSMEDIUMSETID_Standard \
    0x4747B320L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("4747B320-62CE-11CF-A5D6-28DB04C10000", KSMEDIUMSETID_Standard);
#define KSMEDIUMSETID_Standard DEFINE_GUIDNAMED(KSMEDIUMSETID_Standard)

//For compatibility only
#define KSMEDIUM_STANDARD_DEVIO     KSMEDIUM_TYPE_ANYINSTANCE

//===========================================================================

#define STATIC_KSPROPSETID_Pin\
    0x8C134960L, 0x51AD, 0x11CF, 0x87, 0x8A, 0x94, 0xF8, 0x01, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("8C134960-51AD-11CF-878A-94F801C10000", KSPROPSETID_Pin);
#define KSPROPSETID_Pin DEFINE_GUIDNAMED(KSPROPSETID_Pin)

typedef enum {
    KSPROPERTY_PIN_CINSTANCES,
    KSPROPERTY_PIN_CTYPES,
    KSPROPERTY_PIN_DATAFLOW,
    KSPROPERTY_PIN_DATARANGES,
    KSPROPERTY_PIN_DATAINTERSECTION,
    KSPROPERTY_PIN_INTERFACES,
    KSPROPERTY_PIN_MEDIUMS,
    KSPROPERTY_PIN_COMMUNICATION,
    KSPROPERTY_PIN_GLOBALCINSTANCES,
    KSPROPERTY_PIN_NECESSARYINSTANCES,
    KSPROPERTY_PIN_PHYSICALCONNECTION,
    KSPROPERTY_PIN_CATEGORY,
    KSPROPERTY_PIN_NAME,
    KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
    KSPROPERTY_PIN_PROPOSEDATAFORMAT
} KSPROPERTY_PIN;

typedef struct {
    KSPROPERTY      Property;
    ULONG           PinId;
    ULONG           Reserved;
} KSP_PIN, *PKSP_PIN;

#define KSINSTANCE_INDETERMINATE    ((ULONG)-1)

typedef struct {
    ULONG  PossibleCount;
    ULONG  CurrentCount;
} KSPIN_CINSTANCES, *PKSPIN_CINSTANCES;

typedef enum {
    KSPIN_DATAFLOW_IN = 1,
    KSPIN_DATAFLOW_OUT
} KSPIN_DATAFLOW, *PKSPIN_DATAFLOW;

#define KSDATAFORMAT_BIT_TEMPORAL_COMPRESSION   0
#define KSDATAFORMAT_TEMPORAL_COMPRESSION       (1 << KSDATAFORMAT_BIT_TEMPORAL_COMPRESSION)
#define KSDATAFORMAT_BIT_ATTRIBUTES 1
#define KSDATAFORMAT_ATTRIBUTES (1 << KSDATAFORMAT_BIT_ATTRIBUTES)

#define KSDATARANGE_BIT_ATTRIBUTES 1
#define KSDATARANGE_ATTRIBUTES (1 << KSDATARANGE_BIT_ATTRIBUTES)
#define KSDATARANGE_BIT_REQUIRED_ATTRIBUTES 2
#define KSDATARANGE_REQUIRED_ATTRIBUTES (1 << KSDATARANGE_BIT_REQUIRED_ATTRIBUTES)

#if !defined( _MSC_VER ) 
typedef struct {
    ULONG   FormatSize;
    ULONG   Flags;
    ULONG   SampleSize;
    ULONG   Reserved;
    GUID    MajorFormat;
    GUID    SubFormat;
    GUID    Specifier;
} KSDATAFORMAT, *PKSDATAFORMAT, KSDATARANGE, *PKSDATARANGE;
#else
typedef union {
    struct {
        ULONG   FormatSize;
        ULONG   Flags;
        ULONG   SampleSize;
        ULONG   Reserved;
        GUID    MajorFormat;
        GUID    SubFormat;
        GUID    Specifier;
    };
    LONGLONG    Alignment;
} KSDATAFORMAT, *PKSDATAFORMAT, KSDATARANGE, *PKSDATARANGE;
#endif

#define KSATTRIBUTE_REQUIRED 0x00000001

typedef struct {
    ULONG Size;
    ULONG Flags;
    GUID Attribute;
} KSATTRIBUTE, *PKSATTRIBUTE;

#if defined(_NTDDK_)
typedef struct {
    ULONG Count;
    PKSATTRIBUTE* Attributes;
} KSATTRIBUTE_LIST, *PKSATTRIBUTE_LIST;
#endif // _NTDDK_

typedef enum {
    KSPIN_COMMUNICATION_NONE,
    KSPIN_COMMUNICATION_SINK,
    KSPIN_COMMUNICATION_SOURCE,
    KSPIN_COMMUNICATION_BOTH,
    KSPIN_COMMUNICATION_BRIDGE
} KSPIN_COMMUNICATION, *PKSPIN_COMMUNICATION;

typedef KSIDENTIFIER KSPIN_MEDIUM, *PKSPIN_MEDIUM;

typedef struct {
    KSPIN_INTERFACE Interface;
    KSPIN_MEDIUM    Medium;
    ULONG           PinId;
    HANDLE          PinToHandle;
    KSPRIORITY      Priority;
} KSPIN_CONNECT, *PKSPIN_CONNECT;

typedef struct {
    ULONG   Size;
    ULONG   Pin;
    WCHAR   SymbolicLinkName[1];
} KSPIN_PHYSICALCONNECTION, *PKSPIN_PHYSICALCONNECTION;

#if defined(_NTDDK_)
typedef
NTSTATUS
(*PFNKSINTERSECTHANDLER)(
    IN PIRP Irp,
    IN PKSP_PIN Pin,
    IN PKSDATARANGE DataRange,
    OUT PVOID Data OPTIONAL
    );
typedef
NTSTATUS
(*PFNKSINTERSECTHANDLEREX)(
    IN PVOID Context,
    IN PIRP Irp,
    IN PKSP_PIN Pin,
    IN PKSDATARANGE DataRange,
    IN PKSDATARANGE MatchingDataRange,
    IN ULONG DataBufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    );
#endif // _NTDDK_

#define DEFINE_KSPIN_INTERFACE_TABLE(tablename)\
    const KSPIN_INTERFACE tablename[] =

#define DEFINE_KSPIN_INTERFACE_ITEM(guid, interface)\
    {\
        STATICGUIDOF(guid),\
        (interface),\
        0\
    }

#define DEFINE_KSPIN_MEDIUM_TABLE( tablename )\
    const KSPIN_MEDIUM tablename[] =

#define DEFINE_KSPIN_MEDIUM_ITEM(guid, medium)\
    DEFINE_KSPIN_INTERFACE_ITEM(guid, medium)

#define DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_CINSTANCES,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(KSPIN_CINSTANCES),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_CTYPES,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_DATAFLOW,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(KSPIN_DATAFLOW),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_DATARANGES,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_DATAINTERSECTION,\
        (Handler),\
        sizeof(KSP_PIN) + sizeof(KSMULTIPLE_ITEM),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_INTERFACES,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_MEDIUMS,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_COMMUNICATION,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(KSPIN_COMMUNICATION),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_GLOBALCINSTANCES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_GLOBALCINSTANCES,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(KSPIN_CINSTANCES),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_NECESSARYINSTANCES,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_PHYSICALCONNECTION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_PHYSICALCONNECTION,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_CATEGORY,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(GUID),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_NAME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_NAME,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_CONSTRAINEDDATARANGES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_CONSTRAINEDDATARANGES,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_PROPOSEDATAFORMAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_PROPOSEDATAFORMAT,\
        NULL,\
        sizeof(KSP_PIN),\
        sizeof(KSDATAFORMAT),\
        (Handler), NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_PINSET(PinSet,\
    PropGeneral, PropInstances, PropIntersection)\
DEFINE_KSPROPERTY_TABLE(PinSet) {\
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropInstances),\
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropIntersection),\
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropGeneral)\
}

#define DEFINE_KSPROPERTY_PINSETCONSTRAINED(PinSet,\
    PropGeneral, PropInstances, PropIntersection)\
DEFINE_KSPROPERTY_TABLE(PinSet) {\
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropInstances),\
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropIntersection),\
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_CONSTRAINEDDATARANGES(PropGeneral)\
}

#define STATIC_KSNAME_Filter\
    0x9b365890L, 0x165f, 0x11d0, 0xa1, 0x95, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("9b365890-165f-11d0-a195-0020afd156e4", KSNAME_Filter);
#define KSNAME_Filter DEFINE_GUIDNAMED(KSNAME_Filter)

#define KSSTRING_Filter L"{9B365890-165F-11D0-A195-0020AFD156E4}"

#define STATIC_KSNAME_Pin\
    0x146F1A80L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("146F1A80-4791-11D0-A5D6-28DB04C10000", KSNAME_Pin);
#define KSNAME_Pin DEFINE_GUIDNAMED(KSNAME_Pin)

#define KSSTRING_Pin L"{146F1A80-4791-11D0-A5D6-28DB04C10000}"

#define STATIC_KSNAME_Clock\
    0x53172480L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("53172480-4791-11D0-A5D6-28DB04C10000", KSNAME_Clock);
#define KSNAME_Clock DEFINE_GUIDNAMED(KSNAME_Clock)

#define KSSTRING_Clock L"{53172480-4791-11D0-A5D6-28DB04C10000}"

#define STATIC_KSNAME_Allocator\
    0x642F5D00L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("642F5D00-4791-11D0-A5D6-28DB04C10000", KSNAME_Allocator);
#define KSNAME_Allocator DEFINE_GUIDNAMED(KSNAME_Allocator)

#define KSSTRING_Allocator L"{642F5D00-4791-11D0-A5D6-28DB04C10000}"

#define KSSTRING_AllocatorEx L"{091BB63B-603F-11D1-B067-00A0C9062802}"

#define STATIC_KSNAME_TopologyNode\
    0x0621061AL, 0xEE75, 0x11D0, 0xB9, 0x15, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("0621061A-EE75-11D0-B915-00A0C9223196", KSNAME_TopologyNode);
#define KSNAME_TopologyNode DEFINE_GUIDNAMED(KSNAME_TopologyNode)

#define KSSTRING_TopologyNode L"{0621061A-EE75-11D0-B915-00A0C9223196}"

#if defined(_NTDDK_)

typedef struct {
    ULONG                   InterfacesCount;
    const KSPIN_INTERFACE*  Interfaces;
    ULONG                   MediumsCount;
    const KSPIN_MEDIUM*     Mediums;
    ULONG                   DataRangesCount;
    const PKSDATARANGE*     DataRanges;
    KSPIN_DATAFLOW          DataFlow;
    KSPIN_COMMUNICATION     Communication;
    const GUID*             Category;
    const GUID*             Name;
    union {
        LONGLONG            Reserved;
        struct {
            ULONG           ConstrainedDataRangesCount;
            PKSDATARANGE*   ConstrainedDataRanges;
        };
    };
} KSPIN_DESCRIPTOR, *PKSPIN_DESCRIPTOR;
typedef const KSPIN_DESCRIPTOR *PCKSPIN_DESCRIPTOR;

#define DEFINE_KSPIN_DESCRIPTOR_TABLE(tablename)\
    const KSPIN_DESCRIPTOR tablename[] =

#define DEFINE_KSPIN_DESCRIPTOR_ITEM(\
    InterfacesCount, Interfaces,\
    MediumsCount, Mediums,\
    DataRangesCount, DataRanges,\
    DataFlow, Communication)\
{\
    InterfacesCount, Interfaces, MediumsCount, Mediums,\
    DataRangesCount, DataRanges, DataFlow, Communication,\
    NULL, NULL, 0\
}
#define DEFINE_KSPIN_DESCRIPTOR_ITEMEX(\
    InterfacesCount, Interfaces,\
    MediumsCount, Mediums,\
    DataRangesCount, DataRanges,\
    DataFlow, Communication,\
    Category, Name)\
{\
    InterfacesCount, Interfaces, MediumsCount, Mediums,\
    DataRangesCount, DataRanges, DataFlow, Communication,\
    Category, Name, 0\
}

#endif // defined(_NTDDK_)

//===========================================================================

// MEDIATYPE_NULL
#define STATIC_KSDATAFORMAT_TYPE_WILDCARD       STATIC_GUID_NULL
#define KSDATAFORMAT_TYPE_WILDCARD              GUID_NULL

// MEDIASUBTYPE_NULL
#define STATIC_KSDATAFORMAT_SUBTYPE_WILDCARD    STATIC_GUID_NULL
#define KSDATAFORMAT_SUBTYPE_WILDCARD           GUID_NULL

// MEDIATYPE_Stream
#define STATIC_KSDATAFORMAT_TYPE_STREAM\
    0xE436EB83L, 0x524F, 0x11CE, 0x9F, 0x53, 0x00, 0x20, 0xAF, 0x0B, 0xA7, 0x70
DEFINE_GUIDSTRUCT("E436EB83-524F-11CE-9F53-0020AF0BA770", KSDATAFORMAT_TYPE_STREAM);
#define KSDATAFORMAT_TYPE_STREAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STREAM)

// MEDIASUBTYPE_None
#define STATIC_KSDATAFORMAT_SUBTYPE_NONE\
    0xE436EB8EL, 0x524F, 0x11CE, 0x9F, 0x53, 0x00, 0x20, 0xAF, 0x0B, 0xA7, 0x70
DEFINE_GUIDSTRUCT("E436EB8E-524F-11CE-9F53-0020AF0BA770", KSDATAFORMAT_SUBTYPE_NONE);
#define KSDATAFORMAT_SUBTYPE_NONE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NONE)

#define STATIC_KSDATAFORMAT_SPECIFIER_WILDCARD  STATIC_GUID_NULL
#define KSDATAFORMAT_SPECIFIER_WILDCARD         GUID_NULL

#define STATIC_KSDATAFORMAT_SPECIFIER_FILENAME\
    0xAA797B40L, 0xE974, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("AA797B40-E974-11CF-A5D6-28DB04C10000", KSDATAFORMAT_SPECIFIER_FILENAME);
#define KSDATAFORMAT_SPECIFIER_FILENAME DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_FILENAME)

#define STATIC_KSDATAFORMAT_SPECIFIER_FILEHANDLE\
    0x65E8773CL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65E8773C-8F56-11D0-A3B9-00A0C9223196", KSDATAFORMAT_SPECIFIER_FILEHANDLE);
#define KSDATAFORMAT_SPECIFIER_FILEHANDLE DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_FILEHANDLE)

// FORMAT_None
#define STATIC_KSDATAFORMAT_SPECIFIER_NONE\
    0x0F6417D6L, 0xC318, 0x11D0, 0xA4, 0x3F, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("0F6417D6-C318-11D0-A43F-00A0C9223196", KSDATAFORMAT_SPECIFIER_NONE);
#define KSDATAFORMAT_SPECIFIER_NONE DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_NONE)

//===========================================================================

#define STATIC_KSPROPSETID_Quality \
    0xD16AD380L, 0xAC1A, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("D16AD380-AC1A-11CF-A5D6-28DB04C10000", KSPROPSETID_Quality);
#define KSPROPSETID_Quality DEFINE_GUIDNAMED(KSPROPSETID_Quality)

typedef enum {
    KSPROPERTY_QUALITY_REPORT,
    KSPROPERTY_QUALITY_ERROR
} KSPROPERTY_QUALITY;

#define DEFINE_KSPROPERTY_ITEM_QUALITY_REPORT(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_QUALITY_REPORT,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSQUALITY),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_QUALITY_ERROR(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_QUALITY_ERROR,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSERROR),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//===========================================================================

#define STATIC_KSPROPSETID_Connection \
    0x1D58C920L, 0xAC9B, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1D58C920-AC9B-11CF-A5D6-28DB04C10000", KSPROPSETID_Connection);
#define KSPROPSETID_Connection DEFINE_GUIDNAMED(KSPROPSETID_Connection)

typedef enum {
    KSPROPERTY_CONNECTION_STATE,
    KSPROPERTY_CONNECTION_PRIORITY,
    KSPROPERTY_CONNECTION_DATAFORMAT,
    KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
    KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT,
    KSPROPERTY_CONNECTION_ACQUIREORDERING,
    KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX,
    KSPROPERTY_CONNECTION_STARTAT
} KSPROPERTY_CONNECTION;

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_STATE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSSTATE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_PRIORITY(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_PRIORITY,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSPRIORITY),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_DATAFORMAT(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_DATAFORMAT,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSALLOCATOR_FRAMING),\
        NULL, NULL, 0, NULL, NULL, 0)
        
#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING_EX(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSALLOCATOR_FRAMING_EX),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_PROPOSEDATAFORMAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(KSDATAFORMAT),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ACQUIREORDERING(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_ACQUIREORDERING,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(int),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_STARTAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_STARTAT,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(KSRELATIVEEVENT),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

//===========================================================================
//
// pins flags
//
#define KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER   0x00000001
#define KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY      0x00000002
#define KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY    0x00000004
#define KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE      0x00000008
#define KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY   0x80000000

#define KSALLOCATOR_OPTIONF_COMPATIBLE              0x00000001
#define KSALLOCATOR_OPTIONF_SYSTEM_MEMORY           0x00000002
#define KSALLOCATOR_OPTIONF_VALID                   0x00000003
// 
// pins extended framing flags
//
#define KSALLOCATOR_FLAG_PARTIAL_READ_SUPPORT       0x00000010
#define KSALLOCATOR_FLAG_DEVICE_SPECIFIC            0x00000020
#define KSALLOCATOR_FLAG_CAN_ALLOCATE               0x00000040
#define KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO  0x00000080
//
// allocator pipes flags
//
// there is at least one data modification in a pipe
#define KSALLOCATOR_FLAG_NO_FRAME_INTEGRITY         0x00000100
#define KSALLOCATOR_FLAG_MULTIPLE_OUTPUT            0x00000200
#define KSALLOCATOR_FLAG_CYCLE                      0x00000400
#define KSALLOCATOR_FLAG_ALLOCATOR_EXISTS           0x00000800
// there is no framing dependency between neighbouring pipes.
#define KSALLOCATOR_FLAG_INDEPENDENT_RANGES         0x00001000
#define KSALLOCATOR_FLAG_ATTENTION_STEPPING         0x00002000


//
// old Framing structure
//
typedef struct {
    union {
        ULONG       OptionsFlags;       // allocator options (create)
        ULONG       RequirementsFlags;  // allocation requirements (query)
    };
#if defined(_NTDDK_)
    POOL_TYPE   PoolType;
#else // !_NTDDK_
    ULONG       PoolType;
#endif // !_NTDDK_
    ULONG       Frames;     // total number of allowable outstanding frames
    ULONG       FrameSize;  // total size of frame
    ULONG       FileAlignment;
    ULONG       Reserved;
} KSALLOCATOR_FRAMING, *PKSALLOCATOR_FRAMING;

#if defined(_NTDDK_)
typedef
PVOID
(*PFNKSDEFAULTALLOCATE)(
    IN PVOID Context
    );

typedef
VOID
(*PFNKSDEFAULTFREE)(
    IN PVOID Context,
    IN PVOID Buffer
    );

typedef
NTSTATUS
(*PFNKSINITIALIZEALLOCATOR)(
    IN PVOID InitialContext,
    IN PKSALLOCATOR_FRAMING AllocatorFraming,
    OUT PVOID* Context
    );

typedef
VOID
(*PFNKSDELETEALLOCATOR)(
    IN PVOID Context
    );
#endif // !_NTDDK_

//
// new Framing structure, eventually will replace KSALLOCATOR_FRAMING.
// 
typedef struct {
    ULONG   MinFrameSize;
    ULONG   MaxFrameSize;
    ULONG   Stepping;
} KS_FRAMING_RANGE, *PKS_FRAMING_RANGE;


typedef struct {
    KS_FRAMING_RANGE  Range;
    ULONG             InPlaceWeight;
    ULONG             NotInPlaceWeight;
} KS_FRAMING_RANGE_WEIGHTED, *PKS_FRAMING_RANGE_WEIGHTED;


typedef struct {
    ULONG   RatioNumerator;      // compression/expansion ratio
    ULONG   RatioDenominator; 
    ULONG   RatioConstantMargin;
} KS_COMPRESSION, *PKS_COMPRESSION;


//
// Memory Types and Buses are repeated in each entry.
// Easiest to use but takes a little more memory than the varsize layout Pin\Memories\Buses\Ranges.
//
typedef struct {
    GUID                        MemoryType;
    GUID                        BusType;
    ULONG                       MemoryFlags;
    ULONG                       BusFlags;   
    ULONG                       Flags;   
    ULONG                       Frames;              // total number of allowable outstanding frames
    ULONG                       FileAlignment;
    ULONG                       MemoryTypeWeight;    // this memory type Weight pin-wide
    KS_FRAMING_RANGE            PhysicalRange;
    KS_FRAMING_RANGE_WEIGHTED   FramingRange; 
} KS_FRAMING_ITEM, *PKS_FRAMING_ITEM;


typedef struct {
    ULONG               CountItems;         // count of FramingItem-s below.
    ULONG               PinFlags;
    KS_COMPRESSION      OutputCompression;
    ULONG               PinWeight;          // this pin framing's Weight graph-wide
    KS_FRAMING_ITEM     FramingItem[1]; 
} KSALLOCATOR_FRAMING_EX, *PKSALLOCATOR_FRAMING_EX;



//
// define memory type GUIDs
//
#define KSMEMORY_TYPE_WILDCARD          GUID_NULL
#define STATIC_KSMEMORY_TYPE_WILDCARD   STATIC_GUID_NULL

#define KSMEMORY_TYPE_DONT_CARE         GUID_NULL
#define STATIC_KSMEMORY_TYPE_DONT_CARE  STATIC_GUID_NULL

#define KS_TYPE_DONT_CARE           GUID_NULL
#define STATIC_KS_TYPE_DONT_CARE    STATIC_GUID_NULL
     
#define STATIC_KSMEMORY_TYPE_SYSTEM \
    0x091bb638L, 0x603f, 0x11d1, 0xb0, 0x67, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("091bb638-603f-11d1-b067-00a0c9062802", KSMEMORY_TYPE_SYSTEM);
#define KSMEMORY_TYPE_SYSTEM  DEFINE_GUIDNAMED(KSMEMORY_TYPE_SYSTEM)

#define STATIC_KSMEMORY_TYPE_USER \
    0x8cb0fc28L, 0x7893, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("8cb0fc28-7893-11d1-b069-00a0c9062802", KSMEMORY_TYPE_USER);
#define KSMEMORY_TYPE_USER  DEFINE_GUIDNAMED(KSMEMORY_TYPE_USER)

#define STATIC_KSMEMORY_TYPE_KERNEL_PAGED \
    0xd833f8f8L, 0x7894, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("d833f8f8-7894-11d1-b069-00a0c9062802", KSMEMORY_TYPE_KERNEL_PAGED);
#define KSMEMORY_TYPE_KERNEL_PAGED  DEFINE_GUIDNAMED(KSMEMORY_TYPE_KERNEL_PAGED)

#define STATIC_KSMEMORY_TYPE_KERNEL_NONPAGED \
    0x4a6d5fc4L, 0x7895, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("4a6d5fc4-7895-11d1-b069-00a0c9062802", KSMEMORY_TYPE_KERNEL_NONPAGED);
#define KSMEMORY_TYPE_KERNEL_NONPAGED  DEFINE_GUIDNAMED(KSMEMORY_TYPE_KERNEL_NONPAGED)

// old KS clients did not specify the device memory type
#define STATIC_KSMEMORY_TYPE_DEVICE_UNKNOWN \
    0x091bb639L, 0x603f, 0x11d1, 0xb0, 0x67, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("091bb639-603f-11d1-b067-00a0c9062802", KSMEMORY_TYPE_DEVICE_UNKNOWN);
#define KSMEMORY_TYPE_DEVICE_UNKNOWN DEFINE_GUIDNAMED(KSMEMORY_TYPE_DEVICE_UNKNOWN)

//
// Helper framing macros.
//
#define DECLARE_SIMPLE_FRAMING_EX(FramingExName, MemoryType, Flags, Frames, Alignment, MinFrameSize, MaxFrameSize) \
    const KSALLOCATOR_FRAMING_EX FramingExName = \
    {\
        1, \
        0, \
        {\
            1, \
            1, \
            0 \
        }, \
        0, \
        {\
            {\
                MemoryType, \
                STATIC_KS_TYPE_DONT_CARE, \
                0, \
                0, \
                Flags, \
                Frames, \
                Alignment, \
                0, \
                {\
                    0, \
                    (ULONG)-1, \
                    1 \
                }, \
                {\
                    {\
                        MinFrameSize, \
                        MaxFrameSize, \
                        1 \
                    }, \
                    0, \
                    0  \
                }\
            }\
        }\
    }

#define SetDefaultKsCompression(KsCompressionPointer) \
{\
    KsCompressionPointer->RatioNumerator = 1;\
    KsCompressionPointer->RatioDenominator = 1;\
    KsCompressionPointer->RatioConstantMargin = 0;\
}

#define SetDontCareKsFramingRange(KsFramingRangePointer) \
{\
    KsFramingRangePointer->MinFrameSize = 0;\
    KsFramingRangePointer->MaxFrameSize = (ULONG) -1;\
    KsFramingRangePointer->Stepping = 1;\
}

#define SetKsFramingRange(KsFramingRangePointer, P_MinFrameSize, P_MaxFrameSize) \
{\
    KsFramingRangePointer->MinFrameSize = P_MinFrameSize;\
    KsFramingRangePointer->MaxFrameSize = P_MaxFrameSize;\
    KsFramingRangePointer->Stepping = 1;\
}

#define SetKsFramingRangeWeighted(KsFramingRangeWeightedPointer, P_MinFrameSize, P_MaxFrameSize) \
{\
    KS_FRAMING_RANGE *KsFramingRange = &KsFramingRangeWeightedPointer->Range;\
    SetKsFramingRange(KsFramingRange, P_MinFrameSize, P_MaxFrameSize);\
    KsFramingRangeWeightedPointer->InPlaceWeight = 0;\
    KsFramingRangeWeightedPointer->NotInPlaceWeight = 0;\
}

#define INITIALIZE_SIMPLE_FRAMING_EX(FramingExPointer, P_MemoryType, P_Flags, P_Frames, P_Alignment, P_MinFrameSize, P_MaxFrameSize) \
{\
    KS_COMPRESSION *KsCompression = &FramingExPointer->OutputCompression;\
    KS_FRAMING_RANGE *KsFramingRange = &FramingExPointer->FramingItem[0].PhysicalRange;\
    KS_FRAMING_RANGE_WEIGHTED *KsFramingRangeWeighted = &FramingExPointer->FramingItem[0].FramingRange;\
    FramingExPointer->CountItems = 1;\
    FramingExPointer->PinFlags = 0;\
    SetDefaultKsCompression(KsCompression);\
    FramingExPointer->PinWeight = 0;\
    FramingExPointer->FramingItem[0].MemoryType = P_MemoryType;\
    FramingExPointer->FramingItem[0].BusType = KS_TYPE_DONT_CARE;\
    FramingExPointer->FramingItem[0].MemoryFlags = 0;\
    FramingExPointer->FramingItem[0].BusFlags = 0;\
    FramingExPointer->FramingItem[0].Flags = P_Flags;\
    FramingExPointer->FramingItem[0].Frames = P_Frames;\
    FramingExPointer->FramingItem[0].FileAlignment = P_Alignment;\
    FramingExPointer->FramingItem[0].MemoryTypeWeight = 0;\
    SetDontCareKsFramingRange(KsFramingRange);\
    SetKsFramingRangeWeighted(KsFramingRangeWeighted, P_MinFrameSize, P_MaxFrameSize);\
}



// KSEVENTSETID_StreamAllocator: {75D95571-073C-11d0-A161-0020AFD156E4}

#define STATIC_KSEVENTSETID_StreamAllocator\
    0x75d95571L, 0x073c, 0x11d0, 0xa1, 0x61, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("75d95571-073c-11d0-a161-0020afd156e4", KSEVENTSETID_StreamAllocator);
#define KSEVENTSETID_StreamAllocator DEFINE_GUIDNAMED(KSEVENTSETID_StreamAllocator)

typedef enum {
    KSEVENT_STREAMALLOCATOR_INTERNAL_FREEFRAME,
    KSEVENT_STREAMALLOCATOR_FREEFRAME
} KSEVENT_STREAMALLOCATOR;

#define STATIC_KSMETHODSETID_StreamAllocator\
    0xcf6e4341L, 0xec87, 0x11cf, 0xa1, 0x30, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("cf6e4341-ec87-11cf-a130-0020afd156e4", KSMETHODSETID_StreamAllocator);
#define KSMETHODSETID_StreamAllocator DEFINE_GUIDNAMED(KSMETHODSETID_StreamAllocator)

typedef enum {
    KSMETHOD_STREAMALLOCATOR_ALLOC,
    KSMETHOD_STREAMALLOCATOR_FREE
} KSMETHOD_STREAMALLOCATOR;

#define DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_ALLOC(Handler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_STREAMALLOCATOR_ALLOC,\
        KSMETHOD_TYPE_WRITE,\
        (Handler),\
        sizeof(KSMETHOD),\
        sizeof(PVOID),\
        NULL)

#define DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_FREE(Handler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_STREAMALLOCATOR_FREE,\
        KSMETHOD_TYPE_READ,\
        (Handler),\
        sizeof(KSMETHOD),\
        sizeof(PVOID),\
        NULL)

#define DEFINE_KSMETHOD_ALLOCATORSET(AllocatorSet, MethodAlloc, MethodFree)\
DEFINE_KSMETHOD_TABLE(AllocatorSet) {\
    DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_ALLOC(MethodAlloc),\
    DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_FREE(MethodFree)\
}

#define STATIC_KSPROPSETID_StreamAllocator\
    0xcf6e4342L, 0xec87, 0x11cf, 0xa1, 0x30, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("cf6e4342-ec87-11cf-a130-0020afd156e4", KSPROPSETID_StreamAllocator);
#define KSPROPSETID_StreamAllocator DEFINE_GUIDNAMED(KSPROPSETID_StreamAllocator)

#if defined(_NTDDK_)
typedef enum {
    KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE,
    KSPROPERTY_STREAMALLOCATOR_STATUS
} KSPROPERTY_STREAMALLOCATOR;

#define DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_FUNCTIONTABLE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSSTREAMALLOCATOR_FUNCTIONTABLE),\
        NULL, NULL, 0, NULL, NULL, 0)
        
#define DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_STATUS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAMALLOCATOR_STATUS,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSSTREAMALLOCATOR_STATUS),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ALLOCATORSET(AllocatorSet, PropFunctionTable, PropStatus)\
DEFINE_KSPROPERTY_TABLE(AllocatorSet) {\
    DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_STATUS(PropStatus),\
    DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_FUNCTIONTABLE(PropFunctionTable)\
}

typedef
NTSTATUS
(*PFNALLOCATOR_ALLOCATEFRAME)(
    IN PFILE_OBJECT FileObject,
    PVOID *Frame
    );

typedef
VOID
(*PFNALLOCATOR_FREEFRAME)(
    IN PFILE_OBJECT FileObject,
    IN PVOID Frame
    );

typedef struct {
    PFNALLOCATOR_ALLOCATEFRAME  AllocateFrame;
    PFNALLOCATOR_FREEFRAME      FreeFrame;
} KSSTREAMALLOCATOR_FUNCTIONTABLE, *PKSSTREAMALLOCATOR_FUNCTIONTABLE;
#endif // defined(_NTDDK_)

typedef struct {
    KSALLOCATOR_FRAMING Framing;
    ULONG               AllocatedFrames;
    ULONG               Reserved;
} KSSTREAMALLOCATOR_STATUS, *PKSSTREAMALLOCATOR_STATUS;

typedef struct {
    KSALLOCATOR_FRAMING_EX Framing;
    ULONG                  AllocatedFrames;
    ULONG                  Reserved;
} KSSTREAMALLOCATOR_STATUS_EX, *PKSSTREAMALLOCATOR_STATUS_EX;


#define KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT        0x00000001
#define KSSTREAM_HEADER_OPTIONSF_PREROLL            0x00000002
#define KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY  0x00000004
#define KSSTREAM_HEADER_OPTIONSF_TYPECHANGED        0x00000008
#define KSSTREAM_HEADER_OPTIONSF_TIMEVALID          0x00000010
#define KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY  0x00000040
#define KSSTREAM_HEADER_OPTIONSF_FLUSHONPAUSE       0x00000080
#define KSSTREAM_HEADER_OPTIONSF_DURATIONVALID      0x00000100
#define KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM        0x00000200
#define KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA         0x80000000

typedef struct {
    LONGLONG    Time;
    ULONG       Numerator;
    ULONG       Denominator;
} KSTIME, *PKSTIME;

typedef struct {
    ULONG       Size;
    ULONG       TypeSpecificFlags;
    KSTIME      PresentationTime;
    LONGLONG    Duration;
    ULONG       FrameExtent;
    ULONG       DataUsed;
    PVOID       Data;
    ULONG       OptionsFlags;
#if _WIN64
    ULONG       Reserved;
#endif
} KSSTREAM_HEADER, *PKSSTREAM_HEADER;

#define STATIC_KSPROPSETID_StreamInterface\
    0x1fdd8ee1L, 0x9cd3, 0x11d0, 0x82, 0xaa, 0x00, 0x00, 0xf8, 0x22, 0xfe, 0x8a
DEFINE_GUIDSTRUCT("1fdd8ee1-9cd3-11d0-82aa-0000f822fe8a", KSPROPSETID_StreamInterface);
#define KSPROPSETID_StreamInterface DEFINE_GUIDNAMED(KSPROPSETID_StreamInterface)

typedef enum {
    KSPROPERTY_STREAMINTERFACE_HEADERSIZE
} KSPROPERTY_STREAMINTERFACE;

#define DEFINE_KSPROPERTY_ITEM_STREAMINTERFACE_HEADERSIZE( GetHandler )\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAMINTERFACE_HEADERSIZE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)
        
#define DEFINE_KSPROPERTY_STREAMINTERFACESET(StreamInterfaceSet,\
    HeaderSizeHandler)\
DEFINE_KSPROPERTY_TABLE(StreamInterfaceSet) {\
    DEFINE_KSPROPERTY_ITEM_STREAMINTERFACE_HEADERSIZE( HeaderSizeHandler )\
}

#define STATIC_KSPROPSETID_Stream\
    0x65aaba60L, 0x98ae, 0x11cf, 0xa1, 0x0d, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("65aaba60-98ae-11cf-a10d-0020afd156e4", KSPROPSETID_Stream);
#define KSPROPSETID_Stream DEFINE_GUIDNAMED(KSPROPSETID_Stream)

typedef enum {
    KSPROPERTY_STREAM_ALLOCATOR,
    KSPROPERTY_STREAM_QUALITY,
    KSPROPERTY_STREAM_DEGRADATION,
    KSPROPERTY_STREAM_MASTERCLOCK,
    KSPROPERTY_STREAM_TIMEFORMAT,
    KSPROPERTY_STREAM_PRESENTATIONTIME,
    KSPROPERTY_STREAM_PRESENTATIONEXTENT,
    KSPROPERTY_STREAM_FRAMETIME,
    KSPROPERTY_STREAM_RATECAPABILITY,
    KSPROPERTY_STREAM_RATE,
    KSPROPERTY_STREAM_PIPE_ID
} KSPROPERTY_STREAM;

#define DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_ALLOCATOR,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(HANDLE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_QUALITY(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_QUALITY,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSQUALITY_MANAGER),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_DEGRADATION(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_DEGRADATION,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_MASTERCLOCK,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(HANDLE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_TIMEFORMAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_TIMEFORMAT,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(GUID),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONTIME(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_PRESENTATIONTIME,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSTIME),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONEXTENT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_PRESENTATIONEXTENT,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_FRAMETIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_FRAMETIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSFRAMETIME),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_RATECAPABILITY(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_RATECAPABILITY,\
        (Handler),\
        sizeof(KSRATE_CAPABILITY),\
        sizeof(KSRATE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_RATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_RATE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSRATE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_PIPE_ID(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_PIPE_ID,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(HANDLE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

typedef struct {
    HANDLE      QualityManager;
    PVOID       Context;
} KSQUALITY_MANAGER, *PKSQUALITY_MANAGER;

typedef struct {
    LONGLONG    Duration;
    ULONG       FrameFlags;
    ULONG       Reserved;
} KSFRAMETIME, *PKSFRAMETIME;

#define KSFRAMETIME_VARIABLESIZE    0x00000001

typedef struct {
    LONGLONG        PresentationStart;
    LONGLONG        Duration;
    KSPIN_INTERFACE Interface;
    LONG            Rate;
    ULONG           Flags;
} KSRATE, *PKSRATE;

#define KSRATE_NOPRESENTATIONSTART      0x00000001
#define KSRATE_NOPRESENTATIONDURATION   0x00000002

typedef struct {
    KSPROPERTY      Property;
    KSRATE          Rate;
} KSRATE_CAPABILITY, *PKSRATE_CAPABILITY;

#define STATIC_KSPROPSETID_Clock \
    0xDF12A4C0L, 0xAC17, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("DF12A4C0-AC17-11CF-A5D6-28DB04C10000", KSPROPSETID_Clock);
#define KSPROPSETID_Clock DEFINE_GUIDNAMED(KSPROPSETID_Clock)

//
// Performs a x*y/z operation on 64 bit quantities by splitting the operation. The equation
// is simplified with respect to adding in the remainder for the upper 32 bits.
//
// (xh * 10000000 / Frequency) * 2^32 + ((((xh * 10000000) % Frequency) * 2^32 + (xl * 10000000)) / Frequency)
//
#define NANOSECONDS 10000000
#define KSCONVERT_PERFORMANCE_TIME(Frequency, PerformanceTime) \
    ((((ULONGLONG)(ULONG)(PerformanceTime).HighPart * NANOSECONDS / (Frequency)) << 32) + \
    ((((((ULONGLONG)(ULONG)(PerformanceTime).HighPart * NANOSECONDS) % (Frequency)) << 32) + \
    ((ULONGLONG)(PerformanceTime).LowPart * NANOSECONDS)) / (Frequency)))

typedef struct {
    ULONG       CreateFlags;
} KSCLOCK_CREATE, *PKSCLOCK_CREATE;

typedef struct {
    LONGLONG    Time;
    LONGLONG    SystemTime;
} KSCORRELATED_TIME, *PKSCORRELATED_TIME;

typedef struct {
    LONGLONG    Granularity;
    LONGLONG    Error;
} KSRESOLUTION, *PKSRESOLUTION;

typedef enum {
    KSPROPERTY_CLOCK_TIME,
    KSPROPERTY_CLOCK_PHYSICALTIME,
    KSPROPERTY_CLOCK_CORRELATEDTIME,
    KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME,
    KSPROPERTY_CLOCK_RESOLUTION,
    KSPROPERTY_CLOCK_STATE,
#if defined(_NTDDK_)
    KSPROPERTY_CLOCK_FUNCTIONTABLE
#endif // defined(_NTDDK_)
} KSPROPERTY_CLOCK;

#if defined(_NTDDK_)

typedef
LONGLONG
(FASTCALL *PFNKSCLOCK_GETTIME)(
    IN PFILE_OBJECT FileObject
    );
typedef
LONGLONG
(FASTCALL *PFNKSCLOCK_CORRELATEDTIME)(
    IN PFILE_OBJECT FileObject,
    OUT PLONGLONG SystemTime);

typedef struct {
    PFNKSCLOCK_GETTIME GetTime;
    PFNKSCLOCK_GETTIME GetPhysicalTime;
    PFNKSCLOCK_CORRELATEDTIME GetCorrelatedTime;
    PFNKSCLOCK_CORRELATEDTIME GetCorrelatedPhysicalTime;
} KSCLOCK_FUNCTIONTABLE, *PKSCLOCK_FUNCTIONTABLE;

typedef
BOOLEAN
(*PFNKSSETTIMER)(
    IN PVOID Context,
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc
    );

typedef
BOOLEAN
(*PFNKSCANCELTIMER)(
    IN PVOID Context,
    IN PKTIMER Timer
    );

typedef
LONGLONG
(FASTCALL *PFNKSCORRELATEDTIME)(
    IN PVOID Context,
    OUT PLONGLONG SystemTime);

typedef PVOID   PKSDEFAULTCLOCK;

#define DEFINE_KSPROPERTY_ITEM_CLOCK_TIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_TIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_PHYSICALTIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_PHYSICALTIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_CORRELATEDTIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSCORRELATED_TIME),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSCORRELATED_TIME),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_RESOLUTION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_RESOLUTION,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSRESOLUTION),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_STATE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_STATE,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSSTATE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_FUNCTIONTABLE,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSCLOCK_FUNCTIONTABLE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_CLOCKSET(ClockSet,\
    PropTime, PropPhysicalTime,\
    PropCorrelatedTime, PropCorrelatedPhysicalTime,\
    PropResolution, PropState, PropFunctionTable)\
DEFINE_KSPROPERTY_TABLE(ClockSet) {\
    DEFINE_KSPROPERTY_ITEM_CLOCK_TIME(PropTime),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_PHYSICALTIME(PropPhysicalTime),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(PropCorrelatedTime),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(PropCorrelatedPhysicalTime),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_RESOLUTION(PropResolution),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_STATE(PropState),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(PropFunctionTable),\
}

#endif // defined(_NTDDK_)

#define STATIC_KSEVENTSETID_Clock \
    0x364D8E20L, 0x62C7, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("364D8E20-62C7-11CF-A5D6-28DB04C10000", KSEVENTSETID_Clock);
#define KSEVENTSETID_Clock DEFINE_GUIDNAMED(KSEVENTSETID_Clock)

typedef enum {
    KSEVENT_CLOCK_INTERVAL_MARK,
    KSEVENT_CLOCK_POSITION_MARK
} KSEVENT_CLOCK_POSITION;

#define STATIC_KSEVENTSETID_Connection\
    0x7f4bcbe0L, 0x9ea5, 0x11cf, 0xa5, 0xd6, 0x28, 0xdb, 0x04, 0xc1, 0x00, 0x00
DEFINE_GUIDSTRUCT("7f4bcbe0-9ea5-11cf-a5d6-28db04c10000", KSEVENTSETID_Connection);
#define KSEVENTSETID_Connection DEFINE_GUIDNAMED(KSEVENTSETID_Connection)

typedef enum {
    KSEVENT_CONNECTION_POSITIONUPDATE,
    KSEVENT_CONNECTION_DATADISCONTINUITY,
    KSEVENT_CONNECTION_TIMEDISCONTINUITY,
    KSEVENT_CONNECTION_PRIORITY,
    KSEVENT_CONNECTION_ENDOFSTREAM
} KSEVENT_CONNECTION;

typedef struct {
    PVOID       Context;
    ULONG       Proportion;
    LONGLONG    DeltaTime;
} KSQUALITY, *PKSQUALITY;

typedef struct {
    PVOID       Context;
    ULONG       Status;
} KSERROR, *PKSERROR;

typedef KSIDENTIFIER KSDEGRADE, *PKSDEGRADE;

#define STATIC_KSDEGRADESETID_Standard\
    0x9F564180L, 0x704C, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("9F564180-704C-11D0-A5D6-28DB04C10000", KSDEGRADESETID_Standard);
#define KSDEGRADESETID_Standard DEFINE_GUIDNAMED(KSDEGRADESETID_Standard)

typedef enum {
    KSDEGRADE_STANDARD_SAMPLE,
    KSDEGRADE_STANDARD_QUALITY,
    KSDEGRADE_STANDARD_COMPUTATION,
    KSDEGRADE_STANDARD_SKIP
} KSDEGRADE_STANDARD;

#if defined(_NTDDK_)

#define KSPROBE_STREAMREAD      0x00000000
#define KSPROBE_STREAMWRITE     0x00000001
#define KSPROBE_ALLOCATEMDL     0x00000010
#define KSPROBE_PROBEANDLOCK    0x00000020
#define KSPROBE_SYSTEMADDRESS   0x00000040
#define KSPROBE_MODIFY          0x00000200
#define KSPROBE_STREAMWRITEMODIFY (KSPROBE_MODIFY | KSPROBE_STREAMWRITE)
#define KSPROBE_ALLOWFORMATCHANGE   0x00000080

#define KSSTREAM_READ           KSPROBE_STREAMREAD
#define KSSTREAM_WRITE          KSPROBE_STREAMWRITE
#define KSSTREAM_PAGED_DATA     0x00000000
#define KSSTREAM_NONPAGED_DATA  0x00000100
#define KSSTREAM_SYNCHRONOUS    0x00001000
#define KSSTREAM_FAILUREEXCEPTION 0x00002000

typedef
NTSTATUS
(*PFNKSCONTEXT_DISPATCH)(
    IN PVOID Context,
    IN PIRP Irp
    );

typedef
NTSTATUS
(*PFNKSHANDLER)(
    IN PIRP Irp,
    IN PKSIDENTIFIER Request,
    IN OUT PVOID Data
    );

typedef
BOOLEAN
(*PFNKSFASTHANDLER)(
    IN PFILE_OBJECT FileObject,
    IN PKSIDENTIFIER UNALIGNED Request,
    IN ULONG RequestLength,
    IN OUT PVOID UNALIGNED Data,
    IN ULONG DataLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

typedef
NTSTATUS
(*PFNKSALLOCATOR)(
    IN PIRP Irp,
    IN ULONG BufferSize,
    IN BOOLEAN InputOperation
    );

typedef struct {
    KSPROPERTY_MEMBERSHEADER    MembersHeader;
    const VOID*                 Members;
} KSPROPERTY_MEMBERSLIST, *PKSPROPERTY_MEMBERSLIST;

typedef struct {
    KSIDENTIFIER                    PropTypeSet;
    ULONG                           MembersListCount;
    const KSPROPERTY_MEMBERSLIST*   MembersList;
} KSPROPERTY_VALUES, *PKSPROPERTY_VALUES;

#define DEFINE_KSPROPERTY_TABLE(tablename)\
    const KSPROPERTY_ITEM tablename[] =

#define DEFINE_KSPROPERTY_ITEM(PropertyId, GetHandler,\
                               MinProperty,\
                               MinData,\
                               SetHandler,\
                               Values, RelationsCount, Relations, SupportHandler,\
                               SerializedSize)\
{\
    PropertyId, (PFNKSHANDLER)GetHandler, MinProperty, MinData,\
    (PFNKSHANDLER)SetHandler,\
    (PKSPROPERTY_VALUES)Values, RelationsCount, (PKSPROPERTY)Relations,\
    (PFNKSHANDLER)SupportHandler, (ULONG)SerializedSize\
}

typedef struct {
    ULONG                   PropertyId;
    union {
        PFNKSHANDLER            GetPropertyHandler;
        BOOLEAN                 GetSupported;
    };
    ULONG                   MinProperty;
    ULONG                   MinData;
    union {
        PFNKSHANDLER            SetPropertyHandler;
        BOOLEAN                 SetSupported;
    };
    const KSPROPERTY_VALUES*Values;
    ULONG                   RelationsCount;
    const KSPROPERTY*       Relations;
    PFNKSHANDLER            SupportHandler;
    ULONG                   SerializedSize;
} KSPROPERTY_ITEM, *PKSPROPERTY_ITEM;

#define DEFINE_KSFASTPROPERTY_ITEM(PropertyId, GetHandler, SetHandler)\
{\
    PropertyId, (PFNKSFASTHANDLER)GetHandler, (PFNKSFASTHANDLER)SetHandler, 0\
}

typedef struct {
    ULONG                       PropertyId;
    union {
        PFNKSFASTHANDLER            GetPropertyHandler;
        BOOLEAN                     GetSupported;
    };
    union {
        PFNKSFASTHANDLER            SetPropertyHandler;
        BOOLEAN                     SetSupported;
    };
    ULONG                       Reserved;
} KSFASTPROPERTY_ITEM, *PKSFASTPROPERTY_ITEM;

#define DEFINE_KSPROPERTY_SET(Set,\
                              PropertiesCount,\
                              PropertyItem,\
                              FastIoCount,\
                              FastIoTable)\
{\
    Set,\
    PropertiesCount,\
    PropertyItem,\
    FastIoCount,\
    FastIoTable\
}

#define DEFINE_KSPROPERTY_SET_TABLE(tablename)\
    const KSPROPERTY_SET tablename[] =

typedef struct {
    const GUID*                 Set;
    ULONG                       PropertiesCount;
    const KSPROPERTY_ITEM*      PropertyItem;
    ULONG                       FastIoCount;
    const KSFASTPROPERTY_ITEM*  FastIoTable;
} KSPROPERTY_SET, *PKSPROPERTY_SET;

#define DEFINE_KSMETHOD_TABLE(tablename)\
    const KSMETHOD_ITEM tablename[] =

#define DEFINE_KSMETHOD_ITEM(MethodId, Flags,\
                             MethodHandler,\
                             MinMethod, MinData, SupportHandler)\
{\
    MethodId, (PFNKSHANDLER)MethodHandler, MinMethod, MinData,\
    SupportHandler, Flags\
}

typedef struct {
    ULONG                   MethodId;
    union {
        PFNKSHANDLER            MethodHandler;
        BOOLEAN                 MethodSupported;
    };
    ULONG                   MinMethod;
    ULONG                   MinData;
    PFNKSHANDLER            SupportHandler;
    ULONG                   Flags;
} KSMETHOD_ITEM, *PKSMETHOD_ITEM;

#define DEFINE_KSFASTMETHOD_ITEM(MethodId, MethodHandler)\
{\
    MethodId, (PFNKSFASTHANDLER)MethodHandler\
}

typedef struct {
    ULONG                   MethodId;
    union {
        PFNKSFASTHANDLER        MethodHandler;
        BOOLEAN                 MethodSupported;
    };
} KSFASTMETHOD_ITEM, *PKSFASTMETHOD_ITEM;

#define DEFINE_KSMETHOD_SET(Set,\
                            MethodsCount,\
                            MethodItem,\
                            FastIoCount,\
                            FastIoTable)\
{\
    Set,\
    MethodsCount,\
    MethodItem,\
    FastIoCount,\
    FastIoTable\
}

#define DEFINE_KSMETHOD_SET_TABLE(tablename)\
    const KSMETHOD_SET tablename[] =

typedef struct {
    const GUID*             Set;
    ULONG                   MethodsCount;
    const KSMETHOD_ITEM*    MethodItem;
    ULONG                   FastIoCount;
    const KSFASTMETHOD_ITEM*FastIoTable;
} KSMETHOD_SET, *PKSMETHOD_SET;

typedef struct _KSEVENT_ENTRY
KSEVENT_ENTRY, *PKSEVENT_ENTRY;

typedef
NTSTATUS
(*PFNKSADDEVENT)(
    IN PIRP Irp,
    IN PKSEVENTDATA EventData,
    IN struct _KSEVENT_ENTRY* EventEntry
    );

typedef
VOID
(*PFNKSREMOVEEVENT)(
    IN PFILE_OBJECT FileObject,
    IN struct _KSEVENT_ENTRY* EventEntry
    );
    
#define DEFINE_KSEVENT_TABLE(tablename)\
    const KSEVENT_ITEM tablename[] =

#define DEFINE_KSEVENT_ITEM(EventId, DataInput, ExtraEntryData,\
                            AddHandler, RemoveHandler, SupportHandler)\
{\
    EventId,\
    DataInput,\
    ExtraEntryData,\
    AddHandler,\
    RemoveHandler,\
    SupportHandler\
}

typedef struct {
    ULONG               EventId;
    ULONG               DataInput;
    ULONG               ExtraEntryData;
    PFNKSADDEVENT       AddHandler;
    PFNKSREMOVEEVENT    RemoveHandler;
    PFNKSHANDLER        SupportHandler;
} KSEVENT_ITEM, *PKSEVENT_ITEM;

#define DEFINE_KSEVENT_SET(Set,\
                           EventsCount,\
                           EventItem)\
{\
    Set, EventsCount, EventItem\
}

#define DEFINE_KSEVENT_SET_TABLE(tablename)\
    const KSEVENT_SET tablename[] =

typedef struct {
    const GUID*         Set;
    ULONG               EventsCount;
    const KSEVENT_ITEM* EventItem;
} KSEVENT_SET, *PKSEVENT_SET;

typedef struct {
    KDPC            Dpc;
    ULONG           ReferenceCount;
    KSPIN_LOCK      AccessLock;
} KSDPC_ITEM, *PKSDPC_ITEM;

typedef struct {
    KSDPC_ITEM          DpcItem;
    LIST_ENTRY          BufferList;
} KSBUFFER_ITEM, *PKSBUFFER_ITEM;

#define KSEVENT_ENTRY_DELETED   1
#define KSEVENT_ENTRY_ONESHOT   2
#define KSEVENT_ENTRY_BUFFERED  4

struct _KSEVENT_ENTRY {
    LIST_ENTRY      ListEntry;
    PVOID           Object;
    union {
        PKSDPC_ITEM         DpcItem;
        PKSBUFFER_ITEM      BufferItem;
    };
    PKSEVENTDATA        EventData;
    ULONG               NotificationType;
    const KSEVENT_SET*  EventSet;
    const KSEVENT_ITEM* EventItem;
    PFILE_OBJECT        FileObject;
    ULONG               SemaphoreAdjustment;
    ULONG               Reserved;
    ULONG               Flags;
};

typedef enum {
    KSEVENTS_NONE,
    KSEVENTS_SPINLOCK,
    KSEVENTS_MUTEX,
    KSEVENTS_FMUTEX,
    KSEVENTS_FMUTEXUNSAFE,
    KSEVENTS_INTERRUPT,
    KSEVENTS_ERESOURCE
} KSEVENTS_LOCKTYPE;

#define KSDISPATCH_FASTIO       0x80000000

typedef struct {
    PDRIVER_DISPATCH        Create;
    PVOID                   Context;
    UNICODE_STRING          ObjectClass;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;
    ULONG                   Flags;
} KSOBJECT_CREATE_ITEM, *PKSOBJECT_CREATE_ITEM;

typedef
VOID
(*PFNKSITEMFREECALLBACK)(
    IN PKSOBJECT_CREATE_ITEM CreateItem
    );

#define KSCREATE_ITEM_SECURITYCHANGED       0x00000001
#define KSCREATE_ITEM_WILDCARD              0x00000002
#define KSCREATE_ITEM_NOPARAMETERS          0x00000004
#define KSCREATE_ITEM_FREEONSTOP            0x00000008

#define DEFINE_KSCREATE_DISPATCH_TABLE( tablename )\
    KSOBJECT_CREATE_ITEM tablename[] =

#define DEFINE_KSCREATE_ITEM(DispatchCreate, TypeName, Context)\
{\
    (DispatchCreate),\
    (PVOID)(Context),\
    {\
        sizeof(TypeName) - sizeof(UNICODE_NULL),\
        sizeof(TypeName),\
        (PWCHAR)(TypeName)\
    },\
    NULL, 0\
}

#define DEFINE_KSCREATE_ITEMEX(DispatchCreate, TypeName, Context, Flags)\
{\
    (DispatchCreate),\
    (PVOID)(Context),\
    {\
        sizeof(TypeName) - sizeof(UNICODE_NULL),\
        sizeof(TypeName),\
        (PWCHAR)(TypeName)\
    },\
    NULL, (Flags)\
}

#define DEFINE_KSCREATE_ITEMNULL( DispatchCreate, Context )\
{\
    DispatchCreate,\
    Context,\
    {\
        0,\
        0,\
        NULL,\
    },\
    NULL, 0\
}

typedef struct {
    ULONG                    CreateItemsCount;
    PKSOBJECT_CREATE_ITEM    CreateItemsList;
} KSOBJECT_CREATE, *PKSOBJECT_CREATE;

typedef struct {
    PDRIVER_DISPATCH        DeviceIoControl;
    PDRIVER_DISPATCH        Read;
    PDRIVER_DISPATCH        Write;
    PDRIVER_DISPATCH        Flush;
    PDRIVER_DISPATCH        Close;
    PDRIVER_DISPATCH        QuerySecurity;
    PDRIVER_DISPATCH        SetSecurity;
    PFAST_IO_DEVICE_CONTROL FastDeviceIoControl;
    PFAST_IO_READ           FastRead;
    PFAST_IO_WRITE          FastWrite;
} KSDISPATCH_TABLE, *PKSDISPATCH_TABLE;

#define DEFINE_KSDISPATCH_TABLE( tablename, DeviceIoControl, Read, Write,\
                                 Flush, Close, QuerySecurity, SetSecurity,\
                                 FastDeviceIoControl, FastRead, FastWrite  )\
    const KSDISPATCH_TABLE tablename = \
    {\
        DeviceIoControl,        \
        Read,                   \
        Write,                  \
        Flush,                  \
        Close,                  \
        QuerySecurity,          \
        SetSecurity,            \
        FastDeviceIoControl,    \
        FastRead,               \
        FastWrite,              \
    }

#define KSCREATE_ITEM_IRP_STORAGE(Irp)      ((PKSOBJECT_CREATE_ITEM)(Irp)->Tail.Overlay.DriverContext[0])
#define KSEVENT_SET_IRP_STORAGE(Irp)        ((const KSEVENT_SET*)(Irp)->Tail.Overlay.DriverContext[0])
#define KSEVENT_ITEM_IRP_STORAGE(Irp)       ((const KSEVENT_ITEM*)(Irp)->Tail.Overlay.DriverContext[3])
#define KSEVENT_ENTRY_IRP_STORAGE(Irp)      ((PKSEVENT_ENTRY)(Irp)->Tail.Overlay.DriverContext[0])
#define KSMETHOD_SET_IRP_STORAGE(Irp)       ((const KSMETHOD_SET*)(Irp)->Tail.Overlay.DriverContext[0])
#define KSMETHOD_ITEM_IRP_STORAGE(Irp)      ((const KSMETHOD_ITEM*)(Irp)->Tail.Overlay.DriverContext[3])
#define KSMETHOD_TYPE_IRP_STORAGE(Irp)      ((ULONG_PTR)((Irp)->Tail.Overlay.DriverContext[2]))
#define KSQUEUE_SPINLOCK_IRP_STORAGE(Irp)   ((PKSPIN_LOCK)(Irp)->Tail.Overlay.DriverContext[1])
#define KSPROPERTY_SET_IRP_STORAGE(Irp)     ((const KSPROPERTY_SET*)(Irp)->Tail.Overlay.DriverContext[0])
#define KSPROPERTY_ITEM_IRP_STORAGE(Irp)    ((const KSPROPERTY_ITEM*)(Irp)->Tail.Overlay.DriverContext[3])
#define KSPROPERTY_ATTRIBUTES_IRP_STORAGE(Irp) ((PKSATTRIBUTE_LIST)(Irp)->Tail.Overlay.DriverContext[2])

typedef PVOID   KSDEVICE_HEADER, KSOBJECT_HEADER;

typedef enum {
    KsInvokeOnSuccess = 1,
    KsInvokeOnError = 2,
    KsInvokeOnCancel = 4
} KSCOMPLETION_INVOCATION;

typedef enum {
    KsListEntryTail,
    KsListEntryHead
} KSLIST_ENTRY_LOCATION;

typedef enum {
    KsAcquireOnly,
    KsAcquireAndRemove,
    KsAcquireOnlySingleItem,
    KsAcquireAndRemoveOnlySingleItem
} KSIRP_REMOVAL_OPERATION;

typedef enum {
    KsStackCopyToNewLocation,
    KsStackReuseCurrentLocation,
    KsStackUseNewLocation
} KSSTACK_USE;

typedef enum {
    KSTARGET_STATE_DISABLED,
    KSTARGET_STATE_ENABLED
} KSTARGET_STATE;

typedef
NTSTATUS
(*PFNKSIRPLISTCALLBACK)(
    IN PIRP Irp,
    IN PVOID Context
    );

typedef 
VOID 
(*PFNREFERENCEDEVICEOBJECT)( 
    IN PVOID Context
    );
    
typedef 
VOID 
(*PFNDEREFERENCEDEVICEOBJECT)( 
    IN PVOID Context
    );
    
typedef
NTSTATUS
(*PFNQUERYREFERENCESTRING)( 
    IN PVOID Context,
    IN OUT PWCHAR *String
    );

#define BUS_INTERFACE_REFERENCE_VERSION    0x100
    
typedef struct {
    //
    // Standard interface header
    //
    
    INTERFACE                   Interface;
    
    //
    // Standard bus interfaces
    //
    
    PFNREFERENCEDEVICEOBJECT    ReferenceDeviceObject;
    PFNDEREFERENCEDEVICEOBJECT  DereferenceDeviceObject;
    PFNQUERYREFERENCESTRING     QueryReferenceString;
    
} BUS_INTERFACE_REFERENCE, *PBUS_INTERFACE_REFERENCE;

#define STATIC_REFERENCE_BUS_INTERFACE STATIC_KSMEDIUMSETID_Standard
#define REFERENCE_BUS_INTERFACE KSMEDIUMSETID_Standard

typedef
NTSTATUS
(*PFNQUERYMEDIUMSLIST)( 
    IN PVOID Context,
    OUT ULONG* MediumsCount,
    OUT PKSPIN_MEDIUM* MediumList
    );

typedef struct {
    //
    // Standard interface header
    //
    
    INTERFACE                   Interface;
    
    //
    // Interface definition
    //
    
    PFNQUERYMEDIUMSLIST         QueryMediumsList;
    
} BUS_INTERFACE_MEDIUMS, *PBUS_INTERFACE_MEDIUMS;

#define STATIC_GUID_BUS_INTERFACE_MEDIUMS \
    0x4EC35C3EL, 0x201B, 0x11D2, 0x87, 0x45, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4EC35C3E-201B-11D2-8745-00A0C9223196", GUID_BUS_INTERFACE_MEDIUMS);
#define GUID_BUS_INTERFACE_MEDIUMS DEFINE_GUIDNAMED(GUID_BUS_INTERFACE_MEDIUMS)

#endif // defined(_NTDDK_)

#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif

typedef struct {
    GUID            PropertySet;
    ULONG           Count;
} KSPROPERTY_SERIALHDR, *PKSPROPERTY_SERIALHDR;

#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif

typedef struct {
    KSIDENTIFIER    PropTypeSet;
    ULONG           Id;
    ULONG           PropertyLength;
} KSPROPERTY_SERIAL, *PKSPROPERTY_SERIAL;

// @@BEGIN_DDKSPLIT
#if defined(_NTDDK_)

#define IOCTL_KS_HANDSHAKE             CTL_CODE(FILE_DEVICE_KS, 0x007, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct {
    GUID ProtocolId;
    PVOID Argument1;
    PVOID Argument2;
} KSHANDSHAKE, *PKSHANDSHAKE;

typedef struct _KSGATE
KSGATE, *PKSGATE;

struct _KSGATE {
    LONG Count;
    PKSGATE NextGate;
};

#ifndef _NTOS_

void __inline
KsGateTurnInputOn(
    IN PKSGATE Gate OPTIONAL
    )
{
    while (Gate && (InterlockedIncrement(&Gate->Count) == 1)) {
        Gate = Gate->NextGate;
    }
}

void __inline
KsGateTurnInputOff(
    IN PKSGATE Gate OPTIONAL
    )
{
    while (Gate && (InterlockedDecrement(&Gate->Count) == 0)) {
        Gate = Gate->NextGate;
    }
}

BOOLEAN __inline
KsGateGetStateUnsafe(
    IN PKSGATE Gate
    )
{
    ASSERT(Gate);
    return Gate->Count > 0;
}

BOOLEAN __inline
KsGateCaptureThreshold(
    IN PKSGATE Gate
    )
{
    BOOLEAN captured;

    ASSERT(Gate);

    captured = (InterlockedCompareExchange(&Gate->Count,0,1) == 1);
    
    //
    // If we made a transition, it must be propagated.
    //
    if (captured) {
        KsGateTurnInputOff(Gate->NextGate);
    }

    //
    // We return whatever the state was prior to the compare/exchange.  If
    // the state was on, the state is now off.
    //
    return captured;
}

void __inline
KsGateInitialize(
    IN PKSGATE Gate,
    IN LONG InitialCount,
    IN PKSGATE NextGate OPTIONAL,
    IN BOOLEAN StateToPropagate // IN BOOLEAN NextGateIsAnOrGate
    )
{
    ASSERT(Gate);
    Gate->Count = InitialCount;
    Gate->NextGate = NextGate;

    if (NextGate) {
        if (InitialCount > 0) {
            if (StateToPropagate) {
                KsGateTurnInputOn(NextGate);
            }
        } else {
            if (! StateToPropagate) {
                KsGateTurnInputOff(NextGate);
            }
        }
    }
}

void __inline
KsGateInitializeAnd(
    IN PKSGATE AndGate,
    IN PKSGATE NextOrGate OPTIONAL
    )
{
    KsGateInitialize(AndGate,1,NextOrGate,TRUE);
}

void __inline
KsGateInitializeOr(
    IN PKSGATE OrGate,
    IN PKSGATE NextAndGate OPTIONAL
    )
{
    KsGateInitialize(OrGate,0,NextAndGate,FALSE);
}

void __inline KsGateAddOnInputToAnd(IN PKSGATE AndGate) {}
void __inline KsGateAddOffInputToAnd(IN PKSGATE AndGate) { KsGateTurnInputOff(AndGate); }
void __inline KsGateRemoveOnInputFromAnd(IN PKSGATE AndGate) {}
void __inline KsGateRemoveOffInputFromAnd(IN PKSGATE AndGate) { KsGateTurnInputOn(AndGate); }

void __inline KsGateAddOnInputToOr(IN PKSGATE OrGate) { KsGateTurnInputOn(OrGate); }
void __inline KsGateAddOffInputToOr(IN PKSGATE OrGate) {}
void __inline KsGateRemoveOnInputFromOr(IN PKSGATE OrGate) { KsGateTurnInputOff(OrGate); }
void __inline KsGateRemoveOffInputFromOr(IN PKSGATE OrGate) {}

void __inline
KsGateTerminateAnd(
    IN PKSGATE AndGate
    )
{
    ASSERT(AndGate);
    if (KsGateGetStateUnsafe(AndGate)) {
        KsGateRemoveOnInputFromOr(AndGate->NextGate);
    } else {
        KsGateRemoveOffInputFromOr(AndGate->NextGate);
    }
}

void __inline
KsGateTerminateOr(
    IN PKSGATE OrGate
    )
{
    ASSERT(OrGate);
    if (KsGateGetStateUnsafe(OrGate)) {
        KsGateRemoveOnInputFromAnd(OrGate->NextGate);
    } else {
        KsGateRemoveOffInputFromAnd(OrGate->NextGate);
    }
}

#endif // !_NTOS_

typedef PVOID KSOBJECT_BAG;

typedef
BOOLEAN
(*PFNKSGENERATEEVENTCALLBACK)(
    IN PVOID Context,
    IN PKSEVENT_ENTRY EventEntry
    );

typedef
NTSTATUS
(*PFNKSDEVICECREATE)(
    IN PKSDEVICE Device
    );
typedef
NTSTATUS
(*PFNKSDEVICEPNPSTART)(
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN PCM_RESOURCE_LIST TranslatedResourceList OPTIONAL,
    IN PCM_RESOURCE_LIST UntranslatedResourceList OPTIONAL
    );
typedef
NTSTATUS
(*PFNKSDEVICE)(
    IN PKSDEVICE Device
    );
typedef
NTSTATUS
(*PFNKSDEVICEIRP)(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );
typedef
void
(*PFNKSDEVICEIRPVOID)(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );
typedef
NTSTATUS
(*PFNKSDEVICEQUERYCAPABILITIES)(
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN OUT PDEVICE_CAPABILITIES Capabilities
    );
typedef
NTSTATUS
(*PFNKSDEVICEQUERYPOWER)(
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN DEVICE_POWER_STATE DeviceTo,
    IN DEVICE_POWER_STATE DeviceFrom,
    IN SYSTEM_POWER_STATE SystemTo,
    IN SYSTEM_POWER_STATE SystemFrom,
    IN POWER_ACTION Action
    );
typedef
void
(*PFNKSDEVICESETPOWER)(
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN DEVICE_POWER_STATE To,
    IN DEVICE_POWER_STATE From
    );
typedef
NTSTATUS
(*PFNKSFILTERFACTORYVOID)(
    IN PKSFILTERFACTORY FilterFactory
    );
typedef
void
(*PFNKSFILTERFACTORYPOWER)(
    IN PKSFILTERFACTORY FilterFactory,
    IN DEVICE_POWER_STATE State
    );
typedef
NTSTATUS
(*PFNKSFILTERIRP)(
    IN PKSFILTER Filter,
    IN PIRP Irp
    );
typedef
NTSTATUS
(*PFNKSFILTERPROCESS)(
    IN PKSFILTER Filter,
    IN PKSPROCESSPIN_INDEXENTRY Index
    );
typedef
NTSTATUS
(*PFNKSFILTERVOID)(
    IN PKSFILTER Filter
    );
typedef
void
(*PFNKSFILTERPOWER)(
    IN PKSFILTER Filter,
    IN DEVICE_POWER_STATE State
    );
typedef
NTSTATUS
(*PFNKSPINIRP)(
    IN PKSPIN Pin,
    IN PIRP Irp
    );
typedef
NTSTATUS
(*PFNKSPINSETDEVICESTATE)(
    IN PKSPIN Pin,
    IN KSSTATE ToState,
    IN KSSTATE FromState
    );
typedef
NTSTATUS
(*PFNKSPINSETDATAFORMAT)(
    IN PKSPIN Pin,
    IN PKSDATAFORMAT OldFormat OPTIONAL,
    IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
    IN const KSDATARANGE* DataRange,
    IN const KSATTRIBUTE_LIST* AttributeRange OPTIONAL
    );
typedef
NTSTATUS
(*PFNKSPINHANDSHAKE)(
    IN PKSPIN Pin,
    IN PKSHANDSHAKE In,
    IN PKSHANDSHAKE Out
    );
typedef
NTSTATUS
(*PFNKSPIN)(
    IN PKSPIN Pin
    );
typedef
void
(*PFNKSPINVOID)(
    IN PKSPIN Pin
    );
typedef
void
(*PFNKSPINPOWER)(
    IN PKSPIN Pin,
    IN DEVICE_POWER_STATE State
    );
typedef
BOOLEAN
(*PFNKSPINSETTIMER)(
    IN PKSPIN Pin,
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc
    );
typedef
BOOLEAN
(*PFNKSPINCANCELTIMER)(
    IN PKSPIN Pin,
    IN PKTIMER Timer
    );
typedef
LONGLONG
(FASTCALL *PFNKSPINCORRELATEDTIME)(
    IN PKSPIN Pin,
    OUT PLONGLONG SystemTime
    );
typedef
void
(*PFNKSPINRESOLUTION)(
    IN PKSPIN Pin,
    OUT PKSRESOLUTION Resolution
    );
typedef
NTSTATUS
(*PFNKSPININITIALIZEALLOCATOR)(
    IN PKSPIN Pin,
    IN PKSALLOCATOR_FRAMING AllocatorFraming,
    OUT PVOID* Context
    );
typedef
void
(*PFNKSSTREAMPOINTER)(
    IN PKSSTREAM_POINTER StreamPointer
    );

typedef struct KSAUTOMATION_TABLE_ 
KSAUTOMATION_TABLE, *PKSAUTOMATION_TABLE;
struct KSAUTOMATION_TABLE_ {
    ULONG PropertySetsCount;
    ULONG PropertyItemSize;
    const KSPROPERTY_SET* PropertySets;
    ULONG MethodSetsCount;
    ULONG MethodItemSize;
    const KSMETHOD_SET* MethodSets;
    ULONG EventSetsCount;
    ULONG EventItemSize;
    const KSEVENT_SET* EventSets;
#if !defined(_WIN64)
    PVOID Alignment;
#endif // !defined(_WIN64)
};

#define DEFINE_KSAUTOMATION_TABLE(table)\
    const KSAUTOMATION_TABLE table =

#define DEFINE_KSAUTOMATION_PROPERTIES(table)\
    SIZEOF_ARRAY(table),\
    sizeof(KSPROPERTY_ITEM),\
    table

#define DEFINE_KSAUTOMATION_METHODS(table)\
    SIZEOF_ARRAY(table),\
    sizeof(KSMETHOD_ITEM),\
    table

#define DEFINE_KSAUTOMATION_EVENTS(table)\
    SIZEOF_ARRAY(table),\
    sizeof(KSEVENT_ITEM),\
    table

#define DEFINE_KSAUTOMATION_PROPERTIES_NULL\
    0,\
    sizeof(KSPROPERTY_ITEM),\
    NULL

#define DEFINE_KSAUTOMATION_METHODS_NULL\
    0,\
    sizeof(KSMETHOD_ITEM),\
    NULL

#define DEFINE_KSAUTOMATION_EVENTS_NULL\
    0,\
    sizeof(KSEVENT_ITEM),\
    NULL

#define MIN_DEV_VER_FOR_QI (0x100)

struct _KSDEVICE_DISPATCH {
    PFNKSDEVICECREATE Add;
    PFNKSDEVICEPNPSTART Start;
    PFNKSDEVICE PostStart;
    PFNKSDEVICEIRP QueryStop;
    PFNKSDEVICEIRPVOID CancelStop;
    PFNKSDEVICEIRPVOID Stop;
    PFNKSDEVICEIRP QueryRemove;
    PFNKSDEVICEIRPVOID CancelRemove;
    PFNKSDEVICEIRPVOID Remove;
    PFNKSDEVICEQUERYCAPABILITIES QueryCapabilities;
    PFNKSDEVICEIRPVOID SurpriseRemoval;
    PFNKSDEVICEQUERYPOWER QueryPower;
    PFNKSDEVICESETPOWER SetPower;
    PFNKSDEVICEIRP QueryInterface;  // added in version 0x100
};

struct _KSFILTER_DISPATCH {
    PFNKSFILTERIRP Create;
    PFNKSFILTERIRP Close;
    PFNKSFILTERPROCESS Process;
    PFNKSFILTERVOID Reset;
};

struct _KSPIN_DISPATCH {
    PFNKSPINIRP Create;
    PFNKSPINIRP Close;
    PFNKSPIN Process;
    PFNKSPINVOID Reset;
    PFNKSPINSETDATAFORMAT SetDataFormat;
    PFNKSPINSETDEVICESTATE SetDeviceState;
    PFNKSPIN Connect;
    PFNKSPINVOID Disconnect;
    const KSCLOCK_DISPATCH* Clock;
    const KSALLOCATOR_DISPATCH* Allocator;
};

struct _KSCLOCK_DISPATCH {
    PFNKSPINSETTIMER SetTimer;
    PFNKSPINCANCELTIMER CancelTimer;
    PFNKSPINCORRELATEDTIME CorrelatedTime;
    PFNKSPINRESOLUTION Resolution;
};

struct _KSALLOCATOR_DISPATCH {
    PFNKSPININITIALIZEALLOCATOR InitializeAllocator;
    PFNKSDELETEALLOCATOR DeleteAllocator;
    PFNKSDEFAULTALLOCATE Allocate;
    PFNKSDEFAULTFREE Free;
};

#define KSDEVICE_DESCRIPTOR_VERSION (0x100)

struct _KSDEVICE_DESCRIPTOR {
    const KSDEVICE_DISPATCH* Dispatch;
    ULONG FilterDescriptorsCount;
    const KSFILTER_DESCRIPTOR*const* FilterDescriptors;
    ULONG Version; // this is 0 for pre-version 100 driver
    //#if !defined(_WIN64)
    //PVOID Alignment;
    //#endif //!defined(_WIN64)
};

struct _KSFILTER_DESCRIPTOR {
    const KSFILTER_DISPATCH* Dispatch;
    const KSAUTOMATION_TABLE* AutomationTable;
    ULONG Version;
#define KSFILTER_DESCRIPTOR_VERSION ((ULONG)-1)
    ULONG Flags;
#define KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING 0x00000001
#define KSFILTER_FLAG_CRITICAL_PROCESSING 0x00000002
#define KSFILTER_FLAG_HYPERCRITICAL_PROCESSING 0x00000004
    const GUID* ReferenceGuid;
    ULONG PinDescriptorsCount;
    ULONG PinDescriptorSize;
    const KSPIN_DESCRIPTOR_EX* PinDescriptors;
    ULONG CategoriesCount;
    const GUID* Categories;
    ULONG NodeDescriptorsCount;
    ULONG NodeDescriptorSize;
    const KSNODE_DESCRIPTOR* NodeDescriptors;
    ULONG ConnectionsCount;
    const KSTOPOLOGY_CONNECTION* Connections;
    const KSCOMPONENTID* ComponentId;
};

#define DEFINE_KSFILTER_DESCRIPTOR(descriptor)\
    const KSFILTER_DESCRIPTOR descriptor =

#define DEFINE_KSFILTER_PIN_DESCRIPTORS(table)\
    SIZEOF_ARRAY(table),\
    sizeof(table[0]),\
    table

#define DEFINE_KSFILTER_CATEGORIES(table)\
    SIZEOF_ARRAY(table),\
    table

#define DEFINE_KSFILTER_CATEGORY(category)\
    1,\
    &(category)

#define DEFINE_KSFILTER_CATEGORIES_NULL\
    0,\
    NULL

#define DEFINE_KSFILTER_NODE_DESCRIPTORS(table)\
    SIZEOF_ARRAY(table),\
    sizeof(table[0]),\
    table

#define DEFINE_KSFILTER_NODE_DESCRIPTORS_NULL\
    0,\
    sizeof(KSNODE_DESCRIPTOR),\
    NULL

#define DEFINE_KSFILTER_CONNECTIONS(table)\
    SIZEOF_ARRAY(table),\
    table

#define DEFINE_KSFILTER_DEFAULT_CONNECTIONS\
    0,\
    NULL

#define DEFINE_KSFILTER_DESCRIPTOR_TABLE(table)\
    const KSFILTER_DESCRIPTOR*const table[] =

struct _KSPIN_DESCRIPTOR_EX {
    const KSPIN_DISPATCH* Dispatch;
    const KSAUTOMATION_TABLE* AutomationTable;
    KSPIN_DESCRIPTOR PinDescriptor;
    ULONG Flags;
#define KSPIN_FLAG_DISPATCH_LEVEL_PROCESSING KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING
#define KSPIN_FLAG_CRITICAL_PROCESSING KSFILTER_FLAG_CRITICAL_PROCESSING
#define KSPIN_FLAG_HYPERCRITICAL_PROCESSING KSFILTER_FLAG_HYPERCRITICAL_PROCESSING
#define KSPIN_FLAG_ASYNCHRONOUS_PROCESSING 0x00000008
#define KSPIN_FLAG_DO_NOT_INITIATE_PROCESSING 0x00000010
#define KSPIN_FLAG_INITIATE_PROCESSING_ON_EVERY_ARRIVAL 0x00000020
#define KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING 0x00000040
#define KSPIN_FLAG_ENFORCE_FIFO 0x00000080

#define KSPIN_FLAG_GENERATE_MAPPINGS 0x00000100
#define KSPIN_FLAG_DISTINCT_TRAILING_EDGE 0x00000200

#define KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY 0x00010000
#define KSPIN_FLAG_SPLITTER 0x00020000
#define KSPIN_FLAG_USE_STANDARD_TRANSPORT 0x00040000
#define KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT 0x00080000
#define KSPIN_FLAG_FIXED_FORMAT 0x00100000
#define KSPIN_FLAG_GENERATE_EOS_EVENTS 0x00200000
#define KSPIN_FLAG_RENDERER (KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY|KSPIN_FLAG_GENERATE_EOS_EVENTS)
#define KSPIN_FLAG_IMPLEMENT_CLOCK 0x00400000
    ULONG InstancesPossible;
    ULONG InstancesNecessary;
    const KSALLOCATOR_FRAMING_EX* AllocatorFraming;
    PFNKSINTERSECTHANDLEREX IntersectHandler;
};

#define DEFINE_KSPIN_DEFAULT_INTERFACES\
    0,\
    NULL

#define DEFINE_KSPIN_DEFAULT_MEDIUMS\
    0,\
    NULL

struct _KSNODE_DESCRIPTOR {
    const KSAUTOMATION_TABLE* AutomationTable;
    const GUID* Type;
    const GUID* Name;
#if !defined(_WIN64)
    PVOID Alignment;
#endif // !defined(_WIN64)
};

#if !defined(_WIN64)
#define DEFINE_NODE_DESCRIPTOR(automation,type,name) \
    { (automation), (type), (name), NULL }
#else // !defined(_WIN64)
#define DEFINE_NODE_DESCRIPTOR(automation,type,name) \
    { (automation), (type), (name) }
#endif // !defined(_WIN64)

struct _KSDEVICE {
    const KSDEVICE_DESCRIPTOR* Descriptor;
    KSOBJECT_BAG Bag;
    PVOID Context;
    PDEVICE_OBJECT FunctionalDeviceObject;
    PDEVICE_OBJECT PhysicalDeviceObject;
    PDEVICE_OBJECT NextDeviceObject;
    BOOLEAN Started;
    SYSTEM_POWER_STATE SystemPowerState;
    DEVICE_POWER_STATE DevicePowerState;
};

struct _KSFILTERFACTORY {
    const KSFILTER_DESCRIPTOR* FilterDescriptor;
    KSOBJECT_BAG Bag;
    PVOID Context;
};

struct _KSFILTER {
    const KSFILTER_DESCRIPTOR* Descriptor;
    KSOBJECT_BAG Bag;
    PVOID Context;
};

struct _KSPIN {
    const KSPIN_DESCRIPTOR_EX* Descriptor;
    KSOBJECT_BAG Bag;
    PVOID Context;
    ULONG Id;
    KSPIN_COMMUNICATION Communication;
    BOOLEAN ConnectionIsExternal;
    KSPIN_INTERFACE ConnectionInterface;
    KSPIN_MEDIUM ConnectionMedium;
    KSPRIORITY ConnectionPriority;
    PKSDATAFORMAT ConnectionFormat;
    PKSMULTIPLE_ITEM AttributeList;
    ULONG StreamHeaderSize;
    KSPIN_DATAFLOW DataFlow;
    KSSTATE DeviceState;
    KSRESET ResetState;
};

struct _KSMAPPING {
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG ByteCount;
    ULONG Alignment;
};

struct _KSSTREAM_POINTER_OFFSET
{
#if defined(_NTDDK_)
    union {
        PUCHAR Data;
        PKSMAPPING Mappings;
    };
#else // !defined(_NTDDK_)
    PUCHAR Data;
#endif // !defined(_NTDDK_)
#if !defined(_WIN64)
    PVOID Alignment;
#endif // !defined(_WIN64)
    ULONG Count;
    ULONG Remaining;
};

struct _KSSTREAM_POINTER
{
    PVOID Context;
    PKSPIN Pin;
    PKSSTREAM_HEADER StreamHeader;
    PKSSTREAM_POINTER_OFFSET Offset;
    KSSTREAM_POINTER_OFFSET OffsetIn;
    KSSTREAM_POINTER_OFFSET OffsetOut;
};

struct _KSPROCESSPIN {
    PKSPIN Pin;
    PKSSTREAM_POINTER StreamPointer;
    PKSPROCESSPIN InPlaceCounterpart;
    PKSPROCESSPIN DelegateBranch;
    PKSPROCESSPIN CopySource;
    PVOID Data;
    ULONG BytesAvailable;
    ULONG BytesUsed;
    ULONG Flags;
    BOOLEAN Terminate;
};

struct _KSPROCESSPIN_INDEXENTRY {
    PKSPROCESSPIN *Pins;
    ULONG Count;
};

typedef enum {
    KsObjectTypeDevice,
    KsObjectTypeFilterFactory,
    KsObjectTypeFilter,
    KsObjectTypePin
} KSOBJECTTYPE;

typedef
void
(*PFNKSFREE)(
    IN PVOID Data
    );

typedef
void
(*PFNKSPINFRAMERETURN)(
    IN PKSPIN Pin,
    IN PVOID Data OPTIONAL,
    IN ULONG Size OPTIONAL,
    IN PMDL Mdl OPTIONAL,
    IN PVOID Context OPTIONAL,
    IN NTSTATUS Status
    );

#if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)
#if !defined(_IKsControl_)
#define _IKsControl_

typedef interface IKsControl* PIKSCONTROL;

#if !defined(DEFINE_ABSTRACT_UNKNOWN)

#define DEFINE_ABSTRACT_UNKNOWN()                               \
    STDMETHOD_(NTSTATUS, QueryInterface)(THIS_                   \
        REFIID InterfaceId,                                     \
        PVOID* Interface                                        \
        ) PURE;                                                 \
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;                        \
    STDMETHOD_(ULONG,Release)(THIS) PURE;

#endif //!defined(DEFINE_ABSTRACT_UNKNOWN)

#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN() // For C

    STDMETHOD_(NTSTATUS, KsProperty)(THIS_
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT PVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        ) PURE;
    STDMETHOD_(NTSTATUS, KsMethod)(THIS_
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT PVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        ) PURE;
    STDMETHOD_(NTSTATUS, KsEvent)(THIS_
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT PVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        ) PURE;
};

typedef interface IKsReferenceClock* PIKSREFERENCECLOCK;

#undef INTERFACE
#define INTERFACE IKsReferenceClock
DECLARE_INTERFACE_(IKsReferenceClock,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN() // For C

    STDMETHOD_(LONGLONG,GetTime)(THIS
        ) PURE;
    STDMETHOD_(LONGLONG,GetPhysicalTime)(THIS
        ) PURE;
    STDMETHOD_(LONGLONG,GetCorrelatedTime)(THIS_
        OUT PLONGLONG SystemTime
        ) PURE;
    STDMETHOD_(LONGLONG,GetCorrelatedPhysicalTime)(THIS_
        OUT PLONGLONG SystemTime
        ) PURE;
    STDMETHOD_(NTSTATUS, GetResolution)(THIS_
        OUT PKSRESOLUTION Resolution
        ) PURE;
    STDMETHOD_(NTSTATUS, GetState)(THIS_
        OUT PKSSTATE State
        ) PURE;
};
#undef INTERFACE

#define STATIC_IID_IKsControl \
0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUID(IID_IKsControl,
0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("28F54685-06FD-11D2-B27A-00A0C9223196")) IKsControl;
#endif

#define STATIC_IID_IKsFastClock \
0xc9902485, 0xc180, 0x11d2, 0x84, 0x73, 0xd4, 0x23, 0x94, 0x45, 0x9e, 0x5e
DEFINE_GUID(IID_IKsFastClock,
0xc9902485, 0xc180, 0x11d2, 0x84, 0x73, 0xd4, 0x23, 0x94, 0x45, 0x9e, 0x5e);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("C9902485-C180-11d2-8473-D42394459E5E")) IKsFastClock;
#endif

#endif // !defined(_IKsControl_)
#endif // defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

#endif // defined(_NTDDK_)

// @@END_DDKSPLIT
//===========================================================================

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)

//
// exported prototypes
//

#ifdef _KSDDK_
#define KSDDKAPI
#else // !_KSDDK_
#define KSDDKAPI DECLSPEC_IMPORT
#endif // _KSDDK_

#if defined(_NTDDK_)

KSDDKAPI
NTSTATUS
NTAPI
KsEnableEvent(
    IN PIRP Irp,
    IN ULONG EventSetsCount,
    IN const KSEVENT_SET* EventSet,
    IN OUT PLIST_ENTRY EventsList OPTIONAL,
    IN KSEVENTS_LOCKTYPE EventsFlags OPTIONAL,
    IN PVOID EventsLock OPTIONAL
    );

KSDDKAPI
NTSTATUS
NTAPI
KsEnableEventWithAllocator(
    IN PIRP Irp,
    IN ULONG EventSetsCount,
    IN const KSEVENT_SET* EventSet,
    IN OUT PLIST_ENTRY EventsList OPTIONAL,
    IN KSEVENTS_LOCKTYPE EventsFlags OPTIONAL,
    IN PVOID EventsLock OPTIONAL,
    IN PFNKSALLOCATOR Allocator OPTIONAL,
    IN ULONG EventItemSize OPTIONAL
    );

KSDDKAPI
NTSTATUS
NTAPI
KsDisableEvent(
    IN PIRP Irp,
    IN OUT PLIST_ENTRY EventsList,
    IN KSEVENTS_LOCKTYPE EventsFlags,
    IN PVOID EventsLock
    );

KSDDKAPI
VOID
NTAPI
KsDiscardEvent(
    IN PKSEVENT_ENTRY EventEntry
    );

KSDDKAPI
VOID
NTAPI
KsFreeEventList(
    IN PFILE_OBJECT FileObject,
    IN OUT PLIST_ENTRY EventsList,
    IN KSEVENTS_LOCKTYPE EventsFlags,
    IN PVOID EventsLock
    );

KSDDKAPI
NTSTATUS
NTAPI
KsGenerateEvent(
    IN PKSEVENT_ENTRY EventEntry
    );

KSDDKAPI
NTSTATUS
NTAPI
KsGenerateDataEvent(
    IN PKSEVENT_ENTRY EventEntry,
    IN ULONG DataSize,
    IN PVOID Data
    );

KSDDKAPI
VOID
NTAPI
KsGenerateEventList(
    IN GUID* Set OPTIONAL,
    IN ULONG EventId,
    IN PLIST_ENTRY EventsList,
    IN KSEVENTS_LOCKTYPE EventsFlags,
    IN PVOID EventsLock
    );

// property.c:

KSDDKAPI
NTSTATUS
NTAPI
KsPropertyHandler(
    IN PIRP Irp,
    IN ULONG PropertySetsCount,
    IN const KSPROPERTY_SET* PropertySet
    );

KSDDKAPI
NTSTATUS
NTAPI
KsPropertyHandlerWithAllocator(
    IN PIRP Irp,
    IN ULONG PropertySetsCount,
    IN const KSPROPERTY_SET* PropertySet,
    IN PFNKSALLOCATOR Allocator OPTIONAL,
    IN ULONG PropertyItemSize OPTIONAL
    );

KSDDKAPI
BOOLEAN
NTAPI
KsFastPropertyHandler(
    IN PFILE_OBJECT FileObject,
    IN PKSPROPERTY UNALIGNED Property,
    IN ULONG PropertyLength,
    IN OUT PVOID UNALIGNED Data,
    IN ULONG DataLength,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN ULONG PropertySetsCount,
    IN const KSPROPERTY_SET* PropertySet
    );

// method.c:

KSDDKAPI
NTSTATUS
NTAPI
KsMethodHandler(
    IN PIRP Irp,
    IN ULONG MethodSetsCount,
    IN const KSMETHOD_SET* MethodSet
    );

KSDDKAPI
NTSTATUS
NTAPI
KsMethodHandlerWithAllocator(
    IN PIRP Irp,
    IN ULONG MethodSetsCount,
    IN const KSMETHOD_SET* MethodSet,
    IN PFNKSALLOCATOR Allocator OPTIONAL,
    IN ULONG MethodItemSize OPTIONAL
    );

KSDDKAPI
BOOLEAN
NTAPI
KsFastMethodHandler(
    IN PFILE_OBJECT FileObject,
    IN PKSMETHOD UNALIGNED Method,
    IN ULONG MethodLength,
    IN OUT PVOID UNALIGNED Data,
    IN ULONG DataLength,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN ULONG MethodSetsCount,
    IN const KSMETHOD_SET* MethodSet
    );

// alloc.c:

KSDDKAPI
NTSTATUS
NTAPI
KsCreateDefaultAllocator(
    IN PIRP Irp
    );

KSDDKAPI
NTSTATUS
NTAPI
KsCreateDefaultAllocatorEx(
    IN PIRP Irp,
    IN PVOID InitializeContext OPTIONAL,
    IN PFNKSDEFAULTALLOCATE DefaultAllocate OPTIONAL,
    IN PFNKSDEFAULTFREE DefaultFree OPTIONAL,
    IN PFNKSINITIALIZEALLOCATOR InitializeAllocator OPTIONAL,
    IN PFNKSDELETEALLOCATOR DeleteAllocator OPTIONAL
    );

KSDDKAPI
NTSTATUS
NTAPI
KsCreateAllocator(
    IN HANDLE ConnectionHandle,
    IN PKSALLOCATOR_FRAMING AllocatorFraming,
    OUT PHANDLE AllocatorHandle
    );

KSDDKAPI
NTSTATUS
NTAPI
KsValidateAllocatorCreateRequest(
    IN PIRP Irp,
    OUT PKSALLOCATOR_FRAMING* AllocatorFraming
    );

KSDDKAPI
NTSTATUS
NTAPI
KsValidateAllocatorFramingEx(
    IN PKSALLOCATOR_FRAMING_EX Framing,
    IN ULONG BufferSize,
    IN const KSALLOCATOR_FRAMING_EX *PinFraming
    );

// clock.c:

KSDDKAPI
NTSTATUS
NTAPI
KsAllocateDefaultClock(
    OUT PKSDEFAULTCLOCK* DefaultClock
    );

KSDDKAPI
NTSTATUS
NTAPI
KsAllocateDefaultClockEx(
    OUT PKSDEFAULTCLOCK* DefaultClock,
    IN PVOID Context OPTIONAL,
    IN PFNKSSETTIMER SetTimer OPTIONAL,
    IN PFNKSCANCELTIMER CancelTimer OPTIONAL,
    IN PFNKSCORRELATEDTIME CorrelatedTime OPTIONAL,
    IN const KSRESOLUTION* Resolution OPTIONAL,
    IN ULONG Flags
    );

KSDDKAPI
VOID
NTAPI
KsFreeDefaultClock(
    IN PKSDEFAULTCLOCK DefaultClock
    );

KSDDKAPI
NTSTATUS
NTAPI
KsCreateDefaultClock(
    IN PIRP Irp,
    IN PKSDEFAULTCLOCK DefaultClock
    );

KSDDKAPI
NTSTATUS
NTAPI
KsCreateClock(
    IN HANDLE ConnectionHandle,
    IN PKSCLOCK_CREATE ClockCreate,
    OUT PHANDLE ClockHandle
    );

KSDDKAPI
NTSTATUS
NTAPI
KsValidateClockCreateRequest(
    IN PIRP Irp,
    OUT PKSCLOCK_CREATE* ClockCreate
    );

KSDDKAPI
KSSTATE
NTAPI
KsGetDefaultClockState(
    IN PKSDEFAULTCLOCK DefaultClock
    );

KSDDKAPI
VOID
NTAPI
KsSetDefaultClockState(
    IN PKSDEFAULTCLOCK DefaultClock,
    IN KSSTATE State
    );

KSDDKAPI
LONGLONG
NTAPI
KsGetDefaultClockTime(
    IN PKSDEFAULTCLOCK DefaultClock
    );

KSDDKAPI
VOID
NTAPI
KsSetDefaultClockTime(
    IN PKSDEFAULTCLOCK DefaultClock,
    IN LONGLONG Time
    );

// connect.c:

KSDDKAPI
NTSTATUS
NTAPI
KsCreatePin(
    IN HANDLE FilterHandle,
    IN PKSPIN_CONNECT Connect,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE ConnectionHandle
    );

KSDDKAPI
NTSTATUS
NTAPI
KsValidateConnectRequest(
    IN PIRP Irp,
    IN ULONG DescriptorsCount,
    IN const KSPIN_DESCRIPTOR* Descriptor,
    OUT PKSPIN_CONNECT* Connect
    );

KSDDKAPI
NTSTATUS
NTAPI
KsPinPropertyHandler(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PVOID Data,
    IN ULONG DescriptorsCount,
    IN const KSPIN_DESCRIPTOR* Descriptor
    );

KSDDKAPI
NTSTATUS
NTAPI
KsPinDataIntersection(
    IN PIRP Irp,
    IN PKSP_PIN Pin,
    OUT PVOID Data OPTIONAL,
    IN ULONG DescriptorsCount,
    IN const KSPIN_DESCRIPTOR* Descriptor,
    IN PFNKSINTERSECTHANDLER IntersectHandler
    );

KSDDKAPI
NTSTATUS
NTAPI
KsPinDataIntersectionEx(
    IN PIRP Irp,
    IN PKSP_PIN Pin,
    OUT PVOID Data,
    IN ULONG DescriptorsCount,
    IN const KSPIN_DESCRIPTOR* Descriptor,
    IN ULONG DescriptorSize,
    IN PFNKSINTERSECTHANDLEREX IntersectHandler OPTIONAL,
    IN PVOID HandlerContext OPTIONAL
    );

KSDDKAPI
NTSTATUS
NTAPI
KsHandleSizedListQuery(
    IN PIRP Irp,
    IN ULONG DataItemsCount,
    IN ULONG DataItemSize,
    IN const VOID* DataItems
    );

// image.c:

#if (!defined( MAKEINTRESOURCE )) 
#define MAKEINTRESOURCE( res ) ((ULONG_PTR) (USHORT) res)
#endif

#if (!defined( RT_STRING ))
#define RT_STRING           MAKEINTRESOURCE( 6 )
#define RT_RCDATA           MAKEINTRESOURCE( 10 ) 
#endif

KSDDKAPI
NTSTATUS
NTAPI
KsLoadResource(
    IN PVOID ImageBase,
    IN POOL_TYPE PoolType,
    IN ULONG_PTR ResourceName,
    IN ULONG ResourceType,
    OUT PVOID *Resource,
    OUT PULONG ResourceSize            
    );
    
KSDDKAPI
NTSTATUS
NTAPI
KsGetImageNameAndResourceId(
    IN HANDLE RegKey,
    OUT PUNICODE_STRING ImageName,                
    OUT PULONG_PTR ResourceId,
    OUT PULONG ValueType
);

KSDDKAPI
NTSTATUS
NTAPI
KsMapModuleName(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PUNICODE_STRING ModuleName,
    OUT PUNICODE_STRING ImageName,                
    OUT PULONG_PTR ResourceId,
    OUT PULONG ValueType
    );
    
// irp.c:

KSDDKAPI
NTSTATUS
NTAPI
KsReferenceBusObject(
    IN KSDEVICE_HEADER  Header
    );

KSDDKAPI
VOID
NTAPI
KsDereferenceBusObject(
    IN KSDEVICE_HEADER  Header
    );

KSDDKAPI
NTSTATUS
NTAPI
KsDispatchQuerySecurity(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

KSDDKAPI
NTSTATUS
NTAPI
KsDispatchSetSecurity(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

KSDDKAPI
NTSTATUS
NTAPI
KsDispatchSpecificProperty(
    IN PIRP Irp,
    IN PFNKSHANDLER Handler
    );

KSDDKAPI
NTSTATUS
NTAPI
KsDispatchSpecificMethod(
    IN PIRP Irp,
    IN PFNKSHANDLER Handler
    );

KSDDKAPI
NTSTATUS
NTAPI
KsReadFile(
    IN PFILE_OBJECT FileObject,
    IN PKEVENT Event OPTIONAL,
    IN PVOID PortContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN ULONG Key OPTIONAL,
    IN KPROCESSOR_MODE RequestorMode
    );

KSDDKAPI
NTSTATUS
NTAPI
KsWriteFile(
    IN PFILE_OBJECT FileObject,
    IN PKEVENT Event OPTIONAL,
    IN PVOID PortContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Key OPTIONAL,
    IN KPROCESSOR_MODE RequestorMode
    );

KSDDKAPI
NTSTATUS
NTAPI
KsQueryInformationFile(
    IN PFILE_OBJECT FileObject,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

KSDDKAPI
NTSTATUS
NTAPI
KsSetInformationFile(
    IN PFILE_OBJECT FileObject,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

KSDDKAPI
NTSTATUS
NTAPI
KsStreamIo(
    IN PFILE_OBJECT FileObject,
    IN PKEVENT Event OPTIONAL,
    IN PVOID PortContext OPTIONAL,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
    IN PVOID CompletionContext OPTIONAL,
    IN KSCOMPLETION_INVOCATION CompletionInvocationFlags OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN OUT PVOID StreamHeaders,
    IN ULONG Length,
    IN ULONG Flags,
    IN KPROCESSOR_MODE RequestorMode
    );

KSDDKAPI
NTSTATUS
NTAPI
KsProbeStreamIrp(
    IN OUT PIRP Irp,
    IN ULONG ProbeFlags,
    IN ULONG HeaderSize OPTIONAL
    );

KSDDKAPI
NTSTATUS
NTAPI
KsAllocateExtraData(
    IN OUT PIRP Irp,
    IN ULONG ExtraSize,
    OUT PVOID* ExtraBuffer
    );

KSDDKAPI
VOID
NTAPI
KsNullDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

KSDDKAPI
NTSTATUS
NTAPI
KsSetMajorFunctionHandler(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG MajorFunction
    );

KSDDKAPI
NTSTATUS
NTAPI
KsDispatchInvalidDeviceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

KSDDKAPI
NTSTATUS
NTAPI
KsDefaultDeviceIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

KSDDKAPI
NTSTATUS
NTAPI
KsDispatchIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

KSDDKAPI
BOOLEAN
NTAPI
KsDispatchFastIoDeviceControlFailure(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

KSDDKAPI
BOOLEAN
NTAPI
KsDispatchFastReadFailure(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

#define KsDispatchFastWriteFailure KsDispatchFastReadFailure

KSDDKAPI
VOID
NTAPI
KsCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

KSDDKAPI
VOID
NTAPI
KsCancelIo(   
    IN OUT PLIST_ENTRY  QueueHead,
    IN PKSPIN_LOCK SpinLock
    );

KSDDKAPI
VOID
NTAPI
KsReleaseIrpOnCancelableQueue(
    IN PIRP Irp,
    IN PDRIVER_CANCEL DriverCancel OPTIONAL
    );

KSDDKAPI
PIRP
NTAPI
KsRemoveIrpFromCancelableQueue(
    IN OUT PLIST_ENTRY QueueHead,
    IN PKSPIN_LOCK SpinLock,
    IN KSLIST_ENTRY_LOCATION ListLocation,
    IN KSIRP_REMOVAL_OPERATION RemovalOperation
    );

KSDDKAPI
NTSTATUS
NTAPI
KsMoveIrpsOnCancelableQueue(
    IN OUT PLIST_ENTRY SourceList,
    IN PKSPIN_LOCK SourceLock,
    IN OUT PLIST_ENTRY DestinationList,
    IN PKSPIN_LOCK DestinationLock OPTIONAL,
    IN KSLIST_ENTRY_LOCATION ListLocation,
    IN PFNKSIRPLISTCALLBACK ListCallback,
    IN PVOID Context
    );

KSDDKAPI
VOID
NTAPI
KsRemoveSpecificIrpFromCancelableQueue(
    IN PIRP Irp
    );

KSDDKAPI
VOID
NTAPI
KsAddIrpToCancelableQueue(
    IN OUT PLIST_ENTRY QueueHead,
    IN PKSPIN_LOCK SpinLock,
    IN PIRP Irp,
    IN KSLIST_ENTRY_LOCATION ListLocation,
    IN PDRIVER_CANCEL DriverCancel OPTIONAL
    );

// api.c:

KSDDKAPI
NTSTATUS
NTAPI
KsAcquireResetValue(
    IN PIRP Irp,
    OUT KSRESET* ResetValue
    );

KSDDKAPI
NTSTATUS
NTAPI
KsTopologyPropertyHandler(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PVOID Data,
    IN const KSTOPOLOGY* Topology
    );

KSDDKAPI
VOID
NTAPI
KsAcquireDeviceSecurityLock(
    IN KSDEVICE_HEADER Header,
    IN BOOLEAN Exclusive
    );

KSDDKAPI
VOID
NTAPI
KsReleaseDeviceSecurityLock(
    IN KSDEVICE_HEADER Header
    );
    
KSDDKAPI
NTSTATUS
NTAPI
KsDefaultDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

KSDDKAPI
NTSTATUS
NTAPI
KsDefaultDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
KSDDKAPI
NTSTATUS
NTAPI
KsDefaultForwardIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

KSDDKAPI
VOID
NTAPI
KsSetDevicePnpAndBaseObject(
    IN KSDEVICE_HEADER Header,
    IN PDEVICE_OBJECT PnpDeviceObject,
    IN PDEVICE_OBJECT BaseObject
    );

KSDDKAPI
PDEVICE_OBJECT
NTAPI
KsQueryDevicePnpObject(
    IN KSDEVICE_HEADER Header
    );

KSDDKAPI
ACCESS_MASK
NTAPI
KsQueryObjectAccessMask(
    IN KSOBJECT_HEADER Header
    );

KSDDKAPI
VOID
NTAPI
KsRecalculateStackDepth(
    IN KSDEVICE_HEADER Header,
    IN BOOLEAN ReuseStackLocation
    );

KSDDKAPI
VOID
NTAPI
KsSetTargetState(
    IN KSOBJECT_HEADER Header,
    IN KSTARGET_STATE TargetState
    );

KSDDKAPI
VOID
NTAPI
KsSetTargetDeviceObject(
    IN KSOBJECT_HEADER Header,
    IN PDEVICE_OBJECT TargetDevice OPTIONAL
    );

KSDDKAPI
VOID
NTAPI
KsSetPowerDispatch(
    IN KSOBJECT_HEADER Header,
    IN PFNKSCONTEXT_DISPATCH PowerDispatch OPTIONAL,
    IN PVOID PowerContext OPTIONAL
    );

KSDDKAPI
PKSOBJECT_CREATE_ITEM
NTAPI
KsQueryObjectCreateItem(
    IN KSOBJECT_HEADER Header
    );

KSDDKAPI
NTSTATUS
NTAPI
KsAllocateDeviceHeader(
    OUT KSDEVICE_HEADER* Header,
    IN ULONG ItemsCount,
    IN PKSOBJECT_CREATE_ITEM ItemsList OPTIONAL
    );

KSDDKAPI
VOID
NTAPI
KsFreeDeviceHeader(
    IN KSDEVICE_HEADER Header
    );

KSDDKAPI
NTSTATUS
NTAPI
KsAllocateObjectHeader(
    OUT KSOBJECT_HEADER* Header,
    IN ULONG ItemsCount,
    IN PKSOBJECT_CREATE_ITEM ItemsList OPTIONAL,
    IN PIRP Irp,
    IN const KSDISPATCH_TABLE* Table
    );

KSDDKAPI
VOID
NTAPI
KsFreeObjectHeader(
    IN KSOBJECT_HEADER Header
    );

KSDDKAPI
NTSTATUS
NTAPI
KsAddObjectCreateItemToDeviceHeader(
    IN KSDEVICE_HEADER Header,
    IN PDRIVER_DISPATCH Create,
    IN PVOID Context,
    IN PWCHAR ObjectClass,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL
    );

KSDDKAPI
NTSTATUS
NTAPI
KsAddObjectCreateItemToObjectHeader(
    IN KSOBJECT_HEADER Header,
    IN PDRIVER_DISPATCH Create,
    IN PVOID Context,
    IN PWCHAR ObjectClass,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL
    );

KSDDKAPI
NTSTATUS
NTAPI
KsAllocateObjectCreateItem(
    IN KSDEVICE_HEADER Header,
    IN PKSOBJECT_CREATE_ITEM CreateItem,
    IN BOOLEAN AllocateEntry,
    IN PFNKSITEMFREECALLBACK ItemFreeCallback OPTIONAL
    );

KSDDKAPI
NTSTATUS
NTAPI
KsFreeObjectCreateItem(
    IN KSDEVICE_HEADER Header,
    IN PUNICODE_STRING CreateItem
    );

KSDDKAPI
NTSTATUS
NTAPI
KsFreeObjectCreateItemsByContext(
    IN KSDEVICE_HEADER Header,
    IN PVOID Context
    );

KSDDKAPI
NTSTATUS
NTAPI
KsCreateDefaultSecurity(
    IN PSECURITY_DESCRIPTOR ParentSecurity OPTIONAL,
    OUT PSECURITY_DESCRIPTOR* DefaultSecurity
    );

KSDDKAPI
NTSTATUS
NTAPI
KsForwardIrp(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN ReuseStackLocation
    );

KSDDKAPI
NTSTATUS
NTAPI
KsForwardAndCatchIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN KSSTACK_USE StackUse
    );

KSDDKAPI
NTSTATUS
NTAPI
KsSynchronousIoControlDevice(
    IN PFILE_OBJECT FileObject,
    IN KPROCESSOR_MODE RequestorMode,
    IN ULONG IoControl,
    IN PVOID InBuffer,
    IN ULONG InSize,
    OUT PVOID OutBuffer,
    IN ULONG OutSize,
    OUT PULONG BytesReturned
    );

KSDDKAPI
NTSTATUS
NTAPI
KsUnserializeObjectPropertiesFromRegistry(
    IN PFILE_OBJECT FileObject,
    IN HANDLE ParentKey OPTIONAL,
    IN PUNICODE_STRING RegistryPath OPTIONAL
    );

KSDDKAPI
NTSTATUS
NTAPI
KsCacheMedium(
    IN PUNICODE_STRING SymbolicLink,
    IN PKSPIN_MEDIUM Medium,
    IN ULONG PinDirection
    );

// thread.c:

KSDDKAPI
NTSTATUS
NTAPI
KsRegisterWorker(
    IN WORK_QUEUE_TYPE WorkQueueType,
    OUT PKSWORKER* Worker
    );
KSDDKAPI
NTSTATUS
NTAPI
KsRegisterCountedWorker(
    IN WORK_QUEUE_TYPE WorkQueueType,
    IN PWORK_QUEUE_ITEM CountedWorkItem,
    OUT PKSWORKER* Worker
    );
KSDDKAPI
VOID
NTAPI
KsUnregisterWorker(
    IN PKSWORKER Worker
    );
KSDDKAPI
NTSTATUS
NTAPI
KsQueueWorkItem(
    IN PKSWORKER Worker,
    IN PWORK_QUEUE_ITEM WorkItem
    );
KSDDKAPI
ULONG
NTAPI
KsIncrementCountedWorker(
    IN PKSWORKER Worker
    );
KSDDKAPI
ULONG
NTAPI
KsDecrementCountedWorker(
    IN PKSWORKER Worker
    );

// topology.c:

KSDDKAPI
NTSTATUS
NTAPI
KsCreateTopologyNode(
    IN HANDLE ParentHandle,
    IN PKSNODE_CREATE NodeCreate,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE NodeHandle
    );

KSDDKAPI
NTSTATUS
NTAPI
KsValidateTopologyNodeCreateRequest(
    IN PIRP Irp,
    IN PKSTOPOLOGY Topology,
    OUT PKSNODE_CREATE* NodeCreate
    );

// @@BEGIN_DDKSPLIT
KSDDKAPI
NTSTATUS
NTAPI
KsMergeAutomationTables(
    OUT PKSAUTOMATION_TABLE* AutomationTableAB,
    IN PKSAUTOMATION_TABLE AutomationTableA OPTIONAL,
    IN PKSAUTOMATION_TABLE AutomationTableB OPTIONAL,
    IN KSOBJECT_BAG Bag OPTIONAL
    );

KSDDKAPI
NTSTATUS
NTAPI
KsInitializeDriver(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName,
    IN const KSDEVICE_DESCRIPTOR* Descriptor OPTIONAL
    );

KSDDKAPI
NTSTATUS
NTAPI
KsAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

KSDDKAPI
NTSTATUS
NTAPI
KsCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN const KSDEVICE_DESCRIPTOR* Descriptor OPTIONAL,
    IN ULONG ExtensionSize OPTIONAL,
    OUT PKSDEVICE* Device OPTIONAL
    );

KSDDKAPI
NTSTATUS
NTAPI
KsInitializeDevice(
    IN PDEVICE_OBJECT FunctionalDeviceObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PDEVICE_OBJECT NextDeviceObject,
    IN const KSDEVICE_DESCRIPTOR* Descriptor OPTIONAL
    );

KSDDKAPI
void
NTAPI
KsTerminateDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

KSDDKAPI
PKSDEVICE
NTAPI
KsGetDeviceForDeviceObject(
    IN PDEVICE_OBJECT FunctionalDeviceObject
    );

KSDDKAPI
void
NTAPI
KsAcquireDevice(
    IN PKSDEVICE Device
    );

KSDDKAPI
void
NTAPI
KsReleaseDevice(
    IN PKSDEVICE Device
    );

KSDDKAPI
void
NTAPI
KsDeviceRegisterAdapterObject(
    IN PKSDEVICE Device,
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG MaxMappingsByteCount,
    IN ULONG MappingTableStride
    );

KSDDKAPI
ULONG
NTAPI
KsDeviceGetBusData(
    IN PKSDEVICE Device,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

KSDDKAPI
ULONG
NTAPI
KsDeviceSetBusData(
    IN PKSDEVICE Device,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

KSDDKAPI
NTSTATUS
NTAPI
KsCreateFilterFactory(
    IN PDEVICE_OBJECT DeviceObject,
    IN const KSFILTER_DESCRIPTOR* Descriptor,
    IN PWCHAR RefString OPTIONAL,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN ULONG CreateItemFlags,
    IN PFNKSFILTERFACTORYPOWER SleepCallback OPTIONAL,
    IN PFNKSFILTERFACTORYPOWER WakeCallback OPTIONAL,
    OUT PKSFILTERFACTORY* FilterFactory OPTIONAL
    );

#define KsDeleteFilterFactory(FilterFactory) \
    KsFreeObjectCreateItemsByContext(\
        *(KSDEVICE_HEADER *)(\
            KsFilterFactoryGetParentDevice(FilterFactory)->FunctionalDeviceObject->\
                DeviceExtension),\
        FilterFactory)

KSDDKAPI
NTSTATUS
NTAPI
KsFilterFactoryAddCreateItem(
    IN PKSFILTERFACTORY FilterFactory,
    IN PWCHAR RefString,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN ULONG CreateItemFlags
    );

KSDDKAPI
NTSTATUS
NTAPI
KsFilterFactorySetDeviceClassesState(
    IN PKSFILTERFACTORY FilterFactory,
    IN BOOLEAN NewState
    );

KSDDKAPI
PUNICODE_STRING
NTAPI
KsFilterFactoryGetSymbolicLink(
    IN PKSFILTERFACTORY FilterFactory
    );

KSDDKAPI
void
NTAPI
KsAddEvent(
    IN PVOID Object,
    IN PKSEVENT_ENTRY EventEntry
    );

void _inline
KsFilterAddEvent(
    IN PKSFILTER Filter,
    IN PKSEVENT_ENTRY EventEntry
    )
{
    KsAddEvent(Filter,EventEntry);
}

void _inline
KsPinAddEvent(
    IN PKSPIN Pin,
    IN PKSEVENT_ENTRY EventEntry
    )
{
    KsAddEvent(Pin,EventEntry);
}

KSDDKAPI
NTSTATUS    
NTAPI
KsDefaultAddEventHandler(
    IN PIRP Irp,
    IN PKSEVENTDATA EventData,
    IN OUT PKSEVENT_ENTRY EventEntry
    );

KSDDKAPI
void
NTAPI
KsGenerateEvents(
    IN PVOID Object,
    IN const GUID* EventSet OPTIONAL,
    IN ULONG EventId,
    IN ULONG DataSize,
    IN PVOID Data OPTIONAL,
    IN PFNKSGENERATEEVENTCALLBACK CallBack OPTIONAL,
    IN PVOID CallBackContext OPTIONAL
    );

void _inline
KsFilterGenerateEvents(
    IN PKSFILTER Filter,
    IN const GUID* EventSet OPTIONAL,
    IN ULONG EventId,
    IN ULONG DataSize,
    IN PVOID Data OPTIONAL,
    IN PFNKSGENERATEEVENTCALLBACK CallBack OPTIONAL,
    IN PVOID CallBackContext OPTIONAL
    )
{
    KsGenerateEvents(
        Filter,
        EventSet,
        EventId,
        DataSize,
        Data,
        CallBack,
        CallBackContext);
}

void _inline
KsPinGenerateEvents(
    IN PKSPIN Pin,
    IN const GUID* EventSet OPTIONAL,
    IN ULONG EventId,
    IN ULONG DataSize,
    IN PVOID Data OPTIONAL,
    IN PFNKSGENERATEEVENTCALLBACK CallBack OPTIONAL,
    IN PVOID CallBackContext OPTIONAL
    )
{
    KsGenerateEvents(
        Pin,
        EventSet,
        EventId,
        DataSize,
        Data,
        CallBack,
        CallBackContext);
}

typedef enum {
    KSSTREAM_POINTER_STATE_UNLOCKED = 0,
    KSSTREAM_POINTER_STATE_LOCKED
} KSSTREAM_POINTER_STATE;

KSDDKAPI
NTSTATUS
NTAPI
KsPinGetAvailableByteCount(
    IN PKSPIN Pin,
    OUT PLONG InputDataBytes OPTIONAL,
    OUT PLONG OutputBufferBytes OPTIONAL
    );

KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsPinGetLeadingEdgeStreamPointer(
    IN PKSPIN Pin,
    IN KSSTREAM_POINTER_STATE State
    );

KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsPinGetTrailingEdgeStreamPointer(
    IN PKSPIN Pin,
    IN KSSTREAM_POINTER_STATE State
    );

KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerLock(
    IN PKSSTREAM_POINTER StreamPointer
    );

KSDDKAPI
void
NTAPI
KsStreamPointerUnlock(
    IN PKSSTREAM_POINTER StreamPointer,
    IN BOOLEAN Eject
    );

KSDDKAPI
void
NTAPI
KsStreamPointerAdvanceOffsetsAndUnlock(
    IN PKSSTREAM_POINTER StreamPointer,
    IN ULONG InUsed,
    IN ULONG OutUsed,
    IN BOOLEAN Eject
    );

KSDDKAPI
void
NTAPI
KsStreamPointerDelete(
    IN PKSSTREAM_POINTER StreamPointer
    );

KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerClone(
    IN PKSSTREAM_POINTER StreamPointer,
    IN PFNKSSTREAMPOINTER CancelCallback OPTIONAL,
    IN ULONG ContextSize,
    OUT PKSSTREAM_POINTER* CloneStreamPointer
    );

KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerAdvanceOffsets(
    IN PKSSTREAM_POINTER StreamPointer,
    IN ULONG InUsed,
    IN ULONG OutUsed,
    IN BOOLEAN Eject
    );

KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerAdvance(
    IN PKSSTREAM_POINTER StreamPointer
    );

KSDDKAPI
PMDL
NTAPI
KsStreamPointerGetMdl(
    IN PKSSTREAM_POINTER StreamPointer
    );

KSDDKAPI
PIRP
NTAPI
KsStreamPointerGetIrp(
    IN PKSSTREAM_POINTER StreamPointer,
    OUT PBOOLEAN FirstFrameInIrp OPTIONAL,
    OUT PBOOLEAN LastFrameInIrp OPTIONAL
    );

KSDDKAPI
void
NTAPI
KsStreamPointerScheduleTimeout(
    IN PKSSTREAM_POINTER StreamPointer,
    IN PFNKSSTREAMPOINTER Callback,
    IN ULONGLONG Interval
    );

KSDDKAPI
void
NTAPI
KsStreamPointerCancelTimeout(
    IN PKSSTREAM_POINTER StreamPointer
    );

KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsPinGetFirstCloneStreamPointer(
    IN PKSPIN Pin
    );

KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsStreamPointerGetNextClone(
    IN PKSSTREAM_POINTER StreamPointer
    );

KSDDKAPI
NTSTATUS
NTAPI
KsPinHandshake(
    IN PKSPIN Pin,
    IN PKSHANDSHAKE In,
    OUT PKSHANDSHAKE Out
    );

KSDDKAPI
void
NTAPI
KsCompletePendingRequest(
    IN PIRP Irp
    );

KSDDKAPI
KSOBJECTTYPE
NTAPI
KsGetObjectTypeFromIrp(
    IN PIRP Irp
    );

KSDDKAPI
PVOID
NTAPI
KsGetObjectFromFileObject(
    IN PFILE_OBJECT FileObject
    );

KSDDKAPI
KSOBJECTTYPE
NTAPI
KsGetObjectTypeFromFileObject(
    IN PFILE_OBJECT FileObject
    );

PKSFILTER __inline
KsGetFilterFromFileObject(
    IN PFILE_OBJECT FileObject
    )
{
    return (PKSFILTER) KsGetObjectFromFileObject(FileObject);
}

PKSPIN __inline
KsGetPinFromFileObject(
    IN PFILE_OBJECT FileObject
    )
{
    return (PKSPIN) KsGetObjectFromFileObject(FileObject);
}    

KSDDKAPI
PKSGATE
NTAPI
KsFilterGetAndGate(
    IN PKSFILTER Filter
    );

KSDDKAPI
void
NTAPI
KsFilterAcquireProcessingMutex(
    IN PKSFILTER Filter
    );

KSDDKAPI
void
NTAPI
KsFilterReleaseProcessingMutex(
    IN PKSFILTER Filter
    );

KSDDKAPI
void
NTAPI
KsFilterAttemptProcessing(
    IN PKSFILTER Filter,
    IN BOOLEAN Asynchronous
    );

KSDDKAPI
PKSGATE
NTAPI
KsPinGetAndGate(
    IN PKSPIN Pin
    );

KSDDKAPI
void
NTAPI
KsPinAttachAndGate(
    IN PKSPIN Pin,
    IN PKSGATE AndGate OPTIONAL
    );

KSDDKAPI
void
NTAPI
KsPinAttachOrGate(
    IN PKSPIN Pin,
    IN PKSGATE OrGate OPTIONAL
    );

KSDDKAPI
void
NTAPI
KsPinAcquireProcessingMutex(
    IN PKSPIN Pin
    );

KSDDKAPI
void
NTAPI
KsPinReleaseProcessingMutex(
    IN PKSPIN Pin
    );

KSDDKAPI
BOOLEAN
NTAPI
KsProcessPinUpdate(
    IN PKSPROCESSPIN ProcessPin
    );

KSDDKAPI
void
NTAPI
KsPinAttemptProcessing(
    IN PKSPIN Pin,
    IN BOOLEAN Asynchronous
    );

KSDDKAPI
PVOID
NTAPI
KsGetParent(
    IN PVOID Object
    );

PKSDEVICE __inline
KsFilterFactoryGetParentDevice(
    IN PKSFILTERFACTORY FilterFactory
    )
{
    return (PKSDEVICE) KsGetParent((PVOID) FilterFactory);
}

PKSFILTERFACTORY __inline
KsFilterGetParentFilterFactory(
    IN PKSFILTER Filter
    )
{
    return (PKSFILTERFACTORY) KsGetParent((PVOID) Filter);
}

KSDDKAPI
PKSFILTER 
NTAPI
KsPinGetParentFilter(
    IN PKSPIN Pin
    );

KSDDKAPI
PVOID
NTAPI
KsGetFirstChild(
    IN PVOID Object
    );

PKSFILTERFACTORY __inline
KsDeviceGetFirstChildFilterFactory(
    IN PKSDEVICE Device
    )
{
    return (PKSFILTERFACTORY) KsGetFirstChild((PVOID) Device);
}

PKSFILTER __inline
KsFilterFactoryGetFirstChildFilter(
    IN PKSFILTERFACTORY FilterFactory
    )
{
    return (PKSFILTER) KsGetFirstChild((PVOID) FilterFactory);
}

KSDDKAPI
ULONG
NTAPI
KsFilterGetChildPinCount(
    IN PKSFILTER Filter,
    IN ULONG PinId
    );

KSDDKAPI
PKSPIN
NTAPI
KsFilterGetFirstChildPin(
    IN PKSFILTER Filter,
    IN ULONG PinId
    );

KSDDKAPI
PVOID
NTAPI
KsGetNextSibling(
    IN PVOID Object
    );

KSDDKAPI
PKSPIN 
NTAPI
KsPinGetNextSiblingPin(
    IN PKSPIN Pin
    );

PKSFILTERFACTORY __inline
KsFilterFactoryGetNextSiblingFilterFactory(
    IN PKSFILTERFACTORY FilterFactory
    )
{
    return (PKSFILTERFACTORY) KsGetNextSibling((PVOID) FilterFactory);
}

PKSFILTER __inline
KsFilterGetNextSiblingFilter(
    IN PKSFILTER Filter
    )
{
    return (PKSFILTER) KsGetNextSibling((PVOID) Filter);
}


KSDDKAPI
PKSDEVICE
NTAPI
KsGetDevice(
    IN PVOID Object
    );

PKSDEVICE __inline
KsFilterFactoryGetDevice(
    IN PKSFILTERFACTORY FilterFactory
    )
{
    return KsGetDevice((PVOID) FilterFactory);
}

PKSDEVICE __inline
KsFilterGetDevice(
    IN PKSFILTER Filter
    )
{
    return KsGetDevice((PVOID) Filter);
}

PKSDEVICE __inline
KsPinGetDevice(
    IN PKSPIN Pin
    )
{
    return KsGetDevice((PVOID) Pin);
}

KSDDKAPI
PKSFILTER
NTAPI
KsGetFilterFromIrp(
    IN PIRP Irp
    );

KSDDKAPI
PKSPIN
NTAPI
KsGetPinFromIrp(
    IN PIRP Irp
    );

KSDDKAPI
ULONG
NTAPI
KsGetNodeIdFromIrp(
    IN PIRP Irp
    );

KSDDKAPI
void
NTAPI
KsAcquireControl(
    IN PVOID Object
    );

KSDDKAPI
void
NTAPI
KsReleaseControl(
    IN PVOID Object
    );

void __inline
KsFilterAcquireControl(
    IN PKSFILTER Filter
    )
{
    KsAcquireControl((PVOID) Filter);
}

void __inline
KsFilterReleaseControl(
    IN PKSFILTER Filter
    )
{
    KsReleaseControl((PVOID) Filter);
}

void __inline
KsPinAcquireControl(
    IN PKSPIN Pin
    )
{
    KsAcquireControl((PVOID) Pin);
}

void __inline
KsPinReleaseControl(
    IN PKSPIN Pin
    )
{
    KsReleaseControl((PVOID) Pin);
}

KSDDKAPI
NTSTATUS
NTAPI
KsAddItemToObjectBag(
    IN KSOBJECT_BAG ObjectBag,
    IN PVOID Item,
    IN PFNKSFREE Free OPTIONAL
    );

KSDDKAPI
ULONG
NTAPI
KsRemoveItemFromObjectBag(
    IN KSOBJECT_BAG ObjectBag,
    IN PVOID Item,
    IN BOOLEAN Free
    );

#define KsDiscard(Object,Pointer)\
    KsRemoveItemFromObjectBag(\
        (Object)->Bag,\
        (PVOID)(Pointer),\
        TRUE)

KSDDKAPI
NTSTATUS
NTAPI
KsAllocateObjectBag(
    IN PKSDEVICE Device,
    OUT KSOBJECT_BAG* ObjectBag
    );

KSDDKAPI
void
NTAPI
KsFreeObjectBag(
    IN KSOBJECT_BAG ObjectBag
    );

KSDDKAPI
NTSTATUS
NTAPI
KsCopyObjectBagItems(
    IN KSOBJECT_BAG ObjectBagDestination,
    IN KSOBJECT_BAG ObjectBagSource
    );

KSDDKAPI
NTSTATUS
NTAPI
_KsEdit(
    IN KSOBJECT_BAG ObjectBag,
    IN OUT PVOID* PointerToPointerToItem,
    IN ULONG NewSize,
    IN ULONG OldSize,
    IN ULONG Tag
    );

#define KsEdit(Object,PointerToPointer,Tag)\
    _KsEdit(\
        (Object)->Bag,\
        (PVOID*)(PointerToPointer),\
        sizeof(**(PointerToPointer)),\
        sizeof(**(PointerToPointer)),\
        (Tag))
#define KsEditSized(Object,PointerToPointer,NewSize,OldSize,Tag)\
    _KsEdit((Object)->Bag,(PVOID*)(PointerToPointer),(NewSize),(OldSize),(Tag))

KSDDKAPI
NTSTATUS
NTAPI
KsRegisterFilterWithNoKSPins(
                                      IN PDEVICE_OBJECT DeviceObject,
                                      IN const GUID * InterfaceClassGUID,
                                      IN ULONG PinCount,
                                      IN BOOL * PinDirection,
                                      IN KSPIN_MEDIUM * MediumList,
                                      IN OPTIONAL GUID * CategoryList
);

KSDDKAPI
NTSTATUS
NTAPI
KsFilterCreatePinFactory (
    IN PKSFILTER Filter,
    IN const KSPIN_DESCRIPTOR_EX *const PinDescriptor,
    OUT PULONG PinID
    );

KSDDKAPI
NTSTATUS
NTAPI
KsFilterCreateNode (
    IN PKSFILTER Filter,
    IN const KSNODE_DESCRIPTOR *const NodeDescriptor,
    OUT PULONG NodeID
    );

KSDDKAPI
NTSTATUS
NTAPI
KsFilterAddTopologyConnections (
    IN PKSFILTER Filter,
    IN ULONG NewConnectionsCount,
    IN const KSTOPOLOGY_CONNECTION *const NewTopologyConnections
    );

KSDDKAPI
NTSTATUS
NTAPI
KsPinGetConnectedPinInterface(
    IN PKSPIN Pin,
    IN const GUID* InterfaceId,
    OUT PVOID* Interface
    );

KSDDKAPI
PFILE_OBJECT
NTAPI
KsPinGetConnectedPinFileObject(
    IN PKSPIN Pin
    );

KSDDKAPI
NTSTATUS
NTAPI
KsPinGetConnectedFilterInterface(
    IN PKSPIN Pin,
    IN const GUID* InterfaceId,
    OUT PVOID* Interface
    );

#if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

KSDDKAPI
NTSTATUS
NTAPI
KsPinGetReferenceClockInterface(
    IN PKSPIN Pin,
    OUT PIKSREFERENCECLOCK* Interface
    );

#endif //defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

KSDDKAPI
VOID
NTAPI
KsPinSetPinClockTime(
    IN PKSPIN Pin,
    IN LONGLONG Time
    );

KSDDKAPI
NTSTATUS
NTAPI
KsPinSubmitFrame(
    IN PKSPIN Pin,
    IN PVOID Data OPTIONAL,
    IN ULONG Size OPTIONAL,
    IN PKSSTREAM_HEADER StreamHeader OPTIONAL,
    IN PVOID Context OPTIONAL
    );

KSDDKAPI
NTSTATUS
NTAPI
KsPinSubmitFrameMdl(
    IN PKSPIN Pin,
    IN PMDL Mdl OPTIONAL,
    IN PKSSTREAM_HEADER StreamHeader OPTIONAL,
    IN PVOID Context OPTIONAL
    );

KSDDKAPI
void
NTAPI
KsPinRegisterFrameReturnCallback(
    IN PKSPIN Pin,
    IN PFNKSPINFRAMERETURN FrameReturn
    );

KSDDKAPI
void
NTAPI
KsPinRegisterHandshakeCallback(
    IN PKSPIN Pin,
    IN PFNKSPINHANDSHAKE Handshake
    );

KSDDKAPI
void
NTAPI
KsFilterRegisterPowerCallbacks(
    IN PKSFILTER Filter,
    IN PFNKSFILTERPOWER Sleep OPTIONAL,
    IN PFNKSFILTERPOWER Wake OPTIONAL
    );

KSDDKAPI
void
NTAPI
KsPinRegisterPowerCallbacks(
    IN PKSPIN Pin,
    IN PFNKSPINPOWER Sleep OPTIONAL,
    IN PFNKSPINPOWER Wake OPTIONAL
    );

#if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

KSDDKAPI
PUNKNOWN
NTAPI
KsRegisterAggregatedClientUnknown(
    IN PVOID Object,
    IN PUNKNOWN ClientUnknown 
    );

KSDDKAPI
PUNKNOWN
NTAPI
KsGetOuterUnknown(
    IN PVOID Object
    );

PUNKNOWN __inline
KsDeviceRegisterAggregatedClientUnknown(
    IN PKSDEVICE Device,
    IN PUNKNOWN ClientUnknown 
    )
{
    return KsRegisterAggregatedClientUnknown((PVOID) Device,ClientUnknown);
}

PUNKNOWN __inline
KsDeviceGetOuterUnknown(
    IN PKSDEVICE Device
    )
{
    return KsGetOuterUnknown((PVOID) Device);
}

PUNKNOWN __inline
KsFilterFactoryRegisterAggregatedClientUnknown(
    IN PKSFILTERFACTORY FilterFactory,
    IN PUNKNOWN ClientUnknown 
    )
{
    return KsRegisterAggregatedClientUnknown((PVOID) FilterFactory,ClientUnknown);
}

PUNKNOWN __inline
KsFilterFactoryGetOuterUnknown(
    IN PKSFILTERFACTORY FilterFactory
    )
{
    return KsGetOuterUnknown((PVOID) FilterFactory);
}

PUNKNOWN __inline
KsFilterRegisterAggregatedClientUnknown(
    IN PKSFILTER Filter,
    IN PUNKNOWN ClientUnknown 
    )
{
    return KsRegisterAggregatedClientUnknown((PVOID) Filter,ClientUnknown);
}

PUNKNOWN __inline
KsFilterGetOuterUnknown(
    IN PKSFILTER Filter
    )
{
    return KsGetOuterUnknown((PVOID) Filter);
}

PUNKNOWN __inline
KsPinRegisterAggregatedClientUnknown(
    IN PKSPIN Pin,
    IN PUNKNOWN ClientUnknown 
    )
{
    return KsRegisterAggregatedClientUnknown((PVOID) Pin,ClientUnknown);
}

PUNKNOWN __inline
KsPinGetOuterUnknown(
    IN PKSPIN Pin
    )
{
    return KsGetOuterUnknown((PVOID) Pin);
}

#endif // defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

// @@END_DDKSPLIT
#else // !defined(_NTDDK_)

#if !defined( KS_NO_CREATE_FUNCTIONS )

KSDDKAPI
DWORD
WINAPI
KsCreateAllocator(
    IN HANDLE ConnectionHandle,
    IN PKSALLOCATOR_FRAMING AllocatorFraming,
    OUT PHANDLE AllocatorHandle
    );

KSDDKAPI
DWORD
NTAPI
KsCreateClock(
    IN HANDLE ConnectionHandle,
    IN PKSCLOCK_CREATE ClockCreate,
    OUT PHANDLE ClockHandle
    );

KSDDKAPI
DWORD
WINAPI
KsCreatePin(
    IN HANDLE FilterHandle,
    IN PKSPIN_CONNECT Connect,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE ConnectionHandle
    );

KSDDKAPI
DWORD
WINAPI
KsCreateTopologyNode(
    IN HANDLE ParentHandle,
    IN PKSNODE_CREATE NodeCreate,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE NodeHandle
    );
    
#endif

#endif // !defined(_NTDDK_)

#if defined(__cplusplus)
}
#endif // defined(__cplusplus)

#endif // !_KS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\kxalpha.h ===
/*++

  Copyright (c) 1992-1999 Digital Equipment Corporation


  Module:
           kxalpha.h

  Abstract:
           Contains alpha architecture constants and assembly macros.

  Author:
          Joe Notarangelo  31-March-1992   (based on Dave Cutler's kxmips.h)


  Revision History

  16-September-1997  Kim Peterson

  Added ENABLE_ALIGNMENT_FIXUPS and DISABLE_ALIGNMENT_FIXUPS


  16-July-1992       John DeRosa

  Removed fwcalpal.h hook.


  8-July-1992        John DeRosa

  Added fwcalpal.h hooks, defined HALT call_pal.


--*/

//
// Define Sfw Interrupt Levels and masks
//

#define APC_INTERRUPT 0x1
#define DISPATCH_INTERRUPT 0x2

//
// Define standard integer registers.
//
// N.B. `at' is `AT' so it doesn't conflict with the `.set at' pseudo-op.
//

#define v0 $0                   // return value register
#define t0 $1                   // caller saved (temporary) registers
#define t1 $2                   //
#define t2 $3                   //
#define t3 $4                   //
#define t4 $5                   //
#define t5 $6                   //
#define t6 $7                   //
#define t7 $8                   //
#define s0 $9                   // callee saved (nonvolatile) registers
#define s1 $10                  //
#define s2 $11                  //
#define s3 $12                  //
#define s4 $13                  //
#define s5 $14                  //
#define fp $15                  // frame pointer register, or s6
#define a0 $16                  // argument registers
#define a1 $17                  //
#define a2 $18                  //
#define a3 $19                  //
#define a4 $20                  //
#define a5 $21                  //
#define t8 $22                  // caller saved (temporary) registers
#define t9 $23                  //
#define t10 $24                 //
#define t11 $25                 //
#define ra $26                  // return address register
#define t12 $27                 // caller saved (temporary) registers
#define AT $28                  // assembler temporary register
#define gp $29                  // global pointer register
#define sp $30                  // stack pointer register
#define zero $31                // zero register

#ifndef PALCODE

//
// Define standard floating point registers.
//

#define f0 $f0                  // return value register
#define f1 $f1                  // return value register
#define f2 $f2                  // callee saved (nonvolatile) registers
#define f3 $f3                  //
#define f4 $f4                  //
#define f5 $f5                  //
#define f6 $f6                  //
#define f7 $f7                  //
#define f8 $f8                  //
#define f9 $f9                  //
#define f10 $f10                // caller saved (temporary) registers
#define f11 $f11                //
#define f12 $f12                //
#define f13 $f13                //
#define f14 $f14                //
#define f15 $f15                //
#define f16 $f16                // argument registers
#define f17 $f17                //
#define f18 $f18                //
#define f19 $f19                //
#define f20 $f20                //
#define f21 $f21                //
#define f22 $f22                // caller saved (temporary) registers
#define f23 $f23                //
#define f24 $f24                //
#define f25 $f25                //
#define f26 $f26                //
#define f27 $f27                //
#define f28 $f28                //
#define f29 $f29                //
#define f30 $f30                //
#define f31 $f31                // floating zero register
#define fzero $f31              // floating zero register (alias)

#endif //!PALCODE


//
// Define procedure entry macros
//

#define ALTERNATE_ENTRY(Name)           \
        .globl  Name;                   \
Name:;

#define LEAF_ENTRY(Name)                \
        .text;                          \
        .align  4;                      \
        .globl  Name;                   \
        .ent    Name, 0;                \
Name:;                                  \
        .frame  sp, 0, ra;              \
        .prologue 0;

#define NESTED_ENTRY(Name, fsize, retrg) \
        .text;                          \
        .align  4;                      \
        .globl  Name;                   \
        .ent    Name, 0;                \
Name:;                                  \
        .frame  sp, fsize, retrg;

//
// Define global definition macros.
//

#define END_REGION(Name)                \
        .globl  Name;                   \
Name:;

#define START_REGION(Name)              \
        .globl  Name;                   \
Name:;

//
// Define exception handling macros.
//

#define EXCEPTION_HANDLER(Handler)      \
        .edata 1 Handler;


#define PROLOGUE_END  .prologue 1;

//
// Define load pointer macro.
//
//    If the target system contains 64-bit addressing, then pointers
//    are 64-bits. Otherwise, pointers are 32-bits.
//

#if defined(_AXP64_)

#define ADDP addq
#define SUBP subq
#define SPADDP s8addq
#define S4ADDP s4addq
#define S8ADDP s8addq
#define LDIP ldiq
#define LDP ldq
#define LDP_L ldq_l
#define STP stq
#define STP_C stq_c

#else

#define ADDP addl
#define SUBP subl
#define SPADDP s4addl
#define S4ADDP s4addl
#define S8ADDP s8addl
#define LDIP ldil
#define LDP ldl
#define LDP_L ldl_l
#define STP stl
#define STP_C stl_c

#endif

//
// Define save and restore floating state macros.
//

#define SAVE_NONVOLATILE_FLOAT_STATE    \
        bsr     ra, KiSaveNonVolatileFloatState

//
// Define interfaces to pcr and palcode
//
//    The interfaces defined in the following macros will be PALcode
//    calls for some implemenations, but may be in-line code in others
//    (eg. uniprocessor vs multiprocessor).  At the current time all of
//    the interfaces are PALcode calls.
//

//
// Define interfaces for cache coherency
//

//++
//
// IMB
//
// Macro Description:
//
//     Issue the architecture-defined Instruction Memory Barrier.  This
//     instruction will make the processor instruction stream coherent with
//     the system memory.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     None.
//
//--

#define IMB          call_pal imb

//
// Define PALcode Environment Transition Interfaces
//

//++
//
// REBOOT
//
// Macro Description:
//
//     Reboot the processor to return to firmware.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Does not return.
//
// Registers Used:
//
//     None.
//
//--

#define REBOOT         call_pal reboot

//++
//
// RESTART
//
// Macro Description:
//
//     Restart the processor with the processor state found in a
//     restart block.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies a pointer to an ARC restart block with an Alpha AXP
//          saved state area.
//
// Return Value:
//
//     If successful the call does not return.  Otherwise, any return
//     is considered a failure.
//
// Registers Used:
//
//     None.
//
//--

#define RESTART      call_pal restart

//++
//
// SWPPAL
//
// Macro Description:
//
//     Swap the execution environment to a new PALcode image.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the physical address of the base of the new PALcode
//          image.
//
//     a1 - a5 - Supply arguments to the new PALcode environment.
//
// Return Value:
//
//     Does not return.
//
// Registers Used:
//
//     None.
//
//--

#define SWPPAL       call_pal swppal

//
// Define IRQL and interrupt interfaces
//

//++
//
// DISABLE_INTERRUPTS
//
// Macro Description:
//
//     Disable all interrupts for the current processor and return the
//     previous PSR.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     None.
//
//--

#define DISABLE_INTERRUPTS        call_pal di

//++
//
// ENABLE_INTERRUPTS
//
// Macro Description:
//
//     Enable interrupts according to the current PSR for the current
//     processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     None.
//
//--

#define ENABLE_INTERRUPTS         call_pal ei

//++
//
// SWAP_IRQL
//
// Macro Description:
//
//     Swap the IRQL level for the current processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the new IRQL level.
//
// Return Value:
//
//     v0 = previous IRQL level.
//
// Registers Used:
//
//     AT, a1 - a3.
//
//--

#define SWAP_IRQL    call_pal swpirql

//++
//
// GET_CURRENT_IRQL
//
// Macro Description:
//
//     Return the current processor Interrupt Request Level (IRQL).
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = current IRQL.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_CURRENT_IRQL  call_pal rdirql


//
// Define interfaces for software interrupts
//

//++
//
// DEASSERT_SOFTWARE_INTERRUPT
//
// Macro Description:
//
//     Deassert the software interrupts indicated in a0 for the current
//     processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the mask for the software interrupt to be de-asserted.
//          a0<1> - Deassert DISPATCH software interrupt.
//          a0<0> - Deassert APC software interrupt.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a1 - a3.
//
//--

#define DEASSERT_SOFTWARE_INTERRUPT    call_pal csir

//++
//
// REQUEST_SOFTWARE_INTERRUPT
//
// Macro Description:
//
//     Request software interrupts on the current processor according to
//     the mask supplied in a0.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the mask of software interrupts to be requested.
//          a0<1> - Request DISPATCH software interrupt.
//          a0<0> - Request APC software interrupt.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a1 - a3.
//
//--

#define REQUEST_SOFTWARE_INTERRUPT     call_pal ssir

//
// Define interfaces to Processor Status Register
//

//++
//
// GET_CURRENT_PROCESSOR_STATUS_REGISTER
//
// Macro Description:
//
//     Return the current Processor Status Register (PSR) for the current
//     processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = current PSR.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_CURRENT_PROCESSOR_STATUS_REGISTER   call_pal rdpsr


//
// Define current thread interface
//

//++
//
// GET_THREAD_ENVIRONMENT_BLOCK
//
// Macro Description:
//
//     Return the base address of the current Thread Environment Block (TEB),
//     for the currently executing thread on the current processor.
//
// Mode;
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = TEB base address.
//
// Registers Used:
//
//     None.
//
//--

#if defined(_AXP64_)

#define GET_THREAD_ENVIRONMENT_BLOCK  call_pal rdteb64

#else

#define GET_THREAD_ENVIRONMENT_BLOCK  call_pal rdteb

#endif

//++
//
// GET_CURRENT_THREAD
//
// Macro Description:
//
//     Return the thread object address for the currently executing thread
//     on the current processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = PCR base address.
//
// Registers Used:
//
//     AT.
//
//--

#ifdef NT_UP

//
// If uni-processor, retrieve current thread address from the global
// variable KiCurrentThread.
//

#define GET_CURRENT_THREAD              \
        LDP     v0, KiCurrentThread;

#else

//
// If multi-processor, retrive per-processor current thread via a call pal.
//

#define GET_CURRENT_THREAD    call_pal rdthread

#endif //NT_UP

//
// Define per-processor data area routine interfaces
//

//++
//
// GET_PROCESSOR_CONTROL_REGION_BASE
//
// Macro Description:
//
//     Return the base address of the Process Control Region (PCR)
//     for the current processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = PCR base address.
//
// Registers Used:
//
//     AT.
//
//--

#ifdef NT_UP

//
// Uni-processor, address of PCR is in global variable.
//

#define GET_PROCESSOR_CONTROL_REGION_BASE \
        LDP     v0, KiPcrBaseAddress;

#else

//
// Multi-processor, get per-processor value via call pal.
//

#define GET_PROCESSOR_CONTROL_REGION_BASE    call_pal rdpcr

#endif //NT_UP

//++
//
// GET_PROCESSOR_CONTROL_BLOCK_BASE
//
// Macro Description:
//
//     Return the Processor Control Block base address.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = PRCB base address.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_PROCESSOR_CONTROL_BLOCK_BASE   \
        GET_PROCESSOR_CONTROL_REGION_BASE; \
        LDP     v0, PcPrcb(v0)


//
// Define kernel stack interfaces
//

//++
//
// GET_INITIAL_KERNEL_STACK
//
// Macro Description:
//
//     Return the initial kernel stack address for the current thread.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = initial kernel stack address.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_INITIAL_KERNEL_STACK  call_pal rdksp

//++
//
// SET_INITIAL_KERNEL_STACK
//
// Macro Description:
//
//     Set the initial kernel stack address for the current thread.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the new initial kernel stack address.
//
// Return Value:
//
//     v0 - Previous initial kernel stack address.
//
// Registers Used:
//
//     AT.
//
//--

#define SET_INITIAL_KERNEL_STACK  call_pal swpksp

//
// Define initialization routine interfaces
//

//++
//
// INITIALIZE_PAL
//
// Macro Description:
//
//     Supply values to initialize the PALcode.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies initial PageDirectoryBase (32-bit superpage address).
//     a1 - Supplies PRCB Base Address (32-bit superpage address).
//     a2 - Supplies address of initial kernel thread object.
//     a3 - Supplies address of TEB for initial kernel thread object.
//     gp - Supplies kernel image global pointer.
//     sp - Supplies initial thread kernel stack pointer.
//
// Return Value:
//
//     v0 = PAL base address in 32-bit super-page format (KSEG0).
//
// Registers Used:
//
//     AT, a3.
//
//--

#define INITIALIZE_PAL  call_pal initpal

//++
//
// WRITE_KERNEL_ENTRY_POINT
//
// Macro Description:
//
//     Register the kernel entry point to receive control for a
//     class of exceptions.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the address of the kernel entry point.
//     a1 - Supplies the class of exception dispatched to this entry point.
//          0 = bug check conditions
//          1 = memory management faults
//          2 = interrupts
//          3 = system service calls
//          4 = general exception traps
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a2-a3.
//
//--

#define WRITE_KERNEL_ENTRY_POINT  call_pal wrentry

//
// Define entry point values for the wrentry callpal function
//

#define entryBugCheck   0
#define entryMM         1
#define entryInterrupt  2
#define entrySyscall    3
#define entryGeneral    4

//++
//
// CACHE_PCR_VALUES
//
// Macro Description:
//
//     Notify the PALcode that the PCR has been initialized by the
//     kernel and the HAL and that the PALcode may now read values
//     from the PCR and cache them inside the processor.
//
//     N.B. - the PCR pointer must have already been established in
//          initpal
//
//     N.B. - This interface is a processor-specific implementation
//          and cannot be assumed to be present on all processors.
//          Currently implemented for the following processors:
//
//              DECchip 21064
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a0 - a3.
//
//--

#define CACHE_PCR_VALUES  call_pal initpcr

//
// Define transition interfaces
//

//++
//
// RETURN_FROM_TRAP_OR_INTERRUPT
//
// Macro Description:
//
//     Return to execution thread after processing a trap or
//     interrupt.  Traps can be general exceptions (breakpoint,
//     arithmetic traps, etc.) or memory management faults.
//     This macro is also used to startup a thread of execution
//     for the first time.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the previous processor status register.
//     a1 - Supplies new software interrupt requests.
//          a1<1> - Request a DISPATCH Interrupt.
//          a1<0> - Request an APC Interrupt.
//
// Return Value:
//
//     Does not return.
//
// Registers Used:
//
//     None.
//
//--

#define RETURN_FROM_TRAP_OR_INTERRUPT      call_pal rfe

//++
//
// RETURN_FROM_SYSTEM_CALL
//
// Macro Description:
//
//     Return from a system service call.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the previous processor status register.
//     a1 - Supplies new software interrupt requests.
//          a1<1> - Request a DISPATCH Interrupt.
//          a1<0> - Request an APC Interrupt.
//
// Return Value:
//
//     Does not return.
//
// Registers Used:
//
//     All volatile registers.
//
//--

#define RETURN_FROM_SYSTEM_CALL   call_pal retsys

//++
//
// SYSCALL
//
// Macro Description:
//
//     Call a system service.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     v0 - Supplies the system service number.
//     [other arguments as per calling standard]
//
// Return Value:
//
//     Will not return directly, returns via retsys, no return value.
//
// Registers Used:
//
//     All volatile registers.
//
//--

#define SYSCALL  call_pal callsys

//
// Define breakpoint interfaces
//

//++
//
// BREAK
//
// Macro Description:
//
//     Issue a user breakpoint which may be handled by a user-mode
//     debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     None.
//
//--

#define BREAK    call_pal bpt

//++
//
// BREAK_DEBUG_STOP
//
// Macro Description:
//
//     Issue a stop breakpoint to the kernel debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--

#define BREAK_DEBUG_STOP \
    ldil    v0, DEBUG_STOP_BREAKPOINT; \
    call_pal callkd

//++
//++
//
// BREAK_BREAKIN
//
// Macro Description:
//
//     Issue a breakin breakpoint to the kernel debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--

#define BREAK_BREAKIN \
    ldil    v0, BREAKIN_BREAKPOINT; \
    call_pal callkd

//++
//
// BREAK_DEBUG_LOAD_SYMBOLS
//
// Macro Description:
//
//     Issue a load symbols breakpoint to the kernel debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--

#define BREAK_DEBUG_LOAD_SYMBOLS \
    ldil    v0, DEBUG_LOAD_SYMBOLS_BREAKPOINT; \
    call_pal callkd

//++
//
// BREAK_DEBUG_UNLOAD_SYMBOLS
//
// Macro Description:
//
//     Issue a unload symbols breakpoint to the kernel debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--

#define BREAK_DEBUG_UNLOAD_SYMBOLS \
    ldil    v0, DEBUG_UNLOAD_SYMBOLS_BREAKPOINT; \
    call_pal callkd

//++
//
// BREAK_DEBUG_PRINT
//
// Macro Description:
//
//     Cause a debug print breakpoint which will be interpreted by
//     the kernel debugger and will print a string to the kernel debugger
//     port.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     a0 - Supplies the address of ASCII string to print.
//     a1 - Supplies the length of the string to print.
//
// Return Value:
//
//     Does not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--


#define BREAK_DEBUG_PRINT \
    ldil    v0, DEBUG_PRINT_BREAKPOINT; \
    call_pal callkd

//++
//
// BREAK_DEBUG_PROMPT
//
// Macro Description:
//
//     Cause a debug print breakpoint which will be interpreted by
//     the kernel debugger and will receive a string from the kernel debugger
//     port after prompting for input.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     a0 - Supplies the address of ASCII string to print.
//     a1 - Supplies the length of the string to print.
//     a2 - Supplies the address of the buffer to receive the input string.
//     a3 - Supplies the maximum length of the input string.
//
// Return Value:
//
//     Does not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--


#define BREAK_DEBUG_PROMPT \
    ldil    v0, DEBUG_PROMPT_BREAKPOINT; \
    call_pal callkd

//
// Define tb manipulation interfaces
//

//++
//
// TB_INVALIDATE_ALL
//
// Macro Description:
//
//     Invalidate all cached virtual address translations for the current
//     processor that are not fixed.
//     Some translations may be fixed in hardware and/or software and
//     these are not invalidated (eg. super-pages).
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a0 - a3.
//
//--


#define TB_INVALIDATE_ALL   call_pal tbia

//++
//
// TB_INVALIDATE_SINGLE
//
// Macro Description:
//
//     Invalidate any cached virtual address translations for a single
//     virtual address.
//
//     Note - it is legal for an implementation to invalidate more
//     translations that the single one specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Virtual Address of the translation to invalidate.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a1 - a3.
//
//--

#define TB_INVALIDATE_SINGLE   call_pal tbis

//++
//
// TB_INVALIDATE_MULTIPLE
//
// Macro Description:
//
//     Invalidate any cached virtual address translations for the specified
//     set of virtual addresses.
//
//     Note - it is legal for an implementation to invalidate more
//     translations than those specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies a pointer to the list of Virtual Addresses of the
//          translations to invalidate.
//     a1 - Supplies the count of Virtual Addresses in the list
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a2.
//
//--

#define TB_INVALIDATE_MULTIPLE   call_pal tbim

//++
//
// TB_INVALIDATE_SINGLE64
//
// Macro Description:
//
//     Invalidate any cached virtual address translations for a single
//     virtual address.
//
//     Note - it is legal for an implementation to invalidate more
//     translations that the single one specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the virtual page number of the translation to invalidate.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a1 - a3.
//
//--

#define TB_INVALIDATE_SINGLE64   call_pal tbis64

//++
//
// TB_INVALIDATE_MULTIPLE64
//
// Macro Description:
//
//     Invalidate any cached virtual address translations for the specified
//     set of virtual addresses.
//
//     Note - it is legal for an implementation to invalidate more
//     translations than those specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies a pointer to the list of virtual page numbers of the
//          translations to invalidate.
//     a1 - Supplies the count of virtual page numbers in the list
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a2.
//
//--

#define TB_INVALIDATE_MULTIPLE64   call_pal tbim64

//++
//
// TB_INVALIDATE_SINGLE_ASN
//
// Macro Description:
//
//     Invalidate any cached virtual address translations for a single
//     virtual address for the specified address space number.
//
//     Note - it is legal for an implementation to invalidate more
//     translations that the single one specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Virtual Address of the translation to invalidate.
//
//     a1 - Supplies the Address Space Number of the translation to be
//          invalidated.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a1 - a3.
//
//--

#define TB_INVALIDATE_SINGLE_ASN   call_pal tbisasn

//++
//
// TB_INVALIDATE_MULTIPLE_ASN
//
// Macro Description:
//
//     Invalidate any cached virtual address translations for the specified
//     set of virtual addresses for the specified address space number.
//
//     Note - it is legal for an implementation to invalidate more
//     translations than those specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies a pointer to the list of Virtual Addresses of the
//          translations to invalidate.
//
//     a1 - Supplies the count of Virtual Addresses in the list
//
//     a2 - Supplies the Address Space Number of the translation to be
//          invalidated.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a3.
//
//--

#define TB_INVALIDATE_MULTIPLE_ASN   call_pal tbimasn

//++
//
// DATA_TB_INVALIDATE_SINGLE
//
// Macro Description:
//
//     Invalidate data stream translations for a single virtual address.
//
//     Note - it is legal for an implementation to invalidate more
//     translations that the single one specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Virtual Address of the translation to invalidate.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a1 - a3.
//
//--

#define DATA_TB_INVALIDATE_SINGLE  call_pal dtbis

//
// Define context switch interfaces
//

//++
//
// SWAP_THREAD_CONTEXT
//
// Macro Description:
//
//
//     Change to a new thread context.  This will mean a new kernel stack,
//     new current thread address and a new thread environment block.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Virtual Address of new initial kernel stack.
//     a1 - Supplies the address of new thread object.
//     a2 - Supplies the address of new thread environment block.
//     a3 - Supplies the PFN of the new page directory if the process
//          is to be swapped, -1 otherwise.
//     a4 - Supplies the ASN of the new processor if the process is to
//          be swapped, undefined otherwise.
//     a5 - Supplies the ASN wrap indicator if the process is to be swapped,
//          undefined otherwise.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT.
//
//--

#define SWAP_THREAD_CONTEXT   call_pal  swpctx

//++
//
// SWAP_PROCESS_CONTEXT
//
// Macro Description:
//
//     Change from one process address space to another.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Pfn of Page Directory for new address space.
//     a1 - Supplies the Address Space Number for new address space.
//     a2 - Supplies the ASN wrap indicator (0 = no wrap, non-zero = wrap).
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a3.
//
//--

#define SWAP_PROCESS_CONTEXT  call_pal  swpprocess

//
// Define interfaces for generate trap
//

//++
//
// GENERATE_TRAP
//
// Macro Description:
//
//     Generate a trap.  Code has discovered an exception condition
//     and wants to raise a trap to indicate the condition.  Anticipated
//     for use by compilers for divide by zero, etc..
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     a0 = Supplies the trap number which identifies the exception.
//
// Return Value:
//
//     Does not return, generates a trap to kernel mode, no return value.
//
// Registers Used:
//
//     None.
//
//--

#define GENERATE_TRAP call_pal gentrap

//
// Define performance and debug interfaces.
//

//++
//
// GET_INTERNAL_COUNTERS
//
// Macro Description:
//
//     Read the internal processor event counters.  The counter formats
//     and the events counted are processor implementation-dependent.
//
//     N.B. - the counters will only be implemented for checked builds.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     a0 - Supplies the superpage 32 address of the buffer to receive
//          the counter data.  The address must be quadword aligned.
//
//     a1 - Supplies the length of the buffer allocated for the counters.
//
// Return Value:
//
//     v0 - 0 is returned if the interface is not implemented.
//          If v0 <= a1 then v0 is the length of the data returned.
//          If v0 > a1 then v0 is the length of the processor implementation
//          counter record.
//
// Registers Used:
//
//     AT, a2 - a3.
//
//--

#define GET_INTERNAL_COUNTERS  call_pal rdcounters

//++
//
// GET_INTERNAL_PROCESSOR_STATE
//
// Macro Description:
//
//     Read the internal processor state.  The data values returned and
//     their format are processor implementation-dependent.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     a0 - Supplies the superpage 32 address of the buffer to receive
//          the processor state data.  The address must be quadword aligned.
//
//     a1 - Supplies the length of the buffer allocated for the state.
//
// Return Value:
//
//     v0 - If v0 <= a1 then v0 is the length of the data returned.
//          If v0 > a1 then v0 is the length of the processor implementation
//          state record.
//
// Registers Used:
//
//     AT, a2 - a3.
//
//--

#define GET_INTERNAL_PROCESSOR_STATE  call_pal rdstate

//++
//
// WRITE_PERFORMANCE_COUNTERS
//
// Macro Description:
//
//     Write the state of the internal processor performance counters.
//     The number of performance counters, the events they count, and their
//     usage is processor implementation-depedent.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     a0 - Supplies the number of the performance counter.
//
//     a1 - Supplies a flag that indicates if the performance counter is
//          to be enabled or disabled (0 = disabled, non-zero = enabled).
//
//     a2 - a5 - Supply processor implementation-dependent parameters.
//
// Return Value:
//
//     v0 - 0 is returned if the operation is unsuccessful or the performance
//          counter does not exist.  Otherwise, a non-zero value is returned.
//
// Registers Used:
//
//     AT, a2 - a5.
//
//--

#define WRITE_PERFORMANCE_COUNTERS  call_pal wrperfmon


//
// Define interfaces for controlling the state of machine checks.
//

//++
//
// DRAIN_ABORTS
//
// Macro Description:
//
//     Stall processor execution until all previous instructions have
//     executed to the point that any exceptions they may raise have been
//     signalled.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     None.
//
//--

#define DRAIN_ABORTS  call_pal draina


//++
//
// GET_MACHINE_CHECK_ERROR_SUMMARY
//
// Macro Description:
//
//     Read the processor machine check error summary register.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 - The value of the MCES register.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_MACHINE_CHECK_ERROR_SUMMARY  call_pal rdmces


//++
//
// WRITE_MACHINE_CHECK_ERROR_SUMMARY
//
// Macro Description:
//
//     Write new values to the machine check error summary register.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     a0 - Supplies the values to write to the MCES register.
//
// Return Value:
//
//     v0 - Previous value of the MCES register.
//
// Registers Used:
//
//     AT, a1 - a3.
//
//--

#define WRITE_MACHINE_CHECK_ERROR_SUMMARY  call_pal wrmces


//
// Define enabling and disabling alignment fixups in PAL
//

//++
//
// DISABLE_ALIGNMENT_FIXUPS
//
// Macro Description:
//
//     Disable all alignment fixups done in PAL.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     None.
//
//--

#define DISABLE_ALIGNMENT_FIXUPS        call_pal dalnfix

//++
//
// ENABLE_ALIGNMENT_FIXUPS
//
// Macro Description:
//
//     Enable alignment fixups done in PAL if the PAL supports it.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     None.
//
//--

#define ENABLE_ALIGNMENT_FIXUPS         call_pal ealnfix

//++
//
// LoadByte(
//     Register Value,
//     Offset(Register) Base
//     )
//
// Macro Description:
//
//     Loades the byte at the base address defined by the
//     offset + register expression Base into the register Value
//
// Arguments:
//
//     Value - Supplies the string name of the destination register
//
//     Base - Supplies the base address (as an offset(register) string) of
//            the source of the byte.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT
//
//--

#define LoadByte( Value, Base )        \
        .set    noat;                  \
        lda     AT, Base;              \
        ldq_u   Value, Base;           \
        extbl   Value, AT, Value;      \
        .set    at;


//++
//
// StoreByte(
//     Register Value,
//     Offset(Register) Base
//     )
//
// Macro Description:
//
//     Store the low byte of the register Value at the base address
//     defined by the offset + register expression Base.
//
//     N.B. - This macro preserves longword granularity of accesses.
//
// Arguments:
//
//     Value - Supplies the string name of the register containing the store
//             data.
//
//     Base - Supplies the base address (as an offset(register) string) of
//            the destination of the store.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, t12.
//
//--

#define StoreByte( Value, Base )        \
        .set    noat;                   \
        lda     AT, Base;               \
        ldq_u   t12, (AT);              \
        mskbl   t12, AT, t12;           \
        insbl   Value, AT, AT;          \
        bis     t12, AT, t12;           \
        lda     AT, Base;               \
        bic     AT, 3, AT;              \
        extll   t12, AT, t12;           \
        stl     t12, 0(AT);             \
        .set    at;


//++
//
// ZeroByte(
//     Offset(Register) Base
//     )
//
// Macro Description:
//
//     Zeroes the byte at the address defined by the offset + register
//     expression Base.
//
//     N.B. - This macro preserves longword granularity of accesses.
//
// Arguments:
//
//     Base - Supplies the base address (as an offset(register) string) of
//            the destination of the store.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, t12.
//
//--

#define ZeroByte( Base )        \
        .set    noat;                   \
        lda     AT, Base;               \
        ldq_u   t12, (AT);              \
        mskbl   t12, AT, t12;           \
        bic     AT, 3, AT;              \
        extll   t12, AT, t12;           \
        stl     t12, (AT);              \
        .set    at;


//++
//
// StoreWord(
//     Register Value,
//     Offset(Register) Base
//     )
//
// Macro Description:
//
//     Store the word of the register Value at the word aligned base address
//     defined by the offset + register expression Base.
//
//     N.B. - This macro preserves longword granularity of accesses.
//
//     N.B. - The destination must be word-aligned.
//
// Arguments:
//
//     Value - Supplies the string name of the register containing the store
//             data.
//
//     Base - Supplies the base address (as an offset(register) string) of
//            the destination of the store.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, t12.
//
//--

#define StoreWord( Value, Base )        \
        .set    noat;                   \
        lda     AT, Base;               \
        ldq_u   t12, (AT);              \
        mskwl   t12, AT, t12;           \
        inswl   Value, AT, AT;          \
        bis     t12, AT, t12;           \
        lda     AT, Base;               \
        bic     AT, 3, AT;              \
        extll   t12, AT, t12;           \
        stl     t12, 0(AT);             \
        .set    at;

//
// Define subtitle macro
//

#define SBTTL(x)

//
// Define mnemonic for writing callpal in assembly language that will
// fit in the opcode field.
//

#define callpal call_pal

//
// Define exception data section and align.
//
// Nearly all source files that include this header file need the following
// few pseudo-ops and so, by default, they are placed once here rather than
// repeated in every source file.  If these pseudo-ops are not needed, then
// define HEADER_FILE prior to including this file.
//
// Also the PALCODE environment uses this include file but cannot use
// these definitions.
//

#if  !defined(HEADER_FILE) && !defined(PALCODE)

        .edata 0
        .align 2
        .text

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmbrowsr.h ===
/*++ BUILD Version: 0007    // Increment this if a change has global effects

Copyright 1990 - 1998 Microsoft Corporation

Module Name:

    lmbrowsr.h

Abstract:

    This file contains information about browser stubbed versions of the
    NetServer APIs.
        Function Prototypes
        Data Structures
        Definition of special values

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.


--*/

#ifndef _LMBROWSR_
#define _LMBROWSR_

#ifdef __cplusplus
extern "C" {
#endif


typedef struct _BROWSER_STATISTICS {
    LARGE_INTEGER   StatisticsStartTime;
    LARGE_INTEGER   NumberOfServerAnnouncements;
    LARGE_INTEGER   NumberOfDomainAnnouncements;
    ULONG           NumberOfElectionPackets;
    ULONG           NumberOfMailslotWrites;
    ULONG           NumberOfGetBrowserServerListRequests;
    ULONG           NumberOfServerEnumerations;
    ULONG           NumberOfDomainEnumerations;
    ULONG           NumberOfOtherEnumerations;
    ULONG           NumberOfMissedServerAnnouncements;
    ULONG           NumberOfMissedMailslotDatagrams;
    ULONG           NumberOfMissedGetBrowserServerListRequests;
    ULONG           NumberOfFailedServerAnnounceAllocations;
    ULONG           NumberOfFailedMailslotAllocations;
    ULONG           NumberOfFailedMailslotReceives;
    ULONG           NumberOfFailedMailslotWrites;
    ULONG           NumberOfFailedMailslotOpens;
    ULONG           NumberOfDuplicateMasterAnnouncements;
    LARGE_INTEGER   NumberOfIllegalDatagrams;
} BROWSER_STATISTICS, *PBROWSER_STATISTICS, *LPBROWSER_STATISTICS;

typedef struct _BROWSER_STATISTICS_100 {
    LARGE_INTEGER   StartTime;
    LARGE_INTEGER   NumberOfServerAnnouncements;
    LARGE_INTEGER   NumberOfDomainAnnouncements;
    ULONG           NumberOfElectionPackets;
    ULONG           NumberOfMailslotWrites;
    ULONG           NumberOfGetBrowserServerListRequests;
    LARGE_INTEGER   NumberOfIllegalDatagrams;
} BROWSER_STATISTICS_100, *PBROWSER_STATISTICS_100;

typedef struct _BROWSER_STATISTICS_101 {
    LARGE_INTEGER   StartTime;
    LARGE_INTEGER   NumberOfServerAnnouncements;
    LARGE_INTEGER   NumberOfDomainAnnouncements;
    ULONG           NumberOfElectionPackets;
    ULONG           NumberOfMailslotWrites;
    ULONG           NumberOfGetBrowserServerListRequests;
    LARGE_INTEGER   NumberOfIllegalDatagrams;

    ULONG           NumberOfMissedServerAnnouncements;
    ULONG           NumberOfMissedMailslotDatagrams;
    ULONG           NumberOfMissedGetBrowserServerListRequests;
    ULONG           NumberOfFailedServerAnnounceAllocations;
    ULONG           NumberOfFailedMailslotAllocations;
    ULONG           NumberOfFailedMailslotReceives;
    ULONG           NumberOfFailedMailslotWrites;
    ULONG           NumberOfFailedMailslotOpens;
    ULONG           NumberOfDuplicateMasterAnnouncements;
} BROWSER_STATISTICS_101, *PBROWSER_STATISTICS_101;


typedef struct _BROWSER_EMULATED_DOMAIN {
#ifdef MIDL_PASS
    [string] wchar_t *DomainName;
#else
    LPWSTR DomainName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string] wchar_t *EmulatedServerName;
#else
    LPWSTR EmulatedServerName;
#endif // MIDL_PASS
    DWORD Role;
} BROWSER_EMULATED_DOMAIN, *PBROWSER_EMULATED_DOMAIN;

//
// Function Prototypes - BROWSER
//

NET_API_STATUS NET_API_FUNCTION
I_BrowserServerEnum (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     transport OPTIONAL,
    IN  LPCWSTR     clientname OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPCWSTR     domain OPTIONAL,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
I_BrowserServerEnumEx (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     transport OPTIONAL,
    IN  LPCWSTR     clientname OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPCWSTR     domain OPTIONAL,
    IN  LPCWSTR     FirstNameToReturn OPTIONAL
    );


NET_API_STATUS
I_BrowserQueryOtherDomains (
    IN  LPCWSTR      servername OPTIONAL,
    OUT LPBYTE      *bufptr,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries
    );

NET_API_STATUS
I_BrowserResetNetlogonState (
    IN  LPCWSTR      servername OPTIONAL
    );

NET_API_STATUS
I_BrowserSetNetlogonState(
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR DomainName,
    IN LPWSTR EmulatedServerName OPTIONAL,
    IN DWORD Role
    );

#define BROWSER_ROLE_PDC 0x1
#define BROWSER_ROLE_BDC 0x2

NET_API_STATUS
I_BrowserQueryEmulatedDomains(
    IN LPWSTR ServerName OPTIONAL,
    OUT PBROWSER_EMULATED_DOMAIN *EmulatedDomains,
    OUT LPDWORD EntriesRead );

NET_API_STATUS
I_BrowserQueryStatistics (
    IN  LPCWSTR      servername OPTIONAL,
    OUT LPBROWSER_STATISTICS *statistics
    );

NET_API_STATUS
I_BrowserResetStatistics (
    IN  LPCWSTR      servername OPTIONAL
    );


WORD
I_BrowserServerEnumForXactsrv(
    IN LPCWSTR TransportName OPTIONAL,
    IN LPCWSTR ClientName OPTIONAL,

    IN ULONG NtLevel,
    IN USHORT ClientLevel,

    OUT PVOID Buffer,
    IN WORD BufferLength,
    IN DWORD PreferedMaximumLength,

    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,

    IN DWORD ServerType,
    IN LPCWSTR Domain,
    IN LPCWSTR FirstNameToReturn,

    OUT PWORD Converter

    );

#ifdef __cplusplus
}
#endif

#if DBG
NET_API_STATUS
I_BrowserDebugTrace(
    PWCHAR Server,
    PCHAR Buffer
    );

#endif

#endif // _LMBROWSR_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmchdev.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright 1991-1998 Microsoft Corporation

Module Name:

    lmchdev.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetCharDev
        NetCharDevQ
        NetHandle

[Environment:]

    User Mode - Win32

[Notes:]

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMCHDEV_
#define _LMCHDEV_

#ifdef __cplusplus
extern "C" {
#endif

//
// CharDev Class
//

//
// Function Prototypes - CharDev
//

NET_API_STATUS NET_API_FUNCTION
NetCharDevEnum (
    IN  LPCWSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevGetInfo (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  devname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevControl (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  devname,
    IN  DWORD   opcode
    );

//
// Data Structures - CharDev
//

typedef struct _CHARDEV_INFO_0 {
    LPWSTR  ch0_dev;
} CHARDEV_INFO_0, *PCHARDEV_INFO_0, *LPCHARDEV_INFO_0;

typedef struct _CHARDEV_INFO_1 {
    LPWSTR  ch1_dev;
    DWORD   ch1_status;
    LPWSTR  ch1_username;
    DWORD   ch1_time;
} CHARDEV_INFO_1, *PCHARDEV_INFO_1, *LPCHARDEV_INFO_1;


//
// CharDevQ Class
//

//
// Function Prototypes - CharDevQ
//

NET_API_STATUS NET_API_FUNCTION
NetCharDevQEnum (
    IN  LPCWSTR      servername,
    IN  LPCWSTR      username,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevQGetInfo (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  queuename,
    IN  LPCWSTR  username,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevQSetInfo (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  queuename,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevQPurge (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  queuename
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevQPurgeSelf (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  queuename,
    IN  LPCWSTR  computername
    );

//
// Data Structures - CharDevQ
//

typedef struct _CHARDEVQ_INFO_0 {
    LPWSTR  cq0_dev;
} CHARDEVQ_INFO_0, *PCHARDEVQ_INFO_0, *LPCHARDEVQ_INFO_0;

typedef struct _CHARDEVQ_INFO_1 {
    LPWSTR  cq1_dev;
    DWORD   cq1_priority;
    LPWSTR  cq1_devs;
    DWORD   cq1_numusers;
    DWORD   cq1_numahead;
} CHARDEVQ_INFO_1, *PCHARDEVQ_INFO_1, *LPCHARDEVQ_INFO_1;

typedef struct _CHARDEVQ_INFO_1002 {
    DWORD   cq1002_priority;
} CHARDEVQ_INFO_1002, *PCHARDEVQ_INFO_1002, *LPCHARDEVQ_INFO_1002;

typedef struct _CHARDEVQ_INFO_1003 {
    LPWSTR  cq1003_devs;
} CHARDEVQ_INFO_1003, *PCHARDEVQ_INFO_1003, *LPCHARDEVQ_INFO_1003;


//
// Special Values and Constants
//

//
//      Bits for chardev_info_1 field ch1_status.
//

#define CHARDEV_STAT_OPENED             0x02
#define CHARDEV_STAT_ERROR              0x04

//
//      Opcodes for NetCharDevControl
//

#define CHARDEV_CLOSE                   0

//
// Values for parm_err parameter.
//

#define CHARDEVQ_DEV_PARMNUM        1
#define CHARDEVQ_PRIORITY_PARMNUM   2
#define CHARDEVQ_DEVS_PARMNUM       3
#define CHARDEVQ_NUMUSERS_PARMNUM   4
#define CHARDEVQ_NUMAHEAD_PARMNUM   5

//
// Single-field infolevels for NetCharDevQSetInfo.
//

#define CHARDEVQ_PRIORITY_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + CHARDEVQ_PRIORITY_PARMNUM)
#define CHARDEVQ_DEVS_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + CHARDEVQ_DEVS_PARMNUM)

//
//      Minimum, maximum, and recommended default for priority.
//

#define CHARDEVQ_MAX_PRIORITY           1
#define CHARDEVQ_MIN_PRIORITY           9
#define CHARDEVQ_DEF_PRIORITY           5

//
//      Value indicating no requests in the queue.
//

#define CHARDEVQ_NO_REQUESTS            -1

#endif // _LMCHDEV_

//
// Handle Class
//

#ifndef _LMHANDLE_
#define _LMHANDLE_

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetHandleGetInfo (
    IN  HANDLE  handle,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetHandleSetInfo (
    IN  HANDLE  handle,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    IN  DWORD   parmnum,
    OUT LPDWORD parmerr
    );

//
//  Data Structures
//

typedef struct _HANDLE_INFO_1 {
    DWORD   hdli1_chartime;
    DWORD   hdli1_charcount;
}HANDLE_INFO_1, *PHANDLE_INFO_1, *LPHANDLE_INFO_1;

//
// Special Values and Constants
//

//
//      Handle Get Info Levels
//

#define HANDLE_INFO_LEVEL_1                 1

//
//      Handle Set Info parm numbers
//

#define HANDLE_CHARTIME_PARMNUM     1
#define HANDLE_CHARCOUNT_PARMNUM    2

#ifdef __cplusplus
}
#endif

#endif // _LMHANDLE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmconfig.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmconfig.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetConfig

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMCONFIG_
#define _LMCONFIG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define REVISED_CONFIG_APIS

//
// Function Prototypes - Config
//

NET_API_STATUS NET_API_FUNCTION
NetConfigGet (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  component,
    IN  LPCWSTR  parameter,
#ifdef REVISED_CONFIG_APIS
    OUT LPBYTE  *bufptr
#else
    OUT LPBYTE  *bufptr,
    OUT LPDWORD totalavailable
#endif
    );

NET_API_STATUS NET_API_FUNCTION
NetConfigGetAll (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  component,
#ifdef REVISED_CONFIG_APIS
    OUT LPBYTE  *bufptr
#else
    OUT LPBYTE  *bufptr,
    OUT LPDWORD totalavailable
#endif
    );


NET_API_STATUS NET_API_FUNCTION
NetConfigSet (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  reserved1 OPTIONAL,
    IN  LPCWSTR  component,
    IN  DWORD   level,
    IN  DWORD   reserved2,
    IN  LPBYTE  buf,
    IN  DWORD   reserved3
    );

NET_API_STATUS NET_API_FUNCTION
NetRegisterDomainNameChangeNotification(
    PHANDLE NotificationEventHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetUnregisterDomainNameChangeNotification(
    HANDLE NotificationEventHandle
    );

//
// Data Structures - Config
//

typedef struct _CONFIG_INFO_0 {
     LPWSTR         cfgi0_key;
     LPWSTR         cfgi0_data;
} CONFIG_INFO_0, *PCONFIG_INFO_0, *LPCONFIG_INFO_0;


#ifdef __cplusplus
}
#endif

#endif  // _LMCONFIG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\limits.h ===
/***
*limits.h - implementation dependent values
*
*       Copyright (c) 1985-2000, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains defines for a number of implementation dependent values
*       which are commonly used in C programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LIMITS
#define _INC_LIMITS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define CHAR_BIT      8         /* number of bits in a char */
#define SCHAR_MIN   (-128)      /* minimum signed char value */
#define SCHAR_MAX     127       /* maximum signed char value */
#define UCHAR_MAX     0xff      /* maximum unsigned char value */

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN   /* mimimum char value */
#define CHAR_MAX    SCHAR_MAX   /* maximum char value */
#else
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#endif  /* _CHAR_UNSIGNED */

#define MB_LEN_MAX    5             /* max. # bytes in multibyte char */
#define SHRT_MIN    (-32768)        /* minimum (signed) short value */
#define SHRT_MAX      32767         /* maximum (signed) short value */
#define USHRT_MAX     0xffff        /* maximum unsigned short value */
#define INT_MIN     (-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX       2147483647    /* maximum (signed) int value */
#define UINT_MAX      0xffffffff    /* maximum unsigned int value */
#define LONG_MIN    (-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */

#if     _INTEGRAL_MAX_BITS >= 8
#define _I8_MIN     (-127i8 - 1)    /* minimum signed 8 bit value */
#define _I8_MAX       127i8         /* maximum signed 8 bit value */
#define _UI8_MAX      0xffui8       /* maximum unsigned 8 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 16
#define _I16_MIN    (-32767i16 - 1) /* minimum signed 16 bit value */
#define _I16_MAX      32767i16      /* maximum signed 16 bit value */
#define _UI16_MAX     0xffffui16    /* maximum unsigned 16 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 32
#define _I32_MIN    (-2147483647i32 - 1) /* minimum signed 32 bit value */
#define _I32_MAX      2147483647i32 /* maximum signed 32 bit value */
#define _UI32_MAX     0xffffffffui32 /* maximum unsigned 32 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 64
/* minimum signed 64 bit value */
#define _I64_MIN    (-9223372036854775807i64 - 1)
/* maximum signed 64 bit value */
#define _I64_MAX      9223372036854775807i64
/* maximum unsigned 64 bit value */
#define _UI64_MAX     0xffffffffffffffffui64
#endif

#if     _INTEGRAL_MAX_BITS >= 128
/* minimum signed 128 bit value */
#define _I128_MIN   (-170141183460469231731687303715884105727i128 - 1)
/* maximum signed 128 bit value */
#define _I128_MAX     170141183460469231731687303715884105727i128
/* maximum unsigned 128 bit value */
#define _UI128_MAX    0xffffffffffffffffffffffffffffffffui128
#endif

#ifdef  _POSIX_

#define _POSIX_ARG_MAX      4096
#define _POSIX_CHILD_MAX    6
#define _POSIX_LINK_MAX     8
#define _POSIX_MAX_CANON    255
#define _POSIX_MAX_INPUT    255
#define _POSIX_NAME_MAX     14
#define _POSIX_NGROUPS_MAX  0
#define _POSIX_OPEN_MAX     16
#define _POSIX_PATH_MAX     255
#define _POSIX_PIPE_BUF     512
#define _POSIX_SSIZE_MAX    32767
#define _POSIX_STREAM_MAX   8
#define _POSIX_TZNAME_MAX   3

#define ARG_MAX             14500       /* 16k heap, minus overhead */
#define LINK_MAX            1024
#define MAX_CANON           _POSIX_MAX_CANON
#define MAX_INPUT           _POSIX_MAX_INPUT
#define NAME_MAX            255
#define NGROUPS_MAX         16
#define OPEN_MAX            32
#define PATH_MAX            512
#define PIPE_BUF            _POSIX_PIPE_BUF
#define SSIZE_MAX           _POSIX_SSIZE_MAX
#define STREAM_MAX          20
#define TZNAME_MAX          10

#endif  /* POSIX */

#endif  /* _INC_LIMITS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\list.h ===
//=============================================================================
//  Microsoft (R) Bloodhound (tm). Copyright (C) 1991-1999.
//
//  MODULE: list.h
//
//  Modification History
//
//  raypa           03/17/93    Created.
//=============================================================================

#if !defined(_LIST_)

#define _LIST_
#pragma pack(1)

//=============================================================================
//  The LINK structure is used to chain structures together into a list.
//=============================================================================

typedef struct _LINK *LPLINK;

typedef struct _LINK
{
    LPLINK     PrevLink;                    //... Previous or back pointer.
    LPLINK     NextLink;                    //... Next or forward pointer.
} LINK;

//=============================================================================
//  The LIST data structure.
//=============================================================================

typedef struct _LIST
{
    LPLINK      Tail;                       //... List Tail pointer.
    LPLINK      Head;                       //... List Head pointer.
    DWORD       Length;                     //... List Length.
} LIST;

typedef LIST *LPLIST;


#ifndef NO_INLINE

#ifndef INLINE
#define INLINE __inline
#endif

//=============================================================================
//  FUNCTIONS.
//=============================================================================

INLINE LPLINK WINAPI GetPrevLink(LPLINK Link)
{
    return Link->PrevLink;
}

INLINE LPLINK WINAPI GetNextLink(LPLINK Link)
{
    return Link->NextLink;
}

INLINE LPLINK WINAPI GetHeadOfList(LPLIST List)
{
    return List->Head;
}

INLINE LPLINK WINAPI GetTailOfList(LPLIST List)
{
    return List->Tail;
}

INLINE DWORD WINAPI GetListLength(LPLIST List)
{
    return List->Length;
}

//=============================================================================
//  FUNCTION: InitializeList()
//
//  Modification History
//                               
//  raypa           04/15/93        Created
//=============================================================================

INLINE LPLIST WINAPI InitializeList(LPLIST List)
{
    List->Head    = (LPLINK) 0L;
    List->Tail    = (LPLINK) 0L;
    List->Length  = 0;

    return List;
}

//=============================================================================
//  FUNCTION: AddLinkToLink()
//
//  Modification History
//                               
//  raypa           04/15/93        Created
//=============================================================================

INLINE VOID WINAPI AddLinkToLink(LPLINK DstLink, LPLINK SrcLink)
{
    //=========================================================================
    //  Make the source link point at the destination link.
    //=========================================================================

    SrcLink->PrevLink = DstLink;
    SrcLink->NextLink = DstLink->NextLink;

    //=========================================================================
    //  Make the destination link point at the source link.
    //=========================================================================

    DstLink->NextLink->PrevLink = SrcLink;
    DstLink->NextLink = SrcLink;
}

//=============================================================================
//  FUNCTION: AddToList()
//
//  Modification History
//                               
//  raypa           04/15/93        Created
//=============================================================================

INLINE LPLINK WINAPI AddToList(LPLIST List, LPLINK DstLink, LPLINK SrcLink)
{
    //=========================================================================
    //  Grow the list length by one.
    //=========================================================================

    List->Length++;

    //=========================================================================
    //  If SrcLink is NULL then add DstLink to the end of the list.
    //=========================================================================

    if ( SrcLink == (LPLINK) 0L )
    {
        //=====================================================================
        //  If the tail pointer is NULL then the list is empty.
        //=====================================================================

        if ( List->Tail != (LPLINK) 0L )
        {
            AddLinkToLink(List->Tail, DstLink);
        }
        else
        {
            DstLink->PrevLink = DstLink;
            DstLink->NextLink = DstLink;

            List->Head = DstLink;
        }

        return (List->Tail = DstLink);
    }

    //=========================================================================
    //  If DstLink is NULL then add SrcLink to the front of the list.
    //=========================================================================

    if ( DstLink == (LPLINK) 0L )
    {
        //=====================================================================
        //  If the head pointer is NULL then the list is empty.
        //=====================================================================

        if ( List->Head != (LPLINK) 0L )
        {
            AddLinkToLink(List->Head, SrcLink);
        }
        else
        {
            SrcLink->PrevLink = SrcLink;
            SrcLink->NextLink = SrcLink;

            List->Tail = SrcLink;
        }

        return (List->Head = SrcLink);
    }

    //=========================================================================
    //  Neither DstLink nor SrcLink is NULL so link them together.
    //=========================================================================

    AddLinkToLink(DstLink, SrcLink);

    return SrcLink;
}

//=============================================================================
//  FUNCTION: DeleteFromList()
//
//  Modification History
//                               
//  raypa           04/15/93        Created
//=============================================================================

INLINE LPLINK WINAPI DeleteFromList(LPLIST List, LPLINK Link)
{
    //=========================================================================
    //  If the list is empty then return NULL.
    //=========================================================================

    if ( List->Length != 0 )
    {
        //=====================================================================
        //  If the list length is not zero then we may need to fixup head and
        //  tail pointers in the event we delete the first or last link,
        //  respectively.
        //=====================================================================

        if ( --List->Length != 0 )
        {
            //=================================================================
            //  If we are deleting the front link then fixup the head pointer.
            //=================================================================

            if ( List->Head == Link )
            {
                List->Head = List->Head->NextLink;
            }

            //=================================================================
            //  If we are deleting the end link then fixup the tail pointer.
            //=================================================================

            if ( List->Tail == Link )
            {
                List->Tail = List->Tail->PrevLink;
            }

            //=================================================================
            //  Now we can unlink this link from the list.
            //=================================================================

            Link->NextLink->PrevLink = Link->PrevLink;
            Link->PrevLink->NextLink = Link->NextLink;
        }
        else
        {
            //=================================================================
            //  There is only one link on the list and we just deleted it.
            //=================================================================

            List->Head = (LPLINK) 0L;
            List->Tail = (LPLINK) 0L;
        }

        return Link;
    }

    return (LPLINK) 0L;
}

//=============================================================================
//  FUNCTION: AddToFrontOfList()
//
//  Modification History
//                               
//  raypa           04/15/93        Created
//=============================================================================

INLINE LPLINK WINAPI AddToFrontOfList(LPLIST List, LPLINK Link)
{
    return AddToList(List, (LPLINK) 0L, Link);
}

//=============================================================================
//  FUNCTION: AddToEndOfList()
//
//  Modification History
//                               
//  raypa           04/15/93        Created
//=============================================================================

INLINE LPLINK WINAPI AddToEndOfList(LPLIST List, LPLINK Link)
{
    return AddToList(List, Link, (LPLINK) 0L);
}

//=============================================================================
//  FUNCTION: DeleteFromFrontOfList()
//
//  Modification History
//                               
//  raypa           04/15/93        Created
//=============================================================================

INLINE LPLINK WINAPI DeleteFromFrontOfList(LPLIST List)
{
    return DeleteFromList(List, GetHeadOfList(List));
}

//=============================================================================
//  FUNCTION: DeleteFromEndOfList()
//
//  Modification History
//                               
//  raypa           04/15/93        Created
//=============================================================================

INLINE LPLINK WINAPI DeleteFromEndOfList(LPLIST List)
{
    return DeleteFromList(List, GetTailOfList(List));
}

#endif

#pragma pack()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmapibuf.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmapibuf.h

Abstract:

    This file contains information about NetApiBuffer APIs.

Environment:

    User Mode - Win32

Notes:

    You must include LMCONS.H before this file, since this file depends
    on values defined in LMCONS.H.

--*/

#ifndef _LMAPIBUF_
#define _LMAPIBUF_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetApiBufferAllocate(
    IN DWORD ByteCount,
    OUT LPVOID * Buffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferFree (
    IN LPVOID Buffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferReallocate(
    IN LPVOID OldBuffer OPTIONAL,
    IN DWORD NewByteCount,
    OUT LPVOID * NewBuffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferSize(
    IN LPVOID Buffer,
    OUT LPDWORD ByteCount
    );


//
// The following private function will go away eventually.
// Call NetApiBufferAllocate instead.
//
NET_API_STATUS NET_API_FUNCTION
NetapipBufferAllocate (                 // Internal Function
    IN DWORD ByteCount,
    OUT LPVOID * Buffer
    );

#ifdef __cplusplus
}
#endif

#endif // _LMAPIBUF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmmsg.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetMessage API.

[Environment:]

    User Mode - Win32

[Notes:]

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMMSG_
#define _LMMSG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetMessageNameAdd (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  msgname
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameEnum (
    IN  LPCWSTR     servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameGetInfo (
    IN  LPCWSTR servername,
    IN  LPCWSTR msgname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameDel (
    IN  LPCWSTR   servername,
    IN  LPCWSTR   msgname
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageBufferSend (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  msgname,
    IN  LPCWSTR  fromname,
    IN  LPBYTE   buf,
    IN  DWORD    buflen
    );

//
//  Data Structures
//

typedef struct _MSG_INFO_0 {
    LPWSTR  msgi0_name;
}MSG_INFO_0, *PMSG_INFO_0, *LPMSG_INFO_0;

typedef struct _MSG_INFO_1 {
    LPWSTR  msgi1_name;
    DWORD   msgi1_forward_flag;
    LPWSTR  msgi1_forward;
}MSG_INFO_1, *PMSG_INFO_1, *LPMSG_INFO_1;

//
// Special Values and Constants
//

//
// Values for msgi1_forward_flag.
//

#define MSGNAME_NOT_FORWARDED   0       // Name not forwarded
#define MSGNAME_FORWARDED_TO    0x04    // Name forward to remote station
#define MSGNAME_FORWARDED_FROM  0x10    // Name forwarded from remote station

#ifdef __cplusplus
}
#endif

#endif //_LMMSG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmcons.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation


    LMCONS.H (was NETCONS.H in LM 2.x)

Abstract:

    This file contains constants used throughout the LAN Manager
    API header files.  It should be included in any source file
    that is going to include other LAN Manager API header files or
    call a LAN Manager API.

    NOTE:  Lengths of strings are given as the maximum lengths of the
    string in characters (not bytes).  This does not include space for the
    terminating 0-characters.  When allocating space for such an item,
    use the form:

        TCHAR username[UNLEN+1];

    Definitions of the form LN20_* define those values in effect for
    LanMan 2.0.



--*/

/*NOINC*/
#ifndef NETCONS_INCLUDED

#define NETCONS_INCLUDED
#if _MSC_VER > 1000
#pragma once
#endif

/*INC*/

#ifndef PASCAL
#define PASCAL                          // pascal on OS/2
#endif

#ifndef FAR
#define FAR                             // far on OS/2
#endif

//
// String Lengths for various LanMan names
//

#define CNLEN       15                  // Computer name length
#define LM20_CNLEN  15                  // LM 2.0 Computer name length
#define DNLEN       CNLEN               // Maximum domain name length
#define LM20_DNLEN  LM20_CNLEN          // LM 2.0 Maximum domain name length

#if (CNLEN != DNLEN)
#error CNLEN and DNLEN are not equal
#endif

#define UNCLEN      (CNLEN+2)           // UNC computer name length
#define LM20_UNCLEN (LM20_CNLEN+2)      // LM 2.0 UNC computer name length

#define NNLEN       80                  // Net name length (share name)
#define LM20_NNLEN  12                  // LM 2.0 Net name length

#define RMLEN       (UNCLEN+1+NNLEN)    // Max remote name length
#define LM20_RMLEN  (LM20_UNCLEN+1+LM20_NNLEN) // LM 2.0 Max remote name length

#define SNLEN       80                  // Service name length
#define LM20_SNLEN  15                  // LM 2.0 Service name length
#define STXTLEN     256                 // Service text length
#define LM20_STXTLEN 63                 // LM 2.0 Service text length

#define PATHLEN     256                 // Max. path (not including drive name)
#define LM20_PATHLEN 256                // LM 2.0 Max. path

#define DEVLEN      80                  // Device name length
#define LM20_DEVLEN 8                   // LM 2.0 Device name length

#define EVLEN       16                  // Event name length

//
// User, Group and Password lengths
//

#define UNLEN       256                 // Maximum user name length
#define LM20_UNLEN  20                  // LM 2.0 Maximum user name length

#define GNLEN       UNLEN               // Group name
#define LM20_GNLEN  LM20_UNLEN          // LM 2.0 Group name

#define PWLEN       256                 // Maximum password length
#define LM20_PWLEN  14                  // LM 2.0 Maximum password length

#define SHPWLEN     8                   // Share password length (bytes)


#define CLTYPE_LEN  12                  // Length of client type string


#define MAXCOMMENTSZ 256                // Multipurpose comment length
#define LM20_MAXCOMMENTSZ 48            // LM 2.0 Multipurpose comment length

#define QNLEN       NNLEN               // Queue name maximum length
#define LM20_QNLEN  LM20_NNLEN          // LM 2.0 Queue name maximum length
#if (QNLEN != NNLEN)
# error QNLEN and NNLEN are not equal
#endif

//
// The ALERTSZ and MAXDEVENTRIES defines have not yet been NT'ized.
// Whoever ports these components should change these values appropriately.
//

#define ALERTSZ     128                 // size of alert string in server
#define MAXDEVENTRIES (sizeof (int)*8)  // Max number of device entries

                                        //
                                        // We use int bitmap to represent
                                        //

#define NETBIOS_NAME_LEN  16            // NetBIOS net name (bytes)

//
// Value to be used with APIs which have a "preferred maximum length"
// parameter.  This value indicates that the API should just allocate
// "as much as it takes."
//

#define MAX_PREFERRED_LENGTH    ((DWORD) -1)

//
//        Constants used with encryption
//

#define CRYPT_KEY_LEN           7
#define CRYPT_TXT_LEN           8
#define ENCRYPTED_PWLEN         16
#define SESSION_PWLEN           24
#define SESSION_CRYPT_KLEN      21

//
//  Value to be used with SetInfo calls to allow setting of all
//  settable parameters (parmnum zero option)
//
#ifndef PARMNUM_ALL
#define PARMNUM_ALL             0
#endif

#define PARM_ERROR_UNKNOWN      ( (DWORD) (-1) )
#define PARM_ERROR_NONE         0
#define PARMNUM_BASE_INFOLEVEL  1000

//
// Only the UNICODE version of the LM APIs are available on NT.
// Non-UNICODE version on other platforms
//
#if defined( _WIN32_WINNT ) || defined( WINNT ) || defined( __midl ) \
    || defined( FORCE_UNICODE )
#define LMSTR   LPWSTR
#define LMCSTR  LPCWSTR
#else
#define LMSTR   LPSTR
#define LMCSTR  LPCSTR
#endif

//
//        Message File Names
//

#define MESSAGE_FILENAME        TEXT("NETMSG")
#define OS2MSG_FILENAME         TEXT("BASE")
#define HELP_MSG_FILENAME       TEXT("NETH")

/**INTERNAL_ONLY**/

// The backup message file named here is a duplicate of net.msg. It
// is not shipped with the product, but is used at buildtime to
// msgbind certain messages to netapi.dll and some of the services.
// This allows for OEMs to modify the message text in net.msg and
// have those changes show up.        Only in case there is an error in
// retrieving the messages from net.msg do we then get the bound
// messages out of bak.msg (really out of the message segment).

#define BACKUP_MSG_FILENAME     TEXT("BAK.MSG")

/**END_INTERNAL**/

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

//
// Keywords used in Function Prototypes
//

#define NET_API_STATUS          DWORD
#define API_RET_TYPE            NET_API_STATUS      // Old value: do not use
#if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define NET_API_FUNCTION    __stdcall
#else
#define NET_API_FUNCTION
#endif

// Define pseudo-keywords.
#ifndef IN
#define IN
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef OUT
#define OUT
#endif
/*INC*/



//
// The platform ID indicates the levels to use for platform-specific
// information.
//

#define PLATFORM_ID_DOS 300
#define PLATFORM_ID_OS2 400
#define PLATFORM_ID_NT  500
#define PLATFORM_ID_OSF 600
#define PLATFORM_ID_VMS 700

//
//      There message numbers assigned to different LANMAN components
//      are as defined below.
//
//      lmerr.h:        2100 - 2999     NERR_BASE
//      alertmsg.h:     3000 - 3049     ALERT_BASE
//      lmsvc.h:        3050 - 3099     SERVICE_BASE
//      lmerrlog.h:     3100 - 3299     ERRLOG_BASE
//      msgtext.h:      3300 - 3499     MTXT_BASE
//      apperr.h:       3500 - 3999     APPERR_BASE
//      apperrfs.h:     4000 - 4299     APPERRFS_BASE
//      apperr2.h:      4300 - 5299     APPERR2_BASE
//      ncberr.h:       5300 - 5499     NRCERR_BASE
//      alertmsg.h:     5500 - 5599     ALERT2_BASE
//      lmsvc.h:        5600 - 5699     SERVICE2_BASE
//      lmerrlog.h      5700 - 5899     ERRLOG2_BASE
//

#define MIN_LANMAN_MESSAGE_ID  NERR_BASE
#define MAX_LANMAN_MESSAGE_ID  5899

/*NOINC*/
#endif // NETCONS_INCLUDED
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmaccess.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmaccess.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetUser, NetUserModals, NetGroup, NetAccess, and NetLogon API.

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

//
// User Class
//

#ifndef _LMUSER_
#define _LMUSER_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>     // unfortunately created a dependence on this

//
// Function Prototypes - User
//

NET_API_STATUS NET_API_FUNCTION
NetUserAdd (
    IN  LPCWSTR     servername OPTIONAL,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    OUT LPDWORD    parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserEnum (
    IN  LPCWSTR     servername OPTIONAL,
    IN  DWORD      level,
    IN  DWORD      filter,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetInfo (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     username,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetUserSetInfo (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    OUT LPDWORD   parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserDel (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetGroups (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username,
    IN  DWORD     level,
    OUT LPBYTE    *bufptr,
    IN  DWORD     prefmaxlen,
    OUT LPDWORD   entriesread,
    OUT LPDWORD   totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserSetGroups (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    IN  DWORD     num_entries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetLocalGroups (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username,
    IN  DWORD     level,
    IN  DWORD     flags,
    OUT LPBYTE    *bufptr,
    IN  DWORD     prefmaxlen,
    OUT LPDWORD   entriesread,
    OUT LPDWORD   totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserModalsGet (
    IN  LPCWSTR    servername OPTIONAL,
    IN  DWORD     level,
    OUT LPBYTE    *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetUserModalsSet (
    IN  LPCWSTR    servername OPTIONAL,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    OUT LPDWORD   parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserChangePassword (
    IN  LPCWSTR   domainname OPTIONAL,
    IN  LPCWSTR   username OPTIONAL,
    IN  LPCWSTR   oldpassword,
    IN  LPCWSTR   newpassword
    );


//
//  Data Structures - User
//

typedef struct _USER_INFO_0 {
    LPWSTR   usri0_name;
}USER_INFO_0, *PUSER_INFO_0, *LPUSER_INFO_0;

typedef struct _USER_INFO_1 {
    LPWSTR   usri1_name;
    LPWSTR   usri1_password;
    DWORD    usri1_password_age;
    DWORD    usri1_priv;
    LPWSTR   usri1_home_dir;
    LPWSTR   usri1_comment;
    DWORD    usri1_flags;
    LPWSTR   usri1_script_path;
}USER_INFO_1, *PUSER_INFO_1, *LPUSER_INFO_1;

typedef struct _USER_INFO_2 {
    LPWSTR   usri2_name;
    LPWSTR   usri2_password;
    DWORD    usri2_password_age;
    DWORD    usri2_priv;
    LPWSTR   usri2_home_dir;
    LPWSTR   usri2_comment;
    DWORD    usri2_flags;
    LPWSTR   usri2_script_path;
    DWORD    usri2_auth_flags;
    LPWSTR   usri2_full_name;
    LPWSTR   usri2_usr_comment;
    LPWSTR   usri2_parms;
    LPWSTR   usri2_workstations;
    DWORD    usri2_last_logon;
    DWORD    usri2_last_logoff;
    DWORD    usri2_acct_expires;
    DWORD    usri2_max_storage;
    DWORD    usri2_units_per_week;
    PBYTE    usri2_logon_hours;
    DWORD    usri2_bad_pw_count;
    DWORD    usri2_num_logons;
    LPWSTR   usri2_logon_server;
    DWORD    usri2_country_code;
    DWORD    usri2_code_page;
}USER_INFO_2, *PUSER_INFO_2, *LPUSER_INFO_2;

typedef struct _USER_INFO_3 {
    LPWSTR   usri3_name;
    LPWSTR   usri3_password;
    DWORD    usri3_password_age;
    DWORD    usri3_priv;
    LPWSTR   usri3_home_dir;
    LPWSTR   usri3_comment;
    DWORD    usri3_flags;
    LPWSTR   usri3_script_path;
    DWORD    usri3_auth_flags;
    LPWSTR   usri3_full_name;
    LPWSTR   usri3_usr_comment;
    LPWSTR   usri3_parms;
    LPWSTR   usri3_workstations;
    DWORD    usri3_last_logon;
    DWORD    usri3_last_logoff;
    DWORD    usri3_acct_expires;
    DWORD    usri3_max_storage;
    DWORD    usri3_units_per_week;
    PBYTE    usri3_logon_hours;
    DWORD    usri3_bad_pw_count;
    DWORD    usri3_num_logons;
    LPWSTR   usri3_logon_server;
    DWORD    usri3_country_code;
    DWORD    usri3_code_page;
    DWORD    usri3_user_id;
    DWORD    usri3_primary_group_id;
    LPWSTR   usri3_profile;
    LPWSTR   usri3_home_dir_drive;
    DWORD    usri3_password_expired;
}USER_INFO_3, *PUSER_INFO_3, *LPUSER_INFO_3;

typedef struct _USER_INFO_4 {
    LPWSTR   usri4_name;
    LPWSTR   usri4_password;
    DWORD    usri4_password_age;
    DWORD    usri4_priv;
    LPWSTR   usri4_home_dir;
    LPWSTR   usri4_comment;
    DWORD    usri4_flags;
    LPWSTR   usri4_script_path;
    DWORD    usri4_auth_flags;
    LPWSTR   usri4_full_name;
    LPWSTR   usri4_usr_comment;
    LPWSTR   usri4_parms;
    LPWSTR   usri4_workstations;
    DWORD    usri4_last_logon;
    DWORD    usri4_last_logoff;
    DWORD    usri4_acct_expires;
    DWORD    usri4_max_storage;
    DWORD    usri4_units_per_week;
    PBYTE    usri4_logon_hours;
    DWORD    usri4_bad_pw_count;
    DWORD    usri4_num_logons;
    LPWSTR   usri4_logon_server;
    DWORD    usri4_country_code;
    DWORD    usri4_code_page;
    PSID     usri4_user_sid;
    DWORD    usri4_primary_group_id;
    LPWSTR   usri4_profile;
    LPWSTR   usri4_home_dir_drive;
    DWORD    usri4_password_expired;
}USER_INFO_4, *PUSER_INFO_4, *LPUSER_INFO_4;

typedef struct _USER_INFO_10 {
    LPWSTR   usri10_name;
    LPWSTR   usri10_comment;
    LPWSTR   usri10_usr_comment;
    LPWSTR   usri10_full_name;
}USER_INFO_10, *PUSER_INFO_10, *LPUSER_INFO_10;

typedef struct _USER_INFO_11 {
    LPWSTR   usri11_name;
    LPWSTR   usri11_comment;
    LPWSTR   usri11_usr_comment;
    LPWSTR   usri11_full_name;
    DWORD    usri11_priv;
    DWORD    usri11_auth_flags;
    DWORD    usri11_password_age;
    LPWSTR   usri11_home_dir;
    LPWSTR   usri11_parms;
    DWORD    usri11_last_logon;
    DWORD    usri11_last_logoff;
    DWORD    usri11_bad_pw_count;
    DWORD    usri11_num_logons;
    LPWSTR   usri11_logon_server;
    DWORD    usri11_country_code;
    LPWSTR   usri11_workstations;
    DWORD    usri11_max_storage;
    DWORD    usri11_units_per_week;
    PBYTE    usri11_logon_hours;
    DWORD    usri11_code_page;
}USER_INFO_11, *PUSER_INFO_11, *LPUSER_INFO_11;

typedef struct _USER_INFO_20 {
    LPWSTR   usri20_name;
    LPWSTR   usri20_full_name;
    LPWSTR   usri20_comment;
    DWORD    usri20_flags;
    DWORD    usri20_user_id;
}USER_INFO_20, *PUSER_INFO_20, *LPUSER_INFO_20;

typedef struct _USER_INFO_21 {
    BYTE     usri21_password[ENCRYPTED_PWLEN];
}USER_INFO_21, *PUSER_INFO_21, *LPUSER_INFO_21;

typedef struct _USER_INFO_22 {
    LPWSTR   usri22_name;
    BYTE     usri22_password[ENCRYPTED_PWLEN];
    DWORD    usri22_password_age;
    DWORD    usri22_priv;
    LPWSTR   usri22_home_dir;
    LPWSTR   usri22_comment;
    DWORD    usri22_flags;
    LPWSTR   usri22_script_path;
    DWORD    usri22_auth_flags;
    LPWSTR   usri22_full_name;
    LPWSTR   usri22_usr_comment;
    LPWSTR   usri22_parms;
    LPWSTR   usri22_workstations;
    DWORD    usri22_last_logon;
    DWORD    usri22_last_logoff;
    DWORD    usri22_acct_expires;
    DWORD    usri22_max_storage;
    DWORD    usri22_units_per_week;
    PBYTE    usri22_logon_hours;
    DWORD    usri22_bad_pw_count;
    DWORD    usri22_num_logons;
    LPWSTR   usri22_logon_server;
    DWORD    usri22_country_code;
    DWORD    usri22_code_page;
}USER_INFO_22, *PUSER_INFO_22, *LPUSER_INFO_22;

typedef struct _USER_INFO_23 {
    LPWSTR   usri23_name;
    LPWSTR   usri23_full_name;
    LPWSTR   usri23_comment;
    DWORD    usri23_flags;
    PSID     usri23_user_sid;
}USER_INFO_23, *PUSER_INFO_23, *LPUSER_INFO_23;

typedef struct _USER_INFO_1003 {
     LPWSTR  usri1003_password;
} USER_INFO_1003, *PUSER_INFO_1003, *LPUSER_INFO_1003;

typedef struct _USER_INFO_1005 {
     DWORD   usri1005_priv;
} USER_INFO_1005, *PUSER_INFO_1005, *LPUSER_INFO_1005;

typedef struct _USER_INFO_1006 {
     LPWSTR  usri1006_home_dir;
} USER_INFO_1006, *PUSER_INFO_1006, *LPUSER_INFO_1006;

typedef struct _USER_INFO_1007 {
     LPWSTR  usri1007_comment;
} USER_INFO_1007, *PUSER_INFO_1007, *LPUSER_INFO_1007;

typedef struct _USER_INFO_1008 {
     DWORD   usri1008_flags;
} USER_INFO_1008, *PUSER_INFO_1008, *LPUSER_INFO_1008;

typedef struct _USER_INFO_1009 {
     LPWSTR  usri1009_script_path;
} USER_INFO_1009, *PUSER_INFO_1009, *LPUSER_INFO_1009;

typedef struct _USER_INFO_1010 {
     DWORD   usri1010_auth_flags;
} USER_INFO_1010, *PUSER_INFO_1010, *LPUSER_INFO_1010;

typedef struct _USER_INFO_1011 {
     LPWSTR  usri1011_full_name;
} USER_INFO_1011, *PUSER_INFO_1011, *LPUSER_INFO_1011;

typedef struct _USER_INFO_1012 {
     LPWSTR  usri1012_usr_comment;
} USER_INFO_1012, *PUSER_INFO_1012, *LPUSER_INFO_1012;

typedef struct _USER_INFO_1013 {
     LPWSTR  usri1013_parms;
} USER_INFO_1013, *PUSER_INFO_1013, *LPUSER_INFO_1013;

typedef struct _USER_INFO_1014 {
     LPWSTR  usri1014_workstations;
} USER_INFO_1014, *PUSER_INFO_1014, *LPUSER_INFO_1014;

typedef struct _USER_INFO_1017 {
     DWORD   usri1017_acct_expires;
} USER_INFO_1017, *PUSER_INFO_1017, *LPUSER_INFO_1017;

typedef struct _USER_INFO_1018 {
     DWORD   usri1018_max_storage;
} USER_INFO_1018, *PUSER_INFO_1018, *LPUSER_INFO_1018;

typedef struct _USER_INFO_1020 {
    DWORD   usri1020_units_per_week;
    LPBYTE  usri1020_logon_hours;
} USER_INFO_1020, *PUSER_INFO_1020, *LPUSER_INFO_1020;

typedef struct _USER_INFO_1023 {
     LPWSTR  usri1023_logon_server;
} USER_INFO_1023, *PUSER_INFO_1023, *LPUSER_INFO_1023;

typedef struct _USER_INFO_1024 {
     DWORD   usri1024_country_code;
} USER_INFO_1024, *PUSER_INFO_1024, *LPUSER_INFO_1024;

typedef struct _USER_INFO_1025 {
     DWORD   usri1025_code_page;
} USER_INFO_1025, *PUSER_INFO_1025, *LPUSER_INFO_1025;

typedef struct _USER_INFO_1051 {
     DWORD   usri1051_primary_group_id;
} USER_INFO_1051, *PUSER_INFO_1051, *LPUSER_INFO_1051;

typedef struct _USER_INFO_1052 {
     LPWSTR  usri1052_profile;
} USER_INFO_1052, *PUSER_INFO_1052, *LPUSER_INFO_1052;

typedef struct _USER_INFO_1053 {
     LPWSTR  usri1053_home_dir_drive;
} USER_INFO_1053, *PUSER_INFO_1053, *LPUSER_INFO_1053;


//
//  Data Structures - User Modals
//

typedef struct _USER_MODALS_INFO_0 {
    DWORD    usrmod0_min_passwd_len;
    DWORD    usrmod0_max_passwd_age;
    DWORD    usrmod0_min_passwd_age;
    DWORD    usrmod0_force_logoff;
    DWORD    usrmod0_password_hist_len;
}USER_MODALS_INFO_0, *PUSER_MODALS_INFO_0, *LPUSER_MODALS_INFO_0;

typedef struct _USER_MODALS_INFO_1 {
    DWORD    usrmod1_role;
    LPWSTR   usrmod1_primary;
}USER_MODALS_INFO_1, *PUSER_MODALS_INFO_1, *LPUSER_MODALS_INFO_1;

typedef struct _USER_MODALS_INFO_2 {
    LPWSTR  usrmod2_domain_name;
    PSID    usrmod2_domain_id;
}USER_MODALS_INFO_2, *PUSER_MODALS_INFO_2, *LPUSER_MODALS_INFO_2;

typedef struct _USER_MODALS_INFO_3 {
    DWORD   usrmod3_lockout_duration;
    DWORD   usrmod3_lockout_observation_window;
    DWORD   usrmod3_lockout_threshold;
}USER_MODALS_INFO_3, *PUSER_MODALS_INFO_3, *LPUSER_MODALS_INFO_3;

typedef struct _USER_MODALS_INFO_1001 {
     DWORD   usrmod1001_min_passwd_len;
} USER_MODALS_INFO_1001, *PUSER_MODALS_INFO_1001, *LPUSER_MODALS_INFO_1001;

typedef struct _USER_MODALS_INFO_1002 {
     DWORD   usrmod1002_max_passwd_age;
} USER_MODALS_INFO_1002, *PUSER_MODALS_INFO_1002, *LPUSER_MODALS_INFO_1002;

typedef struct _USER_MODALS_INFO_1003 {
     DWORD   usrmod1003_min_passwd_age;
} USER_MODALS_INFO_1003, *PUSER_MODALS_INFO_1003, *LPUSER_MODALS_INFO_1003;

typedef struct _USER_MODALS_INFO_1004 {
     DWORD   usrmod1004_force_logoff;
} USER_MODALS_INFO_1004, *PUSER_MODALS_INFO_1004, *LPUSER_MODALS_INFO_1004;

typedef struct _USER_MODALS_INFO_1005 {
     DWORD   usrmod1005_password_hist_len;
} USER_MODALS_INFO_1005, *PUSER_MODALS_INFO_1005, *LPUSER_MODALS_INFO_1005;

typedef struct _USER_MODALS_INFO_1006 {
     DWORD   usrmod1006_role;
} USER_MODALS_INFO_1006, *PUSER_MODALS_INFO_1006, *LPUSER_MODALS_INFO_1006;

typedef struct _USER_MODALS_INFO_1007 {
     LPWSTR  usrmod1007_primary;
} USER_MODALS_INFO_1007, *PUSER_MODALS_INFO_1007, *LPUSER_MODALS_INFO_1007;


//
// Special Values and Constants - User
//

//
//  Bit masks for field usriX_flags of USER_INFO_X (X = 0/1).
//

#define UF_SCRIPT                          0x0001
#define UF_ACCOUNTDISABLE                  0x0002
#define UF_HOMEDIR_REQUIRED                0x0008
#define UF_LOCKOUT                         0x0010
#define UF_PASSWD_NOTREQD                  0x0020
#define UF_PASSWD_CANT_CHANGE              0x0040
#define UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED 0x0080

//
// Account type bits as part of usri_flags.
//

#define UF_TEMP_DUPLICATE_ACCOUNT       0x0100
#define UF_NORMAL_ACCOUNT               0x0200
#define UF_INTERDOMAIN_TRUST_ACCOUNT    0x0800
#define UF_WORKSTATION_TRUST_ACCOUNT    0x1000
#define UF_SERVER_TRUST_ACCOUNT         0x2000

#define UF_MACHINE_ACCOUNT_MASK ( UF_INTERDOMAIN_TRUST_ACCOUNT | \
                                  UF_WORKSTATION_TRUST_ACCOUNT | \
                                  UF_SERVER_TRUST_ACCOUNT )

#define UF_ACCOUNT_TYPE_MASK         ( \
                    UF_TEMP_DUPLICATE_ACCOUNT | \
                    UF_NORMAL_ACCOUNT | \
                    UF_INTERDOMAIN_TRUST_ACCOUNT | \
                    UF_WORKSTATION_TRUST_ACCOUNT | \
                    UF_SERVER_TRUST_ACCOUNT \
                )

#define UF_DONT_EXPIRE_PASSWD           0x10000
#define UF_MNS_LOGON_ACCOUNT            0x20000
#define UF_SMARTCARD_REQUIRED           0x40000
#define UF_TRUSTED_FOR_DELEGATION       0x80000
#define UF_NOT_DELEGATED               0x100000
#define UF_USE_DES_KEY_ONLY            0x200000
#define UF_DONT_REQUIRE_PREAUTH        0x400000
#define UF_PASSWORD_EXPIRED            0x800000



#define UF_SETTABLE_BITS        ( \
                    UF_SCRIPT | \
                    UF_ACCOUNTDISABLE | \
                    UF_LOCKOUT | \
                    UF_HOMEDIR_REQUIRED  | \
                    UF_PASSWD_NOTREQD | \
                    UF_PASSWD_CANT_CHANGE | \
                    UF_ACCOUNT_TYPE_MASK | \
                    UF_DONT_EXPIRE_PASSWD | \
                    UF_MNS_LOGON_ACCOUNT |\
                    UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED |\
                    UF_SMARTCARD_REQUIRED | \
                    UF_TRUSTED_FOR_DELEGATION | \
                    UF_NOT_DELEGATED | \
                    UF_USE_DES_KEY_ONLY  | \
                    UF_DONT_REQUIRE_PREAUTH |\
                    UF_PASSWORD_EXPIRED \
                )

//
// bit masks for the NetUserEnum filter parameter.
//

#define FILTER_TEMP_DUPLICATE_ACCOUNT       (0x0001)
#define FILTER_NORMAL_ACCOUNT               (0x0002)
// #define FILTER_PROXY_ACCOUNT                (0x0004)
#define FILTER_INTERDOMAIN_TRUST_ACCOUNT    (0x0008)
#define FILTER_WORKSTATION_TRUST_ACCOUNT    (0x0010)
#define FILTER_SERVER_TRUST_ACCOUNT         (0x0020)

//
// bit masks for the NetUserGetLocalGroups flags
//
#define LG_INCLUDE_INDIRECT         (0x0001)

//
//  Bit masks for field usri2_auth_flags of USER_INFO_2.
//

#define AF_OP_PRINT             0x1
#define AF_OP_COMM              0x2
#define AF_OP_SERVER            0x4
#define AF_OP_ACCOUNTS          0x8
#define AF_SETTABLE_BITS        (AF_OP_PRINT | AF_OP_COMM | \
                                AF_OP_SERVER | AF_OP_ACCOUNTS)

//
//  UAS role manifests under NETLOGON
//

#define UAS_ROLE_STANDALONE     0
#define UAS_ROLE_MEMBER         1
#define UAS_ROLE_BACKUP         2
#define UAS_ROLE_PRIMARY        3

//
//  Values for ParmError for NetUserSetInfo.
//

#define USER_NAME_PARMNUM               1
#define USER_PASSWORD_PARMNUM           3
#define USER_PASSWORD_AGE_PARMNUM       4
#define USER_PRIV_PARMNUM               5
#define USER_HOME_DIR_PARMNUM           6
#define USER_COMMENT_PARMNUM            7
#define USER_FLAGS_PARMNUM              8
#define USER_SCRIPT_PATH_PARMNUM        9
#define USER_AUTH_FLAGS_PARMNUM         10
#define USER_FULL_NAME_PARMNUM          11
#define USER_USR_COMMENT_PARMNUM        12
#define USER_PARMS_PARMNUM              13
#define USER_WORKSTATIONS_PARMNUM       14
#define USER_LAST_LOGON_PARMNUM         15
#define USER_LAST_LOGOFF_PARMNUM        16
#define USER_ACCT_EXPIRES_PARMNUM       17
#define USER_MAX_STORAGE_PARMNUM        18
#define USER_UNITS_PER_WEEK_PARMNUM     19
#define USER_LOGON_HOURS_PARMNUM        20
#define USER_PAD_PW_COUNT_PARMNUM       21
#define USER_NUM_LOGONS_PARMNUM         22
#define USER_LOGON_SERVER_PARMNUM       23
#define USER_COUNTRY_CODE_PARMNUM       24
#define USER_CODE_PAGE_PARMNUM          25
#define USER_PRIMARY_GROUP_PARMNUM      51
#define USER_PROFILE                    52 // ?? Delete when convenient
#define USER_PROFILE_PARMNUM            52
#define USER_HOME_DIR_DRIVE_PARMNUM     53

//
// the new infolevel counterparts of the old info level + parmnum
//

#define USER_NAME_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + USER_NAME_PARMNUM)
#define USER_PASSWORD_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_PASSWORD_PARMNUM)
#define USER_PASSWORD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_PASSWORD_AGE_PARMNUM)
#define USER_PRIV_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + USER_PRIV_PARMNUM)
#define USER_HOME_DIR_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_HOME_DIR_PARMNUM)
#define USER_COMMENT_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + USER_COMMENT_PARMNUM)
#define USER_FLAGS_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + USER_FLAGS_PARMNUM)
#define USER_SCRIPT_PATH_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_SCRIPT_PATH_PARMNUM)
#define USER_AUTH_FLAGS_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_AUTH_FLAGS_PARMNUM)
#define USER_FULL_NAME_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + USER_FULL_NAME_PARMNUM)
#define USER_USR_COMMENT_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_USR_COMMENT_PARMNUM)
#define USER_PARMS_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + USER_PARMS_PARMNUM)
#define USER_WORKSTATIONS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_WORKSTATIONS_PARMNUM)
#define USER_LAST_LOGON_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_LAST_LOGON_PARMNUM)
#define USER_LAST_LOGOFF_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_LAST_LOGOFF_PARMNUM)
#define USER_ACCT_EXPIRES_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_ACCT_EXPIRES_PARMNUM)
#define USER_MAX_STORAGE_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_MAX_STORAGE_PARMNUM)
#define USER_UNITS_PER_WEEK_INFOLEVEL   \
            (PARMNUM_BASE_INFOLEVEL + USER_UNITS_PER_WEEK_PARMNUM)
#define USER_LOGON_HOURS_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_LOGON_HOURS_PARMNUM)
#define USER_PAD_PW_COUNT_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_PAD_PW_COUNT_PARMNUM)
#define USER_NUM_LOGONS_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_NUM_LOGONS_PARMNUM)
#define USER_LOGON_SERVER_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_LOGON_SERVER_PARMNUM)
#define USER_COUNTRY_CODE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_COUNTRY_CODE_PARMNUM)
#define USER_CODE_PAGE_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + USER_CODE_PAGE_PARMNUM)
#define USER_PRIMARY_GROUP_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + USER_PRIMARY_GROUP_PARMNUM)
#define USER_POSIX_ID_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_POSIX_ID_PARMNUM)
#define USER_HOME_DIR_DRIVE_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_HOME_DIR_DRIVE_PARMNUM)

//
//  For SetInfo call (parmnum 0) when password change not required
//

#define NULL_USERSETINFO_PASSWD     "              "

#define TIMEQ_FOREVER               ((unsigned long) -1L)
#define USER_MAXSTORAGE_UNLIMITED   ((unsigned long) -1L)
#define USER_NO_LOGOFF              ((unsigned long) -1L)
#define UNITS_PER_DAY               24
#define UNITS_PER_WEEK              UNITS_PER_DAY * 7

//
// Privilege levels (USER_INFO_X field usriX_priv (X = 0/1)).
//

#define USER_PRIV_MASK      0x3
#define USER_PRIV_GUEST     0
#define USER_PRIV_USER      1
#define USER_PRIV_ADMIN     2

//
// user modals related defaults
//

#define MAX_PASSWD_LEN      PWLEN
#define DEF_MIN_PWLEN       6
#define DEF_PWUNIQUENESS    5
#define DEF_MAX_PWHIST      8

#define DEF_MAX_PWAGE       TIMEQ_FOREVER               // forever
#define DEF_MIN_PWAGE       (unsigned long) 0L          // 0 days
#define DEF_FORCE_LOGOFF    (unsigned long) 0xffffffff  // never
#define DEF_MAX_BADPW       0                           // no limit
#define ONE_DAY             (unsigned long) 01*24*3600  // 01 day

//
// User Logon Validation (codes returned)
//

#define VALIDATED_LOGON         0
#define PASSWORD_EXPIRED        2
#define NON_VALIDATED_LOGON     3

#define VALID_LOGOFF            1

//
// parmnum manifests for user modals
//

#define MODALS_MIN_PASSWD_LEN_PARMNUM       1
#define MODALS_MAX_PASSWD_AGE_PARMNUM       2
#define MODALS_MIN_PASSWD_AGE_PARMNUM       3
#define MODALS_FORCE_LOGOFF_PARMNUM         4
#define MODALS_PASSWD_HIST_LEN_PARMNUM      5
#define MODALS_ROLE_PARMNUM                 6
#define MODALS_PRIMARY_PARMNUM              7
#define MODALS_DOMAIN_NAME_PARMNUM          8
#define MODALS_DOMAIN_ID_PARMNUM            9
#define MODALS_LOCKOUT_DURATION_PARMNUM     10
#define MODALS_LOCKOUT_OBSERVATION_WINDOW_PARMNUM 11
#define MODALS_LOCKOUT_THRESHOLD_PARMNUM    12

//
// the new infolevel counterparts of the old info level + parmnum
//

#define MODALS_MIN_PASSWD_LEN_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MIN_PASSWD_LEN_PARMNUM)
#define MODALS_MAX_PASSWD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MAX_PASSWD_AGE_PARMNUM)
#define MODALS_MIN_PASSWD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MIN_PASSWD_AGE_PARMNUM)
#define MODALS_FORCE_LOGOFF_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + MODALS_FORCE_LOGOFF_PARMNUM)
#define MODALS_PASSWD_HIST_LEN_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + MODALS_PASSWD_HIST_LEN_PARMNUM)
#define MODALS_ROLE_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + MODALS_ROLE_PARMNUM)
#define MODALS_PRIMARY_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + MODALS_PRIMARY_PARMNUM)
#define MODALS_DOMAIN_NAME_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + MODALS_DOMAIN_NAME_PARMNUM)
#define MODALS_DOMAIN_ID_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + MODALS_DOMAIN_ID_PARMNUM)

#endif // _LMUSER_

//
// Group Class
//

#ifndef _LMGROUP_
#define _LMGROUP_

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetGroupAdd (
    IN  LPCWSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupAddUser (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   GroupName,
    IN  LPCWSTR   username
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupEnum (
    IN  LPCWSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT PDWORD_PTR resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupGetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupSetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupDel (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupDelUser (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   GroupName,
    IN  LPCWSTR   Username
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupGetUsers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT PDWORD_PTR ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupSetUsers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

//
//  Data Structures - Group
//

typedef struct _GROUP_INFO_0 {
    LPWSTR   grpi0_name;
}GROUP_INFO_0, *PGROUP_INFO_0, *LPGROUP_INFO_0;

typedef struct _GROUP_INFO_1 {
    LPWSTR   grpi1_name;
    LPWSTR   grpi1_comment;
}GROUP_INFO_1, *PGROUP_INFO_1, *LPGROUP_INFO_1;

typedef struct _GROUP_INFO_2 {
    LPWSTR   grpi2_name;
    LPWSTR   grpi2_comment;
    DWORD    grpi2_group_id;
    DWORD    grpi2_attributes;
}GROUP_INFO_2, *PGROUP_INFO_2;

typedef struct _GROUP_INFO_3 {
    LPWSTR   grpi3_name;
    LPWSTR   grpi3_comment;
    PSID     grpi3_group_sid;
    DWORD    grpi3_attributes;
}GROUP_INFO_3, *PGROUP_INFO_3;

typedef struct _GROUP_INFO_1002 {
     LPWSTR  grpi1002_comment;
} GROUP_INFO_1002, *PGROUP_INFO_1002, *LPGROUP_INFO_1002;

typedef struct _GROUP_INFO_1005 {
     DWORD  grpi1005_attributes;
} GROUP_INFO_1005, *PGROUP_INFO_1005, *LPGROUP_INFO_1005;


typedef struct _GROUP_USERS_INFO_0 {
     LPWSTR  grui0_name;
} GROUP_USERS_INFO_0, *PGROUP_USERS_INFO_0, *LPGROUP_USERS_INFO_0;

typedef struct _GROUP_USERS_INFO_1 {
     LPWSTR  grui1_name;
     DWORD   grui1_attributes;
} GROUP_USERS_INFO_1, *PGROUP_USERS_INFO_1, *LPGROUP_USERS_INFO_1;

//
// Special Values and Constants - Group
//

#define GROUPIDMASK                 0x8000      // MSB set if uid refers
                                                // to a group

//
// Predefined group for all normal users, administrators and guests
// LOCAL is a special group for pinball local security.
//

#define GROUP_SPECIALGRP_USERS      L"USERS"
#define GROUP_SPECIALGRP_ADMINS     L"ADMINS"
#define GROUP_SPECIALGRP_GUESTS     L"GUESTS"
#define GROUP_SPECIALGRP_LOCAL      L"LOCAL"

//
// parmnum manifests for SetInfo calls (only comment is settable)
//

#define GROUP_ALL_PARMNUM           0
#define GROUP_NAME_PARMNUM          1
#define GROUP_COMMENT_PARMNUM       2
#define GROUP_ATTRIBUTES_PARMNUM    3

//
// the new infolevel counterparts of the old info level + parmnum
//

#define GROUP_ALL_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + GROUP_ALL_PARMNUM)
#define GROUP_NAME_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + GROUP_NAME_PARMNUM)
#define GROUP_COMMENT_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + GROUP_COMMENT_PARMNUM)
#define GROUP_ATTRIBUTES_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + GROUP_ATTRIBUTES_PARMNUM)
#define GROUP_POSIX_ID_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + GROUP_POSIX_ID_PARMNUM)

#endif  // _LMGROUP_

//
// LocalGroup Class
//

#ifndef _LMLOCALGROUP_
#define _LMLOCALGROUP_

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAdd (
    IN  LPCWSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAddMember (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  PSID     membersid
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupEnum (
    IN  LPCWSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT PDWORD_PTR resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupGetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupSetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDel (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDelMember (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  PSID     membersid
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupGetMembers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     localgroupname,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT PDWORD_PTR resumehandle
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupSetMembers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAddMembers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDelMembers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

//
//  Data Structures - LocalGroup
//

typedef struct _LOCALGROUP_INFO_0 {
    LPWSTR   lgrpi0_name;
}LOCALGROUP_INFO_0, *PLOCALGROUP_INFO_0, *LPLOCALGROUP_INFO_0;

typedef struct _LOCALGROUP_INFO_1 {
    LPWSTR   lgrpi1_name;
    LPWSTR   lgrpi1_comment;
}LOCALGROUP_INFO_1, *PLOCALGROUP_INFO_1, *LPLOCALGROUP_INFO_1;

typedef struct _LOCALGROUP_INFO_1002 {
     LPWSTR  lgrpi1002_comment;
}LOCALGROUP_INFO_1002, *PLOCALGROUP_INFO_1002, *LPLOCALGROUP_INFO_1002;

typedef struct _LOCALGROUP_MEMBERS_INFO_0 {
     PSID    lgrmi0_sid;
} LOCALGROUP_MEMBERS_INFO_0, *PLOCALGROUP_MEMBERS_INFO_0,
  *LPLOCALGROUP_MEMBERS_INFO_0;

typedef struct _LOCALGROUP_MEMBERS_INFO_1 {
     PSID         lgrmi1_sid;
     SID_NAME_USE lgrmi1_sidusage;
     LPWSTR       lgrmi1_name;
} LOCALGROUP_MEMBERS_INFO_1, *PLOCALGROUP_MEMBERS_INFO_1,
  *LPLOCALGROUP_MEMBERS_INFO_1;

typedef struct _LOCALGROUP_MEMBERS_INFO_2 {
     PSID         lgrmi2_sid;
     SID_NAME_USE lgrmi2_sidusage;
     LPWSTR       lgrmi2_domainandname;
} LOCALGROUP_MEMBERS_INFO_2, *PLOCALGROUP_MEMBERS_INFO_2,
  *LPLOCALGROUP_MEMBERS_INFO_2;

typedef struct _LOCALGROUP_MEMBERS_INFO_3 {
     LPWSTR       lgrmi3_domainandname;
} LOCALGROUP_MEMBERS_INFO_3, *PLOCALGROUP_MEMBERS_INFO_3,
  *LPLOCALGROUP_MEMBERS_INFO_3;

typedef struct _LOCALGROUP_USERS_INFO_0 {
     LPWSTR  lgrui0_name;
} LOCALGROUP_USERS_INFO_0, *PLOCALGROUP_USERS_INFO_0,
  *LPLOCALGROUP_USERS_INFO_0;


#define LOCALGROUP_NAME_PARMNUM          1
#define LOCALGROUP_COMMENT_PARMNUM       2

//
// Display Information APIs
//

NET_API_STATUS NET_API_FUNCTION
NetQueryDisplayInformation(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN DWORD Index,
    IN DWORD EntriesRequested,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD ReturnedEntryCount,
    OUT PVOID   *SortedBuffer );

NET_API_STATUS NET_API_FUNCTION
NetGetDisplayInformationIndex(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN LPCWSTR Prefix,
    OUT LPDWORD Index );

//
// QueryDisplayInformation levels

typedef struct _NET_DISPLAY_USER {
    LPWSTR   usri1_name;
    LPWSTR   usri1_comment;
    DWORD    usri1_flags;
    LPWSTR   usri1_full_name;
    DWORD    usri1_user_id;
    DWORD    usri1_next_index;
} NET_DISPLAY_USER, *PNET_DISPLAY_USER;

typedef struct _NET_DISPLAY_MACHINE {
    LPWSTR   usri2_name;
    LPWSTR   usri2_comment;
    DWORD    usri2_flags;
    DWORD    usri2_user_id;
    DWORD    usri2_next_index;
} NET_DISPLAY_MACHINE, *PNET_DISPLAY_MACHINE;

typedef struct _NET_DISPLAY_GROUP {
    LPWSTR   grpi3_name;
    LPWSTR   grpi3_comment;
    DWORD    grpi3_group_id;
    DWORD    grpi3_attributes;
    DWORD    grpi3_next_index;
} NET_DISPLAY_GROUP, *PNET_DISPLAY_GROUP;

#endif  // _LMLOCALGROUP_

//
// Access Class
//

#ifndef _LMACCESS_
#define _LMACCESS_



//
// Function Prototypes - Access
//
//
// The NetAccess APIs are only available to downlevel
//

#define NetAccessAdd RxNetAccessAdd

NET_API_STATUS NET_API_FUNCTION
NetAccessAdd (
    IN  LPCWSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

#define NetAccessEnum RxNetAccessEnum

NET_API_STATUS NET_API_FUNCTION
NetAccessEnum (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     BasePath,
    IN  DWORD      Recursive,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    );

#define NetAccessGetInfo RxNetAccessGetInfo

NET_API_STATUS NET_API_FUNCTION
NetAccessGetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   resource,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

#define NetAccessSetInfo RxNetAccessSetInfo

NET_API_STATUS NET_API_FUNCTION
NetAccessSetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   resource,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

#define NetAccessDel RxNetAccessDel

NET_API_STATUS NET_API_FUNCTION
NetAccessDel (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   resource
    );

#define NetAccessGetUserPerms RxNetAccessGetUserPerms

NET_API_STATUS NET_API_FUNCTION
NetAccessGetUserPerms (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   UGname,
    IN  LPCWSTR   resource,
    OUT LPDWORD  Perms
    );

//
// Data Structures - Access
//

typedef struct _ACCESS_INFO_0 {
    LPWSTR   acc0_resource_name;
}ACCESS_INFO_0, *PACCESS_INFO_0, *LPACCESS_INFO_0;

typedef struct _ACCESS_INFO_1 {
    LPWSTR   acc1_resource_name;
    DWORD    acc1_attr;
    DWORD    acc1_count;
}ACCESS_INFO_1, *PACCESS_INFO_1, *LPACCESS_INFO_1;

typedef struct _ACCESS_INFO_1002 {
     DWORD   acc1002_attr;
} ACCESS_INFO_1002, *PACCESS_INFO_1002, *LPACCESS_INFO_1002;


typedef struct _ACCESS_LIST {
    LPWSTR   acl_ugname;
    DWORD    acl_access;
}ACCESS_LIST, *PACCESS_LIST, *LPACCESS_LIST;

//
// Special Values and Constants - Access
//

//
// Maximum number of permission entries for each resource.
//

#define MAXPERMENTRIES      64

//
//  Bit values for the access permissions.  ACCESS_ALL is a handy
//  way to specify maximum permissions.  These are used in
//  acl_access field of access_list structures.
//

#define ACCESS_NONE         0
#define ACCESS_ALL          ( ACCESS_READ | \
                                ACCESS_WRITE | \
                                ACCESS_CREATE | \
                                ACCESS_EXEC | \
                                ACCESS_DELETE | \
                                ACCESS_ATRIB | \
                                ACCESS_PERM \
                            )

#define ACCESS_READ         0x01
#define ACCESS_WRITE        0x02
#define ACCESS_CREATE       0x04
#define ACCESS_EXEC         0x08
#define ACCESS_DELETE       0x10
#define ACCESS_ATRIB        0x20
#define ACCESS_PERM         0x40

#define ACCESS_GROUP        0x8000

//
// Bit values for the acc1_attr field of the ACCESS_INFO_1 structure.
//

#define ACCESS_AUDIT        0x1

#define ACCESS_SUCCESS_OPEN         0x10
#define ACCESS_SUCCESS_WRITE        0x20
#define ACCESS_SUCCESS_DELETE       0x40
#define ACCESS_SUCCESS_ACL          0x80
#define ACCESS_SUCCESS_MASK         0xF0

#define ACCESS_FAIL_OPEN            0x100
#define ACCESS_FAIL_WRITE           0x200
#define ACCESS_FAIL_DELETE          0x400
#define ACCESS_FAIL_ACL             0x800
#define ACCESS_FAIL_MASK            0xF00

#define ACCESS_FAIL_SHIFT           4

//
// Parmnum value for NetAccessSetInfo.
//

#define ACCESS_RESOURCE_NAME_PARMNUM    1
#define ACCESS_ATTR_PARMNUM             2
#define ACCESS_COUNT_PARMNUM            3
#define ACCESS_ACCESS_LIST_PARMNUM      4

//
// the new infolevel counterparts of the old info level + parmnum
//

#define ACCESS_RESOURCE_NAME_INFOLEVEL  \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_RESOURCE_NAME_PARMNUM)
#define ACCESS_ATTR_INFOLEVEL           \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_ATTR_PARMNUM)
#define ACCESS_COUNT_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_COUNT_PARMNUM)
#define ACCESS_ACCESS_LIST_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_ACCESS_LIST_PARMNUM)

//
// ACCESS_LETTERS defines a letter for each bit position in
// the acl_access field of struct access_list.  Note that some
// bits have a corresponding letter of ' ' (space).
//

#define ACCESS_LETTERS      "RWCXDAP         "

#endif // _LMACCESS_

//
// Domain Class
//

#ifndef _LMDOMAIN_
#define _LMDOMAIN_

//
// Function Prototypes - Domain
//

NET_API_STATUS NET_API_FUNCTION
NetGetDCName (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   domainname OPTIONAL,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetGetAnyDCName (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   domainname OPTIONAL,
    OUT LPBYTE  *bufptr
    );


NET_API_STATUS NET_API_FUNCTION
I_NetLogonControl(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    OUT LPBYTE *Buffer
    );

NET_API_STATUS NET_API_FUNCTION
I_NetLogonControl2(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    IN LPBYTE Data,
    OUT LPBYTE *Buffer
    );

#ifndef _NTDEF_
typedef LONG NTSTATUS, *PNTSTATUS;
#endif

NTSTATUS NET_API_FUNCTION
NetEnumerateTrustedDomains (
    IN LPWSTR ServerName OPTIONAL,
    OUT LPWSTR *DomainNames
    );



//
// Special Values and Constants - Domain
//

//
// FunctionCode values for I_NetLogonControl.
//
// NOTE : if you change the following NETLOGON_CONTROL_* values,
// change them in net\svcdlls\logonsrv\logon.idl file also.
//

#define NETLOGON_CONTROL_QUERY         1    // No-op: just query
#define NETLOGON_CONTROL_REPLICATE     2    // Force replicate on BDC
#define NETLOGON_CONTROL_SYNCHRONIZE   3    // Force synchronize on BDC
#define NETLOGON_CONTROL_PDC_REPLICATE 4    // Force PDC to broadcast change
#define NETLOGON_CONTROL_REDISCOVER    5    // Force to re-discover trusted domain DCs
#define NETLOGON_CONTROL_TC_QUERY      6    // Query status of specified trusted channel status
#define NETLOGON_CONTROL_TRANSPORT_NOTIFY 7 // Notify netlogon that a new transport has come online
#define NETLOGON_CONTROL_FIND_USER     8    // Find named user in a trusted domain
#define NETLOGON_CONTROL_CHANGE_PASSWORD 9  // Change machine password on a secure channel to a trusted domain
#define NETLOGON_CONTROL_TC_VERIFY     10   // Verify status of specified trusted channel
#define NETLOGON_CONTROL_FORCE_DNS_REG 11   // Force DNS re-registration of all registered records

// Debug function codes

#define NETLOGON_CONTROL_UNLOAD_NETLOGON_DLL 0xFFFB
#define NETLOGON_CONTROL_BACKUP_CHANGE_LOG  0xFFFC
#define NETLOGON_CONTROL_TRUNCATE_LOG       0xFFFD
#define NETLOGON_CONTROL_SET_DBFLAG         0xFFFE
#define NETLOGON_CONTROL_BREAKPOINT         0xFFFF

//
// Query level 1 for I_NetLogonControl
//

typedef struct _NETLOGON_INFO_1 {
        DWORD netlog1_flags;
        NET_API_STATUS netlog1_pdc_connection_status;
} NETLOGON_INFO_1, *PNETLOGON_INFO_1;

typedef struct _NETLOGON_INFO_2 {
        DWORD netlog2_flags;
        NET_API_STATUS netlog2_pdc_connection_status;
#ifdef MIDL_PASS
        [string] wchar_t * netlog2_trusted_dc_name;
#else
        LPWSTR netlog2_trusted_dc_name;
#endif // MIDL_PASS
        NET_API_STATUS netlog2_tc_connection_status;
} NETLOGON_INFO_2, *PNETLOGON_INFO_2;

typedef struct _NETLOGON_INFO_3 {
        DWORD netlog3_flags;
        DWORD netlog3_logon_attempts;
        DWORD netlog3_reserved1;
        DWORD netlog3_reserved2;
        DWORD netlog3_reserved3;
        DWORD netlog3_reserved4;
        DWORD netlog3_reserved5;
} NETLOGON_INFO_3, *PNETLOGON_INFO_3;

typedef struct _NETLOGON_INFO_4 {
#ifdef MIDL_PASS
        [string] wchar_t * netlog4_trusted_dc_name;
        [string] wchar_t * netlog4_trusted_domain_name;
#else
        LPWSTR netlog4_trusted_dc_name;
        LPWSTR netlog4_trusted_domain_name;
#endif // MIDL_PASS
} NETLOGON_INFO_4, *PNETLOGON_INFO_4;

//
// Values of netlog1_flags
//

#define NETLOGON_REPLICATION_NEEDED       0x01  // Database is out of date
#define NETLOGON_REPLICATION_IN_PROGRESS  0x02  // Replication is happening now
#define NETLOGON_FULL_SYNC_REPLICATION    0x04  // full sync replication required/progress
#define NETLOGON_REDO_NEEDED              0x08  // Redo of previous replication needed
#define NETLOGON_HAS_IP                   0x10  // The trusted domain DC has an IP address
#define NETLOGON_HAS_TIMESERV             0x20  // The trusted domain DC runs the Windows Time Service

#ifdef __cplusplus
}
#endif

#endif // _LMDOMAIN_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmaudit.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmaudit.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetAudit

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMAUDIT_
#define _LMAUDIT_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _LMHLOGDEFINED_
#define _LMHLOGDEFINED_

typedef struct _HLOG {
     DWORD          time;
     DWORD          last_flags;
     DWORD          offset;
     DWORD          rec_offset;
} HLOG, *PHLOG, *LPHLOG;

#define LOGFLAGS_FORWARD	0
#define LOGFLAGS_BACKWARD	0x1
#define LOGFLAGS_SEEK		0x2

#endif

//
// Function Prototypes - Audit
//

NET_API_STATUS NET_API_FUNCTION
NetAuditClear (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  backupfile OPTIONAL,
    IN  LPCWSTR  service OPTIONAL  // WARNING: buggy support before LM 2.0C!!
    );

NET_API_STATUS NET_API_FUNCTION
NetAuditRead (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  service OPTIONAL,  // WARNING: buggy support before LM 2.0C!!
    IN  LPHLOG   auditloghandle,
    IN  DWORD    offset,
    IN  LPDWORD  reserved1 OPTIONAL,
    IN  DWORD   reserved2,
    IN  DWORD   offsetflag,
    OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    OUT LPDWORD bytesread,
    OUT LPDWORD totalavailable
    );

NET_API_STATUS NET_API_FUNCTION
NetAuditWrite (
    IN  DWORD    type,
    IN  LPBYTE   buf,
    IN  DWORD    numbytes,
    IN  LPCWSTR  service OPTIONAL,
    IN  LPBYTE   reserved OPTIONAL
    );


//
// Data Structures - Audit
//

typedef struct _AUDIT_ENTRY {
     DWORD          ae_len;
     DWORD          ae_reserved;
     DWORD          ae_time;
     DWORD          ae_type;
     DWORD          ae_data_offset;  /* Offset from beginning
                              address of audit_entry */
     DWORD          ae_data_size;  // byte count of ae_data area (not incl pad).
} AUDIT_ENTRY, *PAUDIT_ENTRY, *LPAUDIT_ENTRY;

#define REVISED_AUDIT_ENTRY_STRUCT


typedef struct _AE_SRVSTATUS {
     DWORD	    ae_sv_status;
} AE_SRVSTATUS, *PAE_SRVSTATUS, *LPAE_SRVSTATUS;

typedef struct _AE_SESSLOGON {
     DWORD          ae_so_compname;
     DWORD          ae_so_username;
     DWORD          ae_so_privilege;
} AE_SESSLOGON, *PAE_SESSLOGON, *LPAE_SESSLOGON;

typedef struct _AE_SESSLOGOFF {
     DWORD          ae_sf_compname;
     DWORD          ae_sf_username;
     DWORD          ae_sf_reason;
} AE_SESSLOGOFF, *PAE_SESSLOGOFF, *LPAE_SESSLOGOFF;

typedef struct _AE_SESSPWERR {
     DWORD          ae_sp_compname;
     DWORD          ae_sp_username;
} AE_SESSPWERR, *PAE_SESSPWERR, *LPAE_SESSPWERR;

typedef struct _AE_CONNSTART {
     DWORD          ae_ct_compname;
     DWORD          ae_ct_username;
     DWORD          ae_ct_netname;
     DWORD          ae_ct_connid;
} AE_CONNSTART, *PAE_CONNSTART, *LPAE_CONNSTART;

typedef struct _AE_CONNSTOP {
     DWORD          ae_cp_compname;
     DWORD          ae_cp_username;
     DWORD          ae_cp_netname;
     DWORD          ae_cp_connid;
     DWORD          ae_cp_reason;
} AE_CONNSTOP, *PAE_CONNSTOP, *LPAE_CONNSTOP;

typedef struct _AE_CONNREJ {
     DWORD          ae_cr_compname;
     DWORD          ae_cr_username;
     DWORD          ae_cr_netname;
     DWORD          ae_cr_reason;
} AE_CONNREJ, *PAE_CONNREJ, *LPAE_CONNREJ;

typedef struct _AE_RESACCESS {
     DWORD          ae_ra_compname;
     DWORD          ae_ra_username;
     DWORD          ae_ra_resname;
     DWORD          ae_ra_operation;
     DWORD          ae_ra_returncode;
     DWORD          ae_ra_restype;
     DWORD          ae_ra_fileid;
} AE_RESACCESS, *PAE_RESACCESS, *LPAE_RESACCESS;

typedef struct _AE_RESACCESSREJ {
     DWORD          ae_rr_compname;
     DWORD          ae_rr_username;
     DWORD          ae_rr_resname;
     DWORD          ae_rr_operation;
} AE_RESACCESSREJ, *PAE_RESACCESSREJ, *LPAE_RESACCESSREJ;

typedef struct _AE_CLOSEFILE {
     DWORD          ae_cf_compname;
     DWORD          ae_cf_username;
     DWORD          ae_cf_resname;
     DWORD          ae_cf_fileid;
     DWORD          ae_cf_duration;
     DWORD          ae_cf_reason;
} AE_CLOSEFILE, *PAE_CLOSEFILE, *LPAE_CLOSEFILE;

typedef struct _AE_SERVICESTAT {
     DWORD          ae_ss_compname;
     DWORD          ae_ss_username;
     DWORD          ae_ss_svcname;
     DWORD          ae_ss_status;
     DWORD          ae_ss_code;
     DWORD          ae_ss_text;
     DWORD          ae_ss_returnval;
} AE_SERVICESTAT, *PAE_SERVICESTAT, *LPAE_SERVICESTAT;

typedef struct _AE_ACLMOD {
     DWORD          ae_am_compname;
     DWORD          ae_am_username;
     DWORD          ae_am_resname;
     DWORD          ae_am_action;
     DWORD          ae_am_datalen;
} AE_ACLMOD, *PAE_ACLMOD, *LPAE_ACLMOD;

typedef struct _AE_UASMOD {
     DWORD          ae_um_compname;
     DWORD          ae_um_username;
     DWORD          ae_um_resname;
     DWORD          ae_um_rectype;
     DWORD          ae_um_action;
     DWORD          ae_um_datalen;
} AE_UASMOD, *PAE_UASMOD, *LPAE_UASMOD;

typedef struct _AE_NETLOGON {
     DWORD          ae_no_compname;
     DWORD          ae_no_username;
     DWORD          ae_no_privilege;
     DWORD          ae_no_authflags;
} AE_NETLOGON, *PAE_NETLOGON, *LPAE_NETLOGON;

typedef struct _AE_NETLOGOFF {
     DWORD          ae_nf_compname;
     DWORD          ae_nf_username;
     DWORD          ae_nf_reserved1;
     DWORD          ae_nf_reserved2;
} AE_NETLOGOFF, *PAE_NETLOGOFF, *LPAE_NETLOGOFF;

typedef struct _AE_ACCLIM {
     DWORD          ae_al_compname;
     DWORD          ae_al_username;
     DWORD          ae_al_resname;
     DWORD          ae_al_limit;
} AE_ACCLIM, *PAE_ACCLIM, *LPAE_ACCLIM;

#define ACTION_LOCKOUT          00
#define ACTION_ADMINUNLOCK      01

typedef struct _AE_LOCKOUT {
    DWORD           ae_lk_compname;     // Ptr to computername of client.
    DWORD           ae_lk_username;     // Ptr to username of client (NULL
                                        //  if same as computername).
    DWORD           ae_lk_action;       // Action taken on account:
                                        // 0 means locked out, 1 means not.
    DWORD           ae_lk_bad_pw_count; // Bad password count at the time
                                        // of lockout.
} AE_LOCKOUT, *PAE_LOCKOUT, *LPAE_LOCKOUT;

typedef struct _AE_GENERIC {
     DWORD          ae_ge_msgfile;
     DWORD          ae_ge_msgnum;
     DWORD          ae_ge_params;
     DWORD          ae_ge_param1;
     DWORD          ae_ge_param2;
     DWORD          ae_ge_param3;
     DWORD          ae_ge_param4;
     DWORD          ae_ge_param5;
     DWORD          ae_ge_param6;
     DWORD          ae_ge_param7;
     DWORD          ae_ge_param8;
     DWORD          ae_ge_param9;
} AE_GENERIC, *PAE_GENERIC, *LPAE_GENERIC;

//
// Special Values and Constants - Audit
//

//
// 	Audit entry types (field ae_type in audit_entry).
//

#define AE_SRVSTATUS	0
#define AE_SESSLOGON	1
#define AE_SESSLOGOFF	2
#define AE_SESSPWERR	3
#define AE_CONNSTART	4
#define AE_CONNSTOP	5
#define AE_CONNREJ	6
#define AE_RESACCESS	7
#define AE_RESACCESSREJ	8
#define AE_CLOSEFILE	9
#define AE_SERVICESTAT	11
#define AE_ACLMOD	12
#define AE_UASMOD	13
#define AE_NETLOGON	14
#define AE_NETLOGOFF	15
#define AE_NETLOGDENIED 16
#define AE_ACCLIMITEXCD 17
#define AE_RESACCESS2	18
#define AE_ACLMODFAIL	19
#define AE_LOCKOUT      20
#define AE_GENERIC_TYPE 21
//
//	Values for ae_ss_status field of ae_srvstatus.
//

#define AE_SRVSTART	0
#define AE_SRVPAUSED	1
#define AE_SRVCONT	2
#define AE_SRVSTOP	3

//
// 	Values for ae_so_privilege field of ae_sesslogon.
//

#define AE_GUEST	0		
#define AE_USER		1
#define AE_ADMIN	2

//
//	Values for various ae_XX_reason fields.
//

#define AE_NORMAL	0		
#define AE_USERLIMIT	0
#define AE_GENERAL	0
#define AE_ERROR	1
#define AE_SESSDIS	1
#define AE_BADPW	1
#define AE_AUTODIS	2
#define AE_UNSHARE	2
#define AE_ADMINPRIVREQD 2
#define AE_ADMINDIS	3
#define AE_NOACCESSPERM 3
#define AE_ACCRESTRICT	4

#define	AE_NORMAL_CLOSE	0
#define	AE_SES_CLOSE	1
#define	AE_ADMIN_CLOSE	2

//
// Values for xx_subreason fields.
//

#define AE_LIM_UNKNOWN	    0
#define AE_LIM_LOGONHOURS   1
#define AE_LIM_EXPIRED	    2
#define AE_LIM_INVAL_WKSTA  3
#define AE_LIM_DISABLED     4
#define AE_LIM_DELETED	    5

//
// Values for xx_action fields
//

#define AE_MOD		0
#define AE_DELETE	1
#define AE_ADD		2

//
// Types of UAS record for um_rectype field
//

#define AE_UAS_USER	    0
#define AE_UAS_GROUP	    1
#define AE_UAS_MODALS	    2

//
// Bitmasks for auditing events
//
// The parentheses around the hex constants broke h_to_inc
// and have been purged from the face of the earth.
//

#define SVAUD_SERVICE           0x1
#define SVAUD_GOODSESSLOGON     0x6
#define SVAUD_BADSESSLOGON      0x18
#define SVAUD_SESSLOGON         (SVAUD_GOODSESSLOGON | SVAUD_BADSESSLOGON)
#define SVAUD_GOODNETLOGON      0x60
#define SVAUD_BADNETLOGON       0x180
#define SVAUD_NETLOGON          (SVAUD_GOODNETLOGON | SVAUD_BADNETLOGON)
#define SVAUD_LOGON             (SVAUD_NETLOGON | SVAUD_SESSLOGON)
#define SVAUD_GOODUSE           0x600
#define SVAUD_BADUSE            0x1800
#define SVAUD_USE               (SVAUD_GOODUSE | SVAUD_BADUSE)
#define SVAUD_USERLIST          0x2000
#define SVAUD_PERMISSIONS       0x4000
#define SVAUD_RESOURCE          0x8000
#define SVAUD_LOGONLIM		0x00010000

//
// Resource access audit bitmasks.
//

#define AA_AUDIT_ALL	    0x0001
#define AA_A_OWNER	    0x0004
#define AA_CLOSE	    0x0008
#define AA_S_OPEN	    0x0010
#define AA_S_WRITE	    0x0020
#define AA_S_CREATE	    0x0020
#define AA_S_DELETE	    0x0040
#define AA_S_ACL	    0x0080
#define AA_S_ALL	    ( AA_S_OPEN | AA_S_WRITE | AA_S_DELETE | AA_S_ACL)
#define AA_F_OPEN	    0x0100
#define AA_F_WRITE	    0x0200
#define AA_F_CREATE	    0x0200
#define AA_F_DELETE	    0x0400
#define AA_F_ACL	    0x0800
#define AA_F_ALL	    ( AA_F_OPEN | AA_F_WRITE | AA_F_DELETE | AA_F_ACL)

// Pinball-specific
#define AA_A_OPEN	    0x1000
#define AA_A_WRITE	    0x2000
#define AA_A_CREATE	    0x2000
#define AA_A_DELETE	    0x4000
#define AA_A_ACL	    0x8000
#define AA_A_ALL	    ( AA_F_OPEN | AA_F_WRITE | AA_F_DELETE | AA_F_ACL)


#ifdef __cplusplus
}
#endif

#endif  // _LMAUDIT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmrepl.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    LmRepl.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the replicator APIs.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include LmCons.h before this file.


--*/

#ifndef _LMREPL_
#define _LMREPL_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Replicator Configuration APIs
//

#define REPL_ROLE_EXPORT        1
#define REPL_ROLE_IMPORT        2
#define REPL_ROLE_BOTH          3


#define REPL_INTERVAL_INFOLEVEL         (PARMNUM_BASE_INFOLEVEL + 0)
#define REPL_PULSE_INFOLEVEL            (PARMNUM_BASE_INFOLEVEL + 1)
#define REPL_GUARDTIME_INFOLEVEL        (PARMNUM_BASE_INFOLEVEL + 2)
#define REPL_RANDOM_INFOLEVEL           (PARMNUM_BASE_INFOLEVEL + 3)


typedef struct _REPL_INFO_0 {
    DWORD          rp0_role;
    LPWSTR         rp0_exportpath;
    LPWSTR         rp0_exportlist;
    LPWSTR         rp0_importpath;
    LPWSTR         rp0_importlist;
    LPWSTR         rp0_logonusername;
    DWORD          rp0_interval;
    DWORD          rp0_pulse;
    DWORD          rp0_guardtime;
    DWORD          rp0_random;
} REPL_INFO_0, *PREPL_INFO_0, *LPREPL_INFO_0;

typedef struct _REPL_INFO_1000 {
    DWORD          rp1000_interval;
} REPL_INFO_1000, *PREPL_INFO_1000, *LPREPL_INFO_1000;

typedef struct _REPL_INFO_1001 {
    DWORD          rp1001_pulse;
} REPL_INFO_1001, *PREPL_INFO_1001, *LPREPL_INFO_1001;

typedef struct _REPL_INFO_1002 {
    DWORD          rp1002_guardtime;
} REPL_INFO_1002, *PREPL_INFO_1002, *LPREPL_INFO_1002;

typedef struct _REPL_INFO_1003 {
    DWORD          rp1003_random;
} REPL_INFO_1003, *PREPL_INFO_1003, *LPREPL_INFO_1003;


NET_API_STATUS NET_API_FUNCTION
NetReplGetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplSetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    IN const LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );


//
// Replicator Export Directory APIs
//

#define REPL_INTEGRITY_FILE     1
#define REPL_INTEGRITY_TREE     2


#define REPL_EXTENT_FILE        1
#define REPL_EXTENT_TREE        2


#define REPL_EXPORT_INTEGRITY_INFOLEVEL (PARMNUM_BASE_INFOLEVEL + 0)
#define REPL_EXPORT_EXTENT_INFOLEVEL    (PARMNUM_BASE_INFOLEVEL + 1)


typedef struct _REPL_EDIR_INFO_0 {
    LPWSTR         rped0_dirname;
} REPL_EDIR_INFO_0, *PREPL_EDIR_INFO_0, *LPREPL_EDIR_INFO_0;

typedef struct _REPL_EDIR_INFO_1 {
    LPWSTR         rped1_dirname;
    DWORD          rped1_integrity;
    DWORD          rped1_extent;
} REPL_EDIR_INFO_1, *PREPL_EDIR_INFO_1, *LPREPL_EDIR_INFO_1;

typedef struct _REPL_EDIR_INFO_2 {
    LPWSTR         rped2_dirname;
    DWORD          rped2_integrity;
    DWORD          rped2_extent;
    DWORD          rped2_lockcount;
    DWORD          rped2_locktime;
} REPL_EDIR_INFO_2, *PREPL_EDIR_INFO_2, *LPREPL_EDIR_INFO_2;

typedef struct _REPL_EDIR_INFO_1000 {
    DWORD          rped1000_integrity;
} REPL_EDIR_INFO_1000, *PREPL_EDIR_INFO_1000, *LPREPL_EDIR_INFO_1000;

typedef struct _REPL_EDIR_INFO_1001 {
    DWORD          rped1001_extent;
} REPL_EDIR_INFO_1001, *PREPL_EDIR_INFO_1001, *LPREPL_EDIR_INFO_1001;


NET_API_STATUS NET_API_FUNCTION
NetReplExportDirAdd (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    IN const LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirDel (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirEnum (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirGetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirSetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD level,
    IN const LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirLock (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirUnlock (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD unlockforce
    );


#define REPL_UNLOCK_NOFORCE     0
#define REPL_UNLOCK_FORCE       1


//
// Replicator Import Directory APIs
//


typedef struct _REPL_IDIR_INFO_0 {
    LPWSTR         rpid0_dirname;
} REPL_IDIR_INFO_0, *PREPL_IDIR_INFO_0, *LPREPL_IDIR_INFO_0;

typedef struct _REPL_IDIR_INFO_1 {
    LPWSTR         rpid1_dirname;
    DWORD          rpid1_state;
    LPWSTR         rpid1_mastername;
    DWORD          rpid1_last_update_time;
    DWORD          rpid1_lockcount;
    DWORD          rpid1_locktime;
} REPL_IDIR_INFO_1, *PREPL_IDIR_INFO_1, *LPREPL_IDIR_INFO_1;


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirAdd (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    IN const LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirDel (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirEnum (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirGetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirLock (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname
    );


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirUnlock (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD unlockforce
    );


#define REPL_STATE_OK                   0
#define REPL_STATE_NO_MASTER            1
#define REPL_STATE_NO_SYNC              2
#define REPL_STATE_NEVER_REPLICATED     3


#ifdef __cplusplus
}
#endif

#endif //_LMREPL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmerrlog.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmerrlog.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetErrorLog

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMERRLOG_
#define _LMERRLOG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Data Structures - Config
//

typedef struct _ERROR_LOG {
     DWORD         el_len;
     DWORD         el_reserved;
     DWORD         el_time;
     DWORD         el_error;
     LPWSTR        el_name;             // pointer to service name
     LPWSTR        el_text;             // pointer to string array
     LPBYTE        el_data;             // pointer to BYTE array
     DWORD         el_data_size;        // byte count of el_data area
     DWORD         el_nstrings;         // number of strings in el_text.
} ERROR_LOG, *PERROR_LOG, *LPERROR_LOG;


#define REVISED_ERROR_LOG_STRUCT


#ifndef _LMHLOGDEFINED_
#define _LMHLOGDEFINED_

typedef struct _HLOG {
     DWORD          time;
     DWORD          last_flags;
     DWORD          offset;
     DWORD          rec_offset;
} HLOG, *PHLOG, *LPHLOG;

#define LOGFLAGS_FORWARD    0
#define LOGFLAGS_BACKWARD   0x1
#define LOGFLAGS_SEEK       0x2

#endif

//
// Function Prototypes - ErrorLog
//

NET_API_STATUS NET_API_FUNCTION
NetErrorLogClear (
    IN LPCWSTR server,
    IN LPCWSTR backupfile,
    IN LPBYTE  reserved
    );

NET_API_STATUS NET_API_FUNCTION
NetErrorLogRead (
    IN LPCWSTR server,
    IN LPWSTR  reserved1,
    IN LPHLOG  errloghandle,
    IN DWORD   offset,
    IN LPDWORD reserved2,
    IN DWORD   reserved3,
    IN DWORD offsetflag,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD bytesread,
    OUT LPDWORD totalbytes
    );

NET_API_STATUS NET_API_FUNCTION
NetErrorLogWrite (
    IN LPBYTE  reserved1,
    IN DWORD   code,
    IN LPCWSTR component,
    IN LPBYTE  buffer,
    IN DWORD numbytes,
    IN LPBYTE msgbuf,
    IN DWORD strcount,
    IN LPBYTE reserved2
    );

//
// Special Values and Constants
//


//
//  Generic (could be used by more than one service)
//   error log messages from 0 to 25
//
// Do not change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define ERRLOG_BASE 3100        /* NELOG errors start here */

#define NELOG_Internal_Error        (ERRLOG_BASE + 0)
    /*
    * The operation failed because a network software error occurred.
    */

#define NELOG_Resource_Shortage     (ERRLOG_BASE + 1)
    /*
    * The system ran out of a resource controlled by the %1 option.
    */

#define NELOG_Unable_To_Lock_Segment    (ERRLOG_BASE + 2)
    /*
    * The service failed to obtain a long-term lock on the
    *  segment for network control blocks (NCBs). The error code is the data.
    */

#define NELOG_Unable_To_Unlock_Segment  (ERRLOG_BASE + 3)
    /*
    * The service failed to release the long-term lock on the
    *  segment for network control blocks (NCBs). The error code is the data.
    */

#define NELOG_Uninstall_Service     (ERRLOG_BASE + 4)
    /*
    * There was an error stopping service %1.
    *  The error code from NetServiceControl is the data.
    */

#define NELOG_Init_Exec_Fail        (ERRLOG_BASE + 5)
    /*
    * Initialization failed because of a system execution failure on
    *  path %1. The system error code is the data.
    */

#define NELOG_Ncb_Error         (ERRLOG_BASE + 6)
    /*
    * An unexpected network control block (NCB) was received. The NCB is the data.
    */

#define NELOG_Net_Not_Started       (ERRLOG_BASE + 7)
    /*
    * The network is not started.
    */

#define NELOG_Ioctl_Error       (ERRLOG_BASE + 8)
    /*
    * A DosDevIoctl or DosFsCtl to NETWKSTA.SYS failed.
    * The data shown is in this format:
    *     DWORD  approx CS:IP of call to ioctl or fsctl
    *     WORD   error code
    *     WORD   ioctl or fsctl number
    */

#define NELOG_System_Semaphore      (ERRLOG_BASE + 9)
    /*
    * Unable to create or open system semaphore %1.
    *  The error code is the data.
    */

#define NELOG_Init_OpenCreate_Err   (ERRLOG_BASE + 10)
    /*
    * Initialization failed because of an open/create error on the
    *  file %1. The system error code is the data.
    */

#define NELOG_NetBios           (ERRLOG_BASE + 11)
    /*
    * An unexpected NetBIOS error occurred.
    *  The error code is the data.
    */

#define NELOG_SMB_Illegal       (ERRLOG_BASE + 12)
    /*
    * An illegal server message block (SMB) was received.
    *  The SMB is the data.
    */

#define NELOG_Service_Fail      (ERRLOG_BASE + 13)
    /*
    * Initialization failed because the requested service %1
    *  could not be started.
   */

#define NELOG_Entries_Lost      (ERRLOG_BASE + 14)
    /*
    * Some entries in the error log were lost because of a buffer
    * overflow.
    */


//
//  Server specific error log messages from 20 to 40
//

#define NELOG_Init_Seg_Overflow     (ERRLOG_BASE + 20)
    /*
    * Initialization parameters controlling resource usage other
    *  than net buffers are sized so that too much memory is needed.
    */

#define NELOG_Srv_No_Mem_Grow       (ERRLOG_BASE + 21)
    /*
    * The server cannot increase the size of a memory segment.
    */

#define NELOG_Access_File_Bad       (ERRLOG_BASE + 22)
    /*
    * Initialization failed because account file %1 is either incorrect
    * or not present.
    */

#define NELOG_Srvnet_Not_Started    (ERRLOG_BASE + 23)
    /*
    * Initialization failed because network %1 was not started.
    */

#define NELOG_Init_Chardev_Err      (ERRLOG_BASE + 24)
    /*
    * The server failed to start. Either all three chdev
    *  parameters must be zero or all three must be nonzero.
    */

#define NELOG_Remote_API        (ERRLOG_BASE + 25)
    /* A remote API request was halted due to the following
    * invalid description string: %1.
    */

#define NELOG_Ncb_TooManyErr        (ERRLOG_BASE + 26)
    /* The network %1 ran out of network control blocks (NCBs).  You may need to increase NCBs
    * for this network.  The following information includes the
    * number of NCBs submitted by the server when this error occurred:
    */

#define NELOG_Mailslot_err      (ERRLOG_BASE + 27)
    /* The server cannot create the %1 mailslot needed to send
    * the ReleaseMemory alert message.  The error received is:
    */

#define NELOG_ReleaseMem_Alert      (ERRLOG_BASE + 28)
    /* The server failed to register for the ReleaseMemory alert,
    * with recipient %1. The error code from
    * NetAlertStart is the data.
    */

#define NELOG_AT_cannot_write       (ERRLOG_BASE + 29)
    /* The server cannot update the AT schedule file. The file
    * is corrupted.
    */

#define NELOG_Cant_Make_Msg_File    (ERRLOG_BASE + 30)
    /* The server encountered an error when calling
    * NetIMakeLMFileName. The error code is the data.
    */

#define NELOG_Exec_Netservr_NoMem   (ERRLOG_BASE + 31)
    /* Initialization failed because of a system execution failure on
    * path %1. There is not enough memory to start the process.
    * The system error code is the data.
    */

#define NELOG_Server_Lock_Failure   (ERRLOG_BASE + 32)
    /* Longterm lock of the server buffers failed.
    * Check swap disk's free space and restart the system to start the server.
    */

//
//  Message service and POPUP specific error log messages from 40 to 55
//

#define NELOG_Msg_Shutdown      (ERRLOG_BASE + 40)
    /*
    * The service has stopped due to repeated consecutive
    *  occurrences of a network control block (NCB) error.  The last bad NCB follows
    *  in raw data.
    */

#define NELOG_Msg_Sem_Shutdown      (ERRLOG_BASE + 41)
    /*
    * The Message server has stopped due to a lock on the
    *  Message server shared data segment.
    */

#define NELOG_Msg_Log_Err       (ERRLOG_BASE + 50)
    /*
    * A file system error occurred while opening or writing to the
    *  system message log file %1. Message logging has been
    *  switched off due to the error. The error code is the data.
    */



#define NELOG_VIO_POPUP_ERR     (ERRLOG_BASE + 51)
    /*
    * Unable to display message POPUP due to system VIO call error.
    *  The error code is the data.
    */

#define NELOG_Msg_Unexpected_SMB_Type   (ERRLOG_BASE + 52)
    /*
    * An illegal server message block (SMB) was received.  The SMB is the data.
    */

//
//  Workstation specific error log messages from 60 to 75
//


#define NELOG_Wksta_Infoseg     (ERRLOG_BASE + 60)
    /*
    * The workstation information segment is bigger than 64K.
    *  The size follows, in DWORD format:
    */

#define NELOG_Wksta_Compname        (ERRLOG_BASE + 61)
    /*
    * The workstation was unable to get the name-number of the computer.
    */

#define NELOG_Wksta_BiosThreadFailure   (ERRLOG_BASE + 62)
    /*
    * The workstation could not initialize the Async NetBIOS Thread.
    *  The error code is the data.
    */

#define NELOG_Wksta_IniSeg      (ERRLOG_BASE + 63)
    /*
    * The workstation could not open the initial shared segment.
    *  The error code is the data.
    */

#define NELOG_Wksta_HostTab_Full    (ERRLOG_BASE + 64)
    /*
    * The workstation host table is full.
    */

#define NELOG_Wksta_Bad_Mailslot_SMB    (ERRLOG_BASE + 65)
    /*
    * A bad mailslot server message block (SMB) was received.  The SMB is the data.
    */

#define NELOG_Wksta_UASInit     (ERRLOG_BASE + 66)
    /*
    * The workstation encountered an error while trying to start the user accounts database.
    *  The error code is the data.
    */

#define NELOG_Wksta_SSIRelogon      (ERRLOG_BASE + 67)
    /*
    * The workstation encountered an error while responding to an SSI revalidation request.
    *  The function code and the error codes are the data.
    */

//
//  Alerter service specific error log messages from 70 to 79
//


#define NELOG_Build_Name        (ERRLOG_BASE + 70)
    /*
    * The Alerter service had a problem creating the list of
    * alert recipients.  The error code is %1.
    */

#define NELOG_Name_Expansion        (ERRLOG_BASE + 71)
    /*
    * There was an error expanding %1 as a group name. Try
    *  splitting the group into two or more smaller groups.
    */

#define NELOG_Message_Send      (ERRLOG_BASE + 72)
    /*
    * There was an error sending %2 the alert message -
    *  (
    *  %3 )
    *  The error code is %1.
    */

#define NELOG_Mail_Slt_Err      (ERRLOG_BASE + 73)
    /*
    * There was an error in creating or reading the alerter mailslot.
    *  The error code is %1.
    */

#define NELOG_AT_cannot_read        (ERRLOG_BASE + 74)
    /*
    * The server could not read the AT schedule file.
    */

#define NELOG_AT_sched_err      (ERRLOG_BASE + 75)
    /*
    * The server found an invalid AT schedule record.
    */

#define NELOG_AT_schedule_file_created  (ERRLOG_BASE + 76)
    /*
    * The server could not find an AT schedule file so it created one.
    */

#define NELOG_Srvnet_NB_Open        (ERRLOG_BASE + 77)
    /*
    * The server could not access the %1 network with NetBiosOpen.
    */

#define NELOG_AT_Exec_Err       (ERRLOG_BASE + 78)
    /*
    * The AT command processor could not run %1.
   */

//
//      Cache Lazy Write and HPFS386 specific error log messages from 80 to 89
//

#define NELOG_Lazy_Write_Err            (ERRLOG_BASE + 80)
        /*
        * WARNING:  Because of a lazy-write error, drive %1 now
        *  contains some corrupted data.  The cache is stopped.
        */

#define NELOG_HotFix            (ERRLOG_BASE + 81)
    /*
    * A defective sector on drive %1 has been replaced (hotfixed).
    * No data was lost.  You should run CHKDSK soon to restore full
    * performance and replenish the volume's spare sector pool.
    *
    * The hotfix occurred while processing a remote request.
    */

#define NELOG_HardErr_From_Server   (ERRLOG_BASE + 82)
    /*
    * A disk error occurred on the HPFS volume in drive %1.
    * The error occurred while processing a remote request.
    */

#define NELOG_LocalSecFail1 (ERRLOG_BASE + 83)
    /*
    * The user accounts database (NET.ACC) is corrupted.  The local security
    * system is replacing the corrupted NET.ACC with the backup
    * made at %1.
    * Any updates made to the database after this time are lost.
    *
    */

#define NELOG_LocalSecFail2 (ERRLOG_BASE + 84)
    /*
    * The user accounts database (NET.ACC) is missing.  The local
    * security system is restoring the backup database
    * made at %1.
    * Any updates made to the database made after this time are lost.
    *
    */

#define NELOG_LocalSecFail3 (ERRLOG_BASE + 85)
    /*
    * Local security could not be started because the user accounts database
    * (NET.ACC) was missing or corrupted, and no usable backup
    * database was present.
    *
    * THE SYSTEM IS NOT SECURE.
    */

#define NELOG_LocalSecGeneralFail   (ERRLOG_BASE + 86)
    /*
    * Local security could not be started because an error
    * occurred during initialization. The error code returned is %1.
    *
    * THE SYSTEM IS NOT SECURE.
    *
    */

//
//  NETWKSTA.SYS specific error log messages from 90 to 99
//

#define NELOG_NetWkSta_Internal_Error   (ERRLOG_BASE + 90)
    /*
    * A NetWksta internal error has occurred:
    *  %1
    */

#define NELOG_NetWkSta_No_Resource  (ERRLOG_BASE + 91)
    /*
    * The redirector is out of a resource: %1.
    */

#define NELOG_NetWkSta_SMB_Err      (ERRLOG_BASE + 92)
    /*
    * A server message block (SMB) error occurred on the connection to %1.
    *  The SMB header is the data.
    */

#define NELOG_NetWkSta_VC_Err       (ERRLOG_BASE + 93)
    /*
    * A virtual circuit error occurred on the session to %1.
    *  The network control block (NCB) command and return code is the data.
    */

#define NELOG_NetWkSta_Stuck_VC_Err (ERRLOG_BASE + 94)
    /*
    * Hanging up a stuck session to %1.
    */

#define NELOG_NetWkSta_NCB_Err      (ERRLOG_BASE + 95)
    /*
    * A network control block (NCB) error occurred (%1).
    *  The NCB is the data.
    */

#define NELOG_NetWkSta_Write_Behind_Err (ERRLOG_BASE + 96)
    /*
    * A write operation to %1 failed.
    *  Data may have been lost.
    */

#define NELOG_NetWkSta_Reset_Err    (ERRLOG_BASE + 97)
    /*
    * Reset of driver %1 failed to complete the network control block (NCB).
    *  The NCB is the data.
    */

#define NELOG_NetWkSta_Too_Many     (ERRLOG_BASE + 98)
    /*
    * The amount of resource %1 requested was more
    *  than the maximum. The maximum amount was allocated.
    */

//
//  Spooler specific error log messages from 100 to 103
//

#define NELOG_Srv_Thread_Failure        (ERRLOG_BASE + 104)
    /*
    * The server could not create a thread.
    *  The THREADS parameter in the CONFIG.SYS file should be increased.
    */

#define NELOG_Srv_Close_Failure         (ERRLOG_BASE + 105)
    /*
    * The server could not close %1.
    *  The file is probably corrupted.
    */

#define NELOG_ReplUserCurDir               (ERRLOG_BASE + 106)
    /*
    *The replicator cannot update directory %1. It has tree integrity
    * and is the current directory for some process.
    */

#define NELOG_ReplCannotMasterDir       (ERRLOG_BASE + 107)
    /*
    *The server cannot export directory %1 to client %2.
    * It is exported from another server.
    */

#define NELOG_ReplUpdateError           (ERRLOG_BASE + 108)
    /*
    *The replication server could not update directory %2 from the source
    * on %3 due to error %1.
    */

#define NELOG_ReplLostMaster            (ERRLOG_BASE + 109)
    /*
    *Master %1 did not send an update notice for directory %2 at the expected
    * time.
    */

#define NELOG_NetlogonAuthDCFail        (ERRLOG_BASE + 110)
    /*
    *Failed to authenticate with %2, a Windows NT or Windows 2000 domain controller for domain %1.
    */

#define NELOG_ReplLogonFailed           (ERRLOG_BASE + 111)
    /*
    *The replicator attempted to log on at %2 as %1 and failed.
    */

#define NELOG_ReplNetErr            (ERRLOG_BASE + 112)
    /*
    *  Network error %1 occurred.
    */

#define NELOG_ReplMaxFiles            (ERRLOG_BASE + 113)
    /*
    *  Replicator limit for files in a directory has been exceeded.
    */


#define NELOG_ReplMaxTreeDepth            (ERRLOG_BASE + 114)
    /*
    *  Replicator limit for tree depth has been exceeded.
    */

#define NELOG_ReplBadMsg             (ERRLOG_BASE + 115)
    /*
    *  Unrecognized message received in mailslot.
    */

#define NELOG_ReplSysErr            (ERRLOG_BASE + 116)
    /*
    *  System error %1 occurred.
    */

#define NELOG_ReplUserLoged          (ERRLOG_BASE + 117)
    /*
    *  Cannot log on. User is currently logged on and argument TRYUSER
    *  is set to NO.
    */

#define NELOG_ReplBadImport           (ERRLOG_BASE + 118)
    /*
    *  IMPORT path %1 cannot be found.
    */

#define NELOG_ReplBadExport           (ERRLOG_BASE + 119)
    /*
    *  EXPORT path %1 cannot be found.
    */

#define NELOG_ReplSignalFileErr           (ERRLOG_BASE + 120)
    /*
    *  Replicator failed to update signal file in directory %2 due to
    *  %1 system error.
    */

#define NELOG_DiskFT                (ERRLOG_BASE+121)
    /*
    * Disk Fault Tolerance Error
    *
    * %1
    */

#define NELOG_ReplAccessDenied           (ERRLOG_BASE + 122)
    /*
    *  Replicator could not access %2
    *  on %3 due to system error %1.
    */

#define NELOG_NetlogonFailedPrimary      (ERRLOG_BASE + 123)
    /*
    *The primary domain controller for domain %1 has apparently failed.
    */

#define NELOG_NetlogonPasswdSetFailed (ERRLOG_BASE + 124)
    /*
    * Changing machine account password for account %1 failed with
    * the following error: %n%2
    */

#define NELOG_NetlogonTrackingError      (ERRLOG_BASE + 125)
    /*
    *An error occurred while updating the logon or logoff information for %1.
    */

#define NELOG_NetlogonSyncError          (ERRLOG_BASE + 126)
    /*
    *An error occurred while synchronizing with primary domain controller %1
    */

#define NELOG_NetlogonRequireSignOrSealError (ERRLOG_BASE + 127)
    /*
    * The session setup to the Windows NT or Windows 2000 Domain Controller %1 for the domain %2
    * failed because %1 does not support signing or sealing the Netlogon
    * session.
    *
    * Either upgrade the Domain controller or set the RequireSignOrSeal
    * registry entry on this machine to 0.
    */

//
//  UPS service specific error log messages from 130 to 135
//

#define NELOG_UPS_PowerOut      (ERRLOG_BASE + 130)
    /*
    * A power failure was detected at the server.
    */

#define NELOG_UPS_Shutdown      (ERRLOG_BASE + 131)
    /*
    * The UPS service performed server shut down.
    */

#define NELOG_UPS_CmdFileError      (ERRLOG_BASE + 132)
    /*
    * The UPS service did not complete execution of the
    * user specified shut down command file.
    */

#define NELOG_UPS_CannotOpenDriver  (ERRLOG_BASE+133)
    /*
    * The UPS driver could not be opened.  The error code is
    * the data.
    */

#define NELOG_UPS_PowerBack     (ERRLOG_BASE + 134)
    /*
    * Power has been restored.
    */

#define NELOG_UPS_CmdFileConfig     (ERRLOG_BASE + 135)
    /*
    * There is a problem with a configuration of user specified
    * shut down command file.
    */

#define NELOG_UPS_CmdFileExec       (ERRLOG_BASE + 136)
    /*
    * The UPS service failed to execute a user specified shutdown
    * command file %1.  The error code is the data.
    */

//
//  Remoteboot server specific error log messages are from 150 to 157
//

#define NELOG_Missing_Parameter     (ERRLOG_BASE + 150)
    /*
    * Initialization failed because of an invalid or missing
    *  parameter in the configuration file %1.
    */

#define NELOG_Invalid_Config_Line   (ERRLOG_BASE + 151)
    /*
    * Initialization failed because of an invalid line in the
    *  configuration file %1. The invalid line is the data.
    */

#define NELOG_Invalid_Config_File   (ERRLOG_BASE + 152)
    /*
    * Initialization failed because of an error in the configuration
    *  file %1.
    */

#define NELOG_File_Changed      (ERRLOG_BASE + 153)
    /*
    * The file %1 has been changed after initialization.
    *  The boot-block loading was temporarily terminated.
    */

#define NELOG_Files_Dont_Fit        (ERRLOG_BASE + 154)
    /*
    * The files do not fit to the boot-block configuration
    * file %1. Change the BASE and ORG definitions or the order
    * of the files.
    */

#define NELOG_Wrong_DLL_Version     (ERRLOG_BASE + 155)
    /*
    * Initialization failed because the dynamic-link
    *  library %1 returned an incorrect version number.
    */

#define NELOG_Error_in_DLL      (ERRLOG_BASE + 156)
    /*
    * There was an unrecoverable error in the dynamic-
    *  link library of the service.
    */

#define NELOG_System_Error      (ERRLOG_BASE + 157)
    /*
    * The system returned an unexpected error code.
    *  The error code is the data.
    */

#define NELOG_FT_ErrLog_Too_Large (ERRLOG_BASE + 158)
    /*
    * The fault-tolerance error log file, LANROOT\LOGS\FT.LOG,
    *  is more than 64K.
    */

#define NELOG_FT_Update_In_Progress (ERRLOG_BASE + 159)
    /*
    * The fault-tolerance error-log file, LANROOT\LOGS\FT.LOG, had the
    * update in progress bit set upon opening, which means that the
    * system crashed while working on the error log.
    */

#define NELOG_Joined_Domain         (ERRLOG_BASE + 160)
    /*
    * This computer has been successfully joined to %1 '%2'.
    */


//
// Microsoft has created a generic error log entry for OEMs to use to
// log errors from OEM value added services.  The code, which is the
// 2nd arg to NetErrorLogWrite, is 3299.  This value is manifest in
// NET/H/ERRLOG.H as NELOG_OEM_Code.  The text for error log entry
// NELOG_OEM_Code is:  "%1 %2 %3 %4 %5 %6 %7 %8 %9.".
//
// Microsoft suggests that OEMs use the insertion strings as follows:
// %1:  OEM System Name (e.g. 3+Open)
// %2:  OEM Service Name (e.g. 3+Mail)
// %3:  Severity level (e.g.  error, warning, etc.)
// %4:  OEM error log entry sub-identifier  (e.g. error code #)
// %5 - % 9:  Text.
//
// The call to NetErrorWrite must set nstrings = 9, and provide 9
// ASCIIZ strings.  If the caller does not have 9 insertion strings,
// provide null strings for the empty insertion strings.
//

#define NELOG_OEM_Code              (ERRLOG_BASE + 199)
    /*
    * %1 %2 %3 %4 %5 %6 %7 %8 %9.
    */

//
// another error log range defined for NT Lanman.
//

#define ERRLOG2_BASE 5700        /* New NT NELOG errors start here */

#define NELOG_NetlogonSSIInitError              (ERRLOG2_BASE + 0)
    /*
     * The Netlogon service could not initialize the replication data
     * structures successfully. The service was terminated.  The following
     * error occurred: %n%1
     */

#define NELOG_NetlogonFailedToUpdateTrustList   (ERRLOG2_BASE + 1)
    /*
     * The Netlogon service failed to update the domain trust list.  The
     * following error occurred: %n%1
     */

#define NELOG_NetlogonFailedToAddRpcInterface   (ERRLOG2_BASE + 2)
    /*
     * The Netlogon service could not add the RPC interface.  The
     * service was terminated. The following error occurred: %n%1
     */

#define NELOG_NetlogonFailedToReadMailslot      (ERRLOG2_BASE + 3)
    /*
     * The Netlogon service could not read a mailslot message from %1 due
     * to the following error: %n%2
     */

#define NELOG_NetlogonFailedToRegisterSC        (ERRLOG2_BASE + 4)
    /*
     * The Netlogon service failed to register the service with the
     * service controller. The service was terminated. The following
     * error occurred: %n%1
     */

#define NELOG_NetlogonChangeLogCorrupt          (ERRLOG2_BASE + 5)
    /*
     * The change log cache maintained by the Netlogon service for
     * database changes is corrupted. The Netlogon service is resetting
     * the change log.
     */

#define NELOG_NetlogonFailedToCreateShare       (ERRLOG2_BASE + 6)
    /*
     * The Netlogon service could not create server share %1.  The following
     * error occurred: %n%2
     */

#define NELOG_NetlogonDownLevelLogonFailed      (ERRLOG2_BASE + 7)
    /*
     * The down-level logon request for the user %1 from %2 failed.
     */

#define NELOG_NetlogonDownLevelLogoffFailed     (ERRLOG2_BASE + 8)
    /*
     * The down-level logoff request for the user %1 from %2 failed.
     */

#define NELOG_NetlogonNTLogonFailed             (ERRLOG2_BASE + 9)
    /*
     * The Windows NT or Windows 2000 %1 logon request for the user %2\%3 from %4 (via %5)
     * failed.
     */

#define NELOG_NetlogonNTLogoffFailed            (ERRLOG2_BASE + 10)
    /*
     * The Windows NT or Windows 2000 %1 logoff request for the user %2\%3 from %4
     * failed.
     */

#define NELOG_NetlogonPartialSyncCallSuccess    (ERRLOG2_BASE + 11)
    /*
     * The partial synchronization request from the server %1 completed
     * successfully. %2 changes(s) has(have) been returned to the
     * caller.
     */

#define NELOG_NetlogonPartialSyncCallFailed     (ERRLOG2_BASE + 12)
    /*
     * The partial synchronization request from the server %1 failed with
     * the following error: %n%2
     */

#define NELOG_NetlogonFullSyncCallSuccess       (ERRLOG2_BASE + 13)
    /*
     * The full synchronization request from the server %1 completed
     * successfully. %2 object(s) has(have) been returned to
     * the caller.
     */

#define NELOG_NetlogonFullSyncCallFailed        (ERRLOG2_BASE + 14)
    /*
     * The full synchronization request from the server %1 failed with
     * the following error: %n%2
     */

#define NELOG_NetlogonPartialSyncSuccess        (ERRLOG2_BASE + 15)
    /*
     * The partial synchronization replication of the %1 database from the
     * primary domain controller %2 completed successfully. %3 change(s) is(are)
     * applied to the database.
     */


#define NELOG_NetlogonPartialSyncFailed         (ERRLOG2_BASE + 16)
    /*
     * The partial synchronization replication of the %1 database from the
     * primary domain controller %2 failed with the following error: %n%3
     */

#define NELOG_NetlogonFullSyncSuccess           (ERRLOG2_BASE + 17)
    /*
     * The full synchronization replication of the %1 database from the
     * primary domain controller %2 completed successfully.
     */


#define NELOG_NetlogonFullSyncFailed            (ERRLOG2_BASE + 18)
    /*
     * The full synchronization replication of the %1 database from the
     * primary domain controller %2 failed with the following error: %n%3
     */

#define NELOG_NetlogonAuthNoDomainController    (ERRLOG2_BASE + 19)
    /*
     * No Windows NT or Windows 2000 Domain Controller is available for domain %1.
     * The following error occurred:%n%2
     */

#define NELOG_NetlogonAuthNoTrustLsaSecret      (ERRLOG2_BASE + 20)
    /*
     * The session setup to the Windows NT or Windows 2000 Domain Controller %1 for the domain %2
     * failed because the computer %3 does not have a local security database account.
     */

#define NELOG_NetlogonAuthNoTrustSamAccount     (ERRLOG2_BASE + 21)
    /*
     * The session setup to the Windows NT or Windows 2000 Domain Controller %1 for the domain %2
     * failed because the Domain Controller does not have an account
     * for the computer %3.
     */

#define NELOG_NetlogonServerAuthFailed          (ERRLOG2_BASE + 22)
    /*
     * The session setup from the computer %1 failed to authenticate.
     * The name of the account referenced in the security database is
     * %2.  The following error occurred: %n%3
     */

#define NELOG_NetlogonServerAuthNoTrustSamAccount (ERRLOG2_BASE + 23)
    /*
     * The session setup from the computer %1 failed because there is
     * no trust account in the security database for this computer. The name of
     * the account referenced in the security database is %2.
     */

//
// General log messages for NT services.
//

#define NELOG_FailedToRegisterSC                  (ERRLOG2_BASE + 24)
    /*
     * Could not register control handler with service controller %1.
     */

#define NELOG_FailedToSetServiceStatus            (ERRLOG2_BASE + 25)
    /*
     * Could not set service status with service controller %1.
     */

#define NELOG_FailedToGetComputerName             (ERRLOG2_BASE + 26)
    /*
     * Could not find the computer name %1.
     */

#define NELOG_DriverNotLoaded                     (ERRLOG2_BASE + 27)
    /*
     * Could not load %1 device driver.
     */

#define NELOG_NoTranportLoaded                    (ERRLOG2_BASE + 28)
    /*
     * Could not load any transport.
     */

//
// More Netlogon service events
//

#define NELOG_NetlogonFailedDomainDelta           (ERRLOG2_BASE + 29)
    /*
     * Replication of the %1 Domain Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedGlobalGroupDelta      (ERRLOG2_BASE + 30)
    /*
     * Replication of the %1 Global Group "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedLocalGroupDelta       (ERRLOG2_BASE + 31)
    /*
     * Replication of the %1 Local Group "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedUserDelta             (ERRLOG2_BASE + 32)
    /*
     * Replication of the %1 User "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedPolicyDelta           (ERRLOG2_BASE + 33)
    /*
     * Replication of the %1 Policy Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedTrustedDomainDelta    (ERRLOG2_BASE + 34)
    /*
     * Replication of the %1 Trusted Domain Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedAccountDelta          (ERRLOG2_BASE + 35)
    /*
     * Replication of the %1 Account Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedSecretDelta           (ERRLOG2_BASE + 36)
    /*
     * Replication of the %1 Secret "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonSystemError                 (ERRLOG2_BASE + 37)
    /*
    * The system returned the following unexpected error code: %n%1
    */

#define NELOG_NetlogonDuplicateMachineAccounts    (ERRLOG2_BASE + 38)
    /*
    * Netlogon has detected two machine accounts for server "%1".
    * The server can be either a Windows 2000 Server that is a member of the
    * domain or the server can be a LAN Manager server with an account in the
    * SERVERS global group.  It cannot be both.
    */

#define NELOG_NetlogonTooManyGlobalGroups         (ERRLOG2_BASE + 39)
    /*
    * This domain has more global groups than can be replicated to a LanMan
    * BDC.  Either delete some of your global groups or remove the LanMan
    * BDCs from the domain.
    */

#define NELOG_NetlogonBrowserDriver               (ERRLOG2_BASE + 40)
    /*
    * The Browser driver returned the following error to Netlogon: %n%1
    */

#define NELOG_NetlogonAddNameFailure              (ERRLOG2_BASE + 41)
    /*
    * Netlogon could not register the %1<1B> name for the following reason: %n%2
    */

//
//  More Remoteboot service events.
//
#define NELOG_RplMessages                         (ERRLOG2_BASE + 42)
    /*
    * Service failed to retrieve messages needed to boot remote boot clients.
    */

#define NELOG_RplXnsBoot                          (ERRLOG2_BASE + 43)
    /*
    * Service experienced a severe error and can no longer provide remote boot
    * for 3Com 3Start remote boot clients.
    */

#define NELOG_RplSystem                           (ERRLOG2_BASE + 44)
    /*
    * Service experienced a severe system error and will shut itself down.
    */

#define NELOG_RplWkstaTimeout                     (ERRLOG2_BASE + 45)
    /*
    * Client with computer name %1 failed to acknowledge receipt of the
    * boot data.  Remote boot of this client was not completed.
    */

#define NELOG_RplWkstaFileOpen                    (ERRLOG2_BASE + 46)
    /*
    * Client with computer name %1 was not booted due to an error in opening
    * file %2.
    */

#define NELOG_RplWkstaFileRead                    (ERRLOG2_BASE + 47)
    /*
    * Client with computer name %1 was not booted due to an error in reading
    * file %2.
    */

#define NELOG_RplWkstaMemory                      (ERRLOG2_BASE + 48)
    /*
    * Client with computer name %1 was not booted due to insufficent memory
    * at the remote boot server.
    */

#define NELOG_RplWkstaFileChecksum                (ERRLOG2_BASE + 49)
    /*
    * Client with computer name %1 will be booted without using checksums
    * because checksum for file %2 could not be calculated.
    */

#define NELOG_RplWkstaFileLineCount               (ERRLOG2_BASE + 50)
    /*
    * Client with computer name %1 was not booted due to too many lines in
    * file %2.
    */

#define NELOG_RplWkstaBbcFile                     (ERRLOG2_BASE + 51)
    /*
    * Client with computer name %1 was not booted because the boot block
    * configuration file %2 for this client does not contain boot block
    * line and/or loader line.
    */

#define NELOG_RplWkstaFileSize                    (ERRLOG2_BASE + 52)
    /*
    * Client with computer name %1 was not booted due to a bad size of
    * file %2.
    */

#define NELOG_RplWkstaInternal                    (ERRLOG2_BASE + 53)
    /*
    * Client with computer name %1 was not booted due to remote boot
    * service internal error.
    */

#define NELOG_RplWkstaWrongVersion                (ERRLOG2_BASE + 54)
    /*
    * Client with computer name %1 was not booted because file %2 has an
    * invalid boot header.
    */

#define NELOG_RplWkstaNetwork                     (ERRLOG2_BASE + 55)
    /*
    * Client with computer name %1 was not booted due to network error.
    */

#define NELOG_RplAdapterResource                  (ERRLOG2_BASE + 56)
    /*
    * Client with adapter id %1 was not booted due to lack of resources.
    */

#define NELOG_RplFileCopy                         (ERRLOG2_BASE + 57)
    /*
    * Service experienced error copying file or directory %1.
    */

#define NELOG_RplFileDelete                       (ERRLOG2_BASE + 58)
    /*
    * Service experienced error deleting file or directory %1.
    */

#define NELOG_RplFilePerms                        (ERRLOG2_BASE + 59)
    /*
    * Service experienced error setting permissions on file or directory %1.
    */
#define NELOG_RplCheckConfigs                     (ERRLOG2_BASE + 60)
    /*
    * Service experienced error evaluating RPL configurations.
    */
#define NELOG_RplCreateProfiles                   (ERRLOG2_BASE + 61)
    /*
    * Service experienced error creating RPL profiles for all configurations.
    */
#define NELOG_RplRegistry                         (ERRLOG2_BASE + 62)
    /*
    * Service experienced error accessing registry.
    */
#define NELOG_RplReplaceRPLDISK                   (ERRLOG2_BASE + 63)
    /*
    * Service experienced error replacing possibly outdated RPLDISK.SYS.
    */
#define NELOG_RplCheckSecurity                    (ERRLOG2_BASE + 64)
    /*
    * Service experienced error adding security accounts or setting
    * file permissions.  These accounts are the RPLUSER local group
    * and the user accounts for the individual RPL workstations.
    */
#define NELOG_RplBackupDatabase                   (ERRLOG2_BASE + 65)
    /*
    * Service failed to back up its database.
    */
#define NELOG_RplInitDatabase                     (ERRLOG2_BASE + 66)
    /*
    * Service failed to initialize from its database.  The database may be
    * missing or corrupted.  Service will attempt restoring the database
    * from the backup.
    */
#define NELOG_RplRestoreDatabaseFailure           (ERRLOG2_BASE + 67)
    /*
    * Service failed to restore its database from the backup.  Service
    * will not start.
    */
#define NELOG_RplRestoreDatabaseSuccess           (ERRLOG2_BASE + 68)
    /*
    * Service sucessfully restored its database from the backup.
    */
#define NELOG_RplInitRestoredDatabase             (ERRLOG2_BASE + 69)
    /*
    * Service failed to initialize from its restored database.  Service
    * will not start.
    */

//
// More Netlogon and RPL service events
//
#define NELOG_NetlogonSessionTypeWrong            (ERRLOG2_BASE + 70)
    /*
     * The session setup to the Windows NT or Windows 2000 Domain Controller %1 from computer
     * %2 using account %4 failed.  %2 is declared to be a BDC in domain %3.
     * However, %2 tried to connect as either a DC in a trusted domain,
     * a member workstation in domain %3, or as a server in domain %3.
     * Use the Active Directory Users and Computers tool or Server Manager to remove the BDC account for %2.
     */
#define NELOG_RplUpgradeDBTo40                    (ERRLOG2_BASE + 71)
    /*
    * The Remoteboot database was in NT 3.5 / NT 3.51 format and NT is
    * attempting to convert it to NT 4.0 format. The JETCONV converter
    * will write to the Application event log when it is finished.
    */
#define NELOG_NetlogonLanmanBdcsNotAllowed        (ERRLOG2_BASE + 72)
    /*
     * Global group SERVERS exists in domain %1 and has members.
     * This group defines Lan Manager BDCs in the domain.
     * Lan Manager BDCs are not permitted in NT domains.
     */
#define NELOG_NetlogonNoDynamicDns                (ERRLOG2_BASE + 73)
    /*
     * The DNS server for this DC does not support dynamic DNS.
     * Add the DNS records from the file '%SystemRoot%\System32\Config\netlogon.dns'
     * to the DNS server serving the domain referenced in that file.
     */
#define NELOG_NetlogonDynamicDnsRegisterFailure   (ERRLOG2_BASE + 74)
    /*
     * Registration of the DNS record '%1' failed with the following error: %n%2
     */

#define NELOG_NetlogonDynamicDnsDeregisterFailure (ERRLOG2_BASE + 75)
    /*
     * Deregistration of the DNS record '%1' failed with the following error: %n%2
     */

#define NELOG_NetlogonFailedFileCreate            (ERRLOG2_BASE + 76)
    /*
     * Failed to create/open file %1 with the following error: %n%2
     */

#define NELOG_NetlogonGetSubnetToSite             (ERRLOG2_BASE + 77)
    /*
     * Netlogon got the following error while trying to get the subnet to site
     * mapping information from the DS: %n%1
     */

#define NELOG_NetlogonNoSiteForClient              (ERRLOG2_BASE + 78)
    /*
     * '%1' tried to determine its site by looking up its IP address ('%2')
     * in the Configuration\Sites\Subnets container in the DS.  No subnet matched
     * the IP address.  Consider adding a subnet object for this IP address.
     */

#define NELOG_NetlogonBadSiteName                  (ERRLOG2_BASE + 79)
    /*
     * The site name for this computer is '%1'.  That site name is not a valid
     * site name.  A site name must be a valid DNS label.
     * Rename the site to be a valid name.
     */

#define NELOG_NetlogonBadSubnetName                (ERRLOG2_BASE + 80)
    /*
     * The subnet object '%1' appears in the Configuration\Sites\Subnets
     * container in the DS.  The name is not syntactically valid.  The valid
     * syntax is xx.xx.xx.xx/yy where xx.xx.xx.xx is a valid IP subnet number
     * and yy is the number of bits in the subnet mask.
     *
     * Correct the name of the subnet object.
     */

#define NELOG_NetlogonDynamicDnsServerFailure      (ERRLOG2_BASE + 81)
    /*
     * Dynamic registration or deregistration of one or more DNS records failed because no DNS servers are available.
     */

#define NELOG_NetlogonDynamicDnsFailure            (ERRLOG2_BASE + 82)
    /*
     * Dynamic registration or deregistration of one or more DNS records failed with the following error: %n%1
     */

#define NELOG_NetlogonRpcCallCancelled             (ERRLOG2_BASE + 83)
    /*
     * The session setup to the Windows NT or Windows 2000 Domain Controller %1 for the domain %2
     * is not responsive.  The current RPC call from Netlogon on \\%3 to %1 has been cancelled.
     */

#define NELOG_NetlogonDcSiteCovered                (ERRLOG2_BASE + 84)
    /*
     * Site '%2' does not have any Domain Controllers for domain '%3'.
     * Domain Controllers in site '%1' have been automatically
     * selected to cover site '%2' for domain '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonDcSiteNotCovered             (ERRLOG2_BASE + 85)
    /*
     * This Domain Controller no longer automatically covers site '%1' for domain '%2'.
     */

#define NELOG_NetlogonGcSiteCovered                (ERRLOG2_BASE + 86)
    /*
     * Site '%2' does not have any Global Catalog servers for forest '%3'.
     * Global Catalog servers in site '%1' have been automatically
     * selected to cover site '%2' for forest '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonGcSiteNotCovered             (ERRLOG2_BASE + 87)
    /*
     * This Global Catalog server no longer automatically covers site '%1' for forest '%2'.
     */

#define NELOG_NetlogonFailedSpnUpdate              (ERRLOG2_BASE + 88)
    /*
     * Attempt to update HOST Service Principal Names (SPNs) of the computer
     * object in Active Directory failed. The updated values were '%1' and '%2'.
     * The following error occurred: %n%3
     */

#define NELOG_NetlogonFailedDnsHostNameUpdate      (ERRLOG2_BASE + 89)
    /*
     * Attempt to update DNS Host Name of the computer object
     * in Active Directory failed. The updated value was '%1'.
     * The following error occurred: %n%2
     */

#define NELOG_NetlogonAuthNoUplevelDomainController (ERRLOG2_BASE + 90)
    /*
     * No suitable Domain Controller is available for domain %1.
     * An NT4 or older domain controller is available but it cannot
     * be used for authentication purposes in the Windows 2000 or newer
     * domain that this computer is a member of.
     * The following error occurred:%n%2
     */

#define NELOG_NetlogonAuthDomainDowngraded         (ERRLOG2_BASE + 91)
    /*
     * The domain of this computer, %1 has been downgraded from Windows 2000
     * or newer to Windows NT4 or older. The computer cannot function properly
     * in this case for authentication purposes. This computer needs to rejoin
     * the domain.
     * The following error occurred:%n%2
     */

#define NELOG_NetlogonNdncSiteCovered                (ERRLOG2_BASE + 92)
    /*
     * Site '%2' does not have any LDAP servers for non-domain NC '%3'.
     * LDAP servers in site '%1' have been automatically selected to
     * cover site '%2' for non-domain NC '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonNdncSiteNotCovered             (ERRLOG2_BASE + 93)
    /*
     * This LDAP server no longer automatically covers site '%1' for non-domain NC '%2'.
     */

#define NELOG_NetlogonDcOldSiteCovered               (ERRLOG2_BASE + 94)
    /*
     * Site '%2' is no longer manually configured in the registry as
     * covered by this Domain Controller for domain '%3'. As a result,
     * site '%2' does not have any Domain Controllers for domain '%3'.
     * Domain Controllers in site '%1' have been automatically
     * selected to cover site '%2' for domain '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonDcSiteNotCoveredAuto           (ERRLOG2_BASE + 95)
    /*
     * This Domain Controller no longer automatically covers site '%1' for domain '%2'.
     * However, site '%1' is still (manually) covered by this Domain Controller for
     * domain '%2' since this site has been manually configured in the registry.
     */

#define NELOG_NetlogonGcOldSiteCovered               (ERRLOG2_BASE + 96)
    /*
     * Site '%2' is no longer manually configured in the registry as
     * covered by this Global Catalog server for forest '%3'. As a result,
     * site '%2' does not have any Global Catalog servers for forest '%3'.
     * Global Catalog servers in site '%1' have been automatically
     * selected to cover site '%2' for forest '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonGcSiteNotCoveredAuto           (ERRLOG2_BASE + 97)
    /*
     * This Global Catalog server no longer automatically covers site '%1' for forest '%2'.
     * However, site '%1' is still (manually) covered by this Global catalog for
     * forest '%2' since this site has been manually configured in the registry.
     */

#define NELOG_NetlogonNdncOldSiteCovered             (ERRLOG2_BASE + 98)
    /*
     * Site '%2' is no longer manually configured in the registry as
     * covered by this LDAP server for non-domain NC '%3'. As a result,
     * site '%2' does not have any LDAP servers for non-domain NC '%3'.
     * LDAP servers in site '%1' have been automatically
     * selected to cover site '%2' for non-domain NC '%3' based on
     * configured Directory Server replication costs.
     */

#define NELOG_NetlogonNdncSiteNotCoveredAuto         (ERRLOG2_BASE + 99)
    /*
     * This LDAP server no longer automatically covers site '%1' for non-domain NC '%2'.
     * However, site '%1' is still (manually) covered by this LDAP server for
     * non-domain NC '%2' since this site has been manually configured in the registry.
     */

#define NELOG_NetlogonSpnMultipleSamAccountNames     (ERRLOG2_BASE + 100)
    /*
     * Attempt to update DnsHostName and HOST Service Principal Name (SPN) attributes
     * of the computer object in Active Directory failed because the Domain Controller
     * '%1' had more than one account with the name '%2' corresponding to this computer.
     * Not having SPNs registered may result in authentication failures for this computer.
     * Contact your domain administrator who may need to manually resolve the account name
     * collision.
     */

#define NELOG_NetlogonSpnCrackNamesFailure           (ERRLOG2_BASE + 101)
    /*
     * Attempt to update DnsHostName and HOST Service Principal Name (SPN) attributes
     * of the computer object in Active Directory failed because this computer account
     * name, '%2' could not be mapped to the computer object on Domain Controller '%1'.
     * Not having SPNs registered may result in authentication failures for this computer.
     * Contact your domain administrator. The following technical information may be
     * useful for the resolution of this failure:%n
     * DsCrackNames status = 0x%3, crack error = 0x%4.
     */

#define NELOG_NetlogonNoAddressToSiteMapping         (ERRLOG2_BASE + 102)
    /*
     * None of the IP addresses of this Domain Controller map to the configured site '%1'.
     */

#ifdef __cplusplus
}
#endif

#endif // _LMERRLOG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmsname.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmsname.h

Abstract:

    This file contains service name strings.  It is included by lmsvc.h.

Environment:

    User Mode -Win32


--*/

#ifndef _LMSNAME_
#define _LMSNAME_

#if _MSC_VER > 1000
#pragma once
#endif

//
//  Standard LAN Manager service names.
//

#define SERVICE_WORKSTATION       TEXT("LanmanWorkstation")
#define SERVICE_LM20_WORKSTATION  TEXT("WORKSTATION")
#define WORKSTATION_DISPLAY_NAME  TEXT("Workstation")

#define SERVICE_SERVER            TEXT("LanmanServer")
#define SERVICE_LM20_SERVER       TEXT("SERVER")
#define SERVER_DISPLAY_NAME       TEXT("Server")

#define SERVICE_BROWSER           TEXT("BROWSER")
#define SERVICE_LM20_BROWSER      SERVICE_BROWSER

#define SERVICE_MESSENGER         TEXT("MESSENGER")
#define SERVICE_LM20_MESSENGER    SERVICE_MESSENGER

#define SERVICE_NETRUN            TEXT("NETRUN")
#define SERVICE_LM20_NETRUN       SERVICE_NETRUN

#define SERVICE_SPOOLER           TEXT("SPOOLER")
#define SERVICE_LM20_SPOOLER      SERVICE_SPOOLER

#define SERVICE_ALERTER           TEXT("ALERTER")
#define SERVICE_LM20_ALERTER      SERVICE_ALERTER

#define SERVICE_NETLOGON          TEXT("NETLOGON")
#define SERVICE_LM20_NETLOGON     SERVICE_NETLOGON

#define SERVICE_NETPOPUP          TEXT("NETPOPUP")
#define SERVICE_LM20_NETPOPUP     SERVICE_NETPOPUP

#define SERVICE_SQLSERVER         TEXT("SQLSERVER")
#define SERVICE_LM20_SQLSERVER    SERVICE_SQLSERVER

#define SERVICE_REPL              TEXT("REPLICATOR")
#define SERVICE_LM20_REPL         SERVICE_REPL

#define SERVICE_RIPL              TEXT("REMOTEBOOT")
#define SERVICE_LM20_RIPL         SERVICE_RIPL

#define SERVICE_TIMESOURCE        TEXT("TIMESOURCE")
#define SERVICE_LM20_TIMESOURCE   SERVICE_TIMESOURCE

#define SERVICE_AFP               TEXT("AFP")
#define SERVICE_LM20_AFP          SERVICE_AFP

#define SERVICE_UPS               TEXT("UPS")
#define SERVICE_LM20_UPS          SERVICE_UPS

#define SERVICE_XACTSRV           TEXT("XACTSRV")
#define SERVICE_LM20_XACTSRV      SERVICE_XACTSRV

#define SERVICE_TCPIP             TEXT("TCPIP")
#define SERVICE_LM20_TCPIP        SERVICE_TCPIP

#define SERVICE_NBT               TEXT("NBT")
#define SERVICE_LM20_NBT          SERVICE_NBT

#define SERVICE_LMHOSTS           TEXT("LMHOSTS")
#define SERVICE_LM20_LMHOSTS      SERVICE_LMHOSTS

#define SERVICE_TELNET            TEXT("Telnet")
#define SERVICE_LM20_TELNET       SERVICE_TELNET

#define SERVICE_SCHEDULE          TEXT("Schedule")
#define SERVICE_LM20_SCHEDULE     SERVICE_SCHEDULE

#define SERVICE_NTLMSSP           TEXT("NtLmSsp")

#define SERVICE_DHCP              TEXT("DHCP")
#define SERVICE_LM20_DHCP         SERVICE_DHCP

#define SERVICE_NWSAP             TEXT("NwSapAgent")
#define SERVICE_LM20_NWSAP        SERVICE_NWSAP
#define NWSAP_DISPLAY_NAME        TEXT("NW Sap Agent")

#define SERVICE_NWCS              TEXT("NWCWorkstation")
#define SERVICE_DNS_CACHE         TEXT("DnsCache")

#define SERVICE_W32TIME           TEXT("w32time")
#define SERVCE_LM20_W32TIME       SERVICE_W32TIME

#define SERVICE_KDC               TEXT("kdc")
#define SERVICE_LM20_KDC          SERVICE_KDC

#define SERVICE_RPCLOCATOR        TEXT("RPCLOCATOR")
#define SERVICE_LM20_RPCLOCATOR   SERVICE_RPCLOCATOR

#define SERVICE_TRKSVR            TEXT("TrkSvr")
#define SERVICE_LM20_TRKSVR       SERVICE_TRKSVR

#define SERVICE_TRKWKS            TEXT("TrkWks")
#define SERVICE_LM20_TRKWKS       SERVICE_TRKWKS

#define SERVICE_NTFRS             TEXT("NtFrs")
#define SERVICE_LM20_NTFRS        SERVICE_NTFRS

#define SERVICE_ISMSERV           TEXT("IsmServ")
#define SERVICE_LM20_ISMSERV      SERVICE_ISMSERV

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmstats.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmstats.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetStatistics

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMSTATS_
#define _LMSTATS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>

//
// Function Prototypes - Statistics
//

NET_API_STATUS NET_API_FUNCTION
NetStatisticsGet (
    IN  LMSTR   server,
    IN  LMSTR   service,
    IN  DWORD   level,
    IN  DWORD   options,
    OUT LPBYTE  *bufptr
    );

//
// Data Structures - Statistics
//

#ifdef LM20_WORKSTATION_STATISTICS
typedef struct _STAT_WORKSTATION_0 {
     DWORD          stw0_start;
     DWORD          stw0_numNCB_r;
     DWORD          stw0_numNCB_s;
     DWORD          stw0_numNCB_a;
     DWORD          stw0_fiNCB_r;
     DWORD          stw0_fiNCB_s;
     DWORD          stw0_fiNCB_a;
     DWORD          stw0_fcNCB_r;
     DWORD          stw0_fcNCB_s;
     DWORD          stw0_fcNCB_a;
     DWORD          stw0_sesstart;
     DWORD          stw0_sessfailcon;
     DWORD          stw0_sessbroke;
     DWORD          stw0_uses;
     DWORD          stw0_usefail;
     DWORD          stw0_autorec;
     DWORD          stw0_bytessent_r_lo;
     DWORD          stw0_bytessent_r_hi;
     DWORD          stw0_bytesrcvd_r_lo;
     DWORD          stw0_bytesrcvd_r_hi;
     DWORD          stw0_bytessent_s_lo;
     DWORD          stw0_bytessent_s_hi;
     DWORD          stw0_bytesrcvd_s_lo;
     DWORD          stw0_bytesrcvd_s_hi;
     DWORD          stw0_bytessent_a_lo;
     DWORD          stw0_bytessent_a_hi;
     DWORD          stw0_bytesrcvd_a_lo;
     DWORD          stw0_bytesrcvd_a_hi;
     DWORD          stw0_reqbufneed;
     DWORD          stw0_bigbufneed;
} STAT_WORKSTATION_0, *PSTAT_WORKSTATION_0, *LPSTAT_WORKSTATION_0;
#else

//
// NB: The following structure is REDIR_STATISTICS in sdk\inc\ntddnfs.h. If you
//     change the structure, change it in both places
//

typedef struct _STAT_WORKSTATION_0 {
    LARGE_INTEGER   StatisticsStartTime;

    LARGE_INTEGER   BytesReceived;
    LARGE_INTEGER   SmbsReceived;
    LARGE_INTEGER   PagingReadBytesRequested;
    LARGE_INTEGER   NonPagingReadBytesRequested;
    LARGE_INTEGER   CacheReadBytesRequested;
    LARGE_INTEGER   NetworkReadBytesRequested;

    LARGE_INTEGER   BytesTransmitted;
    LARGE_INTEGER   SmbsTransmitted;
    LARGE_INTEGER   PagingWriteBytesRequested;
    LARGE_INTEGER   NonPagingWriteBytesRequested;
    LARGE_INTEGER   CacheWriteBytesRequested;
    LARGE_INTEGER   NetworkWriteBytesRequested;

    DWORD           InitiallyFailedOperations;
    DWORD           FailedCompletionOperations;

    DWORD           ReadOperations;
    DWORD           RandomReadOperations;
    DWORD           ReadSmbs;
    DWORD           LargeReadSmbs;
    DWORD           SmallReadSmbs;

    DWORD           WriteOperations;
    DWORD           RandomWriteOperations;
    DWORD           WriteSmbs;
    DWORD           LargeWriteSmbs;
    DWORD           SmallWriteSmbs;

    DWORD           RawReadsDenied;
    DWORD           RawWritesDenied;

    DWORD           NetworkErrors;

    //  Connection/Session counts
    DWORD           Sessions;
    DWORD           FailedSessions;
    DWORD           Reconnects;
    DWORD           CoreConnects;
    DWORD           Lanman20Connects;
    DWORD           Lanman21Connects;
    DWORD           LanmanNtConnects;
    DWORD           ServerDisconnects;
    DWORD           HungSessions;
    DWORD           UseCount;
    DWORD           FailedUseCount;

    //
    //  Queue Lengths (updates protected by RdrMpxTableSpinLock NOT
    //  RdrStatisticsSpinlock)
    //

    DWORD           CurrentCommands;

} STAT_WORKSTATION_0, *PSTAT_WORKSTATION_0, *LPSTAT_WORKSTATION_0;
#endif

typedef struct _STAT_SERVER_0 {
     DWORD          sts0_start;
     DWORD          sts0_fopens;
     DWORD          sts0_devopens;
     DWORD          sts0_jobsqueued;
     DWORD          sts0_sopens;
     DWORD          sts0_stimedout;
     DWORD          sts0_serrorout;
     DWORD          sts0_pwerrors;
     DWORD          sts0_permerrors;
     DWORD          sts0_syserrors;
     DWORD          sts0_bytessent_low;
     DWORD          sts0_bytessent_high;
     DWORD          sts0_bytesrcvd_low;
     DWORD          sts0_bytesrcvd_high;
     DWORD          sts0_avresponse;
     DWORD          sts0_reqbufneed;
     DWORD          sts0_bigbufneed;
} STAT_SERVER_0, *PSTAT_SERVER_0, *LPSTAT_SERVER_0;


//
// Special Values and Constants
//

#define STATSOPT_CLR    1
#define STATS_NO_VALUE  ((unsigned long) -1L)
#define STATS_OVERFLOW  ((unsigned long) -2L)


#ifdef __cplusplus
}
#endif

#endif // _LMSTATS.H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmerr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects
*/
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1999          **/
/********************************************************************/

/***    lmerr.h - network error definitions
 *
 */


/**INTERNAL_ONLY**/

/***********WARNING ****************
 *See the comment in lmcons.h for  *
 *info on the allocation of errors *
 ***********************************/

/**END_INTERNAL**/

/*NOINC*/
#ifndef NETERR_INCLUDED
#define NETERR_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

/*INC*/


#define NERR_Success            0       /* Success */

// ERROR_ equates can be intermixed with NERR_ equates.
#include <winerror.h>



/***    NERR_BASE is the base of error codes from network utilities,
 *      chosen to avoid conflict with system and redirector error codes.
 *      2100 is a value that has been assigned to us by system.
 */
#define NERR_BASE       2100


/**INTERNAL_ONLY**/

/***********WARNING ****************
 *See the comment in lmcons.h for  *
 *info on the allocation of errors *
 ***********************************/

/***********WARNING ****************
 *The range 2750-2799 has been     *
 *allocated to the IBM LAN Server  *
 ***********************************/

/***********WARNING ****************
 *The range 2900-2999 has been     *
 *reserved for Microsoft OEMs      *
 ***********************************/

/**END_INTERNAL**/

/* UNUSED BASE+0 */
/* UNUSED BASE+1 */
#define NERR_NetNotStarted      (NERR_BASE+2)   /* The workstation driver is not installed. */
#define NERR_UnknownServer      (NERR_BASE+3)   /* The server could not be located. */
#define NERR_ShareMem           (NERR_BASE+4)   /* An internal error occurred.  The network cannot access a shared memory segment. */

#define NERR_NoNetworkResource  (NERR_BASE+5)   /* A network resource shortage occurred . */
#define NERR_RemoteOnly         (NERR_BASE+6)   /* This operation is not supported on workstations. */
#define NERR_DevNotRedirected   (NERR_BASE+7)   /* The device is not connected. */
/* NERR_BASE+8 is used for ERROR_CONNECTED_OTHER_PASSWORD */
/* UNUSED BASE+9 */
/* UNUSED BASE+10 */
/* UNUSED BASE+11 */
/* UNUSED BASE+12 */
/* UNUSED BASE+13 */
#define NERR_ServerNotStarted   (NERR_BASE+14)  /* The Server service is not started. */
#define NERR_ItemNotFound       (NERR_BASE+15)  /* The queue is empty. */
#define NERR_UnknownDevDir      (NERR_BASE+16)  /* The device or directory does not exist. */
#define NERR_RedirectedPath     (NERR_BASE+17)  /* The operation is invalid on a redirected resource. */
#define NERR_DuplicateShare     (NERR_BASE+18)  /* The name has already been shared. */
#define NERR_NoRoom             (NERR_BASE+19)  /* The server is currently out of the requested resource. */
/* UNUSED BASE+20 */
#define NERR_TooManyItems       (NERR_BASE+21)  /* Requested addition of items exceeds the maximum allowed. */
#define NERR_InvalidMaxUsers    (NERR_BASE+22)  /* The Peer service supports only two simultaneous users. */
#define NERR_BufTooSmall        (NERR_BASE+23)  /* The API return buffer is too small. */
/* UNUSED BASE+24 */
/* UNUSED BASE+25 */
/* UNUSED BASE+26 */
#define NERR_RemoteErr          (NERR_BASE+27)  /* A remote API error occurred.  */
/* UNUSED BASE+28 */
/* UNUSED BASE+29 */
/* UNUSED BASE+30 */
#define NERR_LanmanIniError     (NERR_BASE+31)  /* An error occurred when opening or reading the configuration file. */
/* UNUSED BASE+32 */
/* UNUSED BASE+33 */
/* UNUSED BASE+34 */
/* UNUSED BASE+35 */
#define NERR_NetworkError       (NERR_BASE+36)  /* A general network error occurred. */
#define NERR_WkstaInconsistentState (NERR_BASE+37)
    /* The Workstation service is in an inconsistent state. Restart the computer before restarting the Workstation service. */
#define NERR_WkstaNotStarted    (NERR_BASE+38)  /* The Workstation service has not been started. */
#define NERR_BrowserNotStarted  (NERR_BASE+39)  /* The requested information is not available. */
#define NERR_InternalError      (NERR_BASE+40)  /* An internal Windows 2000 error occurred.*/
#define NERR_BadTransactConfig  (NERR_BASE+41)  /* The server is not configured for transactions. */
#define NERR_InvalidAPI         (NERR_BASE+42)  /* The requested API is not supported on the remote server. */
#define NERR_BadEventName       (NERR_BASE+43)  /* The event name is invalid. */
#define NERR_DupNameReboot      (NERR_BASE+44)  /* The computer name already exists on the network. Change it and restart the computer. */
/*
 *      Config API related
 *              Error codes from BASE+45 to BASE+49
 */

/* UNUSED BASE+45 */
#define NERR_CfgCompNotFound    (NERR_BASE+46)  /* The specified component could not be found in the configuration information. */
#define NERR_CfgParamNotFound   (NERR_BASE+47)  /* The specified parameter could not be found in the configuration information. */
#define NERR_LineTooLong        (NERR_BASE+49)  /* A line in the configuration file is too long. */

/*
 *      Spooler API related
 *              Error codes from BASE+50 to BASE+79
 */

#define NERR_QNotFound          (NERR_BASE+50)  /* The printer does not exist. */
#define NERR_JobNotFound        (NERR_BASE+51)  /* The print job does not exist. */
#define NERR_DestNotFound       (NERR_BASE+52)  /* The printer destination cannot be found. */
#define NERR_DestExists         (NERR_BASE+53)  /* The printer destination already exists. */
#define NERR_QExists            (NERR_BASE+54)  /* The printer queue already exists. */
#define NERR_QNoRoom            (NERR_BASE+55)  /* No more printers can be added. */
#define NERR_JobNoRoom          (NERR_BASE+56)  /* No more print jobs can be added.  */
#define NERR_DestNoRoom         (NERR_BASE+57)  /* No more printer destinations can be added. */
#define NERR_DestIdle           (NERR_BASE+58)  /* This printer destination is idle and cannot accept control operations. */
#define NERR_DestInvalidOp      (NERR_BASE+59)  /* This printer destination request contains an invalid control function. */
#define NERR_ProcNoRespond      (NERR_BASE+60)  /* The print processor is not responding. */
#define NERR_SpoolerNotLoaded   (NERR_BASE+61)  /* The spooler is not running. */
#define NERR_DestInvalidState   (NERR_BASE+62)  /* This operation cannot be performed on the print destination in its current state. */
#define NERR_QInvalidState      (NERR_BASE+63)  /* This operation cannot be performed on the printer queue in its current state. */
#define NERR_JobInvalidState    (NERR_BASE+64)  /* This operation cannot be performed on the print job in its current state. */
#define NERR_SpoolNoMemory      (NERR_BASE+65)  /* A spooler memory allocation failure occurred. */
#define NERR_DriverNotFound     (NERR_BASE+66)  /* The device driver does not exist. */
#define NERR_DataTypeInvalid    (NERR_BASE+67)  /* The data type is not supported by the print processor. */
#define NERR_ProcNotFound       (NERR_BASE+68)  /* The print processor is not installed. */

/*
 *      Service API related
 *              Error codes from BASE+80 to BASE+99
 */

#define NERR_ServiceTableLocked (NERR_BASE+80)  /* The service database is locked. */
#define NERR_ServiceTableFull   (NERR_BASE+81)  /* The service table is full. */
#define NERR_ServiceInstalled   (NERR_BASE+82)  /* The requested service has already been started. */
#define NERR_ServiceEntryLocked (NERR_BASE+83)  /* The service does not respond to control actions. */
#define NERR_ServiceNotInstalled (NERR_BASE+84) /* The service has not been started. */
#define NERR_BadServiceName     (NERR_BASE+85)  /* The service name is invalid. */
#define NERR_ServiceCtlTimeout  (NERR_BASE+86)  /* The service is not responding to the control function. */
#define NERR_ServiceCtlBusy     (NERR_BASE+87)  /* The service control is busy. */
#define NERR_BadServiceProgName (NERR_BASE+88)  /* The configuration file contains an invalid service program name. */
#define NERR_ServiceNotCtrl     (NERR_BASE+89)  /* The service could not be controlled in its present state. */
#define NERR_ServiceKillProc    (NERR_BASE+90)  /* The service ended abnormally. */
#define NERR_ServiceCtlNotValid (NERR_BASE+91)  /* The requested pause or stop is not valid for this service. */
#define NERR_NotInDispatchTbl   (NERR_BASE+92)  /* The service control dispatcher could not find the service name in the dispatch table. */
#define NERR_BadControlRecv     (NERR_BASE+93)  /* The service control dispatcher pipe read failed. */
#define NERR_ServiceNotStarting (NERR_BASE+94)  /* A thread for the new service could not be created. */

/*
 *      Wksta and Logon API related
 *              Error codes from BASE+100 to BASE+118
 */

#define NERR_AlreadyLoggedOn    (NERR_BASE+100) /* This workstation is already logged on to the local-area network. */
#define NERR_NotLoggedOn        (NERR_BASE+101) /* The workstation is not logged on to the local-area network. */
#define NERR_BadUsername        (NERR_BASE+102) /* The user name or group name parameter is invalid.  */
#define NERR_BadPassword        (NERR_BASE+103) /* The password parameter is invalid. */
#define NERR_UnableToAddName_W  (NERR_BASE+104) /* @W The logon processor did not add the message alias. */
#define NERR_UnableToAddName_F  (NERR_BASE+105) /* The logon processor did not add the message alias. */
#define NERR_UnableToDelName_W  (NERR_BASE+106) /* @W The logoff processor did not delete the message alias. */
#define NERR_UnableToDelName_F  (NERR_BASE+107) /* The logoff processor did not delete the message alias. */
/* UNUSED BASE+108 */
#define NERR_LogonsPaused       (NERR_BASE+109) /* Network logons are paused. */
#define NERR_LogonServerConflict (NERR_BASE+110)/* A centralized logon-server conflict occurred. */
#define NERR_LogonNoUserPath    (NERR_BASE+111) /* The server is configured without a valid user path. */
#define NERR_LogonScriptError   (NERR_BASE+112) /* An error occurred while loading or running the logon script. */
/* UNUSED BASE+113 */
#define NERR_StandaloneLogon    (NERR_BASE+114) /* The logon server was not specified.  Your computer will be logged on as STANDALONE. */
#define NERR_LogonServerNotFound (NERR_BASE+115) /* The logon server could not be found.  */
#define NERR_LogonDomainExists  (NERR_BASE+116) /* There is already a logon domain for this computer.  */
#define NERR_NonValidatedLogon  (NERR_BASE+117) /* The logon server could not validate the logon. */

/*
 *      ACF API related (access, user, group)
 *              Error codes from BASE+119 to BASE+149
 */

#define NERR_ACFNotFound        (NERR_BASE+119) /* The security database could not be found. */
#define NERR_GroupNotFound      (NERR_BASE+120) /* The group name could not be found. */
#define NERR_UserNotFound       (NERR_BASE+121) /* The user name could not be found. */
#define NERR_ResourceNotFound   (NERR_BASE+122) /* The resource name could not be found.  */
#define NERR_GroupExists        (NERR_BASE+123) /* The group already exists. */
#define NERR_UserExists         (NERR_BASE+124) /* The account already exists. */
#define NERR_ResourceExists     (NERR_BASE+125) /* The resource permission list already exists. */
#define NERR_NotPrimary         (NERR_BASE+126) /* This operation is only allowed on the primary domain controller of the domain. */
#define NERR_ACFNotLoaded       (NERR_BASE+127) /* The security database has not been started. */
#define NERR_ACFNoRoom          (NERR_BASE+128) /* There are too many names in the user accounts database. */
#define NERR_ACFFileIOFail      (NERR_BASE+129) /* A disk I/O failure occurred.*/
#define NERR_ACFTooManyLists    (NERR_BASE+130) /* The limit of 64 entries per resource was exceeded. */
#define NERR_UserLogon          (NERR_BASE+131) /* Deleting a user with a session is not allowed. */
#define NERR_ACFNoParent        (NERR_BASE+132) /* The parent directory could not be located. */
#define NERR_CanNotGrowSegment  (NERR_BASE+133) /* Unable to add to the security database session cache segment. */
#define NERR_SpeGroupOp         (NERR_BASE+134) /* This operation is not allowed on this special group. */
#define NERR_NotInCache         (NERR_BASE+135) /* This user is not cached in user accounts database session cache. */
#define NERR_UserInGroup        (NERR_BASE+136) /* The user already belongs to this group. */
#define NERR_UserNotInGroup     (NERR_BASE+137) /* The user does not belong to this group. */
#define NERR_AccountUndefined   (NERR_BASE+138) /* This user account is undefined. */
#define NERR_AccountExpired     (NERR_BASE+139) /* This user account has expired. */
#define NERR_InvalidWorkstation (NERR_BASE+140) /* The user is not allowed to log on from this workstation. */
#define NERR_InvalidLogonHours  (NERR_BASE+141) /* The user is not allowed to log on at this time.  */
#define NERR_PasswordExpired    (NERR_BASE+142) /* The password of this user has expired. */
#define NERR_PasswordCantChange (NERR_BASE+143) /* The password of this user cannot change. */
#define NERR_PasswordHistConflict (NERR_BASE+144) /* This password cannot be used now. */
#define NERR_PasswordTooShort   (NERR_BASE+145) /* The password does not meet the password policy requirements. Check the minimum password length, password complexity and password history requirements. */
#define NERR_PasswordTooRecent  (NERR_BASE+146) /* The password of this user is too recent to change.  */
#define NERR_InvalidDatabase    (NERR_BASE+147) /* The security database is corrupted. */
#define NERR_DatabaseUpToDate   (NERR_BASE+148) /* No updates are necessary to this replicant network/local security database. */
#define NERR_SyncRequired       (NERR_BASE+149) /* This replicant database is outdated; synchronization is required. */

/*
 *      Use API related
 *              Error codes from BASE+150 to BASE+169
 */

#define NERR_UseNotFound        (NERR_BASE+150) /* The network connection could not be found. */
#define NERR_BadAsgType         (NERR_BASE+151) /* This asg_type is invalid. */
#define NERR_DeviceIsShared     (NERR_BASE+152) /* This device is currently being shared. */

/*
 *      Message Server related
 *              Error codes BASE+170 to BASE+209
 */

#define NERR_NoComputerName     (NERR_BASE+170) /* The computer name could not be added as a message alias.  The name may already exist on the network. */
#define NERR_MsgAlreadyStarted  (NERR_BASE+171) /* The Messenger service is already started. */
#define NERR_MsgInitFailed      (NERR_BASE+172) /* The Messenger service failed to start.  */
#define NERR_NameNotFound       (NERR_BASE+173) /* The message alias could not be found on the network. */
#define NERR_AlreadyForwarded   (NERR_BASE+174) /* This message alias has already been forwarded. */
#define NERR_AddForwarded       (NERR_BASE+175) /* This message alias has been added but is still forwarded. */
#define NERR_AlreadyExists      (NERR_BASE+176) /* This message alias already exists locally. */
#define NERR_TooManyNames       (NERR_BASE+177) /* The maximum number of added message aliases has been exceeded. */
#define NERR_DelComputerName    (NERR_BASE+178) /* The computer name could not be deleted.*/
#define NERR_LocalForward       (NERR_BASE+179) /* Messages cannot be forwarded back to the same workstation. */
#define NERR_GrpMsgProcessor    (NERR_BASE+180) /* An error occurred in the domain message processor. */
#define NERR_PausedRemote       (NERR_BASE+181) /* The message was sent, but the recipient has paused the Messenger service. */
#define NERR_BadReceive         (NERR_BASE+182) /* The message was sent but not received. */
#define NERR_NameInUse          (NERR_BASE+183) /* The message alias is currently in use. Try again later. */
#define NERR_MsgNotStarted      (NERR_BASE+184) /* The Messenger service has not been started. */
#define NERR_NotLocalName       (NERR_BASE+185) /* The name is not on the local computer. */
#define NERR_NoForwardName      (NERR_BASE+186) /* The forwarded message alias could not be found on the network. */
#define NERR_RemoteFull         (NERR_BASE+187) /* The message alias table on the remote station is full. */
#define NERR_NameNotForwarded   (NERR_BASE+188) /* Messages for this alias are not currently being forwarded. */
#define NERR_TruncatedBroadcast (NERR_BASE+189) /* The broadcast message was truncated. */
#define NERR_InvalidDevice      (NERR_BASE+194) /* This is an invalid device name. */
#define NERR_WriteFault         (NERR_BASE+195) /* A write fault occurred. */
/* UNUSED BASE+196 */
#define NERR_DuplicateName      (NERR_BASE+197) /* A duplicate message alias exists on the network. */
#define NERR_DeleteLater        (NERR_BASE+198) /* @W This message alias will be deleted later. */
#define NERR_IncompleteDel      (NERR_BASE+199) /* The message alias was not successfully deleted from all networks. */
#define NERR_MultipleNets       (NERR_BASE+200) /* This operation is not supported on computers with multiple networks. */

/*
 *      Server API related
 *              Error codes BASE+210 to BASE+229
 */

#define NERR_NetNameNotFound    (NERR_BASE+210) /* This shared resource does not exist.*/
#define NERR_DeviceNotShared    (NERR_BASE+211) /* This device is not shared. */
#define NERR_ClientNameNotFound (NERR_BASE+212) /* A session does not exist with that computer name. */
#define NERR_FileIdNotFound     (NERR_BASE+214) /* There is not an open file with that identification number. */
#define NERR_ExecFailure        (NERR_BASE+215) /* A failure occurred when executing a remote administration command. */
#define NERR_TmpFile            (NERR_BASE+216) /* A failure occurred when opening a remote temporary file. */
#define NERR_TooMuchData        (NERR_BASE+217) /* The data returned from a remote administration command has been truncated to 64K. */
#define NERR_DeviceShareConflict (NERR_BASE+218) /* This device cannot be shared as both a spooled and a non-spooled resource. */
#define NERR_BrowserTableIncomplete (NERR_BASE+219)  /* The information in the list of servers may be incorrect. */
#define NERR_NotLocalDomain     (NERR_BASE+220) /* The computer is not active in this domain. */
#define NERR_IsDfsShare         (NERR_BASE+221) /* The share must be removed from the Distributed File System before it can be deleted. */

/*
 *      CharDev API related
 *              Error codes BASE+230 to BASE+249
 */

/* UNUSED BASE+230 */
#define NERR_DevInvalidOpCode   (NERR_BASE+231) /* The operation is invalid for this device. */
#define NERR_DevNotFound        (NERR_BASE+232) /* This device cannot be shared. */
#define NERR_DevNotOpen         (NERR_BASE+233) /* This device was not open. */
#define NERR_BadQueueDevString  (NERR_BASE+234) /* This device name list is invalid. */
#define NERR_BadQueuePriority   (NERR_BASE+235) /* The queue priority is invalid. */
#define NERR_NoCommDevs         (NERR_BASE+237) /* There are no shared communication devices. */
#define NERR_QueueNotFound      (NERR_BASE+238) /* The queue you specified does not exist. */
#define NERR_BadDevString       (NERR_BASE+240) /* This list of devices is invalid. */
#define NERR_BadDev             (NERR_BASE+241) /* The requested device is invalid. */
#define NERR_InUseBySpooler     (NERR_BASE+242) /* This device is already in use by the spooler. */
#define NERR_CommDevInUse       (NERR_BASE+243) /* This device is already in use as a communication device. */

/*
 *      NetICanonicalize and NetIType and NetIMakeLMFileName
 *      NetIListCanon and NetINameCheck
 *              Error codes BASE+250 to BASE+269
 */

#define NERR_InvalidComputer   (NERR_BASE+251) /* This computer name is invalid. */
/* UNUSED BASE+252 */
/* UNUSED BASE+253 */
#define NERR_MaxLenExceeded    (NERR_BASE+254) /* The string and prefix specified are too long. */
/* UNUSED BASE+255 */
#define NERR_BadComponent      (NERR_BASE+256) /* This path component is invalid. */
#define NERR_CantType          (NERR_BASE+257) /* Could not determine the type of input. */
/* UNUSED BASE+258 */
/* UNUSED BASE+259 */
#define NERR_TooManyEntries    (NERR_BASE+262) /* The buffer for types is not big enough. */

/*
 *      NetProfile
 *              Error codes BASE+270 to BASE+276
 */

#define NERR_ProfileFileTooBig  (NERR_BASE+270) /* Profile files cannot exceed 64K. */
#define NERR_ProfileOffset      (NERR_BASE+271) /* The start offset is out of range. */
#define NERR_ProfileCleanup     (NERR_BASE+272) /* The system cannot delete current connections to network resources. */
#define NERR_ProfileUnknownCmd  (NERR_BASE+273) /* The system was unable to parse the command line in this file.*/
#define NERR_ProfileLoadErr     (NERR_BASE+274) /* An error occurred while loading the profile file. */
#define NERR_ProfileSaveErr     (NERR_BASE+275) /* @W Errors occurred while saving the profile file.  The profile was partially saved. */


/*
 *      NetAudit and NetErrorLog
 *              Error codes BASE+277 to BASE+279
 */

#define NERR_LogOverflow           (NERR_BASE+277)      /* Log file %1 is full. */
#define NERR_LogFileChanged        (NERR_BASE+278)      /* This log file has changed between reads. */
#define NERR_LogFileCorrupt        (NERR_BASE+279)      /* Log file %1 is corrupt. */


/*
 *      NetRemote
 *              Error codes BASE+280 to BASE+299
 */
#define NERR_SourceIsDir   (NERR_BASE+280) /* The source path cannot be a directory. */
#define NERR_BadSource     (NERR_BASE+281) /* The source path is illegal. */
#define NERR_BadDest       (NERR_BASE+282) /* The destination path is illegal. */
#define NERR_DifferentServers   (NERR_BASE+283) /* The source and destination paths are on different servers. */
/* UNUSED BASE+284 */
#define NERR_RunSrvPaused       (NERR_BASE+285) /* The Run server you requested is paused. */
/* UNUSED BASE+286 */
/* UNUSED BASE+287 */
/* UNUSED BASE+288 */
#define NERR_ErrCommRunSrv      (NERR_BASE+289) /* An error occurred when communicating with a Run server. */
/* UNUSED BASE+290 */
#define NERR_ErrorExecingGhost  (NERR_BASE+291) /* An error occurred when starting a background process. */
#define NERR_ShareNotFound      (NERR_BASE+292) /* The shared resource you are connected to could not be found.*/
/* UNUSED BASE+293 */
/* UNUSED BASE+294 */


/*
 *  NetWksta.sys (redir) returned error codes.
 *
 *          NERR_BASE + (300-329)
 */

#define NERR_InvalidLana        (NERR_BASE+300) /* The LAN adapter number is invalid.  */
#define NERR_OpenFiles          (NERR_BASE+301) /* There are open files on the connection.    */
#define NERR_ActiveConns        (NERR_BASE+302) /* Active connections still exist. */
#define NERR_BadPasswordCore    (NERR_BASE+303) /* This share name or password is invalid. */
#define NERR_DevInUse           (NERR_BASE+304) /* The device is being accessed by an active process. */
#define NERR_LocalDrive         (NERR_BASE+305) /* The drive letter is in use locally. */

/*
 *  Alert error codes.
 *
 *          NERR_BASE + (330-339)
 */
#define NERR_AlertExists        (NERR_BASE+330) /* The specified client is already registered for the specified event. */
#define NERR_TooManyAlerts      (NERR_BASE+331) /* The alert table is full. */
#define NERR_NoSuchAlert        (NERR_BASE+332) /* An invalid or nonexistent alert name was raised. */
#define NERR_BadRecipient       (NERR_BASE+333) /* The alert recipient is invalid.*/
#define NERR_AcctLimitExceeded  (NERR_BASE+334) /* A user's session with this server has been deleted
                                                 * because the user's logon hours are no longer valid. */

/*
 *  Additional Error and Audit log codes.
 *
 *          NERR_BASE +(340-343)
 */
#define NERR_InvalidLogSeek     (NERR_BASE+340) /* The log file does not contain the requested record number. */
/* UNUSED BASE+341 */
/* UNUSED BASE+342 */
/* UNUSED BASE+343 */

/*
 *  Additional UAS and NETLOGON codes
 *
 *          NERR_BASE +(350-359)
 */
#define NERR_BadUasConfig       (NERR_BASE+350) /* The user accounts database is not configured correctly. */
#define NERR_InvalidUASOp       (NERR_BASE+351) /* This operation is not permitted when the Netlogon service is running. */
#define NERR_LastAdmin          (NERR_BASE+352) /* This operation is not allowed on the last administrative account. */
#define NERR_DCNotFound         (NERR_BASE+353) /* Could not find domain controller for this domain. */
#define NERR_LogonTrackingError (NERR_BASE+354) /* Could not set logon information for this user. */
#define NERR_NetlogonNotStarted (NERR_BASE+355) /* The Netlogon service has not been started. */
#define NERR_CanNotGrowUASFile  (NERR_BASE+356) /* Unable to add to the user accounts database. */
#define NERR_TimeDiffAtDC       (NERR_BASE+357) /* This server's clock is not synchronized with the primary domain controller's clock. */
#define NERR_PasswordMismatch   (NERR_BASE+358) /* A password mismatch has been detected. */


/*
 *  Server Integration error codes.
 *
 *          NERR_BASE +(360-369)
 */
#define NERR_NoSuchServer       (NERR_BASE+360) /* The server identification does not specify a valid server. */
#define NERR_NoSuchSession      (NERR_BASE+361) /* The session identification does not specify a valid session. */
#define NERR_NoSuchConnection   (NERR_BASE+362) /* The connection identification does not specify a valid connection. */
#define NERR_TooManyServers     (NERR_BASE+363) /* There is no space for another entry in the table of available servers. */
#define NERR_TooManySessions    (NERR_BASE+364) /* The server has reached the maximum number of sessions it supports. */
#define NERR_TooManyConnections (NERR_BASE+365) /* The server has reached the maximum number of connections it supports. */
#define NERR_TooManyFiles       (NERR_BASE+366) /* The server cannot open more files because it has reached its maximum number. */
#define NERR_NoAlternateServers (NERR_BASE+367) /* There are no alternate servers registered on this server. */
/* UNUSED BASE+368 */
/* UNUSED BASE+369 */

#define NERR_TryDownLevel       (NERR_BASE+370) /* Try down-level (remote admin protocol) version of API instead. */

/*
 *  UPS error codes.
 *
 *          NERR_BASE + (380-384)
 */
#define NERR_UPSDriverNotStarted    (NERR_BASE+380) /* The UPS driver could not be accessed by the UPS service. */
#define NERR_UPSInvalidConfig       (NERR_BASE+381) /* The UPS service is not configured correctly. */
#define NERR_UPSInvalidCommPort     (NERR_BASE+382) /* The UPS service could not access the specified Comm Port. */
#define NERR_UPSSignalAsserted      (NERR_BASE+383) /* The UPS indicated a line fail or low battery situation. Service not started. */
#define NERR_UPSShutdownFailed      (NERR_BASE+384) /* The UPS service failed to perform a system shut down. */

/*
 *  Remoteboot error codes.
 *
 *          NERR_BASE + (400-419)
 *          Error codes 400 - 405 are used by RPLBOOT.SYS.
 *          Error codes 403, 407 - 416 are used by RPLLOADR.COM,
 *          Error code 417 is the alerter message of REMOTEBOOT (RPLSERVR.EXE).
 *          Error code 418 is for when REMOTEBOOT can't start
 *          Error code 419 is for a disallowed 2nd rpl connection
 *
 */
#define NERR_BadDosRetCode      (NERR_BASE+400) /* The program below returned an MS-DOS error code:*/
#define NERR_ProgNeedsExtraMem  (NERR_BASE+401) /* The program below needs more memory:*/
#define NERR_BadDosFunction     (NERR_BASE+402) /* The program below called an unsupported MS-DOS function:*/
#define NERR_RemoteBootFailed   (NERR_BASE+403) /* The workstation failed to boot.*/
#define NERR_BadFileCheckSum    (NERR_BASE+404) /* The file below is corrupt.*/
#define NERR_NoRplBootSystem    (NERR_BASE+405) /* No loader is specified in the boot-block definition file.*/
#define NERR_RplLoadrNetBiosErr (NERR_BASE+406) /* NetBIOS returned an error: The NCB and SMB are dumped above.*/
#define NERR_RplLoadrDiskErr    (NERR_BASE+407) /* A disk I/O error occurred.*/
#define NERR_ImageParamErr      (NERR_BASE+408) /* Image parameter substitution failed.*/
#define NERR_TooManyImageParams (NERR_BASE+409) /* Too many image parameters cross disk sector boundaries.*/
#define NERR_NonDosFloppyUsed   (NERR_BASE+410) /* The image was not generated from an MS-DOS diskette formatted with /S.*/
#define NERR_RplBootRestart     (NERR_BASE+411) /* Remote boot will be restarted later.*/
#define NERR_RplSrvrCallFailed  (NERR_BASE+412) /* The call to the Remoteboot server failed.*/
#define NERR_CantConnectRplSrvr (NERR_BASE+413) /* Cannot connect to the Remoteboot server.*/
#define NERR_CantOpenImageFile  (NERR_BASE+414) /* Cannot open image file on the Remoteboot server.*/
#define NERR_CallingRplSrvr     (NERR_BASE+415) /* Connecting to the Remoteboot server...*/
#define NERR_StartingRplBoot    (NERR_BASE+416) /* Connecting to the Remoteboot server...*/
#define NERR_RplBootServiceTerm (NERR_BASE+417) /* Remote boot service was stopped; check the error log for the cause of the problem.*/
#define NERR_RplBootStartFailed (NERR_BASE+418) /* Remote boot startup failed; check the error log for the cause of the problem.*/
#define NERR_RPL_CONNECTED      (NERR_BASE+419) /* A second connection to a Remoteboot resource is not allowed.*/

/*
 *  FTADMIN API error codes
 *
 *       NERR_BASE + (425-434)
 *
 *       (Currently not used in NT)
 *
 */

/*
 *  Browser service API error codes
 *
 *       NERR_BASE + (450-475)
 *
 */
#define NERR_BrowserConfiguredToNotRun     (NERR_BASE+450) /* The browser service was configured with MaintainServerList=No. */

/*
 *  Additional Remoteboot error codes.
 *
 *          NERR_BASE + (510-550)
 */
#define NERR_RplNoAdaptersStarted          (NERR_BASE+510) /*Service failed to start since none of the network adapters started with this service.*/
#define NERR_RplBadRegistry                (NERR_BASE+511) /*Service failed to start due to bad startup information in the registry.*/
#define NERR_RplBadDatabase                (NERR_BASE+512) /*Service failed to start because its database is absent or corrupt.*/
#define NERR_RplRplfilesShare              (NERR_BASE+513) /*Service failed to start because RPLFILES share is absent.*/
#define NERR_RplNotRplServer               (NERR_BASE+514) /*Service failed to start because RPLUSER group is absent.*/
#define NERR_RplCannotEnum                 (NERR_BASE+515) /*Cannot enumerate service records.*/
#define NERR_RplWkstaInfoCorrupted         (NERR_BASE+516) /*Workstation record information has been corrupted.*/
#define NERR_RplWkstaNotFound              (NERR_BASE+517) /*Workstation record was not found.*/
#define NERR_RplWkstaNameUnavailable       (NERR_BASE+518) /*Workstation name is in use by some other workstation.*/
#define NERR_RplProfileInfoCorrupted       (NERR_BASE+519) /*Profile record information has been corrupted.*/
#define NERR_RplProfileNotFound            (NERR_BASE+520) /*Profile record was not found.*/
#define NERR_RplProfileNameUnavailable     (NERR_BASE+521) /*Profile name is in use by some other profile.*/
#define NERR_RplProfileNotEmpty            (NERR_BASE+522) /*There are workstations using this profile.*/
#define NERR_RplConfigInfoCorrupted        (NERR_BASE+523) /*Configuration record information has been corrupted.*/
#define NERR_RplConfigNotFound             (NERR_BASE+524) /*Configuration record was not found.*/
#define NERR_RplAdapterInfoCorrupted       (NERR_BASE+525) /*Adapter id record information has been corrupted.*/
#define NERR_RplInternal                   (NERR_BASE+526) /*An internal service error has occurred.*/
#define NERR_RplVendorInfoCorrupted        (NERR_BASE+527) /*Vendor id record information has been corrupted.*/
#define NERR_RplBootInfoCorrupted          (NERR_BASE+528) /*Boot block record information has been corrupted.*/
#define NERR_RplWkstaNeedsUserAcct         (NERR_BASE+529) /*The user account for this workstation record is missing.*/
#define NERR_RplNeedsRPLUSERAcct           (NERR_BASE+530) /*The RPLUSER local group could not be found.*/
#define NERR_RplBootNotFound               (NERR_BASE+531) /*Boot block record was not found.*/
#define NERR_RplIncompatibleProfile        (NERR_BASE+532) /*Chosen profile is incompatible with this workstation.*/
#define NERR_RplAdapterNameUnavailable     (NERR_BASE+533) /*Chosen network adapter id is in use by some other workstation.*/
#define NERR_RplConfigNotEmpty             (NERR_BASE+534) /*There are profiles using this configuration.*/
#define NERR_RplBootInUse                  (NERR_BASE+535) /*There are workstations, profiles or configurations using this boot block.*/
#define NERR_RplBackupDatabase             (NERR_BASE+536) /*Service failed to backup Remoteboot database.*/
#define NERR_RplAdapterNotFound            (NERR_BASE+537) /*Adapter record was not found.*/
#define NERR_RplVendorNotFound             (NERR_BASE+538) /*Vendor record was not found.*/
#define NERR_RplVendorNameUnavailable      (NERR_BASE+539) /*Vendor name is in use by some other vendor record.*/
#define NERR_RplBootNameUnavailable        (NERR_BASE+540) /*(boot name, vendor id) is in use by some other boot block record.*/
#define NERR_RplConfigNameUnavailable      (NERR_BASE+541) /*Configuration name is in use by some other configuration.*/

/**INTERNAL_ONLY**/

/*
 *  Dfs API error codes.
 *
 *          NERR_BASE + (560-590)
 */

#define NERR_DfsInternalCorruption         (NERR_BASE+560) /*The internal database maintained by the DFS service is corrupt*/
#define NERR_DfsVolumeDataCorrupt          (NERR_BASE+561) /*One of the records in the internal DFS database is corrupt*/
#define NERR_DfsNoSuchVolume               (NERR_BASE+562) /*There is no volume whose entry path matches the input Entry Path*/
#define NERR_DfsVolumeAlreadyExists        (NERR_BASE+563) /*A volume with the given name already exists*/
#define NERR_DfsAlreadyShared              (NERR_BASE+564) /*The server share specified is already shared in the DFS*/
#define NERR_DfsNoSuchShare                (NERR_BASE+565) /*The indicated server share does not support the indicated DFS volume*/
#define NERR_DfsNotALeafVolume             (NERR_BASE+566) /*The operation is not valid on a non-leaf volume*/
#define NERR_DfsLeafVolume                 (NERR_BASE+567) /*The operation is not valid on a leaf volume*/
#define NERR_DfsVolumeHasMultipleServers   (NERR_BASE+568) /*The operation is ambiguous because the volume has multiple servers*/
#define NERR_DfsCantCreateJunctionPoint    (NERR_BASE+569) /*Unable to create a junction point*/
#define NERR_DfsServerNotDfsAware          (NERR_BASE+570) /*The server is not DFS Aware*/
#define NERR_DfsBadRenamePath              (NERR_BASE+571) /*The specified rename target path is invalid*/
#define NERR_DfsVolumeIsOffline            (NERR_BASE+572) /*The specified DFS volume is offline*/
#define NERR_DfsNoSuchServer               (NERR_BASE+573) /*The specified server is not a server for this volume*/
#define NERR_DfsCyclicalName               (NERR_BASE+574) /*A cycle in the DFS name was detected*/
#define NERR_DfsNotSupportedInServerDfs    (NERR_BASE+575) /*The operation is not supported on a server-based DFS*/
#define NERR_DfsDuplicateService           (NERR_BASE+576) /*This volume is already supported by the specified server-share*/
#define NERR_DfsCantRemoveLastServerShare  (NERR_BASE+577) /*Can't remove the last server-share supporting this volume*/
#define NERR_DfsVolumeIsInterDfs           (NERR_BASE+578) /*The operation is not supported for an Inter-DFS volume*/
#define NERR_DfsInconsistent               (NERR_BASE+579) /*The internal state of the DFS Service has become inconsistent*/
#define NERR_DfsServerUpgraded             (NERR_BASE+580) /*The DFS Service has been installed on the specified server*/
#define NERR_DfsDataIsIdentical            (NERR_BASE+581) /*The DFS data being reconciled is identical*/
#define NERR_DfsCantRemoveDfsRoot          (NERR_BASE+582) /*The DFS root volume cannot be deleted - Uninstall DFS if required*/
#define NERR_DfsChildOrParentInDfs         (NERR_BASE+583) /*A child or parent directory of the share is already in a DFS*/
#define NERR_DfsInternalError              (NERR_BASE+590) /*DFS internal error*/

/*
 *  Net setup error codes.
 *
 *          NERR_BASE + (591-600)
 */
#define NERR_SetupAlreadyJoined            (NERR_BASE+591) /*This machine is already joined to a domain.*/
#define NERR_SetupNotJoined                (NERR_BASE+592) /*This machine is not currently joined to a domain.*/
#define NERR_SetupDomainController         (NERR_BASE+593) /*This machine is a domain controller and cannot be unjoined from a domain.*/
#define NERR_DefaultJoinRequired           (NERR_BASE+594) /*The destination domain controller does not support creating machine accounts in OUs.*/
#define NERR_InvalidWorkgroupName          (NERR_BASE+595) /*The specified workgroup name is invalid*/
#define NERR_NameUsesIncompatibleCodePage  (NERR_BASE+596) /*The specified computer name is incompatible with the default language used on the domain controller.*/
#define NERR_ComputerAccountNotFound       (NERR_BASE+597) /*The specified computer account could not be found.*/
#define NERR_PersonalSku                   (NERR_BASE+598) /*This version of Windows cannot be joined to a domain.*/

/***********WARNING ****************
 *The range 2750-2799 has been     *
 *allocated to the IBM LAN Server  *
 ***********************************/

/***********WARNING ****************
 *The range 2900-2999 has been     *
 *reserved for Microsoft OEMs      *
 ***********************************/

/**END_INTERNAL**/

#define MAX_NERR                (NERR_BASE+899) /* This is the last error in NERR range. */

/*
 * end of list
 *
 *    WARNING:  Do not exceed MAX_NERR; values above this are used by
 *              other error code ranges (errlog.h, service.h, apperr.h).
 */


/*NOINC*/
#endif /* NETERR_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmdfs.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmdfs.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetDfs API

Environment:

    User Mode - Win32

Notes:

    You must include <windef.h> and <lmcons.h> before this file.

--*/

#ifndef _LMDFS_
#define _LMDFS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// DFS Volume state
//

#define DFS_VOLUME_STATE_OK            1
#define DFS_VOLUME_STATE_INCONSISTENT  2
#define DFS_VOLUME_STATE_OFFLINE       3
#define DFS_VOLUME_STATE_ONLINE        4

//
// DFS Storage State
//

#define DFS_STORAGE_STATE_OFFLINE      1
#define DFS_STORAGE_STATE_ONLINE       2
#define DFS_STORAGE_STATE_ACTIVE       4

//
// Level 1:
//
typedef struct _DFS_INFO_1 {
    LPWSTR  EntryPath;              // Dfs name for the top of this piece of storage
} DFS_INFO_1, *PDFS_INFO_1, *LPDFS_INFO_1;

//
// Level 2:
//
typedef struct _DFS_INFO_2 {
    LPWSTR  EntryPath;              // Dfs name for the top of this volume
    LPWSTR  Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    DWORD   NumberOfStorages;       // Number of storages for this volume
} DFS_INFO_2, *PDFS_INFO_2, *LPDFS_INFO_2;

typedef struct _DFS_STORAGE_INFO {
    ULONG   State;                  // State of this storage, one of DFS_STORAGE_STATE_*
                                    // possibly OR'd with DFS_STORAGE_STATE_ACTIVE
    LPWSTR  ServerName;             // Name of server hosting this storage
    LPWSTR  ShareName;              // Name of share hosting this storage
} DFS_STORAGE_INFO, *PDFS_STORAGE_INFO, *LPDFS_STORAGE_INFO;

//
// Level 3:
//
typedef struct _DFS_INFO_3 {
    LPWSTR  EntryPath;              // Dfs name for the top of this volume
    LPWSTR  Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
#ifdef MIDL_PASS
    [size_is(NumberOfStorages)] LPDFS_STORAGE_INFO Storage;
#else
    LPDFS_STORAGE_INFO   Storage;   // An array (of NumberOfStorages elements) of storage-specific information.
#endif // MIDL_PASS
} DFS_INFO_3, *PDFS_INFO_3, *LPDFS_INFO_3;

//
// Level 4:
//
typedef struct _DFS_INFO_4 {
    LPWSTR  EntryPath;              // Dfs name for the top of this volume
    LPWSTR  Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    ULONG   Timeout;                // Timeout, in seconds, of this junction point
    GUID    Guid;                   // Guid of this junction point
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
#ifdef MIDL_PASS
    [size_is(NumberOfStorages)] LPDFS_STORAGE_INFO Storage;
#else
    LPDFS_STORAGE_INFO   Storage;   // An array (of NumberOfStorages elements) of storage-specific information.
#endif // MIDL_PASS
} DFS_INFO_4, *PDFS_INFO_4, *LPDFS_INFO_4;

//
// Level 100:
//
typedef struct _DFS_INFO_100 {
    LPWSTR  Comment;                // Comment for this volume or storage
} DFS_INFO_100, *PDFS_INFO_100, *LPDFS_INFO_100;

//
// Level 101:
//
typedef struct _DFS_INFO_101 {
    DWORD   State;                  // State of this storage, one of DFS_STORAGE_STATE_*
                                    // possibly OR'd with DFS_STORAGE_STATE_ACTIVE
} DFS_INFO_101, *PDFS_INFO_101, *LPDFS_INFO_101;

//
// Level 102:
//
typedef struct _DFS_INFO_102 {
    ULONG   Timeout;                // Timeout, in seconds, of the junction
} DFS_INFO_102, *PDFS_INFO_102, *LPDFS_INFO_102;

//
// Level 200:
//
typedef struct _DFS_INFO_200 {
    LPWSTR  FtDfsName;              // FtDfs name
} DFS_INFO_200, *PDFS_INFO_200, *LPDFS_INFO_200;

//
// Add a new volume or additional storage for an existing volume at
// DfsEntryPath.
//
NET_API_STATUS NET_API_FUNCTION
NetDfsAdd(
    IN  LPWSTR DfsEntryPath,        // DFS entry path for this added volume or storage
    IN  LPWSTR ServerName,          // Name of server hosting the storage
    IN  LPWSTR ShareName,           // Existing share name for the storage
    IN  LPWSTR Comment OPTIONAL,    // Optional comment for this volume or storage
    IN  DWORD  Flags                // See below. Zero for no flags.
);

//
// Flags:
//
#define DFS_ADD_VOLUME          1   // Add a new volume to the DFS if not already there
#define DFS_RESTORE_VOLUME      2   // Volume/Replica is being restored - do not verify share etc.

//
// Setup/teardown API's for standard and FtDfs roots.
//

NET_API_STATUS NET_API_FUNCTION
NetDfsAddStdRoot(
    IN  LPWSTR ServerName,          // Server to remote to
    IN  LPWSTR RootShare,           // Share to make Dfs root
    IN  LPWSTR Comment OPTIONAL,    // Comment
    IN  DWORD  Flags                // Flags for operation.  Zero for no flags.
);

NET_API_STATUS NET_API_FUNCTION
NetDfsRemoveStdRoot(
    IN  LPWSTR ServerName,          // Server to remote to
    IN  LPWSTR RootShare,           // Share that host Dfs root
    IN  DWORD  Flags                // Flags for operation.  Zero for no flags.
);

NET_API_STATUS NET_API_FUNCTION
NetDfsAddFtRoot(
    IN  LPWSTR ServerName,          // Server to remote to
    IN  LPWSTR RootShare,           // Share to make Dfs root
    IN  LPWSTR FtDfsName,           // Name of FtDfs to create/join
    IN  LPWSTR Comment,             // Comment
    IN  DWORD  Flags                // Flags for operation.  Zero for no flags.
);

NET_API_STATUS NET_API_FUNCTION
NetDfsRemoveFtRoot(
    IN  LPWSTR ServerName,          // Server to remote to
    IN  LPWSTR RootShare,           // Share that host Dfs root
    IN  LPWSTR FtDfsName,           // Name of FtDfs to remove or unjoin from.
    IN  DWORD  Flags                // Flags for operation.  Zero for no flags.
);

NET_API_STATUS NET_API_FUNCTION
NetDfsRemoveFtRootForced(
    IN  LPWSTR DomainName,          // Name of domain the server is in
    IN  LPWSTR ServerName,          // Server to remote to
    IN  LPWSTR RootShare,           // Share that host Dfs root
    IN  LPWSTR FtDfsName,           // Name of FtDfs to remove or unjoin from.
    IN  DWORD  Flags                // Flags for operation.  Zero for no flags.
);

//
// Call to reinitialize the dfsmanager on a machine
//

NET_API_STATUS NET_API_FUNCTION
NetDfsManagerInitialize(
    IN  LPWSTR ServerName,          // Server to remote to
    IN  DWORD  Flags                // Flags for operation.  Zero for no flags.
);

NET_API_STATUS NET_API_FUNCTION
NetDfsAddStdRootForced(
    IN  LPWSTR ServerName,          // Server to remote to
    IN  LPWSTR RootShare,           // Share to make Dfs root
    IN  LPWSTR Comment OPTIONAL,    // Comment
    IN  LPWSTR Store                // Drive:\dir backing the share
);

NET_API_STATUS NET_API_FUNCTION
NetDfsGetDcAddress(
    IN  LPWSTR ServerName,          // Server to remote to
    IN  OUT LPWSTR *DcIpAddress,    // The IP address of the DC to use
    IN  OUT BOOLEAN *IsRoot,        // TRUE if server is a Dfs root, FALSE otherwise
    IN  OUT ULONG *Timeout          // Time, in sec, that we stay with this DC
);


//
// Flags for NetDfsSetDcAddress()
//

#define NET_DFS_SETDC_FLAGS                 0x00000000
#define NET_DFS_SETDC_TIMEOUT               0x00000001
#define NET_DFS_SETDC_INITPKT               0x00000002

//
// Structures used for site reporting
//

typedef struct {
    ULONG SiteFlags;    // Below
#ifdef  MIDL_PASS
    [string,unique] LPWSTR SiteName;
#else
    LPWSTR SiteName;
#endif
} DFS_SITENAME_INFO, *PDFS_SITENAME_INFO, *LPDFS_SITENAME_INFO;

// SiteFlags

#define DFS_SITE_PRIMARY    0x1     // This site returned by DsGetSiteName()

typedef struct {
    ULONG cSites;
#ifdef  MIDL_PASS
    [size_is(cSites)] DFS_SITENAME_INFO Site[];
#else
    DFS_SITENAME_INFO Site[1];
#endif
} DFS_SITELIST_INFO, *PDFS_SITELIST_INFO, *LPDFS_SITELIST_INFO;

//
// Remove a volume or additional storage for volume from the Dfs at
// DfsEntryPath. When applied to the last storage in a volume, removes
// the volume from the DFS.
//
NET_API_STATUS NET_API_FUNCTION
NetDfsRemove(
    IN  LPWSTR  DfsEntryPath,       // DFS entry path for this added volume or storage
    IN  LPWSTR  ServerName,         // Name of server hosting the storage
    IN  LPWSTR  ShareName           // Name of share hosting the storage
);

//
// Get information about all of the volumes in the Dfs. DfsName is
// the "server" part of the UNC name used to refer to this particular Dfs.
//
// Valid levels are 1-4, 200
//
NET_API_STATUS NET_API_FUNCTION
NetDfsEnum(
    IN      LPWSTR  DfsName,        // Name of the Dfs for enumeration
    IN      DWORD   Level,          // Level of information requested
    IN      DWORD   PrefMaxLen,     // Advisory, but -1 means "get it all"
    OUT     LPBYTE* Buffer,         // API allocates and returns buffer with requested info
    OUT     LPDWORD EntriesRead,    // Number of entries returned
    IN OUT  LPDWORD ResumeHandle    // Must be 0 on first call, reused on subsequent calls
);

//
// Get information about the volume or storage.
// If ServerName and ShareName are specified, the information returned
// is specific to that server and share, else the information is specific
// to the volume as a whole.
//
// Valid levels are 1-4, 100
//
NET_API_STATUS NET_API_FUNCTION
NetDfsGetInfo(
    IN  LPWSTR  DfsEntryPath,       // DFS entry path for the volume
    IN  LPWSTR  ServerName OPTIONAL,// Name of server hosting a storage
    IN  LPWSTR  ShareName OPTIONAL, // Name of share on server serving the volume
    IN  DWORD   Level,              // Level of information requested
    OUT LPBYTE* Buffer              // API allocates and returns buffer with requested info
);

//
// Set info about the volume or storage.
// If ServerName and ShareName are specified, the information set is
// specific to that server and share, else the information is specific
// to the volume as a whole.
//
// Valid levels are 100, 101 and 102
//
NET_API_STATUS NET_API_FUNCTION
NetDfsSetInfo(
    IN  LPWSTR  DfsEntryPath,           // DFS entry path for the volume
    IN  LPWSTR  ServerName OPTIONAL,    // Name of server hosting a storage
    IN  LPWSTR  ShareName OPTIONAL,     // Name of share hosting a storage
    IN  DWORD   Level,                  // Level of information to be set
    IN  LPBYTE  Buffer                  // Buffer holding information
);

//
// Get client's cached information about the volume or storage.
// If ServerName and ShareName are specified, the information returned
// is specific to that server and share, else the information is specific
// to the volume as a whole.
//
// Valid levels are 1-4
//
NET_API_STATUS NET_API_FUNCTION
NetDfsGetClientInfo(
    IN  LPWSTR  DfsEntryPath,       // DFS entry path for the volume
    IN  LPWSTR  ServerName OPTIONAL,// Name of server hosting a storage
    IN  LPWSTR  ShareName OPTIONAL, // Name of share on server serving the volume
    IN  DWORD   Level,              // Level of information requested
    OUT LPBYTE* Buffer              // API allocates and returns buffer with requested info
);

//
// Set client's cached info about the volume or storage.
// If ServerName and ShareName are specified, the information set is
// specific to that server and share, else the information is specific
// to the volume as a whole.
//
// Valid levels are 101 and 102.
//
NET_API_STATUS NET_API_FUNCTION
NetDfsSetClientInfo(
    IN  LPWSTR  DfsEntryPath,           // DFS entry path for the volume
    IN  LPWSTR  ServerName OPTIONAL,    // Name of server hosting a storage
    IN  LPWSTR  ShareName OPTIONAL,     // Name of share hosting a storage
    IN  DWORD   Level,                  // Level of information to be set
    IN  LPBYTE  Buffer                  // Buffer holding information
);

//
// Move a DFS volume and all subordinate volumes from one place in the
// DFS to another place in the DFS.
//
NET_API_STATUS NET_API_FUNCTION
NetDfsMove(
    IN  LPWSTR  DfsEntryPath,           // Current DFS entry path for this volume
    IN  LPWSTR  DfsNewEntryPath         // New DFS entry path for this volume
);

NET_API_STATUS NET_API_FUNCTION
NetDfsRename(
    IN  LPWSTR  Path,                   // Current Win32 path in a Dfs
    IN  LPWSTR  NewPath                 // New Win32 path in the same Dfs
);

#ifdef __cplusplus
}
#endif

#endif // _LMDFS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmuse.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmuse.c

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetUse API.


Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.


--*/

#ifndef _LMUSE_
#define _LMUSE_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>
#include <lmuseflg.h>                   // Deletion force level flags

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetUseAdd (
    IN LMSTR  UncServerName OPTIONAL,
    IN DWORD Level,
    IN LPBYTE Buf,
    OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUseDel (
    IN LMSTR  UncServerName OPTIONAL,
    IN LMSTR  UseName,
    IN DWORD ForceCond
    );

NET_API_STATUS NET_API_FUNCTION
NetUseEnum (
    IN LMSTR  UncServerName OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PreferedMaximumSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetUseGetInfo (
    IN LMSTR  UncServerName OPTIONAL,
    IN LMSTR  UseName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr
    );

//
//  Data Structures
//

typedef struct _USE_INFO_0 {
    LMSTR   ui0_local;
    LMSTR   ui0_remote;
}USE_INFO_0, *PUSE_INFO_0, *LPUSE_INFO_0;

typedef struct _USE_INFO_1 {
    LMSTR   ui1_local;
    LMSTR   ui1_remote;
    LMSTR   ui1_password;
    DWORD   ui1_status;
    DWORD   ui1_asg_type;
    DWORD   ui1_refcount;
    DWORD   ui1_usecount;
}USE_INFO_1, *PUSE_INFO_1, *LPUSE_INFO_1;

typedef struct _USE_INFO_2 {
    LMSTR    ui2_local;
    LMSTR    ui2_remote;
    LMSTR    ui2_password;
    DWORD    ui2_status;
    DWORD    ui2_asg_type;
    DWORD    ui2_refcount;
    DWORD    ui2_usecount;
    LMSTR    ui2_username;
    LMSTR    ui2_domainname;
}USE_INFO_2, *PUSE_INFO_2, *LPUSE_INFO_2;

typedef struct _USE_INFO_3 {
    USE_INFO_2 ui3_ui2;
    ULONG      ui3_flags;
} USE_INFO_3, *PUSE_INFO_3, *LPUSE_INFO_3;


//
// Special Values and Constants
//

//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetUseAdd.
//

#define USE_LOCAL_PARMNUM       1
#define USE_REMOTE_PARMNUM      2
#define USE_PASSWORD_PARMNUM    3
#define USE_ASGTYPE_PARMNUM     4
#define USE_USERNAME_PARMNUM    5
#define USE_DOMAINNAME_PARMNUM  6

//
// Values appearing in the ui1_status field of use_info_1 structure.
// Note that USE_SESSLOST and USE_DISCONN are synonyms.
//

#define USE_OK                  0
#define USE_PAUSED              1
#define USE_SESSLOST            2
#define USE_DISCONN             2
#define USE_NETERR              3
#define USE_CONN                4
#define USE_RECONN              5


//
// Values of the ui1_asg_type field of use_info_1 structure
//

#define USE_WILDCARD            ( (DWORD) (-1) )
#define USE_DISKDEV             0
#define USE_SPOOLDEV            1
#define USE_CHARDEV             2
#define USE_IPC                 3

//
// Flags defined in the use_info_3 structure
//

#define CREATE_NO_CONNECT 0x1        // creation flags
#define CREATE_BYPASS_CSC 0x2        // force connection to server, bypassing CSC
                                     //  all ops on this connection go to the server,
                                     //  never to the cache

#ifdef __cplusplus
}
#endif

#endif // _LMUSE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\lmuseflg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmuseflg.h

Abstract:

    This file contains deletion force levels for deleting a connection.

Environment:

    User Mode - Win32

Notes:

    This file has no dependencies.  It is included by lmwksta.h and
    lmuse.h.

Revision History:

--*/

#ifndef _LMUSEFLG_
#define _LMUSEFLG_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Definition for NetWkstaTransportDel and NetUseDel deletion force levels
//

#define USE_NOFORCE             0
#define USE_FORCE               1
#define USE_LOTS_OF_FORCE       2


#endif // _LMUSEFLG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\crt70\loadperf.h ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    loadperf.h

Abstract:

    Header file for the Performance Monitor counter string installation
    and removal functions.

Revision History

    16-Nov-95   Created (a-robw)

--*/

#ifndef _LOADPERF_H_
#define _LOADPERF_H_

#if _MSC_VER > 1000
#pragma once
#endif

// function prototypes for perf counter name string load & unload functions
// provided in LOADPERF.DLL

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __LOADPERF__
#define LOADPERF_FUNCTION   DWORD __stdcall
#else
#define LOADPERF_FUNCTION   __declspec(dllimport) DWORD __stdcall
#endif

// flags for dwFlags Argument

#define LOADPERF_FLAGS_DELETE_MOF_ON_EXIT   ((ULONG_PTR)1)
#define LOADPERF_FLAGS_LOAD_REGISTRY_ONLY   ((ULONG_PTR)2)
#define LOADPERF_FLAGS_CREATE_MOF_ONLY      ((ULONG_PTR)4)
#define LOADPERF_FLAGS_DISPLAY_USER_MSGS    ((ULONG_PTR)8)

// note: LOADPERF_FLAGS_LOAD_REGISTRY_ONLY is not a valid flag for
// LoadMofFromInstalledServiceA/W as the service must already be installed

LOADPERF_FUNCTION
LoadMofFromInstalledServiceA (
    IN  LPCSTR  szServiceName,  // service to create mof for
    IN  LPCSTR  szMofFilename,  // name of file to create
    IN  ULONG_PTR   dwFlags
);

LOADPERF_FUNCTION
LoadMofFromInstalledServiceW (
    IN  LPCWSTR szServiceName,  // service to create mof for
    IN  LPCWSTR szMofFilename,  // name of file to create
    IN  ULONG_PTR   dwFlags
);

LOADPERF_FUNCTION
InstallPerfDllW (
    IN  LPCWSTR szComputerName,
    IN  LPCWSTR lpIniFile,
    IN  ULONG_PTR   dwFlags         
);

LOADPERF_FUNCTION
InstallPerfDllA (
    IN  LPCSTR  szComputerName,
    IN  LPCSTR  lpIniFile,
    IN  ULONG_PTR   dwFlags         
);

LOADPERF_FUNCTION
UnInstallPerfDllA (
    IN  LPCSTR  szComputerName,
    IN  LPCSTR  lpServiceName,
    IN  ULONG_PTR   dwFlags         
);

LOADPERF_FUNCTION
UnInstallPerfDllA (
    IN  LPCSTR  szComputerName,
    IN  LPCSTR  lpServiceName,
    IN  ULONG_PTR   dwFlags         
);

LOADPERF_FUNCTION
LoadPerfCounterTextStringsA (
    IN  LPSTR   lpCommandLine,
    IN  BOOL    bQuietModeArg
);

LOADPERF_FUNCTION
LoadPerfCounterTextStringsW (
    IN  LPWSTR  lpCommandLine,
    IN  BOOL    bQuietModeArg
);

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsW (
    IN  LPWSTR  lpCommandLine,
    IN  BOOL    bQuietModeArg
);

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsA (
    IN  LPSTR   lpCommandLine,
    IN  BOOL    bQuietModeArg
);

LOADPERF_FUNCTION
UpdatePerfNameFilesA (
    IN  LPCSTR      szNewCtrFilePath,
    IN  LPCSTR      szNewHlpFilePath,
    IN  LPSTR       szLanguageID,
    IN  ULONG_PTR   dwFlags
);

LOADPERF_FUNCTION
UpdatePerfNameFilesW (
    IN  LPCWSTR     szNewCtrFilePath,
    IN  LPCWSTR     szNewHlpFilePath,
    IN  LPWSTR      szLanguageID,
    IN  ULONG_PTR   dwFlags
);

LOADPERF_FUNCTION
SetServiceAsTrustedA (
    LPCSTR szReserved,
    LPCSTR szServiceName
);

LOADPERF_FUNCTION
SetServiceAsTrustedW (
    LPCWSTR szReserved,
    LPCWSTR szServiceName
);


#ifdef UNICODE
#define InstallPerfDll                  InstallPerfDllW
#define UnInstallPerfDll                UnInstallPerfDllW
#define LoadPerfCounterTextStrings      LoadPerfCounterTextStringsW
#define UnloadPerfCounterTextStrings    UnloadPerfCounterTextStringsW
#define LoadMofFromInstalledService     LoadMofFromInstalledServiceW
#define UpdatePerfNameFiles             UpdatePerfNameFilesW 
#define SetServiceAsTrusted             SetServiceAsTrustedW
#else
#define InstallPerfDll                  InstallPerfDllA
#define UnInstallPerfDll                UnInstallPerfDllA
#define LoadPerfCounterTextStrings      LoadPerfCounterTextStringsA
#define UnloadPerfCounterTextStrings    UnloadPerfCounterTextSt