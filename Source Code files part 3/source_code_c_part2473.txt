ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void DuplicateHandleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\b_valid.c ===
/*************************************************************************
MODULE: B_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'B'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>


/******************************************************/

void BeginDeferWindowPosValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void BeginEnumLocaleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void BeginPaintValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void BeginPathValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void BitBltValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void BringWindowToTopValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void BuildCommDCBValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\c_valid.c ===
/*************************************************************************
MODULE: C_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'C'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>
#include <parsedef.h> // for CLOPT_GOOD and CLOPT_BAD added by RamC

/******************************************************/

void CallMsgFilterValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CallNamedPipeAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CallNamedPipeWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CallNextHookProcValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CallWindowProcValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CancelDCValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ChangeClipboardChainValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ChangeMenuValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharLowerAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharLowerBuffAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharLowerBuffWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharLowerWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharNextAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharNextWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharPrevAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharPrevWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharToOemAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharToOemBuffAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharToOemBuffWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharToOemWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharUpperAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharUpperBuffAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharUpperBuffWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CharUpperWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CheckDlgButtonValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CheckColorsInGamutValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/


void CheckMenuItemValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CheckRadioButtonValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ChildWindowFromPointValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ChordValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ClearCommBreakValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ClearCommErrorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ClearEventLogAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ClearEventLogWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ClientToScreenValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ClipCursorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CloseClipboardValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CloseDesktopValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CloseEnhMetaFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CloseEventLogValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CloseFigureValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CloseHandleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CloseLocaleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CloseMetaFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CloseSoundValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CloseWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CloseWindowStationValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
/******************************************************/

void ColorMatchToTargetValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
            

/******************************************************/

void CombineRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HRGN)dwRetVal);
}


/******************************************************/

void CombineTransformValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void CommSetupValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CompareFileTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
   ;
}


/******************************************************/

void CompareStringValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ConnectNamedPipeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ContinueDebugEventValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ConvertRequestValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CopyAcceleratorTableValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CopyEnhMetaFileAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CopyEnhMetaFileWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CopyFileAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CopyFileWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CopyMetaFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CopyRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CopySidValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  /* validate only if the two SID's are valid */

  if((ParmGoodBad[1] == CLOPT_GOOD) && 
     (ParmGoodBad[2] == CLOPT_GOOD) &&
     (ParmGoodBad[0] == CLOPT_GOOD))    {
     if(memcmp((PSID)dwParms[1], (PSID)dwParms[2], dwParms[0]))
	ErrorPrint(hConOut,hLog, "CopySidValidate",1, "Failure");
     else 
	ErrorPrint(hConOut,hLog, "CopySidValidate",1, "Success!!");
  }
}


/******************************************************/

void CountClipboardFormatsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CountVoiceNotesValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateAcceleratorTableValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateBitmapValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateBitmapIndirectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateBrushIndirectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateCaretValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void CreateColorSpaceAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void CreateColorSpaceWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void CreateCompatibleBitmapValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateCompatibleDCValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateConsoleScreenBufferValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateCursorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateDCAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteDC((HDC)dwRetVal);
}


/******************************************************/

void CreateDCWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteDC((HDC)dwRetVal);
}


/******************************************************/

void CreateDIBCursorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateDIBPatternBrushValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateDIBPatternBrushPtValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateDIBSectionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateDIBitmapValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateDesktopAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateDesktopWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateDialogIndirectParamAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateDialogIndirectParamWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateDialogParamAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateDialogParamWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateDirectoryAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateDirectoryWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateDiscardableBitmapValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateEllipticRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HRGN)dwRetVal);
}


/******************************************************/

void CreateEllipticRgnIndirectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HRGN)dwRetVal);
}


/******************************************************/

void CreateEnhMetaFileAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateEnhMetaFileWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateEventAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateEventWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateFileAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateFileMappingAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateFileMappingWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateFileWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateFontAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HFONT)dwRetVal);
}


/******************************************************/

void CreateFontIndirectAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HFONT)dwRetVal);
}


/******************************************************/

void CreateFontIndirectWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HFONT)dwRetVal);
}


/******************************************************/

void CreateFontWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HFONT)dwRetVal);
}


/******************************************************/

void CreateHalftonePaletteValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HPALETTE)dwRetVal);
}


/******************************************************/

void CreateHatchBrushValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HBRUSH)dwRetVal);
}


/******************************************************/

void CreateICAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteDC((HDC)dwRetVal);
}


/******************************************************/

void CreateICWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteDC((HDC)dwRetVal);
}


/******************************************************/

void CreateIconValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateIconFromResourceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateIconIndirectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateMailslotAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateMailslotWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateMenuValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateMetaFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateMutexAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateMutexWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateNamedPipeAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateNamedPipeWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreatePaletteValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HPALETTE)dwRetVal);
}


/******************************************************/

void CreatePatternBrushValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreatePenValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreatePenIndirectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreatePipeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreatePolyPolygonRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HRGN)dwRetVal);
}


/******************************************************/

void CreatePolygonRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HRGN)dwRetVal);
}


/******************************************************/

void CreatePopupMenuValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateProcessAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateProcessWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateRectRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HRGN)dwRetVal);
}


/******************************************************/

void CreateRectRgnIndirectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HRGN)dwRetVal);
}


/******************************************************/

void CreateRoundRectRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteObject((HRGN)dwRetVal);
}


/******************************************************/

void CreateSemaphoreAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateSemaphoreWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateSolidBrushValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateThreadValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateWindowExAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void CreateWindowExWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\f_valid.c ===
/*************************************************************************
MODULE: F_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'F'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>


/******************************************************/

void FatalAppExitAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FatalAppExitWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FatalExitValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FileTimeToDosDateTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FileTimeToSystemTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FillConsoleOutputAttributeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FillConsoleOutputCharacterValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FillPathValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FillRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FillRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FindAtomAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FindAtomWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FindCloseValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FindFirstFileAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FindFirstFileWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FindNextFileAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FindNextFileWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FindResourceAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FindResourceWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FindWindowAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FindWindowWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FlashWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FlattenPathValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FloodFillValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FlushConsoleInputBufferValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FlushFileBuffersValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FlushViewOfFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FormatMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FrameRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FrameRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FreeConsoleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FreeLibraryValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void FreeResourceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\a_valid.c ===
/*************************************************************************
MODULE: A_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Modification History:

        2-20-92  RamC  Added validate routines for AddAce and
                       AddAccessAllowedAce
                       Added include files parsedef.h and security.h

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'A'.
For more information, please refer to BadMan.Doc.
*************************************************************************/


#include <BadMan.h>
#include <Validate.h>
#include <parsedef.h>


/*********************************************************************/

void AddAccessAllowedAceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  //
  // The AddAccessAllowed API accepts the following parameters
  //
  // dwParms[0] = PACL  pAcl           supplies ACL being modified
  // dwParms[1] = DWORD dwAceRevision  ACE revision number
  // dwParms[2] = DWORD dwAccessMask   Mask of accesses to be granted to
  //                                   the specified SID
  // dwParms[3] = PSID  pSid           Pointer to the SID being granted
  //                                   access.
  //

  PACCESS_ALLOWED_ACE pAce;
  PACL                pAcl = (PACL)dwParms[0];
  PVOID               pAcePosition;
  USHORT               i;

  //
  // do the validation only if all the parameters to the API are valid
  //

  if((ParmGoodBad[0] == CLOPT_GOOD) &&
     (ParmGoodBad[1] == CLOPT_GOOD) &&
     (ParmGoodBad[2] == CLOPT_GOOD) &&
     (ParmGoodBad[3] == CLOPT_GOOD))   {

    //
    // Check to see if the API call succeeded
    //

    if((BOOL)dwRetVal == TRUE) {


      //
      // get the first ace address
      //

      pAcePosition = (PVOID)((PUCHAR)(pAcl) + sizeof(ACL));

      //
      // locate the position where the AccessAllowedAce was added
      //

      for (i = 0; i < (USHORT)(pAcl->AceCount - 1); i++) {

          pAcePosition = (PVOID)((PUCHAR)pAcePosition +
                        (((PACE_HEADER)pAcePosition)->AceSize));
      }

      //
      // check to see if the ACE was indeed added here
      //

      pAce = (PACCESS_ALLOWED_ACE)pAcePosition;

      if( (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) &&
          (pAce->Header.AceFlags == 0) &&
          (pAce->Header.AceSize == (USHORT)(sizeof(ACE_HEADER)+
                                   sizeof(ACCESS_MASK) +
                                   0/* BUGBUG GetLengthSid((PSID)dwParms[3])*/ )) &&
          (pAce->Mask == dwParms[2]))  {

         ValPrintf(hConOut, "AddAccessAllowedAceValidate: Success!!\n");
      }
      else
         ErrorPrint(hConOut,hLog,"AddAccessAllowedAceValidate",1,"Failure\n");
    } // end if dwRetVAl
  } // end if ParmGoodBad

  //
  // check to see if the API returned TRUE even when bad parameters were
  // specified.
  //

  else {
    if((BOOL)dwRetVal == TRUE) {
         ErrorPrint(hConOut,hLog,"AddAccessAllowedAceValidate",1,"Failure\n");
    }
  }

  VarInfo;	// -W3 Warning elimination
}



/*********************************************************************/

void AddAccessDeniedAceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  //
  // The AddAccessDenied API accepts the following parameters
  //
  // dwParms[0] = PACL  pAcl           supplies ACL being modified
  // dwParms[1] = DWORD dwAceRevision  ACE revision number
  // dwParms[2] = DWORD dwAccessMask   Mask of accesses to be granted to
  //                                   the specified SID
  // dwParms[3] = PSID  pSid           Pointer to the SID being granted
  //                                   access.
  //

  PACCESS_DENIED_ACE  pAce;
  PACL                pAcl = (PACL)dwParms[0];
  PVOID               pAcePosition;
  USHORT               i;

  //
  // do the validation only if all the parameters to the API are valid
  //

  if((ParmGoodBad[0] == CLOPT_GOOD) &&
     (ParmGoodBad[1] == CLOPT_GOOD) &&
     (ParmGoodBad[2] == CLOPT_GOOD) &&
     (ParmGoodBad[3] == CLOPT_GOOD))   {

    //
    // Check to see if the API call succeeded
    //

    if((BOOL)dwRetVal == TRUE) {


      //
      // get the first ace address
      //

      pAcePosition = (PVOID)((PUCHAR)(pAcl) + sizeof(ACL));

      //
      // locate the position where the AccessDeniedAce was added
      //

      for (i = 0; i < (USHORT)(pAcl->AceCount - 1); i++) {

          pAcePosition = (PVOID)((PUCHAR)pAcePosition +
                        (((PACE_HEADER)pAcePosition)->AceSize));
      }

      //
      // check to see if the ACE was indeed added here
      //

      pAce = (PACCESS_DENIED_ACE)pAcePosition;

      if( (pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE) &&
          (pAce->Header.AceFlags == 0) &&
          (pAce->Header.AceSize == (USHORT)(sizeof(ACE_HEADER)+
                                   sizeof(ACCESS_MASK) +
                                   0 /* BUGBUG GetLengthSid((PSID)dwParms[3])*/ )) &&
          (pAce->Mask == dwParms[2]))  {

         ValPrintf(hConOut, "AddAccessDeniedAceValidate: Success!!\n");
      }
      else
         ErrorPrint(hConOut,hLog,"AddAccessDeniedAceValidate",1,"Failure\n");
    } // end if dwRetVAl
  } // end if ParmGoodBad

  //
  //  check to see if the API returned TRUE even when bad parameters were
  //  specified.
  //

  else {
    if((BOOL)dwRetVal == TRUE) {
         ErrorPrint(hConOut,hLog,"AddAccessDeniedAceValidate",1,"Failure\n");
    }
  }

  VarInfo;		// -W3 warning elimination
}


/*********************************************************************/

void AddAuditAccessAceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  //
  // The AddAuditAccessAce API accepts the following parameters
  //
  // dwParms[0] = PACL  pAcl           supplies ACL being modified
  // dwParms[1] = DWORD dwAceRevision  ACE revision number
  // dwParms[2] = DWORD dwAccessMask   Mask of accesses to be granted to
  //                                   the specified SID
  // dwParms[3] = PSID  pSid           Pointer to the SID being granted
  //                                   access.
  // dwParms[4] = BOOL  bAuditSuccess  if TRUE indicates successful access
  //                                   attempts are to be audited
  // dwParms[5] = BOOL  bAuditFailure  if TRUE indicates failed access attempts
  //                                   are to be audited
  //

  PSYSTEM_AUDIT_ACE pAce;
  PACL              pAcl = (PACL)dwParms[0];
  PVOID             pAcePosition;
  USHORT             i;
  UCHAR	            AuditFlags=0;

  //
  // do the validation only if all the parameters to the API are valid
  //

  if((ParmGoodBad[0] == CLOPT_GOOD) &&
     (ParmGoodBad[1] == CLOPT_GOOD) &&
     (ParmGoodBad[2] == CLOPT_GOOD) &&
     (ParmGoodBad[3] == CLOPT_GOOD) &&
     (ParmGoodBad[4] == CLOPT_GOOD) &&
     (ParmGoodBad[5] == CLOPT_GOOD))   {

    //
    // Check to see if the API call succeeded
    //

    if((BOOL)dwRetVal == TRUE) {


      //
      // get the first ace address
      //

      pAcePosition = (PVOID)((PUCHAR)(pAcl) + sizeof(ACL));

      //
      // locate the position where the SystemAuditAce was added
      //

      for (i = 0; i < (USHORT)(pAcl->AceCount - 1); i++) {
          pAcePosition = (PVOID)((PUCHAR)pAcePosition +
                        (((PACE_HEADER)pAcePosition)->AceSize));
      }

      // set the flags

      if(dwParms[4] == (BOOL)TRUE) {
        AuditFlags |= SUCCESSFUL_ACCESS_ACE_FLAG;
      }

      if(dwParms[5] == (BOOL)TRUE) {
        AuditFlags |= FAILED_ACCESS_ACE_FLAG;
      }


      //
      // check to see if the ACE was indeed added here
      //

      pAce = (PSYSTEM_AUDIT_ACE)pAcePosition;

      if( (pAce->Header.AceType == SYSTEM_AUDIT_ACE_TYPE) &&
          (pAce->Header.AceFlags == AuditFlags) &&
          (pAce->Header.AceSize == (USHORT)(sizeof(ACE_HEADER)+
                                   sizeof(ACCESS_MASK) +
                                   0 /* GetLengthSid((PSID)dwParms[3])*/ )) &&
          (pAce->Mask == dwParms[2]))  {

         ValPrintf(hConOut, "AddAuditAccessAceValidate: Success!!\n");
      }
      else
         ErrorPrint(hConOut,hLog,"AddAuditAccessValidate",1,"Failure\n");
    } // end if dwRetVAl
  } // end if ParmGoodBad

  //
  // check to see if the API returned TRUE even when bad parameters were
  // specified.
  //

  else {
    if((BOOL)dwRetVal == TRUE) {
         ErrorPrint(hConOut,hLog,"AddAuditAccessValidate",1,
                    "BadParms but API returned Success\n");
    }
  }

  VarInfo;		// -W3 warning elimination
}

/******************************************************/

void AddAceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  //
  // The AddAce API accepts the following parameters
  //
  // dwParms[0] = PACL  pAcl           pointer to ACL
  // dwParms[1] = DWORD dwAceRevision  ACE revision number
  // dwParms[2] = DWORD dwAceindex     where to insert ACE list
  // dwParms[3] = PVOID pAceList       list of aces
  // dwParms[4] = DWORD dwAceListLen   length of ace list
  //

  PVOID  pAcePosition, Ace;
  ULONG  i, AceCount;
  PACL   pAcl = (PACL)dwParms[0];

  //
  // do the validation only if all the parameters to the API are valid
  //

  if((ParmGoodBad[0] == CLOPT_GOOD) &&
     (ParmGoodBad[1] == CLOPT_GOOD) &&
     (ParmGoodBad[2] == CLOPT_GOOD) &&
     (ParmGoodBad[3] == CLOPT_GOOD) &&
     (ParmGoodBad[4] == CLOPT_GOOD))   {

    //
    // Check to see if the API call succeeded
    //

    if((BOOL)dwRetVal == TRUE) {

      //
      // get the first ace address
      //

      pAcePosition = (PVOID)((PUCHAR)(pAcl) + sizeof(ACL));

      //
      // if the AceIndex is specified as any value other than zero,
      // we will have to figure out where the AceList was inserted
      // (depending on the number of aces added).
      // We will do this by going down the list of Aces and finding
      // out how many aces were added. We then use that value to
      // decrement our notion of the number of Aces before the
      // AddAce API was invoked.
      //

      Ace = (PVOID)dwParms[3];
      AceCount = pAcl->AceCount;

      if(dwParms[2]) {
        for (i = 0; Ace < (PVOID)((PUCHAR)dwParms[3]+dwParms[4]) ; i++)
             Ace = (PVOID)((PUCHAR)Ace + ((PACE_HEADER)Ace)->AceSize);

        //
        // Decrement the AceCount by this number
        //

        AceCount -= i;
      }


      //
      // locate the position where the Acelist was inserted
      //

      for (i = 0; i < dwParms[2] && i < AceCount ; i++) {

          pAcePosition = (PVOID)((PUCHAR)pAcePosition +
                        (((PACE_HEADER)pAcePosition)->AceSize));
      }

      //
      // check to see if the ACEs were indeed inserted here
      //

      if(!memcmp(pAcePosition, (PVOID)dwParms[3], dwParms[4]))
         ValPrintf(hConOut, "AddAceValidate: Success!!\n");
      else
         ErrorPrint(hConOut,hLog,"AddAceValidate",1,"Failure\n");
    }

  }

  VarInfo;		// -W3 warning elimination
}


/******************************************************/

void AddAliasValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AddAtomAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AddAtomWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AddFontModuleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AddFontResourceAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AddFontResourceWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AddFontResourceExAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AddFontResourceExWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AddFontMemResourceExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}



/******************************************************/

void AdjustWindowRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AdjustWindowRectExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AllocConsoleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AngleArcValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AnimatePaletteValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AnyPopupValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AppendMenuAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void AppendMenuWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void ArcValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void ArcToValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void ArrangeIconicWindowsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\g_valid.c ===
/*************************************************************************
MODULE: G_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Modification History:

        2-20-92  RamC  Added validate routines for AddAce and
                       AddAccessAllowedAce
                       Added include files parsedef.h and security.h

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'G'.
For more information, please refer to BadMan.Doc.
*************************************************************************/


#include <BadMan.h>
#include <Validate.h>
#include <parsedef.h>

void GetGuiResourcesValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    ValPrintf(hConOut, "GetGuiResources: No Validation done - just bad param testing - so always pass!!\r\n");
}

/******************************************************/

void GetKeyboardTypeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    switch(dwParms[0])
    {
        case 1:
        {
            // 0 is now considered acceptable - doc bug 181612
            if(dwRetVal>=0 && dwRetVal<8)
            {
                ValPrintf(hConOut, "GetKeyboardTypeValidate: Success!!\r\n");
            }
            else
            {
                ErrorPrint(hConOut,hLog,"GetKeyboardTypeValidate",1,"Failure\r\n");
            }
        }
        case 2:
        {
            // valid numbers between 1 and 7
            if(dwRetVal>0 && dwRetVal<8)
            {
                ValPrintf(hConOut, "GetKeyboardTypeValidate: Success!!\r\n");
            }
            else
            {
                ErrorPrint(hConOut,hLog,"GetKeyboardTypeValidate",1,"Failure\r\n");
            }
        }
        default:
        {
            // should return 0 for error and non-zero for success
            if(dwRetVal!=0)
            {
                ValPrintf(hConOut, "GetKeyboardTypeValidate: Success!!\r\n");
            }
            else
            {
                ErrorPrint(hConOut,hLog,"GetKeyboardTypeValidate",1,"Failure\r\n");
            }
        }

    }
}

/******************************************************/

void GetKBCodePageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}

/******************************************************/

void GdiFlushValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GdiSetBatchLimitValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}



/******************************************************/

void GetAceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  //
  // The GetAce API accepts the following parameters
  // 
  // dwParms[0] = PACL  pAcl           pointer to ACL
  // dwParms[1] = DWORD dwAceindex     index indicate which Ace within the
  //                                   ACL to return
  // dwParms[2] = PVOID *pAce          pointer to variable to recieve the
  //                                   address of ACE stored in ACL 
  // 

  PACL        pAcl = (PACL)dwParms[0];
  ULONG       i;
  PACE_HEADER pA, pB; 
  
  //
  // do the validation only if all the parameters to the API are valid
  //

  if((ParmGoodBad[0] == CLOPT_GOOD) &&
     (ParmGoodBad[1] == CLOPT_GOOD) &&
     (ParmGoodBad[2] == CLOPT_GOOD))   {
  
    //
    // Check to see if the API call succeeded
    //

    if((BOOL)dwRetVal == TRUE) {

      //
      // get the first ace address
      //

      pB = (ACE_HEADER *)((PUCHAR)(pAcl) + sizeof(ACL));
  
      //
      // locate the position of the Ace 
      //

      for (i = 0; i < dwParms[1] ; i++) {
         pB = (ACE_HEADER *)((PUCHAR)pB + pB->AceSize);
      }
 
      //
      // this is what we got back from GetAce
      // 

      pA = (PACE_HEADER) * ((PVOID *) dwParms[2]);

      //
      // check to see if we got the correct ACE 
      //

      if ((pA->AceType == pB->AceType) &&
          (pA->AceSize == pB->AceSize) &&
          (pA->AceFlags == pB->AceFlags))  
         ValPrintf(hConOut, "GetAceValidate: Success!!\n");
      else
         ErrorPrint(hConOut,hLog,"GetAceValidate",1,"Failure\n");
    }

  }

  VarInfo;	// -W3 warning elimination
}

/******************************************************/

void GetAclInformationValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  if((ParmGoodBad[0] == CLOPT_GOOD) &&
     (ParmGoodBad[1] == CLOPT_GOOD) &&
     (ParmGoodBad[2] == CLOPT_GOOD) &&
     (ParmGoodBad[3] == CLOPT_GOOD))  {
    if(dwParms[3] == AclRevisionInformation) {
       if(((PACL_REVISION_INFORMATION)dwParms[1]) -> AclRevision == ACL_REVISION)
          ValPrintf(hConOut,"GetAclInformationValidate: Success!!\n");
       else
			    // Modified to correct # of parms (JohnMil)
	  ErrorPrint(hConOut,hLog,"GetAclInformationValidate:",0,"Failure\n");
    }
    else { // this is a size information request
        // not much we can test here
    }
  }

  VarInfo;	// -W3 warning elimination
  dwRetVal;	// -W3 warning elimination
}


/******************************************************/

void GetActiveWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetAliasValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetArcDirectionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
                        HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetAspectRatioFilterExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}

/******************************************************/

void GetAsyncKeyStateValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetAtomNameAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetAtomNameWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetBitmapBitsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetBitmapDimensionExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetBkColorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetBkModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetBrushOrgExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCaptureValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCaretBlinkTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCaretPosValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCharTypeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCharWidthAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCharWidthWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetClassInfoAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetClassInfoWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetClassLongValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetClassNameAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetClassNameWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetClassWordValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetClientRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetClipBoxValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetClipCursorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetClipboardDataValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetClipboardFormatNameAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetClipboardFormatNameWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetClipboardOwnerValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetClipboardViewerValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetColorAdjustmentValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void GetColorSpaceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void GetCommConfigValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCommMaskValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCommStateValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCommTimeoutsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCommandLineAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCommandLineWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetConsoleCurrentFontValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetConsoleCursorInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetConsoleFontInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetConsoleFontSizeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetConsoleModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetConsoleNumberOfFontsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetConsoleNumberOfInputEventsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetConsoleNumberOfMouseButtonsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetConsoleScreenBufferInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetConsoleTitleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetContextThreadValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCurrentDirectoryAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCurrentDirectoryWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCurrentObjectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCurrentPositionExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCurrentProcessValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCurrentProcessIdValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCurrentThreadValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCurrentThreadIdValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCurrentTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCursorPosValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDCBrushColorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteDC((HDC)dwRetVal);

	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDCPenColorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteDC((HDC)dwRetVal);

	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDCValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteDC((HDC)dwRetVal);

	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDCExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if (dwRetVal)
        ;//BUGBUG DeleteDC((HDC)dwRetVal);

	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDCOrgExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	if (dwRetVal)
        	;//BUGBUG DeleteDC((HDC)dwRetVal);

	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDIBitsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDesktopAttrsAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDesktopAttrsWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDesktopTypesAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDesktopTypesWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDesktopWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDeviceCapsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}

/******************************************************/

void GetDeviceGammaRampValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void GetDialogBaseUnitsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDIBColorTableValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDiskFreeSpaceAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDiskFreeSpaceWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDlgCtrlIDValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDlgItemValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDlgItemIntValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDlgItemTextAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDlgItemTextWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDoubleClickTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDriveTypeAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetDriveTypeWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetEnhMetaFileAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetEnhMetaFileWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetEnvironmentStringsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetEnvironmentVariableAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetEnvironmentVariableWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetExitCodeProcessValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetExitCodeThreadValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetFileAttributesAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetFileAttributesWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetFileSizeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetFileTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetFileTypeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetFocusValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetFontMapperControlsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetFullPathNameAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetFullPathNameWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetGraphicsModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetIconInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetInputDesktopValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetInputStateValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetKeyNameTextAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetKeyNameTextWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetKeyStateValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetKeyboardStateValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetLastActivePopupValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetLastErrorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetLocaleInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}
/******************************************************/

void GetICMProfileAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void GetICMProfileWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void GetLogColorSpaceAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void GetLogColorSpaceWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}




/******************************************************/

void GetLogicalDriveStringsAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetLogicalDriveStringsWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetLogicalDrivesValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMailslotInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMapModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMenuValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMenuCheckMarkDimensionsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMenuItemCountValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMenuItemIDValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMenuStateValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMenuStringAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMenuStringWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMessageExtraInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMessagePosValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMessageTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMetaFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetMetaFileBitsExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetModuleFileNameAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetModuleFileNameWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetModuleHandleAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetModuleHandleWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetNamedPipeHandleStateAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetNamedPipeHandleStateWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetNamedPipeInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetNearestColorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetNearestPaletteIndexValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetNextDlgGroupItemValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetNextDlgTabItemValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetNextLocaleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetObjectAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetObjectSecurityValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetObjectTypeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetObjectWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetOverlappedResultValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetPaletteEntriesValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetParentValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetPathValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetPixelValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetPolyFillModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetPriorityClipboardFormatValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetPriorityThreadValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetPrivateProfileIntAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetPrivateProfileIntWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetPrivateProfileSectionAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetPrivateProfileSectionWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetPrivateProfileStringAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetPrivateProfileStringWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetProcAddressValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetProcessWindowStationValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetProfileIntAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetProfileIntWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetProfileSectionAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetProfileSectionWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetProfileStringAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetProfileStringWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetPropAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetPropWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetQualifiedLocaleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetQueueStatusValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetROP2Validate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetRgnBoxValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetScrollPosValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetScrollRangeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetSidIdentifierAuthorityValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  // point to opaque SID datastructure

  PISID piSid = (PISID)dwParms[0];
  PSID_IDENTIFIER_AUTHORITY pSidAuthority = (PSID_IDENTIFIER_AUTHORITY)dwRetVal;

  if(ParmGoodBad[0] == CLOPT_GOOD) {
   if((piSid->IdentifierAuthority.Value[0] == pSidAuthority->Value[0]) && 
      (piSid->IdentifierAuthority.Value[1] == pSidAuthority->Value[1]) && 
      (piSid->IdentifierAuthority.Value[2] == pSidAuthority->Value[2]) && 
      (piSid->IdentifierAuthority.Value[3] == pSidAuthority->Value[3]) && 
      (piSid->IdentifierAuthority.Value[4] == pSidAuthority->Value[4]) && 
      (piSid->IdentifierAuthority.Value[5] == pSidAuthority->Value[5]))
    ErrorPrint(hConOut, hLog,"GetSidIdentiferAuthorityValidate",1,"Success!!");
   else 
    ErrorPrint(hConOut, hLog,"GetSidIdentiferAuthorityValidate",1,"Failure");
  }

  VarInfo;	// -W3 warning elimination
}


/******************************************************/

void GetLengthSidValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  /* The default SID created is with one sub-authority and this length
     is equal to the size of the SID datastructure.
  */

  if(ParmGoodBad[0] == CLOPT_GOOD) {
    if(dwRetVal == sizeof(SID))
      ErrorPrint(hConOut, hLog,"GetLengthSidValidate",1,"Success!!");
    else
      ErrorPrint(hConOut, hLog,"GetLengthSidValidate",1,"Failure");
  }

  VarInfo;	// -W3 warning elimination
  dwParms;	// -W3 warning elimination
}


/******************************************************/

void GetSidLengthRequiredValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  /* calculate actual length required for a SID
     and compare against returned value

     the calculation is based on the fact that

     size of SID with 1 SubAuthority	 = sizeof(SID)
     size of SID with 2 SubAuthorities = sizeof(SID) + (2-1) * sizeof(ULONG)
     size of SID with 3 SubAuthorities = sizeof(SID) + (3-1) * sizeof(ULONG)
     and so on.
     Each subauthority takes up the size of a ULONG in the SID array

     This is dependent on the fact that ANYSIZE_ARRAY used in the
     definition of SID is 1.	If this value changes in the future,
     our assumptions here will not be valid anymore.

  */

  if(ParmGoodBad[0] == CLOPT_GOOD) {
    if(dwRetVal == (sizeof(SID) + ((dwParms[0]-1) * sizeof(ULONG))))
      ErrorPrint(hConOut, hLog,"GetSidLengthRequiredValidate",1,"Success!!");
    else
      ErrorPrint(hConOut, hLog,"GetSidLengthRequiredValidate",1,"Failure");
  }

  VarInfo;	// -W3 warning elimination
}


/******************************************************/

void GetSidSubAuthorityValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  PISID piSid = (PISID)dwParms[0];

  if(ParmGoodBad[0] == CLOPT_GOOD && ParmGoodBad[1] == CLOPT_GOOD) {
     if(piSid->SubAuthority[dwParms[1]] == *((PULONG)dwRetVal))
      ErrorPrint(hConOut, hLog,"GetSidSubAuthorityValidate",1,"Success!!");
    else
      ErrorPrint(hConOut, hLog,"GetSidSubAuthorityValidate",1,"Failure");
  }

  VarInfo;	// -W3 warning elimination
}


/******************************************************/

void GetSidSubAuthorityCountValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  PISID piSid = (PISID)dwParms[0];

  if(ParmGoodBad[0] == CLOPT_GOOD) {
     if(piSid->SubAuthorityCount == *((PUCHAR)dwRetVal))
      ErrorPrint(hConOut, hLog,"GetSidSubAuthorityCountValidate",1,"Success!!");
    else
      ErrorPrint(hConOut, hLog,"GetSidSubAuthorityCountValidate",1,"Failure");
  }

  VarInfo;	// -W3 warning elimination
}


/******************************************************/

void GetStartupInfoAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetStartupInfoWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetStdHandleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetStockObjectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetStretchBltModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetSubMenuValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetSysColorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetSysInputModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetSystemDirectoryAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetSystemDirectoryWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetSystemInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetSystemMenuValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetSystemMetricsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetSystemPaletteEntriesValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetSystemPaletteUseValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetSystemTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTabbedTextExtentAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTabbedTextExtentWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTempFileNameAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTempFileNameWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTempPathAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTempPathWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTextAlignValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTextCharacterExtraValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTextColorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTextExtentPointAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTextExtentPointWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTextFaceAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTextFaceWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTextMetricsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTextMetricsWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetThreadDesktopValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetThreadSelectorEntryValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetThresholdEventValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetThresholdStatusValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTickCountValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTokenInformationValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  /*
   * The GetTokenInformation API accepts the following parameters
   * 
   * dwParms[0] = HANDLE TokenHandle
   * dwParms[1] = TOKEN_INFORMATION_CLASS TokenInformationClass
   * dwParms[2] = PVOID TokenInformation
   * dwParms[3] = ULONG TokenInformationLength 
   * dwParms[4] = PULONG ReturnLength 
   */
  
   PSID pSid;
   PACL pAcl;

  /*
   * do the validation only if all the parameters to the API are valid
   */

  if((ParmGoodBad[0] == CLOPT_GOOD) &&
     (ParmGoodBad[1] == CLOPT_GOOD) &&
     (ParmGoodBad[2] == CLOPT_GOOD) &&
     (ParmGoodBad[3] == CLOPT_GOOD) &&
     (ParmGoodBad[4] == CLOPT_GOOD))   {
  
    /*
     * Check to see if the API call succeeded
     */

    if((BOOL)dwRetVal == TRUE) {
      switch((TOKEN_INFORMATION_CLASS)dwParms[1]) {
        case TokenUser:
          pSid = (PSID) ((PTOKEN_USER)(PVOID *)dwParms[2])->User.Sid;

          //BUGBUG 
          //if(!IsValidSid(pSid))
            //ValPrintf(hConOut,"GetTokenInformationValidate Failure\n");
          //else
            ValPrintf(hConOut,"GetTokenInformationValidate Success!!\n");
          break;
        case TokenGroups:
          pSid = (PSID) ((PTOKEN_GROUPS)(PVOID *)dwParms[2])->Groups[0].Sid;

          //BUGBUG
          //if(!IsValidSid(pSid))
            //ValPrintf(hConOut,"GetTokenInformationValidate Failure\n");
          //else
            ValPrintf(hConOut,"GetTokenInformationValidate Success!!\n");
          break;
        case TokenOwner:
          pSid = (PSID) ((PTOKEN_OWNER)(PVOID *)dwParms[2])->Owner;

          //BUGBUG
          //if(!IsValidSid(pSid))
            //ValPrintf(hConOut,"GetTokenInformationValidate Failure\n");
          //else
            ValPrintf(hConOut,"GetTokenInformationValidate Success!!\n");
          break;
        case TokenPrimaryGroup:
          pSid = (PSID) 
                 ((PTOKEN_PRIMARY_GROUP)(PVOID *)dwParms[2])->PrimaryGroup;

          //BUGBUG
          //if(!IsValidSid(pSid))
            //ValPrintf(hConOut,"GetTokenInformationValidate Failure\n");
          //else
            ValPrintf(hConOut,"GetTokenInformationValidate Success!!\n");
          break;
        case TokenDefaultDacl:
          pAcl = (PACL) 
                 ((PTOKEN_DEFAULT_DACL)(PVOID *)dwParms[2])->DefaultDacl;

          if(pAcl)
            //BUGBUG
            //if(!IsValidAcl(pAcl))
              //ValPrintf(hConOut,"GetTokenInformationValidate Failure\n");
            //else
              ValPrintf(hConOut,"GetTokenInformationValidate Success!!\n");
          else
              ValPrintf(hConOut,"GetTokenInformationValidate NullDACL\n");
          break;
        case TokenPrivileges:
        case TokenSource:
        case TokenType:
        case TokenImpersonationLevel:
        case TokenStatistics:
          ValPrintf(hConOut,"GetTokenInformationValidate NOTIMPLEMENTED\n");
          break;
        default:
            ValPrintf(hConOut,"GetTokenInformationValidate Unknown Case\n");
          break;
      } // end switch
    } // end if dwRetVal
  } // end if valid params

  VarInfo;	// -W3 warning elimination
  hLog;		// -W3 warning elimination
}

/******************************************************/

void GetTopWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetUpdateRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetUpdateRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetVersionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetViewportExtExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetViewportOrgExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetVolumeInformationAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetVolumeInformationWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowDCValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowExtExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowLongValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowOrgExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowStationAttrsAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowStationAttrsWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowTextAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowTextLengthValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowTextWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowThreadProcessIdValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowWordValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowsDirectoryAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWindowsDirectoryWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetWorldTransformValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalAddAtomAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalAddAtomWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalAllocValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalDeleteAtomValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalFindAtomAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalFindAtomWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalFlagsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalFreeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalGetAtomNameAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalGetAtomNameWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalLockValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalMemoryStatusValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalReAllocValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalSizeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GlobalUnlockValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GrayStringAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}
/******************************************************/

void GrayStringWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}

/******************************************************/

void GetFontLanguageInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCharWidthIValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetCharABCWidthsIValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTextExtentPointIValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetTextExtentExPointIValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetFontUnicodeRangesValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void GetGlyphIndicesAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}

/******************************************************/

void GetGlyphIndicesWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}



/******************************************************/

void GetFontAssocStatus(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\e_valid.c ===
/*************************************************************************
MODULE: E_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'E'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>
#include <parsedef.h>

/******************************************************/

void EllipseValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EmptyClipboardValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnableCommNotificationValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnableHardwareInputValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnableMenuItemValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnableWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EndDeferWindowPosValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EndDialogValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EndDocValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EndEnumLocaleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EndPageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EndPaintValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EndPathValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnterCriticalSectionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumChildWindowsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumClipboardFormatsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumDesktopsAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumDesktopsWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumDisplayDevicesAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumDisplayDevicesWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumFontFamiliesExAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumFontFamiliesExWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumFontsAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumFontsWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumMetaFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumICMProfilesAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumICMProfilesWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumNearestFontsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumObjectsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumPropsAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumPropsExAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumPropsExWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumPropsWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumResourceNamesAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumResourceNamesWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumResourceTypesAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumResourceTypesWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumThreadWindowsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumWindowStationsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EnumWindowsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EqualRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EqualRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void EqualSidValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  DWORD dwSidLen;

  // validate only if the parameters are valid 

  if((ParmGoodBad[0] == CLOPT_GOOD) && 
     (ParmGoodBad[1] == CLOPT_GOOD))  {

     dwSidLen = 0;//BUGBUG GetLengthSid((PSID)dwParms[0]);

     //
     // check to see if the API was successful
     //

     if(dwRetVal == (BOOL)TRUE) {
        if(memcmp((PSID)dwParms[0], (PSID)dwParms[1], dwSidLen))
	   ErrorPrint(hConOut,hLog,"EqualSidValidate",1, "Failed");
        else 
	   ErrorPrint(hConOut,hLog,"EqualSidValidate",1, "Success!!");
     } // end if dwRetVal
  } // end if ParmGoodBad

  // 
  // check to see if the API returned success even when 
  // bad parameters were passed

  else if(dwRetVal == (BOOL)TRUE) {
      ErrorPrint(hConOut,hLog,"EqualSidValidate",1, 
                 "API returned success with bad parameters- Failed");
  }
}

/******************************************************/

void EscapeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void EscapeCommFunctionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ExcludeClipRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ExcludeUpdateRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ExitProcessValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ExitThreadValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ExitWindowsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ExtCreateFontIndirectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ExtCreateFontIndirectWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ExtDeviceModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ExtFloodFillValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ExtTextOutAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ExtTextOutWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ExtendedProviderFunctionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\h_valid.c ===
/*************************************************************************
MODULE: H_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'H'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>


/******************************************************/

void HeapAllocValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void HeapCreateValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void HeapDestroyValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void HeapFreeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void HeapSizeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void HideCaretValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void HiliteMenuItemValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\local.h ===
/*********************************************
MODULE: Local.h
AUTHOR: JohnMil
DATE:	3-16-92

This file contains temporary case names and definitions for
BadMan, to be used on a machine-by-machine basis. This file should
NEVER be checked in.

For more information, see badman\src\setclean\Local.C.
**********************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\i_valid.c ===
/*************************************************************************
MODULE: I_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'I'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>
#include <parsedef.h>

/******************************************************/

void InSendMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void InflateRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void InitAtomTableValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void InitializeAclValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
   PACL pAcl = (PACL)dwParms[0];

   if((ParmGoodBad[0] == CLOPT_GOOD) &&
      (ParmGoodBad[1] == CLOPT_GOOD) &&
      (ParmGoodBad[2] == CLOPT_GOOD)) {

      // Verify ACL creation

      if((pAcl->AclRevision == ACL_REVISION)  &&
	 (pAcl->AclSize == dwParms[1]))
	 ErrorPrint(hConOut, hLog,"InitializeAclValidate",1,"Success!!");
      else

	 ErrorPrint(hConOut, hLog,"InitializeAclValidate",1,"Failure");
   }
}
/******************************************************/

void InitializeCriticalSectionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void InitializeSidValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
     // point to Opaque SID datastructure

     PISID piSid = (PISID)dwParms[0];
     PSID_IDENTIFIER_AUTHORITY pSidAuthority = (PSID_IDENTIFIER_AUTHORITY)
					       dwParms[1];
     /*++

	Let us verify the SID initialization

	The SID structure is defined in ntseapi.h as

	typedef struct _SID {
	    UCHAR Revision;
	    UCHAR SubAuthorityCount;
	    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
	    ULONG SubAuthority[ANYSIZE_ARRAY];
	} SID, *PISID;

	and the SID_IDENTIFIER_AUTHORITY structure as

	typedef struct _SID_IDENTIFIER_AUTHORITY {
	    UCHAR Value[6];
	} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;

	We will use a pointer to the opaque datastructure to
	verify if the Revision number,Subauthority count and
	Identifier authority are initialized properly.

     --*/
   // check to see if the parameters are good 

   if((ParmGoodBad[0] == CLOPT_GOOD) &&
      (ParmGoodBad[1] == CLOPT_GOOD) &&
      (ParmGoodBad[2] == CLOPT_GOOD))	{

      if((piSid->Revision == SID_REVISION)	  &&  // default revision
	(piSid->SubAuthorityCount == (ULONG)dwParms[2])  &&  // check SA count
	(piSid->IdentifierAuthority.Value[0] ==       // check Identifier
	 pSidAuthority->Value[0])		  &&  // authority value
	(piSid->IdentifierAuthority.Value[1] ==
	 pSidAuthority->Value[1])		  &&
	(piSid->IdentifierAuthority.Value[2] ==
	 pSidAuthority->Value[2])		  &&
	(piSid->IdentifierAuthority.Value[3] ==
	 pSidAuthority->Value[3])		  &&
	(piSid->IdentifierAuthority.Value[4] ==
	 pSidAuthority->Value[4])		  &&
	(piSid->IdentifierAuthority.Value[5] ==
	 pSidAuthority->Value[5]))
       ErrorPrint(hConOut,hLog,"InitializeSidValidate",1, "Success!!");
     else
       ErrorPrint(hConOut,hLog,"InitializeSidValidate",1, "Failure");
   }

}



/******************************************************/

void InsertMenuAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void InsertMenuWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IntersectClipRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IntersectRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void InvalidateConsoleDIBitsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void InvalidateRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void InvalidateRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void InvertRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void InvertRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsCharAlphaAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsCharAlphaNumericAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsCharAlphaNumericWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsCharAlphaWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsCharLowerAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsCharLowerWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsCharUpperAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsCharUpperWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsChildValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsClipboardFormatAvailableValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsDialogMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsDlgButtonCheckedValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsIconicValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsRectEmptyValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsTwoByteCharPrefixValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void IsValidAclValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
   if(ParmGoodBad[0] == CLOPT_GOOD) {

      // Verify ACL creation

      if(((PACL)dwParms[0]) -> AclRevision == ACL_REVISION)
	ErrorPrint(hConOut, hLog,"IsValidAclValidate",1,"Success!!");
      else

	ErrorPrint(hConOut, hLog,"IsValidAclValidate",1,"Failure");
   }
}


/******************************************************/

void IsValidSidValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
   if(ParmGoodBad[0] == CLOPT_GOOD) {
      // note that here we are accessing the Opaque SID structure PISID
      if(((PISID)dwParms[0]) -> Revision == SID_REVISION)
	ErrorPrint(hConOut, hLog,"IsValidSidValidate",1,"Success!!");
      else
	ErrorPrint(hConOut, hLog,"IsValidSidValidate",1,"Failure");
   }
}


/******************************************************/

void IsWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsWindowEnabledValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsWindowVisibleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void IsZoomedValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void InternalExtractIconListAValidate(DefineType VarInfo[],DWORD dwParms[],
                        int ParmGoodBad[],DWORD dwRetVal,
                        HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void InternalExtractIconListWValidate(DefineType VarInfo[],DWORD dwParms[],
                        int ParmGoodBad[],DWORD dwRetVal,
                        HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\j_valid.c ===
/*************************************************************************
MODULE: J_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'J'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\k_valid.c ===
/*************************************************************************
MODULE: K_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'K'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>


/******************************************************/

void KillTimerValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\l_valid.c ===
/*************************************************************************
MODULE: L_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'L'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>

void LoadImageWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    ValPrintf(hConOut, "LoadImageW: No Validation done - just bad param testing - so always pass!!\r\n");
}

void LoadImageAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    ValPrintf(hConOut, "LoadImageA: No Validation done - just bad param testing - so always pass!!\r\n");
}

/*
 * Validation for LookupPrivilegeDisplayNameA
 */

VOID
LookupPrivilegeDisplayNameAValidate(
	DefineType		*VarInfo,
	DWORD			*dwParms,
	int			*ParmGoodBad,
	DWORD			dwRetVal,
	HANDLE			hLog,
	HANDLE			hConOut
)
{

}


/*
 * Validation for LookupPrivilegeNameA()
 */

void
LookupPrivilegeNameAValidate(
	DefineType		*VarInfo,
	DWORD			*dwParms,
	int			*ParmGoodBad,
	DWORD			dwRetVal,
	HANDLE			hLog,
	HANDLE			hConOut
)
{

}


/*
 * Validation for LookupPrivilegeValueA
 */

void
LookupPrivilegeValueAValidate(
	DefineType		*VarInfo,
	DWORD			*dwParms,
	int			*ParmGoodBad,
	DWORD			dwRetVal,
	HANDLE			hLog,
	HANDLE			hConOut
)
{

}


/******************************************************/

void LPtoDPValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LeaveCriticalSectionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LineDDAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LineToValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadAcceleratorsAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadAcceleratorsWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadBitmapAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadBitmapWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadCursorAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadCursorWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadIconAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadIconWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadLibraryAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadLibraryWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadMenuAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadMenuIndirectAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadMenuIndirectWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadMenuWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadModuleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadResourceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadStringAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LoadStringWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LocalAllocValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LocalFlagsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LocalFreeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LocalInitValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LocalLockValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LocalReAllocValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LocalSizeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LocalUnlockValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LockFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LockResourceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LockWindowUpdateValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void LookupIconIdFromDirectoryValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void lstrcatValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void lstrcmpValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void lstrcmpiValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void lstrcpyValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}


/******************************************************/

void lstrlenValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
	VarInfo;	// -W3 warning elimination
	dwParms;	// -W3 warning elimination
	ParmGoodBad;	// -W3 warning elimination
	dwRetVal;	// -W3 warning elimination
	hLog;		// -W3 warning elimination
	hConOut;	// -W3 warning elimination
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\m_valid.c ===
/*************************************************************************
MODULE: M_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'M'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>


/******************************************************/

void MapDialogRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MapStringValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MapViewOfFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MapVirtualKeyValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MapWindowPointsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MaskBltValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MessageBeepValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MessageBoxAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MessageBoxWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ModifyMenuAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ModifyMenuWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ModifyWorldTransformValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MoveFileAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MoveFileWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MoveToExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MoveWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MsgWaitForMultipleObjectsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MulDivValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MultiByteToMultiByteValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void MultiByteToWideCharValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mciExecuteValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mciGetDeviceIDValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mciGetDeviceIDFromElementIDValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mciGetErrorStringValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mciSendCommandValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mciSendStringValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioAdvanceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioAscendValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioCloseValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioCreateChunkValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioDescendValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioFlushValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioGetInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioInstallIOProcValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioOpenValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioReadValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioSeekValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioSendMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioSetBufferValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioSetInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioStringToFOURCCValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void mmioWriteValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\o_valid.c ===
/*************************************************************************
MODULE: O_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'O'.
For more information, please refer to BadMan.Doc.
*************************************************************************/


#include <BadMan.h>
#include <Validate.h>
#include <parsedef.h>


/******************************************************/

void OemToCharAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OemToCharBuffAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OemToCharBuffWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OemToCharWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OffsetClipRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OffsetRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OffsetRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OffsetViewportOrgExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OffsetWindowOrgExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenClipboardValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenDesktopAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenDesktopWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenEventAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenEventLogAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenEventLogWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenEventWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenFileMappingAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenFileMappingWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenIconValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenLocaleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenMutexAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenMutexWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenProcessTokenValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  DWORD ret = 0, cbError;
  BOOL  bRet = FALSE;
  PUCHAR buffer;
  
  if((ParmGoodBad[0] == CLOPT_GOOD) &&
     (ParmGoodBad[1] == CLOPT_GOOD) &&
     (ParmGoodBad[2] == CLOPT_GOOD)) {
     
     // if the call to the API succeeded

     if((BOOL)dwRetVal) {
        buffer = malloc(256);
        if(!buffer) { 
          ValPrintf(hConOut,"Insufficient memory\n");
          return;
        }
        //BUGBUG bRet = GetTokenInformation((HANDLE) * ((PHANDLE)dwParms[2]), 
                                   //TokenOwner,
                                   //buffer,
                                   //256,
                                   //& ret);
        bRet = FALSE;
        if(!bRet) {
          cbError = GetLastError();
          ValPrintf(hConOut,"OpenProcessTokenValidate Failure %d\n", cbError);
        }
        else {
          ValPrintf(hConOut,"OpenProcessTokenValidate success!!\n");
          free(buffer);
        }
     } // end if dwRetVal
     else
        ValPrintf(hConOut,"OpenProcessToken API call failed\n");
  } // end if parm check
}


/******************************************************/

void OpenProcessValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenSemaphoreAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenSemaphoreWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenSoundValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenSystemFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenThreadTokenValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  DWORD ret = 0, cbError;
  BOOL  bRet = FALSE;
  PUCHAR buffer;
  
  if((ParmGoodBad[0] == CLOPT_GOOD) &&
     (ParmGoodBad[1] == CLOPT_GOOD) &&
     (ParmGoodBad[2] == CLOPT_GOOD)) {
     
     // if the call to the API succeeded

     if((BOOL)dwRetVal) {
        buffer = malloc(256);
        if(!buffer) { 
          ValPrintf(hConOut,"Insufficient memory\n");
          return;
        }
        bRet = FALSE;//BUGBUG GetTokenInformation((HANDLE) * ((PHANDLE)dwParms[2]), 
                                   //TokenOwner,
                                   //buffer,
                                   //256,
                                   //& ret);
        if(!bRet) {
          cbError = GetLastError();
          ValPrintf(hConOut,"OpenThreadTokenValidate Failure %d\n", cbError);
        }
        else {
          ValPrintf(hConOut,"OpenThreadTokenValidate success!!\n");
          free(buffer);
        }
     } // end if dwRetVal
     else
        ValPrintf(hConOut,"OpenThreadToken API call failed\n");
  } // end if parm check
}

/******************************************************/

void OpenWindowStationAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OpenWindowStationWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OutputDebugStringAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void OutputDebugStringWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\n_valid.c ===
/*************************************************************************
MODULE: N_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'N'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\p_valid.c ===
/*************************************************************************
MODULE: P_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'P'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>


/******************************************************/

void PaintRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PatBltValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PathToRegionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PeekConsoleInputValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PeekMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PeekNamedPipeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PieValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PlayEnhMetaFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PlayMetaFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PlayMetaFileRecordValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PlaySoundValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PlgBltValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PolyBezierValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PolyBezierToValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PolyPolygonValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PolyPolylineValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PolygonValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PolylineValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PolylineToValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PolyDrawValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PostMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PostQuitMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PostThreadMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ProfClearValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ProfFinishValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ProfFlushValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ProfInsChkValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ProfSampRateValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ProfSetupValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ProfStartValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ProfStopValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PtInRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PtInRegionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PtVisibleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PulseEventValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void PurgeCommValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\s_valid.c ===
/*************************************************************************
MODULE: S_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'S'.
For more information, please refer to BadMan.Doc.
*************************************************************************/

#include <BadMan.h>
#include <xlog.h>
#include <Validate.h>
#include <Parsedef.h>


/******************************************************/

void SetLastErrorExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
    if(dwParms[0]==GetLastError())
    {
	SetLastError(0);
        ValPrintf(hConOut, "SetLastErrorExValidate: Success!!\r\n");
    }
    else
    {
	SetLastError(0);
        ErrorPrint(hConOut,hLog,"SetLastErrorExValidate",1,"Failure\r\n");
    }
}

/******************************************************/

void SaveDCValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ScaleViewportExtExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ScaleWindowExtExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ScreenToClientValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ScrollConsoleScreenBufferValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ScrollDCValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ScrollWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ScrollWindowExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SearchPathAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SearchPathWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SelectClipPathValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SelectClipRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SelectObjectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SelectPaletteValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SendDlgItemMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


// SendMessage is a pain to validate, since it has such a wide
// variety of parameters. We will only attempt to validate if all
// parameters are "good" parameters.
// The validate functions for SendMessage, SendMessageCallback, and SendMessageTimeout
// will pass the msg, wp, and lp params for each call to MsgRetValidate.
void SendMessageAValidate(DefineType VarInfo[],DWORD dwParms[],
                          int ParmGoodBad[],DWORD dwRetVal,
                          HANDLE hLog,HANDLE hConOut)
{
}

void SendMessageWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
}


/******************************************************/

void SendMessageCallbackValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SendMessageTimeoutValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
/******************************************************/

void SendNotifyMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetAclInformationValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  PACL pAcl = (PACL)dwParms[0];

  if((ParmGoodBad[0] == CLOPT_GOOD) &&
     (ParmGoodBad[1] == CLOPT_GOOD) &&
     (ParmGoodBad[2] == CLOPT_GOOD) &&
     (ParmGoodBad[3] == CLOPT_GOOD))  {
       if(((PACL)dwParms[0]) -> AclRevision == ACL_REVISION)
	  ValPrintf(hConOut,"SetAclInformationValidate: Success!!\n");
       else
	  ErrorPrint(hConOut,hLog,"SetAclInformationValidate:",0,"Failure\n");
  }
}

/******************************************************/

void SetActiveWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetArcDirectionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetBitmapBitsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetBitmapDimensionExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetBkColorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetBkModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetBrushOrgValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetCaptureValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetCaretBlinkTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetCaretPosValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetClassLongValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetClassWordValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetClipboardDataValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetClipboardViewerValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetCommBreakValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetCommConfigValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetCommMaskValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetCommStateValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetCommTimeoutsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetConsoleActiveScreenBufferValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetConsoleCtrlHandlerValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetConsoleCursorInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetConsoleCursorPositionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetConsoleFontValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetConsoleMaximumWindowSizeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetConsoleModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetConsoleScreenBufferSizeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetConsoleTextAttributeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetConsoleTitleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetConsoleWindowInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetContextThreadValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetConvertHookValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetConvertParamsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetCurrentDirectoryAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetCurrentDirectoryWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetCursorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetCursorPosValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetDCBrushColorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetDCPenColorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetDIBitsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetDIBitsToDeviceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetDeskWallpaperValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetDlgItemIntValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetDlgItemTextAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetDlgItemTextWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetDoubleClickTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetEndOfFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetEnvironmentVariableAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetEnvironmentVariableWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetErrorModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetEventValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetFileAttributesAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetFileAttributesWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetFilePointerValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetFileTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetFlatnessValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetFocusValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetFontMapperControlsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetForegroundWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetHandleCountValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetKeyboardStateValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetLastErrorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetMailslotInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetMapModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetMapperFlagsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetMenuValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetMenuItemBitmapsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetMetaFileBitsExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetMiterLimitValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetNamedPipeHandleStateValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetObjectSecurityValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetPaletteEntriesValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetParentValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetPixelValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetPixelVValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetPolyFillModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetPriorityThreadValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetProcessWindowStationValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetPropAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetPropWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetROP2Validate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetRectEmptyValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetRectRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetScrollPosValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetScrollRangeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetSoundNoiseValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetStdHandleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetStretchBltModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetSysColorsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetSystemPaletteUseValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetSystemTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetTextAlignValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetTextCharacterExtraValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetTextColorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetTextJustificationValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetThreadDesktopValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetTimerValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetViewportExtExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetViewportOrgExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetVoiceAccentValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetVoiceEnvelopeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetVoiceNoteValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetVoiceQueueSizeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetVoiceSoundValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetVoiceThresholdValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetWindowExtExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetWindowLongValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetWindowOrgExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetWindowPosValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetWindowTextAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetWindowTextWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetWindowWordValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetWindowsHookAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetWindowsHookExAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetWindowsHookExWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetWindowsHookWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SetWorldTransformValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ShowCaretValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ShowCursorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ShowOwnedPopupsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ShowScrollBarValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ShowWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SizeofResourceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SleepValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void StartDocValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void StartPageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void StartSoundValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void StopSoundValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void StretchBltValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void StretchDIBitsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void StrokeAndFillPathValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void StrokePathValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SuspendThreadValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SwapMouseButtonValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SwitchDesktopValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SyncAllVoicesValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SystemParametersInfoValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void SystemTimeToFileTimeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
/******************************************************/

void SetICMProfileAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
/******************************************************/

void SetICMProfileWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
/******************************************************/

void SetDeviceGammaRampValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
/******************************************************/

void SetICMModeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
/******************************************************/

void SetColorAdjustmentValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void SetColorSpaceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
/******************************************************/

void ShellExecuteAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
DWORD dwError;
HWND  hwndOpen;

    dwError = GetLastError();
    if (dwError != ERROR_CALL_NOT_IMPLEMENTED)
        ValPrintf(hConOut,"ShellExecuteAValidate Failure %d\n", dwError);
}

/******************************************************/

void ShellExecuteWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
DWORD dwError;
    dwError = GetLastError();
    if (dwError != ERROR_CALL_NOT_IMPLEMENTED)
        ValPrintf(hConOut,"ShellExecuteWValidate Failure %d\n", dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\q_valid.c ===
/*************************************************************************
MODULE: Q_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'Q'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>


/******************************************************/

void QueryMapValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\t_valid.c ===
/*************************************************************************
MODULE: T_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'T'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>


/******************************************************/

void TabbedTextOutAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TabbedTextOutWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TerminateProcessValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TerminateThreadValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TextOutAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TextOutWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TlsAllocValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TlsFreeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TlsGetValueValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TlsSetValueValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TrackPopupMenuValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TransactNamedPipeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TranslateAcceleratorValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TranslateMDISysAccelValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TranslateMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void TransmitCommCharValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\r_valid.c ===
/*************************************************************************
MODULE: R_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'R'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>


/******************************************************/

void RaiseExceptionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ReadConsoleInputValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ReadConsoleOutputValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ReadConsoleOutputAttributeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ReadConsoleOutputCharacterValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ReadEventLogAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ReadEventLogWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ReadFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ReadMemoryProcessValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RealizePaletteValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RectInRegionValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RectVisibleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RectangleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RedrawWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RegisterClassAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RegisterClassWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RegisterClipboardFormatAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RegisterClipboardFormatWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RegisterHotKeyValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RegisterWindowMessageAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RegisterWindowMessageWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ReleaseCaptureValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ReleaseDCValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ReleaseMutexValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ReleaseSemaphoreValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RemoveDirectoryAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RemoveDirectoryWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RemoveFontModuleValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RemoveFontResourceValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RemoveFontResourceWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}



/******************************************************/

void RemoveFontResourceExAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RemoveFontResourceExWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RemoveFontMemResourceExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}



/******************************************************/

void RemoveMenuValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RemovePropAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RemovePropWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ReplyMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ResetDCAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ResetDCWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ResetEventValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ResizePaletteValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RestoreDCValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ResumeThreadValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void RoundRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\u_valid.c ===
/*************************************************************************
MODULE: U_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'U'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>


/******************************************************/

void UnhookWindowsHookValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void UnhookWindowsHookExValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void UnionRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void UnlockFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void UnmapViewOfFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void UnrealizeObjectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void UnregisterClassAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void UnregisterClassWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void UnregisterHotKeyValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void UpdateColorsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void UpdateWindowValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\validate.c ===
/*************************************************************************
Module: Validate.C
Author: JohnMil
Date:	2-10-92

Copyright (c) 1992 Microsoft Corporation

This file contains miscellaneous files for the use of the API return
code Validation functions.
*************************************************************************/
#include <setcln.h>
#include <stdarg.h>
#include <xlog.h>

/**************************************************************************
ValPrintf is a substitute for printf which will print to the console, since
the Validation functions are in a DLL and can't print to it normally
***************************************************************************/


int ValPrintf(HANDLE hConOut, char *Format, ...)
{
  char buff[512];
  va_list vaList;
  DWORD i;

  va_start(vaList,Format);
  i=vsprintf(buff,Format,vaList);
  va_end(vaList);

  return((int) WriteFile(hConOut,buff,i,&i,NULL));
}




/***************************************************************************
ErrorPrint is a standard format error printer which will print to the
screen and to the log file, if appropriate.
***************************************************************************/

void ErrorPrint(HANDLE hConOut,HANDLE hLog,char *Module,
		int CaseNo, char *Desc)
{
  if (hConOut != NULL) {
    ValPrintf(hConOut,"\nERROR: %s [Case %d] -- %s",Module,CaseNo,Desc);
    }

  if (hLog != NULL) {
    xLog(hLog,XLL_FAIL,"\nERROR: %s [Case %d] -- %s",Module,CaseNo,Desc);
    }

  return;
}


BOOL
WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD fdwReason,
    LPVOID lpvReserved
    )
{
    if ( DLL_PROCESS_ATTACH == fdwReason ) {
        DisableThreadLibraryCalls( hInstance );
    }

    UNREFERENCED_PARAMETER( lpvReserved );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\v_valid.c ===
/*************************************************************************
MODULE: V_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'V'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>


/******************************************************/

void ValidateRectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void ValidateRgnValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void VirtualAllocValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void VirtualFreeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void VirtualProtectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void VirtualQueryValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void VkKeyScanValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\x_valid.c ===
/*************************************************************************
MODULE: X_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'X'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\z_valid.c ===
/*************************************************************************
MODULE: Z_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'Z'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\__valid.c ===
/*************************************************************************
MODULE: [_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter '['.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>


/******************************************************/

void _abnormal_terminationValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void _exception_codeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void _lcloseValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void _lcreatValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void _llseekValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void _lopenValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void _lreadValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void _lwriteValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\w_valid.c ===
/*************************************************************************
MODULE: W_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'W'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>


/******************************************************/

void WaitCommEventValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WaitForDebugEventValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WaitForMultipleObjectsValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WaitForSingleObjectValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WaitMessageValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WaitNamedPipeAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WaitNamedPipeWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WaitSoundStateValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WideCharToMultiByteValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WidenPathValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WinExecValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WinHelpAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WinHelpWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WinMainValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WindowFromDCValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WindowFromPointValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WriteConsoleInputValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WriteConsoleOutputValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WriteConsoleOutputAttributeValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WriteConsoleOutputCharacterValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WriteEventLogEntryAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WriteEventLogEntryWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WriteFileValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WriteMemoryProcessValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WritePrivateProfileSectionAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WritePrivateProfileSectionWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WritePrivateProfileStringAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WritePrivateProfileStringWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WriteProfileSectionAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WriteProfileSectionWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WriteProfileStringAValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void WriteProfileStringWValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void wsprintfValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}


/******************************************************/

void wvsprintfValidate(DefineType VarInfo[],DWORD dwParms[],
			int ParmGoodBad[],DWORD dwRetVal,
			HANDLE hLog,HANDLE hConOut)
{
  ;
}

/******************************************************/

void WrapperForExecuteValidate(DefineType VarInfo[],DWORD dwParms[],
            int ParmGoodBad[],DWORD dwRetVal,
            HANDLE hLog,HANDLE hConOut
)
{
  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\badman\src\validate\y_valid.c ===
/*************************************************************************
MODULE: Y_Valid.C
AUTHOR: JohnMil
  DATE: 2-5-92

Copyright (c) 1992 Microsoft Corporation

This module contains API Return value Validation routines for API's
beginning with the letter 'Y'.
For more information, please refer to BadMan.Doc.
*************************************************************************/
#include <BadMan.h>


#include <Validate.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\codegen\codegen.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fw.cpp
 *  Content:    DirectSound test case framework file generator
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/10/01    danrose Created to generate dsound test framework
 *
 ****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <direct.h>

/****************************************************************************
 *
 * Globals to hild the Path, Directory and date
 *
 ****************************************************************************/

TCHAR* g_tszDir = NULL;
TCHAR g_tszPath[MAX_PATH];
TCHAR g_tszUser[32];
WORD g_wDate = 0;
WORD g_wMonth = 0;

/****************************************************************************
 *
 *  SetDirectory
 *
 *  Description:
 *      set the local directory and path for the app
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      TRUE on success
 *      FALSE on failure
 *
 ****************************************************************************/

BOOL SetDirectory( void )
{
	//
	// Allocate space for an index into the Path
	//

	DWORD dwIndex = 0;

	//
	// get the current directory, chekc for failure
	//

	if ( ! GetCurrentDirectory( MAX_PATH, g_tszPath ) )
		return FALSE;

	//
	// start index at end of path
	//


	dwIndex = _tcslen( g_tszPath ) - 1;

	//
	// Walk back down the path until just after a '\' is found
	//

	while ( '\\' != g_tszPath[dwIndex--] );

	//
	// Set the Directory to point ot the proper index in the path
	//

	g_tszDir = g_tszPath + dwIndex + 2;

	//
	// return success
	//

	return TRUE;
}

/****************************************************************************
 *
 *  SetUser
 *
 *  Description:
 *      set the user of the app
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      TRUE on success
 *      FALSE on failure
 *
 ****************************************************************************/

BOOL SetUser( void )
{
	return GetEnvironmentVariable( "USERNAME", g_tszUser, 32 );
}

/****************************************************************************
 *
 *  SetDate
 *
 *  Description:
 *      set the day of month for the app
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      TRUE on success
 *      FALSE on failure
 *
 ****************************************************************************/

BOOL SetDate( void )
{
	//
	// allocate a system time struct and init it
	//

	SYSTEMTIME sysTime;
	ZeroMemory( &sysTime, sizeof( SYSTEMTIME ) );

	//
	// Get the system time
	//

	GetSystemTime( &sysTime );

	//
	// Save it away
	//

	g_wDate = sysTime.wDay;
	g_wMonth = sysTime.wMonth;

	//
	// return success
	//

	return TRUE;
}

/****************************************************************************
 *
 *  GenerateLibSourcesFile
 *
 *  Description:
 *      generate the sources file to build the source file generated for lib
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      TRUE on success
 *      FALSE on failure
 *
 ****************************************************************************/

BOOL GenerateLibSourcesFile( void )
{
	//
	// allocate the sources file and check to make sure allocation was good
	//

	FILE* pSourcesFile = fopen( "lib\\sources", "wb" );

	if ( NULL == pSourcesFile )
		return FALSE;

	//
	// Output the text for the sources file
	//

	fprintf( pSourcesFile, "TARGETNAME=%s\r\n", g_tszDir );
	fprintf( pSourcesFile, "TARGETPATH=$(BASEDIR)\\private\\test\\lib\r\n" );
	fprintf( pSourcesFile, "TARGETTYPE=LIBRARY\r\n" );
	fprintf( pSourcesFile, "\r\n" );
	fprintf( pSourcesFile, "INCLUDES =          $(PRIVATE_INC_PATH);                               \\\r\n" );
	fprintf( pSourcesFile, "                    $(BASEDIR)\\private\\test\\inc;                       \\\r\n" );
	fprintf( pSourcesFile, "                    $(BASEDIR)\\private\\test\\multimedia\\inc\r\n" );
	fprintf( pSourcesFile, "\r\n" );                                           
	fprintf( pSourcesFile, "SOURCES= 			                                       \\\r\n" );
	fprintf( pSourcesFile, "    ..\\%s.cpp\r\n", g_tszDir );

	//
	// close the file
	//

	if ( NULL != pSourcesFile )
		fclose( pSourcesFile );

	//
	// return Success
	//

	return TRUE;
}

/****************************************************************************
 *
 *  GenerateExeSourcesFile
 *
 *  Description:
 *      generate the sources file to build the source file generated for exe
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      TRUE on success
 *      FALSE on failure
 *
 ****************************************************************************/

BOOL GenerateExeSourcesFile( void )
{
	//
	// allocate the sources file and check to make sure allocation was good
	//

	FILE* pSourcesFile = fopen( "exe\\sources", "wb" );

	if ( NULL == pSourcesFile )
		return FALSE;

	//
	// Output the text for the sources file
	//

	fprintf( pSourcesFile, "TARGETNAME=%s\r\n", g_tszDir );
	fprintf( pSourcesFile, "TARGETPATH=obj\r\n" );
	fprintf( pSourcesFile, "TARGETTYPE=PROGRAM\r\n" );
	fprintf( pSourcesFile, "UMTYPE=xboxapp\r\n" );
	fprintf( pSourcesFile, "\r\n" );
	fprintf( pSourcesFile, "C_DEFINES=$(C_DEFINES) -DNOLOGGING\r\n" );
	fprintf( pSourcesFile, "\r\n" );
	fprintf( pSourcesFile, "MSC_WARNING_LEVEL=/W3 /WX\r\n" );
	fprintf( pSourcesFile, "MSC_OPTIMIZATION =  $(MSC_OPTIMIZATION) /Od\r\n" );
	fprintf( pSourcesFile, "\r\n" );
	fprintf( pSourcesFile, "XE_FLAGS=/TESTNAME:\"%s\" /TESTID:0xA7049955\r\n", g_tszDir );
	fprintf( pSourcesFile, "\r\n" );
	fprintf( pSourcesFile, "INCLUDES =          $(PRIVATE_INC_PATH);                               \\\r\n" );
	fprintf( pSourcesFile, "                    $(BASEDIR)\\private\\test\\inc;                       \\\r\n" );
	fprintf( pSourcesFile, "                    $(BASEDIR)\\private\\test\\multimedia\\inc\r\n" );
	fprintf( pSourcesFile, "\r\n" );
	fprintf( pSourcesFile, "TARGETLIBS =        $(LIBRARY_PATH)\\xonline$(D).lib\r\n" );
	fprintf( pSourcesFile, "\r\n" );
	fprintf( pSourcesFile, "SOURCES= 			                                       \\\r\n" );
	fprintf( pSourcesFile, "    ..\\%s.cpp\r\n", g_tszDir );

	//
	// close the file
	//

	if ( NULL != pSourcesFile )
		fclose( pSourcesFile );

	//
	// return Success
	//

	return TRUE;
}

/****************************************************************************
 *
 *  GenerateSourceCodeFile
 *
 *  Description:
 *      Generate the .cpp file
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      TRUE on success
 *      FALSE on failure
 *
 ****************************************************************************/

BOOL GenerateSourceCodeFile( void )
{
	//
	// allocate space for the file name
	//

	TCHAR tszFileName[MAX_PATH];

	//
	// append .cpp to the directory name
	//

	sprintf( tszFileName, "%s.cpp", g_tszDir );

	//
	// create the source file, check for an error
	//

	FILE* pSourceCodeFile = fopen( tszFileName, "wb" );

	if ( NULL == pSourceCodeFile )
		return FALSE;

	//
	// print the basic framework for the source file
	//

	fprintf( pSourceCodeFile, "/***************************************************************************\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  File:       %s.cpp\r\n", g_tszDir );
	fprintf( pSourceCodeFile, " *  Content:    %s tests\r\n", g_tszDir );
	fprintf( pSourceCodeFile, " *  History:\r\n" );
	fprintf( pSourceCodeFile, " *   Date       By       Reason\r\n" );
	fprintf( pSourceCodeFile, " *   ====       ==       ======\r\n" );
	fprintf( pSourceCodeFile, " *  %2u/%2u/01    %s Created to test Xbox %s\r\n", g_wMonth, g_wDate, g_tszUser, g_tszDir );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " ****************************************************************************/\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "#include \"%s.h\"\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "/****************************************************************************\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " * The Global Logging Handle\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " ****************************************************************************/\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "extern HANDLE g_hLog;\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "/****************************************************************************\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  %s_BasicTest\r\n", g_tszDir );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  Description:\r\n" );
	fprintf( pSourceCodeFile, " *      Basic Test for %s\r\n", g_tszDir );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  Arguments:\r\n" );
	fprintf( pSourceCodeFile, " *      (void)\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  Returns:  \r\n" );
	fprintf( pSourceCodeFile, " *      S_OK on success\r\n" );
	fprintf( pSourceCodeFile, " *      E_XX on failure\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " ****************************************************************************/\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "HRESULT %s_BasicTest( void )\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "{\r\n" );
	fprintf( pSourceCodeFile, "    HRESULT             hr              = S_OK;\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    //\r\n" );
	fprintf( pSourceCodeFile, "    // Return the Hresult\r\n" );
	fprintf( pSourceCodeFile, "    //\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    return hr;\r\n" );
	fprintf( pSourceCodeFile, "}\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "/****************************************************************************\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  %s_StartTest\r\n", g_tszDir );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  Description:\r\n" );
	fprintf( pSourceCodeFile, " *      The Harness Entry into the %s tests\r\n", g_tszDir );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  Arguments:\r\n" );
	fprintf( pSourceCodeFile, " *      LogHandle - a handle to a logging object\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  Returns:  \r\n" );
	fprintf( pSourceCodeFile, " *		(void)\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " ****************************************************************************/\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "VOID WINAPI %s_StartTest( HANDLE LogHandle )\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "{\r\n" );
	fprintf( pSourceCodeFile, "    HRESULT             hr              = S_OK;\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    //\r\n" );
	fprintf( pSourceCodeFile, "    // the following tests will Assert (by design) in debug builds\r\n" );
	fprintf( pSourceCodeFile, "    // to turn these tests on (they are off by default) define\r\n" );
	fprintf( pSourceCodeFile, "    // CODE_COVERAGE when this file is compiled\r\n" );
	fprintf( pSourceCodeFile, "    //\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "#ifdef CODE_COVERAGE\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "#endif // CODE_COVERAGE\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    //\r\n" );
	fprintf( pSourceCodeFile, "    // Test %s in the mannor it was meant to be called\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    //\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    if ( SHOULDRUNTEST( \"%s\", \"Basic\" ) )\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    {\r\n" );
	fprintf( pSourceCodeFile, "        SETLOG( LogHandle, \"%s\", \"Online\", \"%s\", \"Basic\" );\r\n", g_tszUser, g_tszDir );
	fprintf( pSourceCodeFile, "        EXECUTE( %s_BasicTest() );\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    }\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "}\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "/****************************************************************************\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  %s_EndTest\r\n", g_tszDir );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  Description:\r\n" );
	fprintf( pSourceCodeFile, " *      The Exit function for the test harness\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  Arguments:\r\n" );
	fprintf( pSourceCodeFile, " *      (void)\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  Returns:  \r\n" );
	fprintf( pSourceCodeFile, " *		(void)\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " ****************************************************************************/\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "VOID WINAPI %s_EndTest( VOID )\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "{\r\n" );
	fprintf( pSourceCodeFile, "}\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "/****************************************************************************\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  main\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  Description:\r\n" );
	fprintf( pSourceCodeFile, " *      the exe entry point\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  Arguments:\r\n" );
	fprintf( pSourceCodeFile, " *      (void)\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  Returns:  \r\n" );
	fprintf( pSourceCodeFile, " *      (void)\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " ****************************************************************************/\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "#ifdef NOLOGGING\r\n" );
	fprintf( pSourceCodeFile, "void __cdecl main( void )\r\n" );
	fprintf( pSourceCodeFile, "{\r\n" );
	fprintf( pSourceCodeFile, "    %s_StartTest( NULL );\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    %s_EndTest();\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "}\r\n" );
	fprintf( pSourceCodeFile, "#endif // NOLOGGING\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "/****************************************************************************\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " * Export Function Pointers for StartTest and EndTest\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " ****************************************************************************/\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "#pragma data_seg( EXPORT_SECTION_NAME )\r\n" );
	fprintf( pSourceCodeFile, "DECLARE_EXPORT_DIRECTORY( %s )\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "#pragma data_seg()\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "BEGIN_EXPORT_TABLE( %s )\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    EXPORT_TABLE_ENTRY( \"StartTest\", %s_StartTest )\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    EXPORT_TABLE_ENTRY( \"EndTest\", %s_EndTest )\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "END_EXPORT_TABLE( %s )\r\n", g_tszDir );

	//
	// close the open file
	//

	if ( NULL != pSourceCodeFile )
		fclose( pSourceCodeFile );

	//
	// return success
	//

	return TRUE;
}

/****************************************************************************
 *
 *  GenerateSourceCodeFileStandard
 *
 *  Description:
 *      Generate the .cpp file (standard comments)
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      TRUE on success
 *      FALSE on failure
 *
 ****************************************************************************/

BOOL GenerateSourceCodeFileStandard( void )
{
	//
	// allocate space for the file name
	//

	TCHAR tszFileName[MAX_PATH];

	//
	// append .cpp to the directory name
	//

	sprintf( tszFileName, "%s.cpp", g_tszDir );

	//
	// create the source file, check for an error
	//

	FILE* pSourceCodeFile = fopen( tszFileName, "wb" );

	if ( NULL == pSourceCodeFile )
		return FALSE;

	//
	// print the basic framework for the source file
	//

	fprintf( pSourceCodeFile, "/*++\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Copyright (c) Microsoft Corporation. All rights reserved.\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Module Name:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    %s.cpp\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Abstract:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    %s tests\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "--*/\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "#include \"%s.h\"\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "//\r\n" );
	fprintf( pSourceCodeFile, "// The Global Logging Handle\r\n" );
	fprintf( pSourceCodeFile, "//\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "extern HANDLE g_hLog;\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "HRESULT\r\n" );
	fprintf( pSourceCodeFile, "%s_BasicTest(\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    void\r\n" );
	fprintf( pSourceCodeFile, "    )\r\n" );
	fprintf( pSourceCodeFile, "/*++\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Routine Description:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    Basic Test for %s\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Arguments:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    None\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Return Value:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    S_OK on success\r\n" );
	fprintf( pSourceCodeFile, "    E_XX on failure\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "--*/\r\n" );
	fprintf( pSourceCodeFile, "{\r\n" );
	fprintf( pSourceCodeFile, "    HRESULT             hr              = S_OK;\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    //\r\n" );
	fprintf( pSourceCodeFile, "    // Return the Hresult\r\n" );
	fprintf( pSourceCodeFile, "    //\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    return hr;\r\n" );
	fprintf( pSourceCodeFile, "}\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "VOID \r\n" );
	fprintf( pSourceCodeFile, "WINAPI \r\n" );
	fprintf( pSourceCodeFile, "%s_StartTest( \r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    HANDLE              LogHandle \r\n" );
	fprintf( pSourceCodeFile, "    )\r\n" );
	fprintf( pSourceCodeFile, "/*++\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Routine Description:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    The harness entry into the %s tests\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Arguments:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    LogHandle - a handle to a logging object\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Return Value:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    None\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "--*/\r\n" );
	fprintf( pSourceCodeFile, "{\r\n" );
	fprintf( pSourceCodeFile, "    HRESULT             hr              = S_OK;\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    //\r\n" );
	fprintf( pSourceCodeFile, "    // the following tests will Assert (by design) in debug builds\r\n" );
	fprintf( pSourceCodeFile, "    // to turn these tests on (they are off by default) define\r\n" );
	fprintf( pSourceCodeFile, "    // CODE_COVERAGE when this file is compiled\r\n" );
	fprintf( pSourceCodeFile, "    //\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "#ifdef CODE_COVERAGE\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "#endif // CODE_COVERAGE\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    //\r\n" );
	fprintf( pSourceCodeFile, "    // Test %s in the mannor it was meant to be called\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    //\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    if ( SHOULDRUNTEST( \"%s\", \"Basic\" ) )\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    {\r\n" );
	fprintf( pSourceCodeFile, "        SETLOG( LogHandle, \"%s\", \"Online\", \"%s\", \"Basic\" );\r\n", g_tszUser, g_tszDir );
	fprintf( pSourceCodeFile, "        EXECUTE( %s_BasicTest() );\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    }\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "}\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "VOID \r\n" );
	fprintf( pSourceCodeFile, "WINAPI \r\n" );
	fprintf( pSourceCodeFile, "%s_EndTest( \r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    VOID \r\n" );
	fprintf( pSourceCodeFile, "    )\r\n" );
	fprintf( pSourceCodeFile, "/*++\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Routine Description:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    The exit function for the test harness\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Arguments:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    None\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Return Value:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    None\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "--*/\r\n" );
	fprintf( pSourceCodeFile, "{\r\n" );
	fprintf( pSourceCodeFile, "}\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "#ifdef NOLOGGING\r\n" );
	fprintf( pSourceCodeFile, "void \r\n" );
	fprintf( pSourceCodeFile, "__cdecl \r\n" );
	fprintf( pSourceCodeFile, "main( \r\n" );
	fprintf( pSourceCodeFile, "    void \r\n" );
	fprintf( pSourceCodeFile, "    )\r\n" );
	fprintf( pSourceCodeFile, "/*++\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Routine Description:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    the exe entry point\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Arguments:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    None\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Return Value:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    None\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "--*/\r\n" );
	fprintf( pSourceCodeFile, "{\r\n" );
	fprintf( pSourceCodeFile, "    %s_StartTest( NULL );\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    %s_EndTest();\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "}\r\n" );
	fprintf( pSourceCodeFile, "#endif // NOLOGGING\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "//\r\n" );
	fprintf( pSourceCodeFile, "// Export Function Pointers for StartTest and EndTest\r\n" );
	fprintf( pSourceCodeFile, "//\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "#pragma data_seg( EXPORT_SECTION_NAME )\r\n" );
	fprintf( pSourceCodeFile, "DECLARE_EXPORT_DIRECTORY( %s )\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "#pragma data_seg()\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "BEGIN_EXPORT_TABLE( %s )\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    EXPORT_TABLE_ENTRY( \"StartTest\", %s_StartTest )\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "    EXPORT_TABLE_ENTRY( \"EndTest\", %s_EndTest )\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "END_EXPORT_TABLE( %s )\r\n", g_tszDir );

	//
	// close the open file
	//

	if ( NULL != pSourceCodeFile )
		fclose( pSourceCodeFile );

	//
	// return success
	//

	return TRUE;
}

/****************************************************************************
 *
 *  GenerateHeaderFile
 *
 *  Description:
 *      Generate the .h file
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      TRUE on success
 *      FALSE on failure
 *
 ****************************************************************************/

BOOL GenerateHeaderFile( void )
{
	//
	// allocate space for the file name
	//

	TCHAR tszFileName[MAX_PATH];

	//
	// append .h to the directory name
	//

	sprintf( tszFileName, "%s.h", g_tszDir );

	//
	// create the header file, check for an error
	//

	FILE* pSourceCodeFile = fopen( tszFileName, "wb" );

	if ( NULL == pSourceCodeFile )
		return FALSE;

	//
	// print the basic framework for the header file
	//

	fprintf( pSourceCodeFile, "/***************************************************************************\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.\r\n" );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " *  File:       %s.h\r\n", g_tszDir );
	fprintf( pSourceCodeFile, " *  Content:    %s utility interface\r\n", g_tszDir );
	fprintf( pSourceCodeFile, " *  History:\r\n" );
	fprintf( pSourceCodeFile, " *   Date       By       Reason\r\n" );
	fprintf( pSourceCodeFile, " *   ====       ==       ======\r\n" );
	fprintf( pSourceCodeFile, " *  %2u/%2u/01    %s Created to test Xbox %s\r\n", g_wMonth, g_wDate, g_tszUser, g_tszDir );
	fprintf( pSourceCodeFile, " *\r\n" );
	fprintf( pSourceCodeFile, " ****************************************************************************/\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "#pragma once\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "#include <xtl.h>\r\n" );
	fprintf( pSourceCodeFile, "#include <xdbg.h>\r\n" );
	fprintf( pSourceCodeFile, "#include <xlog.h>\r\n" );
	fprintf( pSourceCodeFile, "#include <macros.h>\r\n" );
	fprintf( pSourceCodeFile, "#include <xtestlib.h>\r\n" );

	//
	// close the open file
	//

	if ( NULL != pSourceCodeFile )
		fclose( pSourceCodeFile );

	//
	// return success
	//

	return TRUE;
}

/****************************************************************************
 *
 *  GenerateHeaderFileStandard
 *
 *  Description:
 *      Generate the .h file (standard comments)
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      TRUE on success
 *      FALSE on failure
 *
 ****************************************************************************/

BOOL GenerateHeaderFileStandard( void )
{
	//
	// allocate space for the file name
	//

	TCHAR tszFileName[MAX_PATH];

	//
	// append .h to the directory name
	//

	sprintf( tszFileName, "%s.h", g_tszDir );

	//
	// create the header file, check for an error
	//

	FILE* pSourceCodeFile = fopen( tszFileName, "wb" );

	if ( NULL == pSourceCodeFile )
		return FALSE;

	//
	// print the basic framework for the header file
	//

	fprintf( pSourceCodeFile, "/*++\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Copyright (c) Microsoft Corporation. All rights reserved.\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Module Name:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    %s.h\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "Abstract:\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "    %s utility interface\r\n", g_tszDir );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "--*/\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "#pragma once\r\n" );
	fprintf( pSourceCodeFile, "\r\n" );
	fprintf( pSourceCodeFile, "#include <xtl.h>\r\n" );
	fprintf( pSourceCodeFile, "#include <xdbg.h>\r\n" );
	fprintf( pSourceCodeFile, "#include <xlog.h>\r\n" );
	fprintf( pSourceCodeFile, "#include <macros.h>\r\n" );

	//
	// close the open file
	//

	if ( NULL != pSourceCodeFile )
		fclose( pSourceCodeFile );

	//
	// return success
	//

	return TRUE;
}

/****************************************************************************
 *
 *  GenerateLibMakeFile
 *
 *  Description:
 *      generate the make file for the lib in this project
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      TRUE on success
 *      FALSE on failure
 *
 ****************************************************************************/

BOOL GenerateLibMakeFile( void )
{
	//
	// allocate the make file and check for failure
	//

	FILE* pMakeFile = fopen( "lib\\makefile", "wb" );

	if ( NULL == pMakeFile )
		return FALSE;

	//
	// print out the text ot the makefile
	//

	fprintf( pMakeFile, "#\r\n" );
	fprintf( pMakeFile, "# DO NOT EDIT THIS FILE!!!  Edit .\\sources. if you want to add a new source\r\n" );
	fprintf( pMakeFile, "# file to this component.  This file merely indirects to the real make file\r\n" );
	fprintf( pMakeFile, "# that is shared by all the components of NT OS/2\r\n" );
	fprintf( pMakeFile, "#\r\n" );
	fprintf( pMakeFile, "!INCLUDE $(NTMAKEENV)\\makefile.def\r\n" );

	//
	// close the file handle
	//

	if ( NULL != pMakeFile )
		fclose( pMakeFile );

	//
	// return success
	//

	return TRUE;
}

/****************************************************************************
 *
 *  GenerateExeMakeFile
 *
 *  Description:
 *      generate the make file for the exe in this project
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      TRUE on success
 *      FALSE on failure
 *
 ****************************************************************************/

BOOL GenerateExeMakeFile( void )
{
	//
	// allocate the make file and check for failure
	//

	FILE* pMakeFile = fopen( "exe\\makefile", "wb" );

	if ( NULL == pMakeFile )
		return FALSE;

	//
	// print out the text ot the makefile
	//

	fprintf( pMakeFile, "#\r\n" );
	fprintf( pMakeFile, "# DO NOT EDIT THIS FILE!!!  Edit .\\sources. if you want to add a new source\r\n" );
	fprintf( pMakeFile, "# file to this component.  This file merely indirects to the real make file\r\n" );
	fprintf( pMakeFile, "# that is shared by all the components of NT OS/2\r\n" );
	fprintf( pMakeFile, "#\r\n" );
	fprintf( pMakeFile, "!INCLUDE $(NTMAKEENV)\\makefile.def\r\n" );

	//
	// close the file handle
	//

	if ( NULL != pMakeFile )
		fclose( pMakeFile );

	//
	// return success
	//

	return TRUE;
}

/****************************************************************************
 *
 *  GenerateDirsFile
 *
 *  Description:
 *      generate the dirs file for this project
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      TRUE on success
 *      FALSE on failure
 *
 ****************************************************************************/

BOOL GenerateDirsFile( void )
{
	//
	// allocate the dirsfile and check for failure
	//

	FILE* pFile = fopen( "dirs", "wb" );

	if ( NULL == pFile )
		return FALSE;

	//
	// print out the text ot the makefile
	//

	fprintf( pFile, "DIRS=  exe \\\r\n" );
	fprintf( pFile, "       lib\r\n" );

	//
	// close the file handle
	//

	if ( NULL != pFile )
		fclose( pFile );

	//
	// return success
	//

	return TRUE;
}

/****************************************************************************
 *
 *  GenerateSubDirs
 *
 *  Description:
 *      generate the exe and lib sub dirs
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      TRUE on success
 *      FALSE on failure
 *
 ****************************************************************************/

BOOL GenerateSubDirs( void )
{
	if ( 0 != _mkdir( "exe" ) )
		return FALSE;

	if ( 0 != _mkdir( "lib" ) )
		return FALSE;

	return true;
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      program entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      0 on success
 *      -1 on failure
 *
 ****************************************************************************/

int __cdecl main( int argc, char* argv[] )
{	
	//
	// Set the global directory
	//

	if ( ! SetDirectory() )
	{
		printf( "Could not resolve the current directory name\n" );
		return -1;
	}

	//
	// set the global date
	//

	if ( ! SetDate() )
	{
		printf( "Could not resolve the current date\n" );
		return -1;
	}
	//
	// set the global user
	//

	if ( ! SetUser() )
	{
		printf( "Could not resolve the current user\n" );
		return -1;
	}

	//
	// generate the sub directories
	//

	if ( ! GenerateSubDirs() )
	{
		printf( "Could not generate lib and exe directories" );
		return -1;
	}

	//
	// generate the sources files
	//

	if ( ! GenerateLibSourcesFile() )
	{
		printf( "Could not generate the sources file for lib\n" );
		return -1;
	}

	if ( ! GenerateExeSourcesFile() )
	{
		printf( "Could not generate the sources file for exe\n" );
		return -1;
	}

	//
	// generate the makefiles
	//

	if ( ! GenerateLibMakeFile() )
	{
		printf( "Could not generate the makefile for lib\n" );
		return -1;
	}

	if ( ! GenerateExeMakeFile() )
	{
		printf( "Could not generate the makefile for exe\n" );
		return -1;
	}

	//
	// generate the dirs file
	//

	if ( ! GenerateDirsFile() )
	{
		printf( "Could not generate the dirs file\n" );
		return -1;
	}

	//
	// generate the .cpp file
	//

	if ( NULL == argv[1] )
	{
		if ( ! GenerateSourceCodeFile() )
		{
			printf( "Could not generate the .cpp file\n" );
			return -1;
		}

		if ( ! GenerateHeaderFile() )
		{
			printf( "Could not generate the .h file\n" );
			return - 1;
		}
	}
	else
	{
		if ( ! GenerateSourceCodeFileStandard() )
		{
			printf( "Could not generate the .cpp file\n" );
			return -1;
		}

		if ( ! GenerateHeaderFileStandard() )
		{
			printf( "Could not generate the .h file\n" );
			return -1;
		}
	}

	//
	// return success
	//

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\cpuusage\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This program contains routines to calculate CPU utilization

Environment:

    Xbox

Revision History:

--*/


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}


#include <xtl.h>
#include <xlog.h>
#include <xtestlib.h>
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\datamask\datamask.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  datamask.c

Abstract:

  This module is a common library for masking a data stream

Author:

  Steven Kehrli (steveke) 4-Jan-2002

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/

#include "precomp.h"



namespace DataMaskNamespace {

BYTE  pMaskBuffer[] = { 0x2b, 0xc6, 0xa5, 0x67, 0x14, 0xc6, 0x72, 0xe8,
                        0xb4, 0x08, 0xfc, 0x66, 0x96, 0xf5, 0xb8, 0x43,
                        0x8a, 0xd6, 0x4b, 0x1c, 0xf9, 0xd1, 0x90, 0x7a,
                        0x94, 0xee, 0x16, 0x17, 0x28, 0x80, 0x2c, 0x0d,
                        0x9e, 0xd9, 0x56, 0x09, 0xe8, 0x0f, 0xa0, 0x18,
                        0x17, 0x97, 0xf7, 0x27, 0xef, 0x4f, 0x5e, 0x7d,
                        0x60, 0xf0, 0x01, 0xf9, 0xfa, 0xdb, 0xdd, 0x04,
                        0xa5, 0xc2, 0x7d, 0x96, 0x03, 0x6d, 0x8f, 0xa7,
                        0xb5, 0x38, 0x9f, 0x2f, 0xfc, 0xea, 0xd0, 0xcc,
                        0x42, 0x74, 0xe3, 0x8d, 0xdb, 0x7c, 0xbf, 0x3a,
                        0xdc, 0x4b, 0x48, 0x8b, 0xe8, 0x2d, 0x22, 0xa4,
                        0xa9, 0x0a, 0xa9, 0xba, 0x3a, 0xd2, 0x81, 0x86,
                        0x55, 0x35, 0xa5, 0xeb, 0xd4, 0x6a, 0xf2, 0x8b,
                        0x98, 0x4f, 0x14, 0xd0, 0xb7, 0xcc, 0xec, 0x68,
                        0x5e, 0x2a, 0x3e, 0x76, 0x53, 0x3b, 0x2f, 0xbf,
                        0x50, 0x04, 0xff, 0xe9, 0x7b, 0x23, 0xa5, 0x50 };

UINT  nMaskBufferSize = sizeof(pMaskBuffer);

} // namespace DataMaskNamespace



using namespace DataMaskNamespace;

VOID
WINAPI
DataMask(
    BYTE  *pBuffer,
    UINT  nBufferSize
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Initializes the xbox net stack if necessary.  Increases the ref count for the xbox net stack.

Arguments:

  pBuffer - Pointer to the buffer
  nBufferSize - Specifies the buffer size

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // nByte is a counter to enumerate each byte
    UINT  nByte = 0;



    for (nByte = 0; nByte < nBufferSize; nByte++) {
        pBuffer[nByte] ^= pMaskBuffer[nByte % nMaskBufferSize];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\datamask\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 4-Jan-2002

Environment:

    XBox

Revision History:

------------------------------------------------------------------------------*/

#include <xtl.h>
#include <datamask.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\cpuusage\cpuusage.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    couusage.cpp

Abstract:

    This program contains routines to calculate CPU utilization

Environment:

    Xbox

Revision History:

--*/


#include <precomp.h>


VOID
WINAPI
CpuUsageStartTest(
    HANDLE /* LogHandle */
    )

/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/

{
    static LARGE_INTEGER PrevTotalTime = { 0, 0 };
    static LARGE_INTEGER PrevIdleTime = { 0, 0 };
    static LARGE_INTEGER PrevKernelTime = { 0, 0 };

    LARGE_INTEGER KernelTime;
    LARGE_INTEGER IdleTime;
    LARGE_INTEGER TotalTime;

    LARGE_INTEGER DeltaTotalTime;
    LARGE_INTEGER DeltaIdleTime;
    LARGE_INTEGER DeltaKernelTime;

    BYTE CpuUsage;

    // Ignore Interrupt, DPC and User time
    QueryCpuTimesInformation( &KernelTime, &IdleTime, 0, 0, 0 );

    TotalTime.QuadPart = KernelTime.QuadPart + IdleTime.QuadPart;

    DeltaIdleTime.QuadPart = IdleTime.QuadPart - PrevIdleTime.QuadPart;
    DeltaKernelTime.QuadPart = KernelTime.QuadPart - PrevKernelTime.QuadPart;
    DeltaTotalTime.QuadPart = TotalTime.QuadPart - PrevTotalTime.QuadPart;

    PrevTotalTime.QuadPart = TotalTime.QuadPart;
    PrevIdleTime.QuadPart = IdleTime.QuadPart;
    PrevKernelTime.QuadPart = KernelTime.QuadPart;

    if ( DeltaTotalTime.QuadPart == 0 ) {
        CpuUsage = 0;
    } else {
        CpuUsage = (BYTE)( 100 - ( (DeltaIdleTime.QuadPart * 100)/DeltaTotalTime.QuadPart) );
    }

    KdPrint(( "\rCPUUSAGE: %u%%\r", CpuUsage ));
}


VOID
WINAPI
CpuUsageEndTest(
    VOID
    )

/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/

{
}


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( cpuusage )
#pragma data_seg()

BEGIN_EXPORT_TABLE( cpuusage )
    EXPORT_TABLE_ENTRY( "StartTest", CpuUsageStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", CpuUsageEndTest )
END_EXPORT_TABLE( couusage )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\diskperf\diskperf.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    diskperf.h

Abstract:

    disk perf for xbox

written by:

    John Daly (johndaly) 13-july-2000

Environment:

    XBox

Revision History:


--*/

#ifndef _DISKPERF_
#define _DISKPERF_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <ntos.h>
#include <xlog.h>
#include <xtestlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

//
// Heap handle from HeapCreate
//

HANDLE HeapHandle;
HANDLE LogHandle;
LARGE_INTEGER Frequency;
LARGE_INTEGER PerformanceCount;

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))

#define CREATE_FLAG  1
#define DELETE_FLAG  2

//
// function declarations
//

DWORD
WINAPI
SizeCache(
    DWORD Size
    );

VOID
WINAPI
run_var1(
    VOID
    );

VOID
WINAPI
run_var2(
    VOID
    );

VOID
WINAPI
run_var3(
    VOID
    );

VOID
WINAPI
run_var4(
    VOID
    );

VOID
WINAPI
run_var5(
    VOID
    );

VOID
WINAPI
run_var6(
    VOID
    );

VOID
WINAPI
run_var7(
    VOID
    );

VOID
WINAPI
run_var8(
    VOID
    );

VOID
WINAPI
run_var9(
    VOID
    );

VOID
WINAPI
run_var10(
    VOID
    );

VOID
WINAPI
run_var11(
    VOID
    );

VOID
WINAPI
run_var12(
    VOID
    );

VOID
WINAPI
run_var13(
    VOID
    );

VOID
WINAPI
run_var14(
    VOID
    );

VOID
WINAPI
run_var15(
    VOID
    );

VOID
WINAPI
run_var16(
    VOID
    );

VOID
WINAPI
run_var17(
    VOID
    );

VOID
WINAPI
StartTimer(
    VOID
    );

DWORD
WINAPI
EndTimer(
    VOID
    );

VOID
WINAPI
RecursivelyDiskCopy(
    POCHAR source, 
    POCHAR target,
    PULONGLONG pTotalBytesCopied,
    PDWORD pTotalFilesCopied,
    DWORD CreateDeleteFlag
    );

PVOID
WINAPI
CreateTestDataBuffer(
    DWORD
    );

VOID
WINAPI
CleanCaches(
    VOID
    );

#endif // _DISKPERF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\diskperf\nt\diskperf.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    diskperf.h

Abstract:

    disk perf for xbox

written by:

    John Daly (johndaly) 13-july-2000

Environment:

    XBox

Revision History:


--*/

#ifndef _DISKPERF_
#define _DISKPERF_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

//
// Heap handle from HeapCreate
//

HANDLE HeapHandle;
HANDLE LogHandle;
LARGE_INTEGER Frequency;
LARGE_INTEGER PerformanceCount;

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))

#define CREATE_FLAG  1
#define DELETE_FLAG  2

//
// function declarations
//

VOID
run_var1(
    VOID
    );

VOID
run_var2(
    VOID
    );

VOID
run_var3(
    VOID
    );

VOID
run_var4(
    VOID
    );

VOID
run_var5(
    VOID
    );

VOID
run_var6(
    VOID
    );

VOID
run_var7(
    VOID
    );

VOID
run_var8(
    VOID
    );

VOID
run_var9(
    VOID
    );

VOID
run_var10(
    VOID
    );

VOID
run_var11(
    VOID
    );

VOID
run_var12(
    VOID
    );

VOID
StartTimer(
    VOID
    );

DWORD
EndTimer(
    VOID
    );

VOID
RecursivelyDiskCopy(
    PWCHAR source, 
    PWCHAR target,
    PULONGLONG pTotalBytesCopied,
    PDWORD pTotalFilesCopied,
    DWORD CreateDeleteFlag
    );

PVOID
CreateTestDataBuffer(
    DWORD
    );

VOID
CleanCaches(
    VOID
    );

#endif // _DISKPERF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\diskperf\diskperf.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    diskperf.c

Abstract:

    disk perf for xbox

written by:

    John Daly (johndaly) 13-july-2000

Environment:

    XBox

Revision History:


Notes:

    yes, I know I could make this state or table driven, but it
    will be easier to maintain like this and easier to tweak / special case / debug as well

    using FscInvalidateIdleBlocks() to have the memory manager discard
    clean system cache pages.  Test wants this to get the cache back to a clean slate.  
    It's the responsibility of the caller to flush any volumes in order to maximum the 
    clean page count.
    
    some thing may be hard to port to NT, such as limiting / blowing away cache


--*/

#include "diskperf.h"

VOID
WINAPI
DiskPerfStartTest(
    HANDLE xLogHandle
    )
/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/ 
{
    LogHandle = xLogHandle;

    xSetComponent( LogHandle, "kernel", "diskperf" );
    xSetFunctionName(LogHandle, "StartTest" );

    //
    // set up the timer
    //

    if (FALSE == QueryPerformanceFrequency(&Frequency)) {
        ;// log and exit
    }

    //
    // run the performance variations
    //



    //
    // test the timer
    // it seems to be pretty close, we'll use it for now
    //
    //for (x=0;x<1000;x++) {
    //    // start timer
    //    StartTimer();
    //    Sleep(x*2);
    //    Time = EndTimer();
    //    // log time
    //    xLog(LogHandle, 
    //    XLL_PASS, 
    //    "Time: %10.10u ms",
    //    Time);
    //}


    run_var1(); // ok
    run_var2(); // ok
    run_var3(); // ok


    // run_var4();  stupid, do not code

    run_var5(); // ok
    run_var6(); // ok
    run_var7(); // ok
//    run_var8(); // just use 7 to cover all media
    run_var9(); // ok
    run_var10(); // ok
    run_var11(); //ok
    run_var12();
    //run_var13(); // ignore
    //run_var14(); // ignore
    //run_var15(); // ignore
    //run_var16(); // ignore
    //run_var17(); // ignore

    return;
}

DWORD
WINAPI
SizeCache(
    DWORD Size
    )
/*++

Routine Description:

    Allocate enough memory to prevent the disk cache from growing 
    above the specified size
    
Arguments:

    Size - size in bytes you want the cache limited to

Return Value:

    Size of cache
    
Notes:

    without an elegant way to do this, eat memory
    
    other memory allocations can affect this
    
    free the buffer like this when finished with it
    VirtualFree(<whatever this function returned>, 0, MEM_RELEASE); 
    
    the size you get will be within ~200k, don't try passing a size less than 1 mb

--*/ 
{
    //
    // the old way before we had cache size control
    //
    //
    //MM_STATISTICS mmStats;
    //LPVOID VMem;
    //DWORD SizeInPages = Size / PAGE_SIZE;
    //
    //ZeroMemory(&mmStats, sizeof(mmStats));
    //mmStats.Length = sizeof(mmStats);
    //
    //MmQueryStatistics(&mmStats);
    //
    //VMem = VirtualAlloc(NULL, 
    //                    (((mmStats.AvailablePages * PAGE_SIZE) + 
    //                      (mmStats.CachePagesCommitted * PAGE_SIZE)) - 
    //                     Size),
    //                    MEM_COMMIT,
    //                    PAGE_READWRITE);
    //
    //ZeroMemory(&mmStats, sizeof(mmStats));
    //mmStats.Length = sizeof(mmStats);
    //MmQueryStatistics(&mmStats);
    //

    //
    // Note : cache is currently limited to 8 mb, so after that point we can't grow the cache
    // 
    //

    XSetFileCacheSize( Size );
    return(XGetFileCacheSize());
}

VOID
WINAPI
DiskPerfEndTest(
    VOID
    )
/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/ 
{
    OutputDebugString( TEXT("diskperf: EndTest is called\n") );
}

VOID
WINAPI
run_var1(
        VOID
        )
/*++

Routine Description:

    all writes (all sizes and flags)

Arguments:

    None

Return Value:

    None
    
Notes:

    the overlapped variation is pretty conservative, it waits for 
    each write, it could be rewritten to queue more writes and then wait
    or to use WriteFileEx and have a completion routine, and when the
    total bytes written is achieved then we know we are done

--*/ 
{
#define TestBufferSize 0x10000
    DWORD SizeArray[] = {128, 256, 512, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000,  0x2E000000/*0xFFFF0000*/};
    DWORD FlagSets[] = {FILE_ATTRIBUTE_NORMAL,
        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_WRITE_THROUGH,
        FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_SEQUENTIAL_SCAN};
    DWORD x, y, z;
    HANDLE FileHandle;
    DWORD Time;
    PVOID TestData;
    DWORD BytesWritten;
    DWORD BytesWrittenX;
    OVERLAPPED OverLapped;
    OVERLAPPED *pOverlapped;
    BOOL bResult;
    DWORD Error;

    //
    // set the cache size to something reasonable (128k)
    //

    SizeCache(128 * 1024);
    CleanCaches();

    //
    // allocate and initialize test buffer
    //

    TestData = CreateTestDataBuffer(TestBufferSize);
    if (NULL == TestData) {
        Error = GetLastError();
        DebugBreak();
    }

    xStartVariation( LogHandle, "variation1" );
    xLog(LogHandle, XLL_INFO, "all writes (all sizes and flags)");

    DeleteFile(OTEXT("Z:\\TestFile.prf"));

    //
    // for each flag set....
    //

    for (y = 0; y < ARRAYSIZE(FlagSets); y++) {

        //
        // and each test file size...
        //

        for (x = 0; x < ARRAYSIZE(SizeArray); x++) {

            //
            // clean out caches, reset BytesWrittenX count
            //

            CleanCaches();

            BytesWrittenX = 0;

            //
            // we have to block certain writes, since they don't conform to 
            // limitations imposed by the OS
            //

            if ((FlagSets[y] & FILE_FLAG_NO_BUFFERING) && 
                (SizeArray[x] % 512)) {
                continue;
            }

            //
            // create file
            //

            FileHandle = CreateFile(OTEXT("Z:\\TestFile.prf"),
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FlagSets[y],
                                    NULL);

            if (INVALID_HANDLE_VALUE == FileHandle) {
                xLog(LogHandle, XLL_BLOCK, "CreateFile Failed! (LastError = %d)", GetLastError());
                continue;
            }

            //
            // we have to point to an OVERLAPPED struct when appropriate
            // associate Event with struct (this is optional I believe)
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                pOverlapped = &OverLapped;
                ZeroMemory(pOverlapped, sizeof(*pOverlapped));
                if (NULL == (OverLapped.hEvent = CreateEvent(NULL, TRUE, FALSE, OTEXT("DiskPerfEvent")))) {
                    Error = GetLastError();
                    _asm int 3
                }

            } else {
                pOverlapped = NULL;
            }

            //
            // start timer
            //

            StartTimer();

            //
            // write to it
            //

            if (SizeArray[x] > TestBufferSize) {

                for (z = SizeArray[x] / TestBufferSize; z > 0; z--) {

                    bResult = WriteFile(FileHandle, 
                                        TestData,
                                        TestBufferSize,
                                        &BytesWritten,
                                        pOverlapped);

                    //
                    // if we need to wait on the event during this multi-pass write, do it here
                    //

                    if (FALSE == bResult) {

                        if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                            (ERROR_IO_PENDING == GetLastError())) {

                            bResult = GetOverlappedResult(FileHandle,
                                                          pOverlapped,
                                                          &BytesWritten,
                                                          TRUE);
                            if (FALSE == bResult) {
                                Error = GetLastError();
                                DebugBreak();
                            }

                        } else {

                            //
                            // some other error, like disk full..
                            //

                            Error = GetLastError();
                            DebugBreak();
                        }
                    }

                    //
                    // advance pointer for next write
                    //

                    if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                        pOverlapped->Offset += BytesWritten;
                    }

                    BytesWrittenX += BytesWritten;
                }

            } else {

                bResult = WriteFile(FileHandle, 
                                    TestData,
                                    SizeArray[x],
                                    &BytesWrittenX,
                                    pOverlapped);

                //
                // if we need to wait on the event during this write, do it here
                //

                //
                // if we need to wait on the event during this multi-pass write, do it here
                //

                if (FALSE == bResult) {

                    if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                        (ERROR_IO_PENDING == GetLastError())) {

                        bResult = GetOverlappedResult(FileHandle,
                                                      pOverlapped,
                                                      &BytesWritten,
                                                      TRUE);
                        if (FALSE == bResult) {
                            Error = GetLastError();
                            DebugBreak();
                        }

                    } else {

                        //
                        // some other error, like disk full..
                        //

                        Error = GetLastError();
                        DebugBreak();
                    }
                }
            }

            //
            // stop timer
            //

            Time = EndTimer();

            //
            // cleanup
            //

            CloseHandle(FileHandle);

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                CloseHandle(OverLapped.hEvent);
            }

            //
            // Clean up the file
            //

            bResult = DeleteFile(OTEXT("Z:\\TestFile.prf"));

            //
            // log time
            //

            xLog(LogHandle, 
                 XLL_PASS, 
                 "Flags: 0x%8.8X Bytes Written: %10.10u Time: %10.10u ms",
                 FlagSets[y], BytesWrittenX, Time);
        }
    }

    //
    // free test data buffer
    //

    VirtualFree(TestData, 0, MEM_RELEASE); 

    xEndVariation( LogHandle );
}

VOID
WINAPI
run_var2(
    VOID
    )
/*++

Routine Description:

    all reads  (all sizes and flags)

Arguments:

    None

Return Value:

    None
    
Notes:

    it may seem redundant to create files using the exact same technique used 
    in the preceding test, but it makes writing all this code go faster

--*/ 
{
#define TestBufferSize 0x10000
    DWORD SizeArray[] = {128, 256, 512, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x2E000000/*0xFFFF0000*/};
    DWORD FlagSets[] = {FILE_ATTRIBUTE_NORMAL,
        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_WRITE_THROUGH,
        FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_SEQUENTIAL_SCAN};
    DWORD x, y, z;
    HANDLE FileHandle;
    DWORD Time;
    PVOID TestData;
    PVOID TestDataIn;
    DWORD BytesWritten;
    DWORD BytesWrittenX;
    DWORD BytesRead;
    DWORD BytesReadX;
    OVERLAPPED OverLapped;
    OVERLAPPED *pOverlapped;
    BOOL bResult;
    DWORD Error;

    //
    // allocate and initialize test buffer
    //

    TestData = CreateTestDataBuffer(TestBufferSize);
    TestDataIn = VirtualAlloc(NULL, TestBufferSize, MEM_COMMIT, PAGE_READWRITE);
    if ((NULL == TestDataIn) || (NULL == TestData)) {
        Error = GetLastError();
        DebugBreak();
    }

    //
    // set the cache size to something reasonable (128k)
    //

    SizeCache(128 * 1024);
    CleanCaches();
    
    xStartVariation( LogHandle, "variation2" );
    xLog(LogHandle, XLL_INFO, "all reads  (all sizes and flags)");

    DeleteFile(OTEXT("Z:\\TestFile.prf"));

    //
    // for each flag set....
    //

    for (y = 0; y < ARRAYSIZE(FlagSets); y++) {

        //
        // and each test file size...
        //

        for (x = 0; x < ARRAYSIZE(SizeArray); x++) {

            BytesWrittenX = 0;

            //
            // create file and file data prior to read
            // also, be sure to clear all caches before the reading begins
            //

            //
            // we have to block certain writes, since they don't conform to 
            // limitations imposed by the OS
            //

            if ((FlagSets[y] & FILE_FLAG_NO_BUFFERING) && 
                (SizeArray[x] % 512)) {
                continue;
            }

            FileHandle = CreateFile(OTEXT("Z:\\TestFile.prf"),
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FlagSets[y],
                                    NULL);

            if (INVALID_HANDLE_VALUE == FileHandle) {
                xLog(LogHandle, XLL_BLOCK, "CreateFile Failed! (LastError = %d)", GetLastError());
                continue;
            }

            //
            // we have to point to an OVERLAPPED struct when appropriate
            // associate Event with struct (this is optional I believe)
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                pOverlapped = &OverLapped;
                ZeroMemory(pOverlapped, sizeof(*pOverlapped));
                if (NULL == (OverLapped.hEvent = CreateEvent(NULL, TRUE, FALSE, OTEXT("DiskPerfEvent")))) {
                    Error = GetLastError();
                    _asm int 3
                }
            } else {
                pOverlapped = NULL;
            }

            //
            // create the file data to be read
            // Fill it in
            //

            if (SizeArray[x] > TestBufferSize) {

                for (z = SizeArray[x] / TestBufferSize; z > 0; z--) {

                    bResult = WriteFile(FileHandle, 
                                        TestData,
                                        TestBufferSize,
                                        &BytesWritten,
                                        pOverlapped);

                    //
                    // if we need to wait on the event during this multi-pass write, do it here
                    //

                    if (FALSE == bResult) {

                        if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                            (ERROR_IO_PENDING == GetLastError())) {

                            bResult = GetOverlappedResult(FileHandle,
                                                          pOverlapped,
                                                          &BytesWritten,
                                                          TRUE);
                            if (FALSE == bResult) {
                                Error = GetLastError();
                                DebugBreak();
                            }

                        } else {

                            //
                            // some other error, like disk full..
                            //

                            Error = GetLastError();
                            DebugBreak();
                        }
                    }

                    //
                    // advance pointer for next write
                    //

                    if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                        pOverlapped->Offset += BytesWritten;
                    }

                    BytesWrittenX += BytesWritten;
                }
            } else {

                bResult = WriteFile(FileHandle, 
                                    TestData,
                                    SizeArray[x],
                                    &BytesWrittenX,
                                    pOverlapped);

                //
                // if we need to wait on the event during this write, do it here
                //

                if (FALSE == bResult) {

                    if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                        (ERROR_IO_PENDING == GetLastError())) {

                        bResult = GetOverlappedResult(FileHandle,
                                                      pOverlapped,
                                                      &BytesWritten,
                                                      TRUE);
                        if (FALSE == bResult) {
                            Error = GetLastError();
                            DebugBreak();
                        }

                    } else {

                        //
                        // some other error, like disk full..
                        //

                        Error = GetLastError();
                        DebugBreak();
                    }
                }
            }

            //
            // reset overlapped IO stuff
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                CloseHandle(OverLapped.hEvent);
                pOverlapped = &OverLapped;
                ZeroMemory(pOverlapped, sizeof(*pOverlapped));
                if (NULL == (OverLapped.hEvent = CreateEvent(NULL, TRUE, FALSE, OTEXT("DiskPerfEvent")))) {
                    Error = GetLastError();
                    _asm int 3
                }
            } else {
                pOverlapped = NULL;
            }

            //
            // Set the file pointer back to the beginning
            //

            SetFilePointer(FileHandle, 0L, NULL, FILE_BEGIN);

            //
            // clean out caches, reset BytesReadX counter
            //

            CleanCaches();
            BytesReadX = 0;

            //
            // start timer
            //

            StartTimer();

            //
            // read file data
            //

            if (SizeArray[x] > TestBufferSize) {

                for (z = SizeArray[x] / TestBufferSize; z > 0; z--) {

                    bResult = ReadFile(FileHandle, 
                                       TestDataIn,
                                       TestBufferSize,
                                       &BytesRead,
                                       pOverlapped);

                    //
                    // if we need to wait on the event during this multi-pass read, do it here
                    //

                    if (FALSE == bResult) {

                        if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                            (ERROR_IO_PENDING == GetLastError())) {

                            bResult = GetOverlappedResult(FileHandle,
                                                          pOverlapped,
                                                          &BytesRead,
                                                          TRUE);
                            if (FALSE == bResult) {
                                Error = GetLastError();
                                DebugBreak();
                            }

                        } else {

                            //
                            // some other error, like disk full..
                            //

                            Error = GetLastError();
                            DebugBreak();
                        }
                    }

                    //
                    // advance pointer for next read
                    //

                    if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                        pOverlapped->Offset += BytesRead;
                    }

                    BytesReadX += BytesRead;
                }
            } else {

                bResult = ReadFile(FileHandle, 
                                   TestDataIn,
                                   SizeArray[x],
                                   &BytesReadX,
                                   pOverlapped);

                //
                // if we need to wait on the event during this multi-pass read, do it here
                //

                if (FALSE == bResult) {

                    if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                        (ERROR_IO_PENDING == GetLastError())) {

                        bResult = GetOverlappedResult(FileHandle,
                                                      pOverlapped,
                                                      &BytesReadX,
                                                      TRUE);
                        if (FALSE == bResult) {
                            Error = GetLastError();
                            DebugBreak();
                        }

                    } else {

                        //
                        // some other error, like disk full..
                        //

                        Error = GetLastError();
                        DebugBreak();
                    }
                }
            }

            //
            // stop timer
            //

            Time = EndTimer();

            //
            // cleanup
            //

            CloseHandle(FileHandle);

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                CloseHandle(OverLapped.hEvent);
            }

            //
            // clean up the file
            //

            bResult = DeleteFile(OTEXT("Z:\\TestFile.prf"));

            //
            // log time
            //

            xLog(LogHandle, 
                 XLL_PASS, 
                 "Flags: 0x%8.8X Bytes Read: %10.10u Time: %10.10u ms",
                 FlagSets[y], BytesReadX, Time);
        }
    }

    //
    // free test data buffer
    //

    VirtualFree(TestData, 0, MEM_RELEASE); 
    VirtualFree(TestDataIn, 0, MEM_RELEASE); 

    xEndVariation( LogHandle );
}

VOID
WINAPI
run_var3(
    VOID
    )
/*++

Routine Description:

    writes then reads (all sizes and flags)

Arguments:

    None

Return Value:

    None
    
Notes: 
    
    this is the same as run_var2, but we don't flush the cache
    think of it as write-and-read-back
    re-use the overlapped stuff, file handle, etc.


--*/ 
{
#define TestBufferSize 0x10000
    DWORD SizeArray[] = {128, 256, 512, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000,  0x2E000000/*0xFFFF0000*/};
    DWORD FlagSets[] = {FILE_ATTRIBUTE_NORMAL,
        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_WRITE_THROUGH,
        FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_SEQUENTIAL_SCAN};
    DWORD x, y, z;
    HANDLE FileHandle;
    DWORD Time;
    PVOID TestData;
    PVOID TestDataIn;
    DWORD BytesWritten;
    DWORD BytesWrittenX;
    DWORD BytesRead;
    DWORD BytesReadX;
    OVERLAPPED OverLapped;
    OVERLAPPED *pOverlapped;
    BOOL bResult;
    DWORD Error;

    //
    // allocate and initialize test buffer
    //

    TestData = CreateTestDataBuffer(TestBufferSize);
    TestDataIn = VirtualAlloc(NULL, TestBufferSize, MEM_COMMIT, PAGE_READWRITE);
    if ((NULL == TestDataIn) || (NULL == TestData)) {
        Error = GetLastError();
        DebugBreak();
    }

    xStartVariation( LogHandle, "variation3" );
    xLog(LogHandle, XLL_INFO, "writes then reads (all sizes and flags)");

    DeleteFile(OTEXT("Z:\\TestFile.prf"));

    //
    // set the cache size to something reasonable (128k)
    //

    SizeCache(128 * 1024);
    
    //
    // for each flag set....
    //

    for (y = 0; y < ARRAYSIZE(FlagSets); y++) {

        //
        // and each test file size...
        //

        for (x = 0; x < ARRAYSIZE(SizeArray); x++) {

            BytesWrittenX = 0;

            //
            // create file and file data prior to read
            // also, be sure to clear all caches before the reading begins
            //

            CleanCaches();

            //
            // start timer
            //

            StartTimer();

            //
            // we have to block certain writes, since they don't conform to 
            // limitations imposed by the OS
            //

            if ((FlagSets[y] & FILE_FLAG_NO_BUFFERING) && 
                (SizeArray[x] % 512)) {
                continue;
            }

            FileHandle = CreateFile(OTEXT("Z:\\TestFile.prf"),
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FlagSets[y],
                                    NULL);

            if (INVALID_HANDLE_VALUE == FileHandle) {
                xLog(LogHandle, XLL_BLOCK, "CreateFile Failed! (LastError = %d)", GetLastError());
                continue;
            }

            //
            // we have to point to an OVERLAPPED struct when appropriate
            // associate Event with struct (this is optional I believe)
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                pOverlapped = &OverLapped;
                ZeroMemory(pOverlapped, sizeof(*pOverlapped));
                if (NULL == (OverLapped.hEvent = CreateEvent(NULL, TRUE, FALSE, OTEXT("DiskPerfEvent")))) {
                    Error = GetLastError();
                    _asm int 3
                }
            } else {
                pOverlapped = NULL;
            }

            //
            // create the file data to be read
            // Fill it in
            //

            if (SizeArray[x] > TestBufferSize) {

                for (z = SizeArray[x] / TestBufferSize; z > 0; z--) {

                    bResult = WriteFile(FileHandle, 
                                        TestData,
                                        TestBufferSize,
                                        &BytesWritten,
                                        pOverlapped);

                    //
                    // if we need to wait on the event during this multi-pass write, do it here
                    //

                    if (FALSE == bResult) {

                        if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                            (ERROR_IO_PENDING == GetLastError())) {

                            bResult = GetOverlappedResult(FileHandle,
                                                          pOverlapped,
                                                          &BytesWritten,
                                                          TRUE);
                            if (FALSE == bResult) {
                                Error = GetLastError();
                                DebugBreak();
                            }

                        } else {

                            //
                            // some other error, like disk full..
                            //

                            Error = GetLastError();
                            DebugBreak();
                        }
                    }

                    //
                    // advance pointer for next write
                    //

                    if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                        pOverlapped->Offset += BytesWritten;
                    }

                    BytesWrittenX += BytesWritten;
                }
            } else {

                bResult = WriteFile(FileHandle, 
                                    TestData,
                                    SizeArray[x],
                                    &BytesWrittenX,
                                    pOverlapped);

                //
                // if we need to wait on the event during this write, do it here
                //

                if (FALSE == bResult) {

                    if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                        (ERROR_IO_PENDING == GetLastError())) {

                        bResult = GetOverlappedResult(FileHandle,
                                                      pOverlapped,
                                                      &BytesWritten,
                                                      TRUE);
                        if (FALSE == bResult) {
                            Error = GetLastError();
                            DebugBreak();
                        }

                    } else {

                        //
                        // some other error, like disk full..
                        //

                        Error = GetLastError();
                        DebugBreak();
                    }
                }
            }

            //
            // Set the file pointer back to the beginning
            // 'reset' overlapped
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                pOverlapped->Internal = 0;
                pOverlapped->InternalHigh = 0;
                pOverlapped->Offset = 0;
                pOverlapped->OffsetHigh = 0;
            } else {
                SetFilePointer(FileHandle, 0L, NULL, FILE_BEGIN);
            }

            //
            // reset BytesReadX counter
            //

            BytesReadX = 0;

            //
            // read file data
            //

            if (SizeArray[x] > TestBufferSize) {

                for (z = SizeArray[x] / TestBufferSize; z > 0; z--) {

                    bResult = ReadFile(FileHandle, 
                                       TestDataIn,
                                       TestBufferSize,
                                       &BytesRead,
                                       pOverlapped);

                    //
                    // if we need to wait on the event during this multi-pass read, do it here
                    //

                    if (FALSE == bResult) {

                        if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                            (ERROR_IO_PENDING == GetLastError())) {

                            bResult = GetOverlappedResult(FileHandle,
                                                          pOverlapped,
                                                          &BytesRead,
                                                          TRUE);
                            if (FALSE == bResult) {
                                Error = GetLastError();
                                DebugBreak();
                            }

                        } else {

                            //
                            // some other error, like disk full..
                            //

                            Error = GetLastError();
                            DebugBreak();
                        }
                    }

                    //
                    // advance pointer for next read
                    //

                    if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                        pOverlapped->Offset += BytesRead;
                    }

                    BytesReadX += BytesRead;
                }
            } else {

                bResult = ReadFile(FileHandle, 
                                   TestDataIn,
                                   SizeArray[x],
                                   &BytesReadX,
                                   pOverlapped);

                //
                // if we need to wait on the event during this multi-pass read, do it here
                //

                if (FALSE == bResult) {

                    if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                        (ERROR_IO_PENDING == GetLastError())) {

                        bResult = GetOverlappedResult(FileHandle,
                                                      pOverlapped,
                                                      &BytesReadX,
                                                      TRUE);
                        if (FALSE == bResult) {
                            Error = GetLastError();
                            DebugBreak();
                        }

                    } else {

                        //
                        // some other error, like disk full..
                        //

                        Error = GetLastError();
                        DebugBreak();
                    }
                }
            }

            //
            // stop timer
            //

            Time = EndTimer();

            //
            // cleanup
            //

            CloseHandle(FileHandle);

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                CloseHandle(OverLapped.hEvent);
            }

            //
            // clean up the file
            //

            bResult = DeleteFile(OTEXT("Z:\\TestFile.prf"));

            //
            // log time
            //

            xLog(LogHandle, 
                 XLL_PASS, 
                 "Flags: 0x%8.8X Bytes Written: %10.10u Bytes Read: %10.10u Time: %10.10u ms",
                 FlagSets[y], BytesWrittenX, BytesReadX, Time);
        }
    }

    //
    // free test data buffer
    //

    VirtualFree(TestData, 0, MEM_RELEASE); 
    VirtualFree(TestDataIn, 0, MEM_RELEASE); 

    xEndVariation( LogHandle );
}

VOID
WINAPI
run_var4(
    VOID
    )
/*++

Routine Description:

    writes, then flush, then reads (all sizes and flags)

Arguments:

    None

Return Value:

    None
    
Note: 
    
    this is the same as run_var2 so we'll skip it
    just add the times for run_var1 and run_var2

--*/ 
{

}

VOID
WINAPI
run_var5(
    VOID
    )
/*++

Routine Description:

    writes then reads, using a growing file (1-750mb, 10mb steps)

Arguments:

    None

Return Value:

    None
    
Notes:

    Similar to run_var2, but the file is handled differently. 
    behaves somewhat like a page file
    extend / read

--*/ 
{
#define TestBufferSize5 (0x10000 * 20)
    DWORD FlagSets[] = {FILE_ATTRIBUTE_NORMAL,
        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_WRITE_THROUGH,
        FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_SEQUENTIAL_SCAN};
    DWORD x, y, z;
    HANDLE FileHandle;
    DWORD Time;
    PVOID TestData;
    PVOID TestDataIn;
    DWORD BytesWrittenX;
    DWORD BytesRead;
    DWORD BytesReadX = 0;
    OVERLAPPED OverLapped;
    OVERLAPPED *pOverlapped;
    BOOL bResult;
    DWORD Error;

    //
    // allocate and initialize test buffer
    //

    TestData = CreateTestDataBuffer(TestBufferSize5);
    TestDataIn = VirtualAlloc(NULL, TestBufferSize5, MEM_COMMIT, PAGE_READWRITE);
    if ((NULL == TestDataIn) || (NULL == TestData)) {
        Error = GetLastError();
        DebugBreak();
    }

    //
    // set the cache size to something reasonable (128k)
    //

    SizeCache(128 * 1024);
    
    xStartVariation( LogHandle, "variation5" );
    xLog(LogHandle, XLL_INFO, "writes then reads, using a growing file (1-1000mb, 1310720b steps)");

    //
    // for each flag set....
    //

    for (y = 0; y < ARRAYSIZE(FlagSets); y++) {

        CleanCaches();

        //
        // create file with specified flags
        //

        FileHandle = CreateFile(OTEXT("Z:\\TestFile.prf"),
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                CREATE_ALWAYS,
                                FlagSets[y],
                                NULL);

        if (INVALID_HANDLE_VALUE == FileHandle) {
            Error = GetLastError();
            _asm int 3
        }

        //
        // we have to point to an OVERLAPPED struct when appropriate
        // associate Event with struct (this is optional I believe)
        //

        if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
            pOverlapped = &OverLapped;
            ZeroMemory(pOverlapped, sizeof(*pOverlapped));
            if (NULL == (OverLapped.hEvent = CreateEvent(NULL, TRUE, FALSE, OTEXT("DiskPerfEvent")))) {
                Error = GetLastError();
                _asm int 3
            }
        } else {
            pOverlapped = NULL;
        }

        //
        // for each 10mb extension
        //

        for (x = 0; x < 75; x++) {


            //
            // start timer
            //

            StartTimer();

            //
            // append to file
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                pOverlapped->Offset = BytesReadX;
            } else {
                SetFilePointer(FileHandle, BytesReadX, NULL, FILE_BEGIN);
            }

            bResult = WriteFile(FileHandle, 
                                TestData,
                                TestBufferSize5,
                                &BytesWrittenX,
                                pOverlapped);

            //
            // if we need to wait on the event during this write, do it here
            //

            if (FALSE == bResult) {

                if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                    (ERROR_IO_PENDING == GetLastError())) {

                    bResult = GetOverlappedResult(FileHandle,
                                                  pOverlapped,
                                                  &BytesWrittenX,
                                                  TRUE);
                    if (FALSE == bResult) {
                        Error = GetLastError();
                        DebugBreak();
                    }

                } else {

                    //
                    // some other error, like disk full..
                    //

                    Error = GetLastError();
                    DebugBreak();
                }
            }

            //
            // read it all sequentially
            // Set the file pointer back to the beginning
            // 'reset' overlapped
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                pOverlapped->Offset = 0;
            } else {
                SetFilePointer(FileHandle, 0L, NULL, FILE_BEGIN);
            }

            //
            // reset BytesReadX counter
            //

            BytesReadX = 0;

            //
            // read file data
            // file pointer should be at end when done so append works
            //

            for (z = 0; z <= x; z++) {

                bResult = ReadFile(FileHandle, 
                                   TestDataIn,
                                   TestBufferSize5,
                                   &BytesRead,
                                   pOverlapped);

                //
                // if we need to wait on the event during this multi-pass read, do it here
                //

                if (FALSE == bResult) {

                    if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                        (ERROR_IO_PENDING == GetLastError())) {

                        bResult = GetOverlappedResult(FileHandle,
                                                      pOverlapped,
                                                      &BytesRead,
                                                      TRUE);
                        if (FALSE == bResult) {
                            Error = GetLastError();
                            DebugBreak();
                        }

                    } else {

                        //
                        // some other error, like disk full..
                        //

                        Error = GetLastError();
                        DebugBreak();
                    }
                }

                //
                // advance pointer for next read
                //

                if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                    pOverlapped->Offset += BytesRead;
                }

                BytesReadX += BytesRead;
            }

            //
            // stop timer
            //

            Time = EndTimer();

            //
            // log time
            //

            xLog(LogHandle, 
                 XLL_PASS, 
                 "Flags: 0x%8.8X Bytes Written: %10.10u Bytes Read: %10.10u Time: %10.10u ms",
                 FlagSets[y], BytesWrittenX, BytesReadX, Time);
        }

        //
        // cleanup
        //

        CloseHandle(FileHandle);

        if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
            CloseHandle(OverLapped.hEvent);
        }

        //
        // clean up the file
        //

        bResult = DeleteFile(OTEXT("Z:\\TestFile.prf"));
    }

    //
    // free test data buffers
    //

    VirtualFree(TestData, 0, MEM_RELEASE); 
    VirtualFree(TestDataIn, 0, MEM_RELEASE); 

    xEndVariation( LogHandle );
}

VOID
WINAPI
run_var6(
    VOID
    )
/*++

Routine Description:

    writes then reads, using a growing queue of files to thrash out the cache 
    (all sizes and flags)

Arguments:

    None

Return Value:

    None

Notes:

    using 10mb files, write one, then read all of them, 1 - TestFiles
    set the cache size to 512k

--*/ 
{
#define TestBufferSize6 (0x100000 * 10)
#define TestFiles 50
    DWORD FlagSets[] = {FILE_ATTRIBUTE_NORMAL,
        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_WRITE_THROUGH,
        FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_SEQUENTIAL_SCAN};
    DWORD x, y, z;
    HANDLE FileHandle[TestFiles] = {0};
    OVERLAPPED OverLapped[TestFiles] = {0};
    OCHAR FileNameString[MAX_PATH];
    DWORD Time;
    PVOID TestData;
    PVOID TestDataIn;
    DWORD BytesWritten;
    DWORD BytesWrittenX;
    DWORD BytesRead;
    ULONGLONG BytesReadX;
    OVERLAPPED *pOverlapped;
    BOOL bResult;
    DWORD Error;

    //
    // allocate and initialize test buffer
    //

    TestData = CreateTestDataBuffer(TestBufferSize6);
    TestDataIn = VirtualAlloc(NULL, TestBufferSize6, MEM_COMMIT, PAGE_READWRITE);
    if ((NULL == TestDataIn) || (NULL == TestData)) {
        Error = GetLastError();
        DebugBreak();
    }

    //
    // set the cache size to something reasonable (128k)
    //

    SizeCache(128 * 1024);

    xStartVariation( LogHandle, "variation6" );
    xLog(LogHandle, XLL_INFO, "writes then reads, using a growing queue of files to thrash out the cache (all sizes and flags)");

    //
    // for each flag set....
    //

    for (y = 0; y < ARRAYSIZE(FlagSets); y++) {

        CleanCaches();

        //
        // reset BytesReadX, BytesWrittenX counter
        //

        BytesReadX = 0;
        BytesWrittenX = 0;

        //
        // for each 10mb file...
        //

        //
        // start timer
        //

        StartTimer();

        for (x = 0; x < TestFiles; x++) {

            //
            // we have to point to an OVERLAPPED struct when appropriate
            // associate Event with struct (this is optional I believe)
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                pOverlapped = &OverLapped[x];
                ZeroMemory(pOverlapped, sizeof(*pOverlapped));
                if (NULL == (OverLapped->hEvent = CreateEvent(NULL, TRUE, FALSE, OTEXT("DiskPerfEvent")))) {
                    Error = GetLastError();
                    _asm int 3
                }
            } else {
                pOverlapped = NULL;
            }

            //
            // create file with specified flags
            //

            soprintf(FileNameString, OTEXT("Z:\\Test%d.prf"), x);
            FileHandle[x] = CreateFile(FileNameString,
                                       GENERIC_READ | GENERIC_WRITE,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FlagSets[y],
                                       NULL);
            if (INVALID_HANDLE_VALUE == FileHandle[x]) {
                Error = GetLastError();
                _asm int 3
            }

            //
            // write the file (this will be the only write to this file)
            //

            bResult = WriteFile(FileHandle[x], 
                                TestData,
                                TestBufferSize6,
                                &BytesWritten,
                                pOverlapped);

            //
            // if we need to wait on the event during this write, do it here
            //

            if (FALSE == bResult) {

                if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                    (ERROR_IO_PENDING == GetLastError())) {

                    bResult = GetOverlappedResult(FileHandle[x],
                                                  pOverlapped,
                                                  &BytesWritten,
                                                  TRUE);
                    if (FALSE == bResult) {
                        Error = GetLastError();
                        DebugBreak();
                    }

                } else {

                    //
                    // some other error, like disk full..
                    //

                    Error = GetLastError();
                    DebugBreak();
                }
            }

            BytesWrittenX += BytesWritten;

            //
            // set file pointer to beginning and read file data
            //

            for (z = 0; z <= x; z++) {

                if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                    pOverlapped->Offset = 0;
                    pOverlapped->OffsetHigh = 0;
                } else {
                    SetFilePointer(FileHandle[z], 0L, NULL, FILE_BEGIN);
                }

                bResult = ReadFile(FileHandle[z], 
                                   TestDataIn,
                                   TestBufferSize6,
                                   &BytesRead,
                                   pOverlapped);

                //
                // if we need to wait on the event during this multi-pass read, do it here
                //

                if (FALSE == bResult) {

                    if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                        (ERROR_IO_PENDING == GetLastError())) {

                        bResult = GetOverlappedResult(FileHandle[z],
                                                      pOverlapped,
                                                      &BytesRead,
                                                      TRUE);
                        if (FALSE == bResult) {
                            Error = GetLastError();
                            DebugBreak();
                        }

                    } else {

                        //
                        // some other error, like disk full..
                        //

                        Error = GetLastError();
                        DebugBreak();
                    }
                }

                BytesReadX += BytesRead;
            }
        }

        //
        // stop timer
        //

        Time = EndTimer();

        //
        // log time
        //

        xLog(LogHandle, 
             XLL_PASS, 
             "Flags: 0x%8.8X Bytes Written: %10.10u Bytes Read: %12.12I64u Time: %10.10u ms",
             FlagSets[y], BytesWrittenX, BytesReadX, Time);

        //
        // cleanup
        //

        for (x = 0; x < TestFiles; x++) {
            CloseHandle(FileHandle[x]);
            soprintf(FileNameString, OTEXT("Z:\\TestFile%d.prf"), x);
            DeleteFile(FileNameString);
            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                CloseHandle(OverLapped[x].hEvent);
            }
        }
    }

    //
    // free test data buffer
    //

    VirtualFree(TestData, 0, MEM_RELEASE); 
    VirtualFree(TestDataIn, 0, MEM_RELEASE); 

    xEndVariation( LogHandle );

}

VOID
WINAPI
run_var7(
    VOID
    )
/*++

Routine Description:

    CD-ROM read rate

Arguments:

    None

Return Value:

    None
    
Notes:

    basically read everything off a dvd/CD and to the hard drive, and see how 
    long it takes
    
    Crude but all we can do without custom CDs

--*/ 
{
    ULARGE_INTEGER FreeBytesAvailable;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    DWORD Time;
    ULONGLONG TotalBytesCopied = 0;
    DWORD TotalFilesCopied = 0;

    //
    // figure out the media type, and if is a CD-ROM continue
    //
    //
    if (FALSE == GetDiskFreeSpaceEx(OTEXT("a:\\"), &FreeBytesAvailable, &TotalNumberOfBytes, &TotalNumberOfFreeBytes)) {
        return; // no disk in drive or no drive
    }

    //if (TotalNumberOfBytes.LowPart > 1000000000) {
    //    return; // too big, must be a DVD
    //}

    //
    // set the cache size to something reasonable (128k)
    //

    SizeCache(128 * 1024);

    xStartVariation( LogHandle, "variation7" );
    xLog(LogHandle, XLL_INFO, "CD-ROM read rate - copied contents of CD to disk");

    //
    // start timer
    //

    StartTimer();

    //
    // do all the copies
    //

    RecursivelyDiskCopy(OTEXT("a:\\"), OTEXT("z:\\"), &TotalBytesCopied, &TotalFilesCopied, CREATE_FLAG);

    //
    // stop timer
    //

    Time = EndTimer();

    //
    // log it and calculate some simple stats
    //

    xLog(LogHandle, 
         XLL_PASS, 
         "Bytes copied: %12.12I64u  Files Copied: %10.10u Time: %10.10u ms",
         TotalBytesCopied, TotalFilesCopied, Time);

    //
    // clean up the disk
    //

    RecursivelyDiskCopy(OTEXT("a:\\"), OTEXT("z:\\"), &TotalBytesCopied, &TotalFilesCopied, DELETE_FLAG);

    xEndVariation( LogHandle );
}

typedef struct _RecursiveDiskCopyData {
    WIN32_FIND_DATA NodalFindFileData;
    OCHAR ExistingFileName[MAX_PATH];
    OCHAR NewFileName[MAX_PATH];
    OCHAR NewDirectoryName[MAX_PATH];
    OCHAR CurrentSourcePath[MAX_PATH];
    OCHAR CurrentSearchSourcePath[MAX_PATH];
    OCHAR CurrentDestPath[MAX_PATH];
} RecursiveDiskCopyData, *pRecursiveDiskCopyData;

VOID
WINAPI
RecursivelyDiskCopy(
    POCHAR source, 
    POCHAR target,
    PULONGLONG pTotalBytesCopied,
    PDWORD pTotalFilesCopied,
    DWORD CreateDeleteFlag
    )
/*++

Routine Description:

    recursivly read the data from directory-based device to another

Arguments:

    PWCHAR source - root of source device
    PWCHAR target - root of destination device
    PULONGLONG pTotalBytesCopied - pointer to variable that keeps the total number of bytes copied
    PDWORD pTotalFilesCopied - pointer to variable that keeps the total number of files copied

Return Value:

    None
    
Notes:

    need to modify to handle case when target is full
    probably just return -1 and percolate that back through to abort the traversal 
    the tricky part will be making sure we do the same thing in the copy / delete cases    

--*/ 
{
    HANDLE hNodalFile;
    BOOL bResult;
    DWORD Error;
    pRecursiveDiskCopyData pdata;
    WCHAR LogString[200 + (MAX_PATH * 2)] = {0};

    //
    // sources needs to come in with a  trailing backslash
    //

    pdata = calloc(1, sizeof(RecursiveDiskCopyData));

    if (NULL == pdata) {
        return;
    }

    ocscpy( pdata->CurrentSourcePath, source );
    ocscpy( pdata->CurrentDestPath, target );
    ocscpy( pdata->CurrentSearchSourcePath, pdata->CurrentSourcePath);
    strcat( pdata->CurrentSearchSourcePath, OTEXT("*.*"));

    hNodalFile = FindFirstFile(pdata->CurrentSearchSourcePath, &pdata->NodalFindFileData);

    if (INVALID_HANDLE_VALUE == hNodalFile) {
        Error = GetLastError();
        OutputDebugStringA( pdata->CurrentSearchSourcePath );
        OutputDebugString( L"\n" );
        OutputDebugString( TEXT("FindFirstFile() returned false - exiting node\n") );
        free(pdata);
        return;
    }

    do {

        //
        // if this is a file, copy or delete it
        //

        if (!(pdata->NodalFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

            ocscpy( pdata->NewFileName, pdata->CurrentDestPath );
            strcat( pdata->NewFileName, pdata->NodalFindFileData.cFileName );
            ocscpy( pdata->ExistingFileName, pdata->CurrentSourcePath );
            strcat( pdata->ExistingFileName, pdata->NodalFindFileData.cFileName );

            if (CREATE_FLAG == CreateDeleteFlag) {

                bResult = CopyFile(pdata->ExistingFileName, pdata->NewFileName, FALSE);

                if (FALSE == bResult) {
                    Error = GetLastError();
                    swscanf(LogString, 
                            TEXT("CopyFile(%s to %s) returned false. Error :0x%8.8X - exiting node!\n"), 
                            pdata->ExistingFileName, 
                            pdata->NewFileName, 
                            Error);
                    OutputDebugString( LogString );
                    continue;
                }

                //
                // increment the bytes copied counter
                //

                *pTotalBytesCopied += (ULONGLONG)(pdata->NodalFindFileData.nFileSizeLow);
                *pTotalBytesCopied += (ULONGLONG)(pdata->NodalFindFileData.nFileSizeHigh << 32);
                ++*pTotalFilesCopied;

            } else if (DELETE_FLAG == CreateDeleteFlag) {
                bResult = SetFileAttributes(pdata->NewFileName, FILE_ATTRIBUTE_NORMAL);
                bResult = DeleteFile(pdata->NewFileName);
                if (FALSE == bResult) {
                    Error = GetLastError();
                    swscanf(LogString, 
                            TEXT("DeleteFile(%s) returned false. Error :0x%8.8X\n"), 
                            pdata->NewFileName, 
                            Error);
                    OutputDebugString( LogString );
                }
            }
        }

        //
        // if this is a directory, go in and recurse
        //

        if (pdata->NodalFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            ocscpy( pdata->NewFileName, pdata->CurrentSourcePath );
            strcat( pdata->NewFileName, pdata->NodalFindFileData.cFileName );

            //
            // skip default dirs
            //

            if (pdata->NodalFindFileData.cFileName[0] == L'.') {
                continue;
            }

            //
            // create/delete matching target directory
            //

            ocscpy( pdata->NewDirectoryName, pdata->CurrentDestPath );
            strcat( pdata->NewDirectoryName, pdata->NodalFindFileData.cFileName );
            strcat( pdata->NewDirectoryName, OTEXT("\\" ));

            if (CREATE_FLAG == CreateDeleteFlag) {
                if (FALSE == CreateDirectory( pdata->NewDirectoryName, NULL )) {
                    continue;
                }
            }

            strcat( pdata->NewFileName, OTEXT("\\") );

            RecursivelyDiskCopy(pdata->NewFileName, 
                                pdata->NewDirectoryName, 
                                pTotalBytesCopied, 
                                pTotalFilesCopied, 
                                CreateDeleteFlag);

            if (DELETE_FLAG == CreateDeleteFlag) {
                if (FALSE == RemoveDirectory( pdata->NewDirectoryName)) {
                    Error = GetLastError();
                    swscanf(LogString, 
                            TEXT("RemoveDirectory(%s) returned false. Error :0x%8.8X\n"), 
                            pdata->NewDirectoryName, 
                            Error);
                    OutputDebugString( LogString );
                    continue;
                }
            }
            continue;
        }
    } while (FindNextFile(hNodalFile, &pdata->NodalFindFileData));

    //
    // if there are no more files or directories, return
    //

    free(pdata);
    FindClose(hNodalFile);
    return;
}

VOID
WINAPI
run_var8(
    VOID
    )
/*++

Routine Description:

    DVD read rate  (copied contents of DVD to disk)

Arguments:

    None

Return Value:

    None

--*/ 
{
    ULARGE_INTEGER FreeBytesAvailable;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    DWORD Time;
    ULONGLONG TotalBytesCopied = 0;
    DWORD TotalFilesCopied = 0;

    //
    // figure out the media type, and if is a CD-ROM continue
    //

    if (FALSE == GetDiskFreeSpaceEx(OTEXT("a:\\"), &FreeBytesAvailable, &TotalNumberOfBytes, &TotalNumberOfFreeBytes)) {
        return; // no disk in drive or no drive
    }

    if (TotalNumberOfBytes.LowPart < 1000000000) {
        return; // too small, must be a CD-ROM
    }

    //
    // set the cache size to something reasonable (128k)
    //

    SizeCache(128 * 1024);
    
    xStartVariation( LogHandle, "variation8" );
    xLog(LogHandle, XLL_INFO, "DVD read rate - copied contents of DVD to disk");

    //
    // start timer
    //

    StartTimer();

    //
    // do all the copies
    //

    RecursivelyDiskCopy(OTEXT("a:\\"), OTEXT("z:\\"), &TotalBytesCopied, &TotalFilesCopied, CREATE_FLAG);

    //
    // stop timer
    //

    Time = EndTimer();

    //
    // log it and calculate some simple stats
    //

    xLog(LogHandle, 
         XLL_PASS, 
         "Bytes copied: %12.12I64u  Files Copied: %10.10u Time: %10.10u ms",
         TotalBytesCopied, TotalFilesCopied, Time);

    //
    // clean up the disk
    //

    RecursivelyDiskCopy(OTEXT("a:\\"), OTEXT("z:\\"), &TotalBytesCopied, &TotalFilesCopied, DELETE_FLAG);

    xEndVariation( LogHandle );

}

VOID
WINAPI
run_var9(
    VOID
    )
/*++

Routine Description:

    Delete speed (especially on a full disk to simulate cache clear on startup)

Arguments:

    None

Return Value:

    None

--*/ 
{
#define TestBufferSize9 (0x1000 * 10)
#define TestFiles9 1000
    DWORD x;
    OCHAR FileNameString[MAX_PATH];
    DWORD Time;
    PVOID TestData;
    BOOL bResult;
    DWORD BytesWritten;
    DWORD Error;
    HANDLE FileHandle;

    //
    // set the cache size to something reasonable (128k)
    //

    SizeCache(128 * 1024);
    CleanCaches();

    //
    // allocate and initialize test buffer
    //

    TestData = CreateTestDataBuffer(TestBufferSize9);
    if (NULL == TestData) {
        Error = GetLastError();
        DebugBreak();
    }

    
    xStartVariation( LogHandle, "variation9" );
    xLog(LogHandle, XLL_INFO, "Delete speed (especially on a full disk to simulate cache clear on startup)");

    //
    // clean up any leftovers from the last test
    //

    for (x = 0; x < TestFiles9; x++) {
        soprintf(FileNameString, OTEXT("Z:\\Test%d.prf"), x);
        DeleteFile(FileNameString);
    }

    for (x = 0; x < TestFiles9; x++) {

        //
        // create file with specified flags
        //

        soprintf(FileNameString, OTEXT("Z:\\Test%d.prf"), x);
        FileHandle = CreateFile(FileNameString,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

        if (INVALID_HANDLE_VALUE == FileHandle) {
            Error = GetLastError();
            break;
        }

        //
        // write the file (this will be the only write to this file)
        //

        bResult = WriteFile(FileHandle, 
                            TestData,
                            TestBufferSize9,
                            &BytesWritten,
                            NULL);

        if (FALSE == bResult) {
            Error = GetLastError();
            CloseHandle(FileHandle);
            break;
        }

        CloseHandle(FileHandle);
    }

    //
    // start timer
    //

    StartTimer();

    for (x = 0; x < TestFiles9; x++) {

        soprintf(FileNameString, OTEXT("Z:\\Test%d.prf"), x);
        DeleteFile(FileNameString);

        //
        // query timer, log time every few files
        //

        if ((x % 20) == 0) {
            Time = EndTimer();
            xLog(LogHandle, XLL_PASS, "files: %d Time: %10.10u ms", x, Time);
        }
    }

    //
    // free test data buffer
    //

    VirtualFree(TestData, 0, MEM_RELEASE); 

    xEndVariation( LogHandle );
}

VOID
WINAPI
run_var10(
    VOID
    )
/*++

Routine Description:

    file create slowdown as number of files in a directory increases

Arguments:

    None

Return Value:

    None

--*/ 
{
#define TestFiles10 15000
    DWORD x;
    OCHAR FileNameString[MAX_PATH];
    DWORD Time;
    DWORD Error;
    HANDLE FileHandle;

    xStartVariation( LogHandle, "variation10" );
    xLog(LogHandle, XLL_INFO, "file create slowdown as number of files in a directory increases");

    //
    // pre-clean
    //

    for (x = 0; x < TestFiles10; x++) {
        soprintf(FileNameString, OTEXT("Z:\\Test%d.prf"), x);
        DeleteFile(FileNameString);
    }

    //
    // set the cache size to something reasonable (128k)
    //

    SizeCache(128 * 1024);
    
    CleanCaches();

    //
    // Create files, we'll use empty files
    //

    for (x = 0; x < TestFiles10; x++) {

        if ((x % 20) == 0) {

            //
            // start timer to measure this group of 20 files
            //

            StartTimer();
        }

        //
        // create file with specified flags
        //

        soprintf(FileNameString, OTEXT("Z:\\Test%d.prf"), x);
        FileHandle = CreateFile(FileNameString,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

        if (INVALID_HANDLE_VALUE == FileHandle) {
            Error = GetLastError();
            break;
        }

        CloseHandle(FileHandle);

        //
        // query timer, log time every few files
        //

        if ((x % 20) == 0) {
            Time = EndTimer();
            xLog(LogHandle, XLL_PASS, "files: %d Time: %10.10u ms", x, Time);
        }
    }

    //
    // cleanup
    //

    for (x = 0; x < TestFiles10; x++) {
        soprintf(FileNameString, OTEXT("Z:\\Test%d.prf"), x);
        DeleteFile(FileNameString);
    }
    xEndVariation( LogHandle );
}

VOID
WINAPI
run_var11(
    VOID
    )
/*++

Routine Description:

    directory create slowdown as number of directory entries increases

Arguments:

    None

Return Value:

    None

--*/ 
{
#define TestDirectories11 15000
    DWORD x;
    OCHAR DirectoryNameString[MAX_PATH];
    DWORD Time;
    DWORD Error;
    BOOL bResult;

    xStartVariation( LogHandle, "variation11" );
    xLog(LogHandle, XLL_INFO, "directory create slowdown as number of directories in a directory increases");

    //
    // pre-clean
    //

    for (x = 0; x < TestDirectories11; x++) {
        soprintf(DirectoryNameString, OTEXT("Z:\\Test%d.prf"), x);
        RemoveDirectory(DirectoryNameString);
    }

    //
    // set the cache size to something reasonable (128k)
    //

    SizeCache(128 * 1024);
    
    CleanCaches();

    //
    // Create directories, we'll use empty directories
    //

    for (x = 0; x < TestDirectories11; x++) {

        if ((x % 20) == 0) {

            //
            // start timer to measure this group of 20 directories
            //

            StartTimer();
        }

        //
        // create file with specified flags
        //

        soprintf(DirectoryNameString, OTEXT("Z:\\Test%d.prf"), x);
        bResult = CreateDirectory(DirectoryNameString, NULL);

        if (FALSE == bResult) {
            Error = GetLastError();
            break;
        }

        //
        // query timer, log time every few directories
        //

        if ((x % 20) == 0) {
            Time = EndTimer();
            xLog(LogHandle, XLL_PASS, "directories: %d Time: %10.10u ms", x, Time);
        }
    }

    //
    // cleanup
    //

    for (x = 0; x < TestDirectories11; x++) {
        soprintf(DirectoryNameString, OTEXT("Z:\\Test%d.prf"), x);
        RemoveDirectory(DirectoryNameString);
    }

    xEndVariation( LogHandle );
}

VOID
WINAPI
run_var12(
    VOID
    )
/*++

Routine Description:

    random access within a file while varying cache size

Arguments:

    None

Return Value:

    None
    
Notes:

    repeatable random access will be done by seeding with a constant
    random numbers range from 0-32767
        
    make code stop at cache sizes larger than available memory... 
    since my current test box is not like the 'real' hardware...
    

--*/ 
{
#define TestBufferSize12 0x1000000
#define FileFactorSize 20
    DWORD CacheSizes[] = {
        5000000, 
        10000000, 
        15000000, 
        20000000, 
        25000000, 
        30000000, 
        35000000, 
        40000000, 
        45000000, 
        50000000, 
        55000000
    };
    HANDLE FileHandle;
    BOOL bResult;
    PVOID TestData;
    PVOID TestDataIn;
    DWORD BytesWritten;
    DWORD CacheSize;
    DWORD BytesRead;
    DWORD TestInBufferSize12;
    DWORD FileChunks = (FileFactorSize * TestBufferSize12) / RAND_MAX;
    int x, y;
    DWORD Error;
    DWORD Time;

    //
    // read buffer size rounded to page
    //

    TestInBufferSize12 = FileChunks - (FileChunks % 0x1000);

    xStartVariation( LogHandle, "variation12" );
    xLog(LogHandle, XLL_INFO, "random access within a file while varying cache size");

    //
    // allocate and initialize test buffer
    //

    TestData = CreateTestDataBuffer(TestBufferSize12);
    TestDataIn = VirtualAlloc(NULL, TestInBufferSize12, MEM_COMMIT, PAGE_READWRITE);

    if ((NULL == TestDataIn) || (NULL == TestData)) {
        Error = GetLastError();
        DebugBreak();
    }

    //
    // create and fill file
    //

    FileHandle = CreateFile(OTEXT("Z:\\TestFile.prf"),
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,  // may want to modify this later
                            NULL);

    if (INVALID_HANDLE_VALUE == FileHandle) {
        Error = GetLastError();
        DebugBreak();
    }

    for (x = 0; x < FileFactorSize; x++) {
        bResult = WriteFile(FileHandle, 
                            TestData,
                            TestBufferSize12,
                            &BytesWritten,
                            NULL);

        if (FALSE == bResult) {
            Error = GetLastError();
            DebugBreak();
        }
    }

    VirtualFree(TestData, 0, MEM_RELEASE); 

    for (x = 0; x < ARRAYSIZE(CacheSizes); x++) {

        //
        // initialize randomizer so that each variation has the same access pattern
        //

        srand(5);

        //
        // clear cache
        //

        CleanCaches();

        //
        // limit cache size
        // the functions that do this round up to page
        //

        CacheSize = SizeCache(CacheSizes[x]);

        //
        // start timer
        //

        StartTimer();

        //
        // do searches / reads
        //

        for (y = 0; y < 10000; y++) {

            SetFilePointer(FileHandle, 
                           FileChunks * rand(), 
                           NULL, 
                           FILE_BEGIN);

            bResult = ReadFile(FileHandle, 
                               TestDataIn,
                               TestInBufferSize12,
                               &BytesRead,
                               NULL);

            if (FALSE == bResult) {
                Error = GetLastError();
                DebugBreak();
            }
        }

        //
        // stop timer
        //

        Time = EndTimer();

        //
        // log time
        //

        xLog(LogHandle, 
             XLL_PASS, 
             "cachesize: %10.10u Time: %10.10u ms",
             CacheSizes[x], Time);

        //xLogResourceStatus(LogHandle,NULL);

    }

    //
    // delete file
    //

    CloseHandle(FileHandle);
    DeleteFile(OTEXT("Z:\\TestFile.prf"));
    VirtualFree(TestDataIn, 0, MEM_RELEASE); 
    xEndVariation( LogHandle );
    return;
}

VOID
WINAPI
StartTimer(
    VOID
    )
/*++

Routine Description:

    Start the test timer and returns 

Arguments:

    None

Return Value:

    None

Notes:

    this uses a global variable so the calling function does not have to 
    maintain state. this is to make this as convienient and easy as possible 
    to use and un-clutter the calling function

--*/ 
{
    QueryPerformanceCounter(&PerformanceCount);
}

DWORD
WINAPI
EndTimer(
    VOID
    )
/*++

Routine Description:

    Ends the test timer and returns the elapsed time in Milliseconds

Arguments:

    None

Return Value:

    elapsed time in Milliseconds

--*/ 
{
    LARGE_INTEGER PerformanceCountFinish;

    QueryPerformanceCounter(&PerformanceCountFinish);
    return(DWORD)((PerformanceCountFinish.QuadPart - PerformanceCount.QuadPart) / (Frequency.QuadPart / 1000));
}

PVOID
WINAPI
CreateTestDataBuffer(
    DWORD BufferSize
    )
/*++

Routine Description:

    create our test data buffer

Arguments:

    None

Return Value:

    pointer to test buffer

Notes:

    free the buffer like this when finished with it
    VirtualFree(<whatever this function returned>, 0, MEM_RELEASE);


--*/ 
{
    PVOID FileDataBuffer;
    char *tmpPtr;
    DWORD x;

    FileDataBuffer = VirtualAlloc(NULL, BufferSize, MEM_COMMIT, PAGE_READWRITE);

    if (NULL == FileDataBuffer) {
        OutputDebugString(L"Out of memory!");
        return(NULL);
    }

    tmpPtr = FileDataBuffer;
    for (x = 1; x < BufferSize; x++) {
        *tmpPtr = (char)(x % 16);
        ++tmpPtr;
    }

    return(FileDataBuffer);
}

VOID
WINAPI
CleanCaches(
    VOID
    )
/*++

Routine Description:

    clear out processor and all disk caches

Arguments:

    None

Return Value:

    pointer to test buffer

Notes:

    relies on non-documented functions

--*/ 
{

    FlushDiskCache();
    FscInvalidateIdleBlocks();

    //
    // the following command invalidates the L1 and L2 processor caches
    //

    _asm {
        wbinvd
    }

}


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( diskperf )
#pragma data_seg()

BEGIN_EXPORT_TABLE( diskperf )
EXPORT_TABLE_ENTRY( "StartTest", DiskPerfStartTest )
EXPORT_TABLE_ENTRY( "EndTest", DiskPerfEndTest )
END_EXPORT_TABLE( diskperf )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\idelog\idelog.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    idelog.c

Abstract:

    This is a port form the idelog utility from the NT group

ported by:

    John Daly (johndaly) 25-April-2000

Environment:

    XBox

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddcdvd.h>
#include <windows.h>

#include <xtl.h>
#include <stdio.h>
#include <xlog.h>
#include <xtestlib.h>
#include <ntdddisk.h>
#include <ntddscsi.h>

VOID
PrintData(
    PIDE_IDENTIFY_DATA IdData, 
    POCHAR DeviceName
    );

VOID
WINAPI
CheckBCArea(
    VOID
    );

//
// Heap handle from HeapCreate
//
HANDLE IdeLogHeapHandle;
HANDLE LogHandle;

VOID
WINAPI
IdeLogStartTest(
         HANDLE LogHandleX
         )
/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/
{
    BOOL status;
    DWORD accessMode, shareMode;
    HANDLE fileHandle;
    PATA_PASS_THROUGH atapt;
    ULONG length,errorCode,returned;
    PIDEREGS pIdeReg;
    OCHAR    string[100];
    char    stringa[100];
    ULONG   i, j;
    int DrivesFound = 0;
    IDE_IDENTIFY_DATA idedata = {0};
    DWORD x;
    NTSTATUS NTStatus;
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING VolumeString;
    IO_STATUS_BLOCK IoStatusBlock;

    LogHandle = LogHandleX; // make this global - there is no threading intended for this

    xSetComponent( LogHandle, "kernel", "idelog" );
    xSetFunctionName(LogHandle, "StartTest" );
    xStartVariation( LogHandle, "variation1" );

    atapt = HeapAlloc(IdeLogHeapHandle, HEAP_ZERO_MEMORY | HEAP_NO_SERIALIZE, sizeof(ATA_PASS_THROUGH) + 512);

    if ( !atapt ) {
        xLog(LogHandle, XLL_BLOCK, "memory allocation failure");
        return;
    }

    for ( i=0; i<2; i++ ) {
        if ( i == 0 ) {
            soprintf (string, OTEXT("\\Device\\Harddisk0\\Partition0"));
        } else {
            soprintf (string, OTEXT("\\Device\\CdRom0"));
        }

        shareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;  // default
        accessMode = GENERIC_READ | GENERIC_WRITE;       // default

        //
        //fileHandle = CreateFile(string,
        //                        accessMode,
        //                        shareMode,
        //                        NULL,
        //                        OPEN_EXISTING,
        //                        0,
        //                        NULL);
        //

        RtlInitObjectString(&VolumeString, string);
        InitializeObjectAttributes(&ObjA,&VolumeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

        NTStatus = NtCreateFile(&fileHandle,
                                SYNCHRONIZE|GENERIC_READ,
                                &ObjA,
                                &IoStatusBlock,
                                0,
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ, FILE_OPEN,
                                FILE_SYNCHRONOUS_IO_NONALERT);

        if ( !NT_SUCCESS(NTStatus)) {
            continue;
        } else {
            ++DrivesFound;
        }

        atapt->DataBufferSize = 512;
        atapt->DataBuffer = atapt + 1;

        atapt->IdeReg.bFeaturesReg     = 0;
        atapt->IdeReg.bSectorCountReg  = 0;
        atapt->IdeReg.bSectorNumberReg = 0;
        atapt->IdeReg.bCylLowReg       = 0;
        atapt->IdeReg.bCylHighReg      = 0;
        atapt->IdeReg.bDriveHeadReg    = 0;
        atapt->IdeReg.bHostSendsData   = 0;

        if ( i == 0 ) {

            atapt->IdeReg.bCommandReg      = 0xec;

        } else {

            atapt->IdeReg.bCommandReg      = 0xa1;
        }

        status = DeviceIoControl(fileHandle,
                                 IOCTL_IDE_PASS_THROUGH,
                                 atapt,
                                 sizeof(ATA_PASS_THROUGH),
                                 atapt,
                                 sizeof(ATA_PASS_THROUGH),
                                 &returned,
                                 FALSE);
        //
        // CloseHandle(fileHandle);
        //

        NtClose(fileHandle);

        if ( status != 0 ) {
            PrintData((PIDE_IDENTIFY_DATA)atapt->DataBuffer, string);
            memset(&idedata, sizeof(IDE_IDENTIFY_DATA), 0);
        }

        //
        // Tracy's BCA test
        //
        
        if (i == 1) {
            CheckBCArea();
        }
    }

    sprintf (stringa, "DrivesFound: %d", DrivesFound);
    xLog(LogHandle, XLL_INFO, stringa);

    HeapFree (IdeLogHeapHandle, HEAP_NO_SERIALIZE, atapt);

    xEndVariation( LogHandle );

    return;
}

VOID
PrintData(
    PIDE_IDENTIFY_DATA IdData, 
    POCHAR DeviceName
    )
/*++

Routine Description:

    prints out the data colledted from an IDE device

Arguments:

    PIDENTIFY_DATA IdData : pointer to a structure containing IDE identity data
    PCHAR DeviceName : name of the device

Return Value:

    None

--*/ 
{
#define temp_buff_len   100
    UCHAR tempBuf[temp_buff_len];
    ULONG i;
    USHORT bitmap;
    ULONG mode;

    xLog(LogHandle, XLL_PASS, "%s", DeviceName);

    if ( IdData->GeneralConfiguration & (1 << 15) ) {
        xLog(LogHandle, XLL_PASS, "ATAPI device");
    } else {
        xLog(LogHandle, XLL_PASS, "ATA device");
    }

    if ( IdData->GeneralConfiguration & (1 << 7) ) {
        xLog(LogHandle, XLL_PASS, "removable media device");
    } else {
        xLog(LogHandle, XLL_PASS, "non-removable media device");
    }

    if ( IdData->MediaStatusNotification & 1 ) {

        xLog(LogHandle, XLL_PASS, "MSN supported");
    } else {

        xLog(LogHandle, XLL_PASS, "MSN not supported");
    }

    xLog(LogHandle, XLL_PASS, "ATA standard supported: ");
    bitmap = IdData->MajorRevision;
    mode = 0;
    if ( (bitmap != 0) && (bitmap != 0xffff) ) {

        bitmap >>= 1;
        while ( bitmap ) {

            if ( bitmap & 1 ) {
                xLog(LogHandle, XLL_PASS, "ATA-%d ", mode);
            }
            bitmap >>= 1;
            mode++;
        }
    } else {
        xLog(LogHandle, XLL_PASS, "none");
    }

    for ( i=0; i<sizeof(IdData->ModelNumber); i+=2 ) {
        tempBuf[i + 0] = IdData->ModelNumber[i + 1];
        tempBuf[i + 1] = IdData->ModelNumber[i + 0];
    }
    tempBuf[i] = 0;
    xLog(LogHandle, XLL_PASS, "Model Number: %s", tempBuf);

    for ( i=0; i<sizeof(IdData->SerialNumber); i+=2 ) {
        tempBuf[i + 0] = IdData->SerialNumber[i + 1];
        tempBuf[i + 1] = IdData->SerialNumber[i + 0];
    }
    tempBuf[i] = 0;
    xLog(LogHandle, XLL_PASS, "Serial Number: %s", tempBuf);

    for ( i=0; i<sizeof(IdData->FirmwareRevision); i+=2 ) {
        tempBuf[i + 0] = IdData->FirmwareRevision[i + 1];
        tempBuf[i + 1] = IdData->FirmwareRevision[i + 0];
    }
    tempBuf[i] = 0;
    xLog(LogHandle, XLL_PASS, "Firmware Revision: %s", tempBuf);

    xLog(LogHandle, XLL_PASS, "default number of logical cylinder: 0x%x (%d)", IdData->NumberOfCylinders, IdData->NumberOfCylinders);
    xLog(LogHandle, XLL_PASS, "default number of heads: 0x%x (%d)", IdData->NumberOfHeads, IdData->NumberOfHeads);
    xLog(LogHandle, XLL_PASS, "default number of sectors per track: 0x%x (%d)", IdData->NumberOfSectorsPerTrack, IdData->NumberOfSectorsPerTrack);

    if ( IdData->MaximumBlockTransfer & 0xff ) {
        xLog(LogHandle, XLL_PASS, "maximum number of sectors for READ/WRITE MULTIPLE: 0x%x (%d)", IdData->MaximumBlockTransfer, IdData->MaximumBlockTransfer & 0xf, IdData->MaximumBlockTransfer & 0xf);
    }
    if ( IdData->CurrentMultiSectorSetting & (1 << 8) ) {
        xLog(LogHandle, XLL_PASS, "current number of sectors for READ/WRITE MULTIPLE: 0x%x (%d)", IdData->MaximumBlockTransfer, IdData->MaximumBlockTransfer & 0xf, IdData->CurrentMultiSectorSetting & 0xf);
    }

    if ( IdData->Capabilities & (1 << 10) ) {
        xLog(LogHandle, XLL_PASS, "IORDY can be disabled");
    }
    if ( IdData->Capabilities & (1 << 11) ) {
        xLog(LogHandle, XLL_PASS, "IORDY is supported");
    } else {
        xLog(LogHandle, XLL_PASS, "IORDY may be supported");
    }

    xLog(LogHandle, XLL_PASS, "Highest PIO mode supported: 0x%x (%d)", IdData->PioCycleTimingMode, IdData->PioCycleTimingMode);

    if ( IdData->TranslationFieldsValid & 1 << 0 ) {

        xLog(LogHandle, XLL_PASS, "current number of logical cylinder: 0x%x (%d)", IdData->NumberOfCurrentCylinders, IdData->NumberOfCurrentCylinders);
        xLog(LogHandle, XLL_PASS, "current number of heads: 0x%x (%d)", IdData->NumberOfCurrentHeads, IdData->NumberOfCurrentHeads);
        xLog(LogHandle, XLL_PASS, "current number of sectors per track: 0x%x (%d)", IdData->CurrentSectorsPerTrack, IdData->CurrentSectorsPerTrack);
        xLog(LogHandle, XLL_PASS, "current capacity in sectors: 0x%x (%d)", IdData->CurrentSectorCapacity, IdData->CurrentSectorCapacity);
    }

    xLog(LogHandle, XLL_PASS, "total number of user addressable LBA sectors: 0x%x (%d)", IdData->UserAddressableSectors, IdData->UserAddressableSectors);

    if ( IdData->TranslationFieldsValid & (1 << 1) ) {

        xLog(LogHandle, XLL_PASS, "advanced PIO supported: ");
        bitmap = IdData->AdvancedPIOModes;
        mode = 0;
        while ( bitmap ) {

            if ( bitmap & 1 ) {
                xLog(LogHandle, XLL_PASS, "mode %d ", mode + 3);
            }
            bitmap >>= 1;
            mode++;
        }
        if ( IdData->AdvancedPIOModes ) {
            ;
        } else {
            xLog(LogHandle, XLL_PASS, "none");
        }

        xLog(LogHandle, XLL_PASS, "singleword DMA supported: ");
        bitmap = IdData->SingleWordDMASupport;
        mode = 0;
        while ( bitmap ) {

            if ( bitmap & 1 ) {
                xLog(LogHandle, XLL_PASS, "mode %d ", mode);
            }
            bitmap >>= 1;
            mode++;
        }
        if ( IdData->SingleWordDMASupport ) {
            ;
        } else {
            xLog(LogHandle, XLL_PASS, "none");
        }

        xLog(LogHandle, XLL_PASS, "singleword DMA active: ");
        bitmap = IdData->SingleWordDMAActive;
        mode = 0;
        while ( bitmap ) {

            if ( bitmap & 1 ) {
                xLog(LogHandle, XLL_PASS, "mode %d ", mode);
            }
            bitmap >>= 1;
            mode++;
        }
        if ( IdData->SingleWordDMAActive ) {
            ;
        } else {
            xLog(LogHandle, XLL_PASS, "none");
        }
    }

    xLog(LogHandle, XLL_PASS, "multiword DMA supported: ");
    bitmap = IdData->MultiWordDMASupport;
    mode = 0;
    while ( bitmap ) {

        if ( bitmap & 1 ) {
            xLog(LogHandle, XLL_PASS, "mode %d ", mode);
        }
        bitmap >>= 1;
        mode++;
    }
    if ( IdData->MultiWordDMASupport ) {
        ;
    } else {
        xLog(LogHandle, XLL_PASS, "none");
    }

    xLog(LogHandle, XLL_PASS, "multiword DMA active: ");
    bitmap = IdData->MultiWordDMAActive;
    mode = 0;
    while ( bitmap ) {

        if ( bitmap & 1 ) {
            xLog(LogHandle, XLL_PASS, "mode %d ", mode);
        }
        bitmap >>= 1;
        mode++;
    }
    if ( IdData->MultiWordDMAActive ) {
        ;
    } else {
        xLog(LogHandle, XLL_PASS, "none");
    }

    if ( IdData->TranslationFieldsValid & (1 << 1) ) {
        xLog(LogHandle, XLL_PASS, "min multiword DMA transfer cycle time (ns): 0x%x (%d)", IdData->MinimumMWXferCycleTime, IdData->MinimumMWXferCycleTime);
        xLog(LogHandle, XLL_PASS, "recommended multiword DMA transfer cycle time (ns): 0x%x (%d)", IdData->RecommendedMWXferCycleTime, IdData->RecommendedMWXferCycleTime);
        xLog(LogHandle, XLL_PASS, "min PIO transfer cycle time (ns) w/o flow control: 0x%x (%d)", IdData->MinimumPIOCycleTime, IdData->MinimumPIOCycleTime);
        xLog(LogHandle, XLL_PASS, "min PIO transfer cycle time (ns) w/ flow control: 0x%x (%d)", IdData->MinimumPIOCycleTimeIORDY, IdData->MinimumPIOCycleTimeIORDY);
    }


    if ( IdData->TranslationFieldsValid & (1 << 2) ) {

        xLog(LogHandle, XLL_PASS, "ultra DMA supported: ");
        bitmap = IdData->UltraDMASupport;
        mode = 0;
        while ( bitmap ) {

            if ( bitmap & 1 ) {
                xLog(LogHandle, XLL_PASS, "mode %d ", mode);
            }
            bitmap >>= 1;
            mode++;
        }
        if ( IdData->UltraDMASupport ) {
            ;
        } else {
            xLog(LogHandle, XLL_PASS, "none");
        }

        xLog(LogHandle, XLL_PASS, "ultra DMA active: ");
        bitmap = IdData->UltraDMAActive;
        mode = 0;
        while ( bitmap ) {

            if ( bitmap & 1 ) {
                xLog(LogHandle, XLL_PASS, "mode %d ", mode);
            }
            bitmap >>= 1;
            mode++;
        }
        if ( IdData->UltraDMAActive ) {
            ;
        } else {
            xLog(LogHandle, XLL_PASS, "none");
        }
    }

    xLog(LogHandle, XLL_PASS, "number of unformatted bytes per track: 0x%x (%d)", IdData->Reserved2[0], IdData->Reserved2[0]);
    xLog(LogHandle, XLL_PASS, "number of unformatted bytes per sector: 0x%x (%d)", IdData->Reserved2[1], IdData->Reserved2[1]);

}

VOID
WINAPI
IdeLogEndTest(
       VOID
       )
/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/ 
{
    //OutputDebugString( TEXT("IDELOG: EndTest is called\n") );
}

BOOL
WINAPI
IdeLogDllMain(
       HINSTANCE   hInstance,
       DWORD       fdwReason,
       LPVOID      lpReserved
       )
/*++

Routine Description:

    This function gets called whenever a dll is loaded, unloaded, 
    a thread created or thread exited

Arguments:

    HINSTANCE   hInstance : instance handle (The value is the base address of the DLL)
    fwdReason : DLL_PROCESS_ATTACH, DLL_THREAD_ATTACH, DLL_THREAD_DETACH,DLL_PROCESS_DETACH
    LPVOID      lpReserved : who knows!

Return Value:

    TRUE if nothing bad happened

--*/ 
{
    UNREFERENCED_PARAMETER( lpReserved );

    if ( fdwReason == DLL_PROCESS_ATTACH ) {

        IdeLogHeapHandle = HeapCreate( 0, 0, 0 );

        if ( !IdeLogHeapHandle ) {
            OutputDebugString( TEXT("IDELOG: Unable to create heap\n") );
            return(FALSE);
        }

    } else if ( fdwReason == DLL_PROCESS_DETACH ) {

        if ( IdeLogHeapHandle ) {
            HeapDestroy( IdeLogHeapHandle );
        }
    }

    return(TRUE);
}

VOID
WINAPI
CheckBCArea(
    VOID
    )
{
    HANDLE hDevice;
    DVD_READ_STRUCTURE ReadStructure;
    UCHAR BCABuffer[64];
    BOOL fResult;
    DWORD cbReturned;
    ULONG i;

    hDevice = CreateFile("cdrom0:", 
                         GENERIC_READ, 
                         FILE_SHARE_READ, 
                         NULL,
                         OPEN_EXISTING, 
                         0, 
                         NULL);

    if (hDevice != INVALID_HANDLE_VALUE) {

        ZeroMemory(&ReadStructure, sizeof(ReadStructure));

        ReadStructure.Format = DvdBCADescriptor;
        ReadStructure.LayerNumber = 0xFE;

        fResult = DeviceIoControl(hDevice, 
                                  IOCTL_DVD_READ_STRUCTURE,
                                  &ReadStructure, 
                                  sizeof(ReadStructure), 
                                  BCABuffer, 
                                  sizeof(BCABuffer),
                                  &cbReturned, NULL);

        if (fResult) {

            xLog(LogHandle, XLL_PASS, "READ BCA succeeded: cbReturned=%d\n", cbReturned);

            for (i = 0; i < sizeof(BCABuffer); i+= 8) {
                xLog(LogHandle, XLL_INFO, "%02x: %02x %02x %02x %02x %02x %02x %02x %02x\n", i,
                    BCABuffer[i + 0], BCABuffer[i + 1], BCABuffer[i + 2],
                    BCABuffer[i + 3], BCABuffer[i + 4], BCABuffer[i + 5],
                    BCABuffer[i + 6], BCABuffer[i + 7]);
            }

        } else {
            xLog(LogHandle, XLL_FAIL, "READ BCA failed: %d\n", GetLastError());
        }

        CloseHandle(hDevice);
    } else {
        xLog(LogHandle, XLL_FAIL, "CreateFile(""cdrom0:"",... Failed : %d\n", GetLastError());
    }
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( idelog )
#pragma data_seg()

BEGIN_EXPORT_TABLE( idelog )
    EXPORT_TABLE_ENTRY( "StartTest", IdeLogStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", IdeLogEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", IdeLogDllMain )
END_EXPORT_TABLE( idelog )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\mediadet\mediadet.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

   media detect - mediadet.c

Abstract:

   detect media, break if failed

Author:

   John Daly

Notes:


--*/

#include "mediadet.h"

HANDLE hDuke[XGetPortCount()] = { NULL, NULL, NULL, NULL};

void 
__cdecl 
main(
    void
    )
/*++

Routine Description:

    main

Arguments:

    void

Return Value:

    void
    
Note:

--*/ 
{
    ULARGE_INTEGER FreeBytesAvailable;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    HANDLE hFile;
    DWORD BytesRead;
    DWORD x = 0;
    ANSI_STRING ostDrive, ostPath;
    NTSTATUS status;

    XInitDevices(0, NULL);
    Sleep(2000); // Give the USB time to enumerate any attached devices

    //
    // look at the size in a:\
    // keep running log of sizes found, the person running the test has to 
    // determine what is a pass or fail detection...
    // keep 10 detection size slots open (probably only ever use 3 (0 for fail, 
    // size x for movie partition, size y for game partition))
    //

    xCreateConsole(NULL);
    xSetBackgroundImage(NULL);
    printf("        mediadet - does reboot and media detect\n");
    printf("        starting test\n");

    //
    // open the log file
    //

    hFile = CreateFileA("t:\\Counter", GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, 0, NULL);
    if (INVALID_HANDLE_VALUE == hFile) {
        DebugBreak();
    }

    ReadFile(hFile, (LPVOID)&fbuffer, sizeof(fbuffer), &BytesRead, NULL);
    // on first read this will fail, maybe check to see if we need to create then check, or don't check ever
    //if (BytesRead != sizeof(fbuffer)) {
    //    DebugBreak();
    //}

    //
    // detect controller, select reboot type, or end test and restore box
    //

    //
    // map drive c:\
    //

    RtlInitObjectString( &ostDrive, "\\??\\c:" );
    RtlInitObjectString( &ostPath, "\\Device\\Harddisk0\\Partition1" );
    status = IoCreateSymbolicLink( &ostDrive, &ostPath );
    
    RebootType = RebootMenu();

    //
    // change reboot type if neccessary
    //

    if (RebootType) {
        fbuffer.RebootType = RebootType;
    }

    //
    // get the space, and look for the appropriate slot to increment
    //

    if (FALSE == GetDiskFreeSpaceEx("A:\\",                 // directory name
                                    &FreeBytesAvailable,    // bytes available to caller
                                    &TotalNumberOfBytes,    // bytes on disk
                                    &TotalNumberOfFreeBytes // free bytes on disk
                                   )) {
        //
        // failed to read case, I am not going to assume that TotalNumberOfBytes gets set to 0...
        //

        TotalNumberOfBytes.QuadPart = 0;

    } else {

        for (x = 0; x < DATASLOTS; x++) {

            if (fbuffer.SizesDetected == x) {

                //
                // we detected a new size
                //

                ++fbuffer.SizesDetected;
                fbuffer.DetectData[x].SizeDetected.QuadPart = TotalNumberOfBytes.QuadPart;
                fbuffer.DetectData[x].SizeDetectedCount = 1;
                break;
                
            } else {

                //
                // we detected a previously detected size
                //

                if (TotalNumberOfBytes.QuadPart == fbuffer.DetectData[x].SizeDetected.QuadPart) {
                    ++fbuffer.DetectData[x].SizeDetectedCount;
                    break;
                }
            }
        }
    }

    //
    // we are at the end of the buffer, we have not overwritten, but this
    // is very unexpected and needs to be debugged
    //

    if (x == DATASLOTS) {
        DebugBreak();
    }

    DumpStats();

    sprintf(buffer, "On this iteration, size detected : %#16.16I64x\n", TotalNumberOfBytes.QuadPart);
    printf(buffer);

    SetFilePointer(hFile,0L, NULL, FILE_BEGIN);
    ++fbuffer.iteration;
    WriteFile(hFile, (LPVOID)&fbuffer, sizeof(fbuffer), &BytesRead, NULL);
    CloseHandle(hFile);
    
    //
    // let IO complete - may be unneccessary, better safe than blowing a test run
    //

    Sleep(200);

    //
    // conditionally self-reboot
    //

    if (fbuffer.RebootType == HARD_REBOOT) {
        HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_RESET, SMC_RESET_ASSERT_POWERCYCLE);
    }

    if (fbuffer.RebootType == SOFT_REBOOT) {

        //
        // boot default title, which is this app
        //

        HalReturnToFirmware(HalRebootRoutine);
    }

    if (fbuffer.RebootType == SMC_RESET) {
        HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_RESET, SMC_RESET_ASSERT_RESET);
    }

    //
    // if we return, we get to hit an asster in the CRTs because main exited
    // so we sleep instead to get the SMC time to reboot us
    //

    while (TRUE);
}

DWORD 
__cdecl 
RebootMenu(
    void
    )
/*++

Routine Description:

    RebootMenu - detect controller, if controller found, display menu and stats, fix box if neccessary

Arguments:

    void

Return Value:

    SOFT_REBOOT
    HARD_REBOOT
    0 (no controller detected)
    
Note:

    Josh did the kick-ass USB part for this
    
    input:
        
        A - run Soft reboot
        B - run Hard reboot
        X - quit and restore box
        Y - continue running currently running test
        W (White) - reset all counters
        B (Black) - use SMC_RESET reboot

--*/ 
{
    HANDLE hFile;
    BOOL bRetVal;
    DWORD returnval;
    DWORD x = 0;
    DWORD addDevice, removeDevice;

    //
    // look for restore copy of dashboard.xbx, if it is not there, copy current version to it
    //

    hFile = CreateFileA("c:\\dashboard_backup.xbx", 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (INVALID_HANDLE_VALUE == hFile) {
        bRetVal = CopyFileA("c:\\dashboard.xbx", "c:\\dashboard_backup.xbx", FALSE);

        //
        // check for failure just in case...
        //

        if (FALSE == bRetVal) {
            DebugBreak();
        }

    } else {
        CloseHandle(hFile);
    }

    //
    // look for our substitute dashboard.xbx, if it is not there, we don't run
    //

    hFile = CreateFileA("c:\\mediadet.xbx", 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (INVALID_HANDLE_VALUE == hFile) {

        //
        // add instructions for running the test someday...
        //

        DebugBreak();

    } else {
        CloseHandle(hFile);
    }

    //
    // no USB detected, return 0
    //
    
    addDevice = XGetDevices(XDEVICE_TYPE_GAMEPAD);
    if (0 == addDevice) {
        return 0;
    }

    InputDukeInsertions(addDevice, 0);
    
    //
    // present menu and stats
    //

    sprintf(buffer, "controller detected, test paused, please read the menu\nCurrent Stats:\n");
    printf(buffer);

    DumpStats();

    sprintf(buffer, "Instructions:\n");
    printf(buffer);

    sprintf(buffer, "A - run Soft reboot\n");
    printf(buffer);
    sprintf(buffer, "B - run Hard reboot\n");
    printf(buffer);
    sprintf(buffer, "B (Black) - run SMC_RESET reboot\n");
    printf(buffer);
    sprintf(buffer, "X - quit and restore box\n");
    printf(buffer);
    sprintf(buffer, "Y - continue running currently running test\n");
    printf(buffer);
    sprintf(buffer, "W (White) - reset all counters\n");
    printf(buffer);

    //
    // get input and do the right thing
    //

    while (1) {

        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);

        //
        // if A
        //

        if (InputCheckButton(XINPUT_GAMEPAD_A)) {
            bRetVal = CopyFileA("c:\\mediadet.xbx", "c:\\dashboard.xbx", FALSE);
            if (FALSE == bRetVal) {
                DebugBreak();
            }
            return SOFT_REBOOT;
        }

        //
        // if B
        //

        else if (InputCheckButton(XINPUT_GAMEPAD_B)) {
            bRetVal = CopyFileA("c:\\mediadet.xbx", "c:\\dashboard.xbx", FALSE);
            if (FALSE == bRetVal) {
                DebugBreak();
            }
            return HARD_REBOOT;
        }

        //
        // if B (black)
        //

        else if (InputCheckButton(XINPUT_GAMEPAD_BLACK)) {
            bRetVal = CopyFileA("c:\\mediadet.xbx", "c:\\dashboard.xbx", FALSE);
            if (FALSE == bRetVal) {
                DebugBreak();
            }
            return SMC_RESET;
        }

        //
        // if Y
        //

        else if (InputCheckButton(XINPUT_GAMEPAD_Y)) {
            // don't change anything
            return 0;
        }

        //
        // if WHITE
        //

        else if (InputCheckButton(XINPUT_GAMEPAD_WHITE)) {

            //
            // clear the stats
            //

            fbuffer.iteration = 0;
            fbuffer.SizesDetected = 0;
            for (x = 0; x < DATASLOTS; x++) {
                fbuffer.DetectData[x].SizeDetected.QuadPart = 0;
                fbuffer.DetectData[x].SizeDetectedCount = 0;
            }

            //
            // don't exit from here - user can press white then another selection
            //

        }

        //
        // if X
        //

        else if (InputCheckButton(XINPUT_GAMEPAD_X)) {
            bRetVal = CopyFileA("c:\\dashboard_backup.xbx", "c:\\dashboard.xbx", FALSE);

            if (FALSE == bRetVal) {
                DebugBreak();
            }

            //
            // boot default title
            //

            XLaunchNewImage(NULL, NULL);
        }

        //
        // wait for further input    
        //

        Sleep(300);
    }

    //
    // won't get hit
    //

    return(0);
}

void
__cdecl 
DumpStats(
    void
    )
/*++

Routine Description:

    DumpStats - dump current test stats

Arguments:

    void

Return Value:

    void
        
Note:


--*/ 
{
    DWORD x = 0;

    sprintf(buffer,"results so far:\niterations: %8.8d\n", fbuffer.iteration);
    printf(buffer);

    for (x = 0; x < fbuffer.SizesDetected; x++) {
        sprintf(buffer,"Detected Size:  %#16.16I64x\n", fbuffer.DetectData[x].SizeDetected.QuadPart);
        printf(buffer);
        sprintf(buffer,"Number of times detected: %8.8d\n", fbuffer.DetectData[x].SizeDetectedCount);
        printf(buffer);
    }

}


static const DWORD USBPortMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
};

void
__cdecl 
InputDukeInsertions(
    DWORD add, 
    DWORD remove
    )
/*++

Routine Description:

    InputDukeInsertions - look for Duke

Arguments:

    DWORD add
    DWORD remove

Return Value:

    void
        
Note:


--*/ 
{
    unsigned port;

    for (port=0; port<XGetPortCount(); port++) {
        if (remove & USBPortMasks[port]) {
            if (hDuke[port]) XInputClose(hDuke[port]);
            hDuke[port] = NULL;
        }
        if (add & USBPortMasks[port]) {
            hDuke[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, NULL);
        }
    }
}

BOOL
__cdecl 
InputCheckButton(
    int button
    )
/*++

Routine Description:

    InputCheckButton - look for pressed button

Arguments:

    int button

Return Value:

    void
        
Note:


--*/ 
{
    XINPUT_STATE state;
    unsigned port;

    for (port=0; port<XGetPortCount(); port++) {
        if (hDuke[port]) {
            XInputGetState(hDuke[port], &state);
            if (state.Gamepad.bAnalogButtons[button] > BUTTON_PRESS_VALUE) {
                return TRUE;
            }
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\diskperf\nt\diskperf.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    diskperf.c

Abstract:

    disk perf for xbox

written by:

    John Daly (johndaly) 13-july-2000

Environment:

    XBox - this is the nt version

Revision History:


Notes:

    yes, I know I could make this state or table driven, but it 
    will be easier to maintain like this and easier to tweak / special case / debug as well
    
    using MmDiscardCleanSystemCachePages() to have the memory manager discard 
    clean system cache pages.  Test wants this to get the cache back to a clean slate.  
    It's the responsibility of the caller to flush any volumes in order to maximum the 
    clean page count.
    
    some thing may be hard to port to NT, such as limiting / blowing away cache


--*/

#define UNICODE
#include "diskperf.h"

VOID
StartTest(
    HANDLE xLogHandle
         )
/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/ 
{
    LPVOID CacheThrottle;
    
    LogHandle = xLogHandle;
    
    //xSetComponent( LogHandle, "Harness", "diskperf" );
    //xSetFunctionName(LogHandle, "StartTest" );
    
    //
    // set up the timer
    //
    
    if (FALSE == QueryPerformanceFrequency(&Frequency)) {
        ;// log and exit
    }

    //
    // run the performance variations
    //
    

    
    //
    // test the timer
    // it seems to be pretty close, we'll use it for now
    //
    //for (x=0;x<1000;x++) {
    //    // start timer
    //    StartTimer();
    //    Sleep(x*2);
    //    Time = EndTimer();
    //    // log time
    //    xLog(LogHandle, 
    //    XLL_PASS, 
    //    "Time: %10.10u ms",
    //    Time);
    //}
    

    run_var1(); // ok
    run_var2(); // ok
    run_var3(); // ok
    run_var5(); // ok
    run_var6(); // ok
    run_var7(); // ok
    run_var8(); // ok - may need a little rework to run on machines that have 750k cache
    run_var9(); // ok
    run_var10(); // ok
    run_var11(); //ok
    run_var12();

    return;
}


VOID
EndTest(
       VOID
       )

/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/ 
{
    OutputDebugString( TEXT("diskperf: EndTest is called\n") );
}

int
__cdecl
main()
/*++

Routine Description:

    This function gets called whenever a dll is loaded, unloaded, 
    a thread created or thread exited

Arguments:

    HINSTANCE   hInstance : instance handle (The value is the base address of the DLL)
    fwdReason : DLL_PROCESS_ATTACH, DLL_THREAD_ATTACH, DLL_THREAD_DETACH,DLL_PROCESS_DETACH
    LPVOID      lpReserved : who knows!

Return Value:

    None

--*/ 
{
    HeapHandle = HeapCreate( 0, 0, 0 );
    StartTest(0);
    EndTest();
    HeapDestroy( HeapHandle );
    return(TRUE);
}

VOID
run_var1(
    VOID
    )
/*++

Routine Description:

    all writes (all sizes and flags)

Arguments:

    None

Return Value:

    None
    
Notes:

    the overlapped variation is pretty conservative, it waits for 
    each write, it could be rewritten to queue more writes and then wait
    or to use WriteFileEx and have a completion routine, and when the
    total bytes written is achieved then we know we are done

--*/ 
{
#define TestBufferSize 0x10000
    DWORD SizeArray[] = {128, 256, 512, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000,  0x2E000000/*0xFFFF0000*/};
    DWORD FlagSets[] = {FILE_ATTRIBUTE_NORMAL,
        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_WRITE_THROUGH,
        FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_SEQUENTIAL_SCAN};
    DWORD x, y, z;
    HANDLE FileHandle;
    DWORD Time;
    PVOID TestData;
    DWORD BytesWritten;
    DWORD BytesWrittenX;
    OVERLAPPED OverLapped;
    OVERLAPPED *pOverlapped;
    BOOL bResult;
    DWORD Error;

    //
    // allocate and initialize test buffer
    //

    TestData = CreateTestDataBuffer(TestBufferSize);
    if (NULL == TestData) {
        Error = GetLastError();
        DebugBreak();
    }

    //xStartVariation( LogHandle, "variation1" );
    //xLog(LogHandle, XLL_INFO, "all writes (all sizes and flags)");
    printf("all writes (all sizes and flags)\n");
    
    DeleteFile(L"TestFile.prf");

    //
    // for each flag set....
    //

    for (y = 0; y < ARRAYSIZE(FlagSets); y++) {

        //
        // and each test file size...
        //

        for (x = 0; x < ARRAYSIZE(SizeArray); x++) {
            
            //
            // clean out caches, reset BytesWrittenX count
            //

            CleanCaches();

            BytesWrittenX = 0;

            //
            // we have to block certain writes, since they don't conform to 
            // limitations imposed by the OS
            //

            if ((FlagSets[y] & FILE_FLAG_NO_BUFFERING) && 
                (SizeArray[x] % 512)) {
                continue;
            }
            
            //
            // create file
            //

            FileHandle = CreateFile(L"TestFile.prf",
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FlagSets[y],
                                    NULL);

            if (INVALID_HANDLE_VALUE == FileHandle) {
                //xLog(LogHandle, XLL_BLOCK, "CreateFile Failed! (LastError = %d)", GetLastError());
                printf("CreateFile Failed! (LastError = %d)\n", GetLastError());
                continue;
            }

            //
            // we have to point to an OVERLAPPED struct when appropriate
            // associate Event with struct (this is optional I believe)
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                pOverlapped = &OverLapped;
                ZeroMemory(pOverlapped, sizeof(*pOverlapped));
                OverLapped.hEvent = CreateEvent(NULL, TRUE, FALSE, L"DiskPerfEvent");
            } else {
                pOverlapped = NULL;
            }

            //
            // start timer
            //

            StartTimer();

            //
            // write to it
            //

            if (SizeArray[x] > TestBufferSize) {

                for (z = SizeArray[x] / TestBufferSize; z > 0; z--) {

                    bResult = WriteFile(FileHandle, 
                                        TestData,
                                        TestBufferSize,
                                        &BytesWritten,
                                        pOverlapped);

                    //
                    // if we need to wait on the event during this multi-pass write, do it here
                    //

                    if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                        (FALSE == bResult)) {

                        bResult = GetOverlappedResult(FileHandle,
                                                      pOverlapped,
                                                      &BytesWritten,
                                                      TRUE);
                        if (FALSE == bResult) {
                            Error = GetLastError();
                            DebugBreak();
                        }
                    }

                    //
                    // advance pointer for next write
                    //

                    if (FlagSets[y] & FILE_FLAG_OVERLAPPED){
                        pOverlapped->Offset += BytesWritten;
                    }

                    BytesWrittenX += BytesWritten;
                }

            } else {

                bResult = WriteFile(FileHandle, 
                                    TestData,
                                    SizeArray[x],
                                    &BytesWrittenX,
                                    pOverlapped);

                //
                // if we need to wait on the event during this write, do it here
                //

                if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) &&
                    (FALSE == bResult)) {
                    bResult = GetOverlappedResult(FileHandle,
                                                  pOverlapped,
                                                  &BytesWrittenX,
                                                  TRUE);
                    if (FALSE == bResult) {
                        Error = GetLastError();
                        DebugBreak();
                    }
                }
            }

            //
            // stop timer
            //

            Time = EndTimer();

            //
            // cleanup
            //

            CloseHandle(FileHandle);

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                CloseHandle(OverLapped.hEvent);
            }

            //
            // Clean up the file
            //

            bResult = DeleteFile(L"TestFile.prf");

            //
            // log time
            //

            //xLog(LogHandle, 
            //     XLL_PASS, 
            //     "Flags: 0x%8.8X Bytes Written: %10.10u Time: %10.10u ms",
            //     FlagSets[y], BytesWrittenX, Time);
            printf("Flags: 0x%8.8X Bytes Written: %10.10u Time: %10.10u ms\n",
                   FlagSets[y], BytesWrittenX, Time);
        }
    }

    //
    // free test data buffer
    //

    VirtualFree(TestData, 0, MEM_RELEASE); 

    //xEndVariation( LogHandle );
}

VOID
run_var2(
    VOID
    )
/*++

Routine Description:

    all reads  (all sizes and flags)

Arguments:

    None

Return Value:

    None
    
Notes:

    it may seem redundant to create files using the exact same technique used 
    in the preceding test, but it makes writing all this code go faster

--*/ 
{
#define TestBufferSize 0x10000
    DWORD SizeArray[] = {128, 256, 512, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000, 0x2E000000/*0xFFFF0000*/};
    DWORD FlagSets[] = {FILE_ATTRIBUTE_NORMAL,
        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_WRITE_THROUGH,
        FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_SEQUENTIAL_SCAN};
    DWORD x, y, z;
    HANDLE FileHandle;
    DWORD Time;
    PVOID TestData;
    PVOID TestDataIn;
    DWORD BytesWritten;
    DWORD BytesWrittenX;
    DWORD BytesRead;
    DWORD BytesReadX;
    OVERLAPPED OverLapped;
    OVERLAPPED *pOverlapped;
    BOOL bResult;
    DWORD Error;

    //
    // allocate and initialize test buffer
    //

    TestData = CreateTestDataBuffer(TestBufferSize);
    TestDataIn = VirtualAlloc(NULL, TestBufferSize, MEM_COMMIT, PAGE_READWRITE);
    if ((NULL == TestDataIn) || (NULL == TestData)) {
        Error = GetLastError();
        DebugBreak();
    }

    //xStartVariation( LogHandle, "variation2" );
    //xLog(LogHandle, XLL_INFO, "all reads  (all sizes and flags)");
    printf("all reads  (all sizes and flags)\n");

    DeleteFile(L"TestFile.prf");

    //
    // for each flag set....
    //

    for (y = 0; y < ARRAYSIZE(FlagSets); y++) {

        //
        // and each test file size...
        //

        for (x = 0; x < ARRAYSIZE(SizeArray); x++) {

            BytesWrittenX = 0;

            //
            // create file and file data prior to read
            // also, be sure to clear all caches before the reading begins
            //

            //
            // we have to block certain writes, since they don't conform to 
            // limitations imposed by the OS
            //

            if ((FlagSets[y] & FILE_FLAG_NO_BUFFERING) && 
                (SizeArray[x] % 512)) {
                continue;
            }

            FileHandle = CreateFile(L"TestFile.prf",
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FlagSets[y],
                                    NULL);

            if (INVALID_HANDLE_VALUE == FileHandle) {
                //xLog(LogHandle, XLL_BLOCK, "CreateFile Failed! (LastError = %d)", GetLastError());
                printf("CreateFile Failed! (LastError = %d)\n", GetLastError());
                continue;
            }

            //
            // we have to point to an OVERLAPPED struct when appropriate
            // associate Event with struct (this is optional I believe)
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                pOverlapped = &OverLapped;
                ZeroMemory(pOverlapped, sizeof(*pOverlapped));
                OverLapped.hEvent = CreateEvent(NULL, TRUE, FALSE, L"DiskPerfEvent");
            } else {
                pOverlapped = NULL;
            }

            //
            // create the file data to be read
            // Fill it in
            //

            if (SizeArray[x] > TestBufferSize) {

                for (z = SizeArray[x] / TestBufferSize; z > 0; z--) {

                    bResult = WriteFile(FileHandle, 
                                        TestData,
                                        TestBufferSize,
                                        &BytesWritten,
                                        pOverlapped);

                    //
                    // if we need to wait on the event during this multi-pass write, do it here
                    //

                    if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                        (FALSE == bResult)) {

                        bResult = GetOverlappedResult(FileHandle,
                                                      pOverlapped,
                                                      &BytesWritten,
                                                      TRUE);
                        if (FALSE == bResult) {
                            Error = GetLastError();
                            DebugBreak();
                        }
                    }

                    //
                    // advance pointer for next write
                    //

                    if (FlagSets[y] & FILE_FLAG_OVERLAPPED){
                        pOverlapped->Offset += BytesWritten;
                    }

                    BytesWrittenX += BytesWritten;
                }
            } else {

                bResult = WriteFile(FileHandle, 
                                    TestData,
                                    SizeArray[x],
                                    &BytesWrittenX,
                                    pOverlapped);

                //
                // if we need to wait on the event during this write, do it here
                //

                if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) &&
                    (FALSE == bResult)) {
                    bResult = GetOverlappedResult(FileHandle,
                                                  pOverlapped,
                                                  &BytesWrittenX,
                                                  TRUE);
                    if (FALSE == bResult) {
                        Error = GetLastError();
                        DebugBreak();
                    }
                }
            }

            //
            // reset overlapped IO stuff
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                CloseHandle(OverLapped.hEvent);
                pOverlapped = &OverLapped;
                ZeroMemory(pOverlapped, sizeof(*pOverlapped));
                OverLapped.hEvent = CreateEvent(NULL, TRUE, FALSE, L"DiskPerfEvent");
            } else {
                pOverlapped = NULL;
            }

            //
            // Set the file pointer back to the beginning
            //

            SetFilePointer(FileHandle, 0L, NULL, FILE_BEGIN);

            //
            // clean out caches, reset BytesReadX counter
            //

            CleanCaches();
            BytesReadX = 0;

            //
            // start timer
            //

            StartTimer();

            //
            // read file data
            //

            if (SizeArray[x] > TestBufferSize) {

                for (z = SizeArray[x] / TestBufferSize; z > 0; z--) {

                    bResult = ReadFile(FileHandle, 
                                       TestDataIn,
                                       TestBufferSize,
                                       &BytesRead,
                                       pOverlapped);

                    //
                    // if we need to wait on the event during this multi-pass read, do it here
                    //

                    if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                        (FALSE == bResult)) {

                        bResult = GetOverlappedResult(FileHandle,
                                                      pOverlapped,
                                                      &BytesRead,
                                                      TRUE);
                        if (FALSE == bResult) {
                            Error = GetLastError();
                            DebugBreak();
                        }
                    }

                    //
                    // advance pointer for next read
                    //

                    if (FlagSets[y] & FILE_FLAG_OVERLAPPED){
                        pOverlapped->Offset += BytesRead;
                    }

                    BytesReadX += BytesRead;
                }
            } else {

                bResult = ReadFile(FileHandle, 
                                   TestDataIn,
                                   SizeArray[x],
                                   &BytesReadX,
                                   pOverlapped);

                //
                // if we need to wait on the event during this multi-pass read, do it here
                //

                if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) &&
                    (FALSE == bResult)) {
                    bResult = GetOverlappedResult(FileHandle,
                                                  pOverlapped,
                                                  &BytesReadX,
                                                  TRUE);
                    if (FALSE == bResult) {
                        Error = GetLastError();
                        DebugBreak();
                    }
                }
            }

            //
            // stop timer
            //

            Time = EndTimer();

            //
            // cleanup
            //

            CloseHandle(FileHandle);

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                CloseHandle(OverLapped.hEvent);
            }

            //
            // clean up the file
            //

            bResult = DeleteFile(L"TestFile.prf");

            //
            // log time
            //

            //xLog(LogHandle, 
            //     XLL_PASS, 
            //     "Flags: 0x%8.8X Bytes Read: %10.10u Time: %10.10u ms",
            //     FlagSets[y], BytesReadX, Time);
            printf("Flags: 0x%8.8X Bytes Read: %10.10u Time: %10.10u ms\n",
                   FlagSets[y], BytesReadX, Time);
        }
    }

    //
    // free test data buffer
    //

    VirtualFree(TestData, 0, MEM_RELEASE); 
    VirtualFree(TestDataIn, 0, MEM_RELEASE); 

    //xEndVariation( LogHandle );
}

VOID
run_var3(
    VOID
    )
/*++

Routine Description:

    writes then reads (all sizes and flags)

Arguments:

    None

Return Value:

    None
    
Notes: 
    
    this is the same as run_var2, but we don't flush the cache
    think of it as write-and-read-back
    re-use the overlapped stuff, file handle, etc.


--*/ 
{
#define TestBufferSize 0x10000
    DWORD SizeArray[] = {128, 256, 512, 0x1000, 0x10000, 0x100000, 0x1000000, 0x10000000,  0x2E000000/*0xFFFF0000*/};
    DWORD FlagSets[] = {FILE_ATTRIBUTE_NORMAL,
        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_WRITE_THROUGH,
        FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_SEQUENTIAL_SCAN};
    DWORD x, y, z;
    HANDLE FileHandle;
    DWORD Time;
    PVOID TestData;
    PVOID TestDataIn;
    DWORD BytesWritten;
    DWORD BytesWrittenX;
    DWORD BytesRead;
    DWORD BytesReadX;
    OVERLAPPED OverLapped;
    OVERLAPPED *pOverlapped;
    BOOL bResult;
    DWORD Error;

    //
    // allocate and initialize test buffer
    //

    TestData = CreateTestDataBuffer(TestBufferSize);
    TestDataIn = VirtualAlloc(NULL, TestBufferSize, MEM_COMMIT, PAGE_READWRITE);
    if ((NULL == TestDataIn) || (NULL == TestData)) {
        Error = GetLastError();
        DebugBreak();
    }

    //xStartVariation( LogHandle, "variation3" );
    //xLog(LogHandle, XLL_INFO, "writes then reads (all sizes and flags)");
    printf("writes then reads (all sizes and flags)\n");

    DeleteFile(L"TestFile.prf");

    //
    // for each flag set....
    //

    for (y = 0; y < ARRAYSIZE(FlagSets); y++) {

        //
        // and each test file size...
        //

        for (x = 0; x < ARRAYSIZE(SizeArray); x++) {

            BytesWrittenX = 0;

            //
            // create file and file data prior to read
            // also, be sure to clear all caches before the reading begins
            //
            
            CleanCaches();

            //
            // start timer
            //

            StartTimer();

            //
            // we have to block certain writes, since they don't conform to 
            // limitations imposed by the OS
            //

            if ((FlagSets[y] & FILE_FLAG_NO_BUFFERING) && 
                (SizeArray[x] % 512)) {
                continue;
            }

            FileHandle = CreateFile(L"TestFile.prf",
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FlagSets[y],
                                    NULL);

            if (INVALID_HANDLE_VALUE == FileHandle) {
                //xLog(LogHandle, XLL_BLOCK, "CreateFile Failed! (LastError = %d)", GetLastError());
                printf("CreateFile Failed! (LastError = %d)\n", GetLastError());
                continue;
            }

            //
            // we have to point to an OVERLAPPED struct when appropriate
            // associate Event with struct (this is optional I believe)
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                pOverlapped = &OverLapped;
                ZeroMemory(pOverlapped, sizeof(*pOverlapped));
                OverLapped.hEvent = CreateEvent(NULL, TRUE, FALSE, L"DiskPerfEvent");
            } else {
                pOverlapped = NULL;
            }

            //
            // create the file data to be read
            // Fill it in
            //

            if (SizeArray[x] > TestBufferSize) {

                for (z = SizeArray[x] / TestBufferSize; z > 0; z--) {

                    bResult = WriteFile(FileHandle, 
                                        TestData,
                                        TestBufferSize,
                                        &BytesWritten,
                                        pOverlapped);

                    //
                    // if we need to wait on the event during this multi-pass write, do it here
                    //

                    if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                        (FALSE == bResult)) {

                        bResult = GetOverlappedResult(FileHandle,
                                                      pOverlapped,
                                                      &BytesWritten,
                                                      TRUE);
                        if (FALSE == bResult) {
                            Error = GetLastError();
                            DebugBreak();
                        }
                    }

                    //
                    // advance pointer for next write
                    //

                    if (FlagSets[y] & FILE_FLAG_OVERLAPPED){
                        pOverlapped->Offset += BytesWritten;
                    }

                    BytesWrittenX += BytesWritten;
                }
            } else {

                bResult = WriteFile(FileHandle, 
                                    TestData,
                                    SizeArray[x],
                                    &BytesWrittenX,
                                    pOverlapped);

                //
                // if we need to wait on the event during this write, do it here
                //

                if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) &&
                    (FALSE == bResult)) {
                    bResult = GetOverlappedResult(FileHandle,
                                                  pOverlapped,
                                                  &BytesWrittenX,
                                                  TRUE);
                    if (FALSE == bResult) {
                        Error = GetLastError();
                        DebugBreak();
                    }
                }
            }

            //
            // Set the file pointer back to the beginning
            // 'reset' overlapped
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                pOverlapped->Internal = 0;
                pOverlapped->InternalHigh = 0;
                pOverlapped->Offset = 0;
                pOverlapped->OffsetHigh = 0;
            } else {
                SetFilePointer(FileHandle, 0L, NULL, FILE_BEGIN);
            }

            //
            // reset BytesReadX counter
            //

            BytesReadX = 0;

            //
            // read file data
            //

            if (SizeArray[x] > TestBufferSize) {

                for (z = SizeArray[x] / TestBufferSize; z > 0; z--) {

                    bResult = ReadFile(FileHandle, 
                                       TestDataIn,
                                       TestBufferSize,
                                       &BytesRead,
                                       pOverlapped);

                    //
                    // if we need to wait on the event during this multi-pass read, do it here
                    //

                    if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                        (FALSE == bResult)) {

                        bResult = GetOverlappedResult(FileHandle,
                                                      pOverlapped,
                                                      &BytesRead,
                                                      TRUE);
                        if (FALSE == bResult) {
                            Error = GetLastError();
                            DebugBreak();
                        }
                    }

                    //
                    // advance pointer for next read
                    //

                    if (FlagSets[y] & FILE_FLAG_OVERLAPPED){
                        pOverlapped->Offset += BytesRead;
                    }

                    BytesReadX += BytesRead;
                }
            } else {

                bResult = ReadFile(FileHandle, 
                                   TestDataIn,
                                   SizeArray[x],
                                   &BytesReadX,
                                   pOverlapped);

                //
                // if we need to wait on the event during this multi-pass read, do it here
                //

                if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) &&
                    (FALSE == bResult)) {
                    bResult = GetOverlappedResult(FileHandle,
                                                  pOverlapped,
                                                  &BytesReadX,
                                                  TRUE);
                    if (FALSE == bResult) {
                        Error = GetLastError();
                        DebugBreak();
                    }
                }
            }

            //
            // stop timer
            //

            Time = EndTimer();

            //
            // cleanup
            //

            CloseHandle(FileHandle);

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                CloseHandle(OverLapped.hEvent);
            }

            //
            // clean up the file
            //

            bResult = DeleteFile(L"TestFile.prf");

            //
            // log time
            //

            //xLog(LogHandle, 
            //     XLL_PASS, 
            //     "Flags: 0x%8.8X Bytes Written: %10.10u Bytes Read: %10.10u Time: %10.10u ms",
            //     FlagSets[y], BytesWrittenX, BytesReadX, Time);
            printf("Flags: 0x%8.8X Bytes Written: %10.10u Bytes Read: %10.10u Time: %10.10u ms\n",
                 FlagSets[y], BytesWrittenX, BytesReadX, Time);
        }
    }

    //
    // free test data buffer
    //

    VirtualFree(TestData, 0, MEM_RELEASE); 
    VirtualFree(TestDataIn, 0, MEM_RELEASE); 

    //xEndVariation( LogHandle );
}

VOID
run_var4(
    VOID
    )
/*++

Routine Description:

    writes, then flush, then reads (all sizes and flags)

Arguments:

    None

Return Value:

    None
    
Note: 
    
    this is the same as run_var2 so we'll skip it
    just add the times for run_var1 and run_var2

--*/ 
{

}

VOID
run_var5(
    VOID
    )
/*++

Routine Description:

    writes then reads, using a growing file (1-1000mb, 10mb steps)

Arguments:

    None

Return Value:

    None
    
Notes:

    Similar to run_var2, but the file is handled differently. 
    behaves somewhat like a page file
    extend / read

--*/ 
{
    #define TestBufferSize5 (0x10000 * 20)
    DWORD FlagSets[] = {FILE_ATTRIBUTE_NORMAL,
        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_WRITE_THROUGH,
        FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_SEQUENTIAL_SCAN};
    DWORD x, y, z;
    HANDLE FileHandle;
    DWORD Time;
    PVOID TestData;
    PVOID TestDataIn;
    DWORD BytesWritten;
    DWORD BytesWrittenX;
    DWORD BytesRead;
    DWORD BytesReadX = 0;
    OVERLAPPED OverLapped;
    OVERLAPPED *pOverlapped;
    BOOL bResult;
    DWORD Error;

    //
    // allocate and initialize test buffer
    //

    TestData = CreateTestDataBuffer(TestBufferSize5);
    TestDataIn = VirtualAlloc(NULL, TestBufferSize5, MEM_COMMIT, PAGE_READWRITE);
    if ((NULL == TestDataIn) || (NULL == TestData)) {
        Error = GetLastError();
        DebugBreak();
    }

    //xStartVariation( LogHandle, "variation5" );
    //xLog(LogHandle, XLL_INFO, "writes then reads, using a growing file (1-1000mb, 1310720b steps)");
    printf("writes then reads, using a growing file (1-1000mb, 1310720b steps)\n");
    
    //
    // for each flag set....
    //

    for (y = 0; y < ARRAYSIZE(FlagSets); y++) {

        CleanCaches();

        //
        // create file with specified flags
        //

        FileHandle = CreateFile(L"TestFile.prf",
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                CREATE_ALWAYS,
                                FlagSets[y],
                                NULL);

        //
        // we have to point to an OVERLAPPED struct when appropriate
        // associate Event with struct (this is optional I believe)
        //

        if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
            pOverlapped = &OverLapped;
            ZeroMemory(pOverlapped, sizeof(*pOverlapped));
            OverLapped.hEvent = CreateEvent(NULL, TRUE, FALSE, L"DiskPerfEvent");
        } else {
            pOverlapped = NULL;
        }

        //
        // for each 10mb extension
        //

        for (x = 0; x < 100; x++) {


            //
            // start timer
            //

            StartTimer();

            //
            // append to file
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                pOverlapped->Offset = BytesReadX;
            } else {
                SetFilePointer(FileHandle, BytesReadX, NULL, FILE_BEGIN);
            }

            bResult = WriteFile(FileHandle, 
                                TestData,
                                TestBufferSize5,
                                &BytesWrittenX,
                                pOverlapped);

            //
            // if we need to wait on the event during this write, do it here
            //

            if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) &&
                (FALSE == bResult)) {
                bResult = GetOverlappedResult(FileHandle,
                                              pOverlapped,
                                              &BytesWrittenX,
                                              TRUE);
                if (FALSE == bResult) {
                    Error = GetLastError();
                    DebugBreak();
                }
            }

            //
            // read it all sequentially
            // Set the file pointer back to the beginning
            // 'reset' overlapped
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                pOverlapped->Offset = 0;
            } else {
                SetFilePointer(FileHandle, 0L, NULL, FILE_BEGIN);
            }

            //
            // reset BytesReadX counter
            //

            BytesReadX = 0;

            //
            // read file data
            // file pointer should be at end when done so append works
            //

            for (z = 0; z <= x; z++) {

                bResult = ReadFile(FileHandle, 
                                       TestDataIn,
                                       TestBufferSize5,
                                       &BytesRead,
                                       pOverlapped);

                //
                // if we need to wait on the event during this multi-pass read, do it here
                //

                if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                    (FALSE == bResult)) {

                    bResult = GetOverlappedResult(FileHandle,
                                                  pOverlapped,
                                                  &BytesRead,
                                                  TRUE);
                    if (FALSE == bResult) {
                        Error = GetLastError();
                        DebugBreak();
                    }
                }

                //
                // advance pointer for next read
                //

                if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                    pOverlapped->Offset += BytesRead;
                }

                BytesReadX += BytesRead;
            }
            
            //
            // stop timer
            //

            Time = EndTimer();

            //
            // log time
            //

            //xLog(LogHandle, 
            //     XLL_PASS, 
            //     "Flags: 0x%8.8X Bytes Written: %10.10u Bytes Read: %10.10u Time: %10.10u ms",
            //     FlagSets[y], BytesWrittenX, BytesReadX, Time);
            printf("Flags: 0x%8.8X Bytes Written: %10.10u Bytes Read: %10.10u Time: %10.10u ms\n",
                  FlagSets[y], BytesWrittenX, BytesReadX, Time);
        }

        //
        // cleanup
        //

        CloseHandle(FileHandle);

        if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
            CloseHandle(OverLapped.hEvent);
        }

        //
        // clean up the file
        //

        bResult = DeleteFile(L"TestFile.prf");
    }

    //
    // free test data buffers
    //

    VirtualFree(TestData, 0, MEM_RELEASE); 
    VirtualFree(TestDataIn, 0, MEM_RELEASE); 

    //xEndVariation( LogHandle );
}

VOID
run_var6(
    VOID
    )
/*++

Routine Description:

    writes then reads, using a growing queue of files to thrash out the cache 
    (all sizes and flags)

Arguments:

    None

Return Value:

    None

Notes:

    using 10mb files, write one, then read all of them, 1 - 100

--*/ 
{
    #define TestBufferSize6 (0x100000 * 10)
    #define TestFiles 50
    DWORD FlagSets[] = {FILE_ATTRIBUTE_NORMAL,
        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_WRITE_THROUGH,
        FILE_FLAG_NO_BUFFERING,
        FILE_FLAG_SEQUENTIAL_SCAN};
    DWORD x, y, z;
    HANDLE FileHandle[TestFiles] = {0};
    OVERLAPPED OverLapped[TestFiles] = {0};
    WCHAR FileNameString[MAX_PATH];
    DWORD Time;
    PVOID TestData;
    PVOID TestDataIn;
    DWORD BytesWritten;
    DWORD BytesWrittenX;
    DWORD BytesRead;
    ULONGLONG BytesReadX;
    OVERLAPPED *pOverlapped;
    BOOL bResult;
    DWORD Error;

    //
    // allocate and initialize test buffer
    //

    TestData = CreateTestDataBuffer(TestBufferSize6);
    TestDataIn = VirtualAlloc(NULL, TestBufferSize6, MEM_COMMIT, PAGE_READWRITE);
    if ((NULL == TestDataIn) || (NULL == TestData)) {
        Error = GetLastError();
        DebugBreak();
    }

    //xStartVariation( LogHandle, "variation6" );
    //xLog(LogHandle, XLL_INFO, "writes then reads, using a growing queue of files to thrash out the cache (all sizes and flags)");
    printf("writes then reads, using a growing queue of files to thrash out the cache (all sizes and flags)\n");

    //
    // for each flag set....
    //

    for (y = 0; y < ARRAYSIZE(FlagSets); y++) {

        CleanCaches();

        //
        // reset BytesReadX, BytesWrittenX counter
        //

        BytesReadX = 0;
        BytesWrittenX = 0;

        //
        // for each 10mb file...
        //

        //
        // start timer
        //

        StartTimer();

        for (x = 0; x < TestFiles; x++) {

            //
            // we have to point to an OVERLAPPED struct when appropriate
            // associate Event with struct (this is optional I believe)
            //

            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                pOverlapped = &OverLapped[x];
                ZeroMemory(pOverlapped, sizeof(*pOverlapped));
                pOverlapped->hEvent = CreateEvent(NULL, TRUE, FALSE, L"DiskPerfEvent");
            } else {
                pOverlapped = NULL;
            }

            //
            // create file with specified flags
            //

            swprintf(FileNameString, L"TestFile%d.prf", x);
            FileHandle[x] = CreateFile(FileNameString,
                                       GENERIC_READ | GENERIC_WRITE,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FlagSets[y],
                                       NULL);

            //
            // write the file (this will be the only write to this file)
            //

            bResult = WriteFile(FileHandle[x], 
                                TestData,
                                TestBufferSize6,
                                &BytesWritten,
                                pOverlapped);

            //
            // if we need to wait on the event during this write, do it here
            //

            if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) &&
                (FALSE == bResult)) {
                bResult = GetOverlappedResult(FileHandle[x],
                                              pOverlapped,
                                              &BytesWritten,
                                              TRUE);
                if (FALSE == bResult) {
                    Error = GetLastError();
                    DebugBreak();
                }
            }

            BytesWrittenX += BytesWritten;

            //
            // set file pointer to beginning and read file data
            //

            for (z = 0; z <= x; z++) {

                if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                    pOverlapped->Offset = 0;
                    pOverlapped->OffsetHigh = 0;
                } else {
                    SetFilePointer(FileHandle[z], 0L, NULL, FILE_BEGIN);
                }

                bResult = ReadFile(FileHandle[z], 
                                   TestDataIn,
                                   TestBufferSize6,
                                   &BytesRead,
                                   pOverlapped);

                //
                // if we need to wait on the event during this multi-pass read, do it here
                //

                if ((FlagSets[y] & FILE_FLAG_OVERLAPPED) && 
                    (FALSE == bResult)) {

                    bResult = GetOverlappedResult(FileHandle[z],
                                                  pOverlapped,
                                                  &BytesRead,
                                                  TRUE);
                    if (FALSE == bResult) {
                        Error = GetLastError();
                        DebugBreak();
                    }
                }
                BytesReadX += BytesRead;
            }
        }

        //
        // stop timer
        //

        Time = EndTimer();

        //
        // log time
        //

        //xLog(LogHandle, 
        //     XLL_PASS, 
        //     "Flags: 0x%8.8X Bytes Written: %10.10u Bytes Read: %12.12I64u Time: %10.10u ms",
        //     FlagSets[y], BytesWrittenX, BytesReadX, Time);
        printf("Flags: 0x%8.8X Bytes Written: %10.10u Bytes Read: %12.12I64u Time: %10.10u ms\n",
             FlagSets[y], BytesWrittenX, BytesReadX, Time);

        //
        // cleanup
        //

        for (x = 0; x < TestFiles; x++) {
            CloseHandle(FileHandle[x]);
            swprintf(FileNameString, L"TestFile%d.prf", x);
            DeleteFile(FileNameString);
            if (FlagSets[y] & FILE_FLAG_OVERLAPPED) {
                CloseHandle(OverLapped[x].hEvent);
            }
        }
    }

    //
    // free test data buffer
    //

    VirtualFree(TestData, 0, MEM_RELEASE); 
    VirtualFree(TestDataIn, 0, MEM_RELEASE); 

    //xEndVariation( LogHandle );

}

VOID
run_var7(
    VOID
    )
/*++

Routine Description:

    CD-ROM read rate

Arguments:

    None

Return Value:

    None
    
Notes:

    basically read everything off a CD and to the hard drive, and see how 
    long it takes
    
    Crude but all we can do without custom CDs

--*/ 
{
    BOOL bResult;
    ULARGE_INTEGER FreeBytesAvailable;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    DWORD Time;
    ULONGLONG TotalBytesCopied = 0;
    DWORD TotalFilesCopied = 0;

    //
    // figure out the media type, and if is a CD-ROM continue
    //

    if ( FALSE == GetDiskFreeSpaceEx(L"d:\\", &FreeBytesAvailable, &TotalNumberOfBytes, &TotalNumberOfFreeBytes) ) {
        return; // no disk in drive or no drive
    }

    if ( TotalNumberOfBytes.LowPart > 1000000000 ) {
        return; // too big, must be a DVD
    }

    //xStartVariation( LogHandle, "variation7" );
    //xLog(LogHandle, XLL_INFO, "CD-ROM read rate - copied contents of CD to disk");
    printf("CD-ROM read rate - copied contents of CD to disk\n");

    //
    // start timer
    //

    StartTimer();

    //
    // do all the copies
    //

    RecursivelyDiskCopy(L"d:\\", L"..", &TotalBytesCopied, &TotalFilesCopied, CREATE_FLAG);

    //
    // stop timer
    //

    Time = EndTimer();

    //
    // log it and calculate some simple stats
    //

    //xLog(LogHandle, 
    //     XLL_PASS, 
    //     "Bytes copied: %12.12I64u  Files Copied: %10.10u Time: %10.10u ms",
    //     TotalBytesCopied, TotalFilesCopied, Time);
    printf("Bytes copied: %12.12I64u  Files Copied: %10.10u Time: %10.10u ms\n",
         TotalBytesCopied, TotalFilesCopied, Time);

    //
    // clean up the disk
    //

    RecursivelyDiskCopy(L"d:\\", L"..", &TotalBytesCopied, &TotalFilesCopied, DELETE_FLAG);

    //xEndVariation( LogHandle );
}

typedef struct _RecursiveDiskCopyData {
    WIN32_FIND_DATA NodalFindFileData;
    WCHAR ExistingFileName[MAX_PATH];
    WCHAR NewFileName[MAX_PATH];
    WCHAR NewDirectoryName[MAX_PATH];
    WCHAR CurrentSourcePath[MAX_PATH];
    WCHAR CurrentSearchSourcePath[MAX_PATH];
    WCHAR CurrentDestPath[MAX_PATH];
} RecursiveDiskCopyData, *pRecursiveDiskCopyData;

VOID
RecursivelyDiskCopy(
    PWCHAR source, 
    PWCHAR target,
    PULONGLONG pTotalBytesCopied,
    PDWORD pTotalFilesCopied,
    DWORD CreateDeleteFlag
    )
/*++

Routine Description:

    recursivly read the data from directory-based device to another

Arguments:

    PWCHAR source - root of source device
    PWCHAR target - root of destination device
    PULONGLONG pTotalBytesCopied - pointer to variable that keeps the total number of bytes copied
    PDWORD pTotalFilesCopied - pointer to variable that keeps the total number of files copied

Return Value:

    None
    
Notes:
    

--*/ 
{
    HANDLE hNodalFile;
    BOOL bResult;
    DWORD Error;
    pRecursiveDiskCopyData pdata;

    //
    // sources needs to come in with a  trailing backslash
    //

    pdata = calloc(1, sizeof(RecursiveDiskCopyData));

    if ( NULL == pdata ) {
        return;
    }

    wcscpy( pdata->CurrentSourcePath, source );
    wcscpy( pdata->CurrentDestPath, target );
    wcscpy( pdata->CurrentSearchSourcePath, pdata->CurrentSourcePath);
    wcscat( pdata->CurrentSearchSourcePath, L"*.*");

    hNodalFile = FindFirstFile(pdata->CurrentSearchSourcePath, &pdata->NodalFindFileData);

    if ( INVALID_HANDLE_VALUE == hNodalFile ) {
        Error = GetLastError();
        OutputDebugString( pdata->CurrentSearchSourcePath );
        OutputDebugString( L"\n" );
        OutputDebugString( TEXT("FindFirstFile() returned false - exiting node\n") );
        free(pdata);
        return;
    }

    do {

        //
        // if this is a file, copy or delete it
        //

        if ( !(pdata->NodalFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

            wcscpy( pdata->NewFileName, pdata->CurrentDestPath );
            wcscat( pdata->NewFileName, pdata->NodalFindFileData.cFileName );
            wcscpy( pdata->ExistingFileName, pdata->CurrentSourcePath );
            wcscat( pdata->ExistingFileName, pdata->NodalFindFileData.cFileName );

            if ( CREATE_FLAG == CreateDeleteFlag ) {

                bResult = CopyFile(pdata->ExistingFileName, pdata->NewFileName, FALSE);

                if ( FALSE == bResult ) {
                    Error = GetLastError();
                    OutputDebugString( TEXT("CopyFile() returned false - exiting node\n") );
                    continue;
                }

                //
                // increment the bytes copied counter
                //

                *pTotalBytesCopied += (ULONGLONG)(pdata->NodalFindFileData.nFileSizeLow);
                *pTotalBytesCopied += (ULONGLONG)(pdata->NodalFindFileData.nFileSizeHigh << 32);
                ++*pTotalFilesCopied;

            } else if ( DELETE_FLAG == CreateDeleteFlag ) {
                bResult = SetFileAttributes(pdata->NewFileName, FILE_ATTRIBUTE_NORMAL);
                bResult = DeleteFile(pdata->NewFileName);
                if ( FALSE == bResult ) {
                    Error = GetLastError();
                    OutputDebugString( TEXT("DeleteFile() returned false\n") );
                }
            }
        }

        //
        // if this is a directory, go in and recurse
        //

        if ( pdata->NodalFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

            wcscpy( pdata->NewFileName, pdata->CurrentSourcePath );
            wcscat( pdata->NewFileName, pdata->NodalFindFileData.cFileName );

            //
            // skip default dirs
            //

            if ( pdata->NodalFindFileData.cFileName[0] == L'.' ) {
                continue;
            }

            //
            // create/delete matching target directory
            //

            wcscpy( pdata->NewDirectoryName, pdata->CurrentDestPath );
            wcscat( pdata->NewDirectoryName, pdata->NodalFindFileData.cFileName );
            wcscat( pdata->NewDirectoryName, L"\\" );

            if ( CREATE_FLAG == CreateDeleteFlag ) {
                if ( FALSE == CreateDirectory( pdata->NewDirectoryName, NULL ) ) {
                    continue;
                }
            }

            wcscat( pdata->NewFileName, L"\\" );

            RecursivelyDiskCopy(pdata->NewFileName, 
                                pdata->NewDirectoryName, 
                                pTotalBytesCopied, 
                                pTotalFilesCopied, 
                                CreateDeleteFlag);

            if ( DELETE_FLAG == CreateDeleteFlag ) {
                if ( FALSE == RemoveDirectory( pdata->NewDirectoryName) ) {
                    Error = GetLastError();
                    OutputDebugString( TEXT("RemoveDirectory() returned false - exiting node\n") );
                    continue;
                }
            }
            continue;
        }
    } while ( FindNextFile(hNodalFile, &pdata->NodalFindFileData) );

    //
    // if there are no more files or directories, return
    //

    free(pdata);
    FindClose(hNodalFile);
    return;
}

VOID
run_var8(
    VOID
    )
/*++

Routine Description:

    DVD read rate  (copied contents of DVD to disk)

Arguments:

    None

Return Value:

    None

--*/ 
{
    BOOL bResult;
    ULARGE_INTEGER FreeBytesAvailable;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    DWORD Time;
    ULONGLONG TotalBytesCopied = 0;
    DWORD TotalFilesCopied = 0;

    //
    // figure out the media type, and if is a CD-ROM continue
    //

    if ( FALSE == GetDiskFreeSpaceEx(L"d:\\", &FreeBytesAvailable, &TotalNumberOfBytes, &TotalNumberOfFreeBytes) ) {
        return; // no disk in drive or no drive
    }

    if ( TotalNumberOfBytes.LowPart < 1000000000 ) {
        return; // too small, must be a CD-ROM
    }

    //xStartVariation( LogHandle, "variation7" );
    //xLog(LogHandle, XLL_INFO, "DVD read rate - copied contents of DVD to disk");
    printf("DVD read rate - copied contents of DVD to disk\n");

    //
    // start timer
    //

    StartTimer();

    //
    // do all the copies
    //

    RecursivelyDiskCopy(L"d:\\", L"..", &TotalBytesCopied, &TotalFilesCopied, CREATE_FLAG);

    //
    // stop timer
    //

    Time = EndTimer();

    //
    // log it and calculate some simple stats
    //

    //xLog(LogHandle, 
    //     XLL_PASS, 
    //     "Bytes copied: %12.12I64u  Files Copied: %10.10u Time: %10.10u ms",
    //     TotalBytesCopied, TotalFilesCopied, Time);
    printf("Bytes copied: %12.12I64u  Files Copied: %10.10u Time: %10.10u ms\n",
         TotalBytesCopied, TotalFilesCopied, Time);

    //
    // clean up the disk
    //

    RecursivelyDiskCopy(L"d:\\", L"..", &TotalBytesCopied, &TotalFilesCopied, DELETE_FLAG);

    //xEndVariation( LogHandle );

}

VOID
run_var9(
    VOID
    )
/*++

Routine Description:

    Delete speed (especially on a full disk to simulate cache clear on startup)

Arguments:

    None

Return Value:

    None

--*/ 
{
#define TestBufferSize9 (0x1000 * 10)
#define TestFiles9 1000
    DWORD x;
    WCHAR FileNameString[MAX_PATH];
    DWORD Time;
    PVOID TestData;
    BOOL bResult;
    DWORD BytesWritten;
    DWORD Error;
    HANDLE FileHandle;

    //
    // allocate and initialize test buffer
    //
    
    CleanCaches();

    TestData = CreateTestDataBuffer(TestBufferSize9);
    if (NULL == TestData) {
        Error = GetLastError();
        DebugBreak();
    }

    //xStartVariation( LogHandle, "variation9" );
    //xLog(LogHandle, XLL_INFO, "Delete speed (especially on a full disk to simulate cache clear on startup)");
    printf("Delete speed (especially on a full disk to simulate cache clear on startup)\n");

    //
    // clean up any leftovers from the last test
    //

    for (x = 0; x < TestFiles9; x++) {
        swprintf(FileNameString, L"Test%d.prf", x);
        DeleteFile(FileNameString);
    }

    for (x = 0; x < TestFiles9; x++) {

        //
        // create file with specified flags
        //

        swprintf(FileNameString, L"Test%d.prf", x);
        FileHandle = CreateFile(FileNameString,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

        if (INVALID_HANDLE_VALUE == FileHandle) {
            Error = GetLastError();
            break;
        }

        //
        // write the file (this will be the only write to this file)
        //

        bResult = WriteFile(FileHandle, 
                            TestData,
                            TestBufferSize9,
                            &BytesWritten,
                            NULL);

        if (FALSE == bResult) {
            Error = GetLastError();
            CloseHandle(FileHandle);
            break;
        }

        CloseHandle(FileHandle);
    }

    //
    // start timer
    //

    StartTimer();

    for (x = 0; x < TestFiles9; x++) {

        swprintf(FileNameString, L"Test%d.prf", x);
        DeleteFile(FileNameString);

        //
        // query timer, log time every few files
        //

        if ((x % 20) == 0) {
            Time = EndTimer();
            //xLog(LogHandle, XLL_PASS, "files: %d Time: %10.10u ms", x, Time);
            printf("files: %d Time: %10.10u ms\n", x, Time);
        }
    }

    //
    // free test data buffer
    //

    VirtualFree(TestData, 0, MEM_RELEASE); 

    //xEndVariation( LogHandle );
}

VOID
run_var10(
    VOID
    )
/*++

Routine Description:

    file create slowdown as number of files in a directory increases

Arguments:

    None

Return Value:

    None

--*/ 
{
#define TestFiles10 15000
    DWORD x;
    WCHAR FileNameString[MAX_PATH];
    DWORD Time;
    DWORD Error;
    HANDLE FileHandle;

    //xStartVariation( LogHandle, "variation10" );
    //xLog(LogHandle, XLL_INFO, "file create slowdown as number of files in a directory increases");
    printf("file create slowdown as number of files in a directory increases\n");
    
    //
    // pre-clean
    //

    for (x = 0; x < TestFiles10; x++) {
        swprintf(FileNameString, L"Test%d.prf", x);
        DeleteFile(FileNameString);
    }
    
    CleanCaches();
    
    //
    // Create files, we'll use empty files
    //

    for (x = 0; x < TestFiles10; x++) {

        if ((x % 20) == 0) {

            //
            // start timer to measure this group of 20 files
            //

            StartTimer();
        }

        //
        // create file with specified flags
        //

        swprintf(FileNameString, L"Test%d.prf", x);
        FileHandle = CreateFile(FileNameString,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

        if (INVALID_HANDLE_VALUE == FileHandle) {
            Error = GetLastError();
            break;
        }

        CloseHandle(FileHandle);

        //
        // query timer, log time every few files
        //
        
        if ((x % 20) == 0) {
            Time = EndTimer();
            //xLog(LogHandle, XLL_PASS, "files: %d Time: %10.10u ms", x, Time);
            printf("files: %d Time: %10.10u ms\n", x, Time);
        }
    }

    //
    // cleanup
    //
    
    for (x = 0; x < TestFiles10; x++) {
        swprintf(FileNameString, L"Test%d.prf", x);
        DeleteFile(FileNameString);
    }
}

VOID
run_var11(
    VOID
    )
/*++

Routine Description:

    directory create slowdown as number of directory entries increases

Arguments:

    None

Return Value:

    None

--*/ 
{
#define TestDirectories11 15000
    DWORD x;
    WCHAR DirectoryNameString[MAX_PATH];
    DWORD Time;
    DWORD Error;
    BOOL bResult;

    //xStartVariation( LogHandle, "variation11" );
    //xLog(LogHandle, XLL_INFO, "directory create slowdown as number of directories in a directory increases");
    printf("directory create slowdown as number of directories in a directory increases\n");
    
    //
    // pre-clean
    //

    for (x = 0; x < TestDirectories11; x++) {
        swprintf(DirectoryNameString, L"Test%d.prf", x);
        RemoveDirectory(DirectoryNameString);
    }
    
    CleanCaches();
    
    //
    // Create directories, we'll use empty directories
    //

    for (x = 0; x < TestDirectories11; x++) {

        if ((x % 20) == 0) {

            //
            // start timer to measure this group of 20 directories
            //

            StartTimer();
        }

        //
        // create file with specified flags
        //

        swprintf(DirectoryNameString, L"Test%d.prf", x);
        bResult = CreateDirectory(DirectoryNameString, NULL);

        if (FALSE == bResult) {
            Error = GetLastError();
            break;
        }

        //
        // query timer, log time every few directories
        //
        
        if ((x % 20) == 0) {
            Time = EndTimer();
            //xLog(LogHandle, XLL_PASS, "directories: %d Time: %10.10u ms", x, Time);
            printf("directories: %d Time: %10.10u ms\n", x, Time);
        }
    }

    //
    // cleanup
    //
    
    for (x = 0; x < TestDirectories11; x++) {
        swprintf(DirectoryNameString, L"Test%d.prf", x);
        RemoveDirectory(DirectoryNameString);
    }
}

VOID
run_var12(
    VOID
    )
/*++

Routine Description:

    random access within a file while varying cache size

Arguments:

    None

Return Value:

    None
    
Notes:

    repeatable random access will be done by seeding with a constant
    random numbers range from 0-32767
        
    make code stop at cache sizes larger than available memory... 
    since my current test box is not like the 'real' hardware...
    

--*/ 
{
#define TestBufferSize12 0x1000000
#define FileFactorSize 20
    DWORD CacheSizes[] = {
        5000000, 
        10000000, 
        15000000, 
        20000000, 
        25000000, 
        30000000, 
        35000000, 
        40000000, 
        45000000, 
        50000000, 
        55000000, 
        60000000, 
        65000000
        };
    HANDLE FileHandle;
    BOOL bResult;
    PVOID TestData;
    PVOID TestDataIn;
    DWORD BytesWritten;
    LPVOID CacheSizer;
    DWORD BytesRead;
    DWORD TestInBufferSize12;
    DWORD FileChunks = (FileFactorSize * TestBufferSize12) / RAND_MAX;
    int x, y, z;
    DWORD Error;
    DWORD Time;

    //
    // read buffer size rounded to page
    //

    TestInBufferSize12 = FileChunks - (FileChunks % 0x1000);

    //xStartVariation( LogHandle, "variation12" );
    //xLog(LogHandle, XLL_INFO, "random access within a file while varying cache size");
    printf("random access within a file while varying cache size\n");
    
    //
    // allocate and initialize test buffer
    //

    TestData = CreateTestDataBuffer(TestBufferSize12);
    TestDataIn = VirtualAlloc(NULL, TestInBufferSize12, MEM_COMMIT, PAGE_READWRITE);

    if ((NULL == TestDataIn) || (NULL == TestData)) {
        Error = GetLastError();
        DebugBreak();
    }

    //
    // create and fill file
    //

    FileHandle = CreateFile(L"TestFile.prf",
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,  // may want to modify this later
                            NULL);

    if ( INVALID_HANDLE_VALUE == FileHandle ) {
        Error = GetLastError();
        DebugBreak();
    }

    for (x = 0; x < FileFactorSize; x++) {
        bResult = WriteFile(FileHandle, 
                            TestData,
                            TestBufferSize12,
                            &BytesWritten,
                            NULL);

        if ( FALSE == bResult ) {
            Error = GetLastError();
            DebugBreak();
        }
    }

    VirtualFree(TestData, 0, MEM_RELEASE); 
    
    for (x = 0; x < ARRAYSIZE(CacheSizes); x++) {

        //
        // initialize randomizer so that each variation has the same access pattern
        //

        srand(5);

        //
        // clear cache
        //
        
        CleanCaches();
        
        //
        // limit cache size
        // not on NT...
        // 
        
        
        //
        // start timer
        //

        StartTimer();
        
        //
        // do searches / reads
        //

        for (y = 0; y < 10000; y++) {

            SetFilePointer(FileHandle, 
                           FileChunks * rand(), 
                           NULL, 
                           FILE_BEGIN);

            bResult = ReadFile(FileHandle, 
                       TestDataIn,
                       TestInBufferSize12,
                       &BytesRead,
                       NULL);

            if (FALSE == bResult) {
                Error = GetLastError();
                DebugBreak();
            }
        }

        //
        // stop timer
        //

        Time = EndTimer();

        //
        // log time
        //

        //xLog(LogHandle, 
        //     XLL_PASS, 
        //     "cachesize: %10.10u Time: %10.10u ms",
        //     CacheSizes[x], Time);
        printf("cachesize: %10.10u Time: %10.10u ms\n",
               CacheSizes[x], Time);

        ////xLogResourceStatus(LogHandle,NULL);
        
        //
        // clean up cache sizing
        //

        //VirtualFree(CacheSizer, 0, MEM_RELEASE);
    }

    //
    // delete file
    //

    CloseHandle(FileHandle);
    DeleteFile(L"TestFile.prf");
    VirtualFree(TestDataIn, 0, MEM_RELEASE); 
    return;
}

VOID
StartTimer(
    VOID
    )
/*++

Routine Description:

    Start the test timer and returns 

Arguments:

    None

Return Value:

    None

Notes:

    this uses a global variable so the calling function does not have to 
    maintain state. this is to make this as convienient and easy as possible 
    to use and un-clutter the calling function

--*/ 
{
    QueryPerformanceCounter(&PerformanceCount);
}

DWORD
EndTimer(
    VOID
    )
/*++

Routine Description:

    Ends the test timer and returns the elapsed time in Milliseconds

Arguments:

    None

Return Value:

    elapsed time in Milliseconds

--*/ 
{
    LARGE_INTEGER PerformanceCountFinish;

    QueryPerformanceCounter(&PerformanceCountFinish);
    return(DWORD)((PerformanceCountFinish.QuadPart - PerformanceCount.QuadPart) / (Frequency.QuadPart / 1000));
}

PVOID
CreateTestDataBuffer(
    DWORD BufferSize
    )
/*++

Routine Description:

    create our test data buffer

Arguments:

    None

Return Value:

    pointer to test buffer

Notes:

    free the buffer like this when finished with it
    VirtualFree(<whatever this function returned>, 0, MEM_RELEASE);


--*/ 
{
    PVOID FileDataBuffer;
    char *tmpPtr;
    DWORD x;

    FileDataBuffer = VirtualAlloc(NULL, BufferSize, MEM_COMMIT, PAGE_READWRITE);

    if (NULL == FileDataBuffer) {
        OutputDebugString(L"Out of memory!");
        return NULL;
    }

    tmpPtr = FileDataBuffer;
    for (x = 1; x < BufferSize; x++) {
        *tmpPtr = (char)(x % 16);
        ++tmpPtr;
    }
    
    return(FileDataBuffer);
}

VOID
CleanCaches(
    VOID
    )
/*++

Routine Description:

    clear out processor and all disk caches

Arguments:

    None

Return Value:

    pointer to test buffer

Notes:

    relies on non-documented functions

--*/ 
{

    //FlushDiskCache();
    //MmDiscardCleanSystemCachePages();

    //
    // the following command invalidates the L1 and L2 processor caches
    //

    //_asm {
    //    wbinvd
    //}

    //
    // for nt do something goofy like reding a 100 mb file
    //




}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\sdstress\ctfmul.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ctfmul.c

Abstract:

     copy test multiple file

Author / ported by:

    John Daly (johndaly) porting date 4/29/2000

Environment:

    X-Box

[Notes:]

    port from the NT sdstress for X-Box testing

Revision History:

    initial port: johndaly
        port from NT

--*/

unsigned long 
__stdcall 
CopyTestFileMultiple (
    LPVOID pCopyTestFileData
    )
/*++

Routine Description:

    Test Scenario 3: Issue many reads, and writes

Arguments:

    COPYTESTFILEDATA structure which contains all information required for 
    this function

Return Value:

    Always 0 (actual return value is placed in structure)

--*/ 
{
    HANDLE hSfile, hDfile;
    BOOL bSuccess;
    DWORD dwAccessed, SFP_RetVal = 0;
    DWORD lFileCount = 0;
    UINT subcount = 0;
    BOOL PassFlag = TRUE;
    char szBuffer[200];

    //
    // Init the data structure
    //

    COPYTESTFILE_DATA *CopyTestFileData=(COPYTESTFILE_DATA *)pCopyTestFileData;

    //
    // initialize logging
    //

    xSetComponent(hSdStressLog, "disk", "sdstress" );
    xSetFunctionName( hSdStressLog, "CopyTestFileMultiple" );
    xStartVariation( hSdStressLog, "variation1" );

    __try {

        //
        // start the test
        //

        sprintf (szBuffer, 
                 "CopyTestFileMultiple entered for Thread Src:%c, Dst:%c, Instance:%d\n",
                 CopyTestFileData->ThreadData->SrcDrive->Letter,
                 CopyTestFileData->ThreadData->DestDrive->Letter,
                 CopyTestFileData->ThreadData->ThreadInstance);
        Debug_Print (szBuffer);

        hSfile = CreateFileA(CopyTestFileData->pszSname,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FileMode,
                             NULL);

        hDfile = CreateFileA(CopyTestFileData->pszDname,
                             GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FileMode,
                             NULL);

        if ( hDfile == INVALID_HANDLE_VALUE || hSfile == INVALID_HANDLE_VALUE ) {
            CopyTestFileData->ErrorCode = GetLastError();
            CopyTestFileData->retval = E_NOHANDLE;

            __leave;
        }

        while ( lFileCount <= CopyTestFileData->lFileSize / CopyTestFileData->BlockSize - 1 ) {
            for ( subcount = 1; subcount<=SCEN3REDO; subcount++ ) {
                if ( subcount > 1 && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize ) {

                    SFP_RetVal = SetFilePointer (hSfile,
                                                 (CopyTestFileData->BlockSize * -1),
                                                 NULL,
                                                 FILE_CURRENT);

                } else if ( CopyTestFileData->lFileSize < CopyTestFileData->BlockSize ) {
                    SFP_RetVal = SetFilePointer (hSfile,
                                                 0,
                                                 NULL,
                                                 FILE_BEGIN);
                }

                if ( SFP_RetVal == -1 ) {
                    CopyTestFileData->ErrorCode = GetLastError();
                    CopyTestFileData->retval = E_SEEK;

                    __leave;
                }

                bSuccess=ReadFile(hSfile,
                                  CopyTestFileData->pszDataBuffer,
                                  CopyTestFileData->BlockSize,
                                  &dwAccessed,
                                  NULL);

                if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                     (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                    CopyTestFileData->ErrorCode = GetLastError();
                    CopyTestFileData->retval = E_COPY;

                    __leave;
                }

//                FlushFileBuffers (hSfile);
            }

            for ( subcount=1; subcount<=SCEN3REDO; subcount++ ) {
                if ( subcount > 1 && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize ) {

                    SFP_RetVal = SetFilePointer (hDfile,
                                                 (CopyTestFileData->BlockSize * -1),
                                                 NULL,
                                                 FILE_CURRENT);

                } else if ( CopyTestFileData->lFileSize < CopyTestFileData->BlockSize ) {
                    SFP_RetVal = SetFilePointer (hDfile,
                                                 0,
                                                 NULL,
                                                 FILE_BEGIN);
                }

                if ( SFP_RetVal == -1 ) {
                    CopyTestFileData->ErrorCode = GetLastError();
                    CopyTestFileData->retval = E_SEEK;

                    __leave;
                }

                bSuccess=WriteFile(hDfile,
                                   CopyTestFileData->pszDataBuffer,
                                   CopyTestFileData->BlockSize,
                                   &dwAccessed,
                                   NULL);

                if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                     (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                    CopyTestFileData->ErrorCode=GetLastError();
                    CopyTestFileData->retval=E_COPY;

                    __leave;
                }
            }

            if ( CopyTestFileData->lFileSize < CopyTestFileData->BlockSize ) {
                break;
            } else {
                lFileCount ++;
            }
        }

        Close_Handle(&hSfile);
        Close_Handle(&hDfile);

        hSfile = CreateFileA(CopyTestFileData->pszSname,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FileMode,
                             NULL);

        hDfile = CreateFileA(CopyTestFileData->pszDname,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FileMode,
                             NULL);

        if ( hDfile == INVALID_HANDLE_VALUE || hSfile == INVALID_HANDLE_VALUE ) {
            CopyTestFileData->ErrorCode = GetLastError();
            CopyTestFileData->retval = E_NOHANDLE;

            __leave;
        }

        lFileCount = 0;
        CopyTestFileData->Offset = 0;

        while ( lFileCount <= CopyTestFileData->lFileSize/CopyTestFileData->BlockSize - 1 ) {
            bSuccess = ReadFile (hSfile,
                                 CopyTestFileData->pszCompareBuffer,
                                 CopyTestFileData->BlockSize,
                                 &dwAccessed,
                                 NULL);

            if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                 (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                CopyTestFileData->ErrorCode = GetLastError();
                CopyTestFileData->retval = E_VERIFYREAD;
                Close_Handle (&hSfile);
                Close_Handle (&hDfile);

                __leave;
            }

            bSuccess = ReadFile (hDfile,
                                 CopyTestFileData->pszDataBuffer,
                                 CopyTestFileData->BlockSize,
                                 &dwAccessed,
                                 NULL);

            if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                 (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                CopyTestFileData->ErrorCode = GetLastError();
                CopyTestFileData->retval = E_VERIFYREAD;
                Close_Handle (&hSfile);
                Close_Handle (&hDfile);

                __leave;
            }

            CopyTestFileData->Offset = lFileCount * CopyTestFileData->BlockSize;

            //
            // debug code to catch some memory corruption
            //

            ValidateCOPYTESTFILE_DATA (CopyTestFileData); 

            // end of debug code

            //
            // check buffers
            //

            if ( FALSE == VerifyData(CopyTestFileData) ) {
                xLog (hSdStressLog, 
                      XLL_FAIL, 
                      "VerifyData failure in CopyTestFile.");
                PassFlag = FALSE;
            }


            if ( CopyTestFileData->lFileSize < CopyTestFileData->BlockSize ) {
                break;
            } else {
                lFileCount ++;
            }
        }

        CopyTestFileData->retval=0;
    }

    __finally {

        if ( INVALID_HANDLE_VALUE != hDfile ) {
            FlushFileBuffers (hDfile);
            Close_Handle (&hDfile);
        }

        if ( INVALID_HANDLE_VALUE != hSfile ) {
            FlushFileBuffers (hSfile);
            Close_Handle (&hSfile);
        }

        if ( PassFlag == TRUE ) {
            xLog (hSdStressLog, 
                  XLL_PASS, 
                  "CopyTestFileMultiple Passed");
        }

        if ( CopyTestFileData->ErrorCode ) {
            if ( bDebug && KDENABLED ) {
                //DebugBreak();
                ++GlobalErrorCounter;
                sprintf (szBuffer, 
                         "CopyTestFileMultiple : hit an error Source: %s Dest: %s : code=%d : GlobalErrorCounter=%d\n",
                         CopyTestFileData->pszSname,
                         CopyTestFileData->pszDname,
                         CopyTestFileData->ErrorCode,
                         GlobalErrorCounter);
                Debug_Print (szBuffer);
            }
            xLog (hSdStressLog, 
                  (CopyTestFileData->ErrorCode == ERROR_DISK_FULL) ? XLL_WARN : XLL_FAIL, 
                  "Error detected in CopyTestFileMultiple: Error : %d Source: %s Dest: %s",
                  CopyTestFileData->ErrorCode,
                  CopyTestFileData->pszSname,
                  CopyTestFileData->pszDname);
        }
    }

    //
    // close logging
    //

    xEndVariation( hSdStressLog);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\mediadet\mediadet.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

   mediadet.h

Abstract:

   support ReadFileTest.c

Author:

   John Daly

Notes:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <ntos.h>
#include <winbase.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <smcdef.h>
#include "dxconio.h"

#define BUTTON_PRESS_VALUE      100

extern
NTSTATUS
WINAPI
XWriteTitleInfoNoReboot(
    PCOSTR pszLaunchPath,
    PCOSTR pszDDrivePath,
    DWORD dwLaunchDataType,
    DWORD dwTitleId,
    PLAUNCH_DATA pLaunchData
    );

//
// global data
//

#define SOFT_REBOOT 1
#define HARD_REBOOT 2
#define SMC_RESET   3

#define DATASLOTS 10

DWORD RebootType = HARD_REBOOT; // default to this
char buffer[500] = {0};

struct _fbuffer {
    DWORD iteration;
    DWORD SizesDetected;
    DWORD RebootType;
    struct _DetectData {
        DWORD SizeDetectedCount;
        ULARGE_INTEGER SizeDetected;
    } DetectData[DATASLOTS];
} fbuffer = {0};

//
// function declarations
//

void 
__cdecl 
main(
    void
    );

DWORD 
__cdecl 
RebootMenu(
    void
    );

void 
__cdecl 
DumpStats(
    void
    );

void
__cdecl 
InputDukeInsertions(
    DWORD add, 
    DWORD remove
    );

BOOL
__cdecl 
InputCheckButton(
    int button
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\sdstress\ctfwex.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ctfwex.c

Abstract:

     copy test / file IO / use WriteFileEx for async writes

Author / ported by:

    John Daly (johndaly) porting date 4/29/2000

Environment:

    X-Box

[Notes:]

    port from the NT sdstress for X-Box testing
    
    Limited support for asynchronous file writes is available.  
    As before, a file must be opened for overlapped I/O.  
    When you do a write with the ending byte offset <= the file size, 
    then the write will be asynchronous.  
    If the ending byte offset > file size, then the write will be synchronous.
    To look at both behaviors, the file will be written 2 times.

Revision History:

    initial port: johndaly
        port from NT
    WriteFileEx/async modification from ctfioc.c

--*/

unsigned long 
__stdcall 
CopyTestFileUsingWriteFileEx (
    LPVOID pCopyTestFileData
    )
/*++

Routine Description:

    Test Scenario 2: Use IoCompletionPorts

Arguments:

    COPYTESTFILEDATA structure which contains all information required for this function

Return Value:

    Always 0 (actual return value is placed in structure)

--*/ 
{
    HANDLE hSfile = INVALID_HANDLE_VALUE;
    HANDLE hDfile = INVALID_HANDLE_VALUE;
    DWORD PassCreateFlag = CREATE_ALWAYS;
    BOOL bSuccess;
    DWORD dwAccessed;
    DWORD lFileCount = 0;
    DWORD RetryCount = 0;
    char szBuffer[200] = {0};
    OVERLAPPED sOverLapped;
    int Pass;
    BOOL PassFlag = TRUE;

    //
    // Init the data structure
    //

    COPYTESTFILE_DATA *CopyTestFileData=(COPYTESTFILE_DATA *)pCopyTestFileData;

    //
    // initialize logging
    //

    xSetComponent(hSdStressLog, "disk", "sdstress" );
    xSetFunctionName( hSdStressLog, "CopyTestFileUsingWriteFileEx" );
    xStartVariation( hSdStressLog, "variation1" );

    __try
    {
        //
        // start the test
        //

        //
        // first pass through, the write will be extending the file 
        // (byte offset > the file size), which will cause synchronous IO
        // second pass through, it will be writing into existing file 
        // (byte offset <= the file size), which will allow asynchronous operation
        //

        for ( Pass = 0; Pass < 2; Pass++ ) {
            switch ( Pass ) {
                case 0:
                    PassCreateFlag = CREATE_ALWAYS;
                    break;

                case 1:
                    PassCreateFlag = OPEN_EXISTING;
                    break;
            }

            sprintf (szBuffer, 
                     "CopyTestFileUsingWriteFileEx entered for Thread Src:%c, Dst:%c, Instance:%d Pass:%d\n",
                     CopyTestFileData->ThreadData->SrcDrive->Letter,
                     CopyTestFileData->ThreadData->DestDrive->Letter,
                     CopyTestFileData->ThreadData->ThreadInstance,
                     Pass);
            Debug_Print (szBuffer);

            //
            // Zero the Overlap structure
            //

            memset (&sOverLapped, 0, sizeof (OVERLAPPED));

            hSfile = CreateFileA(CopyTestFileData->pszSname,
                                 GENERIC_READ,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FileMode,
                                 NULL);

            hDfile = CreateFileA(CopyTestFileData->pszDname,
                                 GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 PassCreateFlag,
                                 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING | FileMode,
                                 NULL);

            //
            // Note
            // getting bad hDfile, sharing violation, suspecting pending writes
            // try re-trying
            //

            if ( hDfile == INVALID_HANDLE_VALUE || hSfile == INVALID_HANDLE_VALUE ) {
                CopyTestFileData->ErrorCode=GetLastError();
                CopyTestFileData->retval=E_NOHANDLE;

                __leave;

            }

            while ( lFileCount <= CopyTestFileData->lFileSize / CopyTestFileData->BlockSize - 1 ) {

                bSuccess = ReadFile (hSfile,
                                     CopyTestFileData->pszDataBuffer,
                                     CopyTestFileData->BlockSize,
                                     &dwAccessed,
                                     NULL);

                if ( !bSuccess || 
                     (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                     (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {

                    CopyTestFileData->ErrorCode = GetLastError();

                    if ( CopyTestFileData->ErrorCode != ERROR_IO_PENDING ) {
                        CopyTestFileData->retval = E_COPY;

                        __leave;
                    }
                }

                RetryCount = 0;
                while ( RetryCount < MAXRETRIES ) {
                    bSuccess = WriteFileEx(hDfile,
                                           CopyTestFileData->pszDataBuffer,
                                           CopyTestFileData->BlockSize,
                                           &sOverLapped,
                                           WriteFileExCompletionRoutine);

                    if ( !bSuccess ) {
                        CopyTestFileData->ErrorCode = GetLastError ();

                        if ( (CopyTestFileData->ErrorCode != ERROR_INVALID_USER_BUFFER &&
                              CopyTestFileData->ErrorCode != ERROR_NOT_ENOUGH_QUOTA &&
                              CopyTestFileData->ErrorCode != ERROR_WORKING_SET_QUOTA &&
                              CopyTestFileData->ErrorCode != ERROR_NOT_ENOUGH_MEMORY) ||
                             RetryCount == MAXRETRIES ) {

                            CopyTestFileData->retval = E_COPY;

                            __leave;
                        }
                    } else {
                        break;
                    }

                    RetryCount ++;
                }

                //
                // note: need to SleepEx or wait to get completion routine to fire
                //

                SleepEx(1, TRUE);

                RetryCount = 0;

                sOverLapped.Offset += CopyTestFileData->BlockSize;

                if ( CopyTestFileData->lFileSize < CopyTestFileData->BlockSize ) {
                    break;
                } else {
                    lFileCount ++;
                }
            }

            //
            // flush to blow away any pending IO before we finish up and kill the overlap
            // (I looked at FlushFileBuffers, it appears to do this)
            // this gets us re-synchronized and we avoid 'ERROR_SHARING_VIOLATION' error
            //

            FlushFileBuffers (hDfile);
            FlushFileBuffers (hSfile);
            Close_Handle (&hSfile);
            Close_Handle (&hDfile);

            hSfile = CreateFileA(CopyTestFileData->pszSname,
                                 GENERIC_READ,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE ,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FileMode,
                                 NULL);

            hDfile = CreateFileA(CopyTestFileData->pszDname,
                                 GENERIC_READ,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FileMode,
                                 NULL);

            if ( hDfile == INVALID_HANDLE_VALUE || hSfile == INVALID_HANDLE_VALUE ) {
                CopyTestFileData->ErrorCode=GetLastError();
                CopyTestFileData->retval=E_NOHANDLE;

                __leave;
            }

            lFileCount = 0;
            CopyTestFileData->Offset = 0;

            while ( lFileCount <= CopyTestFileData->lFileSize / CopyTestFileData->BlockSize - 1 ) {

                bSuccess=ReadFile(hSfile,
                                  CopyTestFileData->pszCompareBuffer,
                                  CopyTestFileData->BlockSize,
                                  &dwAccessed,
                                  NULL);

                if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                     (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                    CopyTestFileData->ErrorCode=GetLastError();
                    CopyTestFileData->retval=E_COPY;

                    __leave;
                }

                bSuccess=ReadFile(hDfile,
                                  CopyTestFileData->pszDataBuffer,
                                  CopyTestFileData->BlockSize,
                                  &dwAccessed,
                                  NULL);

                if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                     (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                    CopyTestFileData->ErrorCode=GetLastError();
                    CopyTestFileData->retval=E_COPY;

                    __leave;
                }

                CopyTestFileData->Offset = lFileCount * CopyTestFileData->BlockSize;

                //
                // debug code to catch some memory corruption
                //

                ValidateCOPYTESTFILE_DATA (CopyTestFileData); 

                // end of debug code

                //
                // check buffers
                //

                if ( FALSE == VerifyData(CopyTestFileData) ) {
                    xLog (hSdStressLog, 
                          XLL_FAIL, 
                          "VerifyData failure in CopyTestFile.");
                    PassFlag = FALSE;
                }

                if ( CopyTestFileData->lFileSize < CopyTestFileData->BlockSize ) {
                    break;
                } else {
                    lFileCount++;
                }
            }

            CopyTestFileData->retval=0;

            //
            // flush to blow away any pending IO before we finish up and kill the overlap
            // (I looked at FlushFileBuffers, it appears to do this)
            // this gets us re-synchronized and we avoid 'ERROR_SHARING_VIOLATION' error
            //

            FlushFileBuffers (hDfile);
            FlushFileBuffers (hSfile);
            Close_Handle (&hSfile);
            Close_Handle (&hDfile);

        }
    }

    __finally
    {
        if ( INVALID_HANDLE_VALUE != hDfile ) {
            FlushFileBuffers (hDfile);
            Close_Handle (&hDfile);
        }

        if ( INVALID_HANDLE_VALUE != hSfile ) {
            FlushFileBuffers (hSfile);
            Close_Handle (&hSfile);
        }

        if ( PassFlag == TRUE ) {
            xLog (hSdStressLog, 
                  XLL_PASS, 
                  "CopyTestFileUsingWriteFileEx Passed");
        }

        if ( CopyTestFileData->ErrorCode ) {
            if ( bDebug && KDENABLED ) {
                //DebugBreak();
                ++GlobalErrorCounter;
                sprintf (szBuffer, 
                         "CopyTestFileUsingWriteFileEx : hit an error Source: %s Dest: %s : code=%d : GlobalErrorCounter=%d\n",
                         CopyTestFileData->pszSname,
                         CopyTestFileData->pszDname,
                         CopyTestFileData->ErrorCode,
                         GlobalErrorCounter);
                Debug_Print (szBuffer);
            }
            xLog (hSdStressLog, 
                  (CopyTestFileData->ErrorCode == ERROR_DISK_FULL) ? XLL_WARN : XLL_FAIL, 
                  "Error detected in CopyTestFileUsingWriteFileEx: Error : %d Source: %s Dest: %s",
                  CopyTestFileData->ErrorCode,
                  CopyTestFileData->pszSname,
                  CopyTestFileData->pszDname);
        }
    }

    //
    // close logging
    //

    xEndVariation( hSdStressLog);

    return(0);
}

VOID
CALLBACK 
WriteFileExCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    )
/*++

Routine Description:

    Callback for WriteFileEx

Arguments:

    DWORD dwErrorCode,                // completion code (irrelevant in this case)
    DWORD dwNumberOfBytesTransfered,  // number of bytes transferred
    LPOVERLAPPED lpOverlapped         // I/O information buffer

Return Value:

    none
    
Notes:

    doing anything in here will delay completion of the pending IO, so put a 
    wait in here if you want to experiment with stacking them up...
    other filesystem tests make sure that this things fires correctly, I did
    some experimenting with it while writing this code and have seen that
    it works, so we'll let it do nothing instead of doing a bunch of verification

--*/ 
{
    //Sleep(100);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\sdstress\console.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Console.c

Abstract:

     console interface (will be made UI-less for X-Box)

Author / ported by:

    John Daly (johndaly) porting date 4/29/2000

Environment:

    X-Box

[Notes:]

    port from the NT sdstress for X-Box testing

Revision History:

    initial port: johndaly
        port from NT

--*/

//
// include files
//

#include "windows.h"

BOOL 
WriteTextConsole (
    char *pszText, 
    WORD Attribute, 
    DWORD LoggedLevel
    )
/*++

Routine Description:

    WriteTextConsole writes some text, in the given attribute, to
    the console.  This function also writes logging information.
    x-box - ignore attribute, and just output debug string and log

Arguments:

    pszText - Pointer to the Text to be written to the console
    Attribute - Contains the foreground/background color of the text
    LoggedLevel - Contains Logging level (based on NTLOG.DLL)

Return Value:

    TRUE is success
    FALSE if not

--*/ 
{

    if((FALSE == LoggedLevel) && (TRUE == bDebug)){
        OutputDebugStringA (pszText);
    } 

    return(1);
}

BOOL PrintError (
    long ErrorCode
    )
/*++

Routine Description:

    This function converts Win32 Error Codes to the appropriate message

Arguments:

    Parameters:  ErrorCode - Contains Win32 ErrorCode

Return Value:

    TRUE if successful
    FALSE if not

--*/ 
{
    char szBuffer[240];

    sprintf (szBuffer,
             "Error code: %ld\n",
             ErrorCode);
    
    return(TRUE);
}

BOOL PrintSDError (
    long ErrorCode
    )
/*++

Routine Description:

    This function displays SdStress specific errors

Arguments:

    ErrorCode - Contains SdStress error code

Return Value:

    TRUE if successful
    FALSE if not

--*/ 
{
    char szBuffer[100];

    switch ( ErrorCode ) {
    case E_CDROMCOPY:
        sprintf(szBuffer, "CDROM Copy failure.\n");
        break;
    case E_COPY:
        sprintf(szBuffer, "Copy failed.\n");
        break;
    case E_TESTFILE:
        sprintf(szBuffer, "Testfile creation failed.\n");
        break;
    case E_MEMORY:
        sprintf(szBuffer, "Memory allocation error.\n");
        break;
    case E_VERIFY:
        sprintf(szBuffer, "Verify failed.\n");
        break;
    case E_VERIFYREAD:
        sprintf(szBuffer, "Verify readback failed.\n");
        break;
    case E_VERIFYCOPY:
        sprintf(szBuffer, "Verify after copy failed.\n");
        break;
    case E_NOHANDLE:
        sprintf(szBuffer, "Unable to acquire handle.\n");
        break;
    case E_DELETE:
        sprintf(szBuffer, "Delete failed.\n");
        break;
    case E_DISKSPACE:
        sprintf(szBuffer, "Out of disk space.\n");
        break;
    case E_ACCESSSdStress:
        sprintf(szBuffer, "Undefined. E\n");
        break;
    case E_NOPOINTER:
        sprintf(szBuffer, "Null pointer assignment.\n");
        break;
    case E_SEEK:
        sprintf(szBuffer, "Seek failed.\n");
        break;
    case E_DEALLOC:
        sprintf (szBuffer, "Memory DE-allocation failed.\n");
        break;
    case E_THREAD:
        sprintf (szBuffer, "Thread creation failed.\n");
        break;
    default:
        sprintf(szBuffer, "Undefined.\n");
        break;
    }

    WriteTextConsole(szBuffer, ERRORCOLOR, XLL_WARN);
    return(TRUE);
}

void 
Debug_Print (
    char *Text
    )
/*++

Routine Description:

    This function will print Debug output on the screen if the switch 
    is selected

Arguments:

    Text - Pointer to buffer containing text to be written

Return Value:

    None    

--*/ 
{
    //
    // Return if the text pointer is NULL
    //

    if ( !Text )
        return;

    if ( bDebug ) {
        WriteTextConsole (Text, DEBUGCOLOR, FALSE);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\sdstress\ctfioc.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ctfioc.c

Abstract:

     copy test / file IO / use completion ports

Author / ported by:

    John Daly (johndaly) porting date 4/29/2000

Environment:

    X-Box

[Notes:]

    port from the NT sdstress for X-Box testing

Revision History:

    initial port: johndaly
        port from NT

--*/

unsigned long 
__stdcall 
CopyTestFileUsingIoC (
    LPVOID pCopyTestFileData
    )
/*++

Routine Description:

    Test Scenario 2: Use IoCompletionPorts

Arguments:

    COPYTESTFILEDATA structure which contains all information required for this function

Return Value:

    Always 0 (actual return value is placed in structure)

--*/ 
{
    HANDLE hSfile = INVALID_HANDLE_VALUE;
    HANDLE hDfile = INVALID_HANDLE_VALUE;
    HANDLE IoCPort = NULL;
    BOOL bSuccess;
    DWORD dwAccessed, Dummykey;
    DWORD lFileCount = 0;
    DWORD RetryCount = 0;
    char szBuffer[200];
    OVERLAPPED sOverLapped, *CompletedOverlap;
    BOOL PassFlag = TRUE;

    //
    // Init the data structure
    //

    COPYTESTFILE_DATA *CopyTestFileData=(COPYTESTFILE_DATA *)pCopyTestFileData;

    //
    // initialize logging
    // added extra debug stuff to catch logging error
    //

    xSetComponent(hSdStressLog, "disk", "sdstress" );
    xSetFunctionName( hSdStressLog, "CopyTestFileUsingIoC" );
    xStartVariation( hSdStressLog, "variation1" );

    __try
    {   
        //
        // start the test
        //

        sprintf (szBuffer, 
                 "CopyTestFileUsingIoC entered for Thread Src:%c, Dst:%c, Instance:%d\n",
                 CopyTestFileData->ThreadData->SrcDrive->Letter,
                 CopyTestFileData->ThreadData->DestDrive->Letter,
                 CopyTestFileData->ThreadData->ThreadInstance);
        Debug_Print (szBuffer);

        //
        // Zero the Overlap structure
        //

        memset (&sOverLapped, 0, sizeof (OVERLAPPED));

        hSfile = CreateFileA(CopyTestFileData->pszSname,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FileMode,
                             NULL);

        hDfile = CreateFileA(CopyTestFileData->pszDname,
                             GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING | FileMode,
                             NULL);

        if ( hDfile == INVALID_HANDLE_VALUE || hSfile == INVALID_HANDLE_VALUE ) {
            CopyTestFileData->ErrorCode=GetLastError();
            CopyTestFileData->retval=E_NOHANDLE;

            __leave;
        }

        //
        // Create the IoCompletionPorts
        //

        IoCPort = CreateIoCompletionPort (hDfile, NULL, (ULONG_PTR) hDfile, 0);

        if ( !IoCPort ) {
            CopyTestFileData->ErrorCode = GetLastError ();
            CopyTestFileData->retval = E_NOHANDLE;

            __leave;
        }

        sprintf (szBuffer,
                 "IoCompletionPorts created for Thread Src:%c, Dst:%c, Instance:%d\n",
                 CopyTestFileData->ThreadData->SrcDrive->Letter,
                 CopyTestFileData->ThreadData->DestDrive->Letter,
                 CopyTestFileData->ThreadData->ThreadInstance);

        Debug_Print (szBuffer);

        while ( lFileCount <= CopyTestFileData->lFileSize / CopyTestFileData->BlockSize - 1 ) {

            bSuccess = ReadFile (hSfile,
                                 CopyTestFileData->pszDataBuffer,
                                 CopyTestFileData->BlockSize,
                                 &dwAccessed,
                                 NULL);

            if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                 (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                CopyTestFileData->ErrorCode = GetLastError();

                if ( CopyTestFileData->ErrorCode != ERROR_IO_PENDING ) {
                    CopyTestFileData->retval = E_COPY;

                    __leave;
                }
            }

            while ( RetryCount < MAXRETRIES ) {
                bSuccess = WriteFile(hDfile,
                                     CopyTestFileData->pszDataBuffer,
                                     CopyTestFileData->BlockSize,
                                     &dwAccessed,
                                     &sOverLapped);

                if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                     (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                    CopyTestFileData->ErrorCode = GetLastError ();

                    if ( CopyTestFileData->ErrorCode == ERROR_IO_PENDING ) {
                        break;
                    } else if ( (CopyTestFileData->ErrorCode != ERROR_INVALID_USER_BUFFER &&
                                 CopyTestFileData->ErrorCode != ERROR_NOT_ENOUGH_QUOTA &&
                                 CopyTestFileData->ErrorCode != ERROR_WORKING_SET_QUOTA &&
                                 CopyTestFileData->ErrorCode != ERROR_NOT_ENOUGH_MEMORY) ||
                                RetryCount == MAXRETRIES ) {
                        CopyTestFileData->retval = E_COPY;

                        __leave;
                    }
                } else {
                    break;
                }

                RetryCount ++;
            }

            RetryCount = 0;

            sOverLapped.Offset += CopyTestFileData->BlockSize;

            if ( CopyTestFileData->lFileSize < CopyTestFileData->BlockSize ) {
                break;
            } else {
                lFileCount ++;
            }
        }

        Debug_Print ("Entering GetQueuedCompletionStatus Loop\n");

        lFileCount = 0;

        while ( lFileCount <= CopyTestFileData->lFileSize / CopyTestFileData->BlockSize - 1 ) {
            bSuccess = GetQueuedCompletionStatus (IoCPort,
                                                  &dwAccessed,
                                                  (PULONG_PTR)&Dummykey,
                                                  &CompletedOverlap,
                                                  COMPLETION_TIMEOUT);

            if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                 (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                CopyTestFileData->ErrorCode = GetLastError();
                CopyTestFileData->retval = E_COPY;

                __leave;
            }

            if ( CopyTestFileData->lFileSize < CopyTestFileData->BlockSize ) {
                break;
            } else {
                lFileCount ++;
            }
        }

        Debug_Print ("Leaving GetQueuedCompletionStatus Loop\n");

        Close_Handle (&hSfile);
        Close_Handle (&hDfile);

        hSfile = CreateFileA(CopyTestFileData->pszSname,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FileMode,
                             NULL);

        hDfile = CreateFileA(CopyTestFileData->pszDname,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FileMode,
                             NULL);

        if ( hDfile == INVALID_HANDLE_VALUE || hSfile == INVALID_HANDLE_VALUE ) {
            CopyTestFileData->ErrorCode=GetLastError();
            CopyTestFileData->retval=E_NOHANDLE;

            __leave;
        }

        lFileCount = 0;
        CopyTestFileData->Offset = 0;

        while ( lFileCount <= CopyTestFileData->lFileSize / CopyTestFileData->BlockSize - 1 ) {

            bSuccess=ReadFile(hSfile,
                              CopyTestFileData->pszCompareBuffer,
                              CopyTestFileData->BlockSize,
                              &dwAccessed,
                              NULL);

            if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                 (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                CopyTestFileData->ErrorCode=GetLastError();
                CopyTestFileData->retval=E_COPY;

                __leave;
            }

            bSuccess=ReadFile(hDfile,
                              CopyTestFileData->pszDataBuffer,
                              CopyTestFileData->BlockSize,
                              &dwAccessed,
                              NULL);

            if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                 (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                CopyTestFileData->ErrorCode=GetLastError();
                CopyTestFileData->retval=E_COPY;

                __leave;
            }

            CopyTestFileData->Offset = lFileCount * CopyTestFileData->BlockSize;

            //
            // debug code to catch some memory corruption
            //

            ValidateCOPYTESTFILE_DATA (CopyTestFileData); 

            // end of debug code

            //
            // check buffers
            //

            if ( FALSE == VerifyData(CopyTestFileData) ) {
                xLog (hSdStressLog, 
                      XLL_FAIL, 
                      "VerifyData failure in CopyTestFile.");
                PassFlag = FALSE;
            }

            if ( CopyTestFileData->lFileSize < CopyTestFileData->BlockSize ) {
                break;
            } else {
                lFileCount++;
            }
        }

        CopyTestFileData->retval=0;

    }

    __finally
    {
        if ( INVALID_HANDLE_VALUE != hDfile ) {
            FlushFileBuffers (hDfile);
            Close_Handle (&hDfile);
        }

        if ( INVALID_HANDLE_VALUE != hSfile ) {
            FlushFileBuffers (hSfile);
            Close_Handle (&hSfile);
        }

        if ( PassFlag == TRUE ) {
            xLog (hSdStressLog, 
                  XLL_PASS, 
                  "CopyTestFileUsingIoC Passed");
        }

        if ( IoCPort ) {
            Close_Handle (&IoCPort);
        }

        if ( CopyTestFileData->ErrorCode ) {
            if ( bDebug && KDENABLED ) {
                //DebugBreak();
                ++GlobalErrorCounter;
                sprintf (szBuffer, 
                         "CopyTestFileUsingIoC : hit an error Source: %s Dest: %s : code=%d : GlobalErrorCounter=%d\n",
                         CopyTestFileData->pszSname,
                         CopyTestFileData->pszDname,
                         CopyTestFileData->ErrorCode,
                         GlobalErrorCounter);
                Debug_Print (szBuffer);
            }
            xLog (hSdStressLog, 
                  (CopyTestFileData->ErrorCode == ERROR_DISK_FULL) ? XLL_WARN : XLL_FAIL, 
                  "Error detected in CopyTestFileUsingIoC: Error : %d Source: %s Dest: %s",
                  CopyTestFileData->ErrorCode,
                  CopyTestFileData->pszSname,
                  CopyTestFileData->pszDname);
        }
    }

    //
    // close logging
    //

    xEndVariation( hSdStressLog);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\sdstress\ctf.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ctf.c

Abstract:

     copy test file

Author / ported by:

    John Daly (johndaly) porting date 4/29/2000

Environment:

    X-Box

[Notes:]

    port from the NT sdstress for X-Box testing

Revision History:

    initial port: johndaly
        port from NT

--*/

unsigned long 
__stdcall 
CopyTestFile (
    LPVOID pCopyTestFileData
    )
/*++

Routine Description:

    Test Scenario 1: Standard reads, and writes

Arguments:

    COPYTESTFILEDATA structure which contains all information required for this function

Return Value:

    Always 0 (actual return value is placed in structure)

--*/ 
{
    HANDLE hSfile = INVALID_HANDLE_VALUE;
    HANDLE hDfile = INVALID_HANDLE_VALUE;
    BOOL bSuccess;
    DWORD dwAccessed;
    DWORD lFileCount = 0;
    BOOL PassFlag = TRUE;
    char szBuffer[200];

    //
    // Init the data structure
    //

    COPYTESTFILE_DATA *CopyTestFileData = (COPYTESTFILE_DATA *) pCopyTestFileData;

    //
    // initialize logging
    //

    xSetComponent(hSdStressLog, "disk", "sdstress" );
    xSetFunctionName( hSdStressLog, "CopyTestFile" );
    xStartVariation( hSdStressLog, "variation1" );

    __try
    {
        //
        // start the test
        //

        sprintf (szBuffer, 
                 "CopyTestFile entered for Thread Src:%c, Dst:%c, Instance:%d\n",
                 CopyTestFileData->ThreadData->SrcDrive->Letter,
                 CopyTestFileData->ThreadData->DestDrive->Letter,
                 CopyTestFileData->ThreadData->ThreadInstance);
        Debug_Print (szBuffer);

        hSfile = CreateFileA(CopyTestFileData->pszSname,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FileMode,
                             NULL);

        hDfile = CreateFileA(CopyTestFileData->pszDname,
                             GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FileMode,
                             NULL);

        if ( hDfile == INVALID_HANDLE_VALUE || hSfile == INVALID_HANDLE_VALUE ) {
            CopyTestFileData->ErrorCode=GetLastError();
            CopyTestFileData->retval=E_NOHANDLE;

            __leave;
        }

        while ( lFileCount <= CopyTestFileData->lFileSize / CopyTestFileData->BlockSize - 1 ) {

            bSuccess = ReadFile (hSfile,
                                 CopyTestFileData->pszDataBuffer,
                                 CopyTestFileData->BlockSize,
                                 &dwAccessed,
                                 NULL);

            if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                 (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                CopyTestFileData->ErrorCode = GetLastError();
                CopyTestFileData->retval = E_COPY;

                __leave;
            }

            bSuccess = WriteFile (hDfile,
                                  CopyTestFileData->pszDataBuffer,
                                  CopyTestFileData->BlockSize,
                                  &dwAccessed,
                                  NULL);

            if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                 (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                CopyTestFileData->ErrorCode = GetLastError();
                CopyTestFileData->retval = E_COPY;

                __leave;
            }


            if ( CopyTestFileData->lFileSize < CopyTestFileData->BlockSize ) {
                break;
            }

            else {
                lFileCount ++;
            }
        }

        FlushFileBuffers(hSfile);
        FlushFileBuffers(hDfile);
        Close_Handle(&hSfile);
        Close_Handle(&hDfile);

        hSfile = CreateFileA(CopyTestFileData->pszSname,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FileMode,
                             NULL);

        hDfile = CreateFileA(CopyTestFileData->pszDname,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING | FileMode,
                             NULL);

        if ( hDfile == INVALID_HANDLE_VALUE || hSfile == INVALID_HANDLE_VALUE ) {
            CopyTestFileData->ErrorCode=GetLastError();
            CopyTestFileData->retval=E_NOHANDLE;

            __leave;
        }

        lFileCount = 0;
        CopyTestFileData->Offset = 0;

        while ( lFileCount <= CopyTestFileData->lFileSize / CopyTestFileData->BlockSize - 1 ) {
            bSuccess = ReadFile(hSfile,
                                CopyTestFileData->pszCompareBuffer,
                                CopyTestFileData->BlockSize,
                                &dwAccessed,
                                NULL);

            if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                 (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                CopyTestFileData->ErrorCode=GetLastError();
                CopyTestFileData->retval=E_COPY;

                __leave;
            }

            bSuccess = ReadFile(hDfile,
                                CopyTestFileData->pszDataBuffer,
                                CopyTestFileData->BlockSize,
                                &dwAccessed,
                                NULL);

            if ( !bSuccess || (dwAccessed < CopyTestFileData->lFileSize && CopyTestFileData->lFileSize < CopyTestFileData->BlockSize) ||
                 (dwAccessed != CopyTestFileData->BlockSize && CopyTestFileData->lFileSize > CopyTestFileData->BlockSize) ) {
                CopyTestFileData->ErrorCode=GetLastError();
                CopyTestFileData->retval=E_COPY;

                __leave;
            }

            CopyTestFileData->Offset = lFileCount * CopyTestFileData->BlockSize;

            //
            // debug code to catch some memory corruption
            //

            ValidateCOPYTESTFILE_DATA (CopyTestFileData); 

            // end of debug code

            //
            // check buffers
            //

            if ( FALSE == VerifyData(CopyTestFileData) ) {
                xLog (hSdStressLog, 
                      XLL_FAIL, 
                      "VerifyData failure in CopyTestFile.");
                PassFlag = FALSE;
            }

            if ( CopyTestFileData->retval ) {
                __leave;
            }

            if ( CopyTestFileData->lFileSize < CopyTestFileData->BlockSize ) {
                break;
            }

            else {
                lFileCount ++;
            }

        }

        CopyTestFileData->retval=0;
    }

    __finally
    {
        if ( INVALID_HANDLE_VALUE != hDfile ) {
            FlushFileBuffers (hDfile);
            Close_Handle (&hDfile);
        }

        if ( INVALID_HANDLE_VALUE != hSfile ) {
            FlushFileBuffers (hSfile);
            Close_Handle (&hSfile);
        }

        if ( PassFlag == TRUE ) {
            xLog (hSdStressLog, 
                  XLL_PASS, 
                  "CopyTestFile Passed");
        }

        if ( CopyTestFileData->ErrorCode ) {
            if ( bDebug && KDENABLED ) {
                //DebugBreak();
                ++GlobalErrorCounter;
                sprintf (szBuffer, 
                         "CopyTestFile : hit an error Source: %s Dest: %s : code=%d : GlobalErrorCounter=%d\n",
                         CopyTestFileData->pszSname,
                         CopyTestFileData->pszDname,
                         CopyTestFileData->ErrorCode,
                         GlobalErrorCounter);
                Debug_Print (szBuffer);
            }
            xLog (hSdStressLog, 
                  (CopyTestFileData->ErrorCode == ERROR_DISK_FULL) ? XLL_WARN : XLL_FAIL, 
                  "Error detected in CopyTestFile: Error : %d Source: %s Dest: %s",
                  CopyTestFileData->ErrorCode,
                  CopyTestFileData->pszSname,
                  CopyTestFileData->pszDname);
        }
    }

    //
    // close logging
    //

    xEndVariation( hSdStressLog);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\sdstress\main.cpp ===
/*++
SdStress - Console version
main.cpp
This the MAIN SdStress - C file.

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

   SdStress - main.cpp

Abstract:

   SdStress - Storage Device Stress Utility

Author:

   Vincent Geglia (VincentG)
   ported to X-Box by John Daly

Notes:

Revision History:

1.9 - added WriteFileEx scenario

1.8 - ported to xbox

1.7 - Removed PMTE support and fixed bug in data corruption detection routine

1.63 - Removed limit on /T switch

1.62 - Changed limit on /T switch to 1000 instead of 10
       Fixed bug with code path when writing the test file fails

1.61 - Fixed regression bug with /B switch

1.6  - Fixed bug where sector size is hardcoded to 512.  Now, I look at both drives, and
       set the minimum block size to that of the device with the larger granularity

1.5  - Fixed handle leak problem on scenario 2
       Added string table for title
       Added structured exception handling for scenario 3

1.4  - Fixed bug running under Win9x where SdStress AVs when WFSO fails
       Fixed bug running under Win9x where SdStress AVs when CTRL-BREAK is hit

       (It seems that Win95 behavior for CreateThread and TerminateThread differs
       from NT in the way that Win95 may return a handle, but it may not be validated
       immediately, especially if the system is under s tremendous amount of stress. In
       addition, NT terminates all children of a parent thread when TerminateThread is
       called, but Win95 doesn't do this - result is AV with old design.  SdStress now
       simply kills the app in Win95 without cleaning up.  This is a dirty fix, but
       then again Win95 won't be around forever  :->  )

1.3  - Fixed bug in GetNumberOfFiles and GetRandomFile functions
       Added SetErrorMode so we don't see those annoying dialog boxes talking about missing
         disks, CD-ROMs, etc.
       Fixed bug in loop where CD threads run forever if only other drive is removable

1.2  - Added /LOG: switch to change logfile name.
       Added /PMTE switch to get events from DieterA's PM test shell
       Removed /JD switch in favor of /PTME
       Added Structured Exception Handling
       Optimized SDTHREAD.C by removing some code repetition
       Changed KillAllThreads to NOT force-terminate worker threads - Windows does this for me
       Removed bAbortThreads global variable.  It is not necessary to use this method
         because of the same reason above - Windows kills all my threads for me
       Created 3 new source files (ctf.c, ctfioc.c, and ctfmul.c) - these new files
         contain scenario 1, 2 and 3, respectively.
       Fixed insufficient disk space bug

1.1  - Added /JD switch for JoeDai (thread pause after x seconds)
       Change status reading for CD-ROM so it doesn't look like a bug
       Added thread synchronization when we start, with a timeout in case something goes awry
       Added a check to make sure we don't have too many threads running
       "Quieted output" (moved some output to DEBUG output)
       Set a maximum test file size of 10MB
       Changed shared variables that use -- and ++ to InterlockedDecrement and InterlockedIncrement
       Increased number of concurrent threads to 2000 (instead of MAXIMUM_WAIT_OBJECTS)
       Added logging from "TerminateThread" so ABORTs don't look like PASS

1.0  - Disabled Test Scenario 2 under Win95 - it's not supported
       Added checking on all Waits
       Added CTRL-C handler to call KillAllThreads ()
       Disabled Scenario 2 for if OS != WinNT

0.7  - Fixes as per code review:
       DeallocGetRandomFile () - changed retval to void
       KillAllThreads () - Added WaitForMultipleObjects - to allow a 30 second timeout, if
                           threads are shut down by then, TerminateThread is called.
       All exits from main do the necessary cleanup
       Moved InitThread to StartThreads
       Change DISKBLOCKSIZE, CDBLOCKSIZE to same naming convention
       defined 131072 as MAXDISKBLOCKSIZE
       Added CreateDiskInfo for DiskInfo structure creating, and validating
       Added #define for total clusters for different media
       Changed all SEV1 to SEV2 logging

0.61 - Fixed GetRandomFile function problems again, also changed random seed generation algorithm.
       Added <ESC> key polling every 15 seconds
       Added Cache Write Through switch
       Write CD file selection to screen

0.6  - Fixed the CPU hogging bug by replacing if (kbhit) with WaitForMultipleObject.  The <ESC> key no longer functions.
       Fixed GetRandomFile function problems (hanging up when file size = 0 is selected)
       Raised GetRandomFile retry count from 15 to 500.

--*/

//
// General Includes
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <ntddcdrm.h>

#include <xtl.h>
#include <stddef.h>
#include <direct.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <xtestlib.h>
#include <xlog.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <io.h>


#include "main.h"

#include "resource.h"

//
// SdStress_C dependencies
//

HANDLE SdStressHeapHandle;

#include "sdstress.h"
#include "console.c"
#include "sdthread.c"

void
InitVaribles(
    void
    )
/*++

Routine Description:

    This function initializes the application's variables

Arguments:

    None

Return Value:

    None

Notes:
    ini file options:
    B=n - Specifies block size (multiples of 512, maximum 128K)
    C=n - Specify the CD thread multiplier
    DEBUG={0|1} - Breaks into debugger when error occurs
    D=n - Specify the Disk thread multiplier
    P=n - Specify the number of passes (per thread)
    R={0|1} - Randomize block size
    S=l - Selects the specified drive for stress
    T=n - Test file size (in megabytes)
    WT={0|1} - Perform I/O operations using cache write through
    Z1={0|1} - Perform first test scenario (CopyTestFile)
    Z2={0|1} - Perform second test scenario (CopyTestFileUsingIoC)
    Z3={0|1} - Perform third test scenario (CopyTestFileMultiple)
    Z4={0|1} - Perform fourth test scenario (CopyTestFileUsingWriteFileEx)
    ZA={0|1} - Perform ALL test scenarios
    SS={0|1|2} - sets the spindle speed of the DVD

    Usage: [SDSTRESS]
       S=CDEF
       R=1
       ZA=1
    The above example will stress drives C,D,E, and F using a
    randomized block size, and all scenarios.

--*/ 
{
    int count;

    //
    // BUGBUG
    // don't check this in!
    //

//    XSetFileCacheSize( 2048 * 4096 );
    
    //
    // Zero DiskInfo structures, DriveSelected arrays
    //

    for ( count = 0; count <= MAXDRIVES; count++ ) {
        DriveSelected[count]  =  0;
        DiskInfo[count]  =  0;
    }

    //
    // Zero Thread existance array, and thread handle arrays
    //

    for ( count = 0; count <= MAXHANDLES; count++ ) {
        ThreadExist[count]  =  FALSE;
        ThreadHandles[count]  =  0;
    }

    //
    // Zero global variables
    //

    TotalStartedThreadCount = 0;
    TotalFinishedThreadCount = 0;
    FixedDiskThreadStillRunning = 0;
    TotalNumberHardDrives = 0;
    TotalNumber144Drives = 0;
    TotalNumber12Drives = 0;
    TotalNumberLS120Drives = 0;
    TotalNumberNetDrives = 0;
    TotalNumberCDROMDrives = 0;
    TotalNumberRemovableDrives = 0;
    MaximumThreadCount = 0;
    bPmte = FALSE;

    //
    // Set test defaults
    //

    bDebug = 0;
    bRandomize = 0;
    TestScenarios = 0;
    Passes = 1;
    CDThreads = 1;
    DiskThreads = 1;
    TestFileSize = 1 * MEGABYTE;
    BlockSizeMultiplier = 1;
    FileMode = 0;

}

void
AnalyzeCmdLine(
    void
    )
/*++

Routine Description:

    This function is for determining which Command Line switches
    have been selected.

Arguments:

    argc - "argc" passed from main()
    argv - "argv" passed from main()

Return Value:

    None

--*/ 
{
    #define BuffLen 200
    char iniBuffer[BuffLen] = {0};
    unsigned char count;

    //
    // logging stuff
    //

    xSetComponent(hSdStressLog, "disk", "sdstress" );
    xSetFunctionName( hSdStressLog, "AnalyzeCmdLine" );
    xStartVariation( hSdStressLog, "StartTest" );

    xLog (hSdStressLog, 
          XLL_PASS, 
          "Analyzing Command line parameters");

    //
    // Enable debugger output for SdStress
    //

    if ( GetPrivateProfileIntA("sdstress",
                               "DEBUG",
                               0,
                               "testini.ini") ) {
        xLog (hSdStressLog, 
              XLL_INFO, 
              "/DEBUG switch specified - DEBUG mode active");
        bDebug = TRUE;
    }

    //
    // Check for Randomize block size switch
    //

    if ( GetPrivateProfileIntA("sdstress",
                               "R",
                               0,
                               "testini.ini") ) {
        xLog (hSdStressLog, 
              XLL_INFO, 
              "/R switch specified - Randomizing block sizes");
        bRandomize = TRUE;
    }

    //
    // Check Disk thread multiplier switch
    //

    DiskThreads = GetPrivateProfileIntA("sdstress",
                                        "D",
                                        0,
                                        "testini.ini");

    xLog (hSdStressLog, 
          XLL_INFO, 
          "/D switch specified - %d simultaneous disk thread(s) selected",
          DiskThreads);

    //
    // Check CD Thread multiplier switch
    //

    CDThreads = GetPrivateProfileIntA("sdstress",
                                      "C",
                                      0,
                                      "testini.ini");
    xLog (hSdStressLog, 
          XLL_INFO, 
          "/C switch specified - %d simultaneous CD thread(s) selected",
          CDThreads);

    //
    // Check TestFileSize switch
    //

    TestFileSize = GetPrivateProfileIntA("sdstress",
                                         "T",
                                         1,
                                         "testini.ini");
    TestFileSize *= MEGABYTE;
    xLog (hSdStressLog, 
          XLL_INFO, 
          "/T switch specified - New test file size is %ld bytes",
          TestFileSize);

    //
    // Check NumberOfPasses switch
    //

    Passes = GetPrivateProfileIntA("sdstress",
                                   "P",
                                   1,
                                   "testini.ini");
    xLog (hSdStressLog, 
          XLL_INFO, 
          "/P switch specified - Number of test passes is %d",
          Passes);

    //
    // Check copy block size switch
    //

    BlockSizeMultiplier = GetPrivateProfileIntA("sdstress",
                                                "B",
                                                1,
                                                "testini.ini");

    if ( BlockSizeMultiplier && bRandomize ) {
        xLog (hSdStressLog, 
              XLL_INFO, 
              "/R switch already specified, ignoring /B switch.");
        BlockSizeMultiplier = 1;
    } else if ( BlockSizeMultiplier > MAX_BLOCK_MULTIPLIER ) {
        xLog (hSdStressLog, 
              XLL_INFO, 
              "/B switch specified, but illegal block multiplier.  Ignoring...");
        BlockSizeMultiplier = 1;
    } else {
        xLog (hSdStressLog, 
              XLL_INFO, 
              "/B switch specified - Block size multiplier is set to %d",
              BlockSizeMultiplier);
    }

    //
    // Drive selection switch - selection go into the DriveSelected array
    //

    if ( GetPrivateProfileStringA("sdstress",
                                  "S",
                                  "c",
                                  iniBuffer,
                                  BuffLen,
                                  "testini.ini"
                                 ) ) {
        xLog (hSdStressLog, 
              XLL_INFO, 
              "/S switch specified, the following drives are selected for stress:");
        //
        // _strupr was broken, so use this hack
        //

        char *cp;
        for ( cp = iniBuffer; *cp; ++cp ) {
            if ( 'a' <= *cp && *cp <= 'z' )
                *cp += 'A' - 'a';
        }
        count = 0;
        while ( iniBuffer[count] ) {
            if ( iniBuffer[count] >= 'A' && iniBuffer[count] <= 'Z' ) {
                DriveSelected[count] = iniBuffer[count];
                xLog (hSdStressLog, 
                      XLL_INFO, 
                      "--> Drive %c: is selected.", iniBuffer[count]);
            }
            count++;
        }
    }

    //
    // Force test scenario #1 switch
    //

    if ( GetPrivateProfileIntA("sdstress",
                               "Z1",
                               0,
                               "testini.ini") ) {
        xLog (hSdStressLog, 
              XLL_INFO, 
              "/Z1 switch specified, test scenario one is selected (CopyTestFile)");
        TestScenarios = TestScenarios | CTF;
    }

    //
    // Force test scenario #2 switch
    //

    if ( GetPrivateProfileIntA("sdstress",
                               "Z2",
                               0,
                               "testini.ini") ) {
        xLog (hSdStressLog, 
              XLL_INFO, 
              "/Z2 switch specified, test scenario two is selected (CopyTestFileUsingIoC)");
        TestScenarios = TestScenarios | CTF_IOC;
    }

    //
    // Force test scenario #3 switch
    //

    if ( GetPrivateProfileIntA("sdstress",
                               "Z3",
                               0,
                               "testini.ini") ) {
        xLog (hSdStressLog, 
              XLL_INFO, 
              "/Z3 switch specified, test scenario three is selected (CopyTestFileMultiple)");
        TestScenarios = TestScenarios | CTF_MULTIPLE;
    }

    //
    // Force test scenario #4 switch
    //

    if ( GetPrivateProfileIntA("sdstress",
                               "Z4",
                               0,
                               "testini.ini") ) {
        xLog (hSdStressLog, 
              XLL_INFO, 
              "/Z4 switch specified, test scenario four is selected (CopyTestFileUsingWriteFileEx)");
        TestScenarios = TestScenarios | CTF_WFEX;
    }

    //
    // Use all test scenarios switch
    //

    if ( GetPrivateProfileIntA("sdstress",
                               "ZA",
                               0,
                               "testini.ini") ) {
        xLog (hSdStressLog, 
              XLL_INFO, 
              "/ZA switch specified, all test scenarios are selected");
        TestScenarios = TestScenarios | 0xff;
    }

    //
    // FILE_FLAG_WRITE_THROUGH switch
    //

    if ( GetPrivateProfileIntA("sdstress",
                               "WT",
                               0,
                               "testini.ini") ) {
        xLog (hSdStressLog, 
              XLL_INFO, 
              "/WT switch specified, I/O performed with cache write through");
        FileMode = FILE_FLAG_WRITE_THROUGH;
    }

    //
    // Spindle Speed switch
    //

    SpindleSpeed = GetPrivateProfileIntA("sdstress",
                               "SS",
                               0,
                               "testini.ini");
    
    xLog (hSdStressLog, 
          XLL_INFO, 
          "/SS switch specified, Spindle Speed set to : %d", 
          SpindleSpeed);

    //
    // close this variation
    //

    xEndVariation( hSdStressLog);

}

BOOL
AnalyzeDrives(
    void
    )
/*++

Routine Description:

    This function will analyze all of the selected drives, and gather
    information about them. This function will also toss out drives that
    are not valid.

Arguments:

    None

Return Value:

    None

--*/ 
{
    int count;
    char szBuffer[100];
    DWORDLONG dwlRequiredSpace = 0L;

    //
    // Set up prototype variable
    //

    WriteTextConsole ("\nDetermining disk types:\n", HEADERCOLOR, XLL_INFO);

    //
    // Cycle through DriveSelected to see which drive letters have been selected
    //

    for ( count = 0;count <= MAXDRIVES; count ++ ) {

        //
        // See if drive is valid (0 = not valid)
        //

        if ( DriveSelected[count] ) {

            //
            // Get drive information, allocate and fill DISKINFO structure for each drive.
            //

            CreateDiskInfo (DriveSelected[count], count);
        }
    }

    //
    // Determine disk space requirements.
    //

    WriteTextConsole("\nDetermining disk space requirements:\n", HEADERCOLOR, XLL_INFO);

    for ( count = 0; count <= MAXDRIVES; count ++ ) {
        if ( (DiskInfo[count]) && DiskInfo[count]->Type ) {
            switch ( DiskInfo[count]->Type ) {
                
                case SD_FIXED:
                case SD_REMOVABLE:
                case SD_LS120:
                case SD_NETWORK:
                    {

                        dwlRequiredSpace = TestFileSize +
                                           (DiskThreads * (TestFileSize) * (TotalNumberHardDrives)) +
                                           ((TotalNumber12Drives+TotalNumber144Drives) * FLOPSIZE * DiskThreads) +
                                           ((TotalNumberLS120Drives) * DiskThreads * (TestFileSize)) +
                                           ((TotalNumberCDROMDrives) * CDThreads * (1 * MEGABYTE));

                        break;
                    }

                case SD_CDROM:
                    {
                        dwlRequiredSpace = 0;
                        break;
                    }

                case SD_FLOPPY12:
                case SD_FLOPPY144:
                    {
                        dwlRequiredSpace = FLOPSIZE +
                                           (DiskThreads * FLOPSIZE * TotalNumberHardDrives) +
                                           ((TotalNumber12Drives + TotalNumber144Drives) * FLOPSIZE * DiskThreads) +
                                           ((TotalNumberLS120Drives) * DiskThreads * (TestFileSize)) +
                                           ((TotalNumberCDROMDrives) * CDThreads * 2048);  // Hardcoding 2048 is bad
                    }
                default:
                    {
                        break;
                    }
            }

            //
            // Show available / required space comparison
            //

            sprintf (szBuffer,
                     "Drive %c: - Required space is %I64d\n",
                     DiskInfo[count]->Letter,
                     dwlRequiredSpace);

            WriteTextConsole (szBuffer, NORMALTEXTCOLOR, FALSE);

            //
            // was BUGBUG - this check turned off until tracy fixes the filesystem
            // turned back on - make sure it works
            //

            if ( dwlRequiredSpace > DiskInfo[count]->TotalFreeSpace.QuadPart ) {
                sprintf (szBuffer, "Drive %c: does not have enough free space.  Ignoring.\n", DiskInfo[count]->Letter);
                WriteTextConsole (szBuffer, ERRORCOLOR, XLL_WARN);
                sprintf (szBuffer, "Drive %c: free space:%I64d  Required space:%I64d \n",
                         DiskInfo[count]->Letter,
                         DiskInfo[count]->TotalFreeSpace.QuadPart,
                         dwlRequiredSpace);
                WriteTextConsole (szBuffer, ERRORCOLOR, XLL_WARN);
                if ( !DeleteDiskInfo (DiskInfo[count]) ) {
                    return(FALSE);
                }
            }
        }
    }


    //
    // Check to make sure current disk configuration is valid
    //

    return(ValidateTestConfiguration ());
}

BOOL
DeleteDiskInfo (
    DISKINFO *DskInfo
    )
/*++

Routine Description:

    This function deletes a drive's info structure.

Arguments:

    DISKINFO structure - Contains information about drive

Return Value:

    Value from ValidateTestConfiguration ()

--*/ 
{

    //
    // Update the tally of drive types
    //

    switch ( DskInfo->Type ) {
        case SD_CDROM:
            TotalNumberCDROMDrives --;
            break;
        case SD_FIXED:
            TotalNumberHardDrives --;
            break;
        case SD_NETWORK:
            TotalNumberNetDrives --;
            break;
        case SD_FLOPPY144:
            TotalNumber144Drives --;
            break;
        case SD_FLOPPY12:
            TotalNumber12Drives --;
            break;
        case SD_LS120:
            TotalNumberLS120Drives --;
            break;
        case SD_REMOVABLE:
            TotalNumberRemovableDrives --;
            break;
        default:
            break;
    }

    //
    // Make sure drive configuration is still valid after deleting a drive from the list
    //

    if ( ValidateTestConfiguration () == FALSE ) {
        return(FALSE);
    }

    //
    // Invalidated drives get a type of SD_VOID
    //

    return(TRUE);
}

BOOL
CreateTestFiles(
    void
    )
/*++

Routine Description:

    This function creates the test files on all selected devices.

Arguments:

    None

Return Value:

    TRUE if success
    FALSE if failed

--*/ 
{
    CHAR PathName[50];
    char szBuffer[100];
    BOOL bSuccess;
    UINT count;
    HANDLE hFile;
    long ErrorCode;
    ULONG lCount = 0;
    DWORD dwAccessed;

    xSetComponent(hSdStressLog, "disk", "sdstress" );
    xSetFunctionName( hSdStressLog, "CreateTestFiles" );
    xStartVariation( hSdStressLog, "variation1" );

    //
    // Loop to fill buffer
    //

    while ( lCount < TestFileSize ) {
        pszDataImage[lCount] = rand () % 255;
        lCount++;
    }

    xLog (hSdStressLog, 
          XLL_INFO, 
          "Creating files used for test:");

    //
    // Main loop for test file generation
    //

    for ( count = 0; count <= MAXDRIVES; count ++ ) {

        //
        // IF the DiskInfo structure is valid
        //

        if ( (DiskInfo[count]) && DiskInfo[count]->Type ) {
            sprintf (szBuffer, "Drive %c: - ", DiskInfo[count]->Letter);

            //
            // If the target is CD-ROM, then do not attempt to create a file.
            //

            if ( DiskInfo[count]->Type == SD_CDROM ) {
                xLog (hSdStressLog, 
                      XLL_INFO, 
                      "%sDrive is READ-ONLY (CDROM).  No test file created.",
                      szBuffer);
            }

            //
            // Otherwise, create a test file
            //

            else {
                xLog (hSdStressLog, 
                      XLL_INFO, 
                      "Creating %c:\\SDDATA\\TESTFILE.DAT.",
                      DiskInfo[count]->Letter);

                //
                // Assemble path to test directory
                //

                sprintf (PathName, "%c:\\SDDATA", DiskInfo[count]->Letter);

                //
                // Try to go there.  If unable, try to MAKE the directory
                //

                struct _stat _s;

                if ( _stat (PathName, &_s) && _mkdir (PathName) ) {

                    //
                    // If directory cannot be made, then abort this attempt, and toss out drive.
                    // Retrieve the last error
                    //

                    ErrorCode = GetLastError();

                    xLog (hSdStressLog, 
                          XLL_WARN, 
                          "Drive %c: - Error creating testfile, ignoring drive. GetLastError() = %d",
                          DiskInfo[count]->Letter, 
                          ErrorCode);

                    //
                    // Delete structure pertaining to drive
                    //

                    DeleteDiskInfo (DiskInfo[count]);
                }

                //
                // Append testfile name on the end of the pathname.
                //

                strcat (PathName, "\\TESTFILE.DAT");

                //
                // Create the file, always
                //

                hFile = CreateFile(PathName,
                                   GENERIC_WRITE,
                                   0,
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
                                   NULL);

                //
                // If it fails,  toss out the drive.
                //

                if ( hFile == INVALID_HANDLE_VALUE ) {

                    ErrorCode = GetLastError();
                    xLog (hSdStressLog, 
                          XLL_FAIL, 
                          "Drive %c: - Error creating testfile, ignoring drive. GetLastError() = %d",
                          DiskInfo[count]->Letter,
                          ErrorCode);
                    DeleteDiskInfo (DiskInfo[count]);
                    DiskInfo[count] = NULL;
                    break;
                }

                //
                // Write test file to disk
                //

                bSuccess = WriteFile(hFile,
                                     pszDataImage,
                                     DiskInfo[count]->TestFileSize,
                                     &dwAccessed,
                                     NULL);

                //
                // IF it fails, toss out the drive.
                //

                if ( dwAccessed != DiskInfo[count]->TestFileSize || !bSuccess ) {

                    ErrorCode = GetLastError();
                    xLog (hSdStressLog, 
                          XLL_FAIL, 
                          "Drive %c: - Error creating testfile, ignoring drive. GetLastError() = %d",
                          DiskInfo[count]->Letter,
                          ErrorCode);
                    DeleteDiskInfo (DiskInfo[count]);
                    DiskInfo[count] = NULL;
                    break;
                }

                //
                // Flush and Close file
                //

                xLog (hSdStressLog, 
                      XLL_PASS, 
                      "Drive %c: - created testfile, using drive.",
                      DiskInfo[count]->Letter);

                FlushFileBuffers (hFile);
                CloseHandle (hFile);
            }
        }
    }

    xEndVariation( hSdStressLog);
    return(TRUE);
}

BOOL
ValidateTestConfiguration(
    void
    )
/*++

Routine Description:

   This function will verify the drive configuration is acceptable

Arguments:

    None

Return Value:

    TRUE if success
    FALSE if not success

--*/ 
{

    //
    // IF any CD-ROMs exist without a target, the test shall exit
    //

    if ( !TotalNumber144Drives &&
         !TotalNumber12Drives &&
         !TotalNumberLS120Drives &&
         !TotalNumberNetDrives &&
         !TotalNumberRemovableDrives &&
         !TotalNumberHardDrives ) {
        WriteTextConsole ("Invalid test configuration (Drive Selection) \n\n",
                          ERRORCOLOR,
                          XLL_WARN);

        return(FALSE);
    }

    return(TRUE);
}

BOOL
AllocGetRandomFile (
    void
    )
/*++

Routine Description:

    This function allocates the memory used by GetRandomFile

Arguments:

    None

Return Value:

    TRUE if no error
    FALSE if error

--*/ 
{
    int count;

    for ( count = 0; count < SD_MAXDIRS; count ++ ) {

        pszSubDirList[count] = (char *)HeapAlloc(SdStressHeapHandle, HEAP_ZERO_MEMORY, SUBDIRLISTSIZE);

        if ( !pszSubDirList[count] ) {
            return(FALSE);
        }
    }
    return(TRUE);
}

void
DeallocGetRandomFile (
    void
    )
/*++

Routine Description:

    This function deallocates the memory used by GetRandomFile

Arguments:

    None

Return Value:

    None

--*/ 
{
    int count;

    if (NULL == SdStressHeapHandle) {
        return;
    }

    for ( count = 0; count < SD_MAXDIRS; count ++ ) {
        if ( pszSubDirList[count] ) {
            HeapFree (SdStressHeapHandle, 0, pszSubDirList[count]);
        }
    }
}

void
StartThreads (
    char TestType
    )
/*++

Routine Description:

    This function initializes the worker threads

Arguments:

    char TestType

Return Value:

    None

--*/ 
{
    UCHAR SourceCount, DestCount, Instance;
    char Buffer[200];
    THREAD_DATA *pThreadData;
    LONG ThreadCounter = 0, ThreadHandleCounter = 0, counter = 0;
    DWORD ThreadID, ErrorCode, RetryCount;
    int WaitCount = 0;
    DWORD WaitStatus;

    switch ( TestType ) {
        case CTF:
            {
                WriteTextConsole ("** Test Scenario 1 - CopyTestFile **",
                                  HEADERCOLOR,
                                  FALSE);

                break;
            }

        case CTF_IOC:
            {
                WriteTextConsole ("** Test Scenario 2 - CopyTestFileUsingIoC **",
                                  HEADERCOLOR,
                                  FALSE);
                break;
            }

        case CTF_MULTIPLE:
            {
                WriteTextConsole ("** Test Scenario 3 - CopyTestFileMultiple **",
                                  HEADERCOLOR,
                                  FALSE);
                break;
            }

        case CTF_WFEX:
            {
                WriteTextConsole ("** Test Scenario 4 - CopyTestFileUsingWriteFileEx **",
                                  HEADERCOLOR,
                                  FALSE);
                break;
            }

        default:
            {
                WriteTextConsole ("Unknown Test scenario selected.  Ignoring...",
                                  ERRORCOLOR,
                                  FALSE);
                return;
            }
    }

    WriteTextConsole("\nInitializing threads\n", HEADERCOLOR, FALSE);

    //
    // NOTE - this can create a LOT of threads, basically :
    // (source drives) * (destination drives) * (thread multiplier)
    //
    // every thread that gets started here (SdStressThread()) creates 1 worker 
    // thread (the test)
    // this can easily result in hundreds of threads that use a LOT of memory
    // 
    
    //
    // for the number of source drives (all readable drives)
    //

    for ( SourceCount = 0; SourceCount <= MAXDRIVES; SourceCount ++ ) {

        if ( DiskInfo[SourceCount] && DiskInfo[SourceCount]->Type != SD_VOID ) {

            //
            // for the number of destination drives (all writeable drives)
            //

            for ( DestCount = 0; DestCount <= MAXDRIVES; DestCount ++ ) {

                if ( DiskInfo[DestCount] && DiskInfo[DestCount]->Type != SD_CDROM && DiskInfo[DestCount]->Type != SD_VOID ) {

                    if ( DiskInfo[SourceCount]->Type != SD_CDROM ) {
                        ThreadCounter = DiskThreads;
                    } else {
                        ThreadCounter = CDThreads;
                    }

                    //
                    // for the DiskThreads or CDThreads entry in testini.ini...
                    //
                    
                    for ( Instance = 1; Instance <= ThreadCounter; Instance++ ) {

                        //
                        // Make sure we're not exceeding maximum thread count
                        //

                        if ( ThreadHandleCounter >= MAXHANDLES ) {
                            WriteTextConsole ("Maximum number of threads exceeded - Ignoring additional threads.\n",
                                              ERRORCOLOR,
                                              FALSE);

                            goto SyncThreads;
                        }

                        pThreadData = (THREAD_DATA *)HeapAlloc( SdStressHeapHandle, HEAP_ZERO_MEMORY, sizeof(THREAD_DATA));
                        if ( NULL == pThreadData ) {
                            printf ("FATAL ERROR:  Cannot allocate memory.\n\n");
                            goto CleanUpAndExit;
                        }

                        pThreadData->SrcDrive = DiskInfo[SourceCount];
                        pThreadData->DestDrive = DiskInfo[DestCount];
                        pThreadData->ThreadInstance = Instance;
                        pThreadData->ThreadExist = &ThreadExist[ThreadHandleCounter];
                        pThreadData->TestType = TestType;

                        ThreadHandles[ThreadHandleCounter] = CreateThread (NULL,
                                                                           0,
                                                                           &SdStressThread,
                                                                           pThreadData,
                                                                           0,
                                                                           &ThreadID);

                        sprintf (Buffer,
                                 "Thread init'd - Src:%c, Dst:%c, Instance:%d\n",
                                 pThreadData->SrcDrive->Letter,
                                 pThreadData->DestDrive->Letter,
                                 pThreadData->ThreadInstance);

                        WriteTextConsole (Buffer,
                                          CMDLINECOLOR,
                                          FALSE);

                        if ( !ThreadHandles[ThreadHandleCounter] ) {
                            PrintError (GetLastError());
                            WriteTextConsole ("Could not create thread.\n",
                                              ERRORCOLOR,
                                              FALSE);
                        }

                        else {
                            ThreadHandleCounter ++;
                        }
                    }
                }
            }
        }
    }

    SyncThreads:

    WriteTextConsole ("\n",
                      HEADERCOLOR,
                      FALSE);

    //
    // Set MaximumThreadCount (global variable)
    // at this point, we know how many threads we tried to start, 
    // and the started threads have incremented TotalThreadCount
    // spin until ThreadHandleCounter == TotalThreadCount
    //

    MaximumThreadCount = ThreadHandleCounter;

    do {
        sprintf (Buffer,
                 "started %d Threads - : %d Threads reported starting.\n",
                 MaximumThreadCount,
                 TotalStartedThreadCount);
        Debug_Print(Buffer);
        Sleep(2000);
    } while ( MaximumThreadCount > TotalStartedThreadCount );

    Debug_Print ("Worker threads all accounted for.\n");

    RetryCount = 0;

    //
    // wait for all the threads to finish
    // TotalStartedThreadCount = the counter incremeted by the spawned threads
    // TotalFinishedThreadCount = the counter decremented by the spawned threads
    // waits 24 hours by default
    //
    
    while ( TotalStartedThreadCount + TotalFinishedThreadCount ) {
        Sleep (2000);

        RetryCount ++;

        if ( RetryCount > THREAD_WAIT_MULTIPLIER ) {
            WriteTextConsole ("Thread termination timeout expired.  Possible deadlock.\n\n",
                              ERRORCOLOR,
                              FALSE);

            OutputDebugStringA("SDSTRESS will probably crash if you see this, let johndaly know.");
            DebugBreak();
//            break;
        }

    }

    CleanUpAndExit:

    //
    // clean up thread handles
    //

    for ( counter = 0; counter < ThreadHandleCounter; counter++ ) {
        if ( ThreadHandles[counter] ) {
            CloseHandle(ThreadHandles[counter]);
        }
        ThreadHandles[counter] = NULL;
    }

    return;
}

#define MY_DRIVE_FIXED 3
#define MY_DRIVE_CDROM 5

void
CreateDiskInfo (
    UCHAR DriveLetter,
    INT count
    )
/*++

Routine Description:

    This function creates a DiskInfo structure for a particular drive

Arguments:

    UCHAR DriveLetter
    INT count

Return Value:

    None

--*/ 
{
    char szBuffer[200];
    CHAR szPath[50];

    sprintf (szPath,
             "%c:\\",
             DriveLetter);

    DiskInfo[count] = (DISKINFO *)HeapAlloc(SdStressHeapHandle, HEAP_ZERO_MEMORY, sizeof(DISKINFO));

    //
    // this is bad...
    // consider re-writing to fail gracefully
    //

    if ( NULL == DiskInfo[count] ) {
        WriteTextConsole ("Memory Allocation Failure!.\n\n",
                          ERRORCOLOR,
                          XLL_FAIL);
    }

    //
    // Put drive letter in structure
    //

    DiskInfo[count]->Letter = DriveLetter;

    //
    // get sector size
    //

    DiskInfo[count]->BytesPerSector = XGetDiskSectorSize(szPath);

    //
    // Determine drive type
    //
    // WARNING!!!!
    //
    // Using hard coded data from xbox specs
    // yes, I know a little table would be more efficient...
    //

    // assumes you are using the hack to re-map the CD to this drive
    if ( ((L'A' == szPath[0]) || (L'a' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_CDROM;

    // unused
    //if (((L'B' == szPath[0]) || (L'b' == szPath[0]))) DiskInfo[count]->Type = MY_DRIVE_CDROM;

    // assumes you are using the hack to re-map the dafault title partition to this drive
    if ( ((L'C' == szPath[0]) || (L'c' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;

    // this will change in retail configurations
    if ( ((L'D' == szPath[0]) || (L'd' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;

    // should point to 'c:\devkit' - or nothing
    if ( ((L'E' == szPath[0]) || (L'e' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;

    // MUs - little hard disks!
    if ( ((L'F' == szPath[0]) || (L'f' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;
    if ( ((L'G' == szPath[0]) || (L'g' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;
    if ( ((L'H' == szPath[0]) || (L'h' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;
    if ( ((L'I' == szPath[0]) || (L'i' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;
    if ( ((L'J' == szPath[0]) || (L'j' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;
    if ( ((L'K' == szPath[0]) || (L'k' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;
    if ( ((L'L' == szPath[0]) || (L'l' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;
    if ( ((L'M' == szPath[0]) || (L'm' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;
    
    // unused
    //if ( ((L'N' == szPath[0]) || (L'n' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;
    //if ( ((L'O' == szPath[0]) || (L'o' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;

    // unused
    //if (((L'P' == szPath[0]) || (L'p' == szPath[0]));
    //if (((L'Q' == szPath[0]) || (L'q' == szPath[0]));
    //if (((L'R' == szPath[0]) || (L'r' == szPath[0]));
    //if (((L'S' == szPath[0]) || (L's' == szPath[0]));

    // title data
    if ( ((L'T' == szPath[0]) || (L't' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;

    // user data
    if ( ((L'U' == szPath[0]) || (L'u' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;

    // unused
    //if (((L'V' == szPath[0]) || (L'v' == szPath[0]));
    //if (((L'W' == szPath[0]) || (L'w' == szPath[0]));

    //can map to useres data region
    if ( ((L'X' == szPath[0]) || (L'x' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;

    // can map to title data region
    if ( ((L'Y' == szPath[0]) || (L'y' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;

    // utility partition
    if ( ((L'Z' == szPath[0]) || (L'z' == szPath[0])) ) DiskInfo[count]->Type = MY_DRIVE_FIXED;

    //
    // Show user what info SdStress has found.
    //

    //
    // Fill structure with cluster information / free space
    //

    if (DiskInfo[count]->Type != MY_DRIVE_CDROM &&
        !GetDiskFreeSpaceEx(szPath,
                            &DiskInfo[count]->TotalFreeSpace,
                            &DiskInfo[count]->TotalNumberOfBytes,
                            &DiskInfo[count]->TotalNumberOfFreeBytes) ) {

        sprintf (szBuffer,
                 "Error accessing Drive %c. Error : %d Ignoring...",
                 DriveLetter,
                 GetLastError());
        DeleteDiskInfo(DiskInfo[count]);
        DiskInfo[count] = NULL;
        return;
    }

    switch ( DiskInfo[count]->Type ) {
        
        case MY_DRIVE_FIXED:
            {
                TotalNumberHardDrives ++;
                DiskInfo[count]->Type = SD_FIXED;
                sprintf(szBuffer, "Drive %c: is a Fixed Disk", DiskInfo[count]->Letter);
                DiskInfo[count]->TestFileSize = TestFileSize;
                break;
            }

        case MY_DRIVE_CDROM:
            {
                TotalNumberCDROMDrives ++;
                DiskInfo[count]->Type = SD_CDROM;
                sprintf(szBuffer, "Drive %c: is a CD-ROM", DiskInfo[count]->Letter);
                DiskInfo[count]->TestFileSize = 0;

                //
                // Get number of files on the CDROM
                //

                WriteTextConsole ("Retrieving number of files on CDROM...",
                                  NORMALTEXTCOLOR,
                                  FALSE);

                DiskInfo[count]->NumberOfFiles = GetNumberOfFiles(DiskInfo[count]->Letter);

                if ( !DiskInfo[count]->NumberOfFiles ) {
                    WriteTextConsole ("\nNo files on CD! Ignoring...", ERRORCOLOR, FALSE);
                    DeleteDiskInfo (DiskInfo[count]);
                    DiskInfo[count] = NULL;
                }
                break;
            }

            //
            // If drive type cannot be determined, do not use it. Get rid of DiskInfo structure pertaining to that drive.
            //

        default:
            {
                sprintf (szBuffer, "Drive %c: is of an unknown type. Ignoring", DiskInfo[count]->Letter);
                WriteTextConsole (szBuffer, ERRORCOLOR, FALSE);
                DeleteDiskInfo (DiskInfo[count]);
                break;
            }
    }

    //
    // Show user free space.
    // Also make sure drive wasn't deleted because either not supported or unknown type.
    //

    if ( (DiskInfo[count]) && DiskInfo[count]->Type ) {
        sprintf (szBuffer, "%c with %I64u bytes free space remaining.\n",
                 DiskInfo[count]->Letter,
                 DiskInfo[count]->TotalFreeSpace);

        WriteTextConsole (szBuffer, NORMALTEXTCOLOR, FALSE);
    }

}

VOID
WINAPI
SdStressStartTest(
    HANDLE LogHandle
    )
/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/ 
{
    char szTitle[100] = "SdStress - Storage Device Stress utility, Version ";
    char szBuffer[200];

    //
    // initialize global logging handle
    //

    hSdStressLog = LogHandle;

    __try
    {
        //
        // create a heap
        //

        SdStressHeapHandle = HeapCreate( 0, 0, 0 );

        if ( NULL == SdStressHeapHandle ) {
            OutputDebugString( TEXT("savegame: Unable to create heap\n") );

            __leave;
        }

        //
        // initialize random numbers - be deterministic
        //

        srand ((unsigned) 1);

        //
        // Initialize Variables
        //

        InitVaribles ();

        //
        // This is where it begins, showing app's title, analyzing system components.
        //

        strcat (szTitle, VER_PRODUCTVERSION_STR);
        WriteTextConsole (szTitle, TITLECOLOR, FALSE);

        WriteTextConsole ("OS: Xbox\n", ERRORCOLOR, FALSE);

        //
        // Allocate memory for GetRandomFile function.
        //

        if ( !AllocGetRandomFile () ) {
            WriteTextConsole ("\n\nMemory allocation error!\n",
                              ERRORCOLOR,
                              FALSE);

            __leave;
        }

        //
        // this is kind of a lie, it really looks in the ini file
        //

        AnalyzeCmdLine ();

        pszDataImage = AllocateMemory (TestFileSize);

        if ( !pszDataImage ) {
            WriteTextConsole ("\n\nMemory allocation error!\n",
                              ERRORCOLOR,
                              FALSE);

            __leave;
        }

        if ( !AnalyzeDrives () ) {
            __leave;
        }

        if ( CreateTestFiles () == FALSE ) {
            __leave;
        }

        SetSpindleSpeed();

        //
        // Create the worker threads, if test scenario #1 is selected
        //

        if ( (TestScenarios & CTF) == CTF || !TestScenarios ) {
            StartThreads (CTF);
        }
        
        if ( (TestScenarios & CTF_IOC) == CTF_IOC ) {
            StartThreads (CTF_IOC);
        }
        
        if ( (TestScenarios & CTF_MULTIPLE) == CTF_MULTIPLE ) {
            StartThreads (CTF_MULTIPLE);
        }

        if ( (TestScenarios & CTF_WFEX) == CTF_WFEX ) {
            StartThreads (CTF_WFEX);
        }
    }

    __finally
    {
        //
        // Deallocate memory from GetRandomFile (Check done at function level)
        //

        DeallocGetRandomFile ();

        //
        // Deallocate memory for pszDataImage (Check done at function level)
        //

        DeAllocateMemory (TestFileSize, pszDataImage);

        //
        // check and destroy heap
        //

        if ( SdStressHeapHandle ) {
            HeapDestroy( SdStressHeapHandle );
        }

        //
        // print out error count
        //

        sprintf (szBuffer, "************Total Error Count : GlobalErrorCounter=%d\n", GlobalErrorCounter);
        Debug_Print (szBuffer);


    }
}

VOID
WINAPI
SetSpindleSpeed(
    VOID
    )
/*++

Routine Description:

    Sets the spindle speed of the DVD drive
    
Arguments:

    None

Return Value:

    None

--*/ 
{
    BOOL status;
    HANDLE fileHandle;
    ULONG returned;
    OCHAR    string[100];
    NTSTATUS NTStatus;
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING VolumeString;
    IO_STATUS_BLOCK IoStatusBlock;
    
    soprintf (string, OTEXT("\\Device\\CdRom0"));

    RtlInitObjectString(&VolumeString, string);
    InitializeObjectAttributes(&ObjA,&VolumeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

    NTStatus = NtCreateFile(&fileHandle,
                            SYNCHRONIZE|GENERIC_READ,
                            &ObjA,
                            &IoStatusBlock,
                            0,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ, FILE_OPEN,
                            FILE_SYNCHRONOUS_IO_NONALERT);

    if ( NT_SUCCESS(NTStatus)) {

    status = DeviceIoControl(fileHandle,
                             IOCTL_CDROM_SET_SPINDLE_SPEED,
                             &SpindleSpeed,
                             sizeof(SpindleSpeed),
                             NULL,
                             0,
                             &returned,
                             NULL);
    }
    
    //
    // Clean up
    //
    
    if (fileHandle) {
        NtClose(fileHandle);
    }

    return;
}

VOID
WINAPI
SdStressEndTest(
    VOID
    )
/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/ 
{
    OutputDebugString( TEXT("SDSTRESS: EndTest is called\n") );
}


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( sdstress )
#pragma data_seg()

BEGIN_EXPORT_TABLE( sdstress )
EXPORT_TABLE_ENTRY( "StartTest", SdStressStartTest )
EXPORT_TABLE_ENTRY( "EndTest", SdStressEndTest )
END_EXPORT_TABLE( sdstress )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dvdread\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct TVertex
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
    float u, v;         // Texture coordinates
};

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\sdstress\main.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    main.h

Abstract:

    This the MAIN SdStress - Console header file.

Author / ported by:

    John Daly (johndaly) porting date 4/29/2000

Revision History:

    initial port: johndaly 4/29/2000
        port from NT

--*/

//
// General definitions
//

namespace SDStressNameSpace {

    #define MAXDRIVES 15
    #define MAXHANDLES 2000
    #define MEGABYTE 1048576
    #define FLOPSIZE 512
    #define SD_MAXDIRS 1024 // list of dirs containing files - only used when there is removable media
    #define SCEN3REDO 32
    #define MAXRETRIES 500
    #define SUBDIRLISTSIZE 300
    #define ESC_POLL_TIME 15000
    #define NO_LOG 0
    #define MAXDISKBLOCKSIZE 131072
    #define HDFLOPCLUSTERS 2371
    #define HD144CLUSTERS 2847
    #define LS120CLUSTERS 61503
    #define KILL_THREADS 0x0000FFFF
    #define STOP_THREADS 0x0F0F0F0F
    #define THREAD_WAIT_MULTIPLIER 3600 * 12
    #define INITIAL_PMTE_RESTART_TIMEOUT 20000
    #define MAX_WAIT_RETRIES 100
    #define MAX_BLOCK_MULTIPLIER 256
    #define EXIT_PROCESS             0
    
    //
    // Time definitions
    //
    
    #define THREAD_INITIAL_SYNC     600000
    #define THREAD_TIMEOUT          30000
    #define VERIFY_THREAD_TIMEOUT   INFINITE   // was 60000, but we were having problems
    #define STD_THREAD_TIMEOUT      INFINITE
    #define COMPLETION_TIMEOUT      60000
    #define TERMINATION_TIMEOUT     240000
    //#define FAILED_GRF_STALL        50000
    #define FAILED_GRF_STALL        1000
    
    //
    // Test type definitions
    //
    
    #define CTF 1
    #define CTF_IOC 2
    #define CTF_MULTIPLE 4
    #define CTF_WFEX 8
    
    //
    // Kernel Debugger switch
    //
    
    #define KDENABLED 1
    
    //
    // Color Definitions
    //
    
    #define ERRORCOLOR 12
    #define NORMALTEXTCOLOR 13 
    #define INVERSENORMALCOLOR 208
    #define DRIVETYPECOLOR 208
    #define DRIVESELECTED 13
    #define CMDLINECOLOR 13
    #define HEADERCOLOR 11
    #define PASSCOLOR 10
    #define CDFILESELECT 9
    #define ABORTCOLOR 8
    #define DEBUGCOLOR 14
    #define CMDCOLOR 11
    #define WARNCOLOR 14
    #define TITLECOLOR 10
    
    //
    // Drive Types
    //
    
    #define SD_FIXED 1
    #define SD_CDROM 2
    #define SD_NETWORK 3
    #define SD_FLOPPY144 4
    #define SD_FLOPPY12 5
    #define SD_LS120 6
    #define SD_REMOVABLE 7
    #define SD_VOID 0
    
    //
    // Error codes
    //
    
    #define E_CDROMCOPY 12
    #define E_COPY 4
    #define E_TESTFILE 1
    #define E_MEMORY 2
    #define E_VERIFY 3
    #define E_VERIFYREAD 5
    #define E_VERIFYCOPY 6
    #define E_NOHANDLE 7
    #define E_DELETE 8
    #define E_DISKSPACE 9
    #define E_ACCESSSdStress 14
    #define E_NOPOINTER 11
    #define E_SEEK 13
    #define E_SDABORT 10
    #define E_DEALLOC 15
    #define E_THREAD 16
    
    struct DISKINFO {
         char Letter;
         UINT Type;
         ULARGE_INTEGER TotalFreeSpace;
         ULARGE_INTEGER TotalNumberOfBytes;
         ULARGE_INTEGER TotalNumberOfFreeBytes;
         DWORD BytesPerSector;
         DWORD TestFileSize;
         long NumberOfFiles;
    };
    
    struct THREAD_DATA 
    {
         DISKINFO *SrcDrive;
         DISKINFO *DestDrive;
         UINT ThreadInstance;
         BOOL *ThreadExist;
         char TestType;
         long Passes;
         UINT Count;
    };
    
    struct COPYTESTFILE_DATA {
         char *pszSname;
         char *pszDname;
         DWORD lFileSize;
         DWORD BlockSize;
         DWORD MinimumBlockSize;
         long ErrorCode;
         long retval;
         THREAD_DATA *ThreadData;
         unsigned char *pszCompareBuffer;
         unsigned char *pszDataBuffer;
         unsigned Offset;
    };
    
    //
    // Global Data
    //
    
    HANDLE hSdStressLog;
    unsigned char *pszDataImage;
    DWORD FileMode;
    UINT BlockSizeMultiplier;
    char TestScenarios;
    ULONG SpindleSpeed;
    BOOL bDebug;
    BOOL bRandomize;
    UCHAR DriveSelected[MAXDRIVES+1];
    HANDLE ThreadHandles[MAXHANDLES+1] = {0};
    BOOL ThreadExist[MAXHANDLES+1];
    ULONG Passes;
    ULONG CDThreads;
    ULONG DiskThreads;
    ULONG TestFileSize;
    LONG TotalStartedThreadCount;
    LONG TotalFinishedThreadCount;
    LONG MaximumThreadCount;
    LONG FixedDiskThreadStillRunning;
    ULONG TotalNumberHardDrives;
    ULONG TotalNumber144Drives;
    ULONG TotalNumber12Drives;
    ULONG TotalNumberLS120Drives;
    ULONG TotalNumberRemovableDrives;
    ULONG TotalNumberNetDrives;
    ULONG TotalNumberCDROMDrives;
    HINSTANCE NtLog;
    CRITICAL_SECTION _GetRandomFile;
    CRITICAL_SECTION _WriteTextConsole;
    BOOL bPmte;
    LPVOID TestMgr;
    char *pszSubDirList[SD_MAXDIRS] = {0};
    // struct _CONSOLE_SCREEN_BUFFER_INFO ConsoleDefaultState;
    struct DISKINFO *DiskInfo[MAXDRIVES+1] = {0};
    char g_LogFileName[100] = {0};

    #define MAX_DEPTH (_MAX_DIR / 2) // a/b/c ...
    struct _finddata_t FileInfo[MAX_DEPTH] = {0};
    BYTE FileFoundFlag[MAX_DEPTH] = {0};
    __int3264 hFile[MAX_DEPTH] = {0};
    DWORD GlobalErrorCounter = 0;

}   //SDStressNameSpace

using namespace SDStressNameSpace;

void 
InitVaribles(
    void
    );

void 
AnalyzeCmdLine(
    void
    );

BOOL 
AnalyzeDrives(
    void
    );

BOOL 
DeleteDiskInfo (
    DISKINFO *DiskInfo
    );

BOOL 
CreateTestFiles(
    void
    );

BOOL 
ValidateTestConfiguration(
    void
    );

BOOL 
AllocGetRandomFile (
    void
    );

void 
DeallocGetRandomFile (
    void
    );

void 
CreateDiskInfo (
    UCHAR DriveLetter, 
    INT count
    );

void 
StartThreads (
    char TestType
    );

BOOL 
ValidateCOPYTESTFILE_DATA (
    COPYTESTFILE_DATA *pTestFileData
    );

VOID
WINAPI
SetSpindleSpeed(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\sdstress\resource.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    resources for SDSTRESS

Author / ported by:

    John Daly (johndaly) porting date 4/29/2000

Revision History:

    initial port: johndaly 4/29/2000
        port from NT

--*/


#define IDS_OPTIONS                     1
#define IDS_TITLESTRING                 2
#define VER_FILETYPE	                VFT_APP
#define VER_FILESUBTYPE	                VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Bugs? Tell VincentG."
#define VER_INTERNALNAME_STR            "SdStress.exe"
#define VER_ORIGINALFILENAME_STR        "SdStress.exe"
#define VER_FILEOS                      VOS_NT
#define VER_FILEFLAGSMASK               VS_FFI_FILEFLAGSMASK
#define VER_COMPANYNAME_STR             "Microsoft Corporation"
#define VER_PRODUCTNAME_STR             "SdStress - Storage Device Stress Utility"
#define VER_LEGALCOPYRIGHT_STR          "Copyright (C) 1996-1999 Microsoft Corporation"
#define VER_FILEFLAGS                   0
#define VER_FILEVERSION_STR             "1.7"
#define VER_PRODUCTVERSION_STR          "1.7"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\sdstress\sdstress.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sdstress.h

Abstract:

    This the MAIN SdStress - Console header file.

Author / ported by:

    John Daly (johndaly) porting date 4/29/2000

Revision History:

    initial port: johndaly 4/29/2000
        port from NT

--*/

#ifndef _SDSTRESS_
#define _SDSTRESS_


//
// include files
//

#include <io.h>

//
// Function prototypes
//

unsigned long 
__stdcall 
SdStressThread (
    LPVOID pThreadData
    );

long 
GetNumberOfFiles (
    char DriveLetter
    );

char 
GetRandomFile(
    char DriveLetter, 
    char *pszRndFile, 
    unsigned long *FileLength, 
    long NumberOfFiles
    );

unsigned char * 
AllocateMemory (
    DWORD Size
    );

BOOL 
DeAllocateMemory (
    DWORD Size, 
    LPVOID pszBuffer
    );

long 
ParseReturnValue (
    COPYTESTFILE_DATA *CopyTestFileData, 
    THREAD_DATA *ThreadData
    );

unsigned long 
__stdcall 
VerifyData (
    LPVOID CTFD
    );

BOOL 
Close_Handle (
    HANDLE *phHandle
    );

void 
InitConsole (
    void
    );

BOOL 
WriteTextConsole (
    char *pszText, 
    WORD Attribute, 
    DWORD LoggedLevel
    );

void 
ExitConsole (
    void
    );

BOOL 
PrintError (
    long ErrorCode
    );

BOOL 
PrintWCError (
    long ErrorCode
    );

void 
Debug_Print (
    char *Text
    );

unsigned long 
__stdcall 
CopyTestFile (
    LPVOID pCopyTestFileData
    );

unsigned long 
__stdcall 
CopyTestFileUsingIoC (
    LPVOID pCopyTestFileData
    );

unsigned long 
__stdcall 
CopyTestFileMultiple (
    LPVOID pCopyTestFileData
    );

unsigned long 
__stdcall 
CopyTestFileUsingWriteFileEx (
    LPVOID pCopyTestFileData
    );

VOID
CALLBACK 
WriteFileExCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    );

#endif // _SDSTRESS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dvdread\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef _XBOX
#include <xgraphics.h>
#endif

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef _XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef _XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef _XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\disktool\sdstress\sdthread.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sdthread.c

Abstract:

     This the thread control C file.

Author / ported by:

    John Daly (johndaly) porting date 4/29/2000

Environment:

    X-Box

[Notes:]

    port from the NT sdstress for X-Box testing

Revision History:

    initial port: johndaly
        port from NT

--*/

//
// includes
//

#include "ctf.c"
#include "ctfioc.c"
#include "ctfmul.c"
#include "ctfwex.c"

unsigned long 
__stdcall 
SdStressThread (
    LPVOID pThreadData
    )
/*++

Routine Description:

    This is the intermediate SdStress thread function.  This function creates 
    the worker threads 

Arguments:

    pThreadData - Structure to THREAD_DATA (contains Source & Destination drive info)

Return Value:
    None    

--*/ 
{
    char szBuffer[500];
    char szSrcName[300], szDestName[300], WaitCount = 0;
    long retval;
    ULONG lFileSize;
    UINT RetryCount = 0;
    COPYTESTFILE_DATA CopyTestFileData;
    HANDLE hThread = NULL;
    DWORD Dummy, WaitStatus;
    LPTHREAD_START_ROUTINE lpTestFunction = NULL;
    unsigned long ReturnValue = 0;
    THREAD_DATA *ThreadData = (THREAD_DATA *) pThreadData;

    __try
    {
        //
        //Init structure
        //

        *ThreadData->ThreadExist = TRUE;
        CopyTestFileData.ThreadData = ThreadData;
        ThreadData->Count = 0;

        InterlockedIncrement (&TotalStartedThreadCount);

        srand (TotalStartedThreadCount /*+ (unsigned int)time()*/);

        //
        // Determine test method
        //

        switch ( ThreadData->TestType ) {
            
            case CTF:
            default:
                {
                    lpTestFunction = &CopyTestFile;
                    break;
                }

            case CTF_IOC:
                {
                    lpTestFunction = &CopyTestFileUsingIoC;
                    break;
                }

            case CTF_MULTIPLE:
                {
                    lpTestFunction = &CopyTestFileMultiple;
                    break;
                }

            case CTF_WFEX:
                {
                    lpTestFunction = &CopyTestFileUsingWriteFileEx;
                    break;
                }
        }

        //
        // determine block sizing based on drive types, Allocate memory for copying
        //
        // Under the new model, I need to figure out whether the source or target
        // drive has the highest granularity (BytesPerSector), since I will be setting
        // blocksize based on BytesPerSector instead of hardcoded values
        //

        if ( ThreadData->SrcDrive->BytesPerSector < ThreadData->DestDrive->BytesPerSector ) {

            CopyTestFileData.MinimumBlockSize = ThreadData->DestDrive->BytesPerSector;

        } else {

            CopyTestFileData.MinimumBlockSize = ThreadData->SrcDrive->BytesPerSector;

        }

        if ( bRandomize ) {

            CopyTestFileData.BlockSize = CopyTestFileData.MinimumBlockSize * MAX_BLOCK_MULTIPLIER;

        } else {

            CopyTestFileData.BlockSize = CopyTestFileData.MinimumBlockSize * BlockSizeMultiplier;
        }

        sprintf (szBuffer,
                 "Thread MinBlockSize: Src:%c, Dst:%c, Instance:%d = %d\n",
                 ThreadData->SrcDrive->Letter,
                 ThreadData->DestDrive->Letter,
                 ThreadData->ThreadInstance,
                 CopyTestFileData.MinimumBlockSize);

        Debug_Print (szBuffer);

        CopyTestFileData.pszDataBuffer = AllocateMemory (CopyTestFileData.BlockSize);
        CopyTestFileData.pszCompareBuffer = AllocateMemory (CopyTestFileData.BlockSize);

        if ( (NULL == CopyTestFileData.pszDataBuffer) || 
             (NULL == CopyTestFileData.pszCompareBuffer) ) {
            WriteTextConsole ("Cannot allocate memory.  Terminating thread...\n", 
                              ERRORCOLOR,
                              XLL_BREAK);     

            __leave;
        }

        sprintf (szBuffer,
                 "Thread started: Src:%c, Dst:%c, Instance:%d\n",
                 ThreadData->SrcDrive->Letter,
                 ThreadData->DestDrive->Letter,
                 ThreadData->ThreadInstance);

        Debug_Print (szBuffer);

        //
        // Determine Source and Destination test filenames
        //

        sprintf (szSrcName, "%c:\\SDDATA\\TESTFILE.DAT",
                 ThreadData->SrcDrive->Letter);

        sprintf (szDestName, "%c:\\SDDATA\\%c%ctfile.%d",
                 ThreadData->DestDrive->Letter,
                 ThreadData->SrcDrive->Letter,
                 ThreadData->DestDrive->Letter,
                 ThreadData->ThreadInstance);

        //
        // If this is a Removable or Fixed Disk, increment the counter
        //

        if ( ThreadData->SrcDrive->Type == SD_REMOVABLE || ThreadData->SrcDrive->Type == SD_FIXED ) {
            InterlockedIncrement (&FixedDiskThreadStillRunning);
        }

        //
        // Main loop
        //

        while ( ThreadData->Count < Passes ) {

            //
            // If source ISN'T CD_ROM
            //

            if ( ThreadData->SrcDrive->Type != SD_CDROM ) {

                CopyTestFileData.pszSname = szSrcName;
                CopyTestFileData.pszDname = szDestName;
                CopyTestFileData.lFileSize = TestFileSize;

                if ( bRandomize ) {
                    CopyTestFileData.BlockSize = CopyTestFileData.MinimumBlockSize * ((rand () % (MAX_BLOCK_MULTIPLIER - 1)) + 1);
                    sprintf (szBuffer, "Random block size: %d\n",
                             CopyTestFileData.BlockSize);
                    Debug_Print (szBuffer);
                }

                //
                // Create copying thread
                //

                hThread = CreateThread (NULL,
                                        0,
                                        lpTestFunction,
                                        &CopyTestFileData,
                                        0,
                                        &Dummy);

                //
                // Wait until thread is finished
                //

                if ( hThread == NULL ) {
                    WriteTextConsole ("Unable to create worker thread.\n",
                                      ERRORCOLOR,
                                      XLL_INFO);

                    __leave;
                } else {
                    WriteTextConsole ("worker thread created.\n",
                                      ERRORCOLOR,
                                      XLL_INFO);
                }

                WaitCount = 0;
                while ( WaitStatus = WaitForSingleObject (hThread, STD_THREAD_TIMEOUT) == WAIT_FAILED && 
                      WaitCount < MAX_WAIT_RETRIES ) {
                    Sleep (2000);
                    WaitCount ++;
                }

                //
                // this is bad
                // the thread will still be able to run, and our cleanup will free the 
                // buffers it uses, we want to debug it, we'll eventually crash if we 
                // continue to run
                // probably caused by low memory condition, should be rare that this is hit
                //

                if ( WaitStatus == WAIT_FAILED ) {

                    PrintError (GetLastError ());
                    WriteTextConsole ( "WaitForSingleObject failed.",
                                       ERRORCOLOR,
                                       XLL_BREAK);
                    OutputDebugStringA("WaitForSingleObject failed. contimuing from here will eventually crash.");
                    DebugBreak();
                    __leave;
                }

                //
                // we wait forever, this should probably not happen...
                // 

                if ( WaitStatus == WAIT_TIMEOUT ) {
                    WriteTextConsole ("WaitForSingleObject timeout (CTF), possible deadlock on thread.\n\n",
                                      ERRORCOLOR,
                                      XLL_BREAK);

                    __leave;

                }

                CloseHandle (hThread);
                hThread = NULL;

                //
                // Determine what happened during CopyTestFile
                //

                ParseReturnValue (&CopyTestFileData, ThreadData);

            } else {

                //
                // Source drive is CDROM
                //

                //
                // Get total number of files on CD
                //

                sprintf (szBuffer,
                         "%u directories containing files on the CDROM.\n",
                         ThreadData->SrcDrive->NumberOfFiles);

                Debug_Print (szBuffer);

                //
                // Find random file on CD to copy
                //

                for ( RetryCount = 0; RetryCount < MAXRETRIES; RetryCount ++ ) {

                    retval = GetRandomFile (ThreadData->SrcDrive->Letter,
                                            szSrcName,
                                            &lFileSize,
                                            ThreadData->SrcDrive->NumberOfFiles);

                    if ( retval && lFileSize > 2048 ) {
                        break;
                    }

                    Sleep (FAILED_GRF_STALL);
                }

                if ( !retval ) {
                    sprintf (szBuffer, "Src:%c, Dest:%c, Instance:%d SrcNmae:%s FileSize:%d NumFiles:%d - Could not locate suitable test file.\n",
                             ThreadData->SrcDrive->Letter,
                             ThreadData->DestDrive->Letter,
                             ThreadData->ThreadInstance,
                             szSrcName,
                             lFileSize,
                             ThreadData->SrcDrive->NumberOfFiles);

                    WriteTextConsole (szBuffer,
                                      ERRORCOLOR,
                                      XLL_BREAK);

                    __leave;
                }

                sprintf (szBuffer, "Src:%c, Dest:%c, Instance:%d - File %s (%u) selected.\n",
                         ThreadData->SrcDrive->Letter,
                         ThreadData->DestDrive->Letter,
                         ThreadData->ThreadInstance,
                         szSrcName,
                         lFileSize);

                WriteTextConsole (szBuffer, NORMALTEXTCOLOR, XLL_INFO);

                //
                // Source is CD, Destination is anything but Floppy
                //

                CopyTestFileData.pszSname = szSrcName;
                CopyTestFileData.pszDname = szDestName;
                CopyTestFileData.lFileSize = lFileSize;

                if ( bRandomize ) {
                    CopyTestFileData.BlockSize = CopyTestFileData.MinimumBlockSize * ((rand () % (MAX_BLOCK_MULTIPLIER - 1)) + 1);

                    sprintf (szBuffer, "Random block size (CD): %d\n",
                             CopyTestFileData.BlockSize);

                    Debug_Print (szBuffer);
                }

                else {
                    CopyTestFileData.BlockSize = CopyTestFileData.MinimumBlockSize;
                }

                //
                // Create the Thread
                //

                hThread = CreateThread (NULL,
                                        0,
                                        lpTestFunction,
                                        &CopyTestFileData,
                                        0,
                                        &Dummy);

                //
                // Wait for thread to finish
                //

                if ( hThread == NULL ) {
                    WriteTextConsole ("Unable to create worker thread.\n",
                                      ERRORCOLOR,
                                      XLL_BREAK);

                    __leave;
                } else {
                    WriteTextConsole ("worker thread created.\n",
                                      ERRORCOLOR,
                                      XLL_INFO);
                }

                WaitCount = 0;
                while ( WaitStatus = WaitForSingleObject (hThread, STD_THREAD_TIMEOUT) == WAIT_FAILED && 
                      WaitCount < MAX_WAIT_RETRIES ) {
                    Sleep (2000);
                    WaitCount ++;
                }

                //
                // this is bad
                // the thread will still be able to run, and our cleanup will free the 
                // buffers it uses, we want to debug it, we'll eventually crash if we 
                // continue to run
                // probably caused by low memory condition, should be rare that this is hit
                //

                if ( WaitStatus == WAIT_FAILED ) {

                    PrintError (GetLastError ());
                    WriteTextConsole ( "WaitForSingleObject failed.",
                                       ERRORCOLOR,
                                       XLL_BREAK);
                    OutputDebugStringA("WaitForSingleObject failed. continuing from here will eventually crash.");
                    DebugBreak();
                    __leave;
                }

                //
                // we wait forever, this should probably not happen...
                // 

                if ( WaitStatus == WAIT_TIMEOUT ) {
                    WriteTextConsole ("WaitForSingleObject timeout (CTF), possible deadlock on thread.\n\n",
                                      ERRORCOLOR,
                                      XLL_BREAK);

                    __leave;
                }

                CloseHandle (hThread);
                hThread = NULL;

                //
                // Determine what happened during CopyTestFile
                //

                ParseReturnValue (&CopyTestFileData,ThreadData);
            }

            if ( ThreadData->SrcDrive->Type != SD_REMOVABLE && ThreadData->SrcDrive->Type != SD_FIXED ) {

                if ( !TotalNumberHardDrives && !TotalNumberRemovableDrives ) {
                    ThreadData->Count ++;
                }

                if ( !FixedDiskThreadStillRunning && (TotalNumberHardDrives || TotalNumberRemovableDrives) ) {
                    __leave;
                }
            }

            else
                ThreadData->Count ++;
        }

        //
        // This is where we clean up the thread's data, and exit
        //

        sprintf (szBuffer,
                 "Thread is finished: Src:%c, Dst:%c, Instance:%d\n",
                 ThreadData->SrcDrive->Letter,
                 ThreadData->DestDrive->Letter,
                 ThreadData->ThreadInstance);

        WriteTextConsole(szBuffer,
                         PASSCOLOR,
                         XLL_INFO);

        //
        // sync
        //

        if ( ThreadData->SrcDrive->Type == SD_REMOVABLE || ThreadData->SrcDrive->Type == SD_FIXED ) {
            InterlockedDecrement (&FixedDiskThreadStillRunning);
        }
    }

    __finally
    {
        //
        // DeAllocateMemory does validity checking at function level
        //

        Debug_Print ("Memory Deallocation (SdStressThread)\n");

        DeAllocateMemory (CopyTestFileData.BlockSize,
                          CopyTestFileData.pszDataBuffer);

        DeAllocateMemory (CopyTestFileData.BlockSize,
                          CopyTestFileData.pszCompareBuffer);

        if ( hThread != NULL ) {
            CloseHandle (hThread);
        }

        *ThreadData->ThreadExist = FALSE;

        if ( !InterlockedDecrement (&TotalFinishedThreadCount) ) {
                WriteTextConsole ("FATAL ERROR:Unable to InterlockedDecrement(&TotalFinishedThreadCount).\n",
                                  ERRORCOLOR,
                                  FALSE);
                ReturnValue = EXIT_PROCESS;
        }

    }

    if ( ReturnValue != EXIT_PROCESS ) {
        return(ReturnValue);
    } else {
        ExitThread (EXIT_PROCESS);
    }
}

long 
GetNumberOfFiles (
    char DriveLetter
    )
/*++

Routine Description:

    This function will retrieve the number of files on a CDROM,
    

Arguments:

    DriveLetter - Contains the letter of the drive to retrieve files

Return Value:

    Number of files on the CD-ROM (or 0 if failed)
    
Note:

    . and .. no longer exist on xbox
    

--*/ 
{
    int depth = 0;
    DWORD SubDirCount = 0;
    long FileCount = 0;
    char FindPath[300] = {0};
    char *strptr = NULL;

    //
    // start in root
    //
    
    sprintf (FindPath, "%c:\\", DriveLetter);
    strcat (FindPath, "*.*");
    hFile[0] = _findfirst (FindPath, &FileInfo[0]);
    
    //
    // if something went wrong...
    //

    if ( hFile[0] == -1L )
    {
        OutputDebugStringA("Warning! findfirst failed in root!\n");
        return(0);
    }
    
    while (TRUE) {

        //
        // are there directories in this directory?
        // if yes, data recurse into them immediatly
        //

        if ( FileInfo[depth].attrib & _A_SUBDIR ) {

            //
            // fix path string
            //

            if (strptr = strstr (FindPath, "*.*")) {
                *strptr = '\0';
            }
            strcat (FindPath, FileInfo[depth].name);
            strcat (FindPath, "\\*.*");
            
            //
            // find first file in subdir
            //

            if (depth < MAX_DEPTH - 1) {
                ++depth;
                hFile[depth] = _findfirst (FindPath, &FileInfo[depth]);
            } else {
                //
                // in this case we have overflowed our data area, I will need
                // to know about it so I can fix the code to hold more FileInfo entries, etc
                //
                OutputDebugStringA("SDStress : GetNumberOfFiles : MAX_DEPTH exceeded");
                DebugBreak();
                goto clear; // this should let you fail gracefully
            }

            //
            // empty dir - or error, add code to check errno
            //
            
            if ( hFile[depth] == -1L )
            {
                goto clear; // we are done with this directory
            }

            continue; // continue this look with the new current fileinfo

        } else {
            
            //
            // there are files in this directory if we got here
            // add to pszSubDirList
            // only make this check in the first visit to this directory
            //
            
            ++FileCount;

            if (FALSE == FileFoundFlag[depth]) {
                FileFoundFlag[depth] = TRUE;
                if (SubDirCount < SD_MAXDIRS - 1) {
                    if (strptr = strstr (FindPath, "*.*")) {
                        *strptr = '\0';
                    }
                    strcpy(pszSubDirList[SubDirCount++], FindPath);
                } else {

                    //
                    // we have run out of reasons to be looking through this 
                    // media, but keep going, even though we won't add new dirs
                    //
                }
            }

            //
            // look for next file / directory
            //

            if (-1L == _findnext (hFile[depth], &FileInfo[depth])) {
                goto clear;
            } else {
                continue;
            }
        }
        
        //
        // done with this directory, clear state
        //

        clear:
            
            //
            // truncate directory\*.* off of FindPath so that findpath matches current dir
            //

            if (strptr = strstr (FindPath, "*.*")) {
                *strptr = '\0';
            }
            strptr = FindPath + strlen(FindPath) - 1;
            if (strptr > FindPath) {    // skip terminating '\' - is there always one when this code is hit?
                --strptr;   
                while ((*strptr != '\\') && (strptr > FindPath)){
                    --strptr;
                }
            }
            *++strptr = '\0';   // leave trailing '\'

            //
            // close this level and back out to next level
            //

            _findclose(hFile[depth]);
            memset(&FileInfo[depth], 0, sizeof(FileInfo[0]));
            FileFoundFlag[depth] = FALSE;
            --depth;
            
            //
            // are we are done
            //

            if (depth < 0) {
                break;
            }

            //
            // perform resume scan in level backed into
            //

            if (-1L == _findnext (hFile[depth], &FileInfo[depth])) {
                goto clear;
            } else {
                continue;
            }
    }
    
    return SubDirCount;
}

char 
GetRandomFile (
    char DriveLetter, 
    char *pszRndFile, 
    unsigned long *FileLength, 
    long NumberOfFiles
    )
/*++

Routine Description:

    This function retrieves a file from a CDROM based on a random number

Arguments:

    DriveLetter - Contains the drive letter of the CDROM reader
    pszRndFile - Pointer to buffer where this function will place the file name and path
    FileLength - Pointer to variable to hold the size of the selected file
    NumberOfFiles - Contains the number of directories containing files on the
        CDROM/DVDROM (produced from GetNumberOfFiles)

Return Value:

    0 - Function failed
    1 - Function succeeded
    
    note: the prior incarnation of this function used a critical section, 
    I don't see the need for that since we are only reading the list

--*/ 
{
    long FileCount = 0, SelectFile;
    DWORD LastError;
    __int3264 hFile;
    char FindPath[300];
    char ErrorString[200];
    struct _finddata_t FileInfo;
    char *strptr = NULL;
    
    if ( 0 == NumberOfFiles )   {
        return(0);
    }

    //
    // select a random directory from the ones known to contain files
    //

    if (NumberOfFiles > 1) {
        SelectFile = rand () % (NumberOfFiles);
    } else {
        SelectFile = 0;
    }

    strcpy (FindPath, pszSubDirList[SelectFile]);
    strcat(FindPath, "*.*");
    
    //
    // this means something is wrong!
    //

    while ( -1L == (hFile = _findfirst (FindPath, &FileInfo)))
    {
        LastError = GetLastError();
        // added extra debug crap to track down stress bug
        // safe to stomp on filepath now
        //_asm int 3
        ++GlobalErrorCounter;
        sprintf (ErrorString, 
         "GetRandomFile : hit an error Source: %s errno=%d : lasterror=%d : GlobalErrorCounter=%d\n",
         FindPath,
         errno,
         LastError,
         GlobalErrorCounter);
        Debug_Print (ErrorString);

    }
    
    //
    // count the files in the directory
    // not neccessarily an efficient approach, but we want to do lots of IO...
    //

    do {
        if (!(FileInfo.attrib & _A_SUBDIR )) {
            FileCount++;
        }
    } while ( _findnext (hFile, &FileInfo) == 0 );
    
    _findclose (hFile);

    //
    // randomly pick one to return
    //
    
    hFile = _findfirst (FindPath, &FileInfo);
    if ( hFile == -1L )
    {
        // this has been seen in low memory situations, so don't break
        OutputDebugStringA("ERROR! findfirst failed during count!\n");
        //DebugBreak();
        return(0);
    }
    
    if (FileCount > 1) {
        SelectFile = rand () % (FileCount - 1) + 1;
    } else {
        SelectFile = 1;
    }

    FileCount = 0;
    while( FileCount < SelectFile) {
        if (!(FileInfo.attrib & _A_SUBDIR )) {
            FileCount++;
        }
        _findnext (hFile, &FileInfo);
    }
    
    *FileLength = FileInfo.size;
    if (strptr = strstr (FindPath, "*.*")) {
        *strptr = '\0';
    }
    sprintf (pszRndFile, "%s%s",
             FindPath,
             FileInfo.name);
    
    _findclose (hFile);
    return(1);
}

unsigned 
char * 
AllocateMemory (
    DWORD Size
    )
/*++

Routine Description:

    This function does all of the dynamic memory allocation for the
    copying functions (multiple of sector size, aligned)

Arguments:

    Parameters:  Size - Number of bytes to allocate

Return Value:

    FALSE - Failure
    TRUE - Success

--*/ 
{
    return((unsigned char *) VirtualAlloc (NULL, 
                                           Size,
                                           MEM_COMMIT,
                                           PAGE_READWRITE));

}

BOOL 
DeAllocateMemory (
    DWORD Size, 
    LPVOID pszBuffer
    )
/*++

Routine Description:

    This function deallocates memory allocated by AllocateMemory.

Arguments:

    Size - Number of bytes allocated
    pszBuffer - Pointer to buffer allocated by AllocateMemory

Return Value:

    FALSE - Failure
    TRUE - Success

Note:

    ignore size, just blow away the enitire allocation
    
--*/ 
{
    if ( pszBuffer ) {
        return(VirtualFree (pszBuffer, 0, MEM_RELEASE));
    }

    return(FALSE);
}

long 
ParseReturnValue (
    COPYTESTFILE_DATA *CopyTestFileData, 
    THREAD_DATA *ThreadData
    )
/*++

Routine Description:

    This function shows the result of the copy operation based on retval

Arguments:

    COPYTESTFILEDATA - Contains the scenario's results
    ThreadData - Contains the count information

Return Value:

    Return Value: Retval

--*/ 
{
    char szBuffer[200];

    switch ( CopyTestFileData->retval ) {
    
    case E_SDABORT:
        {
            sprintf (szBuffer,
                     "ABORTED on thread: Src:%c, Dst:%c, Instance:%d\n",
                     ThreadData->SrcDrive->Letter,
                     ThreadData->DestDrive->Letter,
                     ThreadData->ThreadInstance);

            WriteTextConsole(szBuffer, ABORTCOLOR, XLL_WARN);
            break;
        }

    case NULL:
        {
            if ( ThreadData->SrcDrive->Type == SD_CDROM ) {
                sprintf (szBuffer,
                         "PASS on thread: Src:%c, Dst:%c, Instance:%d\n",
                         ThreadData->SrcDrive->Letter,
                         ThreadData->DestDrive->Letter,
                         ThreadData->ThreadInstance);
            }

            else {
                sprintf (szBuffer,
                         "PASS (%u/%u) on thread: Src:%c, Dst:%c, Instance:%d\n",
                         ThreadData->Count+1,
                         Passes,
                         ThreadData->SrcDrive->Letter,
                         ThreadData->DestDrive->Letter,
                         ThreadData->ThreadInstance);
            }

            WriteTextConsole(szBuffer, PASSCOLOR, XLL_PASS);
            break;
        }

    default:
        {
            sprintf (szBuffer,
                     "FAILURE (%u/%u) on thread: Src:%c, Dst:%c, Instance:%d\n",
                     ThreadData->Count+1,
                     Passes,
                     ThreadData->SrcDrive->Letter,
                     ThreadData->DestDrive->Letter,
                     ThreadData->ThreadInstance);

            WriteTextConsole(szBuffer, ERRORCOLOR, XLL_FAIL);
            PrintSDError(CopyTestFileData->retval);
            if ( CopyTestFileData->ErrorCode )
                PrintError(CopyTestFileData->ErrorCode);
            break;
        }

    }

    return(CopyTestFileData->retval);
}

unsigned 
long 
__stdcall 
VerifyData (
    LPVOID CTFD
    )
/*++

Routine Description:

    This function is used by the copy threads to verify the data read 
    and written

Arguments:

    CTFD (CopyTestFileData) - Contains copy thread information

Return Value:

    None (well, not used at least)

--*/ 
{
    unsigned long count = 0, lFileCount = 0;
    char szBuffer[200 + MAX_PATH + MAX_PATH];
    ULONG PassFailFlag = TRUE;

    COPYTESTFILE_DATA *CopyTestFileData = (COPYTESTFILE_DATA *) CTFD;

    CopyTestFileData->ErrorCode = NULL;
    CopyTestFileData->retval = 0;

    if ( CopyTestFileData->lFileSize < CopyTestFileData->BlockSize ) {
        lFileCount = CopyTestFileData->lFileSize;
    }

    else {
        lFileCount = CopyTestFileData->BlockSize;
    }

    //
    // what are we comparing...
    //

    sprintf (szBuffer,
             "VerifyData:Source: %s\nVerifyData:Destination: %s\n",
             CopyTestFileData->pszSname, CopyTestFileData->pszDname);
    
    // too noisy
//    WriteTextConsole (szBuffer, ERRORCOLOR, FALSE);

    //
    // on the compares, only dump at the start and the end of the 
    // corrupted region to make the logs smaller
    //

    if ( CopyTestFileData->ThreadData->SrcDrive->Type == SD_CDROM ) {
        while ( count < lFileCount ) {
            if ( CopyTestFileData->pszDataBuffer[count] != CopyTestFileData->pszCompareBuffer[count] ) {
                if ((NULL != CopyTestFileData->ErrorCode) && (E_VERIFYCOPY != CopyTestFileData->retval)) {
                    sprintf (szBuffer,
                             "Verify failure begin: Offset 0x%X, Exp:0x%X, Actual:0x%X\n",
                             count + (lFileCount * CopyTestFileData->BlockSize),
                             CopyTestFileData->pszCompareBuffer[count],
                             CopyTestFileData->pszDataBuffer[count]);
                    WriteTextConsole (szBuffer, ERRORCOLOR, FALSE);

                    CopyTestFileData->ErrorCode=NULL;
                    CopyTestFileData->retval=E_VERIFYCOPY;
                    PassFailFlag = FALSE;
                }
            } else {
                if ((NULL == CopyTestFileData->ErrorCode) && (E_VERIFYCOPY == CopyTestFileData->retval)) {
                    sprintf (szBuffer,
                             "Verify failure end: Offset 0x%X, Exp:0x%X, Actual:0x%X\n",
                             count - 1 + (lFileCount * CopyTestFileData->BlockSize),
                             CopyTestFileData->pszCompareBuffer[count - 1],
                             CopyTestFileData->pszDataBuffer[count - 1]);
                    WriteTextConsole (szBuffer, ERRORCOLOR, FALSE);
                }
            }
            count ++;
        }
    }

    else {
        int SourceTargetFlag = 0;
        while ( count < lFileCount ) {
            if ( CopyTestFileData->pszDataBuffer[count] != pszDataImage[count + CopyTestFileData->Offset] ) {
                if ((NULL != CopyTestFileData->ErrorCode) && 
                    (E_VERIFYCOPY != CopyTestFileData->retval) &&
                    (SourceTargetFlag & 0x1)) {
                    sprintf (szBuffer,
                             "Verify failure begin from target: Offset 0x%X, Exp:0x%X, Actual:0x%X\n",
                             count + (lFileCount * CopyTestFileData->BlockSize),
                             pszDataImage[count + CopyTestFileData->Offset],
                             CopyTestFileData->pszDataBuffer[count]);
                    WriteTextConsole (szBuffer, ERRORCOLOR, FALSE);
                    CopyTestFileData->ErrorCode=NULL;
                    CopyTestFileData->retval=E_VERIFYCOPY;
                    SourceTargetFlag &= 0x1;
                    PassFailFlag = FALSE;
                }
            } else {
                if ((NULL == CopyTestFileData->ErrorCode) && 
                    (E_VERIFYCOPY == CopyTestFileData->retval) &&
                    (SourceTargetFlag & 0x1)) {
                    sprintf (szBuffer,
                             "Verify failure end from target: Offset 0x%X, Exp:0x%X, Actual:0x%X\n",
                             count - 1 + (lFileCount * CopyTestFileData->BlockSize),
                             pszDataImage[count - 1 + CopyTestFileData->Offset],
                             CopyTestFileData->pszDataBuffer[count - 1]);
                    WriteTextConsole (szBuffer, ERRORCOLOR, FALSE);
                    SourceTargetFlag ^= 0x1;
                }
            }

            if ( CopyTestFileData->pszCompareBuffer[count] != pszDataImage[count + CopyTestFileData->Offset] ) {
                if ((NULL != CopyTestFileData->ErrorCode) && 
                    (E_VERIFYCOPY != CopyTestFileData->retval) &&
                    (SourceTargetFlag & 0x2)) {
                    sprintf (szBuffer,
                             "Verify failure begin from source: Offset 0x%X, Exp:0x%X, Actual:0x%X\n",
                             count + (lFileCount * CopyTestFileData->BlockSize),
                             pszDataImage[count + CopyTestFileData->Offset],
                             CopyTestFileData->pszCompareBuffer[count]);
                    WriteTextConsole (szBuffer, ERRORCOLOR, FALSE);
                    CopyTestFileData->ErrorCode=NULL;
                    CopyTestFileData->retval=E_VERIFYCOPY;
                    SourceTargetFlag &= 0x2;
                    PassFailFlag = FALSE;
                }
            } else {
                if ((NULL == CopyTestFileData->ErrorCode) && 
                    (E_VERIFYCOPY == CopyTestFileData->retval) &&
                    (SourceTargetFlag & 0x2)) {
                    sprintf (szBuffer,
                             "Verify failure begin from source: Offset 0x%X, Exp:0x%X, Actual:0x%X\n",
                             count - 1 + (lFileCount * CopyTestFileData->BlockSize),
                             pszDataImage[count - 1 + CopyTestFileData->Offset],
                             CopyTestFileData->pszCompareBuffer[count - 1]);
                    WriteTextConsole (szBuffer, ERRORCOLOR, FALSE);
                    SourceTargetFlag ^= 0x2;
                }
            }
            count ++;
        }
    }

    return(PassFailFlag);
}

BOOL 
Close_Handle (
    HANDLE *phHandle
    )
/*++

Routine Description:

    This function closes handles and sets them to INVALID_HANDLE_VALUE

Arguments:

    phHandle - Pointer to handle to close

Return Value:

    TRUE if success
    FALSE if not success

--*/ 
{
    if ( *phHandle == INVALID_HANDLE_VALUE ) {
        return(FALSE);
    }

    CloseHandle (*phHandle);

    *phHandle = INVALID_HANDLE_VALUE;

    return(TRUE);
}

BOOL 
ValidateCOPYTESTFILE_DATA (
    COPYTESTFILE_DATA *pTestFileData
    )
/*++

Routine Description:

    This function validates COPYTESTFILE_DATA structure to help track down some memory corruption

Arguments:

    COPYTESTFILE_DATA *pTestFileData

Return Value:

    TRUE if success
    FALSE if not success

--*/ 
{
    DWORD verify_count = 0;
    unsigned char verify_char;
    
    //
    // first, try derefrencing the COPYTESTFILE_DATA data
    //
    
    char *pszSname = pTestFileData->pszSname;          
    char *pszDname = pTestFileData->pszDname;          
    DWORD lFileSize = pTestFileData->lFileSize;         
    DWORD BlockSize = pTestFileData->BlockSize;
    DWORD MinimumBlockSize = pTestFileData->MinimumBlockSize;  
    long ErrorCode = pTestFileData->ErrorCode;         
    long retval = pTestFileData->retval;            
    THREAD_DATA *ThreadData = pTestFileData->ThreadData;        
    unsigned char *pszCompareBuffer = pTestFileData->pszCompareBuffer;  
    unsigned char *pszDataBuffer = pTestFileData->pszDataBuffer;     
    unsigned Offset = pTestFileData->Offset;            

    //
    // walk the THREAD_DATA 
    //

    DISKINFO *SrcDrive = pTestFileData->ThreadData->SrcDrive;
    DISKINFO *DestDrive = pTestFileData->ThreadData->DestDrive;
    UINT ThreadInstance = pTestFileData->ThreadData->ThreadInstance;
    BOOL *ThreadExist = pTestFileData->ThreadData->ThreadExist;
    char TestType = pTestFileData->ThreadData->TestType;
    long Passes = pTestFileData->ThreadData->Passes;
    UINT Count = pTestFileData->ThreadData->Count;

    //
    // walk the DISKINFO
    //
    
    char Letter = pTestFileData->ThreadData->SrcDrive->Letter;
    UINT Type = pTestFileData->ThreadData->SrcDrive->Type;
    ULARGE_INTEGER TotalFreeSpace = pTestFileData->ThreadData->SrcDrive->TotalFreeSpace;
    ULARGE_INTEGER TotalNumberOfBytes = pTestFileData->ThreadData->SrcDrive->TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes = pTestFileData->ThreadData->SrcDrive->TotalNumberOfFreeBytes;
    DWORD BytesPerSector = pTestFileData->ThreadData->SrcDrive->BytesPerSector;
    DWORD TestFileSize = pTestFileData->ThreadData->SrcDrive->TestFileSize;
    long NumberOfFiles = pTestFileData->ThreadData->SrcDrive->NumberOfFiles;

    Letter = pTestFileData->ThreadData->DestDrive->Letter;
    Type = pTestFileData->ThreadData->DestDrive->Type;
    TotalFreeSpace = pTestFileData->ThreadData->DestDrive->TotalFreeSpace;
    TotalNumberOfBytes = pTestFileData->ThreadData->DestDrive->TotalNumberOfBytes;
    TotalNumberOfFreeBytes = pTestFileData->ThreadData->DestDrive->TotalNumberOfFreeBytes;
    BytesPerSector = pTestFileData->ThreadData->DestDrive->BytesPerSector;
    TestFileSize = pTestFileData->ThreadData->DestDrive->TestFileSize;
    NumberOfFiles = pTestFileData->ThreadData->DestDrive->NumberOfFiles;

    //
    // walk the data buffers
    //

    while (verify_count < pTestFileData->BlockSize)
    {
        verify_char = pszCompareBuffer[verify_count];
        ++verify_count;
    }

    verify_count = 0;
    
    while (verify_count < pTestFileData->BlockSize)
    {
        verify_char = pszDataBuffer[verify_count];
        ++verify_count;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dvdread\dvdread.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    dvdread.cpp

Abstract:

    Low level disk test scanner.

Notes:
    dvd player code:
        "\xboxsrc\private\ui\dvd\library\hardware\drives\specific\xboxdvddrive.cpp"
    sense data format:
        "\xboxsrc\public\ddk\inc\scsi.h"

    DVD-X2 Supported Error Sense Codes
        Sense   Sense   Sense   Description
        Key	    Code    Code Qu
        ----------------------------------------------------------------------
        0x00	0x00	0x00	No Additional Sense information (= no error)
        0x01	0x80	0x00	Cache fill error, speed reduction requested
        0x02	0x04	0x00	Logical Unit not ready, cause not reported
        0x02	0x04	0x01	Logical Unit is in process of becoming ready
        0x02	0x30	0x00	Incompatible medium installed
        0x02	0x3A	0x00	Medium not present
        0x03	0x57	0x00	Unable to recover Table of Contents
        0x03	0x80	0x00	Read Error
        0x04	0x00	0x00	Hardware error
        0x04	0x08	0x03	Logical Unit Communication CRC Error - UDMA33
        0x05	0x21	0x00	Logical Block Address Out of Range
        0x05	0x55	0x00	System Resource Failure
        0x05	0x64	0x00	Illegal mode for this track
        0x05	0x6F	0x00	Authentication Failure - CSS
        0x05	0x80	0x00	Authentication Failure - Xbox
        0x05	0x81	0x00	Command error
        0x06	0x29	0x00	Power On, Reset or Bus Device Reset occurred
        0x06	0x2A	0x01	Mode Parameters changed
        0x06	0x2E	0x00	Insufficient time for operation

    Win32 Error code mapping:
        1/80:   ERROR_CRC                   23
        2/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        2/other ERROR_NOT_READY             21
        3/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        3/other ERROR_CRC                   23
        5/21:   ERROR_SECTOR_NOT_FOUND      27
        5/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        5/6F:   ERROR_TOO_MANY_SECRETS      1381
        5/80:   ERROR_TOO_MANY_SECRETS      1381
        other:  ERROR_IO_DEVICE             1117

    IOCTL_CDROM_SET_SPINDLE_SPEED
        speed 2     ~3000rpm      2x -    5x
        speed 1     ~2000rpm    4/3x - 10/3x
        speed 0     ~1000rpm    2/3x -  5/3x

    Hard Drive Partition Sizes
        \Device\Harddisk0\Partition0 19541088
        \Device\Harddisk0\Partition1  9997568
        \Device\Harddisk0\Partition2  1023840
        \Device\Harddisk0\Partition3  1535776
        \Device\Harddisk0\Partition4  1535776
        \Device\Harddisk0\Partition5  1535776

*****************************************************************************/

#include "dvdread.h"

HANDLE hDuke[XGetPortCount()] = { NULL, NULL, NULL, NULL };
HANDLE hSlot[XGetPortCount()*2] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };

//
// config settings
//
DWORD avgTime;
DISK_GEOMETRY gDiskGeometry;
DWORD successfulReadSectors;
int enableRetries = 1;
DWORD spindleSpeed = 2;
DWORD speedDelay0to1 = 0;
DWORD speedDelay1to2 = 0;
DWORD speedDelay2to1 = 0;
DWORD speedDelay1to0 = 0;
DWORD speedDelay0to2 = 0;
DWORD speedDelay2to0 = 0;
DWORD delayOn062E = 300;
DWORD seekOn062E = 0;
DWORD summaryInternalErrs = 1;
ErrorDistrubition *errors = NULL;
DWORD lastReadTime;
DWORD avgTimeCount;
DWORD chunkSizeMin = 32;
DWORD chunkSizeMax = 32;
char deviceName[128];
DWORD readSize = 32;
DWORD startLBA=0, endLBA=0;
DWORD compareBuffers = 0;
DWORD sequentialReads = 1;
DWORD pauseOnMismatch = 0;
DWORD readMode = READMODE_DETECT;
DWORD stopAfter = 0;
DWORD numberOfReads = 0;
ExcludeList *exclude = NULL;
DWORD requestSense = 0;
DWORD launchGUI = 0;
DWORD pauseOnExit = 0;
DWORD avgSpan = 256;
DWORD defaultSpeed = 2;
DWORD seed = 1;
DWORD mediaType = MEDIA_UNKNOWN;

//
// stats
//
DWORD numFailThenFail = 0;
DWORD numFailThenFailSame = 0;
DWORD numFailThenPass = 0;
DWORD numPassThenFail = 0;
DWORD numBuffMisMatch = 0;
DWORD numTimesThrough = 1;
unsigned __int64 numBlocksRead = 0;
DWORD time = 0;
char model[64], serial[64], firmware[64];


void _cdecl main(void)
    {
    Initialize();

    //
    // cleanup old files
    //
    DeleteFile("T:\\dvdexit.txt");


    DebugPrint("DVD Read (Built on " __DATE__ " at " __TIME__ ")\n");
    DebugPrint("Copyright (C) Microsoft Corporation.  All rights reserved.\n\n");

    DWORD addDevice, removeDevice;
    DWORD dumpData = 0;
    DWORD status;
    READ_FUNC ReadBlocks;
    DWORD geometryIOCTL;
    DWORD geoSize;
    bool exit = false;
    DWORD rando = 0;
    ULONGLONG bigResult = 0;
    DWORD block = 0;
    SCSIError err1, err2, err3;
    DWORD numReads = 0;
    DWORD avgStartLBA = 0;
    unsigned numCommandErrors = 0;
    DWORD extraSpace = 0;

    memset(&gDiskGeometry, 0, sizeof(gDiskGeometry));
    strcpy(deviceName, "\\Device\\cdrom0");

    //
    // parse out any user settings
    //
    FILE *f = fopen("D:\\config.txt", "r");
    if(f)
        {
        char line[1024];
        char value[128];
        char variable[64];
        while(fgets(line, 1024, f))
            {
            if(sscanf(line, "%[^=]= %s", variable, value) == 2)
                {
                char *c = strchr(variable, ';');
                if(c) *c = '\0';
                c = strchr(variable, '[');
                if(c) *c = '\0';
                _strlwr(variable);
                if(strstr(variable, "device") != NULL) strcpy(deviceName, value);
                else if(strstr(variable, "startlba") != NULL) startLBA = GetNumber(value);
                else if(strstr(variable, "endlba") != NULL) endLBA = GetNumber(value);
                else if(strstr(variable, "defaultspeed") != NULL) defaultSpeed = atol(value);
                else if(strstr(variable, "enableretries") != NULL) enableRetries = atol(value);
                else if(strstr(variable, "readsizemin") != NULL) chunkSizeMin = GetNumber(value);
                else if(strstr(variable, "readsizemax") != NULL) chunkSizeMax = GetNumber(value);
                else if(strstr(variable, "readsize") != NULL) chunkSizeMax = chunkSizeMin = GetNumber(value);
                else if(strstr(variable, "comparebuffers") != NULL) compareBuffers = atol(value);
                else if(strstr(variable, "sequentialreads") != NULL) sequentialReads = atol(value);
                else if(strstr(variable, "stopafter") != NULL) stopAfter = atol(value);
                else if(strstr(variable, "readmode") != NULL) readMode = GetNumber(value);
                else if(strstr(variable, "dumpdata") != NULL) dumpData = atol(value);
                else if(strstr(variable, "avgspan") != NULL) avgSpan = atol(value);
                else if(strstr(variable, "requestsense") != NULL) requestSense = atol(value);
                else if(strstr(variable, "summaryinternalerrs") != NULL) summaryInternalErrs = atol(value);
                else if(strstr(variable, "pauseonexit") != NULL) pauseOnExit = GetNumber(value);
                else if(strstr(variable, "launchgui") != NULL) launchGUI = GetNumber(value);
                else if(strstr(variable, "speeddelay0to1") != NULL) speedDelay0to1 = atol(value);
                else if(strstr(variable, "speeddelay1to2") != NULL) speedDelay1to2 = atol(value);
                else if(strstr(variable, "speeddelay2to1") != NULL) speedDelay2to1 = atol(value);
                else if(strstr(variable, "speeddelay1to0") != NULL) speedDelay1to0 = atol(value);
                else if(strstr(variable, "speeddelay0to2") != NULL) speedDelay0to2 = atol(value);
                else if(strstr(variable, "speeddelay2to0") != NULL) speedDelay2to0 = atol(value);
                else if(strstr(variable, "delayon062e") != NULL) delayOn062E = atol(value);
                else if(strstr(variable, "seekon062e") != NULL) seekOn062E = atol(value);
                else if(strstr(variable, "numberofreads") != NULL) numberOfReads = GetNumber(value);
                else if(strstr(variable, "pauseonmismatch") != NULL) pauseOnMismatch = atol(value);
                else if(strstr(variable, "seed") != NULL) seed = GetNumber(value);
                else if(strstr(variable, "exclude") != NULL)
                    {
                    if(!exclude) exclude = new ExcludeList(value);
                    else exclude->Add(value);
                    }
                }
            }
        
        fclose(f);
        }

    //
    // seed random number generator
    //
    srand(seed);


    //
    // open the DVD / Hard drive
    //
    HANDLE hDevice;
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING VolumeString;
    IO_STATUS_BLOCK IoStatusBlock;
    RtlInitObjectString(&VolumeString, deviceName);
    InitializeObjectAttributes(&ObjA, &VolumeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtCreateFile(&hDevice, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_INTERMEDIATE_BUFFERING);
    if(!NT_SUCCESS(status))
        {
        DebugPrint("\n\n\nUnable to open the device '%s' (ec: %u)\n", deviceName, RtlNtStatusToDosError(status));
        DebugPrint("Rebooting...\n\n\n");
        Sleep(1000);
        XLaunchNewImage(NULL, NULL);
        }

    _strlwr(deviceName);

    if(strstr(deviceName, "cdrom") != NULL) // target == DVD or CD
        {
        mediaType = GetDiskType(hDevice);
        if(readMode == READMODE_DETECT)
            {
            if(mediaType == MEDIA_CDDA) readMode = READMODE_CD;
            else readMode = READMODE_DVD;
            }

        if(readMode == READMODE_DVD)
            {
            ReadBlocks = ReadDVDBlocks;
            ChangeSpeed(hDevice, defaultSpeed);
            }
        else if(readMode == READMODE_CD)
            {
            ReadBlocks = ReadCDBlocks2;
            extraSpace = 304; // we read in chunks of an audio frame size not clustor size
            }
        else if(readMode == READMODE_HD)
            {
            ReadBlocks = ReadHDBlocks;
            }

        geometryIOCTL = IOCTL_CDROM_GET_DRIVE_GEOMETRY;
	    DeviceIoControl(hDevice, geometryIOCTL, NULL, 0, &gDiskGeometry, sizeof(gDiskGeometry), &geoSize, NULL);
        }
    else // target == hard disk
        {
        mediaType = MEDIA_HD;
        readMode = READMODE_HD;
        ReadBlocks = ReadHDBlocks;
        geometryIOCTL = IOCTL_DISK_GET_DRIVE_GEOMETRY;
	    DeviceIoControl(hDevice, geometryIOCTL, NULL, 0, &gDiskGeometry, sizeof(gDiskGeometry), &geoSize, NULL);

        // gDiskGeometry.Cylinders.QuadPart contains the size of the entire 
        // disk but we only want the size of the current partition so we 
        // need to query the size of the volume and adjust the value
        FILE_FS_SIZE_INFORMATION NormalSizeInfo;
        memset(&NormalSizeInfo, 0, sizeof(NormalSizeInfo));
        NtQueryVolumeInformationFile(
                    hDevice,
                    &IoStatusBlock,
                    &NormalSizeInfo,
                    sizeof(NormalSizeInfo),
                    FileFsSizeInformation
                    );
        gDiskGeometry.Cylinders.QuadPart = NormalSizeInfo.TotalAllocationUnits.QuadPart * NormalSizeInfo.SectorsPerAllocationUnit;
        }
    if(endLBA == 0) endLBA = (DWORD)gDiskGeometry.Cylinders.QuadPart;


    if(launchGUI)
        {
        GUI(true);
        }

    //
    // print out the drive info, disk geometry, and config settings
    //
    memset(model, 0, 64);
    memset(serial, 0, 64);
    memset(firmware, 0, 64);
    GetDriveID(hDevice, geometryIOCTL == IOCTL_CDROM_GET_DRIVE_GEOMETRY, model, serial, firmware);
	DebugPrint("DRIVE: Model:             %s\n", model);
	DebugPrint("DRIVE: Serial:            %s\n", serial);
	DebugPrint("DRIVE: Firmware:          %s\n", firmware);
	DebugPrint("MEDIA: Type:              %s\n", mediaTypeNames[mediaType]);
	DebugPrint("MEDIA: Cylinders:         %u\n", gDiskGeometry.Cylinders.QuadPart);
	DebugPrint("MEDIA: TracksPerCylinder: %u\n", gDiskGeometry.TracksPerCylinder);
	DebugPrint("MEDIA: SectorsPerTrack:   %u\n", gDiskGeometry.SectorsPerTrack);
	DebugPrint("MEDIA: BytesPerSector:    %u\n", gDiskGeometry.BytesPerSector);
	DebugPrint("\n");
    DebugPrint("CONFIG: Device:           %s\n", deviceName);
    DebugPrint("CONFIG: ReadSizeMin:      %u\n", chunkSizeMin);
    DebugPrint("CONFIG: ReadSizeMax:      %u\n", chunkSizeMax);
    DebugPrint("CONFIG: StartLBA:         %u\n", startLBA);
    DebugPrint("CONFIG: EndLBA:           %u\n", endLBA);
    DebugPrint("CONFIG: ReadMode:         %u\n", readMode);
    DebugPrint("CONFIG: NumberOfReads:    %u\n", numberOfReads);
    DebugPrint("CONFIG: SequentialReads:  %u\n", sequentialReads);
    DebugPrint("CONFIG: SummaryInternalErrs: %u\n", summaryInternalErrs);
    DebugPrint("CONFIG: CompareBuffers:   %u\n", compareBuffers);
    DebugPrint("CONFIG: PauseOnMismatch:  %u\n", pauseOnMismatch);
	DebugPrint("\n");
    DebugPrint("CONFIG: RequestSense:     %u\n", requestSense);
    DebugPrint("CONFIG: EnableRetries:    %u\n", enableRetries);
    DebugPrint("CONFIG: DefaultSpeed:     %u\n", defaultSpeed);
    DebugPrint("CONFIG: SpeedDelay0to1:   %u\n", speedDelay0to1);
    DebugPrint("CONFIG: SpeedDelay1to2:   %u\n", speedDelay1to2);
    DebugPrint("CONFIG: SpeedDelay2to1:   %u\n", speedDelay2to1);
    DebugPrint("CONFIG: SpeedDelay1to0:   %u\n", speedDelay1to0);
    DebugPrint("CONFIG: SpeedDelay0to2:   %u\n", speedDelay0to2);
    DebugPrint("CONFIG: SpeedDelay2to0:   %u\n", speedDelay2to0);
    DebugPrint("CONFIG: DelayOn062E:      %u\n", delayOn062E);
    DebugPrint("CONFIG: SeekOn062E :      %u\n", seekOn062E );
    DebugPrint("\n");


    //
    // allocate buffer space
    //
    unsigned char *buff1 = new unsigned char[chunkSizeMax * (gDiskGeometry.BytesPerSector+extraSpace)];
    unsigned char *buff2 = new unsigned char[chunkSizeMax * (gDiskGeometry.BytesPerSector+extraSpace)];
    unsigned char *buff3 = new unsigned char[chunkSizeMax * (gDiskGeometry.BytesPerSector+extraSpace)];
    if(!buff1 || !buff2 || !buff3)
        {
        DebugPrint("\n\n\nUnable to allocate enough space (%u)\n", chunkSizeMax * gDiskGeometry.BytesPerSector * 3);
        DebugPrint("Lower the 'ReadSize=' value in the config.txt file\n");
        DebugPrint("Rebooting...\n\n\n");
        Sleep(1000);
        XLaunchNewImage(NULL, NULL);
        return;
        }

    time = GetTickCount();

    //
    // run the test
    //
    avgStartLBA = block = startLBA;
    while(!exit)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);
        UpdateGraphics(DISPLAYMODE_RUN_TIME);

        memset(buff1, 0, chunkSizeMax * gDiskGeometry.BytesPerSector);
        memset(buff2, 0, chunkSizeMax * gDiskGeometry.BytesPerSector);
        memset(buff3, 0, chunkSizeMax * gDiskGeometry.BytesPerSector);

        //
        // calculate the size of the next read
        //
        rando = rand();
        bigResult = (ULONGLONG)(rando*(ULONGLONG)(chunkSizeMax-chunkSizeMin));
        readSize = (DWORD)((bigResult/RAND_MAX) + chunkSizeMin);

        ++numReads;

        //
        // read from the disk
        //
        err1 = ReadBlocks(hDevice, block, readSize, buff1);
        numBlocksRead += readSize;
        if(requestSense == 2 && err1.win32 == 0 && geometryIOCTL == IOCTL_CDROM_GET_DRIVE_GEOMETRY && readMode == READMODE_DVD) RequestSense(hDevice, err1);
        if(dumpData)
            {
            DebugPrint("Block %u: ", block);
            err1.Print();
            DebugPrint("\n");
            HexDump(buff1, readSize * gDiskGeometry.BytesPerSector);
            goto EOErrorCheck;
            }
        if(numberOfReads == 1) goto EOErrorCheck;

        err2 = ReadBlocks(hDevice, block, readSize, buff2);
        numBlocksRead += readSize;
        if(requestSense == 2 && err2.win32 == 0 && geometryIOCTL == IOCTL_CDROM_GET_DRIVE_GEOMETRY && readMode == READMODE_DVD) RequestSense(hDevice, err2);

        //
        // check for errors
        //
        if(err1.win32 != 0 && err2.win32 == 0)
            {
            numCommandErrors = 0;
            if(!errors) errors = new ErrorDistrubition(err1);
            else errors->AddError(err1);
            ++numFailThenPass;
            DebugPrint("Block %u: Read1 failed ", block);
            err1.Print();
            DebugPrint(" Read2 succeeded ");
            err2.Print();
            DebugPrint("\n");
            }
        else if(err1.win32 == 0 && err2.win32 != 0)
            {
            numCommandErrors = 0;
            if(!errors) errors = new ErrorDistrubition(err2);
            else errors->AddError(err2);
            ++numPassThenFail;
            DebugPrint("Block %u: Read1 succeeded ", block);
            err1.Print();
            DebugPrint(" Read2 failed ");
            err2.Print();
            DebugPrint("\n");
            }
        else if((err1.sense.ErrorCode                    != err2.sense.ErrorCode)           ||
                (err1.sense.Valid                        != err2.sense.Valid)               ||
                (err1.sense.SenseKey                     != err2.sense.SenseKey)            ||
                (err1.sense.Reserved                     != err2.sense.Reserved)            ||
                (err1.sense.IncorrectLength              != err2.sense.IncorrectLength)     ||
                (err1.sense.EndOfMedia                   != err2.sense.EndOfMedia)          ||
                (err1.sense.FileMark                     != err2.sense.FileMark)            ||
                (err1.sense.AdditionalSenseCode          != err2.sense.AdditionalSenseCode) ||
                (err1.sense.AdditionalSenseCodeQualifier != err2.sense.AdditionalSenseCodeQualifier))
            {
            numCommandErrors = 0;
            if(!errors) errors = new ErrorDistrubition(err1);
            else errors->AddError(err1);
            if(!errors) errors = new ErrorDistrubition(err2);
            else errors->AddError(err2);
            ++numFailThenFail;
            DebugPrint("Block %u: Err1", block);
            err1.Print();
            DebugPrint(" != Err2");
            err2.Print();
            DebugPrint("\n");
            }

        // errors are the same at this point
        else if(err1.win32!=0 || err2.win32!=0)
            {
            if(!errors) errors = new ErrorDistrubition(err1);
            else errors->AddError(err1);
            errors->AddError(err2);
            ++numFailThenFailSame;
            DebugPrint("Block %u: Same Error Err1/2", block);
            err1.Print();
            DebugPrint("\n");
            if(err1.sense.SenseKey == 0x05 && err1.sense.AdditionalSenseCode == 0x81) // command error
                {
                numCommandErrors += readSize;
                if(numCommandErrors >= 4096)
                    {
                    numCommandErrors = 0;
                    numFailThenFailSame -= (4096/readSize);
                    errors->RemoveError(err1, (4096/readSize) * 2);
                    DebugPrint("End of security section.\n");
                    }
                }
            }
        else if(err1.win32==0 && err2.win32==0 && (memcmp(buff1, buff2, readSize*gDiskGeometry.BytesPerSector) != 0))
            {
            numCommandErrors = 0;
            if(requestSense == 1 && readMode == READMODE_DVD) RequestSense(hDevice, err2);
            if(pauseOnMismatch) Pause();
            int retry = 3;
            do {
                // do another read for reference
                err3 = ReadBlocks(hDevice, block, readSize, buff3);
                retry--;
                } while(err3.win32 != 0 && retry >= 0);

            numBlocksRead += readSize;

            ++numBuffMisMatch;
            DebugPrint("Block %u: buff1 != buff2, Err1", block);
            err1.Print();
            DebugPrint(", Err2");
            err2.Print();
            DebugPrint("\n");
            if(compareBuffers) CompareBuff(buff1, buff2, buff3, readSize*gDiskGeometry.BytesPerSector);
            }

        EOErrorCheck:

        if(numberOfReads == 1)
            {
            if(err1.win32!=0)
                {
                if(!errors) errors = new ErrorDistrubition(err1);
                else errors->AddError(err1);
                ++numFailThenFailSame;
                DebugPrint("Block %u: Single Error ", block);
                err1.Print();
                DebugPrint("\n");
                if(err1.sense.SenseKey == 0x05 && err1.sense.AdditionalSenseCode == 0x81) // command error
                    {
                    numCommandErrors += readSize;
                    if(numCommandErrors >= 4096)
                        {
                        numCommandErrors = 0;
                        numFailThenFailSame -= (4096/readSize);
                        errors->RemoveError(err1, (4096/readSize) * 2);
                        DebugPrint("End of security section.\n");
                        }
                    }
                }
            }


        //
        // adjust the read pointer (skipping any exclude areas)
        //
        do {
            if(sequentialReads)
                {
                block += readSize;
                if(block >= endLBA)
                    {
                    block = startLBA;
                    ++numTimesThrough;
                    if(stopAfter && numTimesThrough >= stopAfter) 
                        {
                        exit = true;
                        break;
                        }
                    }
                }
            else
                {
                rando = rand();
                bigResult = (ULONGLONG)(rando*(ULONGLONG)(endLBA-startLBA));
                block = (DWORD)((bigResult/RAND_MAX) + startLBA);
                }
            } while((exclude && exclude->InList(block, chunkSizeMax)) || (block+chunkSizeMax >= endLBA));


        //
        // avg read time
        //
        if(avgSpan && (numReads % avgSpan == 0))
            {
            DWORD avg = 0;
            if(avgTimeCount != 0)
                avg = avgTime/avgTimeCount;

            if(sequentialReads)
                DebugPrint("Blocks %u-%u: avg Read Time == %u ms\n", avgStartLBA, block, avg);
            else
                DebugPrint("Read %u-%u: avg Read Time == %u ms\n", numReads-avgSpan, numReads, avg);

            avgTimeCount = 0;
            avgTime = 0;
            avgStartLBA = block;
            }

        if(InputCheckDigitalButton(XINPUT_GAMEPAD_START)) GUI(false);
        if(InputCheckExitCombo()) exit = true;
        } // while


    //
    // dump the stats
    //
    DWORD finalTime = (GetTickCount() - time)/1000;
    DWORD totalErrors = numFailThenFailSame*2 + numFailThenFail*2 + numFailThenPass + numPassThenFail;

    DebugPrint("****Program Stats:\n");
    DebugPrint("*** %9u sec run time\n", finalTime);
    DebugPrint("*** %9I64u Total blocks read\n", numBlocksRead);
    DebugPrint("****\n");
    if(numberOfReads == 1)
        DebugPrint("*** %9u Single Failures\n", numFailThenFailSame);
    else
        {
        DebugPrint("*** %9u Buffer mismatches (no failure reported)\n", numBuffMisMatch);
        DebugPrint("*** %9u Failures then different failures\n", numFailThenFail);
        DebugPrint("*** %9u Failures then same failures\n", numFailThenFailSame);
        DebugPrint("*** %9u Failures then successes\n", numFailThenPass);
        DebugPrint("*** %9u Successes then failures\n", numPassThenFail);
        }
    DebugPrint("*** %9u Total Reported Errors\n", totalErrors);
    DebugPrint("****\n");
    DebugPrint("*** %9u errors / reads\n", numReads? totalErrors / numReads : 0);
    DebugPrint("*** %9u errors / sec\n", finalTime? totalErrors / finalTime : 0);
    if(errors)
        {
        DebugPrint("****Error Distribution:\n");
        errors->PrintErrors();
        }

    if(pauseOnExit) Pause();

    XLaunchNewImage(NULL, NULL);
    }



void Initialize(void)
    {
    DWORD error;

    //
    // Misc
    //
    DWORD dataType = 0xCDCDCDCD;
    LAUNCH_DATA launchInfo;
    error = XGetLaunchInfo(&dataType, &launchInfo);

    //
    // USB
    //
    XInitDevices(0, NULL);

    //
    // Network
    //
    /*
    XNetStartupParams xnsp = { sizeof(XNetStartupParams), XNET_STARTUP_BYPASS_SECURITY };
    error = XNetStartup(&xnsp);
    if(error != NO_ERROR)
        {
        DebugPrint("XNetStartup Error (ec: %ld)\n", error);
        }
    Sleep(5000); // needed cause XNetStartup isnt fully started when call exits
    */

    //
    //
    //
    InitGraphics();
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dvdread\dvdUtils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    dvdUtils.cpp

Abstract:

    Functions that talk to the DVD drive

Notes:
    dvd player code:
        "\xboxsrc\private\ui\dvd\library\hardware\drives\specific\xboxdvddrive.cpp"
    filesystem retry code:
        "\xboxsrc\private\ntos\idex\cdrom.c" (IdexCdRomFinishRequestSense)
    sense data format:
        "\xboxsrc\public\ddk\inc\scsi.h"


    DVD-X2 Supported Error Sense Codes
        Sense   Sense   Sense   Description
        Key	    Code    Code Qu
        ----------------------------------------------------------------------
        0x00	0x00	0x00	No Additional Sense information (= no error)
        0x01	0x80	0x00	Cache fill error, speed reduction requested
        0x02	0x04	0x00	Logical Unit not ready, cause not reported
        0x02	0x04	0x01	Logical Unit is in process of becoming ready
        0x02	0x30	0x00	Incompatible medium installed
        0x02	0x3A	0x00	Medium not present
        0x03	0x57	0x00	Unable to recover Table of Contents
        0x03	0x80	0x00	Read Error
        0x04	0x00	0x00	Hardware error
        0x04	0x08	0x03	Logical Unit Communication CRC Error - UDMA33
        0x05	0x21	0x00	Logical Block Address Out of Range
        0x05	0x55	0x00	System Resource Failure
        0x05	0x64	0x00	Illegal mode for this track
        0x05	0x6F	0x00	Authentication Failure - CSS
        0x05	0x80	0x00	Authentication Failure - Xbox
        0x05	0x81	0x00	Command error
        0x06	0x29	0x00	Power On, Reset or Bus Device Reset occurred
        0x06	0x2A	0x01	Mode Parameters changed
        0x06	0x2E	0x00	Insufficient time for operation

    Win32 Error code mapping:
        1/80:   ERROR_CRC                   23
        2/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        2/other ERROR_NOT_READY             21
        3/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        3/other ERROR_CRC                   23
        5/21:   ERROR_SECTOR_NOT_FOUND      27
        5/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        5/6F:   ERROR_TOO_MANY_SECRETS      1381
        5/80:   ERROR_TOO_MANY_SECRETS      1381
        other:  ERROR_IO_DEVICE             1117

    IOCTL_CDROM_SET_SPINDLE_SPEED
        speed 2     ~3000rpm      2x -    5x
        speed 1     ~2000rpm    4/3x - 10/3x
        speed 0     ~1000rpm    2/3x -  5/3x

*****************************************************************************/

#include "dvdread.h"

/*
APIs in this file:

    SCSIError ReadDVDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
    SCSIError ReadCDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
    SCSIError ReadHDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
    void SeekLBA(HANDLE hDevice, DWORD LBA);
    void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware);
    void ChangeSpeed(HANDLE hDevice, DWORD newSpeed);
    bool CDTestReady(HANDLE hDevice);
    void RequestSense(HANDLE hDevice, SCSIError &sense);

*/





/*
    Retry Schema for the DeviceIoControl mode:

                                                action1                     action2                         action3                     action4
    Retry for 01/80/00:                         change speed wait retry.... change speed, wait, retry....   fail
    Retry for 03/80/00, 04/00/00 and 05/55/00:  retry...                    change speed, wait, retry....   change speed, wait, retry   fail
    Retry for 06/2E/00:                         delay 2 sec, retry...       change speed, wait, retry       change speed, wait, retry   fail
    Retry for 06/29/00:                         wait untill drive is ready
    Retry for 05/81/00:                         retry...                    fail
*/
SCSIError ReadDVDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer)
    {
    DWORD time = GetTickCount();
    ++avgTimeCount;

    SCSIError err;
    bool retry = false;
	PCDB Cdb;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    DWORD cbReturned;
    SENSE_DATA sense;
    SENSE_DATA previousSense;
    memset(&previousSense, 0, sizeof(SENSE_DATA));

    ZeroMemory(&PassThrough, sizeof(PassThrough));
    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = buffer;
    PassThrough.DataTransferLength = num*gDiskGeometry.BytesPerSector;

	Cdb = (PCDB)&PassThrough.Cdb;
    Cdb->CDB10.OperationCode = SCSIOP_READ;
	Cdb->CDB10.ForceUnitAccess = 1;
	Cdb->CDB10.LogicalBlock = RtlUlongByteSwap(block);
	Cdb->CDB10.TransferBlocks = RtlUshortByteSwap((unsigned short)num);

    DWORD actionState = 1;
    DWORD retryCount = 0;

    do {
        if(retry) ++retryCount;
        SetLastError(0);
        memset(&err, 0, sizeof(SCSIError));
        memset(&sense, 0, sizeof(SENSE_DATA));
        retry = false;

        if(!DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT), &sense, sizeof(SENSE_DATA), &cbReturned, NULL))
            {
            err.win32 = GetLastError();
            memcpy(&err.sense, &sense, sizeof(SENSE_DATA));
            successfulReadSectors = 0;
            }
        else if(sense.ErrorCode)
            {
            err.win32 = 99999;
            memcpy(&err.sense, &sense, sizeof(SENSE_DATA));

            if(enableRetries && sense.ErrorCode == 0x70)
                {
                if(actionState == 2 && memcmp(&previousSense, &sense, sizeof(SENSE_DATA)) != 0)
                    {
                    if(retryCount == 3)
                        {
                        retry = false;
                        actionState = 99;
                        }
                    else
                        {
                        actionState = 1;
                        }
                    }

                if(actionState == 1)
                    {
                    if((sense.SenseKey == 0x01 && sense.AdditionalSenseCode == 0x80))
                        {
                        if(spindleSpeed == 0) retry = false;
                        else { PrintPreRetryError(block, err); ChangeSpeed(hDevice, spindleSpeed-1); retry = true; }
                        }
                    else if((sense.SenseKey == 0x06 && sense.AdditionalSenseCode == 0x2E))
                        {
                        PrintPreRetryError(block, err);
                        if(seekOn062E)
                            {
                            SeekLBA(hDevice, 0);
                            }
                        Sleep(delayOn062E);

                        retry = true;
                        }
                    else if((sense.SenseKey == 0x06 && sense.AdditionalSenseCode == 0x29))
                        {
                        PrintPreRetryError(block, err);
                        while(CDTestReady(hDevice) == false)
                            {
                            // do nothing until drive is ready
                            }
                        retry = true;
                        }
                    else
                        {
                        PrintPreRetryError(block, err); 
                        retry = true;
                        }
                    }
                else if(actionState == 2)
                    {
                    if((sense.SenseKey == 0x01 && sense.AdditionalSenseCode == 0x80) ||
                       (sense.SenseKey == 0x03 && sense.AdditionalSenseCode == 0x80) ||
                       (sense.SenseKey == 0x04 && sense.AdditionalSenseCode == 0x00) ||
                       (sense.SenseKey == 0x05 && sense.AdditionalSenseCode == 0x55) ||
                       (sense.SenseKey == 0x06 && sense.AdditionalSenseCode == 0x2E) )
                        {
                        if(spindleSpeed == 0) retry = false;
                        else { PrintPreRetryError(block, err); ChangeSpeed(hDevice, spindleSpeed-1); retry = true; }
                        }
                    else
                        {
                        retry = false;
                        }
                    }
                else if(actionState == 3)
                    {
                    if((sense.SenseKey == 0x03 && sense.AdditionalSenseCode == 0x80) ||
                       (sense.SenseKey == 0x04 && sense.AdditionalSenseCode == 0x00) ||
                       (sense.SenseKey == 0x05 && sense.AdditionalSenseCode == 0x55) ||
                       (sense.SenseKey == 0x06 && sense.AdditionalSenseCode == 0x2E) )
                        {
                        if(spindleSpeed == 0) retry = false;
                        else { PrintPreRetryError(block, err); ChangeSpeed(hDevice, spindleSpeed-1); retry = true; }
                        }
                    else
                        {
                        retry = false;
                        }
                    }
                else
                    {
                    retry = false;
                    }
                }

            memcpy(&previousSense, &sense, sizeof(SENSE_DATA));
            successfulReadSectors = 0;
            }
        else
            {
            successfulReadSectors += num;
            }

        if(retry && summaryInternalErrs)
            {
            if(!errors) errors = new ErrorDistrubition(err);
            else errors->AddError(err);
            }

        ++actionState;
        } while(retry);

    if(enableRetries == 1 && spindleSpeed == 0 && successfulReadSectors >= 4096)
        {
        ChangeSpeed(hDevice, spindleSpeed+1);
        successfulReadSectors = 0;
        }
    else if(enableRetries == 1 && spindleSpeed == 1 && successfulReadSectors >= 16384)
        {
        ChangeSpeed(hDevice, spindleSpeed+1);
        successfulReadSectors = 0;
        }

    lastReadTime = GetTickCount()-time;
    avgTime += lastReadTime;
    if(lastReadTime > 1000)
        DebugPrint("Block %u: Read took %ums\n", block, lastReadTime);
    return err;
    }

SCSIError ReadCDBlocks2(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer)
    {
    // "E:\xboxsrc\private\ntos\idex\cdrom.c" (1519):IdexCdRomStartRawRead(
    DWORD time = GetTickCount();
    ++avgTimeCount;

	PCDB Cdb;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    DWORD cbReturned;
    SENSE_DATA sense;
    memset(&sense, 0, sizeof(SENSE_DATA));

    SCSIError err;

    // NT drivers seem to want the disk offset to be (sector - 150) * 2048,
    // regardless of what the actual disk lead-in amount is.
    RAW_READ_INFO rri;
    rri.DiskOffset.QuadPart = (unsigned __int64)(block - CDAUDIO_SECTOR_OFFSET) * (unsigned __int64)gDiskGeometry.BytesPerSector;
    rri.SectorCount = num;
    rri.TrackMode = CDDA;


    ZeroMemory(&PassThrough, sizeof(PassThrough));
    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = buffer;
    PassThrough.DataTransferLength = rri.SectorCount * IDE_ATAPI_RAW_CD_SECTOR_SIZE;

	Cdb = (PCDB)&PassThrough.Cdb;
    Cdb->READ_CD.OperationCode = SCSIOP_READ_CD;
    *((PULONG)Cdb->READ_CD.StartingLBA) = RtlUlongByteSwap((ULONG)(rri.DiskOffset.QuadPart >>IDE_ATAPI_CD_SECTOR_SHIFT));
    Cdb->READ_CD.TransferBlocks[2] = (UCHAR)(rri.SectorCount);
    Cdb->READ_CD.TransferBlocks[1] = (UCHAR)(rri.SectorCount >> 8);
    Cdb->READ_CD.TransferBlocks[0] = (UCHAR)(rri.SectorCount >> 16);

    // TrackMode == CDDA
    Cdb->READ_CD.ExpectedSectorType = 1;
    Cdb->READ_CD.IncludeUserData = 1;
    Cdb->READ_CD.HeaderCode = 3;
    Cdb->READ_CD.IncludeSyncData = 1;

/*
    // TrackMode == YellowMode2
    Cdb.READ_CD.ExpectedSectorType = 3;
    Cdb.READ_CD.IncludeUserData = 1;
    Cdb.READ_CD.HeaderCode = 1;
    Cdb.READ_CD.IncludeSyncData = 1;

    // TrackMode == XAForm2
    Cdb.READ_CD.ExpectedSectorType = 5;
    Cdb.READ_CD.IncludeUserData = 1;
    Cdb.READ_CD.HeaderCode = 3;
    Cdb.READ_CD.IncludeSyncData = 1;
*/

    if(!DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT), &sense, sizeof(SENSE_DATA), &cbReturned, NULL))
        {
        err.win32 = GetLastError();
        memcpy(&err.sense, &sense, sizeof(SENSE_DATA));
        }
    //status = DeviceIoControl(hDevice, IOCTL_CDROM_RAW_READ, &rri, sizeof(RAW_READ_INFO), buffer, CDAUDIO_BYTES_PER_FRAME * num, &cbReturned, NULL);
    //status = DeviceIoControl(hDevice, IOCTL_CDROM_RAW_READ, &rri, sizeof(RAW_READ_INFO), buffer, gDiskGeometry.BytesPerSector * num, &cbReturned, NULL);


    lastReadTime = GetTickCount()-time;
    avgTime += lastReadTime;
    if(lastReadTime > 1000)
        DebugPrint("Block %u: Read took %ums\n", block, lastReadTime);
    return err;
    }


SCSIError ReadCDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer)
    {
    DWORD time = GetTickCount();
    ++avgTimeCount;

    SCSIError err;
    NTSTATUS status;
    DWORD cbReturned;
    RAW_READ_INFO rri;

    // NT drivers seem to want the disk offset to be (sector - 150) * 2048,
    // regardless of what the actual disk lead-in amount is.
    rri.DiskOffset.QuadPart = (unsigned __int64)(block - CDAUDIO_SECTOR_OFFSET) * (unsigned __int64)gDiskGeometry.BytesPerSector;
    rri.SectorCount = num;
    rri.TrackMode = CDDA;

    status = DeviceIoControl(hDevice, IOCTL_CDROM_RAW_READ, &rri, sizeof(RAW_READ_INFO), buffer, CDAUDIO_BYTES_PER_FRAME * num, &cbReturned, NULL);
    //status = DeviceIoControl(hDevice, IOCTL_CDROM_RAW_READ, &rri, sizeof(RAW_READ_INFO), buffer, gDiskGeometry.BytesPerSector * num, &cbReturned, NULL);

    if(!NT_SUCCESS(status))
        {
        err.win32 = RtlNtStatusToDosError(status);
        }

    lastReadTime = GetTickCount()-time;
    avgTime += lastReadTime;
    if(lastReadTime > 1000)
        DebugPrint("Block %u: Read took %ums\n", block, lastReadTime);
    return err;
    }

SCSIError ReadHDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer)
    {
    DWORD time = GetTickCount();
    ++avgTimeCount;

    SCSIError err;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;
    LARGE_INTEGER Offset;

    // Calculate Offset
    Offset.QuadPart = (unsigned __int64)block * (unsigned __int64)gDiskGeometry.BytesPerSector;

    // Read bytes at offset
    status = NtReadFile(hDevice, NULL, NULL, NULL, &ioStatusBlock, buffer, num * gDiskGeometry.BytesPerSector, &Offset);

    if(!NT_SUCCESS(status))
        {
        err.win32 = RtlNtStatusToDosError(status);
        }

    lastReadTime = GetTickCount()-time;
    avgTime += lastReadTime;
    if(lastReadTime > 1000)
        DebugPrint("Block %u: Read took %ums\n", block, lastReadTime);
    return err;
    }


void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware)
    {
    unsigned i;
    DWORD returned;
    char buffer[sizeof(ATA_PASS_THROUGH) + 512];
    PATA_PASS_THROUGH atapt = (PATA_PASS_THROUGH)buffer;

    atapt->DataBufferSize = 512;
    atapt->DataBuffer = atapt + 1;

    atapt->IdeReg.bFeaturesReg     = 0;
    atapt->IdeReg.bSectorCountReg  = 0;
    atapt->IdeReg.bSectorNumberReg = 0;
    atapt->IdeReg.bCylLowReg       = 0;
    atapt->IdeReg.bCylHighReg      = 0;
    atapt->IdeReg.bDriveHeadReg    = 0;
    atapt->IdeReg.bHostSendsData   = 0;

    if(cdrom) atapt->IdeReg.bCommandReg = 0xA1;
    else atapt->IdeReg.bCommandReg = 0xEC;

    DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH, atapt, sizeof(ATA_PASS_THROUGH), atapt, sizeof(ATA_PASS_THROUGH), &returned, FALSE);
    PIDE_IDENTIFY_DATA IdData = (PIDE_IDENTIFY_DATA)atapt->DataBuffer;

    for(i=0; i<sizeof(IdData->ModelNumber); i+=2)
        {
        model[i + 0] = IdData->ModelNumber[i + 1];
        model[i + 1] = IdData->ModelNumber[i + 0];
        }
    model[i] = 0;

    for(i=0; i<sizeof(IdData->SerialNumber); i+=2)
        {
        serial[i + 0] = IdData->SerialNumber[i + 1];
        serial[i + 1] = IdData->SerialNumber[i + 0];
        }
    serial[i] = 0;

    for(i=0; i<sizeof(IdData->FirmwareRevision); i+=2)
        {
        firmware[i + 0] = IdData->FirmwareRevision[i + 1];
        firmware[i + 1] = IdData->FirmwareRevision[i + 0];
        }
    firmware[i] = 0;
    }


void ChangeSpeed(HANDLE hDevice, DWORD newSpeed)
    {
    DWORD cbReturned;

    if(spindleSpeed == newSpeed) return;

    DeviceIoControl(hDevice, IOCTL_CDROM_SET_SPINDLE_SPEED, &newSpeed, sizeof(newSpeed), NULL, 0, &cbReturned, NULL);
    DebugPrint("Speed changed to %u (ec: %u)\n", newSpeed, GetLastError());

    if(spindleSpeed == 0 && newSpeed == 1) Sleep(speedDelay0to1);
    else if(spindleSpeed == 1 && newSpeed == 2) Sleep(speedDelay1to2);
    else if(spindleSpeed == 2 && newSpeed == 1) Sleep(speedDelay2to1);
    else if(spindleSpeed == 1 && newSpeed == 0) Sleep(speedDelay1to0);
    else if(spindleSpeed == 0 && newSpeed == 2) Sleep(speedDelay0to2);
    else if(spindleSpeed == 2 && newSpeed == 0) Sleep(speedDelay2to0);

    spindleSpeed = newSpeed;
    }


void SeekLBA(HANDLE hDevice, DWORD LBA)
    {
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    SENSE_DATA SenseData;
    DWORD cbBytesReturned;
    PCDB Cdb;

    RtlZeroMemory(&PassThrough, sizeof(PassThrough));
    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);

    Cdb = (PCDB)&PassThrough.Cdb;
    Cdb->SEEK.OperationCode = SCSIOP_SEEK;
    *((PULONG)Cdb->SEEK.LogicalBlockAddress) = RtlUlongByteSwap(LBA);

    DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
								&PassThrough, sizeof(PassThrough), 
                                &SenseData, sizeof(SenseData),
                                &cbBytesReturned, NULL);
    
    
    DebugPrint("Seek to %u (ec: %u)\n", LBA, GetLastError());
    }


bool CDTestReady(HANDLE hDevice)
    {
    DWORD cbReturned;

    BOOL fReturn = DeviceIoControl(hDevice, IOCTL_CDROM_CHECK_VERIFY, NULL, 0, NULL, 0, &cbReturned, NULL);

    if(fReturn || (GetLastError() == ERROR_UNRECOGNIZED_MEDIA))
        {
        return false;
        }
    
    return true;
    }


void RequestSense(HANDLE hDevice, SCSIError &err)
    {
	PCDB Cdb;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    DWORD cbReturned;
    SENSE_DATA sense;

    ZeroMemory(&PassThrough, sizeof(PassThrough));
    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = &sense;
    PassThrough.DataTransferLength = sizeof(SENSE_DATA);

	Cdb = (PCDB)&PassThrough.Cdb;
    Cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
	Cdb->CDB6INQUIRY.AllocationLength = sizeof(SENSE_DATA);

    SetLastError(0);
    memset(&err, 0, sizeof(SCSIError));
    memset(&sense, 0, sizeof(SENSE_DATA));

    DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT), &sense, sizeof(SENSE_DATA), &cbReturned, NULL);

    err.win32 = GetLastError();
    memcpy(&err.sense, &sense, sizeof(SENSE_DATA));
    }





DWORD GetDiskType(HANDLE hDevice)
    {
    DVD_READ_STRUCTURE readStruct;
    UCHAR readStructureOutput[ALIGN_UP(sizeof(DVD_DESCRIPTOR_HEADER) + sizeof(DVD_LAYER_DESCRIPTOR), ULONG)];

    memset(&readStruct, 0, sizeof(DVD_READ_STRUCTURE));
    memset(&readStructureOutput, 0, sizeof(readStructureOutput));

    // try DVD Read Structure
    readStruct.Format = DvdPhysicalDescriptor;

    DWORD returned = 0;
    BOOL result = DeviceIoControl(hDevice, IOCTL_DVD_READ_STRUCTURE, &readStruct, sizeof(DVD_READ_STRUCTURE), &readStructureOutput, sizeof(readStructureOutput), &returned, NULL);
    if(result)
        {
        DVD_LAYER_DESCRIPTOR *layerDescr = (DVD_LAYER_DESCRIPTOR *)(&readStructureOutput[sizeof(DVD_DESCRIPTOR_HEADER)]);
        BYTE layerType = (layerDescr->BookType) | (layerDescr->BookVersion << 4);
        if(layerDescr->LayerType == 1)
            {
            if(layerDescr->NumberOfLayers == 0)
                return MEDIA_DVD_5_RO;
            else return MEDIA_DVD_9_RO;
            }
        else
            {
            if(layerDescr->NumberOfLayers == 0)
                return MEDIA_DVD_5_RW;
            else return MEDIA_DVD_9_RW;
            }
        }

    // not a DVD disk...
    else
        {
	    CDROM_TOC toc;
        memset(&toc, 0, sizeof(CDROM_TOC));
		result = DeviceIoControl( hDevice, IOCTL_CDROM_READ_TOC, &toc, sizeof(CDROM_TOC), &toc, sizeof(CDROM_TOC), &returned, NULL);
        if(result)
            {
            if(toc.FirstTrack == toc.LastTrack) return MEDIA_CDROM;
            return MEDIA_CDDA;
            }
        else
            {
            return MEDIA_CDROM;
            }
        }

    return MEDIA_UNKNOWN;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dvdread\gui.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    gui.cpp

Abstract:

    Low level disk test scanner.

Notes:

*****************************************************************************/
#include "dvdread.h"

IDirect3D8*		    g_d3d		= NULL;
IDirect3DDevice8*	g_pDevice	= NULL;
BitFont				g_font;
IDirect3DTexture8*	g_pd3dtText	= NULL;
TVertex				g_prText[4];
D3DLOCKED_RECT		g_d3dlr;

#define STICK_DEAD_ZONE         6400
#define BUTTON_PRESS_VALUE      100
#define BUTTON_SPEEP_VALUE      150         // in ms

#define COLUMN_1_OFFSET         25
#define COLUMN_2_OFFSET         165

int ThumbStickScale(int stick, int max)
    {
    if(stick > 0) stick -= STICK_DEAD_ZONE;
    else stick += STICK_DEAD_ZONE;

    return (stick*max)/(32768-STICK_DEAD_ZONE);
    }


void AdjustValue(DWORD &value, DWORD min, DWORD max, XINPUT_STATE &input, DWORD maxThumbStickScale)
    {
    // UP
    if(input.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
        {
        ++value;
        if(value > max) value = max;
        }
    if(input.Gamepad.sThumbLY > STICK_DEAD_ZONE)
        {
        value += ThumbStickScale(input.Gamepad.sThumbLY, maxThumbStickScale);
        if(value > max) value = max;
        }

    // DOWN
    if(input.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN)
        {
        --value;
        if(value < min) value = min;
        if(value > max) value = min;
        }
    if(input.Gamepad.sThumbLY < -STICK_DEAD_ZONE)
        {
        value += ThumbStickScale(input.Gamepad.sThumbLY, maxThumbStickScale);
        if(value < min) value = min;
        if(value > max) value = min;
        }
    }

DWORD buttonXColor, buttonYColor, buttonAColor, buttonBColor, buttonBlkColor, buttonWhtColor;
DWORD currentSelection = 0;

void GUI(bool interactive)
    {
    bool exit = false;
    DWORD addDevice, removeDevice;
    XINPUT_STATE state;

    while(!exit)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        buttonXColor = buttonYColor = buttonAColor = buttonBColor = buttonBlkColor = buttonWhtColor = 0xFFFFFFFF;
        for(unsigned port=0; port<XGetPortCount(); port++)
            {
            if(hDuke[port])
                {
                XInputGetState(hDuke[port], &state);

                if(interactive)
                    {
                    if(state.Gamepad.wButtons & XINPUT_GAMEPAD_START) exit = true;
                    }
                else
                    {
                    if(state.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) exit = true;
                    }

                if(!interactive) continue;

                if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] > BUTTON_PRESS_VALUE)
                    {
                    buttonXColor = 0xFFFFFF00;
                    AdjustValue(chunkSizeMin, 1, chunkSizeMax, state, 16);
                    }
                if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > BUTTON_PRESS_VALUE)
                    {
                    buttonAColor = 0xFFFFFF00;
                    if(readMode == READMODE_HD)
                        AdjustValue(chunkSizeMax, chunkSizeMin, 10000, state, 16);
                    else
                        AdjustValue(chunkSizeMax, chunkSizeMin, 64, state, 16);
                    }
                if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] > BUTTON_PRESS_VALUE)
                    {
                    buttonYColor = 0xFFFFFF00;
                    AdjustValue(startLBA, 0, endLBA-1, state, 4096);
                    }
                if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > BUTTON_PRESS_VALUE)
                    {
                    buttonBColor = 0xFFFFFF00;
                    AdjustValue(endLBA, startLBA+1, (DWORD)gDiskGeometry.Cylinders.QuadPart, state, 4096);
                    }
                if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > BUTTON_PRESS_VALUE)
                    {
                    buttonBlkColor = 0xFFFFFF00;
                    AdjustValue(sequentialReads, 0, 1, state, 8);
                    }
                if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] > BUTTON_PRESS_VALUE)
                    {
                    buttonWhtColor = 0xFFFFFF00;
                    AdjustValue(readMode, 0, READMODE_MAX, state, 8);
                    }
                }
            }

        UpdateGraphics(interactive ? DISPLAYMODE_CONFIG_INTERACTIVE : DISPLAYMODE_CONFIG_READONLY);

        Sleep(BUTTON_SPEEP_VALUE);
        }

    // sleep past any residual user input presses
    Sleep(BUTTON_SPEEP_VALUE);
    buttonXColor = buttonYColor = buttonAColor = buttonBColor = buttonBlkColor = buttonWhtColor = 0xFFFFFFFF;
    }


void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...)
    {
    char szBuffer[256];

    va_list args;
    va_start(args, format);

    vsprintf(szBuffer, format, args);

    WCHAR *ptr = Ansi2UnicodeHack(szBuffer);

    g_font.DrawText(pd3ds, ptr, x, (line+1)*10, 0, color, 0);
    }


void UpdateGraphics(unsigned mode /*=DISPLAYMODE_RUN_TIME*/)
    {
    IDirect3DSurface8*	pd3ds;

    // Clear the device
    g_pDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff000000, 1.0f, 0);

    // Clear the texture
    g_pd3dtText->LockRect(0, &g_d3dlr, NULL, 0);
    for(unsigned i=0; i<240; i++)
        memset((LPBYTE)g_d3dlr.pBits + i * g_d3dlr.Pitch, 0, 320 * 4);
    g_pd3dtText->UnlockRect(0);

    // Get the surface to draw the text to
    g_pd3dtText->GetSurfaceLevel(0, &pd3ds);

    //
    // run time status mode
    //
    if(mode == DISPLAYMODE_RUN_TIME || mode == DISPLAYMODE_PAUSE)
        {
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 1, 0xFF4444FF, "Model: %s", model);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 2, 0xFF4444FF, "Serial: %s", serial);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 3, 0xFF4444FF, "Firmware: %s", firmware);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 4, 0xFF4444FF, "Media: %s", mediaTypeNames[mediaType]);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 1, 0xFF4444FF, " Cylinders: %u", gDiskGeometry.Cylinders.QuadPart);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 2, 0xFF4444FF, " Tracks/Cylinder: %u", gDiskGeometry.TracksPerCylinder);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 3, 0xFF4444FF, " Sectors/Track: %u", gDiskGeometry.SectorsPerTrack);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 4, 0xFF4444FF, " Bytes/Sector: %u", gDiskGeometry.BytesPerSector);

        unsigned line = 5;
        GraphicPrint(pd3ds, COLUMN_1_OFFSET, line, 0xFFFFFFFF, "Blocks Read: %I64u", numBlocksRead);
        GraphicPrint(pd3ds, COLUMN_2_OFFSET, line, 0xFFFFFFFF, " Run Time: %u sec", (GetTickCount() - time)/1000);

        if(sequentialReads)
            {
            if(stopAfter)
                GraphicPrint(pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Pass %u of %u", numTimesThrough, stopAfter);
            else
                GraphicPrint(pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Pass %u", numTimesThrough);
            }

        GraphicPrint(pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "Buffer Mismatches: %u", numBuffMisMatch);
        GraphicPrint(pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "2 Diff Failures: %u", numFailThenFail);
        GraphicPrint(pd3ds, COLUMN_2_OFFSET,   line, 0xFFFFFFFF, " Pass then Fail:  %u", numPassThenFail);
        GraphicPrint(pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "2 Same Failures: %u", numFailThenFailSame);
        GraphicPrint(pd3ds, COLUMN_2_OFFSET,   line, 0xFFFFFFFF, " Fail then Pass:  %u", numFailThenPass);

        if(mode == DISPLAYMODE_RUN_TIME)
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFFFF,  "Press START to view the current settings");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press Left Trigger + Right Trigger + Black to reboot");
            }
        else if(mode == DISPLAYMODE_PAUSE)
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFF00,  "PAUSED");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFF00,  "Press BACK to continue");
            }
        }

    //
    // config setup gui
    //
    else if(mode == DISPLAYMODE_CONFIG_READONLY || mode == DISPLAYMODE_CONFIG_INTERACTIVE)
        {
        DWORD color;
        if(mode == 2) color = 0xFF777777;
        else color = 0xFFFFFFFF;

	    GraphicPrint(pd3ds, COLUMN_1_OFFSET,  1, buttonXColor & color,  "X: Read Size Min: %u", chunkSizeMin);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET , 2, buttonAColor & color,  "A: Read Size Max: %u", chunkSizeMax);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 1, buttonYColor & color,  " Y: Start LBA: %u", startLBA);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 2, buttonBColor & color,  " B: End LBA: %u", endLBA);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET,  3, buttonWhtColor & color,  "White: ReadMode: %u", readMode);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 3, buttonBlkColor & color,  " Black: SequentialReads: %u", sequentialReads);


        if(mode == DISPLAYMODE_CONFIG_INTERACTIVE) // interactive
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFFFF,  "Use the DPAD or Left Thumbstick UP/DOWN to change the values");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press START to continue");
            }
        else // non interactive
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press BACK to continue");
            }
        }

    // Release the surface
    pd3ds->Release();

    // Draw the textured primitive (with the text)
    g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));

    // End the scene and present it
    g_pDevice->EndScene();
    g_pDevice->Present(NULL, NULL, NULL, NULL);
    }



bool InputCheckExitCombo(void)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > BUTTON_PRESS_VALUE)
                {
                DebugPrint("\r\n\r\nFound Exit Combo on gamepad %u - rebooting\r\n", port+1);
                return true;
                }
            }
        }

    // check for exit file
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind = FindFirstFile("T:\\dvdexit.txt", &FindFileData);
    FindClose(hFind);
    if(hFind != INVALID_HANDLE_VALUE)
        {
        DebugPrint("\r\n\r\nFound Exit File (dvdexit.txt) - rebooting\r\n");
        return true;
        }

    return false;
    }


bool InputCheckButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[button] > BUTTON_PRESS_VALUE)
                {
                return true;
                }
            }
        }

    return false;
    }


bool InputCheckDigitalButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.wButtons & button)
                {
                return true;
                }
            }
        }

    return false;
    }


void Pause(void)
    {
    DWORD addDevice, removeDevice;
    OutputDebugStringA("*****************************************************************************\n");
    OutputDebugStringA("* Entered Paused State. Hit the BACK button to resume...\n");
    OutputDebugStringA("*****************************************************************************\n");
    while(!InputCheckDigitalButton(XINPUT_GAMEPAD_BACK))
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        UpdateGraphics(DISPLAYMODE_PAUSE);

        Sleep(BUTTON_SPEEP_VALUE);
        }
    }


void InputDukeInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(remove & USBPortMasks[port])
            {
            if(hDuke[port]) XInputClose(hDuke[port]);
            hDuke[port] = NULL;
            }
        if(add & USBPortMasks[port])
            {
            hDuke[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, NULL);
            //DebugPrint("Adding Duke in Port %u\n", port+1);
            }
        }
    }


void InputMUInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned i=0; i<XGetPortCount()*2; i++)
        {
        DWORD port = i/2;
        DWORD slot = i%2==0?XDEVICE_BOTTOM_SLOT:XDEVICE_TOP_SLOT;
        if(remove & USBSlotMasks[i])
            {
            if(hSlot[i]) XUnmountMU(XMUPortFromDriveLetter((char)hSlot[i]), XMUSlotFromDriveLetter((char)hSlot[i]));
            hSlot[i] = NULL;
            }
        if(add & USBSlotMasks[i])
            {
            char drive;
            if(XMountMU(port, slot, &drive) == ERROR_SUCCESS)
                {
                hSlot[i] = (HANDLE)drive;
                //DebugPrint("Adding MU in Port %u, Slot %u\n", XMUPortFromDriveLetter((char)hSlot[i])+1, XMUSlotFromDriveLetter((char)hSlot[i])+1);
                }
            }
        }
    }


/*

Routine Description:

	Initializes the graphics

Arguments:

	None

Return Value:

	None

*/
HRESULT InitGraphics(void)
    {
    HRESULT	hr;
    D3DPRESENT_PARAMETERS d3dpp;
    int i;
    
    // Create an instance of a Direct3D8 object 
    g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
    if(g_d3d == NULL)
        return E_FAIL;
    
    // Setup the present parameters: 640x480x24
    ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth					= 640;
    d3dpp.BackBufferHeight					= 480;
    d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount					= 1;
    d3dpp.Flags								= 0;
    d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
    d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow						= NULL;
    d3dpp.Windowed							= FALSE;
    d3dpp.EnableAutoDepthStencil			= TRUE;
    d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
    d3dpp.Flags								= 0;
    d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;
    
    // Create the device
    hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDevice);
    if(FAILED(hr))
        return hr;
    
    // Create a buffer for the text
    hr = g_pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &g_pd3dtText);
    if(FAILED(hr))
        return hr;
    
    // Text plane
    g_prText[0].x = 0.0f;
    g_prText[0].y = 480.0f;
    g_prText[0].u = 0.0f;
    g_prText[0].v = 240.0f;
    g_prText[1].x = 0.0f;
    g_prText[1].y = 0.0f;
    g_prText[1].u = 0.0f;
    g_prText[1].v = 0.0f;
    g_prText[2].x = 640.0f;
    g_prText[2].y = 0.0f;
    g_prText[2].u = 320.0f;
    g_prText[2].v = 0.0f;
    g_prText[3].x = 640.0f;
    g_prText[3].y = 480.0f;
    g_prText[3].u = 320.0f;
    g_prText[3].v = 240.0f;
    
    for(i=0; i<4; i++) 
        {
        g_prText[i].z	= 0.0f;
        g_prText[i].rhw	= 1.0f;
        }
    
    // Setup stuff
    g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
    g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
    g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
    g_pDevice->SetTexture(0, g_pd3dtText);
    g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);
    
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dvdread\utils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    utils.cpp

Abstract:

    Helper functions

Notes:

*****************************************************************************/

#include "dvdread.h"

void CompareBuff(unsigned char *buff1, unsigned char *buff2, unsigned char *buff3, unsigned length)
    {
    for(unsigned i=0; i<length; i++)
        {
        if(buff1[i] != buff2[i])
            {
            DebugPrint("    %08X: %02X %02X %02X\n", i, buff1[i], buff2[i], buff3[i]);
            }
        }
    }


long GetNumber(char *string)
    {
    char *tmp;
    if((tmp = strchr(string, 'x')) != NULL)
        {
        long a=0;
        sscanf(tmp+1, "%X", &a);
        return a;
        }

    return atol(string);
    }


void PrintPreRetryError(DWORD block, SCSIError &err)
    {
    DebugPrint("Block %u: Internal Error ", block);
    err.Print();
    DebugPrint(" retrying\n");
    }


/*****************************************************************************

Routine Description:

    Ansi2UnicodeHack

    In-place Pseudo Ansi to Unicode (char to wide char) conversion.

Arguments:

    IN char* str - char string to convert to wide char string

Return Value:

    WCHAR* - pointer to Unicode string

Note:
    
    Because a bunch of Unicode functions expect a WCHAR string to be on an
    even boundry, the returned string may be moved 1 character over.

*****************************************************************************/
WCHAR* Ansi2UnicodeHack(char *str)
    {
    if(!str) return NULL;

    int align = 0;
    int len = strlen(str)+1;

    // put string on an even boundry because some freak put a bunch of ASSERTs
    // that check for even boundries in Unicode functions like 
    // RtlEqualUnicodeString()
    if(((DWORD)str & 1) != 0)
        {
        align = 1;
        }

    for(; len>=0; len--)
        {
        str[len*2+align] = str[len];
        str[len*2+align+1] = '\0';
        }

    str += align;

    return (WCHAR*)str;
    }



static char *logFilename = NULL;
static XGAME_FIND_DATA saveGameData;
void DebugPrint(char* format, ...)
    {
    char szBuffer[1024];
    DWORD err = GetLastError(); // we dont want DebugPrint to tromp on the last error

    va_list args;
    va_start(args, format);

    vsprintf(szBuffer, format, args);
    OutputDebugStringA(szBuffer);

    if(!logFilename)
        {
        HANDLE h = XFindFirstSaveGame("U:\\", &saveGameData);
        if(h == INVALID_HANDLE_VALUE)
            {
            logFilename = saveGameData.szSaveGameDirectory;
            XCreateSaveGame("U:\\", L"Test Results Log", OPEN_ALWAYS, 0, logFilename, MAX_PATH);
            strcat(logFilename, "\\dvdread.txt");
            }
        else
            {
            logFilename = saveGameData.szSaveGameDirectory;
            strcat(logFilename, "\\dvdread.txt");
            DeleteFile(logFilename); // remove old copy of file
            XFindClose(h);
            }
        }

    FILE *f = fopen(logFilename, "a+");
    if(f)
        {
        fprintf(f, "%s", szBuffer);
        fclose(f);
        }

    va_end(args);

    SetLastError(err);
    }


void HexDump(const unsigned char * buffer, DWORD length)
    {
    DWORD i, count, index;
    char digits[]="0123456789ABCDEF";
    char line[100];
    unsigned cbLine;

    for(index = 0; length; length -= count, buffer += count, index += count)
        {
        count = (length > 16) ? 16:length;

        cbLine = sprintf(line, "%08X  ", index);

        for(i=0;i<count;i++)
            {
            line[cbLine++] = digits[buffer[i] >> 4];
            line[cbLine++] = digits[buffer[i] & 0x0f];
            if(i == 7)
                {
                line[cbLine++] = ' ';
                line[cbLine++] = '|';
                line[cbLine++] = ' ';
                }
            else
                {
                line[cbLine++] = ' ';
                }
            }
        for(; i < 16; i++)
            {
            line[cbLine++] = ' ';
            line[cbLine++] = ' ';
            line[cbLine++] = ' ';
            }

        line[cbLine++] = ' ';

        for(i = 0; i < count; i++)
            {
            if(buffer[i] < 32 || buffer[i] > 126)
                {
                line[cbLine++] = '.';
                }
            else
                {
                line[cbLine++] = buffer[i];
                }
            }

        line[cbLine++] = 0;
        DebugPrint("%s\n", line);
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dvdread\dvdread.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    dvdread.h

Abstract:

    Low level disk test scanner.

Notes:
    dvd player code:
        "\xboxsrc\private\ui\dvd\library\hardware\drives\specific\xboxdvddrive.cpp"
    filesystem retry code:
        "\xboxsrc\private\ntos\idex\cdrom.c" (IdexCdRomFinishRequestSense)
    sense data format:
        "\xboxsrc\public\ddk\inc\scsi.h"


    DVD-X2 Supported Error Sense Codes
        Sense   Sense   Sense   Description
        Key	    Code    Code Qu
        ----------------------------------------------------------------------
        0x00	0x00	0x00	No Additional Sense information (= no error)
        0x01	0x80	0x00	Cache fill error, speed reduction requested
        0x02	0x04	0x00	Logical Unit not ready, cause not reported
        0x02	0x04	0x01	Logical Unit is in process of becoming ready
        0x02	0x30	0x00	Incompatible medium installed
        0x02	0x3A	0x00	Medium not present
        0x03	0x57	0x00	Unable to recover Table of Contents
        0x03	0x80	0x00	Read Error
        0x04	0x00	0x00	Hardware error
        0x04	0x08	0x03	Logical Unit Communication CRC Error - UDMA33
        0x05	0x21	0x00	Logical Block Address Out of Range
        0x05	0x55	0x00	System Resource Failure
        0x05	0x64	0x00	Illegal mode for this track
        0x05	0x6F	0x00	Authentication Failure - CSS
        0x05	0x80	0x00	Authentication Failure - Xbox
        0x05	0x81	0x00	Command error
        0x06	0x29	0x00	Power On, Reset or Bus Device Reset occurred
        0x06	0x2A	0x01	Mode Parameters changed
        0x06	0x2E	0x00	Insufficient time for operation

    Win32 Error code mapping:
        1/80:   ERROR_CRC                   23
        2/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        2/other ERROR_NOT_READY             21
        3/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        3/other ERROR_CRC                   23
        5/21:   ERROR_SECTOR_NOT_FOUND      27
        5/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        5/6F:   ERROR_TOO_MANY_SECRETS      1381
        5/80:   ERROR_TOO_MANY_SECRETS      1381
        other:  ERROR_IO_DEVICE             1117

    IOCTL_CDROM_SET_SPINDLE_SPEED
        speed 2     ~3000rpm      2x -    5x
        speed 1     ~2000rpm    4/3x - 10/3x
        speed 0     ~1000rpm    2/3x -  5/3x

    Hard Drive Partition Sizes
        \Device\Harddisk0\Partition0 19541088
        \Device\Harddisk0\Partition1  9997568
        \Device\Harddisk0\Partition2  1023840
        \Device\Harddisk0\Partition3  1535776
        \Device\Harddisk0\Partition4  1535776
        \Device\Harddisk0\Partition5  1535776

*****************************************************************************/

#ifndef _DVDREAD_H_
#define _DVDREAD_H_

#ifdef _VC
//#define DEVICE_TYPE ULONG
#define NTLEANANDMEAN
#define _X86_
#define _WIN32_WINNT 0x0500
#endif

#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <scsi.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>

#include <xtl.h>
#include <stdio.h>

#include "bitfont.h"

//
// utility functions
//
void DebugPrint(char* format, ...);
long GetNumber(char *string);

enum READ_MODES
    {
    READMODE_DETECT = 0,
    READMODE_DVD,
    READMODE_CD,
    READMODE_HD,
    READMODE_MAX
    };

struct SCSIError
    {
    DWORD win32;
    SENSE_DATA sense;

    SCSIError() {win32=0; memset(&sense, 0, sizeof(SENSE_DATA)); }
    void Print(bool full=true)
        {
        unsigned char *s = (unsigned char*)&sense;
        if(full)
            DebugPrint("(%u [<%02X> %02X <%02X> %02X%02X%02X%02X %02X %02X%02X%02X%02X <%02X> <%02X> %02X %02X%02X%02X])",
                win32, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8], s[9], s[10], s[11], s[12], s[13], s[14], s[15], s[16], s[17]);
        else
            DebugPrint("(%u [<%02X> -- <%02X> -------- -- -------- <%02X> <%02X> -- ------])",
                win32, s[0], s[2], s[12], s[13]);
        }
    };

class ErrorDistrubition
    {
    public:
        SCSIError error;
        DWORD count;
        ErrorDistrubition *next;

    public:
        ErrorDistrubition(SCSIError &e)
            {
            memcpy(&error, &e, sizeof(SCSIError));
            count = 1;
            next = NULL;
            }

        void AddError(SCSIError &e)
            {
            ErrorDistrubition *ptr = this;
            while(ptr)
                {
                if((ptr->error.sense.ErrorCode                     == e.sense.ErrorCode)           &&
                    (ptr->error.sense.Valid                        == e.sense.Valid)               &&
                    (ptr->error.sense.SenseKey                     == e.sense.SenseKey)            &&
                    (ptr->error.sense.Reserved                     == e.sense.Reserved)            &&
                    (ptr->error.sense.IncorrectLength              == e.sense.IncorrectLength)     &&
                    (ptr->error.sense.EndOfMedia                   == e.sense.EndOfMedia)          &&
                    (ptr->error.sense.FileMark                     == e.sense.FileMark)            &&
                    (ptr->error.sense.AdditionalSenseCode          == e.sense.AdditionalSenseCode) &&
                    (ptr->error.sense.AdditionalSenseCodeQualifier == e.sense.AdditionalSenseCodeQualifier))
                    {
                    ptr->count++;
                    return;
                    }
                else if(!ptr->next)
                    {
                    ptr->next = new ErrorDistrubition(e);
                    return;
                    }
                ptr = ptr->next;
                }
            }

        void RemoveError(SCSIError &e, DWORD count)
            {
            ErrorDistrubition *ptr = this;
            while(ptr)
                {
                if(memcmp(&ptr->error, &e, sizeof(SCSIError)) == 0)
                    {
                    ptr->count -= count;
                    return;
                    }
                ptr = ptr->next;
                }
            }

        void PrintErrors(void)
            {
            ErrorDistrubition *ptr = this;
            while(ptr)
                {
                DebugPrint("*** %9u Errors of ", ptr->count);
                ptr->error.Print(false);
                DebugPrint("\n");
                ptr = ptr->next;
                }
            }
    };


struct ExcludeList
    {
    DWORD lba1, lba2;
    ExcludeList *next;

    ExcludeList() { lba1=lba2=0; next=NULL; }
    ExcludeList(char *pair)
        {
        next = NULL;
        lba1 = GetNumber(pair);
        char *tmp = strchr(pair, '-');
        if(tmp) lba2 = GetNumber(tmp+1);
        else lba2 = lba1;
        }
    void Add(char *pair)
        {
        ExcludeList *ptr = this;
        while(ptr)
            {
            if(!ptr->next)
                {
                ptr->next = new ExcludeList(pair);
                return;
                }
            ptr = ptr->next;
            }
        }
    bool InList(DWORD lba, DWORD readSize)
        {
        ExcludeList *ptr = this;
        while(ptr)
            {
            if(lba+readSize >= ptr->lba1 && lba <= ptr->lba2)
                {
                return true;
                }
            ptr = ptr->next;
            }
        return false;
        }
    };





//
// Initialization calls
//
void Initialize(void);
HRESULT InitGraphics(void);

//
// User input
// 
void InputDukeInsertions(DWORD add, DWORD remove=0);
void InputMUInsertions(DWORD add, DWORD remove=0);
bool InputCheckExitCombo(void);
bool InputCheckButton(int button);
bool InputCheckDigitalButton(int button);
void Pause(void);
int ThumbStickScale(int stick, int max);
void AdjustValue(DWORD &value, DWORD min, DWORD max, XINPUT_STATE &input, DWORD maxThumbStickScale);


//
// Graphics / GUI methods
//
enum DISPLAY_MODE
    {
    DISPLAYMODE_PAUSE,
    DISPLAYMODE_RUN_TIME,
    DISPLAYMODE_CONFIG_READONLY,
    DISPLAYMODE_CONFIG_INTERACTIVE
    };
void UpdateGraphics(unsigned mode = DISPLAYMODE_RUN_TIME);
void GUI(bool interactive);
void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...);


//
// Utility functions
//
void HexDump(const unsigned char * buffer, DWORD length);
WCHAR* Ansi2UnicodeHack(char *str);
void PrintPreRetryError(DWORD block, SCSIError &err);
void CompareBuff(unsigned char *buff1, unsigned char *buff2, unsigned char *buff3, unsigned length);


//
// DVD utils
//
typedef SCSIError (*READ_FUNC)(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
SCSIError ReadDVDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
SCSIError ReadCDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
SCSIError ReadCDBlocks2(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
SCSIError ReadHDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
void SeekLBA(HANDLE hDevice, DWORD LBA);
void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware);
void ChangeSpeed(HANDLE hDevice, DWORD newSpeed);
bool CDTestReady(HANDLE hDevice);
void RequestSense(HANDLE hDevice, SCSIError &sense);
DWORD GetDiskType(HANDLE hDevice);


//
// User input
//
extern HANDLE hDuke[XGetPortCount()];
extern HANDLE hSlot[XGetPortCount()*2];
static const DWORD USBPortMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };
static const DWORD USBSlotMasks[] = {
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK
    };


//
// config settings
//
extern DWORD avgTime;
extern DISK_GEOMETRY gDiskGeometry;
extern DWORD successfulReadSectors;
extern int enableRetries;
extern DWORD spindleSpeed;
extern DWORD speedDelay0to1;
extern DWORD speedDelay1to2;
extern DWORD speedDelay2to1;
extern DWORD speedDelay1to0;
extern DWORD speedDelay0to2;
extern DWORD speedDelay2to0;
extern DWORD delayOn062E;
extern DWORD seekOn062E;
extern DWORD summaryInternalErrs;
extern ErrorDistrubition *errors;
extern DWORD lastReadTime;
extern DWORD avgTimeCount;
extern DWORD chunkSizeMin;
extern DWORD chunkSizeMax;
extern char deviceName[128];
extern DWORD readSize;
extern DWORD startLBA, endLBA ;
extern DWORD compareBuffers;
extern DWORD sequentialReads;
extern DWORD pauseOnMismatch;
extern DWORD dvdUseReadFile;
extern DWORD readMode;
extern DWORD stopAfter;
extern DWORD numberOfReads;
extern ExcludeList *exclude;
extern DWORD requestSense;
extern DWORD launchGUI;
extern DWORD avgSpan;
extern DWORD defaultSpeed;
extern DWORD seed;
extern DWORD mediaType;

//
// stats
//
extern DWORD numFailThenFail;
extern DWORD numFailThenFailSame;
extern DWORD numFailThenPass;
extern DWORD numPassThenFail;
extern DWORD numBuffMisMatch;
extern unsigned __int64 numBlocksRead;
extern DWORD time;
extern char model[64], serial[64], firmware[64];
extern DWORD numTimesThrough;

//
// graphics
//
extern IDirect3D8*		    g_d3d;
extern IDirect3DDevice8*	g_pDevice;
extern BitFont				g_font;
extern IDirect3DTexture8*	g_pd3dtText;
extern TVertex				g_prText[4];
extern D3DLOCKED_RECT		g_d3dlr;




//
// Low level IOCTL stuff
//
#define CTL_CODE(DeviceType, Function, Method, Access) ( \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) )

#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_CONTROLLER          0x00000004

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

#define FILE_ANY_ACCESS                 0

#define IOCTL_DVD_BASE                  FILE_DEVICE_DVD
#define IOCTL_DVD_START_SESSION         CTL_CODE(IOCTL_DVD_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_READ_KEY              CTL_CODE(IOCTL_DVD_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SEND_KEY              CTL_CODE(IOCTL_DVD_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_END_SESSION           CTL_CODE(IOCTL_DVD_BASE, 0x0403, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SET_READ_AHEAD        CTL_CODE(IOCTL_DVD_BASE, 0x0404, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_GET_REGION            CTL_CODE(IOCTL_DVD_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SEND_KEY2             CTL_CODE(IOCTL_DVD_BASE, 0x0406, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DVD_READ_STRUCTURE        CTL_CODE(IOCTL_DVD_BASE, 0x0450, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_BASE                FILE_DEVICE_CD_ROM
#define IOCTL_CDROM_GET_DRIVE_GEOMETRY  CTL_CODE(IOCTL_CDROM_BASE, 0x0013, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_SET_SPINDLE_SPEED   CTL_CODE(IOCTL_CDROM_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_CHECK_VERIFY        CTL_CODE(IOCTL_CDROM_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_SCSI_BASE                 FILE_DEVICE_CONTROLLER
#define IOCTL_SCSI_PASS_THROUGH_DIRECT  CTL_CODE(IOCTL_SCSI_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
//#define IOCTL_IDE_PASS_THROUGH          CTL_CODE(IOCTL_SCSI_BASE, 0x040a, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define CDAUDIO_BYTES_PER_FRAME         2352
#define CDAUDIO_BYTES_PER_SECOND        176400
#define CDAUDIO_BYTES_PER_MINUTE        10584000
#define CDAUDIO_FRAMES_PER_SECOND       75
#define CDAUDIO_FRAMES_PER_MINUTE       4500
#define CDAUDIO_SECTOR_OFFSET           150

// from private\ntos\idex\idex.h:
#define IDE_ATAPI_RAW_CD_SECTOR_SIZE            2352
#define IDE_ATAPI_CD_SECTOR_SHIFT               11


#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

enum MEDIA_TYPES
	{
	MEDIA_UNKNOWN,
	MEDIA_CDDA,
	MEDIA_CDROM,
	MEDIA_DVD_5_RO,
	MEDIA_DVD_5_RW,
	MEDIA_DVD_9_RO,
	MEDIA_DVD_9_RW,
	MEDIA_HD
	};

static const char *mediaTypeNames[] = 
    {
    "Unknown",
    "CD DA",
    "CD ROM",
    "DVD 5 RO",
    "DVD 5 RW",
    "DVD 9 RO",
    "DVD 9 RW",
    "Hard Disk"
    };

#endif //_DVDREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\conio.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    conio.cpp

Description:

    Console and text output functions.

*******************************************************************************/

#define _DXCONIO_EXPORT_
#define DXCONIO_NO_OVERRIDES

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#include <xboxverp.h>
#endif // UNDER_XBOX
#include <stdio.h>
#include <tchar.h>
#include <d3dx8.h>
#ifdef UNDER_XBOX
#include <xgraphics.h>
#endif
#include "d3dinit.h"
#include "fontmap.h"
#include "main.h"
#include "noise.h"
#include "texture.h"
#include "util.h"
#include "vrttypes.h"
#include "conio.h"
#include "dxconio.h"

#ifdef UNDER_XBOX
#define DEMO_HACK
#endif

#define TV_ALIGNED

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#define TAB_LENGTH          8

#ifndef TV_ALIGNED
#define BORDER_LEFT         10.0f
#define BORDER_RIGHT        10.0f
#define BORDER_TOP          0.0f
#define BORDER_BOTTOM       0.0f
#else
#define BORDER_LEFT         25.0f
#define BORDER_RIGHT        25.0f
#define BORDER_TOP          15.0f
#define BORDER_BOTTOM       15.0f
#endif

#define SHADOW_OFFSET_X     4.0f
#define SHADOW_OFFSET_Y     4.0f
#define SHADOW_INTENSITY    191.0f

#define BACKTEX_WIDTH       256
#define BACKTEX_HEIGHT      256

#define MAX_TEXTOUT_LENGTH  256

#define POS_BLANK           -3.402823466e+36F

//******************************************************************************
// Globals
//******************************************************************************

namespace DXCONIO {

extern BOOL                 g_bInitialized;

// Console text output buffer
LPSTR                       g_pchOut = NULL;
UINT                        g_uOutSize = 4096;
UINT                        g_uOutHead = 0;
UINT                        g_uOutTail = 0;
#ifndef TV_ALIGNED
UINT                        g_uOutWidth = 77;
#else
UINT                        g_uOutWidth = 71;
#endif

// Console text vertex layout
UINT                        g_uTextSize = 0;
UINT                        g_uTextHead = 0;
UINT                        g_uTextTail = 0;
UINT                        g_uTextLine = 0;
UINT                        g_uTextHeight = 1;
UINT                        g_uTextCol = 0;
UINT                        g_uTextCursor = 0;
float                       g_fTextX;

// Visible console text vertices
UINT                        g_uVStart1;
UINT                        g_uVStart2;
UINT                        g_uVCount1;
UINT                        g_uVCount2;

// xTextOut vertices
PTLVERTEX                   g_prTextOut = NULL;
LPWORD                      g_pwTextOut = NULL;

// Console vertices
LPDIRECT3DVERTEXBUFFER8     g_pd3drPosition = NULL;
UINT                        g_uVBPositionSize;
LPDIRECT3DVERTEXBUFFER8     g_pd3drTexCoord = NULL;
UINT                        g_uVBTexCoordSize;
LPDIRECT3DINDEXBUFFER8      g_pd3diText = NULL;
UINT                        g_uIBTextSize;
// ##DELETE
LPDIRECT3DVERTEXBUFFER8     g_pd3drDeleteMe = NULL;
UINT                        g_uVBDeleteMeSize;
// ##END DELETE

// Console background
LPDIRECT3DVERTEXBUFFER8     g_pd3drBack = NULL;
LPDIRECT3DTEXTURE8          g_pd3dtBackBase = NULL;
LPDIRECT3DTEXTURE8          g_pd3dtBackBump = NULL;
LPDIRECT3DTEXTURE8          g_pd3dtBackEnv = NULL;
CPerlinNoise2D*             g_pNoise = NULL;

// Console state
float                       g_fCharWidth = 8.0f;
float                       g_fCharHeight = 15.0f; //(CHAR_ASPECT * g_fCharWidth);
DWORD                       g_dwTextColor = 0xFFFFFFFF;
DWORD                       g_dwBackgroundColor = 0xBFA4A400;
//DWORD                       g_dwBackgroundColor = 0xBF44FF44;
TCHAR                       g_szBackImage[MAX_PATH] = {0};
BOOL                        g_bUseBackground = TRUE;
BOOL                        g_bInScene = FALSE;

// Device information
BOOL                        g_bAttached;
float                       g_fTargetWidth;
float                       g_fTargetHeight;
ADAPTERDESC                 g_adpd;
DEVICEDESC                  g_devd;
DISPLAYMODE                 g_dm;

// Console scrolling
D3DVECTOR                   g_vTranslate;

float                       g_fMaxRowScroll = 0.0f;
float                       g_fMaxColScroll = 0.0f;
float                       g_fCurrentRow = 0.0f;
float                       g_fCurrentCol = 0.0f;

// Serial access to dxconio functions
CRITICAL_SECTION            g_csConsoleLock;

//******************************************************************************
// Function prototypes
//******************************************************************************

void                        PutStringA(LPCSTR pszString);
void                        PutStringW(LPCWSTR pszString);

BOOL                        InitConsole();
void                        EffaceConsole();

static void                 UpdateConsole(UINT uStart);
static void                 RefreshConsole();
static void                 DrawConsole();

static BOOL                 UpdateVisibility();

static BOOL                 CreateGeometry(UINT uNumChars);
static void                 ReleaseGeometry();

static BOOL                 SetBackgroundImage(LPCTSTR pszImage);

static void                 UpdateConsoleScrollY();

static BOOL                 GetDeviceInfo();

static BOOL                 BeginConsoleScene();
static void                 EndConsoleScene();
static void                 DrawConsoleBackground();
static void                 DrawConsoleText();

static void                 DrawTextQuads(LPCSTR szText, UINT uCount, float fX, 
                                float fY, float fHeight, float fWidth, 
                                D3DCOLOR c, float fLeftMargin);

BOOL                        ValidateDisplay(LPDIRECT3D8 pd3d, 
                                    D3DCAPS8* pd3dcaps, D3DDISPLAYMODE* pd3ddm);

inline void                 LockConsole() { EnterCriticalSection(&g_csConsoleLock); }
inline void                 UnlockConsole() { LeaveCriticalSection(&g_csConsoleLock); }

} // namespace DXCONIO

using namespace DXCONIO;

//******************************************************************************
// Startup and shutdown routines
//******************************************************************************

#ifdef UNDER_XBOX

#ifdef __cplusplus
extern "C" {
#endif

// Initialize startup and shutdown routines with the CRT
#pragma data_seg(".CRT$XIU")
PROC dxconio_startup = (PROC)ConsoleStartup;
#pragma data_seg()

#pragma data_seg(".CRT$XTU")
PROC dxconio_shutdown = (PROC)ConsoleShutdown;
#pragma data_seg()

#ifdef __cplusplus
}
#endif

#endif // UNDER_XBOX

//******************************************************************************
// Console management functions
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     LoadConsole
//
// Description:
//
//     Create a heap for the console and allocate a buffer to contain the
//     output stream.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     0 on success, 1 on failure.
//
//******************************************************************************
BOOL LoadConsole() {

#ifndef UNDER_XBOX
    OSVERSIONINFO osvi;
#else
//    extern PULONG NtBuildVersion
#endif

    // Create a heap for the application
    if (!CreateHeap()) {
        return 1;
    }

    // Initialize the critical section
    InitializeCriticalSection(&g_csConsoleLock);

    g_uOutHead = 0;
    g_uOutTail = 0;

    // Allocate a buffer for the output stream
    g_pchOut = (LPSTR)MemAlloc(g_uOutSize);
    if (!g_pchOut) {
        xReleaseConsole();
        return 1;
    }

#ifndef UNDER_XBOX
    memset(&osvi, 0, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osvi);

    xprintf("Microsoft Xbox OS [Version %d.%02d.%04d]\n", 
            osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber);
#else
//    xprintf("Microsoft Xbox OS [Version %08x]\n", *NtBuildVersion);
    xprintf("Microsoft Xbox OS [Version %02d.%02d.%04d.%02d]\n", VER_PRODUCTVERSION);
#endif // UNDER_XBOX

    xputs("(C) Copyright 1999-2000 Microsoft Corp.\n");

    return 0;
}

//******************************************************************************
//
// Function:
//
//     UnloadConsole
//
// Description:
//
//     Free the console output buffer and release the heap.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void UnloadConsole() {

    if (g_pchOut) {
        MemFree(g_pchOut);
        g_pchOut = NULL;
    }

    // Release the critical section
    DeleteCriticalSection(&g_csConsoleLock);

    // Release the heap
    ReleaseHeap();
}

//******************************************************************************
//
// Function:
//
//     xCreateConsole
//
// Description:
//
//     Create all Direct3D and related objects necessary for rendering the
//     console output stream to the screen.
//
// Arguments:
//
//     LPVOID pvDevice          - Pointer to the Direct3DDevice object used
//                                by the application.  If no device is
//                                specified, the console will create and
//                                manage the device and other Direct3D objects
//                                for the application
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL DXCIOAPI xCreateConsole(LPVOID pvDevice) {

    D3DCREATIONDESC d3dcd;
    WORD            i, j, k;
    HRESULT         hr;

    LockConsole();

    xReleaseConsole();

    // Create a perlin noise object
    g_pNoise = new CPerlinNoise2D(0.5f, 5, GetTickCount(), INTERPOLATE_COSINE, FALSE, FALSE);
    if (!g_pNoise) {
        UnlockConsole();
        return FALSE;
    }

    g_uTextHead = 0;
    g_uTextTail = 0;
    g_uTextLine = 0;
    g_uTextHeight = 1;
    g_uTextCol = 0;
    g_uTextCursor = 0;
    g_fTextX = 0.0f;

    if (pvDevice) {

        g_bAttached = TRUE;
        g_pd3dDevice = (LPDIRECT3DDEVICE8)pvDevice;
        g_pd3dDevice->AddRef();

        // Get the Direct3D interface
        hr = g_pd3dDevice->GetDirect3D(&g_pd3d);
        if (FAILED(hr)) {
            ResultFailed(hr, TEXT("IDirect3DDevice8::GetDirect3D"));
            xReleaseConsole();
            UnlockConsole();
            return FALSE;
        }

        if (!GetDeviceInfo()) {
            xReleaseConsole();
            UnlockConsole();
            return FALSE;
        }
    }

    else {

        D3DMATRIX mProj;

        g_bAttached = FALSE;

        // Set the validation procedure for the device
        InitCheckDisplayProc(ValidateDisplay);

        // Initialize creation parameters
        memset(&d3dcd, 0, sizeof(D3DCREATIONDESC));
        d3dcd.d3ddt = D3DDEVTYPE_HAL;
        d3dcd.bWindowed = FALSE;
        d3dcd.d3ddm.Width = 640;
        d3dcd.d3ddm.Height = 480;
        d3dcd.d3ddm.Format = D3DFMT_LIN_X8R8G8B8;
        d3dcd.d3ddm.RefreshRate = 0;
//        d3dcd.d3ddm.Format = D3DFMT_UNKNOWN_C5;
//        SetRect(&d3dcd.rectWnd, 20, 20, 320, 320);
        d3dcd.bDepthBuffer = FALSE;
//        d3dcd.fmtd = D3DFMT_UNKNOWN_D16;
        d3dcd.bAntialias = FALSE;

        // Initialize Direct3D
        if (!CreateDirect3D(&d3dcd)) {
            xReleaseConsole();
            UnlockConsole();
            return FALSE;
        }

        // Set device initialization functions
        InitSetDeviceProc(InitConsole);
        InitClearDeviceProc(EffaceConsole);

        // Initialize transformation matrices
        SetPerspectiveProjection(&mProj, g_cam.fNearPlane, g_cam.fFarPlane, 
                g_cam.fFieldOfView, (float)g_d3dsdBack.Height / (float)g_d3dsdBack.Width);

        hr = g_pd3dDevice->SetTransform(D3DTS_PROJECTION, &mProj);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTransform"))) {
            UnlockConsole();
            return FALSE;
        }
    }

    // Initialize the device objects for the console
    if (!InitConsole()) {
        xReleaseConsole();
        UnlockConsole();
        return FALSE;
    }

    // Allocate memory for the xTextOut vertices
    g_prTextOut = (PTLVERTEX)MemAlloc32(MAX_TEXTOUT_LENGTH * 2 * 4 * sizeof(TLVERTEX));
    if (!g_prTextOut) {
        xReleaseConsole();
        UnlockConsole();
        return FALSE;
    }
    memset(g_prTextOut, 0, MAX_TEXTOUT_LENGTH * 2 * 4 * sizeof(TLVERTEX));
    for (i = 0; i < MAX_TEXTOUT_LENGTH * 2 * 4; i++) {
        g_prTextOut[i].vPosition.z = 0.00001f;
        g_prTextOut[i].fRHW = 100000.0f;
    }

    // Allocate memory for the xTextOut indices
    g_pwTextOut = (LPWORD)MemAlloc32(MAX_TEXTOUT_LENGTH * 6 * sizeof(WORD));
    if (!g_pwTextOut) {
        xReleaseConsole();
        UnlockConsole();
        return FALSE;
    }

    // Initialize the xTextOut indices
    for (i = 0, j = 0, k = 0; i < MAX_TEXTOUT_LENGTH; i++, j += 4, k += 6) {
        g_pwTextOut[k]   = j;
        g_pwTextOut[k+1] = j + 2;
        g_pwTextOut[k+2] = j + 1;
        g_pwTextOut[k+3] = j + 1;
        g_pwTextOut[k+4] = j + 2;
        g_pwTextOut[k+5] = j + 3;
    }

    g_bInitialized = TRUE;

    RefreshConsole();

    UnlockConsole();

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     xReleaseConsole
//
// Description:
//
//     Release all Direct3D and related objects created by the console.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void DXCIOAPI xReleaseConsole() {

    LockConsole();

    EffaceConsole();

    if (g_bAttached) {
        if (g_pd3d) {
            g_pd3d->Release();
            g_pd3d = NULL;
        }
        if (g_pd3dDevice) {
            g_pd3dDevice->Release();
            g_pd3dDevice = NULL;
        }
    }
    else {
        ReleaseDirect3D();
    }

    if (g_pNoise) {
        delete g_pNoise;
        g_pNoise = NULL;
    }

    g_bInitialized = FALSE;

    UnlockConsole();
}

//******************************************************************************
//
// Function:
//
//     xClearScreen
//
// Description:
//
//     Clear the console output stream buffer of its contents.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void DXCIOAPI xClearScreen(void) {

    LockConsole();

    g_uOutHead = 0;
    g_uOutTail = 0;

    if (g_bInitialized) {

        g_fCurrentRow = 0.0f;
        g_fCurrentCol = 0.0f;

        RefreshConsole();
    }

    UnlockConsole();
}

//******************************************************************************
//
// Function:
//
//     xSetFontA
//
// Description:
//
//     Set the width, height, and typeface of the characters used in outputting 
//     the console text.
//
// Arguments:
//
//     float fWidth             - Width of a console character in pixels
//
//     float fHeight            - Height of a console character in pixels
//
//     LPCSTR pszFace           - Typeface of a console character
//
// Return Value:
//
//     None.
//
//******************************************************************************
void DXCIOAPI xSetFontA(float fWidth, float fHeight, LPCSTR pszFace) {

    LockConsole();

    g_fCharWidth = fWidth;
    g_fCharHeight = fHeight;
    if (g_bInitialized) {
        xResetConsole();
    }

    UnlockConsole();
}

//******************************************************************************
//
// Function:
//
//     xSetFontW
//
// Description:
//
//     Set the width, height, and typeface of the characters used in outputting 
//     the console text.
//
// Arguments:
//
//     float fWidth             - Width of a console character in pixels
//
//     float fHeight            - Height of a console character in pixels
//
//     LPCWSTR pszFace          - Typeface of a console character
//
// Return Value:
//
//     None.
//
//******************************************************************************
void DXCIOAPI xSetFontW(float fWidth, float fHeight, LPCWSTR pszFace) {

    LockConsole();

    g_fCharWidth = fWidth;
    g_fCharHeight = fHeight;
    if (g_bInitialized) {
        xResetConsole();
    }

    UnlockConsole();
}

//******************************************************************************
//
// Function:
//
//     xSetTextColor
//
// Description:
//
//     Set the color of the console text.
//
// Arguments:
//
//     BYTE red                 - Red intensity of the text color
//
//     BYTE green               - Green intensity of the text color
//
//     BYTE blue                - Blue intensity of the text color
//
//     BYTE alpha               - Alpha intensity of the text color (where
//                                0 indicates transparent and 255 indicates
//                                opaque)
//
// Return Value:
//
//     The old color of the console text.
//
//******************************************************************************
XCOLOR DXCIOAPI xSetTextColor(BYTE red, BYTE green, BYTE blue, BYTE alpha) {

    DWORD dwColor;

    LockConsole();

    dwColor = g_dwTextColor;
    g_dwTextColor = RGBA_MAKE(red, green, blue, alpha);
    if (g_bInitialized && !g_bAttached) {
        DrawConsole();
    }

    UnlockConsole();

    return dwColor;
}

//******************************************************************************
//
// Function:
//
//     xSetBackgroundColor
//
// Description:
//
//     Set the background color of the console.  If a background texture has
//     been specified, the background color will be modulated with it.
//
// Arguments:
//
//     BYTE red                 - Red intensity of the background color
//
//     BYTE green               - Green intensity of the background color
//
//     BYTE blue                - Blue intensity of the background color
//
//     BYTE alpha               - Alpha intensity of the background color (where
//                                0 indicates transparent and 255 indicates
//                                opaque).  This value will be ignored if
//                                the console is managing Direct3D
//
// Return Value:
//
//     The old background color of the console.
//
//******************************************************************************
XCOLOR DXCIOAPI xSetBackgroundColor(BYTE red, BYTE green, BYTE blue, BYTE alpha) {

    PTLBVERTEX prBack;
    DWORD      dwColor;
    UINT       i;
    HRESULT    hr;

    LockConsole();

    if (!g_bAttached) {
        alpha = 255;
    }

    dwColor = g_dwBackgroundColor;
    g_dwBackgroundColor = RGBA_MAKE(red, green, blue, alpha);

    if (g_bInitialized) {

        if (g_pd3drBack) {

            hr = g_pd3drBack->Lock(0, 4 * sizeof(TLBVERTEX), (LPBYTE*)&prBack, 0);
            if (SUCCEEDED(hr)) {
                for (i = 0; i < 4; i++) {
                    prBack[i].cDiffuse = g_dwBackgroundColor;
                }
                g_pd3drBack->Unlock();
            }
        }

        if (!g_bAttached) {
            DrawConsole();
        }
    }

    UnlockConsole();

    return dwColor;
}

//******************************************************************************
//
// Function:
//
//     xSetBackgroundImageA
//
// Description:
//
//     Set the background texture for the console.
//
// Arguments:
//
//     LPCSTR pszImage          - A string containing the file or resource
//                                name of the image to use as the background
//                                texture.  If set to NULL, the current
//                                background texture will be released and
//                                no background texture will be used
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL DXCIOAPI xSetBackgroundImageA(LPCSTR pszImage) {

    BOOL bRet;

    LockConsole();

    if (!pszImage) {
        bRet = SetBackgroundImage(NULL);
    }
    else {
#ifndef UNICODE
        bRet = SetBackgroundImage(pszImage);
#else
        WCHAR wszImage[MAX_PATH];
        mbstowcs(wszImage, pszImage, MAX_PATH);
        bRet = SetBackgroundImage(wszImage);
#endif // !UNICODE
    }

    UnlockConsole();

    return bRet;
}

//******************************************************************************
//
// Function:
//
//     xSetBackgroundImageW
//
// Description:
//
//     Set the background texture for the console.
//
// Arguments:
//
//     LPCWSTR pszImage         - A string containing the file or resource
//                                name of the image to use as the background
//                                texture.  If set to NULL, the current
//                                background texture will be released and
//                                no background texture will be used
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL DXCIOAPI xSetBackgroundImageW(LPCWSTR pszImage) {

    BOOL bRet;

    LockConsole();

    if (!pszImage) {
        bRet = SetBackgroundImage(NULL);
    }
    else {
#ifndef UNICODE
        char szImage[MAX_PATH];
        wcstombs(szImage, pszImage, MAX_PATH);
        bRet = SetBackgroundImage(szImage);
#else
        bRet = SetBackgroundImage(pszImage);
#endif // !UNICODE
    }

    UnlockConsole();

    return bRet;
}

namespace DXCONIO {

//******************************************************************************
//
// Function:
//
//     SetBackgroundImage
//
// Description:
//
//     Set the background texture for the console.
//
// Arguments:
//
//     LPCTSTR pszImage         - A string containing the file or resource
//                                name of the image to use as the background
//                                texture.  If set to NULL, the current
//                                background texture will be released and
//                                no background texture will be used
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL SetBackgroundImage(LPCTSTR pszImage) {

    LPDIRECT3DTEXTURE8 pd3dt = NULL;

    if (!pszImage) {
        g_bUseBackground = FALSE;
    }
    else {
        _tcscpy(g_szBackImage, pszImage);
    }

    if (!g_bInitialized) {
        return TRUE;
    }

    if (pszImage) {

        pd3dt = (LPDIRECT3DTEXTURE8)CreateTexture(pszImage, D3DFMT_A8R8G8B8, TTYPE_TEXTURE);
        if (!pd3dt) {
            return FALSE;
        }
        g_bUseBackground = TRUE;
    }

    if (!pszImage || pd3dt) {
        if (g_pd3dtBackEnv) {
            ReleaseTexture(g_pd3dtBackEnv);
            g_pd3dtBackEnv = NULL;
        }
        if (g_pd3dtBackBump) {
            ReleaseTexture(g_pd3dtBackBump);
            g_pd3dtBackBump = NULL;
        }
        if (g_pd3dtBackBase) {
            ReleaseTexture(g_pd3dtBackBase);
            g_pd3dtBackBase = NULL;
        }
        g_pd3dtBackBase = pd3dt;
    }

    if (!g_bAttached) {
        DrawConsole();
    }

    return TRUE;
}

} // namespace DXCONIO

//******************************************************************************
//
// Function:
//
//     xScrollConsole
//
// Description:
//
//     Scroll the console according to the scroll flag(s) specified.
//
// Arguments:
//
//     DWORD dwScroll           - Scrolling flags that indicate the direction
//                                and amount to scroll the console
//
//     float* pfHorz            - Pointer to a floating point value indicating 
//                                the amount to scroll the console horizontally
//                                in pixels if the XSCROLL_HORZ flag has been 
//                                specified.  On return, this value will contain 
//                                the horizontal amount the console has been 
//                                scrolled.
//
//     float* pfVert            - Pointer to a floating point value indicating 
//                                the amount to scroll the console vertically
//                                in pixels if the XSCROLL_VERT flag has been 
//                                specified.  On return, this value will contain 
//                                the vertical amount the console has been 
//                                scrolled.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void DXCIOAPI xScrollConsole(DWORD dwScroll, float* pfHorz, float* pfVert) {

    float fX = 0.0f, 
          fY = 0.0f;

    if (!g_bInitialized) {
        return;
    }

    LockConsole();

    if (dwScroll & XSCROLL_LINEUP) {
        fY -= 1.0f;
    }
    if (dwScroll & XSCROLL_LINEDOWN) {
        fY += 1.0f;
    }
    if (dwScroll & XSCROLL_LINELEFT) {
        fX -= 1.0f;
    }
    if (dwScroll & XSCROLL_LINERIGHT) {
        fX += 1.0f;
    }
    if (dwScroll & XSCROLL_PAGEUP) {
        fY -= (g_fTargetHeight - BORDER_TOP - BORDER_BOTTOM) / g_fCharHeight - 1.0f;
    }
    if (dwScroll & XSCROLL_PAGEDOWN) {
        fY += (g_fTargetHeight - BORDER_TOP - BORDER_BOTTOM) / g_fCharHeight - 1.0f;
    }
    if (dwScroll & XSCROLL_PAGELEFT) {
        fX -= (g_fTargetWidth - BORDER_LEFT - BORDER_RIGHT) / g_fCharWidth;
    }
    if (dwScroll & XSCROLL_PAGERIGHT) {
        fX += (g_fTargetWidth - BORDER_LEFT - BORDER_RIGHT) / g_fCharWidth;
    }
    if (dwScroll & XSCROLL_HORZ && pfHorz) {
        fX += *pfHorz;
    }
    if (dwScroll & XSCROLL_VERT && pfVert) {
        fY += *pfVert;
    }

    fX = (float)(int)(fX * 100.0f) / 100.0f;
    fY = (float)(int)(fY * 100.0f) / 100.0f;

    if (g_fMaxColScroll > 0.0f) {

        if (dwScroll & XSCROLL_LEFT) {
            g_fCurrentCol = 0.0f;
        }
        else if (dwScroll & XSCROLL_RIGHT) {
            g_fCurrentCol = g_fMaxColScroll;
        }
        else {
            g_fCurrentCol += fX;

            if (g_fCurrentCol < 0.0f) {
                g_fCurrentCol = 0.0f;
            }
            else if (g_fCurrentCol > g_fMaxColScroll) {
                g_fCurrentCol = g_fMaxColScroll;
            }
        }

        g_vTranslate.x = BORDER_LEFT - g_fCurrentCol * g_fCharWidth;
    }

    if (g_fMaxRowScroll > 0.0f) {

        if (dwScroll & XSCROLL_TOP) {
            g_fCurrentRow = g_fMaxRowScroll;
        }
        else if (dwScroll & XSCROLL_BOTTOM) {
            g_fCurrentRow = 0.0f;
        }
        else {
            g_fCurrentRow -= fY;
        }

        UpdateConsoleScrollY();

        UpdateVisibility();
    }

    if (!g_bAttached) {
        DrawConsole();
    }

    if (pfHorz) {
        *pfHorz = g_fCurrentCol;
    }
    if (pfVert) {
        *pfVert = g_fMaxRowScroll - g_fCurrentRow;
    }

    UnlockConsole();
}

namespace DXCONIO {

//******************************************************************************
//
// Function:
//
//     UpdateConsoleScrollY
//
// Description:
//
//     Update the vertical translation value for the console.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void UpdateConsoleScrollY() {

    if (g_fCurrentRow < 0.0f) {
        g_fCurrentRow = 0.0f;
    }
    else if (g_fMaxRowScroll > 0.0f && g_fCurrentRow > g_fMaxRowScroll) {
        g_fCurrentRow = g_fMaxRowScroll;
    }

    if (g_fMaxRowScroll <= 0.0f) {
        g_vTranslate.y = g_fTargetHeight - BORDER_BOTTOM + g_fMaxRowScroll * g_fCharHeight;
    }
    else {
        g_vTranslate.y = g_fTargetHeight - BORDER_BOTTOM + g_fCurrentRow * g_fCharHeight;
    }
}

} // namespace DXCONIO

//******************************************************************************
//
// Function:
//
//     xSetOutputBufferSize
//
// Description:
//
//     Set the size of the console output stream buffer.
//
// Arguments:
//
//     UINT uBytes              - Size of the output stream buffer in bytes
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL DXCIOAPI xSetOutputBufferSize(UINT uBytes) {

    LPDIRECT3DVERTEXBUFFER8 pd3drPos;
    LPDIRECT3DVERTEXBUFFER8 pd3drTC;
    LPDIRECT3DINDEXBUFFER8  pd3diText;
    LPSTR                   pchNewOut;

    if (uBytes > 10922) {
        DebugString(TEXT("xSetOutputBufferSize: DXCONIO does not support buffer sizes > 10922")); // Limited by 16 bit index buffers
        return FALSE;
    }

    LockConsole();

    pchNewOut = (LPSTR)MemAlloc(uBytes);
    if (!pchNewOut) {
        UnlockConsole();
        return FALSE;
    }

    if (g_bInitialized) {

        pd3drPos = g_pd3drPosition;
        pd3drTC = g_pd3drTexCoord;
        pd3diText = g_pd3diText;

        pd3drPos->AddRef();
        pd3drTC->AddRef();
        pd3diText->AddRef();
        ReleaseGeometry();

        if (!CreateGeometry(uBytes)) {
            MemFree(pchNewOut);
            g_pd3drPosition = pd3drPos;
            g_pd3drTexCoord = pd3drTC;
            g_pd3diText = pd3diText;
            UnlockConsole();
            return FALSE;
        }
    }

    xClearScreen();

    if (g_pchOut) {
        MemFree(g_pchOut);
    }

    if (g_bInitialized) {    
        pd3drPos->Release();
        pd3drTC->Release();
        pd3diText->Release();
    }

    g_pchOut = pchNewOut;
    g_uOutSize = uBytes;

    UnlockConsole();

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     xSetDisplayWidth
//
// Description:
//
//     Set the width of the console display, in characters.  This width will
//     determine how long a line of console text can be before it is wrapped
//     to the next line.
//
// Arguments:
//
//     UINT uWidth              - Width of the console in characters
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL DXCIOAPI xSetDisplayWidth(UINT uWidth) {

    if (uWidth == 0) {
        return FALSE;
    }

    LockConsole();

    xClearScreen();

    if (g_bInitialized) {
        g_fMaxColScroll = (float)uWidth - ((g_fTargetWidth - BORDER_LEFT - BORDER_RIGHT) / g_fCharWidth);
    }

    g_uOutWidth = uWidth;

    UnlockConsole();

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     xDisplayConsole
//
// Description:
//
//     Draw the console on the screen.  If the console manages Direct3D and
//     text has been drawn to the frame buffer using xTextOut, the console
//     will be overlayed in the scene and the frame buffer will be presented.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void DXCIOAPI xDisplayConsole(void) {

    LockConsole();

    if (g_bAttached) {
        DrawConsole();
    }
    else {
        if (!g_bInScene) {
            DrawConsole();
        }
        else {
            DrawConsoleText();
            EndConsoleScene();
        }
    }

    UnlockConsole();
}

//******************************************************************************
//
// Function:
//
//     xResetConsole
//
// Description:
//
//     Reset the console in response to a device loss or change.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL DXCIOAPI xResetConsole(void) {

    LockConsole();

    EffaceConsole();

    if (!g_bAttached) {
        if (!RestoreDisplay()) {
            UnlockConsole();
            return FALSE;
        }
    }

    if (!InitConsole()) {
        UnlockConsole();
        return FALSE;
    }

    RefreshConsole();

    UnlockConsole();

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     xTextOutA
//
// Description:
//
//     Draw the given text string on the frame buffer.
//
// Arguments:
//
//     float fXStart            - x screen coordinate of the upper left corner 
//                                of the start of the string
//
//     float fYStart            - y screen coordinate of the upper left corner
//                                of the start of the string
//
//     float fCWidth            - Width in pixels of the characters to be used
//                                to display the string
//
//     float fCHeight           - Height in pixels of the characters to be used
//                                to display the string
//
//     XCOLOR xcColor           - Text color used to display the string
//
//     LPCSTR pszString         - String to output on the screen
//
//     UINT uCount              - Number of characters in the string
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL DXCIOAPI xTextOutA(float fXStart, float fYStart, float fCWidth, 
                        float fCHeight, XCOLOR xcColor, LPCSTR pszString, 
                        UINT uCount)
{
    LPDIRECT3DBASETEXTURE8  pd3dt;
    LPDIRECT3DVERTEXBUFFER8 pd3dr;
    LPDIRECT3DINDEXBUFFER8  pd3di;
    UINT                    uStride;
    UINT                    uBaseIndex;
    DWORD                   dwSrcBlend, dwDstBlend, dwAlphaBlend, dwColorOp0, 
                            dwColorOp1, dwAlphaOp0, dwColorArg1, dwColorArg2, 
                            dwAlphaArg1, dwAlphaArg2, dwAlphaTest, dwShader;

    if (!g_bInitialized) {
        return FALSE;
    }

    LockConsole();

    if (g_bAttached) {

        // Save the device state
        g_pd3dDevice->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlend);
        g_pd3dDevice->GetRenderState(D3DRS_DESTBLEND, &dwDstBlend);
        g_pd3dDevice->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlphaBlend);
        g_pd3dDevice->GetRenderState(D3DRS_ALPHATESTENABLE, &dwAlphaTest);
        g_pd3dDevice->GetTextureStageState(0, D3DTSS_COLOROP, &dwColorOp0);
        g_pd3dDevice->GetTextureStageState(0, D3DTSS_COLORARG1, &dwColorArg1);
        g_pd3dDevice->GetTextureStageState(0, D3DTSS_COLORARG2, &dwColorArg2);
        g_pd3dDevice->GetTextureStageState(0, D3DTSS_ALPHAOP, &dwAlphaOp0);
        g_pd3dDevice->GetTextureStageState(0, D3DTSS_ALPHAARG1, &dwAlphaArg1);
        g_pd3dDevice->GetTextureStageState(0, D3DTSS_ALPHAARG2, &dwAlphaArg2);
        g_pd3dDevice->GetTextureStageState(1, D3DTSS_COLOROP, &dwColorOp1);
        g_pd3dDevice->GetStreamSource(0, &pd3dr, &uStride);
        g_pd3dDevice->GetIndices(&pd3di, &uBaseIndex);
        g_pd3dDevice->GetTexture(0, &pd3dt);
        g_pd3dDevice->GetVertexShader(&dwShader);

        // Prepare to render the text
        g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
        g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);
        g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, (DWORD)FALSE);
    }
    else {
        if (!g_bInScene) {
            if (!BeginConsoleScene()) {
                UnlockConsole();
                return FALSE;
            }
            DrawConsoleBackground();
        }
    }

    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, (DWORD)TRUE);
    SetColorStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);
    SetAlphaStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);
    g_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
    g_pd3dDevice->SetTexture(0, g_pd3dtFontMap);
    g_pd3dDevice->SetVertexShader(FVF_TLVERTEX);

    // Draw the text
    DrawTextQuads(pszString, uCount, fXStart, fYStart, fCWidth, 
                  fCHeight, (D3DCOLOR)xcColor, fXStart);

    if (g_bAttached) {
        // Restore the device state
        g_pd3dDevice->SetVertexShader(dwShader);
        if (pd3di) {
            g_pd3dDevice->SetIndices(pd3di, uBaseIndex);
//            pd3di->Release(); // ##REVIEW: Will GetIndices increment the ref count of the index buffer?
        }
        if (pd3dr) {
            g_pd3dDevice->SetStreamSource(0, pd3dr, uStride);
//            pd3dr->Release(); // ##REVIEW: Will GetStreamSource increment the ref count of the vertex buffer?
        }
        g_pd3dDevice->SetTexture(0, pd3dt);
        SetColorStage(0, dwColorArg1, dwColorArg2, (D3DTEXTUREOP)dwColorOp0);
        SetAlphaStage(0, dwAlphaArg1, dwAlphaArg2, (D3DTEXTUREOP)dwAlphaOp0);
        g_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, dwColorOp1);
        g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlphaBlend);
        g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, dwAlphaTest);
        g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, dwSrcBlend);
        g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, dwDstBlend);
    }

    UnlockConsole();

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     xTextOutW
//
// Description:
//
//     Draw the given text string on the frame buffer.
//
// Arguments:
//
//     float fXStart            - x screen coordinate of the upper left corner 
//                                of the start of the string
//
//     float fYStart            - y screen coordinate of the upper left corner
//                                of the start of the string
//
//     float fCWidth            - Width in pixels of the characters to be used
//                                to display the string
//
//     float fCHeight           - Height in pixels of the characters to be used
//                                to display the string
//
//     XCOLOR xcColor           - Text color used to display the string
//
//     LPCWSTR pszString        - String to output on the screen
//
//     UINT uCount              - Number of characters in the string
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL DXCIOAPI xTextOutW(float fXStart, float fYStart, float fCWidth,
                        float fCHeight, XCOLOR xcColor, LPCWSTR pszString, 
                        UINT uCount) 
{
    char szBuffer[MAX_TCHAR_OUTPUT];
    wcstombs(szBuffer, pszString, MAX_TCHAR_OUTPUT);
    return xTextOutA(fXStart, fYStart, fCWidth, fCHeight, xcColor, szBuffer, uCount);
}

//******************************************************************************
//
// Function:
//
//     xDebugStringA
//
// Description:
//
//     Take the formatted output and send it to both the console output stream
//     and to the debugger.
//
// Arguments:
//
//     LPCSTR pszFormat         - Formatted string describing the output
//
//     Varaiable argument list  - Data to be placed in the output string
//
// Return Value:
//
//     None.
//
//******************************************************************************
void DXCIOAPI xDebugStringA(LPCSTR pszFormat, ...) {

    char szBuffer[MAX_TCHAR_OUTPUT];
    va_list vl;
    va_start(vl, pszFormat);
    xvprintf(pszFormat, vl);
    vsprintf(szBuffer, pszFormat, vl);
    va_end(vl);
    OutputDebugStringA(szBuffer);
}

//******************************************************************************
//
// Function:
//
//     xDebugStringW
//
// Description:
//
//     Take the formatted output and send it to both the console output stream
//     and to the debugger.
//
// Arguments:
//
//     LPCWSTR pszFormat        - Formatted string describing the output
//
//     Varaiable argument list  - Data to be placed in the output string
//
// Return Value:
//
//     None.
//
//******************************************************************************
void DXCIOAPI xDebugStringW(LPCWSTR pszFormat, ...) {

    wchar_t wszBuffer[MAX_TCHAR_OUTPUT];
    va_list vl;
    va_start(vl, pszFormat);
    xvwprintf(pszFormat, vl);
    vswprintf(wszBuffer, pszFormat, vl);
    va_end(vl);
    OutputDebugStringW(wszBuffer);
}

//******************************************************************************
// stdio functions
//******************************************************************************

//******************************************************************************
int DXCIOAPI xprintf(const char* format, ...) {

    va_list vl;
    int     nPrinted;

    va_start(vl, format);
    nPrinted = xvprintf(format, vl);
    va_end(vl);

    return nPrinted;
}

//******************************************************************************
int DXCIOAPI xwprintf(const wchar_t* format, ...) {

    va_list vl;
    int     nPrinted;

    va_start(vl, format);
    nPrinted = xvwprintf(format, vl);
    va_end(vl);

    return nPrinted;
}

//******************************************************************************
int DXCIOAPI xvprintf(const char* format, va_list argptr) {

    char szBuffer[MAX_TCHAR_OUTPUT];
    int  nWritten;
    
    nWritten = vsprintf(szBuffer, format, argptr);
    LockConsole();
    PutStringA(szBuffer);
    UnlockConsole();

    return nWritten;
}

//******************************************************************************
int DXCIOAPI xvwprintf(const wchar_t* format, va_list argptr) {

    wchar_t wszBuffer[MAX_TCHAR_OUTPUT];
    int     nWritten;

    nWritten = vswprintf(wszBuffer, format, argptr);
    LockConsole();
    PutStringW(wszBuffer);
    UnlockConsole();

    return nWritten;
}

//******************************************************************************
int DXCIOAPI xputchar(int c) {

    char sz[2];

    sz[0] = (char)c;
    sz[1] = '\0';
    LockConsole();
    PutStringA(sz);
    UnlockConsole();

    return (int)sz[0];
}

//******************************************************************************
wint_t DXCIOAPI xputwchar(wint_t c) {

    wchar_t wsz[2];

    wsz[0] = c;
    wsz[1] = L'\0';
    LockConsole();
    PutStringW(wsz);
    UnlockConsole();

    return wsz[0];
}

//******************************************************************************
int DXCIOAPI xputs(const char* string) {

    LockConsole();
    PutStringA(string);
    PutStringA("\n");
    UnlockConsole();
    return 0;
}

//******************************************************************************
int DXCIOAPI xputws(const wchar_t* string) {

    LockConsole();
    PutStringW(string);
    PutStringW(L"\n");
    UnlockConsole();
    return 0;
}

namespace DXCONIO {

//******************************************************************************
// Output buffer functions
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     PutStringA
//
// Description:
//
//     Append the given string to the end of the output stream buffer.
//
// Arguments:
//
//     LPCSTR                   - Null-terminated string to add to the stream
//
// Return Value:
//
//     None.
//
//******************************************************************************
void PutStringA(LPCSTR pszString) {

    LPCSTR psz;
    UINT   uStart;
    UINT   i;

    if (!pszString) {
        return;
    }

    uStart = g_uOutTail;

    for (psz = pszString; *psz; psz++) {

        g_pchOut[g_uOutTail++] = *psz;
        if (g_uOutTail == g_uOutSize) {
            g_uOutTail = 0;
        }
        if (g_uOutTail == g_uOutHead) {
            for (i = 0; g_pchOut[g_uOutHead] != '\n'; ) {
                switch (g_pchOut[g_uOutHead]) {
                    case '\t':
                        i += (i / TAB_LENGTH + 1) * TAB_LENGTH - i;
                        break;
                    case '\r':
                        i = 0;
                        break;
                    case '\b':
                        if (i > 0) i--;
                        break;
                    default:
                        i++;
                        break;
                }
                if (i >= g_uOutWidth) {
                    break;
                }
                if (++g_uOutHead == g_uOutSize) {
                    g_uOutHead = 0;
                }
                if (g_uOutHead == g_uOutTail) {
                    // Complete wraparound (the buffer is too small
                    // relative to the width of the margin and the length
                    // of the line.
                    uStart = g_uOutHead + 1;
                    if (uStart == g_uOutSize) {
                        uStart = 0;
                    }
                    if (g_bInitialized) {
                        g_uTextHead = 0;
                        g_uTextTail = 0;
                        g_uTextLine = 0;
                        g_uTextCol = 0;
                        g_uTextCursor = 0;
                    }
                    break;
                }
            }
            if (++g_uOutHead == g_uOutSize) {
                g_uOutHead = 0;
            }
        }
    }

    if (g_bInitialized) {
        UpdateConsole(uStart);
    }
}

//******************************************************************************
//
// Function:
//
//     PutStringW
//
// Description:
//
//     Append the given string to the end of the output stream buffer.
//
// Arguments:
//
//     LPCWSTR                  - Null-terminated string to add to the stream
//
// Return Value:
//
//     None.
//
//******************************************************************************
void PutStringW(LPCWSTR pszString) {

    char szBuffer[MAX_TCHAR_OUTPUT];
    wcstombs(szBuffer, pszString, MAX_TCHAR_OUTPUT);
    PutStringA(szBuffer);
}

//******************************************************************************
// Display functions
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     InitConsole
//
// Description:
//
//     Initialize the console's textures, vertex buffers, and index buffers.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL InitConsole() {

    LPDIRECT3DSURFACE8  pd3ds;
    D3DSURFACE_DESC     d3dsd;
// ##TODO: Switch to bump mapping a noise background when DX8 supports it on the GeForce2
//    D3DLOCKED_RECT      d3dlr;
//    LPDWORD             pdwPixel;
//    DWORD               dwPitch;
//    UINT                i, j;
//    float               fX, fY, fDX, fDY, fIntensity;
    HRESULT             hr;

    hr = g_pd3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pd3ds);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DDevice8::GetBackBuffer"));
        xReleaseConsole();
        return FALSE;
    }
    pd3ds->GetDesc(&d3dsd);
    pd3ds->Release();

    g_fTargetWidth = (float)d3dsd.Width;
    g_fTargetHeight = (float)d3dsd.Height;

    g_fMaxColScroll = (float)g_uOutWidth - ((g_fTargetWidth - BORDER_LEFT - BORDER_RIGHT) / g_fCharWidth);
    g_fMaxRowScroll = (float)g_uTextHeight - ((g_fTargetHeight - BORDER_TOP - BORDER_BOTTOM) / g_fCharHeight);
    g_fCurrentRow = 0.0f;
    g_fCurrentCol = 0.0f;

    g_vTranslate.x = BORDER_LEFT;
    g_vTranslate.y = g_fTargetHeight - BORDER_BOTTOM - g_fMaxRowScroll * g_fCharHeight;

    // Create a font map to use in displaying the output text on the screen
    if (!CreateFontMap()) {
        return FALSE;
    }

    if (!CreateGeometry(g_uOutSize)) {
        EffaceConsole();
        return FALSE;
    }

    if (g_bUseBackground) {

        if (*g_szBackImage) {
            g_pd3dtBackBase = (LPDIRECT3DTEXTURE8)CreateTexture(g_szBackImage, D3DFMT_A8R8G8B8, TTYPE_TEXTURE);
            if (!g_pd3dtBackBase) {
                g_bUseBackground = FALSE;
            }
        }

        else {

#ifdef UNDER_XBOX
            Swizzler swz(BACKTEX_WIDTH, BACKTEX_HEIGHT, 1);
#endif
            g_pd3dtBackBase = (LPDIRECT3DTEXTURE8)CreateTexture(TEXT("T_XBump"), D3DFMT_A8R8G8B8, TTYPE_TEXTURE);
            if (!g_pd3dtBackBase) {

                D3DLOCKED_RECT      d3dlr;
                LPDWORD             pdwPixel;
                DWORD               dwPitch;
                UINT                i, j;
                float               fX, fY, fDX, fDY, fIntensity;
//##DELETE
                g_pd3dtBackBase = (LPDIRECT3DTEXTURE8)CreateTexture(BACKTEX_WIDTH, BACKTEX_HEIGHT, D3DFMT_A8R8G8B8, TTYPE_TEXTURE);
                if (!g_pd3dtBackBase) {
                    EffaceConsole();
                    return FALSE;
                }

                hr = g_pd3dtBackBase->LockRect(0, &d3dlr, NULL, 0);
                if (FAILED(hr)) {
                    ResultFailed(hr, TEXT("IDirect3DTexture8::LockRect"));
                    EffaceConsole();
                    return FALSE;
                }

                pdwPixel = (LPDWORD)d3dlr.pBits;

                dwPitch = d3dlr.Pitch / 4;

                g_pNoise->SetRange(0.0f, 255.0f);

                fDX = 1.0f / (float)(BACKTEX_WIDTH - 1) * g_fTargetWidth / ((float)BACKTEX_WIDTH / 4.0f);
                fDY = 1.0f / (float)(BACKTEX_HEIGHT - 1) * g_fTargetHeight / ((float)BACKTEX_HEIGHT / 4.0f);

#ifdef UNDER_XBOX
                swz.SetU(0);
                swz.SetV(0);
#endif

                for (i = 0, fY = 0.0f; i < BACKTEX_HEIGHT; i++, fY += fDY) {

                    for (j = 0, fX = 0.0f; j < BACKTEX_WIDTH; j++, fX += fDX) {


                        fIntensity = g_pNoise->GetIntensity(fX, fY);
#ifndef UNDER_XBOX
                        pdwPixel[j] = RGBA_MAKE((BYTE)fIntensity, (BYTE)fIntensity, (BYTE)fIntensity, 255);
#else
                        pdwPixel[swz.Get2D()] = RGBA_MAKE((BYTE)fIntensity, (BYTE)fIntensity, (BYTE)fIntensity, 255);
                        swz.IncU();
#endif
                    }

#ifndef UNDER_XBOX
                    pdwPixel += dwPitch;
#else
                    swz.IncV();
#endif
                }

                hr = g_pd3dtBackBase->UnlockRect(0);
                if (FAILED(hr)) {
                    ResultFailed(hr, TEXT("IDirect3DTexture8::LockRect"));
                    EffaceConsole();
                    return FALSE;
                }
//##END DELETE
//                g_bUseBackground = FALSE;
            }
/*
            // ##TODO: Switch to bump mapping a noise background when DX8 supports it on the GeForce2

            g_pd3dtBackBase = (LPDIRECT3DTEXTURE8)CreateTexture(BACKTEX_WIDTH, BACKTEX_HEIGHT, D3DFMT_A8R8G8B8, TTYPE_TEXTURE);
            if (!g_pd3dtBackBase) {
                EffaceConsole();
                return FALSE;
            }

            hr = g_pd3dtBackBase->LockRect(0, &d3dlr, NULL, 0);
            if (FAILED(hr)) {
                ResultFailed(hr, TEXT("IDirect3DTexture8::LockRect"));
                EffaceConsole();
                return FALSE;
            }

            pdwPixel = (LPDWORD)d3dlr.pBits;

            dwPitch = d3dlr.Pitch / 4;

            g_pNoise->SetRange(0.0f, 255.0f);

            fDX = 1.0f / (float)(BACKTEX_WIDTH - 1) * g_fTargetWidth / ((float)BACKTEX_WIDTH / 4.0f);
            fDY = 1.0f / (float)(BACKTEX_HEIGHT - 1) * g_fTargetHeight / ((float)BACKTEX_HEIGHT / 4.0f);

            for (i = 0, fY = 0.0f; i < BACKTEX_HEIGHT; i++, fY += fDY) {

                for (j = 0, fX = 0.0f; j < BACKTEX_WIDTH; j++, fX += fDX) {


                    fIntensity = g_pNoise->GetIntensity(fX, fY);
                    *(pdwPixel + j) = RGBA_MAKE((BYTE)fIntensity, (BYTE)fIntensity, (BYTE)fIntensity, 255);
                }

                pdwPixel += dwPitch;
            }

            hr = g_pd3dtBackBase->UnlockRect(0);
            if (FAILED(hr)) {
                ResultFailed(hr, TEXT("IDirect3DTexture8::LockRect"));
                EffaceConsole();
                return FALSE;
            }

            g_pd3dtBackBump = (LPDIRECT3DTEXTURE8)CreateTexture(TEXT("T_XBump"), D3DFMT_V8U8, TTYPE_BUMPMAP);
            if (!g_pd3dtBackBump) {
                EffaceConsole();
                return FALSE;
            }

            g_pd3dtBackEnv = (LPDIRECT3DTEXTURE8)CreateDiffuseMap(BACKTEX_WIDTH, BACKTEX_HEIGHT, RGBA_MAKE(255, 255, 255, 255), D3DFMT_A8R8G8B8, FALSE);
            if (!g_pd3dtBackEnv) {
                EffaceConsole();
                return FALSE;
            }
*/
        }
    }

    g_bInScene = FALSE;

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     EffaceConsole
//
// Description:
//
//     Release the textures, vertex buffers, and index buffers used by the 
//     console.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void EffaceConsole() {

    if (g_pd3dtBackEnv) {
        ReleaseTexture(g_pd3dtBackEnv);
        g_pd3dtBackEnv = NULL;
    }
    if (g_pd3dtBackBump) {
        ReleaseTexture(g_pd3dtBackBump);
        g_pd3dtBackBump = NULL;
    }
    if (g_pd3dtBackBase) {
        ReleaseTexture(g_pd3dtBackBase);
        g_pd3dtBackBase = NULL;
    }

    ReleaseGeometry();

    ReleaseFontMap();
}

//******************************************************************************
//
// Function:
//
//     CreateGeometry
//
// Description:
//
//     Create and initialize the vertex and index buffers used by the console
//     in drawing the background and outputting text.
//
// Arguments:
//
//     UINT uNumChars           - Number of quads to be used in displaying
//                                output stream text on the screen
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CreateGeometry(UINT uNumChars) {

    LPBYTE     pData;
    D3DVECTOR* pvPos;
    PTLBVERTEX prBack;
    D3DXMATRIX mIdentity;
    LPWORD     pwText;
    WORD       i, j, k;
    HRESULT    hr;

// ##DELETE: Until support for vertex shaders is introduced, use a temporary vertex buffer to hold transformed vertices
// Create a vertex buffer to hold the positions of text quads
g_uVBDeleteMeSize = uNumChars * 4 * sizeof(TLVERTEX);
hr = g_pd3dDevice->CreateVertexBuffer(g_uVBDeleteMeSize,
                                        0, 0, D3DPOOL_DEFAULT, 
                                        &g_pd3drDeleteMe);
if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVertexBuffer"))) {
    return FALSE;
}
// ##END DELETE

    // Create a vertex buffer to hold the positions of text quads
    g_uVBPositionSize = uNumChars * 4 * sizeof(D3DVECTOR);
    hr = g_pd3dDevice->CreateVertexBuffer(g_uVBPositionSize,
                                            0, 0, D3DPOOL_DEFAULT, 
                                            &g_pd3drPosition);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVertexBuffer"))) {
        return FALSE;
    }

    // Initialize position vertices to zero so nothing will be initially drawn
    hr = g_pd3drPosition->Lock(0, g_uVBPositionSize, &pData, 0);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::Lock"));
        ReleaseGeometry();
        return FALSE;
    }
    pvPos = (D3DVECTOR*)pData;

    for (i = 0; i < uNumChars * 4; i++) {
        pvPos[i].x = POS_BLANK;
        pvPos[i].y = POS_BLANK;
        pvPos[i].z = 0.0f;
    }

    hr = g_pd3drPosition->Unlock();
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::Unlock"));
        ReleaseGeometry();
        return FALSE;
    }

    // Create a vertex buffer to hold the texture coordinates of text quads
    g_uVBTexCoordSize = uNumChars * 4 * sizeof(TCOORD);
    hr = g_pd3dDevice->CreateVertexBuffer(g_uVBTexCoordSize,
                                            0, 0, D3DPOOL_DEFAULT, 
                                            &g_pd3drTexCoord);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVertexBuffer"))) {
        ReleaseGeometry();
        return FALSE;
    }

    // Create an index buffer for the text geometry
    g_uIBTextSize = uNumChars * 6 * sizeof(WORD);
    hr = g_pd3dDevice->CreateIndexBuffer(g_uIBTextSize,
                                            0, D3DFMT_INDEX16, D3DPOOL_DEFAULT,
                                            &g_pd3diText);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateIndexBuffer"))) {
        ReleaseGeometry();
        return FALSE;
    }

    hr = g_pd3diText->Lock(0, g_uIBTextSize, &pData, 0);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DIndexBuffer8::Lock"));
        ReleaseGeometry();
        return FALSE;
    }

    // Initialize the indices
    for (pwText = (LPWORD)pData, i = 0, j = 0, k = 0; i < uNumChars; i++, j += 4, k += 6) {
        pwText[k]   = j;
        pwText[k+1] = j + 2;
        pwText[k+2] = j + 1;
        pwText[k+3] = j + 1;
        pwText[k+4] = j + 2;
        pwText[k+5] = j + 3;
    }

    hr = g_pd3diText->Unlock();
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DIndexBuffer8::Unlock"));
        ReleaseGeometry();
        return FALSE;
    }

    // Create a vertex buffer the hold the background vertices
    hr = g_pd3dDevice->CreateVertexBuffer(4 * sizeof(TLBVERTEX),
                                            0, FVF_TLBVERTEX, D3DPOOL_DEFAULT, 
                                            &g_pd3drBack);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVertexBuffer"))) {
        ReleaseGeometry();
        return FALSE;
    }

    // Initialize the background vertices
    hr = g_pd3drBack->Lock(0, 4 * sizeof(TLBVERTEX), &pData, 0);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::Lock"));
        ReleaseGeometry();
        return FALSE;
    }

    prBack = (PTLBVERTEX)pData;
    *prBack++ = TLBVERTEX(D3DXVECTOR3(0.0f, g_fTargetHeight, 0.9999f), 0.0001f, g_dwBackgroundColor, 0, 0.0f, 1.0f, 0.0f, 0.0f);
    *prBack++ = TLBVERTEX(D3DXVECTOR3(0.0f, 0.0f, 0.9999f), 0.0001f, g_dwBackgroundColor, 0, 0.0f, 0.0f, 0.0f, 0.0f);
    *prBack++ = TLBVERTEX(D3DXVECTOR3(g_fTargetWidth, 0.0f, 0.9999f), 0.0001f, g_dwBackgroundColor, 0, 1.0f, 0.0f, 0.0f, 0.0f);
    *prBack   = TLBVERTEX(D3DXVECTOR3(g_fTargetWidth, g_fTargetHeight, 0.9999f), 0.0001f, g_dwBackgroundColor, 0, 1.0f, 1.0f, 0.0f, 0.0f);

    prBack = (PTLBVERTEX)pData;
    D3DXMatrixIdentity(&mIdentity);
    SetDiffuseMapCoords(&D3DXVECTOR3(0.0f, 0.0f, -1.0f), 0, 
                       (PTCOORD)&prBack[0].u1, sizeof(TLBVERTEX), 
                       4, &mIdentity, &D3DXVECTOR3(0.0f, 1.0f, 0.5f), M_3PIDIV2);

    hr = g_pd3drBack->Unlock();
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::Unlock"));
        ReleaseGeometry();
        return FALSE;
    }

    g_uTextSize = uNumChars;

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     ReleaseGeometry
//
// Description:
//
//     Release the vertex and index buffers used by the console.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void ReleaseGeometry() {

// ##DELETE: Until support for vertex shaders is introduced, use a temporary vertex buffer to hold transformed vertices
if (g_pd3drDeleteMe){
g_pd3drDeleteMe->Release();
g_pd3drDeleteMe = NULL;
}
// ##END DELETE

    if (g_pd3drBack) {
        g_pd3drBack->Release();
        g_pd3drBack = NULL;
    }

    if (g_pd3drPosition) {
        g_pd3drPosition->Release();
        g_pd3drPosition = NULL;
    }

    if (g_pd3drTexCoord) {
        g_pd3drTexCoord->Release();
        g_pd3drTexCoord = NULL;
    }

    if (g_pd3diText) {
        g_pd3diText->Release();
        g_pd3diText = NULL;
    }
}

//******************************************************************************
//
// Function:
//
//     RefreshConsole
//
// Description:
//
//     Recalculate all vertex data pertaining to the display of text for the 
//     console from the output stream buffer.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void RefreshConsole() {

    LPBYTE      pData;
    D3DVECTOR*  pvPos;
    HRESULT     hr;
    UINT        i;

    g_uTextHead = 0;
    g_uTextTail = 0;
    g_uTextLine = 0;
    g_uTextHeight = 1;
    g_uTextCol = 0;
    g_uTextCursor = 0;
    g_fTextX = 0.0f;

    // Clear the position buffer (such that it won't get displayed)
    hr = g_pd3drPosition->Lock(0, g_uVBPositionSize, &pData, 0);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::Lock"));
        return;
    }
    pvPos = (D3DVECTOR*)pData;

    for (i = 0; i < g_uTextSize * 4; i++) {
        pvPos[i].x = POS_BLANK;
        pvPos[i].y = POS_BLANK;
        pvPos[i].z = 0.0f;
    }

    hr = g_pd3drPosition->Unlock();
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::Unlock"));
        return;
    }

    UpdateConsole(g_uOutHead);
}

//******************************************************************************
//
// Function:
//
//     UpdateConsole
//
// Description:
//
//     Update the vertex buffers with new data from the console output stream.
//
// Arguments:
//
//     UINT uStart              - Starting index into the console output buffer
//                                from which to update the console with new text
//
// Return Value:
//
//     None.
//
//******************************************************************************
void UpdateConsole(UINT uStart) {

    UINT  src;
    LPBYTE pData;
    D3DVECTOR* pvPos;
    PTCOORD    ptcUV, ptcChar;
    UINT i, j;
    UINT uSpaces;
    HRESULT hr;

    // Lock the vertex buffers
    hr = g_pd3drPosition->Lock(0, g_uVBPositionSize, &pData, 0);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::Lock"));
        return;
    }
    pvPos = (D3DVECTOR*)pData;

    hr = g_pd3drTexCoord->Lock(0, g_uVBTexCoordSize, &pData, 0);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::Lock"));
        return;
    }
    ptcUV = (PTCOORD)pData;

    for (src = uStart; src != g_uOutTail; ) {

        if (g_pchOut[src] == '\n' || g_uTextCol >= g_uOutWidth) {
            g_fTextX = 0.0f;
            g_uTextLine = g_uTextTail;
            g_uTextCursor = g_uTextTail;
            g_uTextCol = 0;
            for (i = g_uTextHead; i != g_uTextTail; ) {
                pvPos[i * 4].y     -= g_fCharHeight;
                pvPos[i * 4 + 1].y -= g_fCharHeight;
                pvPos[i * 4 + 2].y -= g_fCharHeight;
                pvPos[i * 4 + 3].y -= g_fCharHeight;

                if (++i == g_uTextSize) {
                    i = 0;
                }
            }
            g_uTextHeight++;
            g_fMaxRowScroll = (float)g_uTextHeight - ((g_fTargetHeight - BORDER_TOP - BORDER_BOTTOM) / g_fCharHeight);
            if (g_fCurrentRow != 0.0f) {
                g_fCurrentRow += 1.0f;
            }
            UpdateConsoleScrollY();
        }

        uSpaces = 0;

        switch (g_pchOut[src]) {

            case '\r':
                g_uTextCursor = g_uTextLine;
                g_uTextCol = 0;
                g_fTextX = 0.0f;
                break;

            case '\b':
                if (g_uTextCursor != g_uTextLine) {
                    if (g_uTextCursor > 0) {
                        g_uTextCursor--;
                    }
                    else {
                        g_uTextCursor = g_uTextSize - 1;
                    }
                    g_uTextCol--;
                    g_fTextX -= g_fCharWidth;
                }
                break;

            case '\n':
                // Already handled
                break;

            case '\t':
                uSpaces = (g_uTextCol / TAB_LENGTH + 1) * TAB_LENGTH - g_uTextCol;
                if (g_uTextCol + uSpaces >= g_uOutWidth) {
                    uSpaces = g_uOutWidth - g_uTextCol;
                }
                // Fall through

            default:
                if (uSpaces) {
                    ptcChar = CHAR_TO_TCOORD(' ');
                    i = 1;
                }
                else {
                    ptcChar = CHAR_TO_TCOORD(g_pchOut[src]);
                    i = 0;
                }

                for (; i <= uSpaces; i++) {

                    pvPos[g_uTextCursor * 4].x        = g_fTextX;
                    pvPos[g_uTextCursor * 4].y        = -g_fCharHeight;
                    ptcUV[g_uTextCursor * 4].u        = ptcChar->u;
                    ptcUV[g_uTextCursor * 4].v        = ptcChar->v;

                    pvPos[g_uTextCursor * 4 + 1].x    = g_fTextX;
                    pvPos[g_uTextCursor * 4 + 1].y    = 0.0f;
                    ptcUV[g_uTextCursor * 4 + 1].u    = ptcChar->u;
                    ptcUV[g_uTextCursor * 4 + 1].v    = ptcChar->v + FONT_TCOORD_HEIGHT;

                    pvPos[g_uTextCursor * 4 + 2].x    = g_fTextX + g_fCharWidth;
                    pvPos[g_uTextCursor * 4 + 2].y    = -g_fCharHeight;
                    ptcUV[g_uTextCursor * 4 + 2].u    = ptcChar->u + FONT_TCOORD_WIDTH;
                    ptcUV[g_uTextCursor * 4 + 2].v    = ptcChar->v;

                    pvPos[g_uTextCursor * 4 + 3].x    = g_fTextX + g_fCharWidth;
                    pvPos[g_uTextCursor * 4 + 3].y    = 0.0f;
                    ptcUV[g_uTextCursor * 4 + 3].u    = ptcChar->u + FONT_TCOORD_WIDTH;
                    ptcUV[g_uTextCursor * 4 + 3].v    = ptcChar->v + FONT_TCOORD_HEIGHT;

                    if (g_uTextCursor == g_uTextTail) {
                        if (++g_uTextTail == g_uTextSize) {
                            g_uTextTail = 0;
                        }
                        if (g_uTextTail == g_uTextHead) {

                            float       y;
                            D3DVECTOR*  pv;

                            // Advance the head of the list to the start of the 
                            // next line, clearing the text in between
                            for (y = pvPos[g_uTextHead * 4].y; y == pvPos[g_uTextHead * 4].y; ) {
                                for (j = 0, pv = pvPos + g_uTextHead * 4; j < 4; j++, pv++) {
                                    pv->x = POS_BLANK;
                                    pv->y = POS_BLANK;
                                    pv->z = 0.0f;
                                }

                                if (++g_uTextHead == g_uTextSize) {
                                    g_uTextHead = 0;
                                }
                            }

                            g_uTextHeight -= (UINT)((pvPos[g_uTextHead * 4].y - y) / g_fCharHeight + 0.5f);
                            g_fMaxRowScroll = (float)g_uTextHeight - ((g_fTargetHeight - BORDER_TOP - BORDER_BOTTOM) / g_fCharHeight);
                            UpdateConsoleScrollY();
                        }
                    }
                    if (++g_uTextCursor == g_uTextSize) {
                        g_uTextCursor = 0;
                    }

                    g_fTextX += g_fCharWidth;
                    g_uTextCol++;
                }
                break;
        }

        if (++src == g_uOutSize) {
            src = 0;
        }
    }

    // Unlock the vertex buffers
    hr = g_pd3drPosition->Unlock();
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::Unlock"));
        return;
    }

    hr = g_pd3drTexCoord->Unlock();
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::Unlock"));
        return;
    }

    // Calculate the visible portions of the vertex buffer
    UpdateVisibility();

    if (!g_bAttached) {
        DrawConsole();
    }
}

//******************************************************************************
//
// Function:
//
//     BeginConsoleScene
//
// Description:
//
//     Pump messages, check for a lost device, clear the background, and begin a 
//     new scene for the console.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
static BOOL BeginConsoleScene() {

    HRESULT hr;

#ifndef UNDER_XBOX
    MSG     msg;

    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

        // If a message is ready, process it and proceed to
        // check for another message
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    hr = g_pd3dDevice->TestCooperativeLevel();
    if (FAILED(hr)) {
        if (hr == D3DERR_DEVICELOST) {
            return FALSE;
        }
        if (hr == D3DERR_DEVICENOTRESET) {
            if (!xResetConsole()) {
                return FALSE;
            }
        }
    }
#endif

    // Clear the rendering target
#ifndef UNDER_XBOX
    if (!g_bUseBackground) {
        g_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET, g_dwBackgroundColor, 1.0f, 0);
    }
#else
    // ##HACK to temporarily compensate for the background texture not getting
    // rendered
    g_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET, RGBA_MAKE(0, 0, 0, 255), 1.0f, 0);
#endif // UNDER_XBOX

    // Begin the scene
    g_pd3dDevice->BeginScene();

    g_bInScene = TRUE;

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     EndConsoleScene
//
// Description:
//
//     End a console scene and present the frame buffer.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
static void EndConsoleScene() {

    // End the scene
    g_pd3dDevice->EndScene();

    // Update the screen
    g_pd3dDevice->Present(NULL, NULL, NULL, NULL);

    g_bInScene = FALSE;
}

//******************************************************************************
//
// Function:
//
//     DrawConsoleBackground
//
// Description:
//
//     Draw the background for the console.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
static void DrawConsoleBackground() {

    g_pd3dDevice->SetVertexShader(FVF_TLBVERTEX);

    // Set textures

    if (g_bUseBackground || g_bAttached) {
/*
        // ##TODO: Switch to bump mapping a noise background when DX8 supports it on the GeForce2

        g_pd3dDevice->SetTexture(0, g_pd3dtBackBase);
        g_pd3dDevice->SetTexture(1, g_pd3dtBackBump);
        g_pd3dDevice->SetTexture(2, g_pd3dtBackEnv);

        g_pd3dDevice->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);
        g_pd3dDevice->SetTextureStageState(1, D3DTSS_TEXCOORDINDEX, 0);
        g_pd3dDevice->SetTextureStageState(2, D3DTSS_TEXCOORDINDEX, 1);

        SetColorStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);
        if (g_pd3dtBackBump) {
            SetColorStage(1, D3DTA_TEXTURE, D3DTA_CURRENT, D3DTOP_BUMPENVMAP);
            SetColorStage(2, D3DTA_TEXTURE, D3DTA_CURRENT, D3DTOP_MODULATE4X);
        }
        else {
            g_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
        }

        g_pd3dDevice->SetTextureStageState(1, D3DTSS_BUMPENVMAT00, F2DW(1.0f));
        g_pd3dDevice->SetTextureStageState(1, D3DTSS_BUMPENVMAT01, F2DW(0.0f));
        g_pd3dDevice->SetTextureStageState(1, D3DTSS_BUMPENVMAT10, F2DW(0.0f));
        g_pd3dDevice->SetTextureStageState(1, D3DTSS_BUMPENVMAT11, F2DW(1.0f));

        g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, (DWORD)FALSE);
//        SetColorStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);
//        SetAlphaStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);
//        g_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
//        g_pd3dDevice->SetTexture(0, g_pd3dtBackBase);
*/

        g_pd3dDevice->SetTextureStageState(0, D3DTSS_MINFILTER, (DWORD)D3DTEXF_LINEAR);
        g_pd3dDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, (DWORD)D3DTEXF_LINEAR);
        g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, (DWORD)g_bAttached);
        SetColorStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);
        SetAlphaStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);
        g_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
        g_pd3dDevice->SetTexture(0, g_pd3dtBackBase);

        g_pd3dDevice->SetStreamSource(0, g_pd3drBack, sizeof(TLBVERTEX));

        g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);

        g_pd3dDevice->SetTextureStageState(0, D3DTSS_MINFILTER, (DWORD)D3DTEXF_POINT);
        g_pd3dDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, (DWORD)D3DTEXF_POINT);
    }
}

//******************************************************************************
//
// Function:
//
//     DrawConsoleText
//
// Description:
//
//     Draw the console text.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
static void DrawConsoleText() {

    D3DCOLOR    cShadow;
// ##DELETE: Until support for vertex shaders is introduced, transform the vertices
LPBYTE pData, pPos, pTex;
D3DVECTOR* pvPos;
PTCOORD ptc;
PTLVERTEX pr;
UINT    i;
// ##END DELETE

    // ##REVIEW: When supported, switch to using vertex shaders to translate the vertices.
    // The output from the shader must be in clip-space
    // (0.0f to 1.0f) and will later be mapped to the viewport.  Any
    // clipping will be performed by d3d after shading.

    g_pd3dDevice->SetVertexShader(FVF_TLVERTEX);

    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, (DWORD)TRUE);
    SetColorStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);
    SetAlphaStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);
    g_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
    g_pd3dDevice->SetTexture(0, g_pd3dtFontMap);
    g_pd3dDevice->SetTexture(1, NULL);
#ifndef DEMO_HACK
    g_pd3dDevice->SetTexture(2, NULL);
#endif // DEMO_HACK

    g_pd3dDevice->SetIndices(g_pd3diText, 0);

    cShadow = RGBA_MAKE(0, 0, 0, (BYTE)((float)RGBA_GETALPHA(g_dwTextColor) / 255.0f * SHADOW_INTENSITY));

// ##DELETE: Until support for vertex shaders is introduced, transform the vertices
// Transform the vertices
g_pd3drDeleteMe->Lock(0, g_uVBDeleteMeSize, &pData, 0);
g_pd3drPosition->Lock(0, g_uVBPositionSize, &pPos, 0);
g_pd3drTexCoord->Lock(0, g_uVBTexCoordSize, &pTex, 0);
//pr = (PTLVERTEX)pData;
//pvPos = (D3DVECTOR*)pPos;
//ptc = (PTCOORD)pTex;

for (i = 0, pvPos = ((D3DVECTOR*)pPos) + g_uVStart1, pr = ((PTLVERTEX)pData) + g_uVStart1, ptc = ((PTCOORD)pTex) + g_uVStart1; i < g_uVCount1; i++, pr++, pvPos++, ptc++) {

    pr->fRHW = 110000.0f;
    pr->vPosition.x = pvPos->x + g_vTranslate.x + SHADOW_OFFSET_X;
    pr->vPosition.y = pvPos->y + g_vTranslate.y + SHADOW_OFFSET_Y;
    pr->vPosition.z = 0.000009f;
    pr->cDiffuse = cShadow;
    pr->cSpecular = 0;
    pr->u0 = ptc->u;
    pr->v0 = ptc->v;
}
for (i = 0, pvPos = ((D3DVECTOR*)pPos) + g_uVStart2, pr = ((PTLVERTEX)pData) + g_uVStart2, ptc = ((PTCOORD)pTex) + g_uVStart2; i < g_uVCount2; i++, pr++, pvPos++, ptc++) {

    pr->fRHW = 110000.0f;
    pr->vPosition.x = pvPos->x + g_vTranslate.x + SHADOW_OFFSET_X;
    pr->vPosition.y = pvPos->y + g_vTranslate.y + SHADOW_OFFSET_Y;
    pr->vPosition.z = 0.000009f;
    pr->cDiffuse = cShadow;
    pr->cSpecular = 0;
    pr->u0 = ptc->u;
    pr->v0 = ptc->v;
}

g_pd3drTexCoord->Unlock();
g_pd3drPosition->Unlock();
g_pd3drDeleteMe->Unlock();
// ##END DELETE

    g_pd3dDevice->SetStreamSource(0, g_pd3drDeleteMe, sizeof(TLVERTEX));

    if (g_uVCount1) {
        g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, g_uVStart1, g_uVCount1, g_uVStart1 / 4 * 6, g_uVCount1 / 2);
    }
    if (g_uVCount2) {
        g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, g_uVStart2, g_uVCount2, g_uVStart2 / 4 * 6, g_uVCount2 / 2);
    }

// ##DELETE: Until support for vertex shaders is introduced, transform the vertices
// Transform the vertices
g_pd3drDeleteMe->Lock(0, g_uVBDeleteMeSize, &pData, 0);
g_pd3drPosition->Lock(0, g_uVBPositionSize, &pPos, 0);
g_pd3drTexCoord->Lock(0, g_uVBTexCoordSize, &pTex, 0);
pr = (PTLVERTEX)pData;
pvPos = (D3DVECTOR*)pPos;
ptc = (PTCOORD)pTex;

for (i = 0, pvPos = ((D3DVECTOR*)pPos) + g_uVStart1, pr = ((PTLVERTEX)pData) + g_uVStart1, ptc = ((PTCOORD)pTex) + g_uVStart1; i < g_uVCount1; i++, pr++, pvPos++, ptc++) {

    pr->fRHW = 120000.0f;
    pr->vPosition.x = pvPos->x + g_vTranslate.x;
    pr->vPosition.y = pvPos->y + g_vTranslate.y;
    pr->vPosition.z = 0.000008f;
    pr->cDiffuse = g_dwTextColor;
    pr->cSpecular = 0;
    pr->u0 = ptc->u;
    pr->v0 = ptc->v;
}
for (i = 0, pvPos = ((D3DVECTOR*)pPos) + g_uVStart2, pr = ((PTLVERTEX)pData) + g_uVStart2, ptc = ((PTCOORD)pTex) + g_uVStart2; i < g_uVCount2; i++, pr++, pvPos++, ptc++) {

    pr->fRHW = 120000.0f;
    pr->vPosition.x = pvPos->x + g_vTranslate.x;
    pr->vPosition.y = pvPos->y + g_vTranslate.y;
    pr->vPosition.z = 0.000008f;
    pr->cDiffuse = g_dwTextColor;
    pr->cSpecular = 0;
    pr->u0 = ptc->u;
    pr->v0 = ptc->v;
}
g_pd3drTexCoord->Unlock();
g_pd3drPosition->Unlock();
g_pd3drDeleteMe->Unlock();
// ##END DELETE

    g_pd3dDevice->SetStreamSource(0, g_pd3drDeleteMe, sizeof(TLVERTEX));

    if (g_uVCount1) {
        g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, g_uVStart1, g_uVCount1, g_uVStart1 / 4 * 6, g_uVCount1 / 2);
    }
    if (g_uVCount2) {
        g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, g_uVStart2, g_uVCount2, g_uVStart2 / 4 * 6, g_uVCount2 / 2);
    }
}

//******************************************************************************
//
// Function:
//
//     DrawConsole
//
// Description:
//
//     Draw the console to the screen.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void DrawConsole() {

    DWORD dwZCmp, dwTexFMin, dwTexFMag;

    if (!g_bInitialized) {
        return;
    }

    if (g_bInScene) {
        return;
    }

//##DELETE
if (!g_bAttached) {
if (g_kdKeys & KEY_LEFT) {
g_kdKeys &= ~KEY_LEFT;
xScrollConsole(XSCROLL_LINELEFT, NULL, NULL);
}
else if (g_kdKeys & KEY_RIGHT) {
g_kdKeys &= ~KEY_RIGHT;
xScrollConsole(XSCROLL_LINERIGHT, NULL, NULL);
}
if (g_kdKeys & KEY_UP) {
g_kdKeys &= ~KEY_UP;
xScrollConsole(XSCROLL_LINEUP, NULL, NULL);
}
else if (g_kdKeys & KEY_DOWN) {
g_kdKeys &= ~KEY_DOWN;
xScrollConsole(XSCROLL_LINEDOWN, NULL, NULL);
}
if (g_kdKeys & KEY_PAGEUP) {
g_kdKeys &= ~KEY_PAGEUP;
xScrollConsole(XSCROLL_PAGEUP, NULL, NULL);
}
else if (g_kdKeys & KEY_PAGEDOWN) {
g_kdKeys &= ~KEY_PAGEDOWN;
xScrollConsole(XSCROLL_PAGEDOWN, NULL, NULL);
}
if (g_kdKeys & KEY_HOME) {
g_kdKeys &= ~KEY_HOME;
xScrollConsole(XSCROLL_TOP, NULL, NULL);
}
else if (g_kdKeys & KEY_END) {
g_kdKeys &= ~KEY_END;
xScrollConsole(XSCROLL_BOTTOM, NULL, NULL);
}
if (g_kdKeys & KEY_INSERT) {
g_kdKeys &= ~KEY_INSERT;
xScrollConsole(XSCROLL_PAGELEFT, NULL, NULL);
}
else if (g_kdKeys & KEY_DELETE) {
g_kdKeys &= ~KEY_DELETE;
xScrollConsole(XSCROLL_PAGERIGHT, NULL, NULL);
}
}
//$#END DELETE

    if (!g_bAttached) {
        if (!BeginConsoleScene()) {
            return;
        }
    }
    else {
        g_pd3dDevice->GetRenderState(D3DRS_ZFUNC, &dwZCmp);
        g_pd3dDevice->SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS);
        g_pd3dDevice->GetTextureStageState(0, D3DTSS_MINFILTER, &dwTexFMin);
        g_pd3dDevice->GetTextureStageState(0, D3DTSS_MAGFILTER, &dwTexFMag);
    }

    DrawConsoleBackground();
    DrawConsoleText();

// ##DELETE
// ##HACK to make diffuse modulated blending work on Inspiron 5000
    TLVERTEX rDummy[3];
    rDummy[0] = TLVERTEX(D3DXVECTOR3(0.0f, (float)0.0f, 0.000009f), 110000.0f, RGBA_MAKE(0,0,0,255), RGBA_MAKE(0,0,0,0), 0.0f, 1.0f);
    rDummy[1] = TLVERTEX(D3DXVECTOR3(0.0f, 0.0f, 0.000009f), 110000.0f, RGBA_MAKE(0,0,0,255), RGBA_MAKE(0,0,0,0), 0.0f, 0.0f);
    rDummy[2] = TLVERTEX(D3DXVECTOR3((float)0.0f, 0.0f, 0.000009f), 110000.0f, RGBA_MAKE(0,0,0,255), RGBA_MAKE(0,0,0,0), 1.0f, 0.0f);
    SetColorStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_SELECTARG2);
    SetAlphaStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_SELECTARG2);
    g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 1, rDummy, sizeof(TLVERTEX));
    SetColorStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);
    SetAlphaStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);
// ##END HACK
// ##END DELETE

    if (!g_bAttached) {
        EndConsoleScene();
    }
    else {
        g_pd3dDevice->SetRenderState(D3DRS_ZFUNC, dwZCmp);
        g_pd3dDevice->SetTextureStageState(0, D3DTSS_MINFILTER, dwTexFMin);
        g_pd3dDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, dwTexFMag);
    }
}

//******************************************************************************
//
// Function:
//
//     DrawTextQuads
//
// Description:
//
//     Draw the given text string on the frame buffer.
//
// Arguments:
//
//     LPCSTR szText            - String to output on the screen
//
//     UINT uCount              - Number of characters in the string
//
//     float fXStart            - x screen coordinate of the upper left corner 
//                                of the start of the string
//
//     float fYStart            - y screen coordinate of the upper left corner
//                                of the start of the string
//
//     float fWidth             - Width in pixels of the characters to be used
//                                to display the string
//
//     float fHeight            - Height in pixels of the characters to be used
//                                to display the string
//
//     D3DCOLOR c               - Text color used to display the string
//
//     float fLeftMargin        - Location of the left margin for the text in
//                                screen coordinates.  If a newline character
//                                is encountered the continuation of the
//                                string will begin at this point.
//
// Return Value:
//
//     None.
//
//******************************************************************************
static void DrawTextQuads(LPCSTR szText, UINT uCount, float fX, float fY, 
                          float fWidth, float fHeight, D3DCOLOR c,
                          float fLeftMargin)
{
    PTCOORD ptcChar;
    UINT uLen = uCount;
    D3DCOLOR cShadow;
    UINT i, j;

    if (uCount > MAX_TEXTOUT_LENGTH) {
        uLen = MAX_TEXTOUT_LENGTH;
    }

    for (i = 0, j = 0; i < uLen; i++) {

        if (szText[i] == '\n') {
            fX = fLeftMargin;
            fY += fHeight;
            continue;
        }

        ptcChar = CHAR_TO_TCOORD(szText[i]);

        g_prTextOut[j].vPosition.x     = fX;
        g_prTextOut[j].vPosition.y     = fY;
        g_prTextOut[j].cDiffuse        = c;
        g_prTextOut[j].u0              = ptcChar->u;
        g_prTextOut[j].v0              = ptcChar->v;

        g_prTextOut[j+1].vPosition.x   = fX;
        g_prTextOut[j+1].vPosition.y   = fY + fHeight;
        g_prTextOut[j+1].cDiffuse      = c;
        g_prTextOut[j+1].u0            = ptcChar->u;
        g_prTextOut[j+1].v0            = ptcChar->v + FONT_TCOORD_HEIGHT;

        g_prTextOut[j+2].vPosition.x   = fX + fWidth;
        g_prTextOut[j+2].vPosition.y   = fY;
        g_prTextOut[j+2].cDiffuse      = c;
        g_prTextOut[j+2].u0            = ptcChar->u + FONT_TCOORD_WIDTH;
        g_prTextOut[j+2].v0            = ptcChar->v;

        g_prTextOut[j+3].vPosition.x   = fX + fWidth;
        g_prTextOut[j+3].vPosition.y   = fY + fHeight;
        g_prTextOut[j+3].cDiffuse      = c;
        g_prTextOut[j+3].u0            = ptcChar->u + FONT_TCOORD_WIDTH;
        g_prTextOut[j+3].v0            = ptcChar->v + FONT_TCOORD_HEIGHT;

        fX += fWidth;

        j += 4;
    }

    if (!g_bAttached) {

        cShadow = RGBA_MAKE(0, 0, 0, (BYTE)((float)RGBA_GETALPHA(c) / 255.0f * SHADOW_INTENSITY));

        for (i = 0; i < j; i++) {
            g_prTextOut[MAX_TEXTOUT_LENGTH+i].vPosition.x = g_prTextOut[i].vPosition.x + SHADOW_OFFSET_X;
            g_prTextOut[MAX_TEXTOUT_LENGTH+i].vPosition.y = g_prTextOut[i].vPosition.y + SHADOW_OFFSET_Y;
            g_prTextOut[MAX_TEXTOUT_LENGTH+i].cDiffuse = cShadow;
            g_prTextOut[MAX_TEXTOUT_LENGTH+i].u0 = g_prTextOut[i].u0;
            g_prTextOut[MAX_TEXTOUT_LENGTH+i].v0 = g_prTextOut[i].v0;
        }

        if (j) {
            g_pd3dDevice->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, 
                            j, j / 2, g_pwTextOut, D3DFMT_INDEX16, 
                            g_prTextOut + MAX_TEXTOUT_LENGTH, sizeof(TLVERTEX));
        }
    }

    if (j) {
        g_pd3dDevice->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, 
                        j, j / 2, g_pwTextOut, 
                        D3DFMT_INDEX16, g_prTextOut, sizeof(TLVERTEX));
    }

    if (uCount > MAX_TEXTOUT_LENGTH) {
        DrawTextQuads(szText + MAX_TEXTOUT_LENGTH, uCount - MAX_TEXTOUT_LENGTH, fX, fY, fWidth, 
                        fHeight, c, fLeftMargin);
    }
}

//******************************************************************************
//
// Function:
//
//     GetDeviceInfo
//
// Description:
//
//     Get the capabilities, adapter identifier, and display mode of the device.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
static BOOL GetDeviceInfo() {

    HRESULT   hr;

    hr = g_pd3dDevice->GetDeviceCaps(&g_devd.d3dcaps);
    if (FAILED(hr)) {
        return FALSE;
    }

    g_adpd.uAdapter = g_devd.d3dcaps.AdapterOrdinal;

    hr = g_pd3d->GetAdapterIdentifier(g_adpd.uAdapter, 0, &g_adpd.d3dai);
    if (FAILED(hr)) {
        return FALSE;
    }

    g_devd.d3ddt = g_devd.d3dcaps.DeviceType;

    hr = g_pd3d->GetAdapterDisplayMode(g_adpd.uAdapter, &g_dm.d3ddm);
    if (FAILED(hr)) {
        return FALSE;
    }

    g_dm.fmtd = g_dm.d3ddm.Format;

    g_disdCurrent.padpd = &g_adpd;
    g_disdCurrent.pdevd = &g_devd;
    g_disdCurrent.pdm = &g_dm;

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     UpdateVisibility
//
// Description:
//
//     Update the visibility information for the console so only the visible
//     text will be drawn.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL UpdateVisibility() {

    LPBYTE      pData;
    D3DVECTOR*  pvPos;
    float       fTop, fBottom;
    UINT        uTextVertices;
    UINT        i;
    HRESULT     hr;

    // Lock the position buffer
    hr = g_pd3drPosition->Lock(0, g_uVBPositionSize, &pData, 0);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::Lock"));
        return FALSE;
    }
    pvPos = (D3DVECTOR*)pData;

    fTop = -g_fTargetHeight - g_fCurrentRow * g_fCharHeight - g_fCharHeight;
    fBottom = -g_fCurrentRow * g_fCharHeight + g_fCharHeight;

    // Identify the visible text vertices
    uTextVertices = g_uTextSize * 4;
    for (i = 0; i < uTextVertices; i += 4) {
        if (pvPos[i].y > fTop && pvPos[i].y < fBottom) {
            g_uVStart1 = i;
            break;
        }
    }
    for (g_uVCount1 = 0; i < uTextVertices && (pvPos[i].y > fTop && pvPos[i].y < fBottom); i += 4, g_uVCount1 += 4);
    for (i += 4; i < uTextVertices; i += 4) {
        if (pvPos[i].y > fTop && pvPos[i].y < fBottom) {
            g_uVStart2 = i;
            break;
        }
    }
    for (g_uVCount2 = 0; i < uTextVertices && (pvPos[i].y > fTop && pvPos[i].y < fBottom); i += 4, g_uVCount2 += 4);

    hr = g_pd3drPosition->Unlock();
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::Unlock"));
        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     ValidateDisplay
//
// Description:
//
//     Evaluate the given display information in order to determine whether or
//     not the display is capable of rendering the scene.  If not, the given
//     display will not be included in the display list.
//
// Arguments:
//
//     LPDIRECT3D8 pd3d         - Pointer to the Direct3D object
//
//     D3DCAPS8* pd3dcaps       - Capabilities of the device
//
//     D3DDISPLAYMODE*          - Display mode into which the device
//                                will be placed
//
// Return Value:
//
//     TRUE if the scene can be rendered using the given display, FALSE if
//     it cannot.
//
//******************************************************************************
BOOL ValidateDisplay(LPDIRECT3D8 pd3d, D3DCAPS8* pd3dcaps, D3DDISPLAYMODE* pd3ddm) {

//if (pd3dcaps->DeviceType != D3DDEVTYPE_REF) return FALSE;
    return TRUE;
}

} // namespace DXCONIO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\d3denum.cpp ===
/*******************************************************************************

Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

File Name:

    d3denum.cpp

Description:

    Direct3D initialization routines.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3dinit.h"
#include "main.h"
#include "util.h"
#include "d3denum.h"

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#define D3DDEVTYPE_NULL ((D3DDEVTYPE)0)

//******************************************************************************
// Local function prototypes
//******************************************************************************

namespace DXCONIO {

static DWORD            SelectVertexPipeline(D3DCAPS8* pd3dcaps);
static D3DFORMAT        SelectDepthStencilFormat(LPDIRECT3D8 pd3d, 
                            UINT uAdapter, D3DDEVTYPE d3ddt, 
                            D3DFORMAT d3dfmtMode);
static
D3DMULTISAMPLE_TYPE     SelectMultiSampleType(LPDIRECT3D8 pd3d, UINT uAdapter, 
                            D3DDEVTYPE d3ddt, D3DFORMAT d3dfmtMode,
                            BOOL bWindowed);

//******************************************************************************
// Globals
//******************************************************************************

ADAPTERDESC             g_adpdDefault = {
                            (UINT)(-1), {0}, D3DFMT_UNKNOWN, NULL, NULL
                        };
DEVICEDESC              g_devdDefault = {
                            D3DDEVTYPE_NULL, {D3DDEVTYPE_NULL, 0}, 0, TRUE, D3DFMT_UNKNOWN, 
                            D3DMULTISAMPLE_NONE, NULL, NULL
                        };
DISPLAYMODE             g_dmDefault = {
                            {0}, D3DFMT_UNKNOWN, D3DMULTISAMPLE_NONE, NULL
                        };
D3DFORMAT               g_fmtdDefault = D3DFMT_UNKNOWN;

static CHECKDISPLAYPROC g_pfnValidate = NULL;

//******************************************************************************
//
// Function:
//
//     EnumDisplays
//
// Description:
//
//     Build a display device list containing information about all supported
//     adapters, devices, and display modes present on the system at the time
//     the Direct3D object was created.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     A pointer to the head of the display adapter list (NULL if no adapters
//     are supported).
//
//******************************************************************************
PADAPTERDESC EnumDisplays(LPDIRECT3D8 pd3d) {

    PADAPTERDESC        padpdHead = NULL, padpdNode;
    UINT                uAdapter, uNumAdapters;
    PDEVICEDESC         pdevdNode;
    D3DDISPLAYMODE      d3ddm;
    PDISPLAYMODE        pdmNode;
    UINT                uMode, uNumModes;
    D3DFORMAT           fmt;
    D3DMULTISAMPLE_TYPE d3dmst;
    HRESULT             hr;
    UINT                uDevice;
    D3DDEVTYPE          d3ddt[] = {
                            D3DDEVTYPE_HAL,
                            D3DDEVTYPE_SW,
                            D3DDEVTYPE_REF,
                        };

    if (!pd3d) {
        return NULL;
    }

    // Enumerate adapters
    uNumAdapters = pd3d->GetAdapterCount();

    for (uAdapter = 0; uAdapter < pd3d->GetAdapterCount(); uAdapter++) {

        // Allocate memory for the adapter information
        padpdNode = (PADAPTERDESC)MemAlloc(sizeof(ADAPTERDESC));
        if (!padpdNode) {
            DebugString(TEXT("ERROR: Not enough memory available to store adapter information"));
            break;
        }

        // Save the adapter number
        padpdNode->uAdapter = uAdapter;

        // Save the adapter idenifier
        hr = pd3d->GetAdapterIdentifier(uAdapter, 0, &padpdNode->d3dai);
        if (ResultFailed(hr, TEXT("IDirect3D8::GetDeviceIdentifier"))) {
            MemFree(padpdNode);
            continue;
        }

        // Save the initial display mode of the adapter (for use in windowed applications)
        hr = pd3d->GetAdapterDisplayMode(uAdapter, &d3ddm);
        if (ResultFailed(hr, TEXT("IDirect3D8::GetAdapterDisplayMode"))) {
            MemFree(padpdNode);
            continue;
        }
        padpdNode->fmtrWindowed = d3ddm.Format;

        padpdNode->pdevdList = NULL;

        // Enumerate devices
#ifndef UNDER_XBOX
        for (uDevice = 0; uDevice < 3; uDevice++) {
#else
        for (uDevice = 0; !uDevice; uDevice++) {
#endif // UNDER_XBOX

            // Allocate memory for the device information
            pdevdNode = (PDEVICEDESC)MemAlloc(sizeof(DEVICEDESC));
            if (!pdevdNode) {
                DebugString(TEXT("ERROR: Not enough memory available to store device information"));
                break;
            }

            // Save the device type
            pdevdNode->d3ddt = d3ddt[uDevice];
            
            // Save the caps
            hr = pd3d->GetDeviceCaps(uAdapter, d3ddt[uDevice], &pdevdNode->d3dcaps);
            if (ResultFailed(hr, TEXT("IDirect3D8::GetDeviceCaps"))) {
                MemFree(pdevdNode);
                continue;
            }

            // The device supports windowed mode if the caps exposes it and
            // the device can render to the initial display mode of the adapter
#ifndef UNDER_XBOX
            hr = g_pd3d->CheckDeviceType(uAdapter, d3ddt[uDevice], padpdNode->fmtrWindowed, padpdNode->fmtrWindowed, TRUE);
#else
            hr = D3DERR_NOTAVAILABLE;
#endif // DEMO_HACK
            pdevdNode->bCanRenderWindowed = ((pdevdNode->d3dcaps.Caps2 & D3DCAPS2_CANRENDERWINDOWED) && SUCCEEDED(hr));

            // Select where the vertex processing is to be performed
            pdevdNode->dwBehavior = SelectVertexPipeline(&pdevdNode->d3dcaps);

            if (SUCCEEDED(hr)) {

                // Select a depth/stencil buffer format for a windowed device
                pdevdNode->fmtdWindowed = SelectDepthStencilFormat(pd3d, uAdapter, d3ddt[uDevice], padpdNode->fmtrWindowed);

                // Select a multisample type for a windowed device
#ifndef UNDER_XBOX
                pdevdNode->d3dmstWindowed = SelectMultiSampleType(pd3d, uAdapter, d3ddt[uDevice], padpdNode->fmtrWindowed, TRUE);
#else
                pdevdNode->d3dmstWindowed = D3DMULTISAMPLE_NONE;
#endif
            }

            // Save the display modes supported by the adapter, device, and application
            uNumModes = pd3d->GetAdapterModeCount(uAdapter);
            pdevdNode->pdmList = NULL;

            for (uMode = 0; uMode < uNumModes; uMode++) {

                hr = pd3d->EnumAdapterModes(uAdapter, uMode, &d3ddm);
                if (ResultFailed(hr, TEXT("IDirect3D8::EnumAdapterModes"))) {
                    continue;
                }

                // Select a depth/stencil buffer format for the full screen display mode
                fmt = SelectDepthStencilFormat(pd3d, uAdapter, d3ddt[uDevice], d3ddm.Format);

                // Select a multisample type for the full screen display mode
                d3dmst = SelectMultiSampleType(pd3d, uAdapter, d3ddt[uDevice], d3ddm.Format, FALSE);

                // Check if the device supports the display mode format
                hr = pd3d->CheckDeviceType(uAdapter, d3ddt[uDevice], d3ddm.Format, d3ddm.Format, FALSE);
                if (FAILED(hr)) {
                    if (hr != D3DERR_INVALIDDEVICE) {
                        ResultFailed(hr, TEXT("IDirect3D8::CheckDeviceTypes"));
                    }
                    continue;
                }

                // Check if the application supports the display mode format
                if (g_pfnValidate && !g_pfnValidate(pd3d, &pdevdNode->d3dcaps, &d3ddm)) {
                    // The application rejected the mode, skip it
                    continue;
                }
                        
                // Allocate memory for the display mode information
                pdmNode = (PDISPLAYMODE)MemAlloc(sizeof(DISPLAYMODE));
                if (!pdmNode) {
                    DebugString(TEXT("ERROR: Not enough memory available to store display mode information"));
                    break;
                }

                // Save the display mode
                memcpy(&pdmNode->d3ddm, &d3ddm, sizeof(D3DDISPLAYMODE));

                // Save the selected depth/stencil format
                pdmNode->fmtd = fmt;

                // Save the selected multisample type
                pdmNode->d3dmst = d3dmst;

                // Add the display mode to the list
                pdmNode->pdmNext = pdevdNode->pdmList;
                pdevdNode->pdmList = pdmNode;
            }

            // If no display modes are supported by the device, skip it
            if (!pdevdNode->pdmList) {
                MemFree(pdevdNode);
                continue;
            }

            // Add the device to the list
            pdevdNode->pdevdNext = padpdNode->pdevdList;
            padpdNode->pdevdList = pdevdNode;
        }

        // If no devices are supported by the adapter, skip it
        if (!padpdNode->pdevdList) {
            MemFree(padpdNode);
            continue;
        }

        // Add the adapter to the list
        padpdNode->padpdNext = padpdHead;
        padpdHead = padpdNode;
    }

    return padpdHead;
}

//******************************************************************************
void InitCheckDisplayProc(CHECKDISPLAYPROC pfnValidate) {
    
    g_pfnValidate = pfnValidate;
}

//******************************************************************************
// Initialization functions
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     SelectAdapter
//
// Description:
//
//     Select a default adapter for the application from a list of available
//     adapters.
//
// Arguments:
//
//     PADAPTERDESC padpdList   - List of the available adapters.
//
// Return Value:
//
//     A pointer to the selected adapter in the list.
//
//******************************************************************************
PADAPTERDESC SelectAdapter(PADAPTERDESC padpdList) {

    PADAPTERDESC padpd;

    if (!padpdList) {
        return NULL;
    }

    // Look for the default adapter in the list
    if (g_adpdDefault.uAdapter != (UINT)(-1)) {
        for (padpd = padpdList; padpd; padpd = padpd->padpdNext) {
            if (padpd->uAdapter == g_adpdDefault.uAdapter) 
            {
                return padpd;
            }
        }
    }

    // Select the primary display adapter
    for (padpd = padpdList; padpd; padpd = padpd->padpdNext) {

        if (padpd->uAdapter == 0) {
            return padpd;
        }
    }

    return padpdList;
}

//******************************************************************************
//
// Function:
//
//     SelectDevice
//
// Description:
//
//     Select the default device for the application from a list of available
//     devices.
//
// Arguments:
//
//     PADAPTERDESC padpd       - The adapter from which to select the default
//                                device.
//
// Return Value:
//
//     A pointer to the selected device in the list.
//
//******************************************************************************
PDEVICEDESC SelectDevice(PADAPTERDESC padpd) {

    PDEVICEDESC pdevd,
                pdevdSelection = NULL;

    if (!padpd) {
        return NULL;
    }

    // Look for the default device in the list
    if (g_devdDefault.d3ddt != D3DDEVTYPE_NULL) {
        for (pdevd = padpd->pdevdList; pdevd; pdevd = pdevd->pdevdNext) {
            if (pdevd->d3ddt == g_devdDefault.d3ddt) {
                return pdevd;
            }
        }
    }

    for (pdevd = padpd->pdevdList; pdevd; pdevd = pdevd->pdevdNext) {

        // If the device is a HAL device, select it and return
        if (pdevd->d3ddt == D3DDEVTYPE_HAL) {
            return pdevd;
        }

        // If the device is an emulation device, save it and keep looking
        if (pdevd->d3ddt == D3DDEVTYPE_SW) {
            pdevdSelection = pdevd;
        }

        // If no device has yet been selected, save the reference device 
        // and keep looking
        if (!pdevdSelection) {
            pdevdSelection = pdevd;
        }
    }

    return pdevdSelection;
}

//******************************************************************************
//
// Function:
//
//     SelectDisplayMode
//
// Description:
//
//     Select the default display mode for the application from a list of 
//     display modes available to the given device.
//
// Arguments:
//
//     PDEVICEDESC pdevd        - The device from which to select the default
//                                display mode.
//
// Return Value:
//
//     A pointer to the selected display mode in the list.
//
//******************************************************************************
PDISPLAYMODE SelectDisplayMode(PDEVICEDESC pdevd) {

    PDISPLAYMODE pdm;

    if (!pdevd) {
        return NULL;
    }

    // Look for the default display mode in the list
    if (g_dmDefault.d3ddm.Width != 0 && g_dmDefault.d3ddm.Height != 0) {
        for (pdm = pdevd->pdmList; pdm; pdm = pdm->pdmNext) {
            if (pdm->d3ddm.Width == g_dmDefault.d3ddm.Width && 
                pdm->d3ddm.Height == g_dmDefault.d3ddm.Height &&
                pdm->d3ddm.Format == g_dmDefault.d3ddm.Format) 
            {
                if (pdm->d3ddm.RefreshRate == g_dmDefault.d3ddm.RefreshRate ||
                    g_dmDefault.d3ddm.RefreshRate == 0) 
                {
                    return pdm;
                }
            }
        }
    }

    for (pdm = pdevd->pdmList; pdm; pdm = pdm->pdmNext) {

        if (pdm->d3ddm.Width == 640 && pdm->d3ddm.Height == 480 &&
            FormatToBitDepth(pdm->d3ddm.Format) == 16) 
        {
            return pdm;
        }
    }

    return pdevd->pdmList;
}

//******************************************************************************
static DWORD SelectVertexPipeline(D3DCAPS8* pd3dcaps) {

    if (pd3dcaps->DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) {
        return D3DCREATE_HARDWARE_VERTEXPROCESSING;
    }
    else {
        return D3DCREATE_SOFTWARE_VERTEXPROCESSING;
    }
}

//******************************************************************************
static D3DFORMAT SelectDepthStencilFormat(LPDIRECT3D8 pd3d, 
                                UINT uAdapter, D3DDEVTYPE d3ddt, 
                                D3DFORMAT d3dfmtMode)
{
    HRESULT     hr;
    UINT        i;
    D3DFORMAT   d3dfmt[] = {
                    D3DFMT_D24S8,
#ifndef UNDER_XBOX
                    D3DFMT_D24X4S4,
                    D3DFMT_D15S1,
                    D3DFMT_D32,
                    D3DFMT_D24X8,
#else
                    D3DFMT_F24S8,
#endif // UNDER_XBOX
                    D3DFMT_D16_LOCKABLE,
                    D3DFMT_D16,
#ifdef UNDER_XBOX
                    D3DFMT_F16,
#endif // UNDER_XBOX
                };

    if (g_fmtdDefault != D3DFMT_UNKNOWN) {
        hr = pd3d->CheckDeviceFormat(uAdapter, d3ddt, d3dfmtMode, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, g_fmtdDefault);
        if (FAILED(hr)) {
            if (hr != D3DERR_NOTAVAILABLE) {
                ResultFailed(hr, TEXT("IDirect3D8::CheckDeviceFormats"));
            }
        }
        else {
            return g_fmtdDefault;
        }
    }

    for (i = 0; i < 7; i++) {
        hr = pd3d->CheckDeviceFormat(uAdapter, d3ddt, d3dfmtMode, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, d3dfmt[i]);
        if (FAILED(hr)) {
            if (hr != D3DERR_NOTAVAILABLE) {
                ResultFailed(hr, TEXT("IDirect3D8::CheckDeviceFormats"));
            }
        }
        else {
            return d3dfmt[i];
        }
    }

    return D3DFMT_UNKNOWN;
}

//******************************************************************************
static D3DMULTISAMPLE_TYPE SelectMultiSampleType(LPDIRECT3D8 pd3d, UINT uAdapter, 
                                D3DDEVTYPE d3ddt, D3DFORMAT d3dfmtMode,
                                BOOL bWindowed)
{
    UINT    i;
    HRESULT hr;

    for (i = 16; i > 0; i--) {

        hr = pd3d->CheckDeviceMultiSampleType(uAdapter, d3ddt, d3dfmtMode, bWindowed, (D3DMULTISAMPLE_TYPE)i);
        if (FAILED(hr)) {
            if (hr != D3DERR_NOTAVAILABLE) {
                ResultFailed(hr, TEXT("IDirect3D8::CheckDeviceMultiSampleTypes"));
            }
        }
        else {
            return (D3DMULTISAMPLE_TYPE)i;
        }
    }

    return D3DMULTISAMPLE_NONE;
}

DWORD FormatToBitDepth(D3DFORMAT d3dfmt) {

    switch (d3dfmt) {
        case D3DFMT_R3G3B2:
        case D3DFMT_A8:
        case D3DFMT_P8:
        case D3DFMT_L8:
        case D3DFMT_A4L4:
            return 8;
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
        case D3DFMT_A1R5G5B5:
        case D3DFMT_A4R4G4B4:
        case D3DFMT_A8R3G3B2:
        case D3DFMT_X4R4G4B4:
        case D3DFMT_A8P8:
        case D3DFMT_A8L8:
        case D3DFMT_V8U8:
        case D3DFMT_L6V5U5:
#ifndef UNDER_XBOX
        case D3DFMT_D16_LOCKABLE:
#endif // !UNDER_XBOX
        case D3DFMT_D16:
        case D3DFMT_D15S1:
            return 16;
        case D3DFMT_R8G8B8:
            return 24;
        case D3DFMT_A8R8G8B8:
        case D3DFMT_X8R8G8B8:
#ifndef UNDER_XBOX
        case D3DFMT_X8L8V8U8:
#endif // !UNDER_XBOX
        case D3DFMT_Q8W8V8U8:
        case D3DFMT_V16U16:
        case D3DFMT_W11V11U10:
        case D3DFMT_D32:
        case D3DFMT_D24S8:
#ifndef UNDER_XBOX
        case D3DFMT_D24X8:
#endif // !UNDER_XBOX
        case D3DFMT_D24X4S4:
            return 32;
        default:
            return 0;
    }
}

} // namespace DXCONIO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\conio.h ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    conio.h

Description:

    Console and text output functions.

*******************************************************************************/

#ifndef __CONIO_H__
#define __CONIO_H__

//******************************************************************************
// Function prototypes
//******************************************************************************

BOOL LoadConsole();
void UnloadConsole();

#endif //__CONIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\fontmap.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    fontmap.cpp

Description:

    Functions for creating and indexing into a font texture.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#ifdef UNDER_XBOX
#include <xgraphics.h>
#endif
#include "d3dinit.h"
#include "util.h"
#include "fontmap.h"

namespace DXCONIO {

//******************************************************************************
// Globals
//******************************************************************************

LPDIRECT3DTEXTURE8          g_pd3dtFontMap = NULL;
TCOORD                      g_ptcFont[96];

static BYTE g_bFontPixels[120][12] = {

    {0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x18, 0x66, 0x36, 0x3C, 0xD8, 0x38, 0x18, 0x0C, 0x30, 0x00, 0x00},
    {0x00, 0x3C, 0x66, 0x36, 0x66, 0xDA, 0x6C, 0x18, 0x18, 0x18, 0x00, 0x00},
    {0x00, 0x3C, 0x66, 0x7F, 0x60, 0x76, 0x6C, 0x18, 0x18, 0x18, 0x36, 0x18},
    {0x00, 0x3C, 0x00, 0x36, 0x30, 0x0C, 0x38, 0x00, 0x30, 0x0C, 0x1C, 0x18},
    {0x00, 0x18, 0x00, 0x36, 0x18, 0x18, 0x60, 0x00, 0x30, 0x0C, 0x7F, 0x7E},
    {0x00, 0x18, 0x00, 0x36, 0x0C, 0x30, 0x6F, 0x00, 0x30, 0x0C, 0x1C, 0x18},
    {0x00, 0x00, 0x00, 0x7F, 0x06, 0x6E, 0x66, 0x00, 0x30, 0x0C, 0x36, 0x18},
    {0x00, 0x18, 0x00, 0x36, 0x66, 0x5B, 0x66, 0x00, 0x30, 0x0C, 0x00, 0x00},
    {0x00, 0x18, 0x00, 0x36, 0x3C, 0x1B, 0x3B, 0x00, 0x18, 0x18, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x18, 0x0E, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x0C, 0x30, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x06, 0x1E, 0x0C, 0x3C, 0x3C, 0x30, 0x7E, 0x1C, 0x7E},
    {0x00, 0x00, 0x00, 0x06, 0x33, 0x1C, 0x66, 0x66, 0x30, 0x60, 0x18, 0x06},
    {0x00, 0x00, 0x00, 0x0C, 0x37, 0x7C, 0x66, 0x66, 0x36, 0x60, 0x30, 0x0C},
    {0x00, 0x00, 0x00, 0x0C, 0x37, 0x0C, 0x06, 0x06, 0x36, 0x60, 0x7C, 0x0C},
    {0x00, 0x7E, 0x00, 0x18, 0x33, 0x0C, 0x0C, 0x1C, 0x36, 0x7C, 0x66, 0x18},
    {0x00, 0x00, 0x00, 0x18, 0x3B, 0x0C, 0x18, 0x06, 0x66, 0x06, 0x66, 0x18},
    {0x00, 0x00, 0x00, 0x30, 0x3B, 0x0C, 0x30, 0x66, 0x7F, 0x06, 0x66, 0x30},
    {0x1C, 0x00, 0x1C, 0x30, 0x33, 0x0C, 0x60, 0x66, 0x06, 0x0C, 0x66, 0x30},
    {0x1C, 0x00, 0x1C, 0x60, 0x1E, 0x0C, 0x7E, 0x3C, 0x06, 0x78, 0x3C, 0x30},
    {0x0C, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x3C, 0x3C, 0x00, 0x00, 0x06, 0x00, 0x60, 0x3C, 0x7E, 0x18, 0x7C, 0x3C},
    {0x66, 0x66, 0x00, 0x00, 0x0C, 0x00, 0x30, 0x66, 0xC3, 0x3C, 0x66, 0x66},
    {0x66, 0x66, 0x1C, 0x1C, 0x18, 0x00, 0x18, 0x66, 0xC3, 0x66, 0x66, 0x66},
    {0x76, 0x66, 0x1C, 0x1C, 0x30, 0x7E, 0x0C, 0x0C, 0xCF, 0x66, 0x66, 0x60},
    {0x3C, 0x66, 0x00, 0x00, 0x60, 0x00, 0x06, 0x18, 0xDB, 0x66, 0x7C, 0x60},
    {0x6E, 0x3E, 0x00, 0x00, 0x30, 0x7E, 0x0C, 0x18, 0xDB, 0x7E, 0x66, 0x60},
    {0x66, 0x0C, 0x00, 0x00, 0x18, 0x00, 0x18, 0x00, 0xCF, 0x66, 0x66, 0x66},
    {0x66, 0x18, 0x1C, 0x1C, 0x0C, 0x00, 0x30, 0x18, 0xC0, 0x66, 0x66, 0x66},
    {0x3C, 0x38, 0x1C, 0x1C, 0x06, 0x00, 0x60, 0x18, 0x7F, 0x66, 0x7C, 0x3C},
    {0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x78, 0x7E, 0x7E, 0x3C, 0x66, 0x3C, 0x06, 0x66, 0x60, 0x63, 0x63, 0x3C},
    {0x6C, 0x60, 0x60, 0x66, 0x66, 0x18, 0x06, 0x66, 0x60, 0x63, 0x63, 0x66},
    {0x66, 0x60, 0x60, 0x66, 0x66, 0x18, 0x06, 0x6C, 0x60, 0x77, 0x73, 0x66},
    {0x66, 0x60, 0x60, 0x60, 0x66, 0x18, 0x06, 0x6C, 0x60, 0x6B, 0x7B, 0x66},
    {0x66, 0x7C, 0x7C, 0x60, 0x7E, 0x18, 0x06, 0x78, 0x60, 0x6B, 0x6F, 0x66},
    {0x66, 0x60, 0x60, 0x6E, 0x66, 0x18, 0x06, 0x6C, 0x60, 0x6B, 0x67, 0x66},
    {0x66, 0x60, 0x60, 0x66, 0x66, 0x18, 0x66, 0x6C, 0x60, 0x63, 0x63, 0x66},
    {0x6C, 0x60, 0x60, 0x66, 0x66, 0x18, 0x66, 0x66, 0x60, 0x63, 0x63, 0x66},
    {0x78, 0x7E, 0x60, 0x3E, 0x66, 0x3C, 0x3C, 0x66, 0x7E, 0x63, 0x63, 0x3C},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x7C, 0x3C, 0x7C, 0x3C, 0x7E, 0x66, 0x66, 0x63, 0x66, 0x66, 0x7E, 0x3C},
    {0x66, 0x66, 0x66, 0x66, 0x18, 0x66, 0x66, 0x63, 0x66, 0x66, 0x06, 0x30},
    {0x66, 0x66, 0x66, 0x60, 0x18, 0x66, 0x66, 0x63, 0x34, 0x66, 0x06, 0x30},
    {0x66, 0x66, 0x66, 0x30, 0x18, 0x66, 0x66, 0x6B, 0x18, 0x66, 0x0C, 0x30},
    {0x7C, 0x66, 0x7C, 0x18, 0x18, 0x66, 0x66, 0x6B, 0x18, 0x3C, 0x18, 0x30},
    {0x60, 0x66, 0x6C, 0x0C, 0x18, 0x66, 0x66, 0x6B, 0x2C, 0x18, 0x30, 0x30},
    {0x60, 0x66, 0x66, 0x06, 0x18, 0x66, 0x66, 0x36, 0x66, 0x18, 0x60, 0x30},
    {0x60, 0x66, 0x66, 0x66, 0x18, 0x66, 0x3C, 0x36, 0x66, 0x18, 0x60, 0x30},
    {0x60, 0x3C, 0x66, 0x3C, 0x18, 0x3C, 0x18, 0x36, 0x66, 0x18, 0x7E, 0x30},
    {0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30},
    {0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x18, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x3C, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x60, 0x3C, 0x66, 0x00, 0x0C, 0x00, 0x60, 0x00, 0x06, 0x00, 0x1E, 0x00},
    {0x60, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x06, 0x00, 0x30, 0x00},
    {0x30, 0x0C, 0x00, 0x00, 0x00, 0x3C, 0x7C, 0x3C, 0x3E, 0x3C, 0x30, 0x3E},
    {0x30, 0x0C, 0x00, 0x00, 0x00, 0x06, 0x66, 0x66, 0x66, 0x66, 0x30, 0x66},
    {0x18, 0x0C, 0x00, 0x00, 0x00, 0x06, 0x66, 0x60, 0x66, 0x66, 0x7E, 0x66},
    {0x18, 0x0C, 0x00, 0x00, 0x00, 0x3E, 0x66, 0x60, 0x66, 0x7E, 0x30, 0x66},
    {0x0C, 0x0C, 0x00, 0x00, 0x00, 0x66, 0x66, 0x60, 0x66, 0x60, 0x30, 0x66},
    {0x0C, 0x0C, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x60, 0x30, 0x66},
    {0x06, 0x0C, 0x00, 0x00, 0x00, 0x3E, 0x7C, 0x3C, 0x3E, 0x3C, 0x30, 0x3E},
    {0x06, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06},
    {0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06},
    {0x00, 0x3C, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x60, 0x18, 0x0C, 0x60, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x60, 0x00, 0x00, 0x60, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x7C, 0x78, 0x3C, 0x66, 0x18, 0x7E, 0x7C, 0x3C, 0x7C, 0x3E, 0x66, 0x3E},
    {0x66, 0x18, 0x0C, 0x66, 0x18, 0x6B, 0x66, 0x66, 0x66, 0x66, 0x6E, 0x60},
    {0x66, 0x18, 0x0C, 0x6C, 0x18, 0x6B, 0x66, 0x66, 0x66, 0x66, 0x70, 0x60},
    {0x66, 0x18, 0x0C, 0x78, 0x18, 0x6B, 0x66, 0x66, 0x66, 0x66, 0x60, 0x3C},
    {0x66, 0x18, 0x0C, 0x6C, 0x18, 0x6B, 0x66, 0x66, 0x66, 0x66, 0x60, 0x06},
    {0x66, 0x18, 0x0C, 0x66, 0x18, 0x6B, 0x66, 0x66, 0x66, 0x66, 0x60, 0x06},
    {0x66, 0x7E, 0x0C, 0x66, 0x7E, 0x63, 0x66, 0x3C, 0x7C, 0x3E, 0x60, 0x7C},
    {0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x06, 0x00, 0x00},
    {0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x06, 0x00, 0x00},
    {0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x06, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x18, 0x30, 0x71, 0x7E},
    {0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xDB, 0x7E},
    {0x7E, 0x66, 0x66, 0x63, 0x66, 0x66, 0x7E, 0x18, 0x18, 0x18, 0x8E, 0x7E},
    {0x30, 0x66, 0x66, 0x6B, 0x66, 0x66, 0x06, 0x18, 0x18, 0x18, 0x00, 0x7E},
    {0x30, 0x66, 0x66, 0x6B, 0x3C, 0x66, 0x0C, 0x30, 0x18, 0x0C, 0x00, 0x7E},
    {0x30, 0x66, 0x66, 0x6B, 0x18, 0x66, 0x18, 0x60, 0x18, 0x06, 0x00, 0x7E},
    {0x30, 0x66, 0x66, 0x6B, 0x3C, 0x66, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x7E},
    {0x30, 0x66, 0x3C, 0x36, 0x66, 0x66, 0x60, 0x18, 0x18, 0x18, 0x00, 0x7E},
    {0x1E, 0x3E, 0x18, 0x36, 0x66, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x00, 0x7E},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x18, 0x18, 0x18, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x0C, 0x18, 0x30, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
};

//******************************************************************************
//
// Function:
//
//     CreateFontMap
//
// Description:
//
//     Create a texture and populate it with font information to be used to
//     output text.  Build a texture coordinate table containing the positions
//     of characters in the font map.
//
// Arguments:
//
//     D3DFORMAT fmt            - Format of the texture
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CreateFontMap(D3DFORMAT fmt) {

    D3DLOCKED_RECT  d3dlr;
    UINT            i, j;
    float           fU, fV;
    HRESULT         hr;
#ifdef UNDER_XBOX
    Swizzler        swz(128, 128, 1);
#endif

    if (!fmt) {
        fmt = D3DFMT_A4R4G4B4;
    }

    // Verify the current device supports the given format
    hr = g_pd3d->CheckDeviceFormat(g_disdCurrent.padpd->uAdapter, 
                                    g_disdCurrent.pdevd->d3ddt, 
                                    g_disdCurrent.pdm->d3ddm.Format, 
                                    0, D3DRTYPE_TEXTURE, fmt);
    if (FAILED(hr)) {
        if (hr != D3DERR_NOTAVAILABLE) {
            ResultFailed(hr, TEXT("IDirect3D8::CheckDeviceFormats"));
        }
        return NULL;
    }

    // Create the text map texture
    hr = g_pd3dDevice->CreateTexture(128, 128, 1, 0, 
                                    fmt, D3DPOOL_DEFAULT, &g_pd3dtFontMap);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DDevice8::CreateMipMap"));
        return NULL;
    }

    // Lock the texture
    hr = g_pd3dtFontMap->LockRect(0, &d3dlr, NULL, 0);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DMipMap8::LockRect"));
        ReleaseFontMap();
        return FALSE;
    }

#ifdef UNDER_XBOX
    swz.SetU(0);
    swz.SetV(0);
#endif

    if (FormatToBitDepth(fmt) == 16) {

        WORD    wBlack = 0;
        WORD    wWhite = 0xFFFF;
        LPWORD  pwPixel;
        DWORD   dwPitch;
        UINT    i, j;

        pwPixel = (LPWORD)d3dlr.pBits;

        dwPitch = d3dlr.Pitch / 2;

#ifdef UNDER_XBOX
        if (!XGIsSwizzledFormat(fmt)) {
#endif

            for (i = 0; i < 128; i++) {

                for (j = 0; j < 128; j++) {

                    if (i < 120 && j < 96 && 
//                        ((g_bFontPixels[i][j/8] >> (7-j%8)) & 0x1))) 
                        (g_bFontPixels[i][j/8] & (0x1 << (7-j%8))))
                    {
                        pwPixel[j] = wWhite;
                    }
                    else {
                        pwPixel[j] = wBlack;
                    }
                }

                pwPixel += dwPitch;
            }

#ifdef UNDER_XBOX

        }
        else {

            for (i = 0; i < 128; i++, swz.IncV()) {

                for (j = 0; j < 128; j++, swz.IncU()) {

                    if (i < 120 && j < 96 && 
                        (g_bFontPixels[i][j/8] & (0x1 << (7-j%8))))
                    {
                        pwPixel[swz.Get2D()] = wWhite;
                    }
                    else {
                        pwPixel[swz.Get2D()] = wBlack;
                    }
                }
            }
        }
#endif

    }

    else if (FormatToBitDepth(fmt) == 32) {

        DWORD   dwBlack = 0;
        DWORD   dwWhite = 0xFFFFFFFF;
        LPDWORD pdwPixel;
        DWORD   dwPitch;
        UINT    i, j;

        pdwPixel = (LPDWORD)d3dlr.pBits;

        dwPitch = d3dlr.Pitch / 4;

#ifdef UNDER_XBOX
        if (!XGIsSwizzledFormat(fmt)) {
#endif

            for (i = 0; i < 128; i++) {

                for (j = 0; j < 128; j++) {

                    if (i < 120 && j < 96 && 
    //                    ((g_bFontPixels[i][j/8] >> (7-j%8)) & 0x1))) 
                        (g_bFontPixels[i][j/8] & (0x1 << (7-j%8))))
                    {
                        pdwPixel[j] = dwWhite;
                    }
                    else {
                        pdwPixel[j] = dwBlack;
                    }
                }

                pdwPixel += dwPitch;
            }

#ifdef UNDER_XBOX

        }
        else {

            for (i = 0; i < 128; i++, swz.IncV()) {

                for (j = 0; j < 128; j++, swz.IncU()) {

                    if (i < 120 && j < 96 && 
                        (g_bFontPixels[i][j/8] & (0x1 << (7-j%8))))
                    {
                        pdwPixel[swz.Get2D()] = dwWhite;
                    }
                    else {
                        pdwPixel[swz.Get2D()] = dwBlack;
                    }
                }
            }
        }
#endif

    }

    else {

        return FALSE;
    }

    // Unlock the texture
    hr = g_pd3dtFontMap->UnlockRect(0);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DMipMap8::UnlockRect"));
        ReleaseFontMap();
        return FALSE;
    }

    // Build the texture coordinate table
    for (i = 0, fV = 0.0f; i < 8; i++, fV += FONT_TCOORD_HEIGHT) {

        for (j = 0, fU = 0.0f; j < 12; j++, fU += FONT_TCOORD_WIDTH) {

            g_ptcFont[i*12+j].u = fU + 0.00390625f; // add a half texel bias
            g_ptcFont[i*12+j].v = fV - 0.00390625f; // add a half texel bias
        }
    }

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     ReleaseFontMap
//
// Description:
//
//     Release the font texture map.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void ReleaseFontMap() {

    if (g_pd3dtFontMap) {
        g_pd3dtFontMap->Release();
        g_pd3dtFontMap = NULL;
    }
}

} // namespace DXCONIO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\main.h ===
/*******************************************************************************

Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

File Name:

    main.h

Description:

    Application entry point and window procedure.

*******************************************************************************/

#ifndef __MAIN_H__
#define __MAIN_H__

//******************************************************************************
// Function prototypes
//******************************************************************************

BOOL __cdecl ConsoleStartup();
void __cdecl ConsoleShutdown();

#endif //__MAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\d3denum.h ===
/*******************************************************************************

Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

File Name:

    d3denum.h

Description:

    Direct3D enumeration routines.

*******************************************************************************/

#ifndef __D3DENUM_H__
#define __D3DENUM_H__

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

//******************************************************************************
// Macros
//******************************************************************************

#define ANTIALIAS_SUPPORTED(pdevd, pdm, bWindowed) \
    ((bWindowed && pdevd->d3dmstWindowed != D3DMULTISAMPLE_NONE) || \
    (!bWindowed && pdm->d3dmst != D3DMULTISAMPLE_NONE))

namespace DXCONIO {

//******************************************************************************
// Data types
//******************************************************************************

typedef BOOL (* CHECKDISPLAYPROC)(LPDIRECT3D8, D3DCAPS8*, D3DDISPLAYMODE*);

//******************************************************************************
// Structures
//******************************************************************************

//******************************************************************************
// Description of a display mode
typedef struct _DISPLAYMODE {
    D3DDISPLAYMODE              d3ddm;
    D3DFORMAT                   fmtd;
    D3DMULTISAMPLE_TYPE         d3dmst;
    struct _DISPLAYMODE*        pdmNext;
} DISPLAYMODE, *PDISPLAYMODE;

//******************************************************************************
// Description of a device
typedef struct _DEVICEDESC {
    D3DDEVTYPE                  d3ddt;
    D3DCAPS8                    d3dcaps;
    DWORD                       dwBehavior;
    BOOL                        bCanRenderWindowed;
    D3DFORMAT                   fmtdWindowed;
    D3DMULTISAMPLE_TYPE         d3dmstWindowed;
    PDISPLAYMODE                pdmList;
    struct _DEVICEDESC*         pdevdNext;
} DEVICEDESC, *PDEVICEDESC;

//******************************************************************************
// Description of an adapter
typedef struct _ADAPTERDESC {
    UINT                        uAdapter;
    D3DADAPTER_IDENTIFIER8      d3dai;
    D3DFORMAT                   fmtrWindowed;
    PDEVICEDESC                 pdevdList;
    struct _ADAPTERDESC*        padpdNext;
} ADAPTERDESC, *PADAPTERDESC;

//******************************************************************************
// Globals
//******************************************************************************

extern ADAPTERDESC              g_adpdDefault;
extern DEVICEDESC               g_devdDefault;
extern DISPLAYMODE              g_dmDefault;
extern D3DFORMAT                g_fmtdDefault;

//******************************************************************************
// Function prototypes
//******************************************************************************

PADAPTERDESC        EnumDisplays(LPDIRECT3D8 pd3d);

PADAPTERDESC        SelectAdapter(PADAPTERDESC padpdList);
PDEVICEDESC         SelectDevice(PADAPTERDESC padpd);
PDISPLAYMODE        SelectDisplayMode(PDEVICEDESC pdevd);

DWORD               FormatToBitDepth(D3DFORMAT d3dfmt);

void                InitCheckDisplayProc(CHECKDISPLAYPROC pfnValidate);

} // namespace DXCONIO

#endif //__D3DENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\d3dinit.h ===
/*******************************************************************************

Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

File Name:

    d3dinit.h

Description:

    Direct3D initialization routines.

*******************************************************************************/

#ifndef __D3DINIT_H__
#define __D3DINIT_H__

#include "d3denum.h"

#ifdef UNDER_XBOX
#define DEMO_HACK
#endif

#ifdef DEMO_HACK
#define D3DFMT_D24S8            ((D3DFORMAT)0xFFFF0001)
#define D3DFMT_D24X4S4          ((D3DFORMAT)0xFFFF0002)
#define D3DFMT_D15S1            ((D3DFORMAT)0xFFFF0003)
#define D3DFMT_D32              ((D3DFORMAT)0xFFFF0004)
#define D3DFMT_R3G3B2           ((D3DFORMAT)0xFFFF0005)
#define D3DFMT_A4L4             ((D3DFORMAT)0xFFFF0006)
#define D3DFMT_A8R3G3B2         ((D3DFORMAT)0xFFFF0007)
#define D3DFMT_X4R4G4B4         ((D3DFORMAT)0xFFFF0008)
#define D3DFMT_A8P8             ((D3DFORMAT)0xFFFF0009)
#define D3DFMT_R8G8B8           ((D3DFORMAT)0xFFFF000A)
#define D3DFMT_W11V11U10        ((D3DFORMAT)0xFFFF000B)
#endif

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#define KEY_LEFT                0x0001
#define KEY_RIGHT               0x0002
#define KEY_UP                  0x0004
#define KEY_DOWN                0x0008
#define KEY_ADD                 0x0010
#define KEY_SUBTRACT            0x0020
#define KEY_HOME                0x0040
#define KEY_END                 0x0080
#define KEY_INSERT              0x0100
#define KEY_DELETE              0x0200
#define KEY_PAGEUP              0x0400
#define KEY_PAGEDOWN            0x0800
#define KEY_SHIFT               0x1000

namespace DXCONIO {

//******************************************************************************
// Data types
//******************************************************************************

typedef DWORD                   KEYSDOWN;

typedef BOOL                    (* SETDEVICEPROC)(void);
typedef void                    (* CLEARDEVICEPROC)(void);
typedef BOOL                    (* SUBWNDPROC)(LRESULT*, HWND, UINT, WPARAM, LPARAM);

//******************************************************************************
// Structures
//******************************************************************************

//******************************************************************************
typedef struct _DISPLAYDESC {
    PADAPTERDESC    padpd;
    PDEVICEDESC     pdevd;
    PDISPLAYMODE    pdm;
    BOOL            bWindowed;
    BOOL            bDepthBuffer;
    BOOL            bAntialias;
} DISPLAYDESC, *PDISPLAYDESC;

//******************************************************************************
typedef struct _D3DCREATIONDESC {
    D3DDEVTYPE      d3ddt;
    BOOL            bWindowed;
    D3DDISPLAYMODE  d3ddm;
    RECT            rectWnd;
    BOOL            bDepthBuffer;
    D3DFORMAT       fmtd;
    BOOL            bAntialias;
} D3DCREATIONDESC, *PD3DCREATIONDESC;

//******************************************************************************
typedef struct _CAMERA {
	D3DXVECTOR3     vPosition;
	D3DXVECTOR3     vInterest;
	float           fRoll;
	float           fFieldOfView;
	float           fNearPlane;
	float           fFarPlane;
} CAMERA, *PCAMERA;

//******************************************************************************
typedef struct _TCOORD {
    float           u;
    float           v;
} TCOORD, *PTCOORD;

//******************************************************************************
// Globals
//******************************************************************************

extern LPDIRECT3D8              g_pd3d;
extern LPDIRECT3DDEVICE8        g_pd3dDevice;
extern D3DPRESENT_PARAMETERS    g_d3dpp;
extern D3DSURFACE_DESC          g_d3dsdBack;
extern PADAPTERDESC             g_padpdList;
extern DISPLAYDESC              g_disdCurrent;
extern HWND						g_hWnd;
extern RECT                     g_rectWnd;
extern BOOL                     g_bActive;
extern KEYSDOWN                 g_kdKeys;
extern CAMERA                   g_cam;
extern float                    g_fCameraTDelta;
extern float                    g_fCameraRDelta;
extern float                    g_fTimeDilation;

//******************************************************************************
// Function prototypes
//******************************************************************************

BOOL                CreateDirect3D(PD3DCREATIONDESC pd3dcd = NULL);
void                ReleaseDirect3D();

BOOL                RestoreDisplay();

BOOL                UpdateDisplay(PDISPLAYMODE pdm, BOOL bWindowed, 
                                    BOOL bDepthBuffer, BOOL bAntialias);
BOOL                MoveWindowTarget(int x, int y);
BOOL                SizeWindowTarget(int width, int height);

void                DisplayFrameRate();

void                SelectDisplay();

void                InitSetDeviceProc(SETDEVICEPROC pfnSetDevice);
void                InitClearDeviceProc(CLEARDEVICEPROC pfnClearDevice);
void                InitSubWindowProc(SUBWNDPROC pfnSubWndProc);

BOOL                SetCameraView(PCAMERA pcam);
void                UpdateCamera(PCAMERA pcam);

} // namespace DXCONIO

#endif //__D3DINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\noise.cpp ===
#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <math.h>
#include "noise.h"

namespace DXCONIO {

//******************************************************************************
// CPerlinNoise
//******************************************************************************

UINT CPerlinNoise::m_puPrimes[3][PRIME_TABLE_ENTRIES] = {0};

//******************************************************************************
CPerlinNoise::CPerlinNoise(float fPersistence, UINT uOctaves, DWORD dwSeed, 
                                            INTERPOLATIONTYPE irp, BOOL bClamp) 
{
    if (!m_puPrimes[0][0]) {

        UINT i, j, k;
        UINT uBase[] = {
                10000,
                770000,
                1376310000,
        };

        // Find the first PRIME_TABLE_ENTRIES prime numbers that proceed 3 base numbers
        for (i = 0; i < 3; i++) {
            for (j = 0, k = uBase[i]; j < PRIME_TABLE_ENTRIES; k++) {
                if (IsPrime(k)) {
                    m_puPrimes[i][j++] = k;
                }
            }
        }
    }

    m_fPersistence = fPersistence;
    m_uOctaves = uOctaves;
    m_dwSeed = dwSeed;
    switch (irp) {
        case INTERPOLATE_LINEAR:
            m_pfnInterpolate = CPerlinNoise::InterpolateLinear;
            break;
        case INTERPOLATE_COSINE:
        default:
            m_pfnInterpolate = CPerlinNoise::InterpolateCosine;
            break;
    }
    m_bClamp = bClamp;
    m_fRangeBase = 0.0f;
    m_fRangeMagnitude = 1.0f;

    if (uOctaves > MAX_OCTAVES) {
        DebugBreak();
    }

    InitPrimesList(uOctaves, dwSeed);
}

//******************************************************************************
CPerlinNoise::~CPerlinNoise() {
}

//******************************************************************************
void CPerlinNoise::SetPersistence(float fPersistence) {

    m_fPersistence = fPersistence;
}

//******************************************************************************
void CPerlinNoise::SetOctaves(UINT uOctaves) {

    if (uOctaves > MAX_OCTAVES) {
        return;
    }

    m_uOctaves = uOctaves;

    InitPrimesList(uOctaves, m_dwSeed);
}

//******************************************************************************
void CPerlinNoise::SetSeed(DWORD dwSeed) {

    m_dwSeed = dwSeed;

    InitPrimesList(m_uOctaves, dwSeed);
}

//******************************************************************************
void CPerlinNoise::SetInterpolation(INTERPOLATIONTYPE irp) {

    switch (irp) {
        case INTERPOLATE_LINEAR:
            m_pfnInterpolate = CPerlinNoise::InterpolateLinear;
            break;
        case INTERPOLATE_COSINE:
            m_pfnInterpolate = CPerlinNoise::InterpolateCosine;
            break;
    }
}

//******************************************************************************
void CPerlinNoise::EnableClamp(BOOL bEnable) {

    m_bClamp = bEnable;
}

//******************************************************************************
void CPerlinNoise::SetRange(float fMin, float fMax) {

    if (fMax > fMin) {

        m_fRangeBase = fMin;
        m_fRangeMagnitude = fMax - fMin;
    }
}

//******************************************************************************
float CPerlinNoise::InterpolateLinear(float f1, float f2, float fBeta) {

    return f1 * (1.0f - fBeta) + f2 * fBeta;
}

//******************************************************************************
float CPerlinNoise::InterpolateCosine(float f1, float f2, float fBeta) {

    float f = (1.0f - (float)cos(fBeta * 3.14159265359f)) * 0.5f;
    return f1 * (1.0f - f) + f2 * f;
}

//******************************************************************************
DWORD CPerlinNoise::Rand32(DWORD dwSeed) {

    dwSeed = (dwSeed << 13) ^ dwSeed;
    return ((dwSeed * (dwSeed * dwSeed * 9973 + 769999) + 1376309969) & 0xFFFFFFFF);
}

//******************************************************************************
BOOL CPerlinNoise::IsPrime(UINT u) {

    UINT i = 1, j, k = 0;

    do {
        j = k;
        k = i;
        i = (k + (u / k));
        i >>= 1;
    } while(j != i);

    for (j = 2; j <= i; j++) {
        if (u % j == 0) {
            return FALSE;
        }
    }

    return TRUE;
}

//******************************************************************************
void CPerlinNoise::InitPrimesList(UINT uOctaves, DWORD dwSeed) {

    DWORD dwRandFunc, dwRand;
    UINT  i;

    for (i = 0, dwRandFunc = dwSeed; i < uOctaves; i++) {

        dwRand = Rand32(dwRandFunc);
        m_plPrimesList[i].uPrime1 = m_puPrimes[0][dwRand % PRIME_TABLE_ENTRIES];
        dwRand = Rand32(dwRand);
        m_plPrimesList[i].uPrime2 = m_puPrimes[1][dwRand % PRIME_TABLE_ENTRIES];
        dwRand = Rand32(dwRand);
        m_plPrimesList[i].uPrime3 = m_puPrimes[2][dwRand % PRIME_TABLE_ENTRIES];
        dwRandFunc = Rand32(dwRandFunc);
    }
}

//******************************************************************************
// CPerlinNoise1D
//******************************************************************************

//******************************************************************************
CPerlinNoise1D::CPerlinNoise1D(float fPersistence, UINT uOctaves, DWORD dwSeed, 
                    INTERPOLATIONTYPE irp, BOOL bClamp, BOOL bSmooth) :
                    CPerlinNoise(fPersistence, uOctaves, dwSeed, irp, bClamp)
{
    if (bSmooth) {
        m_pfnNoise = CPerlinNoise1D::SmoothNoise1D;
    }
    else {
        m_pfnNoise = CPerlinNoise1D::Noise1D;
    }
}

//******************************************************************************
CPerlinNoise1D::~CPerlinNoise1D() {
}

//******************************************************************************
void CPerlinNoise1D::EnableSmoothing(BOOL bEnable) {

    if (bEnable) {
        m_pfnNoise = CPerlinNoise1D::SmoothNoise1D;
    }
    else {
        m_pfnNoise = CPerlinNoise1D::Noise1D;
    }
}

//******************************************************************************
float CPerlinNoise1D::GetIntensity(float x) {

    float fIntensity = 0.0f, fAmplitude, fFrequency, fTotalAmp = 0.0f;

    fAmplitude = 1.0f;

    for (m_uOctave = 0; m_uOctave < m_uOctaves; m_uOctave++) {

//        fFrequency = (float)pow(2.0, (double)m_uOctave);
        fFrequency = (float)(0x1 << m_uOctave);
//        fAmplitude = (float)pow(m_fPersistence, (double)m_uOctave);
        fIntensity = fIntensity + InterpolatedNoise1D(x * fFrequency) * fAmplitude;
        fTotalAmp += fAmplitude;
        fAmplitude *= m_fPersistence;
    }

    if (m_bClamp) {
        fTotalAmp = 1.0f;
        if (fIntensity < -1.0f) {
            fIntensity = -1.0f;
        }
        else if (fIntensity > 1.0f) {
            fIntensity = 1.0f;
        }
    }

    return m_fRangeBase + m_fRangeMagnitude * ((fIntensity + fTotalAmp) / (fTotalAmp * 2.0f));
}

//******************************************************************************
float CPerlinNoise1D::InterpolatedNoise1D(float x) {

    int     nx;
    float   fx;

    nx = (int)x;
    fx = x - (float)nx;

    return (this->*m_pfnInterpolate)((this->*m_pfnNoise)(nx), (this->*m_pfnNoise)(nx+1), fx);
}

//******************************************************************************
float CPerlinNoise1D::Noise1D(int x) {

    DWORD   dwSeed;

    dwSeed = (x << 13) ^ x;

    return (1.0f - ((dwSeed * (dwSeed * dwSeed * m_plPrimesList[m_uOctave].uPrime1 + m_plPrimesList[m_uOctave].uPrime2) + m_plPrimesList[m_uOctave].uPrime3) & 0x7FFFFFFF) / 1073741824.0f);
}

//******************************************************************************
float CPerlinNoise1D::SmoothNoise1D(int x) {

    return Noise1D(x) / 2.0f + Noise1D(x-1) / 4.0f + Noise1D(x+1) / 4.0f;
}

//******************************************************************************
// CPerlinNoise2D
//******************************************************************************

//******************************************************************************
CPerlinNoise2D::CPerlinNoise2D(float fPersistence, UINT uOctaves, DWORD dwSeed, 
                    INTERPOLATIONTYPE irp, BOOL bClamp, BOOL bSmooth) :
                    CPerlinNoise(fPersistence, uOctaves, dwSeed, irp, bClamp)
{
    if (bSmooth) {
        m_pfnNoise = CPerlinNoise2D::SmoothNoise2D;
    }
    else {
        m_pfnNoise = CPerlinNoise2D::Noise2D;
    }
}

//******************************************************************************
CPerlinNoise2D::~CPerlinNoise2D() {
}

//******************************************************************************
void CPerlinNoise2D::EnableSmoothing(BOOL bEnable) {

    if (bEnable) {
        m_pfnNoise = CPerlinNoise2D::SmoothNoise2D;
    }
    else {
        m_pfnNoise = CPerlinNoise2D::Noise2D;
    }
}

//******************************************************************************
float CPerlinNoise2D::GetIntensity(float x, float y) {

    float fIntensity = 0.0f, fAmplitude, fFrequency, fTotalAmp = 0.0f;

    fAmplitude = 1.0f;

    for (m_uOctave = 0; m_uOctave < m_uOctaves; m_uOctave++) {

//        fFrequency = (float)pow(2.0, (double)m_uOctave);
        fFrequency = (float)(0x1 << m_uOctave);
//        fAmplitude = (float)pow(m_fPersistence, (double)m_uOctave);
        fIntensity = fIntensity + InterpolatedNoise2D(x * fFrequency, y * fFrequency) * fAmplitude;
        fTotalAmp += fAmplitude;
        fAmplitude *= m_fPersistence;
    }

    if (m_bClamp) {
        fTotalAmp = 1.0f;
        if (fIntensity < -1.0f) {
            fIntensity = -1.0f;
        }
        else if (fIntensity > 1.0f) {
            fIntensity = 1.0f;
        }
    }

    return m_fRangeBase + m_fRangeMagnitude * ((fIntensity + fTotalAmp) / (fTotalAmp * 2.0f));
}

//******************************************************************************
float CPerlinNoise2D::InterpolatedNoise2D(float x, float y) {

    int     nx, ny;
    float   fx, fy;
    float   i1, i2;

    nx = (int)x;
    ny = (int)y;
    fx = x - (float)nx;
    fy = y - (float)ny;

    i1 = (this->*m_pfnInterpolate)((this->*m_pfnNoise)(nx, ny  ), (this->*m_pfnNoise)(nx+1, ny  ), fx);
    i2 = (this->*m_pfnInterpolate)((this->*m_pfnNoise)(nx, ny+1), (this->*m_pfnNoise)(nx+1, ny+1), fx);

    return (this->*m_pfnInterpolate)(i1, i2, fy);
}

//******************************************************************************
float CPerlinNoise2D::Noise2D(int x, int y) {

    DWORD   dwSeed;

    dwSeed = x + y * 57;
    dwSeed = (dwSeed << 13) ^ dwSeed;

    return (1.0f - ((dwSeed * (dwSeed * dwSeed * m_plPrimesList[m_uOctave].uPrime1 + m_plPrimesList[m_uOctave].uPrime2) + m_plPrimesList[m_uOctave].uPrime3) & 0x7FFFFFFF) / 1073741824.0f);
}

//******************************************************************************
float CPerlinNoise2D::SmoothNoise2D(int x, int y) {

    float fCorners, fSides, fCenter;

    fCorners = (Noise2D(x-1, y-1) + Noise2D(x+1, y-1) + 
                Noise2D(x-1, y+1) + Noise2D(x+1, y+1)) / 16.0f;
    fSides =   (Noise2D(x-1, y) + Noise2D(x+1, y) +
                Noise2D(x, y-1) + Noise2D(x, y+1)) / 8.0f;
    fCenter =   Noise2D(x, y) / 4.0f;

    return fCorners + fSides + fCenter;
}

//******************************************************************************
// CPerlinNoise3D
//******************************************************************************

//******************************************************************************
CPerlinNoise3D::CPerlinNoise3D(float fPersistence, UINT uOctaves, DWORD dwSeed, 
                    INTERPOLATIONTYPE irp, BOOL bClamp, BOOL bSmooth) :
                    CPerlinNoise(fPersistence, uOctaves, dwSeed, irp, bClamp)
{
    if (bSmooth) {
        m_pfnNoise = CPerlinNoise3D::SmoothNoise3D;
    }
    else {
        m_pfnNoise = CPerlinNoise3D::Noise3D;
    }
}

//******************************************************************************
CPerlinNoise3D::~CPerlinNoise3D() {
}

//******************************************************************************
void CPerlinNoise3D::EnableSmoothing(BOOL bEnable) {

    if (bEnable) {
        m_pfnNoise = CPerlinNoise3D::SmoothNoise3D;
    }
    else {
        m_pfnNoise = CPerlinNoise3D::Noise3D;
    }
}

//******************************************************************************
float CPerlinNoise3D::GetIntensity(float x, float y, float z) {

    float fIntensity = 0.0f, fAmplitude, fFrequency, fTotalAmp = 0.0f;

    fAmplitude = 1.0f;

    for (m_uOctave = 0; m_uOctave < m_uOctaves; m_uOctave++) {

//        fFrequency = (float)pow(2.0, (double)m_uOctave);
        fFrequency = (float)(0x1 << m_uOctave);
//        fAmplitude = (float)pow(m_fPersistence, (double)m_uOctave);
        fIntensity = fIntensity + InterpolatedNoise3D(x * fFrequency, y * fFrequency, z * fFrequency) * fAmplitude;
        fTotalAmp += fAmplitude;
        fAmplitude *= m_fPersistence;
    }

    if (m_bClamp) {
        fTotalAmp = 1.0f;
        if (fIntensity < -1.0f) {
            fIntensity = -1.0f;
        }
        else if (fIntensity > 1.0f) {
            fIntensity = 1.0f;
        }
    }

    return m_fRangeBase + m_fRangeMagnitude * ((fIntensity + fTotalAmp) / (fTotalAmp * 2.0f));
}

//******************************************************************************
float CPerlinNoise3D::InterpolatedNoise3D(float x, float y, float z) {

    int     nx, ny, nz;
    float   fx, fy, fz;
    float   i1, i2, i3, i4, i5, i6;

    nx = (int)x;
    ny = (int)y;
    nz = (int)z;
    fx = x - (float)nx;
    fy = y - (float)ny;
    fz = z - (float)nz;

    i3 = (this->*m_pfnInterpolate)((this->*m_pfnNoise)(nx,   ny,   nz),   
                                   (this->*m_pfnNoise)(nx+1, ny  , nz),   fx);
    i4 = (this->*m_pfnInterpolate)((this->*m_pfnNoise)(nx,   ny+1, nz),   
                                   (this->*m_pfnNoise)(nx+1, ny+1, nz),   fx);

    i5 = (this->*m_pfnInterpolate)((this->*m_pfnNoise)(nx,   ny,   nz+1), 
                                   (this->*m_pfnNoise)(nx+1, ny,   nz+1), fx);
    i6 = (this->*m_pfnInterpolate)((this->*m_pfnNoise)(nx,   ny+1, nz+1), 
                                   (this->*m_pfnNoise)(nx+1, ny+1, nz+1), fx);

    i1 = (this->*m_pfnInterpolate)(i3, i4, fy);
    i2 = (this->*m_pfnInterpolate)(i5, i6, fy);

    return (this->*m_pfnInterpolate)(i1, i2, fz);
}

//******************************************************************************
float CPerlinNoise3D::Noise3D(int x, int y, int z) {

    DWORD   dwSeed;

    dwSeed = x + y * 57 + z * 117;
    dwSeed = (dwSeed << 13) ^ dwSeed;

    return (1.0f - ((dwSeed * (dwSeed * dwSeed * m_plPrimesList[m_uOctave].uPrime1 + m_plPrimesList[m_uOctave].uPrime2) + m_plPrimesList[m_uOctave].uPrime3) & 0x7FFFFFFF) / 1073741824.0f);
}

//******************************************************************************
float CPerlinNoise3D::SmoothNoise3D(int x, int y, int z) {

    float fEnds, fCorners, fSides, fCenter;

    fEnds =    (Noise3D(x-1, y-1, z-1) + Noise3D(x+1, y-1, z-1) +
                Noise3D(x-1, y+1, z-1) + Noise3D(x+1, y+1, z-1) +
                Noise3D(x-1, y-1, z+1) + Noise3D(x+1, y-1, z+1) +
                Noise3D(x-1, y+1, z+1) + Noise3D(x+1, y+1, z+1)) / 64.0f;
    fCorners = (Noise3D(x-1, y-1, z) + Noise3D(x+1, y-1, z) + 
                Noise3D(x-1, y+1, z) + Noise3D(x+1, y+1, z) +
                Noise3D(x-1, y, z-1) + Noise3D(x+1, y, z-1) +
                Noise3D(x, y-1, z-1) + Noise3D(x, y+1, z-1) +
                Noise3D(x-1, y, z+1) + Noise3D(x+1, y, z+1) +
                Noise3D(x, y-1, z+1) + Noise3D(x, y+1, z+1)) / 32.0f;
    fSides =   (Noise3D(x-1, y, z) + Noise3D(x+1, y, z) +
                Noise3D(x, y-1, z) + Noise3D(x, y+1, z) +
                Noise3D(x, y, z-1) + Noise3D(x, y, z+1)) / 16.0f;
    fCenter =   Noise3D(x, y, z) / 8.0f;

    return fEnds + fCorners + fSides + fCenter;
}

} // namespace DXCONIO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\d3dinit.cpp ===
/*******************************************************************************

Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

File Name:

    d3dinit.cpp

Description:

    Direct3D initialization routines.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <stdio.h>
#include <math.h>
#include <d3dx8.h>
#include "util.h"
#include "main.h"
#include "d3denum.h"
#include "d3dinit.h"
#include "texture.h"
#include "fontmap.h"

#ifdef UNDER_XBOX
#define DEMO_HACK
#endif

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

// View and projection transform data
#define VIEW_POS        D3DXVECTOR3(0.0f, 0.0f, 0.0f)
#define VIEW_AT         D3DXVECTOR3(0.0f, 0.0f, 1.0f)
#define VIEW_UP         D3DXVECTOR3(0.0f, 1.0f, 0.0f)
#define PROJ_NEAR       0.1f
#define PROJ_FAR        1000.0f
#define PROJ_FOV        (M_PI / 4.0f)

// Resource identifiers
#define IDM_DEFAULT_FILE_DISPLAY    1
#define IDM_DEFAULT_FILE_EXIT       2

#ifndef IDC_STATIC
#define IDC_STATIC                  (-1)
#endif
#define IDC_DISPLAY_ADAPTER         101
#define IDC_DISPLAY_DEVICE          102
#define IDC_DISPLAY_MODE            103
#define IDC_DISPLAY_FULLSCREEN      104
#define IDC_DISPLAY_DEPTHBUFFER     105
#define IDC_DISPLAY_ANTIALIAS       106

//******************************************************************************
// Structures
//******************************************************************************

//******************************************************************************
// Local function prototypes
//******************************************************************************

namespace DXCONIO {

static BOOL             InitDeviceState();
static BOOL             SetViewport(DWORD dwWidth, DWORD dwHeight);

static BOOL             CreateDevice(PADAPTERDESC padpd, PDEVICEDESC pdevd, 
                                PDISPLAYMODE pdm, BOOL bWindowed, 
                                BOOL bDepthBuffer, BOOL bAntialias);

static BOOL             RestoreFrameBuffer();

static HMENU            CreateMainMenu();
static BOOL CALLBACK    DisplayDlgProc(HWND hDlg, UINT message, WPARAM wParam, 
                                LPARAM lParam);
static void             AddDlgItemTemplate(LPWORD* ppw, WORD wClass, 
                                LPWSTR wszText, WORD wId, short x, short y, 
                                short cx, short cy, DWORD dwStyle);


//******************************************************************************
// Globals
//******************************************************************************

LPDIRECT3D8             g_pd3d = NULL;
LPDIRECT3DDEVICE8       g_pd3dDevice = NULL;

D3DPRESENT_PARAMETERS   g_d3dpp;
D3DSURFACE_DESC         g_d3dsdBack;

PADAPTERDESC            g_padpdList = NULL;
DISPLAYDESC             g_disdCurrent = {0};

HWND                    g_hWnd = NULL;
RECT                    g_rectWnd;
static RECT             g_rectBorder;

KEYSDOWN                g_kdKeys = 0;

CAMERA                  g_cam;

float                   g_fCameraTDelta = 0.5f;
float                   g_fCameraRDelta = 0.011415f;

float                   g_fTimeDilation = 1.0f;

BOOL                    g_bActive = TRUE;

static BOOL             g_bDisplayFPS = TRUE;

static SETDEVICEPROC    g_pfnSetDevice;
static CLEARDEVICEPROC  g_pfnClearDevice;
static SUBWNDPROC       g_pfnSubWndProc = NULL;

#ifndef UNDER_XBOX

//******************************************************************************
// WndProc
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     WndProc
//
// Description:
//
//     Window procedure to process messages for the main application window
//
// Arguments:
//
//     HWND hWnd                - Application window
//
//     UINT message             - Message to process
//
//     WPARAM wParam            - First message parameter
//
//     LPARAM lParam            - Second message parameter
//
// Return Value:
//
//     0 if the message was handled, the return of DefWindowProc otherwise.
//
//******************************************************************************
LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    // If the application supplied a window procedure, give it a chance to
    // handle the message first
    if (g_pfnSubWndProc) {
        LRESULT lr;
        if (g_pfnSubWndProc(&lr, hWnd, uMsg, wParam, lParam)) {
            return lr;  // The message was handled, return the given LRESULT
        }
    }

    switch (uMsg) {

        case WM_ACTIVATEAPP:

            // Suspend the application if it is running in full screen mode
            if (!g_disdCurrent.bWindowed) {
                g_bActive = (BOOL)wParam;
            }

            break;

        case WM_MOVE:

            if (!MoveWindowTarget((short)LOWORD(lParam), (short)HIWORD(lParam))) {
                DestroyWindow(hWnd);
            }

            break;

        case WM_SIZE:

            if (wParam != SIZE_MINIMIZED) {
                if (!SizeWindowTarget(LOWORD(lParam), HIWORD(lParam))) {
                    DestroyWindow(hWnd);
                }
            }
            break;

        case WM_SETCURSOR:

            if (g_bActive && !g_disdCurrent.bWindowed) {
                SetCursor(NULL);
                return TRUE;
            }
            break;

        case WM_MOUSEMOVE:

            if (g_pd3dDevice && g_bActive) {
                POINT point;
                GetCursorPos(&point);
                ScreenToClient(hWnd, &point);
                g_pd3dDevice->SetCursorPosition(point.x, point.y, D3DCURSOR_IMMEDIATE_UPDATE);
            }
            break;

        case WM_ENTERMENULOOP:

            if (g_pd3dDevice && !g_disdCurrent.bWindowed) {
// ##REVIEW: Is FlipToGDISurface gone or has it been changed to something else?  Can we simply remove the call and still have things work?
//                g_pd3dDevice->FlipToGDISurface();
                DrawMenuBar(g_hWnd);
                RedrawWindow(g_hWnd, NULL, NULL, RDW_FRAME);
            }
            break;

        case WM_EXITMENULOOP:

            // Do not include the amount of time the menu was up in game time calculations
//            g_bTimeSync = TRUE;
            break;

        case WM_POWERBROADCAST:

            switch( wParam )
            {
                case PBT_APMQUERYSUSPEND:
                    if (g_pd3dDevice && !g_disdCurrent.bWindowed) {
//                        g_pd3dDevice->FlipToGDISurface();
                        DrawMenuBar(g_hWnd);
                        RedrawWindow(g_hWnd, NULL, NULL, RDW_FRAME);
                    }
                    break;

                case PBT_APMRESUMESUSPEND:
                    // Do not include the amount of time power management was up in game time calculations
//                    g_bTimeSync = TRUE;
                    break;
            }
            break;
/*
        case WM_SYSCOMMAND:
            switch (wParam) {
                case SC_MOVE:
                case SC_SIZE:
                case SC_MAXIMIZE:
                case SC_MONITORPOWER:
                    if (!g_disdCurrent.bWindowed) {
                        return 1;
                    }
                    break;
            }
            break;
*/
        case WM_COMMAND:

            switch (LOWORD(wParam)) {

                case IDM_DEFAULT_FILE_DISPLAY:
                    SelectDisplay();
                    return 0;

                case IDM_DEFAULT_FILE_EXIT:
                    SendMessage(hWnd, WM_CLOSE, 0, 0);
                    return 0;
            }

            break;

        case WM_KEYDOWN:

            switch (wParam) {

                case VK_LEFT:
                    g_kdKeys |= KEY_LEFT;
                    return 0;

                case VK_RIGHT:
                    g_kdKeys |= KEY_RIGHT;
                    return 0;

                case VK_UP:
                    g_kdKeys |= KEY_UP;
                    return 0;

                case VK_DOWN:
                    g_kdKeys |= KEY_DOWN;
                    return 0;

                case VK_ADD:
                    g_kdKeys |= KEY_ADD;
                    return 0;

                case VK_SUBTRACT:
                    g_kdKeys |= KEY_SUBTRACT;
                    return 0;

                case VK_INSERT:
                    g_kdKeys |= KEY_INSERT;
                    return 0;

                case VK_DELETE:
                    g_kdKeys |= KEY_DELETE;
                    return 0;

                case VK_HOME:
                    g_kdKeys |= KEY_HOME;
                    return 0;

                case VK_END:
                    g_kdKeys |= KEY_END;
                    return 0;

                case VK_PRIOR:
                    g_kdKeys |= KEY_PAGEUP;
                    return 0;

                case VK_NEXT:
                    g_kdKeys |= KEY_PAGEDOWN;
                    return 0;

                case VK_SHIFT:
                    g_kdKeys |= KEY_SHIFT;
                    return 0;

                case VK_RETURN: // Toggle pause state
                    g_bPaused = !g_bPaused;
                    return 0;

                case VK_ESCAPE: // Exit
                    SendMessage(hWnd, WM_CLOSE, 0, 0);
                    return 0;
            }

            break;

// REVIEW: Don't reference the device pointer in any of these handlers
// instead call a function (i.e. OnPointFill) which will make the
// necessary device method call
        case WM_KEYUP:

            switch (wParam) {

                case VK_LEFT:
                    g_kdKeys &= ~KEY_LEFT;
                    return 0;

                case VK_RIGHT:
                    g_kdKeys &= ~KEY_RIGHT;
                    return 0;

                case VK_UP:
                    g_kdKeys &= ~KEY_UP;
                    return 0;

                case VK_DOWN:
                    g_kdKeys &= ~KEY_DOWN;
                    return 0;

                case VK_ADD:
                    g_kdKeys &= ~KEY_ADD;
                    return 0;

                case VK_SUBTRACT:
                    g_kdKeys &= ~KEY_SUBTRACT;
                    return 0;

                case VK_INSERT:
                    g_kdKeys &= ~KEY_INSERT;
                    return 0;

                case VK_DELETE:
                    g_kdKeys &= ~KEY_DELETE;
                    return 0;

                case VK_HOME:
                    g_kdKeys &= ~KEY_HOME;
                    return 0;

                case VK_END:
                    g_kdKeys &= ~KEY_END;
                    return 0;

                case VK_PRIOR:
                    g_kdKeys &= ~KEY_PAGEUP;
                    return 0;

                case VK_NEXT:
                    g_kdKeys &= ~KEY_PAGEDOWN;
                    return 0;

                case VK_SHIFT:
                    g_kdKeys &= ~KEY_SHIFT;
                    return 0;

                case VK_SPACE:
                    g_bPaused = TRUE;
                    g_bAdvance = TRUE;
                    return 0;

                case VK_F2:     // Open display dialog
                    SelectDisplay();
                    return 0;
/*
                case VK_F3:     // Gouraud shading
                    g_pd3dDevice->SetRenderState(D3DRENDERSTATE_SHADEMODE, 
                                                 (DWORD)D3DSHADE_GOURAUD);
                    return 0;

                case VK_F5: {   // Toggle z-buffering
                    BOOL bZBufferOn;
                    if (SUCCEEDED(g_pd3dDevice->GetRenderState(
                                  D3DRENDERSTATE_ZENABLE, 
                                  (LPDWORD)&bZBufferOn))) {
                        bZBufferOn = !bZBufferOn;
                        g_pd3dDevice->SetRenderState(
                                  D3DRENDERSTATE_ZENABLE, 
                                  (DWORD)bZBufferOn);
                    }
                    return 0;
                }

                case VK_F7: {   // Toggle specular highlights
                    BOOL bSpecularOn;
                    if (SUCCEEDED(g_pd3dDevice->GetRenderState(
                                  D3DRENDERSTATE_SPECULARENABLE, 
                                  (LPDWORD)&bSpecularOn))) {
                        bSpecularOn = !bSpecularOn;
                        g_pd3dDevice->SetRenderState(
                                  D3DRENDERSTATE_SPECULARENABLE, 
                                  (DWORD)bSpecularOn);
                    }
                    return 0;
                }

                case VK_F10: {  // Toggle perspective correction
                    BOOL bPerspectiveOn;
                    if (SUCCEEDED(g_pd3dDevice->GetRenderState(
                                  D3DRENDERSTATE_TEXTUREPERSPECTIVE, 
                                  (LPDWORD)&bPerspectiveOn))) {
                        bPerspectiveOn = !bPerspectiveOn;
                        g_pd3dDevice->SetRenderState(
                                  D3DRENDERSTATE_TEXTUREPERSPECTIVE, 
                                  (DWORD)bPerspectiveOn);
                    }
                    return 0;
                }
*/
            }

            break;


        case WM_SYSKEYUP:

            switch (wParam) {

                case VK_RETURN:
                    UpdateDisplay(g_disdCurrent.pdm, !g_disdCurrent.bWindowed,
                                  g_disdCurrent.bDepthBuffer, 
                                  g_disdCurrent.bAntialias);
                    return 0;
            }

            break;

        case WM_CHAR:

            switch (wParam) {

                case TEXT('F'):
                case TEXT('f'):
                    g_bDisplayFPS = !g_bDisplayFPS;
                    return 0;

                case TEXT('T'):
                case TEXT('t'):
                    if (g_fTimeDilation < 1.5f && g_fTimeDilation > 0.26f) {
                        g_fTimeDilation /= 2.0f;
                    }
                    else if (g_fTimeDilation < 0.26f) {
                        g_fTimeDilation = 2.0f;
                    }
                    else if (g_fTimeDilation >= 1.5f) {
                        g_fTimeDilation = 1.0f;
                    }
                    return 0;

                case TEXT('D'):
                case TEXT('d'):
                    UpdateDisplay(g_disdCurrent.pdm, g_disdCurrent.bWindowed, 
                        !g_disdCurrent.bDepthBuffer, g_disdCurrent.bAntialias);
                    return 0;

                case TEXT('A'):
                case TEXT('a'):
                    UpdateDisplay(g_disdCurrent.pdm, g_disdCurrent.bWindowed, 
                        g_disdCurrent.bDepthBuffer, !g_disdCurrent.bAntialias);
                    return 0;

/*
                case TEXT('P'):      // Point fill
                case TEXT('p'):
                    g_pd3dDevice->SetRenderState(D3DRENDERSTATE_FILLMODE, 
                                                        (DWORD)D3DFILL_POINT);
                    return 0;

                case TEXT('W'):      // Wireframe fill
                case TEXT('w'):
                    g_pd3dDevice->SetRenderState(D3DRENDERSTATE_FILLMODE, 
                                                        (DWORD)D3DFILL_WIREFRAME);
                    return 0;

                case TEXT('S'):      // Solid fill
                case TEXT('s'):
                    g_pd3dDevice->SetRenderState(D3DRENDERSTATE_FILLMODE, 
                                                        (DWORD)D3DFILL_SOLID);
                    return 0;

                case TEXT('D'):      // Toggle dithering
                case TEXT('d'): {
                    BOOL bDitheringOn;
                    if (SUCCEEDED(g_pd3dDevice->GetRenderState(
                                  D3DRENDERSTATE_DITHERENABLE, 
                                  (LPDWORD)&bDitheringOn))) {
                        bDitheringOn = !bDitheringOn;
                        g_pd3dDevice->SetRenderState(
                                  D3DRENDERSTATE_DITHERENABLE, 
                                  (DWORD)bDitheringOn);
                    }
                    return 0;
                }

                case TEXT('A'):      // Toggle anti-aliasing
                case TEXT('a'): {
                    BOOL bAntialias;
                    if (SUCCEEDED(g_pd3dDevice->GetRenderState(
                                  D3DRENDERSTATE_ANTIALIAS, 
                                  (LPDWORD)&bAntialias))) {
                        bAntialias = !bAntialias;
                        g_pd3dDevice->SetRenderState(
                                  D3DRENDERSTATE_ANTIALIAS, 
                                  (DWORD)bAntialias);
                    }
                    return 0;
                }

                case TEXT('O'):      // Point filtering
                case TEXT('o'):
                    g_pd3dDevice->SetRenderState(D3DRENDERSTATE_TEXTUREMAG, 
                                                 (DWORD)D3DFILTER_NEAREST);
                    g_pd3dDevice->SetRenderState(D3DRENDERSTATE_TEXTUREMIN, 
                                                 (DWORD)D3DFILTER_NEAREST);
                    return 0;

                case TEXT('L'):      // Bi-linear filtering
                case TEXT('l'):
                    g_pd3dDevice->SetRenderState(D3DRENDERSTATE_TEXTUREMAG, 
                                                 (DWORD)D3DFILTER_LINEAR);
                    g_pd3dDevice->SetRenderState(D3DRENDERSTATE_TEXTUREMIN, 
                                                 (DWORD)D3DFILTER_LINEAR);
                    return 0;
*/
            }

            break;

        case WM_CLOSE:
            DestroyWindow(hWnd);
            return 0;

        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

#endif // UNDER_XBOX

//******************************************************************************
// Initialization functions
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     InitDeviceState
//
// Description:
//
//     Initialize the default render states.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
static BOOL InitDeviceState() {

    D3DMATRIX       mTransform;
    BOOL            bRet = TRUE;
    UINT            i;
    HRESULT         hr;

    // Begin the scene
    hr = g_pd3dDevice->BeginScene();
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::BeginScene"))) {
        return FALSE;
    }

    // Set ambient lighting
    hr = g_pd3dDevice->SetRenderState(D3DRS_AMBIENT, 
                                      (DWORD)RGBA_MAKE(128, 128, 128, 128));
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        bRet = FALSE;
    }

    // Enable z-buffering
    hr = g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, (DWORD)D3DZB_FALSE);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        bRet = FALSE;
    }

    hr = g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, (DWORD)FALSE);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        bRet = FALSE;
    }

    hr = g_pd3dDevice->SetRenderState(D3DRS_ZFUNC, (DWORD)D3DCMP_LESSEQUAL);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        bRet = FALSE;
    }

    // Set the texture filters
#ifndef DEMO_HACK
    for (i = 0; i < 4; i++) {
#else
    for (i = 0; i < 2; i++) {
#endif
        hr = g_pd3dDevice->SetTextureStageState(i, D3DTSS_MINFILTER, (DWORD)D3DTEXF_POINT);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTextureStageState"))) {
            bRet = FALSE;
        }

        hr = g_pd3dDevice->SetTextureStageState(i, D3DTSS_MAGFILTER, (DWORD)D3DTEXF_POINT);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTextureStageState"))) {
            bRet = FALSE;
        }

        hr = g_pd3dDevice->SetTextureStageState(i, D3DTSS_MIPFILTER, (DWORD)D3DTEXF_NONE);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTextureStageState"))) {
            bRet = FALSE;
        }
    }

    // Use gouraud shading
    hr = g_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, (DWORD)D3DSHADE_GOURAUD);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        bRet = FALSE;
    }

    // Set blend modes
    hr = g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        bRet = FALSE;
    }

    hr = g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        bRet = FALSE;
    }
    
    // Modulate color and alpha texture stages
    hr = SetColorStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTextureStageState"))) {
        bRet = FALSE;
    }

    hr = SetAlphaStage(0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTextureStageState"))) {
        bRet = FALSE;
    }

    hr = g_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTextureStageState"))) {
        bRet = FALSE;
    }

    hr = g_pd3dDevice->SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTextureStageState"))) {
        bRet = FALSE;
    }

    // Set the alpha comparison function
    hr = g_pd3dDevice->SetRenderState(D3DRS_ALPHAFUNC, (DWORD)D3DCMP_GREATEREQUAL);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        bRet = FALSE;
    }

    // Set the alpha reference value to opaque
    hr = g_pd3dDevice->SetRenderState(D3DRS_ALPHAREF, 0xFF);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        bRet = FALSE;
    }

    // Use a solid fill mode
    hr = g_pd3dDevice->SetRenderState(D3DRS_FILLMODE, (DWORD)D3DFILL_SOLID);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        bRet = FALSE;
    }

    // Disable lighting
    hr = g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, (DWORD)FALSE);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        bRet = FALSE;
    }
    
    // Turn off specular highlights
    hr = g_pd3dDevice->SetRenderState(D3DRS_SPECULARENABLE, (DWORD)FALSE);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        bRet = FALSE;
    }

    // Disable texture wrapping
    for (i = 0; i < 8; i++) {
        hr = g_pd3dDevice->SetRenderState((D3DRENDERSTATETYPE)((DWORD)D3DRS_WRAP0 + i), (DWORD)0);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
            bRet = FALSE;
        }
    }

    // Enable dithering
    hr = g_pd3dDevice->SetRenderState(D3DRS_DITHERENABLE, (DWORD)TRUE);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        bRet = FALSE;
    }

    // Disable per-vertex color
    hr = g_pd3dDevice->SetRenderState(D3DRS_COLORVERTEX, (DWORD)FALSE);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        bRet = FALSE;
    }

    // End the scene
    hr = g_pd3dDevice->EndScene();
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::EndScene"))) {
        bRet = FALSE;
    }

    // Initialize the world matrix to the identity matrix
    InitMatrix(&mTransform,
        1.0f, 0.0f, 0.0f, 0.0f,
        0.0f, 1.0f, 0.0f, 0.0f,
        0.0f, 0.0f, 1.0f, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f
    );

    hr = g_pd3dDevice->SetTransform(D3DTS_WORLD, &mTransform);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTransform"))) {
        return FALSE;
    }

    // Initialize the camera
    if (!SetCameraView(&g_cam)) {
        return FALSE;
    }

    return bRet;
}

//******************************************************************************
static BOOL SetViewport(DWORD dwWidth, DWORD dwHeight) {

    D3DVIEWPORT8    viewport;
    HRESULT         hr;

    // Set a viewport for the device
    viewport.X = 0;
    viewport.Y = 0;
    viewport.Width = dwWidth;
    viewport.Height = dwHeight;
    viewport.MinZ = 0.0f;
    viewport.MaxZ = 1.0f;

    hr = g_pd3dDevice->SetViewport(&viewport);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetViewport"))) {
        return FALSE;
    }

    return TRUE;
}
/*
//******************************************************************************
//
// Function:
//
//     CreateDevice
//
// Description:
//
//     Create the device object using the given adapter, device, and display
//     mode information.
//
// Arguments:
//
//     PADAPTERDESC padpd       - The adapter to use in creating the device
//                                object
//
//     PDEVICEDESC pdevd        - The device to use in creating the device
//                                object.
//
//     PDISPLAYMODE pdm         - The display mode to use in creating the
//                                device object (if full screen)
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
//##HACK function (see replacement commented out)
BOOL CreateDevice(PADAPTERDESC padpd, PDEVICEDESC pdevd, PDISPLAYMODE pdm, 
                    BOOL bWindowed, BOOL bDepthBuffer, BOOL bAntialias)
{
    LPDIRECT3DSURFACE8      pd3ds;
    HRESULT                 hr;

    if (!padpd || !pdevd || !pdm) {
        return FALSE;
    }

    // Check if windowed mode is available
    if (!pdevd->bCanRenderWindowed) {
//        bWindowed = FALSE;
    }

    if (!ANTIALIAS_SUPPORTED(pdevd, pdm, bWindowed)) {
        bAntialias = FALSE;
    }

    // Initialize the presentation parameters
    memset(&g_d3dpp, 0, sizeof(D3DPRESENT_PARAMETERS));
    if (bWindowed) {
//        g_d3dpp.BackBufferFormat                  = D3DFMT_UNKNOWN;
        g_d3dpp.MultiSampleType                   = pdevd->d3dmstWindowed;
        g_d3dpp.AutoDepthStencilFormat            = D3DFMT_D16;
    }
    else {
        g_d3dpp.BackBufferWidth                   = pdm->d3ddm.Width;
        g_d3dpp.BackBufferHeight                  = pdm->d3ddm.Height;
        g_d3dpp.BackBufferFormat                  = pdm->d3ddm.Format;
        g_d3dpp.MultiSampleType                   = pdm->d3dmst;
        g_d3dpp.AutoDepthStencilFormat            = pdm->fmtd;
        g_d3dpp.FullScreen_RefreshRateInHz        = pdm->d3ddm.RefreshRate;
        // REVIEW: The following should be checked against D3DCAPS8 for support
        g_d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
    }
    g_d3dpp.BackBufferCount                       = 1;
    g_d3dpp.SwapEffect                            = D3DSWAPEFFECT_DISCARD;
    g_d3dpp.hDeviceWindow                         = g_hWnd;
    g_d3dpp.Windowed                              = bWindowed;
    g_d3dpp.EnableAutoDepthStencil                = bDepthBuffer;
    if (!bAntialias) {
        g_d3dpp.MultiSampleType                   = D3DMULTISAMPLE_NONE;
    }

    // Create the device
    hr = g_pd3d->CreateDevice(padpd->uAdapter, pdevd->d3ddt, g_hWnd, pdevd->dwBehavior, &g_d3dpp, &g_pd3dDevice);
    if (ResultFailed(hr, TEXT("IDirect3D8::CreateDevice"))) {
        return FALSE;
    }

    // Get the surface description of the back buffer
    hr = g_pd3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pd3ds);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetBackBuffer"))) {
        return FALSE;
    }
    g_d3dsdBack = pd3ds->GetDesc();
    pd3ds->Release();

    // Initialize the viewport
    SetViewport(g_d3dsdBack.Width, g_d3dsdBack.Height);

    // Initialize the default states of the device
    if (!InitDeviceState()) {
        return FALSE;
    }

    g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, bAntialias);

    g_disdCurrent.padpd = padpd;
    g_disdCurrent.pdevd = pdevd;
    g_disdCurrent.pdm = pdm;
    g_disdCurrent.bWindowed = bWindowed;
    g_disdCurrent.bDepthBuffer = bDepthBuffer;
    g_disdCurrent.bAntialias = bAntialias;

    return TRUE;
}
*/

BOOL CreateDevice(PADAPTERDESC padpd, PDEVICEDESC pdevd, PDISPLAYMODE pdm, 
                    BOOL bWindowed, BOOL bDepthBuffer, BOOL bAntialias)
{
    LPDIRECT3DSURFACE8      pd3ds;
    HRESULT                 hr;

    if (!padpd || !pdevd || !pdm) {
        return FALSE;
    }

//##HACK
pdevd->bCanRenderWindowed = TRUE;
    // Check if windowed mode is available
    if (!pdevd->bCanRenderWindowed) {
        bWindowed = FALSE;
    }

    // Check if antialiasing is available
    if (!ANTIALIAS_SUPPORTED(pdevd, pdm, bWindowed)) {
        bAntialias = FALSE;
    }

    // Initialize the presentation parameters
    memset(&g_d3dpp, 0, sizeof(D3DPRESENT_PARAMETERS));
    if (bWindowed) {
        g_d3dpp.BackBufferFormat                  = D3DFMT_UNKNOWN;
        g_d3dpp.MultiSampleType                   = pdevd->d3dmstWindowed;
        g_d3dpp.AutoDepthStencilFormat            = pdevd->fmtdWindowed;
    }
    else {
        g_d3dpp.BackBufferWidth                   = pdm->d3ddm.Width;
        g_d3dpp.BackBufferHeight                  = pdm->d3ddm.Height;
        g_d3dpp.BackBufferFormat                  = pdm->d3ddm.Format;
        g_d3dpp.MultiSampleType                   = pdm->d3dmst;
        g_d3dpp.AutoDepthStencilFormat            = pdm->fmtd;
        g_d3dpp.FullScreen_RefreshRateInHz        = pdm->d3ddm.RefreshRate;
        // REVIEW: The following should be checked against D3DCAPS8 for support
        g_d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
    }
    g_d3dpp.BackBufferCount                       = 1;
    g_d3dpp.SwapEffect                            = D3DSWAPEFFECT_DISCARD;
    g_d3dpp.hDeviceWindow                         = g_hWnd;
    g_d3dpp.Windowed                              = bWindowed;
    g_d3dpp.EnableAutoDepthStencil                = bDepthBuffer;
    if (!bAntialias) {
        g_d3dpp.MultiSampleType                   = D3DMULTISAMPLE_NONE;
    }

    // Create the device
    hr = g_pd3d->CreateDevice(padpd->uAdapter, pdevd->d3ddt, g_hWnd, pdevd->dwBehavior, &g_d3dpp, &g_pd3dDevice);
    if (ResultFailed(hr, TEXT("IDirect3D8::CreateDevice"))) {
        return FALSE;
    }

    // Get the surface description of the back buffer
    hr = g_pd3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pd3ds);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetBackBuffer"))) {
        return FALSE;
    }
    pd3ds->GetDesc(&g_d3dsdBack);
    pd3ds->Release();

    // Initialize the viewport
    SetViewport(g_d3dsdBack.Width, g_d3dsdBack.Height);

    // Initialize the default states of the device
    if (!InitDeviceState()) {
        return FALSE;
    }

    g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, bAntialias);

    g_disdCurrent.padpd = padpd;
    g_disdCurrent.pdevd = pdevd;
    g_disdCurrent.pdm = pdm;
    g_disdCurrent.bWindowed = bWindowed;
    g_disdCurrent.bDepthBuffer = bDepthBuffer;
    g_disdCurrent.bAntialias = bAntialias;

    return TRUE;
}

//******************************************************************************
BOOL RestoreDisplay() {

    HRESULT hr;

    hr = g_pd3dDevice->Reset(&g_d3dpp);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::Reset"))) {
        return FALSE;
    }

    InitDeviceState();

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     CreateDirect3D
//
// Description:
//
//     Initialize all DirectX objects needed for 3D rendering.
//
// Arguments:
//
//     PD3DCREATIONDESC pd3dcd          - Pointer to creation parameters
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CreateDirect3D(PD3DCREATIONDESC pd3dcd) {

    TCHAR           szPath[MAX_PATH];
    LPTSTR          szFile, sz;
#ifndef UNDER_XBOX
	WNDCLASS        wc;
#endif
    BOOL            bWindowedDefault = FALSE;
    BOOL            bDepthBufferDefault = TRUE;
    BOOL            bAntialiasDefault = FALSE;
    RECT            rect, rectWndDefault = {30, 30, 550, 460};
    POINT           point;
    PADAPTERDESC    padpd;
    PDEVICEDESC     pdevd;
    PDISPLAYMODE    pdm;

    // Release all objects if intialization has already taken place.
    ReleaseDirect3D();

    // Initialize the camera
    g_cam.vPosition     = VIEW_POS;
    g_cam.vInterest     = VIEW_AT;
    g_cam.fRoll         = 0.0f;
    g_cam.fFieldOfView  = PROJ_FOV;
    g_cam.fNearPlane    = PROJ_NEAR;
    g_cam.fFarPlane     = PROJ_FAR;

    // Set the creation parameters
    if (pd3dcd) {
        if (pd3dcd->d3ddt == D3DDEVTYPE_HAL ||
            pd3dcd->d3ddt == D3DDEVTYPE_SW ||
            pd3dcd->d3ddt == D3DDEVTYPE_REF)
        {
            g_devdDefault.d3ddt = pd3dcd->d3ddt;
        }
        if (pd3dcd->d3ddm.Width != 0 && pd3dcd->d3ddm.Height != 0) {
            memcpy(&g_dmDefault.d3ddm, &pd3dcd->d3ddm, sizeof(D3DDISPLAYMODE));
        }
        g_fmtdDefault = pd3dcd->fmtd;

        if (pd3dcd->rectWnd.right > 0 && pd3dcd->rectWnd.bottom > 0) {
            memcpy(&rectWndDefault, &pd3dcd->rectWnd, sizeof(RECT));
        }
        bWindowedDefault = pd3dcd->bWindowed;
        bDepthBufferDefault = pd3dcd->bDepthBuffer;
        bAntialiasDefault = pd3dcd->bAntialias;
    }

#ifndef UNDER_XBOX
    // Register the window class
    memset(&wc, 0, sizeof(WNDCLASS));
    wc.style            = 0;
    wc.lpfnWndProc      = WndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = GetModuleHandle(NULL);
    wc.hIcon            = NULL;
    wc.hbrBackground    = NULL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = TEXT("Direct3D Application");

    if (!RegisterClass(&wc)) {
        DebugString(TEXT("RegisterClass failed"));
        return FALSE;
    }

    // Get the name of the executable
    _tcscpy(szPath, GetCommandLine());
    szFile = _tcstok(szPath, TEXT(" \t"));
    sz = szFile + _tcslen(szFile) - 1;
    if (*sz == TEXT('"')) {
        *sz = TEXT('\0');
    }
    sz = szFile + _tcslen(szFile) - 4;
    if (!_tcsncmp(sz, TEXT(".exe"), 4)) {
        *sz = TEXT('\0');
    }
    for (sz = szFile + _tcslen(szFile); sz != szFile && *(sz - 1) != TEXT('\\'); sz--);

    // Create the main application window
    g_hWnd = CreateWindowEx(0, TEXT("Direct3D Application"), 
                            sz, 
                            WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                            rectWndDefault.left, rectWndDefault.top,
                            rectWndDefault.right - rectWndDefault.left, 
                            rectWndDefault.bottom - rectWndDefault.top,
                            NULL, CreateMainMenu(), GetModuleHandle(NULL), NULL);

    if (!g_hWnd) {
        DebugString(TEXT("CreateWindowEx failed"));
		return FALSE;
    }

    UpdateWindow(g_hWnd);

    // Get the client area of the window
    if (!GetClientRect(g_hWnd, &rect)) {
        return FALSE;
    }

    // Convert the client window coordinates to screen coordinates
    point.x = rect.left;
    point.y = rect.top;
    if (!ClientToScreen(g_hWnd, &point)) {
        return FALSE;
    }

    // Save the screen coordinates of the client window
    SetRect(&g_rectWnd, point.x, point.y, 
            point.x + rect.right, point.y + rect.bottom);

    // Get the size offsets of the window border
    GetWindowRect(g_hWnd, &g_rectBorder);
    SetRect(&g_rectBorder, g_rectWnd.left - g_rectBorder.left,
            g_rectWnd.top - g_rectBorder.top,
            g_rectBorder.right - g_rectWnd.right,
            g_rectBorder.bottom - g_rectWnd.bottom);
#else
    g_hWnd = NULL;
#endif

    // Create the Direct3D object
    g_pd3d = Direct3DCreate8(D3D_SDK_VERSION);
    if (!g_pd3d) {
        DebugString(TEXT("Direct3DCreate8 failed"));
        return FALSE;
    }

    // Enumerate all display devices in the system and store the information in
    // a global driver list
    g_padpdList = EnumDisplays(g_pd3d);
    if (!g_padpdList) {
        ReleaseDirect3D();
        return FALSE;
    }

    // Select a default driver
    padpd = SelectAdapter(g_padpdList);
    if (!padpd) {
        ReleaseDirect3D();
        return FALSE;
    }

    // Select a default device
    pdevd = SelectDevice(padpd);
    if (!pdevd) {
        ReleaseDirect3D();
        return FALSE;
    }

    // Select a default display mode (in case of full screen)
    pdm = SelectDisplayMode(pdevd);
    if (!pdm) {
        ReleaseDirect3D();
        return FALSE;
    }

    // Create the device
    if (!CreateDevice(padpd, pdevd, pdm, bWindowedDefault, bDepthBufferDefault, bAntialiasDefault)) {
        ReleaseDirect3D();
        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     ReleaseDirect3D
//
// Description:
//
//     Release all 3D rendering objects created by the InitDirect3D function.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void ReleaseDirect3D() {

    PADAPTERDESC padpd;
    PDEVICEDESC  pdevd;
    PDISPLAYMODE pdm;

    // Release the device
    if (g_pd3dDevice) {
        g_pd3dDevice->Release();
        g_pd3dDevice = NULL;
    }

    // Release the Direct3D object
    if (g_pd3d) {
        g_pd3d->Release();
        g_pd3d = NULL;
    }

#ifndef UNDER_XBOX
    MoveWindow(g_hWnd, g_rectWnd.left, g_rectWnd.top, 
               g_rectWnd.right - g_rectWnd.left, 
               g_rectWnd.bottom - g_rectWnd.top, TRUE);
#endif

    // Free the display device list
    for (padpd = g_padpdList; g_padpdList; padpd = g_padpdList) {
        g_padpdList = g_padpdList->padpdNext;
        for (pdevd = padpd->pdevdList; padpd->pdevdList; pdevd = padpd->pdevdList) {
            padpd->pdevdList = padpd->pdevdList->pdevdNext;
            for (pdm = pdevd->pdmList; pdevd->pdmList; pdm = pdevd->pdmList) {
                pdevd->pdmList = pdevd->pdmList->pdmNext;
                MemFree(pdm);
            }
            MemFree(pdevd);
        }
        MemFree(padpd);
    }

    // Reset any application supplied window procedure
    g_pfnSubWndProc = NULL;

#ifndef UNDER_XBOX
    // Unregister the window class
    UnregisterClass(TEXT("Direct3D Application"), GetModuleHandle(NULL));
#endif
}

//******************************************************************************
// Utilitiy functions
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     FlipFrameBuffer
//
// Description:
//
//     Bring the contents of the rendering target to the screen.  If the 
//     application is running in fullscreen mode, this is accomplished by
//     flipping the front and back buffers.  If the application is windowed,
//     the contents of the rendering target are copied to the primary surface.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Result of the call to IDirectDrawSurface7::Flip for fullscreen mode.
//     Result of the call to IDirectDrawSurface7::BltFast for windowed mode.
//
//******************************************************************************
/*
HRESULT DisplayFrame() {

    HRESULT hr;

    if (g_bWindowed) {
        // Blt the contents of the rendering target to the primary surface
        hr = g_pddsFront->Blt(&g_rectWnd, g_pddsBack, NULL, DDBLT_WAIT, NULL);
        ResultFailed(hr, TEXT("IDirectDrawSurface7::Blt"));
    }

    else {

        // Flip the back and front buffers
        hr = g_pddsFront->Flip(NULL, DDFLIP_WAIT);
        ResultFailed(hr, TEXT("IDirectDrawSurface7::Flip"));
    }

    if (hr == DDERR_SURFACELOST) {

        // Rendering failed because video memory got freed
        // End the scene in case rendering failed within the scene
        g_pd3dDevice->EndScene();

        // Restore the video memory and continue rendering
        if (RestoreFrameBuffer() && RestoreTextures(g_pd3dDevice)) {
            hr = D3D_OK;
        }
    }

    return hr;
}
*/
//******************************************************************************
//
// Function:
//
//     RestoreFrameBuffer
//
// Description:
//
//     If the surface memory associated with either the primary surface or the  
//     z buffer has been freed, restore it.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
/*
static BOOL RestoreFrameBuffer(void) {

    HRESULT              hr;
    LPDIRECTDRAWSURFACE7 pddsZBuffer;
    DDSCAPS2             ddscaps;

    // If the primary surface has been lost, restore it
    if (g_pddsFront->IsLost() == DDERR_SURFACELOST) {

        hr = g_pddsFront->Restore();
        if (ResultFailed(hr, TEXT("IDirectDrawSurface7::Restore"))) {
            return FALSE;
        }
    }

    // If we are running in windowed mode, restore the back buffer as
    // well since (For full screen mode, the back buffer is an 
    // implicitly created surface and is restored when the front buffer
    // is restored)
    if (g_bWindowed && g_pddsBack->IsLost() == DDERR_SURFACELOST) {
        
        hr = g_pddsBack->Restore();
        if (ResultFailed(hr, TEXT("IDirectDrawSurface7::Restore"))) {
            return FALSE;
        }
    }

    // Get a pointer to the Z-buffer
    memset(&ddscaps, 0, sizeof(DDSCAPS2));
    ddscaps.dwCaps = DDSCAPS_ZBUFFER;

    hr = g_pddsBack->GetAttachedSurface(&ddscaps, &pddsZBuffer);
    if (hr == DDERR_NOTFOUND) {
        // The device isn't using a Z-buffer so we're finished
        return TRUE;
    }
    else if (ResultFailed(hr, TEXT("IDirectDrawSurface7::GetAttachedSurface"))) {
        return FALSE;
    }

    if (pddsZBuffer->IsLost() == DDERR_SURFACELOST) {

        hr = pddsZBuffer->Restore();
        if (ResultFailed(hr, TEXT("IDirectDrawSurface7::Restore"))) {
            pddsZBuffer->Release();
            return FALSE;
        }
    }

    pddsZBuffer->Release();

    return TRUE;
}
*/

#ifndef UNDER_XBOX

//******************************************************************************
BOOL MoveWindowTarget(int x, int y) {

    if (g_disdCurrent.bWindowed && g_pd3dDevice) {
        SetRect(&g_rectWnd, x, y, x + g_d3dsdBack.Width, y + g_d3dsdBack.Height);
    }

    return TRUE;
}

//******************************************************************************
BOOL SizeWindowTarget(int width, int height) {

    if (g_disdCurrent.bWindowed && g_pd3dDevice) {
        g_rectWnd.right = g_rectWnd.left + width;
        g_rectWnd.bottom = g_rectWnd.top + height;
        return UpdateDisplay(g_disdCurrent.pdm, TRUE, g_disdCurrent.bDepthBuffer, 
                             g_disdCurrent.bAntialias);
    }

    return TRUE;
}

#endif 

/*
//******************************************************************************
//##HACK function (see replacement commented out)
BOOL UpdateDisplay(PDISPLAYMODE pdm, BOOL bWindowed, BOOL bDepthBuffer, BOOL bAntialias) {

    DISPLAYDESC             disdLast;
    LPDIRECT3DSURFACE8      pd3ds;
    D3DPRESENT_PARAMETERS   g_d3dpp;
    D3DMATRIX               mTransform;
    HRESULT                 hr;

    if (!g_pd3dDevice) {
        return TRUE;
    }

    // Check if windowed mode is available
//    if (bWindowed && !g_disdCurrent.pdevd->bCanRenderWindowed) {
//        return FALSE;
//    }

    // If no display mode was given, use the current
    if (!pdm) {
        pdm = g_disdCurrent.pdm;
    }

    if (bAntialias && !ANTIALIAS_SUPPORTED(g_disdCurrent.pdevd, pdm, bWindowed)) {
        return FALSE;
    }

    if (bWindowed && !g_disdCurrent.bWindowed) {

        // Restore the window position
        MoveWindow(g_hWnd, g_rectWnd.left - g_rectBorder.left, 
                   g_rectWnd.top - g_rectBorder.top, 
                   g_rectWnd.right - (g_rectWnd.left - g_rectBorder.left) + g_rectBorder.right, 
                   g_rectWnd.bottom - (g_rectWnd.top - g_rectBorder.top) + g_rectBorder.bottom, TRUE);
//        MoveWindow(g_hWnd, g_rectWnd.left, g_rectWnd.top, 
//                   g_rectWnd.right - g_rectWnd.left, 
//                   g_rectWnd.bottom - g_rectWnd.top, TRUE);
    }

    memcpy(&disdLast, &g_disdCurrent, sizeof(DISPLAYDESC));
    g_disdCurrent.pdm = pdm;
    g_disdCurrent.bWindowed = bWindowed;
    g_disdCurrent.bDepthBuffer = bDepthBuffer;
    g_disdCurrent.bAntialias = bAntialias;

//##HACK
if (g_pfnClearDevice) {
    g_pfnClearDevice();
}
ReleaseFontMap();

    // Initialize the presentation parameters
    memset(&g_d3dpp, 0, sizeof(D3DPRESENT_PARAMETERS));
    if (bWindowed) {
//        g_d3dpp.BackBufferFormat                  = D3DFMT_UNKNOWN;
        g_d3dpp.MultiSampleType                   = g_disdCurrent.pdevd->d3dmstWindowed;
        g_d3dpp.AutoDepthStencilFormat            = D3DFMT_D16;
    }
    else {
        g_d3dpp.BackBufferWidth                   = pdm->d3ddm.Width;
        g_d3dpp.BackBufferHeight                  = pdm->d3ddm.Height;
        g_d3dpp.BackBufferFormat                  = pdm->d3ddm.Format;
        g_d3dpp.MultiSampleType                   = pdm->d3dmst;
        g_d3dpp.AutoDepthStencilFormat            = pdm->fmtd;
        g_d3dpp.FullScreen_RefreshRateInHz        = pdm->d3ddm.RefreshRate;
        // REVIEW: The following should be checked against D3DCAPS8 for support
        g_d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
    }
    g_d3dpp.BackBufferCount                       = 1;
    g_d3dpp.SwapEffect                            = D3DSWAPEFFECT_DISCARD;
    g_d3dpp.hDeviceWindow                         = g_hWnd;
    g_d3dpp.Windowed                              = bWindowed;
    g_d3dpp.EnableAutoDepthStencil                = bDepthBuffer;
    if (!bAntialias) {
        g_d3dpp.MultiSampleType                   = D3DMULTISAMPLE_NONE;
    }

    // Reset the device
//##HACK
g_pd3dDevice->Release();
//    hr = g_pd3dDevice->Reset(&g_d3dpp);
hr = g_pd3d->CreateDevice(g_disdCurrent.padpd->uAdapter, g_disdCurrent.pdevd->d3ddt, g_hWnd, g_disdCurrent.pdevd->dwBehavior, &g_d3dpp, &g_pd3dDevice);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::Reset"))) {
        return FALSE;
    }

    // Get the surface description of the back buffer
    hr = g_pd3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pd3ds);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetBackBuffer"))) {
        return FALSE;
    }
    g_d3dsdBack = pd3ds->GetDesc();
    pd3ds->Release();

    // Initialize the viewport
    SetViewport(g_d3dsdBack.Width, g_d3dsdBack.Height);

    // Rebuild the projection transform using the new aspect ratio
    hr = g_pd3dDevice->GetTransform(D3DTS_PROJECTION, &mTransform);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetTransform"))) {
        return FALSE;
    }

    mTransform._22 = 1.0f / ((float)g_d3dsdBack.Height / (float)g_d3dsdBack.Width);

    hr = g_pd3dDevice->SetTransform(D3DTS_PROJECTION, &mTransform);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTransform"))) {
        return FALSE;
    }

    g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, bAntialias);

//##HACK
InitDeviceState();
if (!CreateFontMap()) {
return FALSE;
}
if (g_pfnSetDevice) {
    if (!g_pfnSetDevice()) {
        return FALSE;
    }
}

    // Do not include the amount of time the display took to update in game time calculations
    g_bTimeSync = TRUE;

    return TRUE;
}
*/

//******************************************************************************
BOOL UpdateDisplay(PDISPLAYMODE pdm, BOOL bWindowed, BOOL bDepthBuffer, BOOL bAntialias) {

    DISPLAYDESC             disdLast;
    LPDIRECT3DSURFACE8      pd3ds;
    D3DMATRIX               mTransform;
    HRESULT                 hr;

    if (!g_pd3dDevice) {
        return TRUE;
    }

    // Check if windowed mode is available
    if (bWindowed && !g_disdCurrent.pdevd->bCanRenderWindowed) {
        return FALSE;
    }

    // If no display mode was given, use the current
    if (!pdm) {
        pdm = g_disdCurrent.pdm;
    }

    // Check if antialiasing is available
    if (bAntialias && !ANTIALIAS_SUPPORTED(g_disdCurrent.pdevd, pdm, bWindowed)) {
        return FALSE;
    }

#ifndef UNDER_XBOX
    if (bWindowed && !g_disdCurrent.bWindowed) {

        // Restore the window position
        MoveWindow(g_hWnd, g_rectWnd.left - g_rectBorder.left, 
                   g_rectWnd.top - g_rectBorder.top, 
                   g_rectWnd.right - (g_rectWnd.left - g_rectBorder.left) + g_rectBorder.right, 
                   g_rectWnd.bottom - (g_rectWnd.top - g_rectBorder.top) + g_rectBorder.bottom, TRUE);
//        MoveWindow(g_hWnd, g_rectWnd.left, g_rectWnd.top, 
//                   g_rectWnd.right - g_rectWnd.left, 
//                   g_rectWnd.bottom - g_rectWnd.top, TRUE);
    }
#endif

    memcpy(&disdLast, &g_disdCurrent, sizeof(DISPLAYDESC));
    g_disdCurrent.pdm = pdm;
    g_disdCurrent.bWindowed = bWindowed;
    g_disdCurrent.bDepthBuffer = bDepthBuffer;
    g_disdCurrent.bAntialias = bAntialias;

//##HACK
if (g_pfnClearDevice) {
    g_pfnClearDevice();
}
//##HACK END

    // Initialize the presentation parameters
    memset(&g_d3dpp, 0, sizeof(D3DPRESENT_PARAMETERS));
    if (bWindowed) {
        g_d3dpp.BackBufferFormat                  = D3DFMT_UNKNOWN;
        g_d3dpp.MultiSampleType                   = g_disdCurrent.pdevd->d3dmstWindowed;
        g_d3dpp.AutoDepthStencilFormat            = g_disdCurrent.pdevd->fmtdWindowed;
    }
    else {
        g_d3dpp.BackBufferWidth                   = pdm->d3ddm.Width;
        g_d3dpp.BackBufferHeight                  = pdm->d3ddm.Height;
        g_d3dpp.BackBufferFormat                  = pdm->d3ddm.Format;
        g_d3dpp.MultiSampleType                   = pdm->d3dmst;
        g_d3dpp.AutoDepthStencilFormat            = pdm->fmtd;
        g_d3dpp.FullScreen_RefreshRateInHz        = pdm->d3ddm.RefreshRate;
        // REVIEW: The following should be checked against D3DCAPS8 for support
        g_d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
    }
    g_d3dpp.BackBufferCount                       = 1;
    g_d3dpp.SwapEffect                            = D3DSWAPEFFECT_DISCARD;
    g_d3dpp.hDeviceWindow                         = g_hWnd;
    g_d3dpp.Windowed                              = bWindowed;
    g_d3dpp.EnableAutoDepthStencil                = bDepthBuffer;
    if (!bAntialias) {
        g_d3dpp.MultiSampleType                   = D3DMULTISAMPLE_NONE;
    }

    // Resize the device
    hr = g_pd3dDevice->Reset(&g_d3dpp);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::Reset"))) {
        // Restore the display description
        memcpy(&g_disdCurrent, &disdLast, sizeof(DISPLAYDESC));
        return FALSE;
    }

    // Get the surface description of the back buffer
    hr = g_pd3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pd3ds);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetBackBuffer"))) {
        return FALSE;
    }
    pd3ds->GetDesc(&g_d3dsdBack);
    pd3ds->Release();

    // Initialize the viewport
    SetViewport(g_d3dsdBack.Width, g_d3dsdBack.Height);

    // Rebuild the projection transform using the new aspect ratio
    hr = g_pd3dDevice->GetTransform(D3DTS_PROJECTION, &mTransform);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetTransform"))) {
        return FALSE;
    }

    mTransform._22 = 1.0f / ((float)g_d3dsdBack.Height / (float)g_d3dsdBack.Width);

    hr = g_pd3dDevice->SetTransform(D3DTS_PROJECTION, &mTransform);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTransform"))) {
        return FALSE;
    }

    g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, bAntialias);

//##HACK
InitDeviceState();
if (g_pfnSetDevice) {
    if (!g_pfnSetDevice()) {
        return FALSE;
    }
}
//##HACK END

    // Do not include the amount of time the display took to update in game time calculations
//    g_bTimeSync = TRUE;

    return TRUE;
}

//******************************************************************************
void DisplayFrameRate() {
/*
    if (g_bDisplayFPS) {

        TCHAR sz[256];
        float fHeight = (float)g_d3dsdBack.Height / 20.0f;
        float fWidth = FONT_ASPECT * fHeight;
        UINT  uLen;
        sprintf(sz, TEXT("%.02f fps"), g_fFPS);
        uLen = _tcslen(sz);
        DisplayText(sz, uLen, (float)(g_d3dsdBack.Width / 2) - (float)(uLen / 2) * fWidth, 
                    (float)g_d3dsdBack.Height - (fHeight * 2.0f), fHeight, 
                    RGBA_MAKE(255, 255, 0, 255));
    }
*/
}

//******************************************************************************
void InitSetDeviceProc(SETDEVICEPROC pfnSetDevice) {

    g_pfnSetDevice = pfnSetDevice;
}

//******************************************************************************
void InitClearDeviceProc(CLEARDEVICEPROC pfnClearDevice) {

    g_pfnClearDevice = pfnClearDevice;
}

//******************************************************************************
void InitSubWindowProc(SUBWNDPROC pfnSubWndProc) {

    g_pfnSubWndProc = pfnSubWndProc;
}

//******************************************************************************
//
// Function:
//
//     SetCameraView
//
// Description:
//
//     Update the view and projection matrices based on the given camera data.
//
// Arguments:
//
//     PCAMERA pcam                 - Pointer to the camera information.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL SetCameraView(PCAMERA pcam) {

    D3DXMATRIX      mTransform;
    HRESULT         hr;

    // Initialize the view matrix
    SetView(&mTransform, &pcam->vPosition, &pcam->vInterest, 
            &D3DXVECTOR3((float)sin(pcam->fRoll), (float)cos(pcam->fRoll), 
            0.0f));

    hr = g_pd3dDevice->SetTransform(D3DTS_VIEW, &mTransform);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTransform"))) {
        return FALSE;
    }

    // Initialize the projection matrix
    SetPerspectiveProjection(&mTransform, pcam->fNearPlane, pcam->fFarPlane, 
            pcam->fFieldOfView, (float)g_d3dsdBack.Height / (float)g_d3dsdBack.Width);

    hr = g_pd3dDevice->SetTransform(D3DTS_PROJECTION, &mTransform);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTransform"))) {
        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     UpdateCamera
//
// Description:
//
//     Update the camera state by polling user input from the keyboard
//
// Arguments:
//
//     PCAMERA pcam                 - Pointer to the camera information.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
void UpdateCamera(PCAMERA pcam) {

#ifndef UNDER_XBOX
    static KEYSDOWN     kdLastKeys = 0;
    static D3DXVECTOR3  vViewTranslation = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
    static D3DXVECTOR3  vViewRotation = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
    static D3DXMATRIX   mViewRotationX = D3DXMATRIX(
                            1.0f, 0.0f, 0.0f, 0.0f,
                            0.0f, 1.0f, 0.0f, 0.0f,
                            0.0f, 0.0f, 1.0f, 0.0f,
                            0.0f, 0.0f, 0.0f, 1.0f
                        );
    static D3DXMATRIX   mViewRotationY = mViewRotationX;

    // Poll the keyboard
    if (g_kdKeys != kdLastKeys) {

        if (g_kdKeys & KEY_PAGEDOWN) {
            vViewTranslation.x = -g_fCameraTDelta;
        }
        else if (g_kdKeys & KEY_DELETE) {
            vViewTranslation.x = g_fCameraTDelta;
        }
        else {
            vViewTranslation.x = 0.0f;
        }

        if (g_kdKeys & KEY_HOME) {
            vViewTranslation.y = -g_fCameraTDelta;
        }
        else if (g_kdKeys & KEY_END) {
            vViewTranslation.y = g_fCameraTDelta;
        }
        else {
            vViewTranslation.y = 0.0f;
        }

        if (g_kdKeys & KEY_ADD || g_kdKeys & KEY_PAGEUP) {
            vViewTranslation.z = -g_fCameraTDelta;
        }
        else if (g_kdKeys & KEY_SUBTRACT || g_kdKeys & KEY_INSERT) {
            vViewTranslation.z = g_fCameraTDelta;
        }
        else {
            vViewTranslation.z = 0.0f;
        }

        if (g_kdKeys & KEY_LEFT) {
            vViewRotation.y = -g_fCameraRDelta;
        }
        else if (g_kdKeys & KEY_RIGHT) {
            vViewRotation.y = g_fCameraRDelta;
        }
        else {
            vViewRotation.y = 0.0f;
        }

        if (g_kdKeys & KEY_UP) {
            vViewRotation.x = -g_fCameraRDelta;
        }
        else if (g_kdKeys & KEY_DOWN) {
            vViewRotation.x = g_fCameraRDelta;
        }
        else {
            vViewRotation.x = 0.0f;
        }
    }

    kdLastKeys = g_kdKeys;

    if (pcam) {

        D3DXMATRIX  mView, mViewTransform;
        D3DXVECTOR3 vTranslation, vDirection, vUp, vProj, vCross;
        D3DXVECTOR3 vViewTrans = vViewTranslation;
        float       fMagnitude, fDot, fScaleX, fScaleY, fTheta;
        BOOL        bOrbit = (BOOL)(g_kdKeys & KEY_SHIFT);

        if (!bOrbit) {
            vDirection = pcam->vInterest - pcam->vPosition;
        }
        else {
            vDirection = pcam->vPosition - pcam->vInterest;
        }
        fMagnitude = D3DXVec3Length(&vDirection);
        D3DXVec3Normalize(&vDirection, &vDirection);
        vUp = D3DXVECTOR3((float)sin(pcam->fRoll), (float)cos(pcam->fRoll), 0.0f);
        // Project the direction vector into a plane orthogonal to the up vector.
        // The resulting vector will originate at the point the projected direction
        // vector intersects with the plane and terminate at the up vector/
        // The DotProduct gives the ratio between the magnitude of the direction
        // vector and the scalar projection of the direction vector onto the up
        // vector.  Multiplying by this scales the direction vector out to the
        // point that it will intersect with the up vector's orthogonal plane
        fDot = D3DXVec3Dot(&vUp, &vDirection);
        D3DXVec3Normalize(&vProj, &(vUp - (vDirection * fDot)));
        D3DXVec3Cross(&vCross, &vProj, &vDirection);

        fScaleY = (fDot < 0.0f) ? -fDot : fDot;
        fTheta = (float)acos(fScaleY);
        fScaleY = fTheta / M_PIDIV2;

        if (bOrbit) {
            fScaleY *= -3.0f;
            fScaleX = 3.0f;
        }
        else {
            fScaleX = 1.0f;
        }

        mViewRotationY._11 = (float)cos(vViewRotation.y * fScaleY);
        mViewRotationY._13 = (float)-sin(vViewRotation.y * fScaleY);
        mViewRotationY._31 = -mViewRotationY._13;
        mViewRotationY._33 = mViewRotationY._11;

        mViewRotationX._22 = (float)cos(vViewRotation.x * fScaleX);
        mViewRotationX._23 = (float)sin(vViewRotation.x * fScaleX);
        mViewRotationX._32 = -mViewRotationX._23;
        mViewRotationX._33 = mViewRotationX._22;

        InitMatrix(&mViewTransform,
            vCross.x,       vCross.y,       vCross.z,       0.0f,
            vProj.x,        vProj.y,        vProj.z,        0.0f,
            vDirection.x,   vDirection.y,   vDirection.z,   0.0f,
            0.0f,           0.0f,           0.0f,           1.0f
        );

        D3DXMatrixMultiply(&mView, &mViewRotationX, &mViewTransform);
        D3DXMatrixMultiply(&mViewTransform, &mViewRotationY, &mView);

        if (!bOrbit) {
            D3DXVec3TransformCoord(&pcam->vInterest, 
                                &D3DXVECTOR3(0.0f, 0.0f, fMagnitude), &mViewTransform);
            pcam->vInterest += pcam->vPosition;
        }
        else {
            D3DXVec3TransformCoord(&pcam->vPosition, 
                                &D3DXVECTOR3(0.0f, 0.0f, fMagnitude), &mViewTransform);
            pcam->vPosition += pcam->vInterest;
            vViewTrans.x = -vViewTrans.x;
            vViewTrans.z = -vViewTrans.z;
        }
        D3DXVec3TransformCoord(&vTranslation, &vViewTrans, &mViewTransform);
        pcam->vPosition -= vTranslation;
        pcam->vInterest -= vTranslation;

        if (fDot != 0.0f) {
            float fPol = (fDot < 0.0f) ? 1.0f : -1.0f;
            if ((fPol * vViewRotation.x * fScaleX) > fTheta) {
                pcam->fRoll += M_PI;
                if (pcam->fRoll > M_PI) {
                    pcam->fRoll -= M_2PI;
                }
            }
        }
    }
#endif
}

#ifndef UNDER_XBOX

//******************************************************************************
// Menu functions
//******************************************************************************

//******************************************************************************
static HMENU CreateMainMenu() {

    HMENU hMenu, hMenuFile;

    // If the application has supplied a menu, load and return it
    hMenu = LoadMenu(GetModuleHandle(NULL), TEXT("IDR_MENU"));
    if (hMenu) {
        return hMenu;
    }

    // Otherwise create a default menu
    hMenu = CreateMenu();

    hMenuFile = CreateMenu();

    AppendMenu(hMenuFile, MF_STRING, IDM_DEFAULT_FILE_DISPLAY, TEXT("&Display...\tF2"));
    AppendMenu(hMenuFile, MF_SEPARATOR, 0, NULL);
    AppendMenu(hMenuFile, MF_STRING, IDM_DEFAULT_FILE_EXIT, TEXT("E&xit\tEsc"));

    AppendMenu(hMenu, MF_POPUP, (UINT)hMenuFile, TEXT("&File"));

    return hMenu;
}

//******************************************************************************
static BOOL CALLBACK DisplayDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    static PDISPLAYDESC pdisd;
    PADAPTERDESC        padpd;
    PDEVICEDESC         pdevd;
    PDISPLAYMODE        pdm;
    TCHAR               szMode[512];
    int                 sel;
    TCHAR*              pszDevice[] = {
                            TEXT(""),
                            TEXT("NULL"),
                            TEXT("Abstraction (HAL)"),
                            TEXT("Reference (REF)"),
                            TEXT("Emulation (SW)"),
                        };

    switch (uMsg) {

        case WM_INITDIALOG:

            // ##REVIEW: Change all of the g_disdCurrent references in WM_INITDIALOG to pdisd references?
            pdisd = (PDISPLAYDESC)lParam;

            // Fill the adapter list
            for (padpd = g_padpdList; padpd; padpd = padpd->padpdNext) {
                // REVIEW: Adapter info strings are currently char...if they aren't changed to TCHAR a conversion must be performed
                sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_ADAPTER, CB_ADDSTRING, 0, (LPARAM)padpd->d3dai.Description);
                SendDlgItemMessage(hDlg, IDC_DISPLAY_ADAPTER, CB_SETITEMDATA, (WPARAM)sel, (LPARAM)padpd);
                if (g_disdCurrent.padpd == padpd) {
                    SendDlgItemMessage(hDlg, IDC_DISPLAY_ADAPTER, CB_SETCURSEL, (WPARAM)sel, 0);
                }
            }

            // Fill the device list
            for (pdevd = g_disdCurrent.padpd->pdevdList; pdevd; pdevd = pdevd->pdevdNext) {
                sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_ADDSTRING, 0, (LPARAM)pszDevice[pdevd->d3ddt]);
                SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_SETITEMDATA, (WPARAM)sel, (LPARAM)pdevd);
                if (g_disdCurrent.pdevd == pdevd) {
                    SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_SETCURSEL, (WPARAM)sel, 0);
                }
            }

            // Fill the display mode
            for (pdm = g_disdCurrent.pdevd->pdmList; pdm; pdm = pdm->pdmNext) {
                if (pdm->d3ddm.RefreshRate) {
                    wsprintf(szMode, TEXT("%d x %d x %d  %d Hz"), pdm->d3ddm.Width, pdm->d3ddm.Height, FormatToBitDepth(pdm->d3ddm.Format), pdm->d3ddm.RefreshRate);
                }
                else {
                    wsprintf(szMode, TEXT("%d x %d x %d"), pdm->d3ddm.Width, pdm->d3ddm.Height, FormatToBitDepth(pdm->d3ddm.Format));
                }
                sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_ADDSTRING, 0, (LPARAM)szMode);
                SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_SETITEMDATA, (WPARAM)sel, (LPARAM)pdm);
                if (pdm == g_disdCurrent.pdm) {
                    SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_SETCURSEL, (WPARAM)sel, 0);
                }
            }

            SendDlgItemMessage(hDlg, IDC_DISPLAY_FULLSCREEN, BM_SETCHECK, (BOOL)!g_disdCurrent.bWindowed, 0);
            EnableWindow(GetDlgItem(hDlg, IDC_DISPLAY_FULLSCREEN), g_disdCurrent.pdevd->bCanRenderWindowed);
            EnableWindow(GetDlgItem(hDlg, IDC_DISPLAY_MODE), !g_disdCurrent.bWindowed);

            SendDlgItemMessage(hDlg, IDC_DISPLAY_DEPTHBUFFER, BM_SETCHECK, g_disdCurrent.bDepthBuffer, 0);
            if (ANTIALIAS_SUPPORTED(g_disdCurrent.pdevd, g_disdCurrent.pdm, g_disdCurrent.bWindowed)) {
                SendDlgItemMessage(hDlg, IDC_DISPLAY_ANTIALIAS, BM_SETCHECK, g_disdCurrent.bAntialias, 0);
            }
            else {
                SendDlgItemMessage(hDlg, IDC_DISPLAY_ANTIALIAS, BM_SETCHECK, FALSE, 0);
                EnableWindow(GetDlgItem(hDlg, IDC_DISPLAY_ANTIALIAS), FALSE);
            }

            return TRUE;

        case WM_COMMAND:

            switch (LOWORD(wParam)) {

                case IDC_DISPLAY_FULLSCREEN:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        PDEVICEDESC pdevd;
                        PDISPLAYMODE pdm;
                        BOOL bAntialias;
                        BOOL bFullscreen = SendDlgItemMessage(hDlg, IDC_DISPLAY_FULLSCREEN, BM_GETCHECK, 0, 0);
                        EnableWindow(GetDlgItem(hDlg, IDC_DISPLAY_MODE), bFullscreen);

                        sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_GETCURSEL, 0, 0);
                        pdevd = (PDEVICEDESC)SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_GETITEMDATA, (WPARAM)sel, 0);
                        sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_GETCURSEL, 0, 0);
                        pdm = (PDISPLAYMODE)SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_GETITEMDATA, (WPARAM)sel, 0);
                        bAntialias = ANTIALIAS_SUPPORTED(pdevd, pdm, !bFullscreen);
                        if (!bAntialias) {
                            SendDlgItemMessage(hDlg, IDC_DISPLAY_ANTIALIAS, BM_SETCHECK, FALSE, 0);
                        }
                        EnableWindow(GetDlgItem(hDlg, IDC_DISPLAY_ANTIALIAS), bAntialias);
                        return TRUE;
                    }
                    break;

                case IDC_DISPLAY_ADAPTER:

                    if (HIWORD(wParam) == CBN_SELCHANGE) {

                        PADAPTERDESC padpdCurrent;
                        PDEVICEDESC  pdevdDefault, pdevdLast;
                        int          def;

                        // Get the current device selection
                        sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_GETCURSEL, 0, 0);
                        pdevdLast = (PDEVICEDESC)SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_GETITEMDATA, (WPARAM)sel, 0);

                        // Clear the device list
                        SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_RESETCONTENT, 0, 0);

                        // Get the new adapter
                        sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_ADAPTER, CB_GETCURSEL, 0, 0);
                        padpdCurrent = (PADAPTERDESC)SendDlgItemMessage(hDlg, IDC_DISPLAY_ADAPTER, CB_GETITEMDATA, (WPARAM)sel, 0);

                        // Select a default device for the adapter
                        pdevdDefault = SelectDevice(padpdCurrent);

                        // Add the devices for the new adapter
                        for (pdevd = padpdCurrent->pdevdList; pdevd; pdevd = pdevd->pdevdNext) {

                            sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_ADDSTRING, 0, (LPARAM)pszDevice[pdevd->d3ddt]);
                            SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_SETITEMDATA, (WPARAM)sel, (LPARAM)pdevd);

                            // If the new adapter supports the same device that was selected for the old
                            // adapter, select the device again
                            if (pdevd->d3ddt == pdevdLast->d3ddt) {
                                SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_SETCURSEL, (WPARAM)sel, 0);
                            }

                            // If the device matches the default device, save the index
                            if (pdevd == pdevdDefault) {
                                def = sel;
                            }
                        }

                        // If no device has been selected (the new adapter does not support the old selected device)
                        // select the default as current
                        sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_GETCURSEL, 0, 0);
                        if (sel == CB_ERR) {
                            SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_SETCURSEL, (WPARAM)def, 0);
                        }

                        // Update the display mode list for the new device
                        SendMessage(hDlg, WM_COMMAND, MAKELPARAM(IDC_DISPLAY_DEVICE, CBN_SELCHANGE), (LPARAM)GetDlgItem(hDlg, IDC_DISPLAY_DEVICE));

                        return TRUE;
                    }
                    break;

                case IDC_DISPLAY_DEVICE:

                    if (HIWORD(wParam) == CBN_SELCHANGE) {

                        PDEVICEDESC  pdevdCurrent;
                        PDISPLAYMODE pdmDefault, pdmLast;
                        int          def;
                        BOOL         bEnable;

                        // Get the current display mode selection
                        sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_GETCURSEL, 0, 0);
                        pdmLast = (PDISPLAYMODE)SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_GETITEMDATA, (WPARAM)sel, 0);

                        // Clear the display mode list
                        SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_RESETCONTENT, 0, 0);

                        // Get the new device
                        sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_GETCURSEL, 0, 0);
                        pdevdCurrent = (PDEVICEDESC)SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_GETITEMDATA, (WPARAM)sel, 0);

                        // Select a default display mode for the device
                        pdmDefault = SelectDisplayMode(pdevdCurrent);

                        // Add the display modes for the new device
                        for (pdm = pdevdCurrent->pdmList; pdm; pdm = pdm->pdmNext) {

                            if (pdm->d3ddm.RefreshRate) {
                                wsprintf(szMode, TEXT("%d x %d x %d  %d Hz"), pdm->d3ddm.Width, pdm->d3ddm.Height, FormatToBitDepth(pdm->d3ddm.Format), pdm->d3ddm.RefreshRate);
                            }
                            else {
                                wsprintf(szMode, TEXT("%d x %d x %d"), pdm->d3ddm.Width, pdm->d3ddm.Height, FormatToBitDepth(pdm->d3ddm.Format));
                            }
                            sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_ADDSTRING, 0, (LPARAM)szMode);
                            SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_SETITEMDATA, (WPARAM)sel, (LPARAM)pdm);

                            // If the new device supports the same display mode that was selected for the old
                            // device, select the mode again
                            if (pdm->d3ddm.Width == pdmLast->d3ddm.Width &&
                                pdm->d3ddm.Height == pdmLast->d3ddm.Height &&
                                pdm->d3ddm.Format == pdmLast->d3ddm.Format &&
                                pdm->d3ddm.RefreshRate == pdmLast->d3ddm.RefreshRate) 
                            {
                                SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_SETCURSEL, (WPARAM)sel, 0);
                            }

                            // If the display mode matches the default, save the index
                            if (pdm == pdmDefault) {
                                def = sel;
                            }
                        }

                        // If no mode has been selected (the new device does not support the old selected mode)
                        // select the default as current
                        sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_GETCURSEL, 0, 0);
                        if (sel == CB_ERR) {
                            SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_SETCURSEL, (WPARAM)def, 0);
                        }

                        // If the device does not supported rendering in a windowed state, select and
                        // disable the full screen check box
                        if (!pdevdCurrent->bCanRenderWindowed) {
                            SendDlgItemMessage(hDlg, IDC_DISPLAY_FULLSCREEN, BM_SETCHECK, (WPARAM)TRUE, 0);
                        }
                        EnableWindow(GetDlgItem(hDlg, IDC_DISPLAY_FULLSCREEN), pdevdCurrent->bCanRenderWindowed);
                        bEnable = SendDlgItemMessage(hDlg, IDC_DISPLAY_FULLSCREEN, BM_GETCHECK, 0, 0);
                        EnableWindow(GetDlgItem(hDlg, IDC_DISPLAY_MODE), bEnable);

                        // Update the antialias check box
                        SendMessage(hDlg, WM_COMMAND, MAKELPARAM(IDC_DISPLAY_MODE, CBN_SELCHANGE), (LPARAM)GetDlgItem(hDlg, IDC_DISPLAY_MODE));

                        return TRUE;
                    }
                    break;

                case IDC_DISPLAY_MODE:

                    if (HIWORD(wParam) == CBN_SELCHANGE) {
                        PDEVICEDESC pdevd;
                        PDISPLAYMODE pdm;
                        BOOL bAntialias;
                        BOOL bFullscreen = SendDlgItemMessage(hDlg, IDC_DISPLAY_FULLSCREEN, BM_GETCHECK, 0, 0);
                        sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_GETCURSEL, 0, 0);
                        pdevd = (PDEVICEDESC)SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_GETITEMDATA, (WPARAM)sel, 0);
                        sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_GETCURSEL, 0, 0);
                        pdm = (PDISPLAYMODE)SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_GETITEMDATA, (WPARAM)sel, 0);
                        bAntialias = ANTIALIAS_SUPPORTED(pdevd, pdm, !bFullscreen);
                        if (!bAntialias) {
                            SendDlgItemMessage(hDlg, IDC_DISPLAY_ANTIALIAS, BM_SETCHECK, FALSE, 0);
                        }
                        EnableWindow(GetDlgItem(hDlg, IDC_DISPLAY_ANTIALIAS), bAntialias);
                        return TRUE;
                    }
                    break;

                case IDOK:
                    // Update the current driver, device, window state, and display mode
                    sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_ADAPTER, CB_GETCURSEL, 0, 0);
                    pdisd->padpd = (PADAPTERDESC)SendDlgItemMessage(hDlg, IDC_DISPLAY_ADAPTER, CB_GETITEMDATA, (WPARAM)sel, 0);
                    sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_GETCURSEL, 0, 0);
                    pdisd->pdevd = (PDEVICEDESC)SendDlgItemMessage(hDlg, IDC_DISPLAY_DEVICE, CB_GETITEMDATA, (WPARAM)sel, 0);
                    sel = SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_GETCURSEL, 0, 0);
                    pdisd->pdm = (PDISPLAYMODE)SendDlgItemMessage(hDlg, IDC_DISPLAY_MODE, CB_GETITEMDATA, (WPARAM)sel, 0);
                    pdisd->bWindowed = !((BOOL)SendDlgItemMessage(hDlg, IDC_DISPLAY_FULLSCREEN, BM_GETCHECK, 0, 0));
                    pdisd->bDepthBuffer = (BOOL)SendDlgItemMessage(hDlg, IDC_DISPLAY_DEPTHBUFFER, BM_GETCHECK, 0, 0);
                    pdisd->bAntialias = (BOOL)SendDlgItemMessage(hDlg, IDC_DISPLAY_ANTIALIAS, BM_GETCHECK, 0, 0);

                case IDCANCEL:
                    EndDialog(hDlg, wParam);
                    return TRUE;
            }

            break;
    }

    return FALSE;
}

//******************************************************************************
static void AddDlgItemTemplate(LPWORD* ppw, WORD wClass, LPWSTR wszText, 
            WORD wId, short x, short y, short cx, short cy, DWORD dwStyle) 
{
    LPDLGITEMTEMPLATE pdit;
    LPWSTR            wsz;
    LPWORD            pw = *ppw;

    pdit = (LPDLGITEMTEMPLATE)((((DWORD)pw) + 3) & ~3);    // Align the data
    pdit->style           = WS_VISIBLE | WS_CHILD | dwStyle;
    pdit->dwExtendedStyle = 0;
    pdit->x               = x;
    pdit->y               = y;
    pdit->cx              = cx;
    pdit->cy              = cy;
    pdit->id              = wId;

    pw = (LPWORD)(pdit+1);
    *pw++ = 0xFFFF;                         // System class
    *pw++ = wClass;                         // Class ordinal
    wsz = (LPWSTR)pw;
    wcscpy(wsz, wszText);                   // Item text
    pw = (LPWORD)(wsz + wcslen(wsz) + 1);
    *pw++ = 0;                              // No creation data
    *ppw = pw;
}

//******************************************************************************
void SelectDisplay() {

    LPDLGTEMPLATE     pTemplate;
    LPWORD            pw;
    LPWSTR            wsz;
    DISPLAYDESC       disd;
    int               ret;

    // Save the current display state
    memcpy(&disd, &g_disdCurrent, sizeof(DISPLAYDESC));

    pTemplate = (LPDLGTEMPLATE)MemAlloc(sizeof(DLGTEMPLATE) + 3 * sizeof(WORD) + 
                                        512 * sizeof(WCHAR) + 
                                        11 * (sizeof(DLGITEMTEMPLATE) +
                                        (5 * sizeof(WORD) + 256 * sizeof(WCHAR))));
    if (!pTemplate) {
        return;
    }

    // Initialize the dialog template
    pTemplate->style = WS_POPUP | WS_CAPTION | WS_SYSMENU | DS_MODALFRAME | DS_CENTER | DS_SETFONT;
    pTemplate->cdit  = 11;
    pTemplate->x     = 0;
    pTemplate->y     = 0;
    pTemplate->cx    = 149;
    pTemplate->cy    = 138;
    pTemplate->dwExtendedStyle = 0;

    pw = (LPWORD)(pTemplate+1);
    *pw++ = 0;                                  // No menu
    *pw++ = 0;                                  // Default dialog class
    
    // Specify the caption for the dialog
    wsz = (LPWSTR)pw;
    wcscpy(wsz, L"Display");                    // Caption
    pw = (LPWORD)(wsz + wcslen(wsz) + 1);
    *pw++ = 8;                                  // 8 point font
    wsz = (LPWSTR)pw;
    wcscpy(wsz, L"MS Sans Serif");              // MS Sans Serif typeface
    pw = (LPWORD)(wsz + wcslen(wsz) + 1);

    // Specify the controls of the dialog
    AddDlgItemTemplate(&pw, 0x0085, L"", IDC_DISPLAY_ADAPTER, 13, 16, 123, 50, CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP);
    AddDlgItemTemplate(&pw, 0x0080, L"Adapter", IDC_STATIC, 7, 7, 135, 27, WS_GROUP | BS_GROUPBOX);
    AddDlgItemTemplate(&pw, 0x0085, L"", IDC_DISPLAY_DEVICE, 13, 48, 123, 50, CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP);
    AddDlgItemTemplate(&pw, 0x0080, L"Device", IDC_STATIC, 7, 38, 135, 27, WS_GROUP | BS_GROUPBOX);
    AddDlgItemTemplate(&pw, 0x0080, L"", IDC_STATIC, 7, 70, 135, 27, WS_GROUP | BS_GROUPBOX);
    AddDlgItemTemplate(&pw, 0x0080, L"F&ull screen", IDC_DISPLAY_FULLSCREEN, 13, 68, 50, 10, BS_AUTOCHECKBOX | WS_TABSTOP);
    AddDlgItemTemplate(&pw, 0x0085, L"", IDC_DISPLAY_MODE, 13, 79, 123, 100, CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP);
    AddDlgItemTemplate(&pw, 0x0080, L"&Depth Buffer", IDC_DISPLAY_DEPTHBUFFER, 13, 102, 56, 10, BS_AUTOCHECKBOX | WS_TABSTOP);
    AddDlgItemTemplate(&pw, 0x0080, L"&Antialias", IDC_DISPLAY_ANTIALIAS, 83, 102, 42, 10, BS_AUTOCHECKBOX | WS_TABSTOP);
    AddDlgItemTemplate(&pw, 0x0080, L"OK", IDOK, 38, 117, 50, 14, BS_DEFPUSHBUTTON | WS_TABSTOP);
    AddDlgItemTemplate(&pw, 0x0080, L"Cancel", IDCANCEL, 92, 117, 50, 14, WS_TABSTOP);

    // Display the dialog in a full screen state
    if (g_pd3dDevice && !g_disdCurrent.bWindowed) {
//        g_pd3dDevice->FlipToGDISurface();
        DrawMenuBar(g_hWnd);
        RedrawWindow(g_hWnd, NULL, NULL, RDW_FRAME);
    }

    // Create the display dialog
    ret = DialogBoxIndirectParam(GetModuleHandle(NULL), pTemplate, g_hWnd, DisplayDlgProc, (LPARAM)&disd);

    MemFree(pTemplate);

    // Do not include the amount of time the dialog was open in game time calculations
//    g_bTimeSync = TRUE;

    if (ret != IDOK) {
        return;
    }

    // If the display driver or device has been changed, recreate everything
    if (g_disdCurrent.padpd != disd.padpd || g_disdCurrent.pdevd != disd.pdevd) {
        if (g_pfnClearDevice) {
            g_pfnClearDevice();
        }
        g_pd3dDevice->Release();
        g_pd3dDevice = NULL;
        if (!CreateDevice(disd.padpd, disd.pdevd, disd.pdm, disd.bWindowed, disd.bDepthBuffer, disd.bAntialias) ||
            (g_pfnSetDevice && !g_pfnSetDevice())) 
        {
            DestroyWindow(g_hWnd);
        }
/*
        // Save the current state of the display as the default
        SetRect(&g_rectWndDefault,
                g_rectWnd.left - g_rectBorder.left,
                g_rectWnd.top - g_rectBorder.top,
                g_rectWnd.right + g_rectBorder.right,
                g_rectWnd.bottom + g_rectBorder.bottom);
//        g_bWindowedDefault = disd.bWindowed;
        memcpy(&g_drvdDefault, disd.padpd, sizeof(DRIVERDESC));
        memcpy(&g_devdDefault, disd.pdevd, sizeof(DEVICEDESC));
        memcpy(&g_dmDefault, disd.pdm, sizeof(DISPLAYMODE));
        g_bRestart = TRUE;
        SendMessage(g_hWnd, WM_CLOSE, 0, 0);
*/
    }

    // If the state of the display has changed, update the display
    else if (g_disdCurrent.pdm != disd.pdm ||
             g_disdCurrent.bWindowed != disd.bWindowed ||
             g_disdCurrent.bDepthBuffer != disd.bDepthBuffer ||
             g_disdCurrent.bAntialias != disd.bAntialias) 
    {
        UpdateDisplay(disd.pdm, disd.bWindowed, disd.bDepthBuffer, disd.bAntialias);
    }
}

#endif

} // namespace DXCONIO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\fontmap.h ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    fontmap.h

Description:

    Functions for creating and indexing into a font texture.

*******************************************************************************/

#ifndef __FONTMAP_H__
#define __FONTMAP_H__

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#define FONT_TCOORD_WIDTH   0.0625f
#define FONT_TCOORD_HEIGHT  0.1171875f

#define CHAR_TO_TCOORD(c)  (&g_ptcFont[(c < ' ' || c > '~') ? (' ') : (c - ' ')])

namespace DXCONIO {

//******************************************************************************
// Globals
//******************************************************************************

extern LPDIRECT3DTEXTURE8   g_pd3dtFontMap;
extern TCOORD               g_ptcFont[96];

//******************************************************************************
// Function prototypes
//******************************************************************************

BOOL                        CreateFontMap(D3DFORMAT fmt = D3DFMT_A1R5G5B5);
void                        ReleaseFontMap();

} // namespace DXCONIO

#endif //__FONTMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\main.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    main.cpp

Description:

    Direct3D Immediate-Mode Framework.

*******************************************************************************/

#define _DXCONIO_EXPORT_
#define DXCONIO_NO_OVERRIDES

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3denum.h"
#include "d3dinit.h"
#include "main.h"
#include "util.h"
#include "conio.h"
#include "dxconio.h"

//******************************************************************************
// Globals
//******************************************************************************

namespace DXCONIO {

BOOL g_bInitialized;

}

using namespace DXCONIO;

//******************************************************************************
// Functions
//******************************************************************************

//******************************************************************************
BOOL __cdecl ConsoleStartup() {

    g_bInitialized = FALSE;
    return LoadConsole();
}

//******************************************************************************
void __cdecl ConsoleShutdown() {

    UnloadConsole();
}

#ifndef UNDER_XBOX

//******************************************************************************
// DllMain
//******************************************************************************

//******************************************************************************
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved) {

    switch (dwReason) {

        case DLL_PROCESS_ATTACH: {

            if (!ConsoleStartup()) {
                return FALSE;
            }

            break;
        }

        case DLL_PROCESS_DETACH:

            ConsoleShutdown();
            break;
    }

    return TRUE;
}

#endif // !UNDER_XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\texture.h ===
/*******************************************************************************

Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

File Name:

    texture.h

Description:

    Direct3D texture routines.

*******************************************************************************/

#ifndef __TEXTURE_H__
#define __TEXTURE_H__

#define COLORKEY_NONE       0xFF000000
#define COLORKEY_PIXEL1     0x01000000

#define TTYPE_TEXTURE       0x0000
#define TTYPE_CUBEMAP       0x0001
#define TTYPE_VOLUME        0x0002
#define TTYPE_BUMPMAP       0x0004
#define TTYPE_MIPMAP        0x0100
#define TTYPE_TARGET        0x0200
#define TTYPE_DEPTH         0x0400
#define TTYPE_RMASK         0x00FF

namespace DXCONIO {

typedef DWORD               TEXTURETYPE;

//******************************************************************************
// Function prototypes
//******************************************************************************

LPDIRECT3DBASETEXTURE8  CreateTexture(UINT uWidth, UINT uHeight,
                                    D3DFORMAT fmt, 
                                    TEXTURETYPE tt = TTYPE_TEXTURE,
                                    D3DPOOL pool = D3DPOOL_DEFAULT);
LPDIRECT3DBASETEXTURE8  CreateTexture(UINT uWidth, UINT uHeight, UINT uDepth,
                                    D3DFORMAT fmt, 
                                    TEXTURETYPE tt = TTYPE_TEXTURE,
                                    D3DPOOL pool = D3DPOOL_DEFAULT);
LPDIRECT3DBASETEXTURE8  CreateTexture(LPCTSTR szName, D3DFORMAT fmt,
                                    TEXTURETYPE tt = TTYPE_TEXTURE,
                                    PALETTEENTRY* pcPalette = NULL,
                                    float fAlpha = 1.0f,
                                    D3DCOLOR cColorKey = COLORKEY_NONE,
                                    UINT uWidth = D3DX_DEFAULT, 
                                    UINT uHeight = D3DX_DEFAULT);
void                    ReleaseTexture(LPDIRECT3DBASETEXTURE8 pd3dt);
void                    ReleaseTextures();

BOOL                    SetTranslucency(LPDIRECT3DBASETEXTURE8 pd3dt, 
                                    PALETTEENTRY* pcPalette, float fAlpha, 
                                    D3DCOLOR cColorKey = COLORKEY_NONE);

DWORD                   ColorToPixel(LPDIRECT3DSURFACE8 pd3dt, 
                                    PALETTEENTRY* pcPalette, D3DCOLOR c);

HRESULT                 CopyTexture(LPDIRECT3DBASETEXTURE8 pd3dtDst,
                                    PALETTEENTRY* pcPalDst,
                                    LPDIRECT3DBASETEXTURE8 pd3dtSrc,
                                    PALETTEENTRY* pcPalSrc, DWORD dwFilter);

LPDIRECT3DTEXTURE8      CreateDiffuseMap(UINT uWidth, UINT uHeight, D3DCOLOR c,
                                    D3DFORMAT fmt, BOOL bMipmap = FALSE,
                                    PALETTEENTRY* pcPalette = NULL,
                                    D3DPOOL pool = D3DPOOL_DEFAULT);

BOOL                    SetDiffuseMapCoords(D3DVECTOR* pvNormal, UINT uNStride, 
                                    PTCOORD ptcTCoord, UINT uTStride, 
                                    UINT uVertices, D3DMATRIX* pmWorld, 
                                    D3DVECTOR* pvLightDir, float fTheta);

//******************************************************************************
// Inline functions
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     SetColorStage
//
// Description:
//
//     Set the texture stage color states for the given stage and operation
//     to the given arguments.
//
// Arguments:
//
//     DWORD dwStage                        - Texture stage
//
//     DWORD dwArg1                         - First color argument
//
//     DWORD dwArg2                         - Second color argument
//
//     D3DTEXTUREOP                         - Color operation
//
// Return Value:
//
//     An HRESULT returned by IDirect3DDevice3::SetTextureStageState
//
//******************************************************************************
inline HRESULT SetColorStage(DWORD dwStage, DWORD dwArg1, DWORD dwArg2, D3DTEXTUREOP d3dtop)
{
    HRESULT hr;
    hr = g_pd3dDevice->SetTextureStageState(dwStage, D3DTSS_COLOROP, d3dtop);
    if (FAILED(hr)) {
        return hr;
    }
    hr = g_pd3dDevice->SetTextureStageState(dwStage, D3DTSS_COLORARG1, dwArg1);
    if (FAILED(hr)) {
        return hr;
    }
    hr = g_pd3dDevice->SetTextureStageState(dwStage, D3DTSS_COLORARG2, dwArg2);
    return hr;
}

//******************************************************************************
//
// Function:
//
//     SetAlphaStage
//
// Description:
//
//     Set the texture stage alpha states for the given stage and operation
//     to the given arguments.
//
// Arguments:
//
//     DWORD dwStage                        - Texture stage
//
//     DWORD dwArg1                         - First alpha argument
//
//     DWORD dwArg2                         - Second alpha argument
//
//     D3DTEXTUREOP                         - Alpha operation
//
// Return Value:
//
//     An HRESULT returned by IDirect3DDevice3::SetTextureStageState
//
//******************************************************************************
inline HRESULT SetAlphaStage(DWORD dwStage, DWORD dwArg1, DWORD dwArg2, D3DTEXTUREOP d3dtop)
{
    HRESULT hr;
    hr = g_pd3dDevice->SetTextureStageState(dwStage, D3DTSS_ALPHAOP, d3dtop);
    if (FAILED(hr)) {
        return hr;
    }
    hr = g_pd3dDevice->SetTextureStageState(dwStage, D3DTSS_ALPHAARG1, dwArg1);
    if (FAILED(hr)) {
        return hr;
    }
    hr = g_pd3dDevice->SetTextureStageState(dwStage, D3DTSS_ALPHAARG2, dwArg2);
    return hr;
}

} // namespace DXCONIO

#endif //__TEXTURE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\texture.cpp ===
/*******************************************************************************

Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

File Name:

    texture.cpp

Description:

    Direct3D texture routines.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include <limits.h>
#include "d3denum.h"
#include "d3dinit.h"
#include "util.h"
#include "texture.h"

#ifdef UNDER_XBOX
#define DEMO_HACK
#endif

namespace DXCONIO {

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

//******************************************************************************
// Structures
//******************************************************************************

typedef struct _TEXTUREDESC {
    LPDIRECT3DBASETEXTURE8  pd3dt;
    TCHAR                   szName[MAX_PATH];
    WORD                    wResourceID;
    UINT                    uWidth;
    UINT                    uHeight;
    UINT                    uDepth;
    D3DFORMAT               fmt;
    TEXTURETYPE             tt;
    D3DPOOL                 pool;
    float                   fAlpha;
    D3DCOLOR                cColorKey;
    struct _TEXTUREDESC*    ptexdNext;
} TEXTUREDESC, *PTEXTUREDESC;

//******************************************************************************
typedef struct _ARGBPIXELDESC {
    DWORD   dwAMask;
    DWORD   dwRMask;
    DWORD   dwGMask;
    DWORD   dwBMask;
    DWORD   dwAShift;
    DWORD   dwRShift;
    DWORD   dwGShift;
    DWORD   dwBShift;
    UINT    uStride;
} ARGBPIXELDESC, *PARGBPIXELDESC;

//******************************************************************************
// Local function prototypes
//******************************************************************************

static PTEXTUREDESC             GetTextureDesc(LPDIRECT3DBASETEXTURE8 pd3dt);
static void                     GetARGBPixelDesc(D3DFORMAT fmt, PARGBPIXELDESC ppixd);

/*
static BOOL                     InitPalette(LPPALETTEENTRY ppe, UINT uNumEntries);

static BOOL                     ReduceResolution(LPDIRECTDRAWSURFACE7 pddsSrc);
*/

//******************************************************************************
// Globals
//******************************************************************************

PTEXTUREDESC                    g_ptexdList = NULL;

//******************************************************************************
// Texture functions
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     CreateTexture
//
// Description:
//
//     Create a IDirectDrawSurface7 texture object.
//
// Arguments:
//
//     DWORD dwWidth                        - Width of the surface
//
//     DWORD dwHeight                       - Height of the surface
//
//     PIXELFORMAT pxf                      - Optional pixel format of the 
//                                            texture to create
//
//     MEMORYPOOL mp                        - Location in which to create the
//                                            texture
//
//     TEXTURETYPE tt                       - Type of texture to create (i.e.
//                                            mipmap, cubemap, bumpmap, etc.)
//
// Return Value:
//
//     A pointer to the created IDirectDrawSurface7 object on 
//     success, NULL on failure.
//
//******************************************************************************
LPDIRECT3DBASETEXTURE8 CreateTexture(UINT uWidth, UINT uHeight, D3DFORMAT fmt, 
                                    TEXTURETYPE tt, D3DPOOL pool)
{
    return CreateTexture(uWidth, uHeight, 0, fmt, tt, pool);
}

//******************************************************************************
LPDIRECT3DBASETEXTURE8 CreateTexture(UINT uWidth, UINT uHeight, UINT uDepth,
                                    D3DFORMAT fmt, TEXTURETYPE tt, D3DPOOL pool)
{
    LPDIRECT3DTEXTURE8  pd3dt;
    D3DFORMAT           fmtt;
    PTEXTUREDESC        ptexdNode;
    DWORD               dwUsage = 0;
    D3DRESOURCETYPE     rt;
    HRESULT             hr;

    // Verify the current device supports the given format
    if (tt & TTYPE_DEPTH) {
        dwUsage |= D3DUSAGE_DEPTHSTENCIL;
    }
    else if (tt & TTYPE_TARGET) {
        dwUsage |= D3DUSAGE_RENDERTARGET;
    }

    if (tt & TTYPE_VOLUME) {
        rt = D3DRTYPE_VOLUMETEXTURE;
    }
    else if (tt & TTYPE_CUBEMAP) {
        rt = D3DRTYPE_CUBETEXTURE;
    }
    else {
        rt = D3DRTYPE_TEXTURE;
    }

    hr = g_pd3d->CheckDeviceFormat(g_disdCurrent.padpd->uAdapter, 
                                    g_disdCurrent.pdevd->d3ddt, 
                                    g_disdCurrent.pdm->d3ddm.Format, 
                                    dwUsage, rt, fmt);
//##HACK to get around checkdeviceformats failing on valid formats
/*
    if (FAILED(hr)) {
        if (hr != D3DERR_NOTAVAILABLE) {
            ResultFailed(hr, TEXT("IDirect3D8::CheckDeviceFormats"));
        }
        return NULL;
    }
*/
    // Create a texture of the specified type
    if (tt & TTYPE_VOLUME) {

        D3DVOLUME_DESC d3dvd;

        hr = g_pd3dDevice->CreateVolumeTexture(uWidth, uHeight, uDepth, 
                                    tt & TTYPE_MIPMAP ? 0 : 1,
                                    dwUsage, fmt, pool, 
                                    (LPDIRECT3DVOLUMETEXTURE8*)&pd3dt);
        if (FAILED(hr)) {
            ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVolumeTexture"));
            return NULL;
        }

#ifndef DEMO_HACK
        ((LPDIRECT3DVOLUMETEXTURE8)pd3dt)->GetLevelDesc(0, &d3dvd);
        fmtt = d3dvd.Format;
#else
        fmtt = D3DFMT_A8R8G8B8;
#endif
    }
    else if (tt & TTYPE_CUBEMAP) {

        D3DSURFACE_DESC d3dsd;

        hr = g_pd3dDevice->CreateCubeTexture(uWidth > uHeight ? uWidth : uHeight,
                                    tt & TTYPE_MIPMAP ? 0 : 1,
                                    dwUsage, fmt, pool, 
                                    (LPDIRECT3DCUBETEXTURE8*)&pd3dt);
        if (FAILED(hr)) {
            ResultFailed(hr, TEXT("IDirect3DDevice8::CreateCubeTexture"));
            return NULL;
        }

#ifndef DEMO_HACK
        ((LPDIRECT3DCUBETEXTURE8)pd3dt)->GetLevelDesc(0, &d3dsd);
        fmtt = d3dsd.Format;
#else
        fmtt = D3DFMT_A8R8G8B8;
#endif
    }
    else {

        D3DSURFACE_DESC d3dsd;

        hr = g_pd3dDevice->CreateTexture(uWidth, uHeight,
                                    tt & TTYPE_MIPMAP ? 0 : 1, 
                                    dwUsage, fmt, pool, 
                                    (LPDIRECT3DTEXTURE8*)&pd3dt);
        if (FAILED(hr)) {
            ResultFailed(hr, TEXT("IDirect3DDevice8::CreateTexture"));
            return NULL;
        }

#ifndef DEMO_HACK
        ((LPDIRECT3DTEXTURE8)pd3dt)->GetLevelDesc(0, &d3dsd);
        fmtt = d3dsd.Format;
#else
        fmtt = D3DFMT_A8R8G8B8;
#endif
    }

    // Add the texture to the texture list
    ptexdNode = (PTEXTUREDESC)MemAlloc(sizeof(TEXTUREDESC));
    if (!ptexdNode) {
        pd3dt->Release();
        return NULL;
    }
    memset(ptexdNode, 0, sizeof(TEXTUREDESC));
    ptexdNode->pd3dt = pd3dt;
    ptexdNode->uWidth = uWidth;
    ptexdNode->uHeight = uHeight;
    ptexdNode->uDepth = uDepth;
    ptexdNode->fmt = fmtt;
    ptexdNode->pool = pool;
    ptexdNode->tt = tt;
    ptexdNode->ptexdNext = g_ptexdList;
    g_ptexdList = ptexdNode;

    return pd3dt;
}

//******************************************************************************
//
// Function:
//
//     CreateTexture
//
// Description:
//
//     Create a texture object and populate it using the image contained in
//     the given resource or file name.
//
// Arguments:
//
//     LPCTSTR szName                       - File or resource name of the 
//                                            bitmap to create the texture from
//
//     PIXELFORMAT pxf                      - Optional pixel format of the 
//                                            texture to create
//
//     MEMORYPOOL mp                        - Location in which to create the
//                                            texture
//
//     TEXTURETYPE tt                       - Type of texture to create (i.e.
//                                            mipmap, cubemap, bumpmap, etc.)
//
//
//     float fAlpha                         - Optional transparency value for
//                                            the texture
//
//     D3DCOLOR cColorKey                   - Optional color key for the
//                                            texture
//
// Return Value:
//
//     A pointer to the created IDirectDrawSurface7 object on 
//     success, NULL on failure.
//
//******************************************************************************
LPDIRECT3DBASETEXTURE8 CreateTexture(LPCTSTR szName, D3DFORMAT fmt, TEXTURETYPE tt,
                                 PALETTEENTRY* pcPalette, float fAlpha,
                                 D3DCOLOR cColorKey, UINT uWidth, UINT uHeight)
{
    LPDIRECT3DBASETEXTURE8  pd3dt = NULL;
    D3DRESOURCETYPE         rt;
    D3DFORMAT               fmtt;
    DWORD                   dwUsage = 0;
    PTEXTUREDESC            ptexdNode;
    LPTSTR                  szImage;
    TCHAR                   szResource[32] = {TEXT("resource ")};
    WORD                    wResourceID;
    HRESULT                 hr;

    if (!szName) {
        // Fail if a NULL name pointer or a resource identifer of zero is given
        return NULL;
    }

    // Verify the current device supports the given format
    // ##REVIEW: Should this be replaced with D3DXCheckMipMapRequirements and
    // D3DXCheckCubeMapRequirements?
    if (tt & TTYPE_DEPTH) {
        dwUsage |= D3DUSAGE_DEPTHSTENCIL;
    }
    else if (tt & TTYPE_TARGET) {
        dwUsage |= D3DUSAGE_RENDERTARGET;
    }

    if (tt & TTYPE_VOLUME) {
        rt = D3DRTYPE_VOLUMETEXTURE;
    }
    else if (tt & TTYPE_CUBEMAP) {
        rt = D3DRTYPE_CUBETEXTURE;
    }
    else {
        rt = D3DRTYPE_TEXTURE;
    }

    hr = g_pd3d->CheckDeviceFormat(g_disdCurrent.padpd->uAdapter, 
                                    g_disdCurrent.pdevd->d3ddt, 
                                    g_disdCurrent.pdm->d3ddm.Format, 
                                    dwUsage, rt, fmt);
//##HACK to get around checkdeviceformats failing on valid formats
/*
    if (FAILED(hr)) {
        if (hr != D3DERR_NOTAVAILABLE) {
            ResultFailed(hr, TEXT("IDirect3D8::CheckDeviceFormats"));
        }
        return NULL;
    }
*/
    // If the high order word of the name is zero, the name is a resource
    // identifier rather than a pointer to the name string
    if (!(BOOL)((DWORD)szName >> 16)) {
        wResourceID = (WORD)szName;
        wsprintf(szResource + 9, TEXT("%d"), wResourceID);
        szImage = szResource;
    }
    else {
        wResourceID = 0;
        szImage = (LPTSTR)szName;
    }

// ##REVIEW: Don't apply a box filter (use point filter instead) for the mipfilter
// if any fAlpha or color key is given because the mipmap will have to be re-filtered
// later on after translucency information is set...the box filter will be applied at
// that time

    if (tt & TTYPE_VOLUME) {

        return NULL;
    }

    else if (tt & TTYPE_CUBEMAP) {

        LPDIRECT3DCUBETEXTURE8  pd3dcube;
        LPDIRECT3DSURFACE8      pd3ds;
        D3DSURFACE_DESC         d3dsd;
        TCHAR                   szFace[6][MAX_PATH];
        TCHAR                   szTemp[MAX_PATH];
        TCHAR*                  sz;
        UINT                    i;

        // Create the cubemap
        hr = D3DXCreateCubeTexture(g_pd3dDevice, uWidth > uHeight ? uWidth : uHeight,
                            tt & TTYPE_MIPMAP ? 0 : 1, 0, fmt, D3DPOOL_DEFAULT,
                            &pd3dcube);
        if (FAILED(hr)) {
            ResultFailed(hr, TEXT("D3DXCreateCubeMap"));
            return NULL;
        }

        pd3dcube->GetLevelDesc(0, &d3dsd);
        fmtt = d3dsd.Format;

        // Initialize the image names for the faces
        _tcscpy(szTemp, szName);
        sz = szTemp + _tcslen(szTemp);
        if (*(sz-1) == TEXT('0')) {
            sz--;
        }
        else if (*(sz-5) == TEXT('0')) {
            sz -= 5;
        }
        if (*sz) {
            for (i = 0, sz--; i < 6; i++) {
// ##REVIEW: Will the following work for UNICODE?:
                *sz = TEXT('0') + i;
                _tcscpy(szFace[i], szTemp);
            }
        }
        else {
            for (i = 0; i < 6; i++) {
                _tcscpy(szFace[i], szName);
            }
        }

        // Copy the image into the faces
        for (i = 0; i < 6; i++) {

            hr = pd3dcube->GetCubeMapSurface((D3DCUBEMAP_FACES)i, 0, &pd3ds);
            if (FAILED(hr)) {
                ResultFailed(hr, TEXT("IDirect3DCubeMap8::GetCubeMapSurface"));
                pd3dcube->Release();
                return NULL;
            }

            CHAR szAnsi[1024];
            WideCharToMultiByte(CP_ACP, 0, szFace[i], -1, szAnsi, 1024, NULL, NULL);

            hr = D3DXLoadSurfaceFromFile(pd3ds, pcPalette, NULL,
                        szAnsi, NULL, D3DX_FILTER_LINEAR, 0, NULL);
            if (FAILED(hr)) {
                ResultFailed(hr, TEXT("D3DXLoadSurfaceFromFile/Resource"));
                pd3ds->Release();
                pd3dcube->Release();
                return NULL;
            }

            pd3ds->Release();
        }

        pd3dt = (LPDIRECT3DCUBETEXTURE8)pd3dcube;
    }

    else if (tt & TTYPE_BUMPMAP) {

        // The given image is a height map.  Use it to generate the bump map
        LPDIRECT3DTEXTURE8  pd3dtHeight;
        D3DSURFACE_DESC     d3dsd;

        // Load the height map
        pd3dtHeight = (LPDIRECT3DTEXTURE8)CreateTexture(szName, D3DFMT_A8R8G8B8, 
                                            TTYPE_TEXTURE, NULL, 1.0f, 
                                            COLORKEY_NONE, uWidth, uHeight);
        if (!pd3dtHeight) {
            return NULL;
        }
        pd3dtHeight->GetLevelDesc(0, &d3dsd);

        // Create the bump map
        pd3dt = CreateTexture(d3dsd.Width, d3dsd.Height, fmt, tt, D3DPOOL_DEFAULT);
        if (!pd3dt) {
            ReleaseTexture(pd3dtHeight);
            return NULL;
        }
        
        hr = CopyTexture(pd3dt, pcPalette, pd3dtHeight, NULL, D3DX_FILTER_LINEAR);

        ReleaseTexture(pd3dtHeight);

        if (FAILED(hr)) {
            ReleaseTexture(pd3dt);
            return NULL;
        }

        ((LPDIRECT3DTEXTURE8)pd3dt)->GetLevelDesc(0, &d3dsd);
        fmtt = d3dsd.Format;

        return pd3dt;
    }

    else {

        D3DSURFACE_DESC d3dsd;

        CHAR szAnsi[1024];
        WideCharToMultiByte(CP_ACP, 0, szName, -1, szAnsi, 1024, NULL, NULL);

        // Attempt to load the image as a file
        hr = D3DXCreateTextureFromFileEx(g_pd3dDevice, 
                            szAnsi, uWidth, uHeight, tt & TTYPE_MIPMAP ? 0 : 1,
                            0, fmt, D3DPOOL_DEFAULT, D3DX_FILTER_LINEAR, D3DX_FILTER_POINT,
                            0, NULL, pcPalette, (LPDIRECT3DTEXTURE8*)&pd3dt);
        if (FAILED(hr)) {
            TCHAR szError[512];
            D3DXGetErrorString(hr, szError, 512);
            DebugString(TEXT("D3DXCreateMipMapFromFile/ResourceEx failed on %s with %s [0x%X]"), szImage, szError, hr);
            return NULL;
        }

        ((LPDIRECT3DTEXTURE8)pd3dt)->GetLevelDesc(0, &d3dsd);
        fmtt = d3dsd.Format;
    }

    // Add the texture to the texture list
    ptexdNode = (PTEXTUREDESC)MemAlloc(sizeof(TEXTUREDESC));
    if (!ptexdNode) {
        pd3dt->Release();
        return NULL;
    }
    memset(ptexdNode, 0, sizeof(TEXTUREDESC));
    ptexdNode->pd3dt = pd3dt;
    if (wResourceID) {
        _tcscpy(ptexdNode->szName, szResource);
        ptexdNode->wResourceID = wResourceID;
    }
    else {
        _tcscpy(ptexdNode->szName, szName);
        ptexdNode->wResourceID = 0;
    }
    ptexdNode->uWidth = uWidth;
    ptexdNode->uHeight = uHeight;
    ptexdNode->uDepth = 0;
    ptexdNode->fmt = fmtt;
    ptexdNode->pool = D3DPOOL_DEFAULT;
    ptexdNode->tt = tt;
    ptexdNode->fAlpha = fAlpha;
    ptexdNode->cColorKey = cColorKey;
    ptexdNode->ptexdNext = g_ptexdList;
    g_ptexdList = ptexdNode;

    // Set the translucency.  This will also perform a filter of the highest
    // resolution level(s) to all lower resolution levels (if present)
    if (!SetTranslucency(pd3dt, pcPalette, fAlpha, cColorKey)) {
        ReleaseTexture(pd3dt);
        return NULL;
    }

    return pd3dt;
}

//******************************************************************************
void ReleaseTexture(LPDIRECT3DBASETEXTURE8 pd3dt) {

    PTEXTUREDESC ptexd, ptexdDel;
#if defined(DEBUG) || defined(_DEBUG)
    TCHAR        szName[MAX_PATH];
    UINT         uRef;
#endif

    if (!pd3dt) {
        return;
    }

    if (g_ptexdList) {

        if (g_ptexdList->pd3dt == pd3dt) {
            ptexd = g_ptexdList->ptexdNext;
#if defined(DEBUG) || defined(_DEBUG)
            _tcscpy(szName, g_ptexdList->szName);
#endif
            MemFree(g_ptexdList);
            g_ptexdList = ptexd;
        }

        else {

            for (ptexd = g_ptexdList; 
                 ptexd->ptexdNext && ptexd->ptexdNext->pd3dt != pd3dt; 
                 ptexd = ptexd->ptexdNext
            );

            if (ptexd->ptexdNext) {
                ptexdDel = ptexd->ptexdNext;
                ptexd->ptexdNext = ptexdDel->ptexdNext;
#if defined(DEBUG) || defined(_DEBUG)
                _tcscpy(szName, ptexdDel->szName);
#endif
                MemFree(ptexdDel);
            }
        }
    }

#if defined(DEBUG) || defined(_DEBUG)
    uRef = pd3dt->Release();
    if (uRef != 0) {
        DebugString(TEXT("WARNING: Texture %s has a ref count of %d on release"), szName, uRef);
    }
#else
    pd3dt->Release();
#endif
}

//******************************************************************************
//
// Function:
//
//     ReleaseTextures
//
// Description:
//
//     Release all textures.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void ReleaseTextures() {

    while (g_ptexdList) {
        ReleaseTexture(g_ptexdList->pd3dt);
    }
}

//******************************************************************************
void GetARGBPixelDesc(D3DFORMAT fmt, PARGBPIXELDESC ppixd) {

    if (!ppixd) {
        return;
    }

    memset(ppixd, 0, sizeof(ARGBPIXELDESC));

    switch (fmt) {

        case D3DFMT_P8:
        case D3DFMT_A8R8G8B8:
            ppixd->dwAMask     = 0xFF000000;
            ppixd->dwAShift    = 24;

        case D3DFMT_X8R8G8B8:
            ppixd->dwRMask     = 0x00FF0000;
            ppixd->dwGMask     = 0x0000FF00;
            ppixd->dwBMask     = 0x000000FF;
            ppixd->dwRShift    = 16;
            ppixd->dwGShift    = 8;
            ppixd->dwBShift    = 0;
            ppixd->uStride     = 4;
            break;

        case D3DFMT_R8G8B8:
            ppixd->dwRMask     = 0xFF0000;
            ppixd->dwGMask     = 0x00FF00;
            ppixd->dwBMask     = 0x0000FF;
            ppixd->dwRShift    = 16;
            ppixd->dwGShift    = 8;
            ppixd->dwBShift    = 0;
            ppixd->uStride     = 3;
            break;

        case D3DFMT_A1R5G5B5:
            ppixd->dwAMask     = 0x8000;
            ppixd->dwAShift    = 15;

        case D3DFMT_X1R5G5B5:
            ppixd->dwRMask     = 0x7C00;
            ppixd->dwGMask     = 0x03E0;
            ppixd->dwBMask     = 0x001F;
            ppixd->dwRShift    = 10;
            ppixd->dwGShift    = 5;
            ppixd->dwBShift    = 0;
            ppixd->uStride     = 2;
            break;

        case D3DFMT_R5G6B5:
            ppixd->dwRMask     = 0xF800;
            ppixd->dwGMask     = 0x07E0;
            ppixd->dwBMask     = 0x001F;
            ppixd->dwRShift    = 11;
            ppixd->dwGShift    = 5;
            ppixd->dwBShift    = 0;
            ppixd->uStride     = 2;
            break;

        case D3DFMT_A4R4G4B4:
            ppixd->dwAMask     = 0xF000;
            ppixd->dwAShift    = 12;

        case D3DFMT_X4R4G4B4:
            ppixd->dwRMask     = 0x0F00;
            ppixd->dwGMask     = 0x00F0;
            ppixd->dwBMask     = 0x000F;
            ppixd->dwRShift    = 8;
            ppixd->dwGShift    = 4;
            ppixd->dwBShift    = 0;
            ppixd->uStride     = 2;
            break;
    }
}

//******************************************************************************
static PTEXTUREDESC GetTextureDesc(LPDIRECT3DBASETEXTURE8 pd3dt) {

    PTEXTUREDESC ptexd;

    for (ptexd = g_ptexdList; 
         ptexd && ptexd->pd3dt != pd3dt; 
         ptexd = ptexd->ptexdNext
    );

    return ptexd;
}

/*
//******************************************************************************
BOOL PopulateTexture(LPDIRECTDRAWSURFACE7 pdds, LPCTSTR szName, float fAlpha, 
                     D3DCOLOR cColorKey)
{
    DDSURFACEDESC2  ddsd;
    LPTSTR          szImage;
    TCHAR           szResource[32] = {TEXT("resource ")};
    WORD            wResourceID;
    HBITMAP         hBitmap = NULL;
    BITMAP          bitmap;
    HDC             hdcSrc = NULL,
                    hdcDst = NULL;
    DWORD           dwPitch;
    UINT            i, j;
    HRESULT         hr;

    if (!szName) {
        // Fail if a NULL name pointer or a resource identifer of zero is given
        return NULL;
    }

    // Get the surface description
    memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
    ddsd.dwSize = sizeof(DDSURFACEDESC2);
    hr = pdds->GetSurfaceDesc(&ddsd);
    if (ResultFailed(hr, TEXT("IDirectDrawSurface7::GetSurfaceDesc"))) {
        return FALSE;
    }

    // If the high order word of the name is zero, the name is a resource
    // identifier rather than a pointer to the name string
    if (!(BOOL)((DWORD)szName >> 16)) {
        wResourceID = (WORD)szName;
        wsprintf(szResource + 9, TEXT("%d"), wResourceID);
        szImage = szResource;
    }
    else {
        wResourceID = 0;
        szImage = (LPTSTR)szName;
    }

    // Attempt to load the bitmap as a resource
    hBitmap = LoadBitmap(g_hInstance, szName);
    if (!hBitmap && !wResourceID) {
        // Attempt to load the bitmap as a file
        hBitmap = (HBITMAP)LoadImage(g_hInstance, szName, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
    }
    if (!hBitmap) {
        DebugString(TEXT("LoadBitmap/LoadImage failed on %s"), szImage);
        return NULL;
    }

    // Get the bitmap information
    if (!GetObject(hBitmap, sizeof(BITMAP), &bitmap)) {
        DebugString(TEXT("GetObject failed on %s"), szImage);
        DeleteObject(hBitmap);
        return FALSE;
    }

    // If the texture is palettized, initialize the palette
    if (ddsd.ddpfPixelFormat.dwRGBBitCount < 16) {

        LPDIRECTDRAWPALETTE pddp;
        RGBQUAD             prgbq[256];
        UINT                uNumEntries;
        PALETTEENTRY        ppe[256];

        hr = pdds->GetPalette(&pddp);
        if (ResultFailed(hr, TEXT("IDirectDrawSurface7::GetPalette"))) {
            DeleteObject(hBitmap);
            return FALSE;
        }

        // Get the color table from the bitmap
        hdcSrc = CreateCompatibleDC(NULL);
        if (!hdcSrc) {
            DebugString(TEXT("CreateCompatibleDC failed for %s"), szImage);
            pddp->Release();
            DeleteObject(hBitmap);
            return FALSE;
        }

        SelectObject(hdcSrc, hBitmap);

        uNumEntries = GetDIBColorTable(hdcSrc, 0, 
                                        (0x1 << bitmap.bmBitsPixel), prgbq);

        DeleteDC(hdcSrc);

        memset(&ppe, 0, sizeof(PALETTEENTRY) * 256);

        if (uNumEntries) {

            // Convert the RGBQUAD entries to PALETTEENTRY structures
            for (i = 0; i < uNumEntries; i++) {
                ppe[i].peRed = prgbq[i].rgbRed;
                ppe[i].peGreen = prgbq[i].rgbGreen;
                ppe[i].peBlue = prgbq[i].rgbBlue;
            }
        }
        else {

            // Use the existing entries
            hr = pddp->GetEntries(0, 0, (UINT)(0x1 << ddsd.ddpfPixelFormat.dwRGBBitCount), ppe);
            if (ResultFailed(hr, TEXT("IDirectDrawPalette::GetEntries"))) {
                if (!InitPalette(ppe, (0x1 << ddsd.ddpfPixelFormat.dwRGBBitCount))) {
                    pddp->Release();
                    DeleteObject(hBitmap);
                    return FALSE;
                }
            }
        }

        // Initialize alpha in the palette
        if (fAlpha != 1.0f && (g_pdevdCurrent->d3ddDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_ALPHAPALETTE)) {
            for (i = 0; i < (UINT)(0x1 << ddsd.ddpfPixelFormat.dwRGBBitCount); i++) {
                ppe[i].peFlags = (BYTE)(fAlpha * 255.0f);
            }
        }

        // Set the new palette entries
        hr = pddp->SetEntries(0, 0, (UINT)(0x1 << ddsd.ddpfPixelFormat.dwRGBBitCount), ppe);

        // Release a reference on the palette
        pddp->Release();

        if (ResultFailed(hr, TEXT("IDirectDrawPalette::SetEntries"))) {
            DeleteObject(hBitmap);
            return FALSE;
        }
    }

    // Create an offscreen DC for the bitmap
    hdcSrc = CreateCompatibleDC(NULL);
    if (!hdcSrc) {
        DebugString(TEXT("CreateCompatibleDC failed for %s"), szImage);
        DeleteObject(hBitmap);
        return FALSE;
    }

    SelectObject(hdcSrc, hBitmap);

    // Get a DC on the texture surface
    hr = pdds->GetDC(&hdcDst);
    if (ResultFailed(hr, TEXT("IDirectDrawSurface7::GetDC"))) {
        DeleteDC(hdcSrc);
        DeleteObject(hBitmap);
        return FALSE;
    }

    // Copy the bitmap into the texture
    if (!BitBlt(hdcDst, 0, 0, bitmap.bmWidth, bitmap.bmHeight, hdcSrc, 0, 
                0, SRCCOPY)) 
    {
        DebugString(TEXT("BitBlt failed for %s"), szImage);
        DeleteDC(hdcSrc);
        DeleteObject(hBitmap);
        return FALSE;
    }

    // Release the DCs and bitmap
    pdds->ReleaseDC(hdcDst);
    DeleteDC(hdcSrc);
    DeleteObject(hBitmap);

    // Set the translucency information if the surface has alpha bits
    if (ddsd.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) {

        // Lock the surface
        memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
        ddsd.dwSize = sizeof(DDSURFACEDESC2);
        hr = pdds->Lock(NULL, &ddsd, DDLOCK_SURFACEMEMORYPTR |
                                    DDLOCK_WAIT, NULL);
        if (ResultFailed(hr, TEXT("IDirectDrawSurface7::Lock"))) {
            return FALSE;
        }

        switch (ddsd.ddpfPixelFormat.dwRGBBitCount) {

            case 16: {

                LPWORD pwPixel = (LPWORD)ddsd.lpSurface;
                dwPitch = ddsd.lPitch / (sizeof(WORD) / sizeof(BYTE));

                // Set all alpha bits of the texture to 1
                for (i = 0; i < ddsd.dwHeight; i++) {

                    for (j = 0; j < ddsd.dwWidth; j++) {

                        *(pwPixel + j) |= ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;
                    }

                    pwPixel += dwPitch;
                }
                
                break;
            }

            case 32: {

                LPDWORD pdwPixel = (LPDWORD)ddsd.lpSurface;
                dwPitch = ddsd.lPitch / (sizeof(DWORD) / sizeof(BYTE));

                // Set all alpha bits of the texture to 1
                for (i = 0; i < ddsd.dwHeight; i++) {

                    for (j = 0; j < ddsd.dwWidth; j++) {

                        *(pdwPixel + j) |= ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;
                    }

                    pdwPixel += dwPitch;
                }

                break;
            }
        }

        // Unlock the surface and release it
        hr = pdds->Unlock(NULL);
        if (ResultFailed(hr, TEXT("IDirectDrawSurface7::Unlock"))) {
            return FALSE;
        }

        // Set the translucency
        SetTranslucency(pdds, fAlpha);
    }

    // Add colorkey information if necessary
    if (RGBA_GETALPHA(cColorKey) != 0xFF) {
        SetColorKey(pdds, cColorKey);
    }

    // Reduce the resolution for the lower levels of the mipmap
    // using the bitmap information from the highest level
    if (ddsd.ddsCaps.dwCaps & DDSCAPS_MIPMAP) {
        if (!ReduceResolution(pdds)) {
            return FALSE;
        }
    }

    return TRUE;
}
*/

//******************************************************************************
BOOL SetTranslucency(LPDIRECT3DSURFACE8 pd3ds, PALETTEENTRY* pcPalette, 
                        float fAlpha, D3DCOLOR cColorKey) 
{
    D3DSURFACE_DESC     d3dsd;
    D3DLOCKED_RECT      d3dlr;
    ARGBPIXELDESC       pixd;
    DWORD               dwPitch;
    DWORD               dwColorKey;
    UINT                i, j;
    HRESULT             hr;

    if (!(cColorKey == COLORKEY_NONE || cColorKey == COLORKEY_PIXEL1)) {
        // Get the surface-specific colorkey value (the representation of
        // the pixel in surface memory) from the red, green, and blue
        // components of the given D3DCOLOR
        dwColorKey = ColorToPixel(pd3ds, pcPalette, cColorKey & 0xFFFFFF);
    }

    // Get the format of the mipmap
    pd3ds->GetDesc(&d3dsd);

    // Lock the texture
    hr = pd3ds->LockRect(&d3dlr, NULL, 0);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DSurface8::LockRect"));
        return FALSE;
    }

    // If the texture is palettized, set the translucency in the palette entries
    if (d3dsd.Format == D3DFMT_P8) {

        UINT i;

        if (!pcPalette || !(g_disdCurrent.pdevd->d3dcaps.TextureCaps & D3DPTEXTURECAPS_ALPHAPALETTE)) {
            return FALSE;
        }

        for (i = 0; i < 256; i++) {
            pcPalette[i].peFlags = (BYTE)(fAlpha * 255.0f);
        }

        if (cColorKey == COLORKEY_PIXEL1) {
            dwColorKey = *(LPBYTE)d3dlr.pBits;
        }
        if (cColorKey != COLORKEY_NONE) {
            pcPalette[dwColorKey].peFlags = 0;
        }

        return TRUE;
    }

    // Get the pixel format of the texture
    GetARGBPixelDesc(d3dsd.Format, &pixd);

    if (cColorKey == COLORKEY_NONE) {
        dwColorKey = COLORKEY_NONE;
    }

    // Set the translucency
    switch (d3dsd.Format) {

        case D3DFMT_A8R8G8B8:

            LPDWORD pdwPixel;
            DWORD   dwAlpha;

            dwAlpha = (DWORD)((float)pixd.dwAMask * fAlpha) & pixd.dwAMask;
            pdwPixel = (LPDWORD)d3dlr.pBits;

            dwPitch = d3dlr.Pitch / pixd.uStride;

            if (cColorKey == COLORKEY_PIXEL1) {
                dwColorKey = *pdwPixel;
            }

            for (i = 0; i < d3dsd.Height; i++) {

                for (j = 0; j < d3dsd.Width; j++) {

                    if ((*(pdwPixel + j) & ~pixd.dwAMask) == dwColorKey) {
                        *(pdwPixel + j) &= ~pixd.dwAMask;
                    }
                    else {
                        *(pdwPixel + j) = dwAlpha | (~pixd.dwAMask & *(pdwPixel + j));
                    }
                }

                pdwPixel += dwPitch;
            }

            break;

        case D3DFMT_A1R5G5B5:
        case D3DFMT_A4R4G4B4: {

            LPWORD pwPixel;
            WORD   wAlpha;

            wAlpha = (WORD) ((UINT)((float)pixd.dwAMask * fAlpha) & pixd.dwAMask);
            pwPixel = (LPWORD)d3dlr.pBits;

            dwPitch = d3dlr.Pitch / pixd.uStride;

            if (cColorKey == COLORKEY_PIXEL1) {
                dwColorKey = *pwPixel;
            }

            for (i = 0; i < d3dsd.Height; i++) {

                for (j = 0; j < d3dsd.Width; j++) {

                    if ((*(pwPixel + j) & ~pixd.dwAMask) == dwColorKey) {
                        *(pwPixel + j) &= ~pixd.dwAMask;
                    }
                    else {
                        *(pwPixel + j) = wAlpha | (~(WORD)pixd.dwAMask & *(pwPixel + j));
                    }
                }

                pwPixel += dwPitch;
            }

            break;
        }
    }

    // Unlock the surface
    hr = pd3ds->UnlockRect();
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DSurface8::UnlockRect"));
        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     SetTranslucency
//
// Description:
//
//     Set the alpha channel information on a texture.
//
// Arguments:
//
//     LPDIRECTDRAWSURFACE7 pd3dt           - Texture to make translucent
//
//     float fAlpha                         - Translucency value ranging from
//                                            0.0 to 1.0, where 0.0 is 
//                                            transparent and 1.0 is opaque
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL SetTranslucency(LPDIRECT3DBASETEXTURE8 pd3dt, PALETTEENTRY* pcPalette, 
                        float fAlpha, D3DCOLOR cColorKey) 
{
    PTEXTUREDESC    ptexd;
    HRESULT         hr;

    // Parameter validation
    if (!pd3dt) {
        return FALSE;
    }

    // Fail if the current device does not support translucency
    if (!(g_disdCurrent.pdevd->d3dcaps.TextureCaps & D3DPTEXTURECAPS_ALPHA)) {
        return FALSE;
    }

    // ##TODO: Get the resource type of the surface and then set the translucency accordingly
    // for now assume mipmap

    ptexd = GetTextureDesc(pd3dt);
    if (!ptexd) {
        return FALSE;
    }

    if (ptexd->tt & TTYPE_VOLUME) {

    }
    else if (ptexd->tt & TTYPE_CUBEMAP) {

        LPDIRECT3DSURFACE8      pd3ds;
        LPDIRECT3DCUBETEXTURE8  pd3dcube = (LPDIRECT3DCUBETEXTURE8)pd3dt;
        UINT                    i;

        for (i = 0; i < 6; i++) {

            hr = pd3dcube->GetCubeMapSurface((D3DCUBEMAP_FACES)i, 0, &pd3ds);
            if (FAILED(hr)) {
                ResultFailed(hr, TEXT("IDirect3DCubeMap8::GetCubeMapSurface"));
                return FALSE;
            }

            if (!SetTranslucency(pd3ds, pcPalette, fAlpha, cColorKey)) {
                pd3ds->Release();
                return FALSE;
            }

            pd3ds->Release();
        }

        if (ptexd->tt & TTYPE_MIPMAP) {

            hr = D3DXFilterCubeTexture(pd3dcube, pcPalette, D3DX_DEFAULT, D3DX_FILTER_BOX);
            if (FAILED(hr)) {
                ResultFailed(hr, TEXT("D3DXFilterCubeMap"));
                return FALSE;
            }
        }
    }
    else {

        LPDIRECT3DSURFACE8 pd3ds;
        LPDIRECT3DTEXTURE8 pd3dmip = (LPDIRECT3DTEXTURE8)pd3dt;

        hr = pd3dmip->GetSurfaceLevel(0, &pd3ds);
        if (FAILED(hr)) {
            ResultFailed(hr, TEXT("IDirect3DMipMap8::GetSurfaceLevel"));
            return FALSE;
        }

        if (!SetTranslucency(pd3ds, pcPalette, fAlpha, cColorKey)) {
            pd3ds->Release();
            return FALSE;
        }

        pd3ds->Release();

        if (ptexd->tt & TTYPE_MIPMAP) {

            hr = D3DXFilterTexture(pd3dmip, pcPalette, D3DX_DEFAULT, D3DX_FILTER_BOX);
            if (FAILED(hr)) {
                ResultFailed(hr, TEXT("D3DXFilterMipMap"));
                return FALSE;
            }
        }
    }

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     ColorToPixel
//
// Description:
//
//     Calculate the surface-specific colorkey value (the representation of
//     the pixel in surface memory) from the red, green, and blue
//     components of the given D3DCOLOR.
//
// Arguments:
//
//     LPDIRECTDRAWSURFACE7 pdds       - Surface on which to calculate the 
//                                       pixel value
//
//     D3DCOLOR c                      - Color of the pixel
//
// Return Value:
//
//     The pixel representation in surface memory of the given color value on
//     success, zero on failure.
//
//******************************************************************************
DWORD ColorToPixel(LPDIRECT3DSURFACE8 pd3ds, PALETTEENTRY* pcPalette, D3DCOLOR c) {

    D3DSURFACE_DESC     d3dsd;
    DWORD               dwPixel;
    BYTE                r, g, b, a;

    // Parameter validation
    if (!pd3ds) {
        return 0;
    }

    r = (BYTE)RGBA_GETRED(c);
    g = (BYTE)RGBA_GETGREEN(c);
    b = (BYTE)RGBA_GETBLUE(c);
    a = (BYTE)RGBA_GETALPHA(c);

    // Get the format of the mipmap
    pd3ds->GetDesc(&d3dsd);

    // If the surface is palettized, select the nearest palette entry
    // to the given color
    if (d3dsd.Format == D3DFMT_P8) {

        UINT                i;
        int                 dr, dg, db, d, dLast;

        if (!pcPalette) {
            return 0;
        }

        dLast = INT_MAX;

        // Find the entry in the palette that most closely matches the
        // given pixel color
        for (i = 0; i < 256; i++) {

            dr = (int)pcPalette[i].peRed - r;
            dg = (int)pcPalette[i].peGreen - g;
            db = (int)pcPalette[i].peBlue - b;

            d = dr * dr + dg * dg + db * db;

            if (d < dLast) {
                dwPixel = i;
                dLast = d;
                if (d == 0) {
                    break;
                }
            }
        }

//        DebugString(TEXT("Color key set to index %d - r: %d, g: %d, b: %d"), 
//                match, ppe[match].peRed, ppe[match].peGreen, ppe[match].peBlue);
    }

    else {

        ARGBPIXELDESC       pixd;

        // Get the pixel format of the texture
        GetARGBPixelDesc(d3dsd.Format, &pixd);

        dwPixel = ((BYTE)((float)(pixd.dwAMask >> pixd.dwAShift) * ((float)a / 255.0f) + 0.5f) << pixd.dwAShift) |
                  ((BYTE)((float)(pixd.dwRMask >> pixd.dwRShift) * ((float)r / 255.0f) + 0.5f) << pixd.dwRShift) |
                  ((BYTE)((float)(pixd.dwGMask >> pixd.dwGShift) * ((float)g / 255.0f) + 0.5f) << pixd.dwGShift) |
                  ((BYTE)((float)(pixd.dwBMask >> pixd.dwBShift) * ((float)b / 255.0f) + 0.5f) << pixd.dwBShift);
    }

    return dwPixel;
}

//******************************************************************************
HRESULT CopyTexture(LPDIRECT3DBASETEXTURE8 pd3dtDst, PALETTEENTRY* pcPalDst, 
                    LPDIRECT3DBASETEXTURE8 pd3dtSrc, PALETTEENTRY* pcPalSrc, 
                    DWORD dwFilter) 
{
    PTEXTUREDESC        ptexdDst, ptexdSrc;
    LPDIRECT3DSURFACE8  pd3dsDst, pd3dsSrc;
    UINT                uLevelsDst, uLevelsSrc, i, j, k;
    HRESULT             hr;

    ptexdDst = GetTextureDesc(pd3dtDst);
    ptexdSrc = GetTextureDesc(pd3dtSrc);

    if (!ptexdDst || !ptexdSrc) {
        return E_INVALIDARG;
    }

    if ((((ptexdDst->tt & TTYPE_RMASK) == TTYPE_TEXTURE) &&
         ((ptexdSrc->tt & TTYPE_RMASK) == TTYPE_TEXTURE)) ||
        (((ptexdDst->tt & TTYPE_RMASK) == TTYPE_BUMPMAP) &&
         ((ptexdSrc->tt & TTYPE_RMASK) == TTYPE_BUMPMAP)))
    {
        uLevelsDst = pd3dtDst->GetLevelCount();
        uLevelsSrc = pd3dtSrc->GetLevelCount();

        for (i = 0, j = 0; i < uLevelsDst; i++) {

            j = (uLevelsDst - i >= uLevelsSrc) ? 0 : j + 1;
            hr = ((LPDIRECT3DTEXTURE8)pd3dtDst)->GetSurfaceLevel(i, &pd3dsDst);
            if (ResultFailed(hr, TEXT("IDirect3DTexture8::GetSurfaceLevel"))) {
                return hr;
            }
            hr = ((LPDIRECT3DTEXTURE8)pd3dtSrc)->GetSurfaceLevel(j, &pd3dsSrc);
            if (ResultFailed(hr, TEXT("IDirect3DTexture8::GetSurfaceLevel"))) {
                pd3dsDst->Release();
                return hr;
            }
            hr = D3DXLoadSurfaceFromSurface(pd3dsDst, pcPalDst, NULL,
                                            pd3dsSrc, pcPalSrc, NULL,
                                            dwFilter, 0);

            pd3dsSrc->Release();
            pd3dsDst->Release();

            if (ResultFailed(hr, TEXT("D3DXLoadSurfaceFromSurface"))) {
                return hr;
            }
        }

        return hr;
    }

    if ((((ptexdDst->tt & TTYPE_RMASK) == TTYPE_CUBEMAP) &&
         ((ptexdSrc->tt & TTYPE_RMASK) == TTYPE_TEXTURE)) ||
        (((ptexdDst->tt & TTYPE_RMASK) == TTYPE_CUBEMAP) &&
         ((ptexdSrc->tt & TTYPE_RMASK) == TTYPE_CUBEMAP)))
    {
        uLevelsDst = pd3dtDst->GetLevelCount();
        uLevelsSrc = pd3dtSrc->GetLevelCount();

        for (k = 0; k < 6; k++) {

            for (i = 0, j = 0; i < uLevelsDst; i++) {

                j = (uLevelsDst - i >= uLevelsSrc) ? 0 : j + 1;
                hr = ((LPDIRECT3DCUBETEXTURE8)pd3dtDst)->GetCubeMapSurface((D3DCUBEMAP_FACES)k, i, &pd3dsDst);
                if (ResultFailed(hr, TEXT("IDirect3DCubeMap8::GetSurfaceLevel"))) {
                    return hr;
                }
                if (ptexdSrc->tt & TTYPE_CUBEMAP) {
                    hr = ((LPDIRECT3DCUBETEXTURE8)pd3dtSrc)->GetCubeMapSurface((D3DCUBEMAP_FACES)k, j, &pd3dsSrc);
                }
                else {
                    hr = ((LPDIRECT3DTEXTURE8)pd3dtSrc)->GetSurfaceLevel(j, &pd3dsSrc);
                }
                if (ResultFailed(hr, TEXT("IDirect3DTexture8::GetSurfaceLevel"))) {
                    pd3dsDst->Release();
                    return hr;
                }
                hr = D3DXLoadSurfaceFromSurface(pd3dsDst, pcPalDst, NULL,
                                                pd3dsSrc, pcPalSrc, NULL,
                                                dwFilter, 0);

                pd3dsSrc->Release();
                pd3dsDst->Release();

                if (ResultFailed(hr, TEXT("D3DXLoadSurfaceFromSurface"))) {
                    return hr;
                }
            }
        }

        return hr;
    }

    if (((ptexdDst->tt & TTYPE_RMASK) == TTYPE_BUMPMAP) &&
        ((ptexdSrc->tt & TTYPE_RMASK) == TTYPE_TEXTURE))
    {
        LPDIRECT3DSURFACE8  pd3dsH, pd3dsB, pd3ds;
        D3DSURFACE_DESC     d3dsd;
        D3DLOCKED_RECT      d3dlr;
        LPDWORD             pdwPixel;
        LPWORD              pwBump;
        float               fOrder;
        float               *pfHeightMap, *pfHeight;
        D3DXVECTOR3         v1, v2, n;
        UINT                x, y;

        uLevelsDst = pd3dtDst->GetLevelCount();
        uLevelsSrc = pd3dtSrc->GetLevelCount();

        for (i = 0, j = 0; i < uLevelsDst; i++) {

            j = (uLevelsDst - i >= uLevelsSrc) ? 0 : j + 1;

            ((LPDIRECT3DTEXTURE8)pd3dtSrc)->GetLevelDesc(j, &d3dsd);

            // Create a 32 bit height map
            if (ptexdSrc->fmt == D3DFMT_X8R8G8B8 ||
                ptexdSrc->fmt == D3DFMT_A8R8G8B8)
            {
                hr = ((LPDIRECT3DTEXTURE8)pd3dtSrc)->GetSurfaceLevel(j, &pd3dsH);
                if (ResultFailed(hr, TEXT("IDirect3DTexture8::GetSurfaceLevel"))) {
                    return hr;
                }
            }
            else {

                hr = g_pd3dDevice->CreateImageSurface(d3dsd.Width, d3dsd.Height, D3DFMT_A8R8G8B8, &pd3dsH);
                if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateImageSurface"))) {
                    return hr;
                }
            
                hr = ((LPDIRECT3DTEXTURE8)pd3dtSrc)->GetSurfaceLevel(j, &pd3ds);
                if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetSurfaceLevel"))) {
                    pd3dsH->Release();
                    return hr;
                }

                hr = D3DXLoadSurfaceFromSurface(pd3dsH, NULL, NULL, pd3ds, pcPalSrc, NULL, dwFilter, 0);
                pd3ds->Release();
                if (ResultFailed(hr, TEXT("D3DXLoadSurfaceFromSurface"))) {
                    pd3dsH->Release();
                    return hr;
                }
            }

            // Create a 16 bit bump map
            hr = g_pd3dDevice->CreateImageSurface(d3dsd.Width, d3dsd.Height, D3DFMT_V8U8, &pd3dsB);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateImageSurface"))) {
                pd3dsH->Release();
                return hr;
            }

            // Convert the pixel intensities in the source image into height values
            // ranging from 0.0 to 1.0
            pfHeightMap = (float*)MemAlloc(d3dsd.Width * d3dsd.Height * sizeof(float));
            if (!pfHeightMap) {
                DebugString(TEXT("Memory allocation failed for height map"));
                pd3dsB->Release();
                pd3dsH->Release();
                return E_OUTOFMEMORY;
            }

            hr = pd3dsH->LockRect(&d3dlr, NULL, 0);
            if (FAILED(hr)) {
                ResultFailed(hr, TEXT("IDirect3DSurface8::LockRect"));
                MemFree(pfHeightMap);
                pd3dsB->Release();
                pd3dsH->Release();
                return hr;
            }

            pdwPixel = (LPDWORD)d3dlr.pBits;

            for (y = 0; y < d3dsd.Height; y++) {

                for (x = 0; x < d3dsd.Width; x++) {

                    pfHeightMap[y * d3dsd.Width + x] = 
                           (float)(((pdwPixel[x] >> 16) & 0xFF) +
                                   ((pdwPixel[x] >> 8)  & 0xFF) +
                                   ((pdwPixel[x])       & 0xFF)) / 3.0f / 255.0f;
                }

                pdwPixel += d3dlr.Pitch / 4;
            }

            pd3dsH->UnlockRect();
            pd3dsH->Release();
       
            // Calculate bump map offsets from the height map information
            hr = pd3dsB->LockRect(&d3dlr, NULL, 0);
            if (FAILED(hr)) {
                ResultFailed(hr, TEXT("IDirect3DSurface8::LockRect"));
                MemFree(pfHeightMap);
                pd3dsB->Release();
                return hr;
            }

            pwBump = (LPWORD)d3dlr.pBits;
            v1 = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
            v2 = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

            for (y = 0; y < d3dsd.Height; y++) {

                for (x = 0; x < d3dsd.Width; x++) {

                    pfHeight = &pfHeightMap[y * d3dsd.Width + x];
                    fOrder = 1.0f;
                    if (y == d3dsd.Height - 1) {
                        v2.y = *(pfHeight - d3dsd.Width) - *pfHeight;
                        fOrder *= -1.0f;
                    }
                    else {
                        v2.y = pfHeight[d3dsd.Width] - pfHeight[0];
                    }
                    if (x == d3dsd.Width - 1) {
                        v1.y = *(pfHeight - 1) - *pfHeight;
                        fOrder *= -1.0f;
                    }
                    else {
                        v1.y = pfHeight[1] - pfHeight[0];
                    }
                    v1.x = (float)sqrt(1.0f - v1.y * v1.y);
                    v2.z = -(float)sqrt(1.0f - v2.y * v2.y);
                    if (fOrder > 0.0f) {
                        D3DXVec3Cross(&n, &v1, &v2);
                    }
                    else {
                        D3DXVec3Cross(&n, &v2, &v1);
                    }
                    D3DXVec3Normalize(&n, &n);
                    pwBump[x] = (int)(-n.z * 64.0f) << 8 |
                                (int)(n.x * 64.0f);
                }

                pwBump += d3dlr.Pitch / 2;
            }

            MemFree(pfHeightMap);

            hr = pd3dsB->UnlockRect();
            if (FAILED(hr)) {
                ResultFailed(hr, TEXT("IDirect3DSurface8::UnlockRect"));
                pd3dsB->Release();
                return hr;
            }

            // Copy the bump map to the destination bump map
            hr = ((LPDIRECT3DTEXTURE8)pd3dtDst)->GetSurfaceLevel(i, &pd3ds);
            if (ResultFailed(hr, TEXT("IDirect3DTexture8::GetSurfaceLevel"))) {
                pd3dsB->Release();
                return hr;
            }

            hr = D3DXLoadSurfaceFromSurface(pd3ds, pcPalDst, NULL, pd3dsB, NULL, NULL, dwFilter, 0);

            pd3ds->Release();
            pd3dsB->Release();

            if (ResultFailed(hr, TEXT("D3DXLoadSurfaceFromSurface"))) {
                return hr;
            }
        }

        return hr;
    }

    if (((ptexdDst->tt & TTYPE_RMASK) == TTYPE_VOLUME) &&
        ((ptexdSrc->tt & TTYPE_RMASK) == TTYPE_VOLUME))
    {

    }

    return E_NOTIMPL;
}

//******************************************************************************
LPDIRECT3DTEXTURE8 CreateDiffuseMap(UINT uWidth, UINT uHeight, D3DCOLOR c,
                                    D3DFORMAT fmt, BOOL bMipmap, 
                                    PALETTEENTRY* pcPalette, D3DPOOL pool)
{
    LPDIRECT3DTEXTURE8  pd3dt;
    D3DSURFACE_DESC     d3dsd;
    D3DLOCKED_RECT      d3dlr;
    D3DFORMAT           fmtt;
    DWORD               dwDepth;
    ARGBPIXELDESC       pixd;
    D3DXVECTOR3         vNormal, vLight;
    float               fIntensity, fx, fy, fSin, fMag, fMP, fRed, fGreen, fBlue, fU, fV;
    UINT                uLevels;
    UINT                i, j, k;
    HRESULT             hr;

    pd3dt = (LPDIRECT3DTEXTURE8)CreateTexture(uWidth, uHeight, fmt, bMipmap ? TTYPE_MIPMAP : TTYPE_TEXTURE, pool);
    if (!pd3dt) {
        return NULL;
    }

    ((LPDIRECT3DTEXTURE8)pd3dt)->GetLevelDesc(0, &d3dsd);
    fmtt = d3dsd.Format;

    dwDepth = FormatToBitDepth(fmtt);
    if (!(dwDepth == 16 || dwDepth == 32)) {

        LPDIRECT3DTEXTURE8  pd3dtMap;
        D3DFORMAT           fmtMap[] = {
                                D3DFMT_X8R8G8B8,
                                D3DFMT_A8R8G8B8,
                                D3DFMT_R5G6B5,
                                D3DFMT_A1R5G5B5,
                                D3DFMT_X1R5G5B5,
                                D3DFMT_A4R4G4B4
                            };

        for (i = 0; i < 6; i++) {
            pd3dtMap = (LPDIRECT3DTEXTURE8)CreateDiffuseMap(uWidth, uHeight, 
                        c, fmtMap[i], bMipmap, NULL, D3DPOOL_SYSTEMMEM);
            if (pd3dtMap) {
                hr = CopyTexture(pd3dt, pcPalette, pd3dtMap, NULL, 
                                    D3DX_FILTER_LINEAR);
                ReleaseTexture(pd3dtMap);
                if (!ResultFailed(hr, TEXT("D3DXLoadSurfaceFromSurface"))) {
                    return pd3dt;
                }
            }
        }

        ReleaseTexture(pd3dt);
        return NULL;
    }

    vLight = D3DXVECTOR3(0.0f, 1.0f, 0.0f);
    fRed = (float)RGBA_GETRED(c);
    fGreen = (float)RGBA_GETGREEN(c);
    fBlue = (float)RGBA_GETBLUE(c);

    uLevels = pd3dt->GetLevelCount();

    for (i = 0; i < uLevels; i++) {

        pd3dt->GetLevelDesc(i, &d3dsd);

        // Get the pixel format of the texture
        GetARGBPixelDesc(d3dsd.Format, &pixd);

        hr = pd3dt->LockRect(i, &d3dlr, NULL, 0);
        if (FAILED(hr)) {
            ResultFailed(hr, TEXT("IDirect3DTexture8::LockRect"));
            ReleaseTexture(pd3dt);
            return NULL;
        }

        switch (d3dsd.Format) {

            case D3DFMT_X8R8G8B8:
            case D3DFMT_A8R8G8B8: {

                LPDWORD pdwPixel = (LPDWORD)d3dlr.pBits;

                for (j = 0, fV = 0.0f; j < d3dsd.Height; j++, fV += (1.0f / (float)(d3dsd.Height-1))) {

                    for (k = 0, fU = 0.0f; k < d3dsd.Width; k++, fU += (1.0f / (float)(d3dsd.Width-1))) {

                        fx = (fU - 0.5f) * 2.0f;
                        fy = (fV - 0.5f) * 2.0f;
                        fMag = (float)sqrt(fx * fx + fy * fy);
                        if (fMag > 1.0f) {
                            vNormal = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
                        }
                        else {
                            fMP = fMag * M_PI;
                            fSin = (float)sin(fMP);
                            vNormal.y = (float)cos(fMP);
                            fx /= fMag; // Normalize
                            fy /= fMag;
                            vNormal.x = fx * fSin;
                            vNormal.z = fy * fSin;
                        }

                        fIntensity = D3DXVec3Dot(&vLight, &vNormal);
                        if (fIntensity < 0.0f) {
                            fIntensity = 0.0f;
                        }
                        pdwPixel[k] = 0xFF                        << pixd.dwAShift |
                                      (BYTE)(fIntensity * fRed)   << pixd.dwRShift |
                                      (BYTE)(fIntensity * fGreen) << pixd.dwGShift |
                                      (BYTE)(fIntensity * fBlue)  << pixd.dwBShift;
                    }

                    pdwPixel += (d3dlr.Pitch / pixd.uStride);
                }

                break;
            }

            case D3DFMT_R5G6B5:
            case D3DFMT_X1R5G5B5:
            case D3DFMT_A1R5G5B5:
            case D3DFMT_A4R4G4B4: {

                LPWORD pwPixel = (LPWORD)d3dlr.pBits;

                fRed = fRed / 255.0f * (float)(pixd.dwRMask >> pixd.dwRShift);
                fGreen = fGreen / 255.0f * (float)(pixd.dwGMask >> pixd.dwGShift);
                fBlue = fBlue / 255.0f * (float)(pixd.dwBMask >> pixd.dwBShift);

                for (j = 0, fV = 0.0f; j < d3dsd.Height; j++, fV += (1.0f / (float)(d3dsd.Height-1))) {

                    for (k = 0, fU = 0.0f; k < d3dsd.Width; k++, fU += (1.0f / (float)(d3dsd.Width-1))) {

                        fx = (fU - 0.5f) * 2.0f;
                        fy = (fV - 0.5f) * 2.0f;
                        fMag = (float)sqrt(fx * fx + fy * fy);
                        if (fMag > 1.0f) {
                            vNormal = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
                        }
                        else {
                            fMP = fMag * M_PI;
                            fSin = (float)sin(fMP);
                            vNormal.y = (float)cos(fMP);
                            fx /= fMag; // Normalize
                            fy /= fMag;
                            vNormal.x = fx * fSin;
                            vNormal.z = fy * fSin;
                        }

                        fIntensity = D3DXVec3Dot(&vLight, &vNormal);
                        if (fIntensity < 0.0f) {
                            fIntensity = 0.0f;
                        }

                        pwPixel[k] = (WORD)(pixd.dwAMask |
                                      ((UINT)(fIntensity * fRed)   << pixd.dwRShift) & pixd.dwRMask |
                                      ((UINT)(fIntensity * fGreen) << pixd.dwGShift) & pixd.dwGMask |
                                      ((UINT)(fIntensity * fBlue)  << pixd.dwBShift) & pixd.dwBMask);
                    }

                    pwPixel += (d3dlr.Pitch / pixd.uStride);
                }

                break;
            }
        }

        hr = pd3dt->UnlockRect(i);
        if (FAILED(hr)) {
            ResultFailed(hr, TEXT("IDirect3DTexture8::UnlockRect"));
            ReleaseTexture(pd3dt);
            return NULL;
        }
    }

    return pd3dt;
}

//******************************************************************************
BOOL SetDiffuseMapCoords(D3DVECTOR* pvNormal, UINT uNStride, PTCOORD ptcTCoord, 
                        UINT uTStride, UINT uVertices, D3DMATRIX* pmWorld, 
                        D3DVECTOR* pvLightDir, float fTheta)
{
    D3DXVECTOR3     vL, vLDir, vNormal, vCross;
    LPD3DXVECTOR3   pvN;
    LPBYTE          pNormal, pTexCoord;
    float           fSin, fCos, fSin2, fCos2;
    float           fNU, fNV, fMagUV, fMagXZ;
    UINT            i;

    if (!pvNormal || !ptcTCoord || !pmWorld || !pvLightDir) {
        return FALSE;
    }

    fTheta = M_PI - fTheta;
    fCos2 = (float)cos(fTheta);
    fSin2 = (float)sin(fTheta);

    // Normalize the light direction vector
    D3DXVec3Normalize(&vLDir, (LPD3DXVECTOR3)pvLightDir);

    // Transform the light direction vector into model space
    // (multiply the vector by the transposed rotational component of the
    // world matrix) and negate it
    vL.x = -(vLDir.x * pmWorld->_11 + vLDir.y * pmWorld->_12 + vLDir.z * pmWorld->_13);
    vL.y = -(vLDir.x * pmWorld->_21 + vLDir.y * pmWorld->_22 + vLDir.z * pmWorld->_23);
    vL.z = -(vLDir.x * pmWorld->_31 + vLDir.y * pmWorld->_32 + vLDir.z * pmWorld->_33);

    // Generate texture coordinates for the vertices
    pNormal = (LPBYTE)pvNormal;
    pTexCoord = (LPBYTE)ptcTCoord;

    for (i = 0; i < uVertices; i++) {

        pvN = (LPD3DXVECTOR3)pNormal;
        ptcTCoord = (PTCOORD)pTexCoord;

        fCos = D3DXVec3Dot(&vL, pvN);

        D3DXVec3Cross(&vCross, &vL, pvN);
        fSin = D3DXVec3Length(&vCross);

        vNormal.x = -fSin * fCos2;
        vNormal.y = fCos;
        vNormal.z = -fSin * -fSin2;

        // Find the normal vector offsets in the light map
        fMagUV = (float)acos(vNormal.y) / M_PI;

        if (fMagUV < 0.0001f) {
            fNU = 0.5f;
            fNV = 0.5f;
        }
        else if (fMagUV > 0.9999) {
            fNU = 0.0f;
            fNV = 0.5f;
        }
        else {
            fMagXZ = (float)sqrt(vNormal.x * vNormal.x + vNormal.z * vNormal.z);
            fNU = vNormal.x / fMagXZ;
            fNV = vNormal.z / fMagXZ;
           
            fNU *= fMagUV;
            fNV *= fMagUV;

            fNU = 0.5f + (fNU / 2.0f);
            fNV = 0.5f - (fNV / 2.0f);
        }

        ptcTCoord->u = fNU;
        ptcTCoord->v = fNV;

        pNormal += uNStride;
        pTexCoord += uTStride;
    }

    return TRUE;
}

/*
//******************************************************************************
//
// Function:
//
//     SetColorKey
//
// Description:
//
//     Add source colorkey information to a texture.  This can be done in one
//     of two ways: using the SetColorKey method of DirectDraw or using
//     alpha channel information in each pixel to simulate the colorkey.
//     If the driver supports source colorkeying (using either the hardware or
//     under emulation), set the colorkey using the SetColorKey method.
//     Otherwise, if the texture contains alpha information set the alpha bits 
//     to zero for the colorkeyed pixels.
//
// Arguments:
//
//     LPDIRECTDRAWSURFACE7 pd3dt             - Texture on which to set the colorkey
//
//     D3DCOLOR cColorKey                   - Color value of the pixels to
//                                            make transparent
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL SetColorKey(LPDIRECTDRAWSURFACE7 pd3dt, D3DCOLOR cColorKey) {

    DDSURFACEDESC2       ddsd;
    DWORD                dwColorKey;
    HRESULT              hr;

    // Parameter validation
    if (!pd3dt) {
        return FALSE;
    }

    // Get the surface-specific colorkey value (the representation of
    // the pixel in surface memory) from the red, green, and blue
    // components of the given D3DCOLOR
    dwColorKey = ColorToPixel(pd3dt, RGB_MAKE(RGBA_GETRED(cColorKey),
                                              RGBA_GETGREEN(cColorKey), 
                                              RGBA_GETBLUE(cColorKey)));

    // Get the description of the texture surface
    memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
    ddsd.dwSize = sizeof(DDSURFACEDESC2);
    hr = pd3dt->GetSurfaceDesc(&ddsd);
    if (ResultFailed(hr, TEXT("IDirectDrawSurface7::GetSurfaceDesc"))) {
        return FALSE;
    }

    // If the texture is palettized, attempt to use alpha in the palette
    // to simulate the colorkeying
    if ((ddsd.ddpfPixelFormat.dwRGBBitCount < 16) &&
        (g_pdevdCurrent->d3ddDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_ALPHAPALETTE)) 
    {
        LPDIRECTDRAWPALETTE pddp;
        PALETTEENTRY        pe;
        DWORD               dwCaps;

        hr = pd3dt->GetPalette(&pddp);
        if (ResultFailed(hr, TEXT("IDirectDrawSurface7::GetPalette"))) {
            return FALSE;
        }

        hr = pddp->GetCaps(&dwCaps);
        if (ResultFailed(hr, TEXT("IDirectDrawPalette::GetCaps"))) {
            pddp->Release();
            return FALSE;
        }

        if (dwCaps & DDPCAPS_ALPHA) {

            hr = pddp->GetEntries(0, dwColorKey, 1, &pe);
            if (ResultFailed(hr, TEXT("IDirectDrawPalette::GetEntries"))) {
                pddp->Release();
                return FALSE;
            }

            pe.peFlags = 0;

            hr = pddp->SetEntries(0, dwColorKey, 1, &pe);

            pddp->Release();

            if (ResultFailed(hr, TEXT("IDirectDrawPalette::SetEntries"))) {
                return FALSE;
            }

            return TRUE;
        }

        pddp->Release();        
    }

    // If the texture contains alpha information, use the alpha bits
    // to simulate the colorkeying
    if (ddsd.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS
        && (g_pdevdCurrent->d3ddDesc.dpcTriCaps.dwTextureCaps 
            & D3DPTEXTURECAPS_TRANSPARENCY)) 
    {
        DWORD   dwPitch;
        UINT    i, j;

        // Lock the surface
        memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
        ddsd.dwSize = sizeof(DDSURFACEDESC2);
        hr = pd3dt->Lock(NULL, &ddsd, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL);
        if (ResultFailed(hr, TEXT("IDirectDrawSurface4::Lock"))) {
            return FALSE;
        }

        switch (ddsd.ddpfPixelFormat.dwRGBBitCount) {

            case 16: {

                LPWORD pwPixel = (LPWORD)ddsd.lpSurface;

                dwPitch = ddsd.lPitch / (sizeof(WORD) / sizeof(BYTE));

                for (i = 0; i < ddsd.dwHeight; i++) {

                    for (j = 0; j < ddsd.dwWidth; j++) {

                        if ((DWORD)(*(pwPixel + j) & ~(WORD)ddsd.ddpfPixelFormat.dwRGBAlphaBitMask) == (WORD)dwColorKey) {
                            *(pwPixel + j) &= ~ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;
                        }
                    }

                    pwPixel += dwPitch;
                }

                break;
            }

            case 32: {

                LPDWORD pdwPixel = (LPDWORD)ddsd.lpSurface;

                dwPitch = ddsd.lPitch / (sizeof(DWORD) / sizeof(BYTE));

                for (i = 0; i < ddsd.dwHeight; i++) {

                    for (j = 0; j < ddsd.dwWidth; j++) {

                        if ((*(pdwPixel + j) & ~ddsd.ddpfPixelFormat.dwRGBAlphaBitMask) == dwColorKey) {
                            *(pdwPixel + j) &= ~ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;
                        }
                    }

                    pdwPixel += dwPitch;
                }

                break;
            }
        }

        // Unlock the surface
        hr = pd3dt->Unlock(NULL);
        if (ResultFailed(hr, TEXT("IDirectDrawSurface7::Unlock"))) {
            return FALSE;
        }
    }

    // If source colorkeying is supported, use it
    else if ((g_pdevdCurrent->d3ddDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_COLORKEYBLEND) &&
             ((g_pdevdCurrent->d3ddDesc.dwDevCaps & D3DDEVCAPS_HWRASTERIZATION && 
             (g_pdrvdCurrent->ddcHAL.dwCKeyCaps & DDCKEYCAPS_SRCBLT)) ||
             (!(g_pdevdCurrent->d3ddDesc.dwDevCaps & D3DDEVCAPS_HWRASTERIZATION) && 
             (g_pdrvdCurrent->ddcHEL.dwCKeyCaps & DDCKEYCAPS_SRCBLT))))
             
    {
        DDCOLORKEY ddck;

        ddck.dwColorSpaceLowValue = dwColorKey;
        ddck.dwColorSpaceHighValue = dwColorKey;
        hr = pd3dt->SetColorKey(DDCKEY_SRCBLT, &ddck);
        if (ResultFailed(hr, TEXT("IDirectDrawSurface7::SetColorKey"))) {
            return FALSE;
        }
    }

    // Otherwise a source colorkey cannot be applied to the texture
    else {

        DebugString(TEXT("A source colorkey cannot be applied to the texture ")
                    TEXT("without either source colorkey support or an alpha ")
                    TEXT("channel in the texture/palette"));
        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     EnableColorKey
//
// Description:
//
//     Set the appropriate render state to enable or disable colorkeyed
//     rendering.
//
// Arguments:
//
//     LPDIRECTDRAWSURFACE7 pd3dt       - Direct3DTexture object to be 
//                                        colorkeyed
//
//     BOOL bEnable                     - Set to TRUE to enable colorkeying,
//                                        set to FALSE to disable it.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL EnableColorKey(LPDIRECTDRAWSURFACE7 pd3dt, BOOL bEnable) 
{
    DDSURFACEDESC2       ddsd;
    HRESULT              hr;

    if (!pd3dt) {
        return FALSE;
    }

    // Get the description of the texture surface
    memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
    ddsd.dwSize = sizeof(DDSURFACEDESC2);
    hr = pd3dt->GetSurfaceDesc(&ddsd);
    if (ResultFailed(hr, TEXT("IDirectDrawSurface7::GetSurfaceDesc"))) {
        return FALSE;
    }

    // If the texture contains alpha information and the device supports
    // transparency, enable alpha testing
    if (ddsd.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS
        && (g_pdevdCurrent->d3ddDesc.dpcTriCaps.dwTextureCaps 
            & D3DPTEXTURECAPS_TRANSPARENCY)) 
    {
        g_pd3dDevice->SetRenderState(D3DRENDERSTATE_ALPHATESTENABLE, bEnable);
    }

    // If the texture contains alpha information and the device supports
    // translucency, enable alpha blending
    if (ddsd.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS
        && (g_pdevdCurrent->d3ddDesc.dpcTriCaps.dwTextureCaps 
            & D3DPTEXTURECAPS_ALPHA)) 
    {
        g_pd3dDevice->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, bEnable);
    }

    // If source colorkeying is supported by either hardware or emulation, use it
    else if ((g_pdevdCurrent->d3ddDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_COLORKEYBLEND) &&
             ((g_pdevdCurrent->d3ddDesc.dwDevCaps & D3DDEVCAPS_HWRASTERIZATION && 
             (g_pdrvdCurrent->ddcHAL.dwCKeyCaps & DDCKEYCAPS_SRCBLT)) ||
             (!(g_pdevdCurrent->d3ddDesc.dwDevCaps & D3DDEVCAPS_HWRASTERIZATION) && 
             (g_pdrvdCurrent->ddcHEL.dwCKeyCaps & DDCKEYCAPS_SRCBLT))))
    {
        g_pd3dDevice->SetRenderState(D3DRENDERSTATE_COLORKEYENABLE, bEnable);
    }

    // Otherwise colorkeying cannot be enabled/disabled
    else {
        return FALSE;
    }

    return true;
}

//******************************************************************************
//
// Function:
//
//     RestoreTextures
//
// Description:
//
//     Restore all textures.
//
// Arguments:
//
//     LPDIRECT3DDEVICE7 pd3dDevice         - Current device object.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL RestoreTextures(LPDIRECT3DDEVICE7 pd3dDevice) {

    PTEXTUREDESC ptexd;
    BOOL         bRet;
    HRESULT      hr;

    for (ptexd = g_ptexdList; ptexd; ptexd = ptexd->ptexdNext) {

        if (ptexd->pdds->IsLost() == DDERR_SURFACELOST) {

            hr = ptexd->pdds->Restore();
            if (ResultFailed(hr, TEXT("IDirectDrawSurface7::Restore"))) {
                bRet = FALSE;
                continue;
            }

            if (*(ptexd->szName) || ptexd->wResourceID) {

                if (!PopulateTexture(ptexd->pdds, ptexd->wResourceID ? 
                    MAKEINTRESOURCE(ptexd->wResourceID) : ptexd->szName, 
                    ptexd->fAlpha, ptexd->cColorKey)) 
                {
                    bRet = FALSE;
                }
            }
        }
    }

    return bRet;
}

//******************************************************************************
//
// Function:
//
//     ColorToPixel
//
// Description:
//
//     Calculate the surface-specific colorkey value (the representation of
//     the pixel in surface memory) from the red, green, and blue
//     components of the given D3DCOLOR.
//
// Arguments:
//
//     LPDIRECTDRAWSURFACE7 pdds       - Surface on which to calculate the 
//                                       pixel value
//
//     D3DCOLOR c                      - Color of the pixel
//
// Return Value:
//
//     The pixel representation in surface memory of the given color value on
//     success, zero on failure.
//
//******************************************************************************
DWORD ColorToPixel(LPDIRECTDRAWSURFACE7 pdds, D3DCOLOR c) {

    HRESULT         hr;
    DDSURFACEDESC2  ddsd;
    BYTE            r, g, b, a;
    DWORD           dwPixel;

    // Parameter validation
    if (!pdds) {
        return 0;
    }

    // Get the description of the surface
    memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
    ddsd.dwSize = sizeof(DDSURFACEDESC2);

    hr = pdds->GetSurfaceDesc(&ddsd);
    if (ResultFailed(hr, TEXT("IDirectDrawSurface4::GetSurfaceDesc"))) {
        return 0;
    }

    r = (BYTE)RGBA_GETRED(c);
    g = (BYTE)RGBA_GETGREEN(c);
    b = (BYTE)RGBA_GETBLUE(c);
    a = (BYTE)RGBA_GETALPHA(c);

    // If the surface is palettized, select the nearest palette entry
    // to the given color
    if (ddsd.ddpfPixelFormat.dwRGBBitCount < 16) {

        LPDIRECTDRAWPALETTE pddp;
        PALETTEENTRY        ppe[256];
        UINT                uNumEntries, 
                            i;
        BYTE                match;
        int                 dr, dg, db, d, dLast;

        // Get the palette
        hr = pdds->GetPalette(&pddp);
        if (ResultFailed(hr, TEXT("IDirectDrawSurface4::GetPalette"))) {
            return 0;
        }

        uNumEntries = (0x1 << ddsd.ddpfPixelFormat.dwRGBBitCount);

        // Retrieve the palette entries
        hr = pddp->GetEntries(0, 0, uNumEntries, ppe);
        pddp->Release();
        if (ResultFailed(hr, TEXT("IDirectDrawPalette::GetEntries"))) {
            return 0;
        }

        dLast = INT_MAX;

        // Find the entry in the palette that most closely matches the
        // given pixel color
        for (i = 0; i < uNumEntries; i++) {

            dr = (int)ppe[i].peRed - r;
            dg = (int)ppe[i].peGreen - g;
            db = (int)ppe[i].peBlue - b;

            d = dr * dr + dg * dg + db * db;

            if (d < dLast) {
                match = i;
                dLast = d;
                if (d == 0) {
                    break;
                }
            }
        }

	    dwPixel = match;

        DebugString(TEXT("Color key set to index %d - r: %d, g: %d, b: %d"), 
                match, ppe[match].peRed, ppe[match].peGreen, ppe[match].peBlue);
    }

    else {

        UINT            sa, sr, sg, sb, s;
        DWORD           ma, mr, mg, mb;

        // Calculate mask values for getting at the alpha, 
        // red, green, and blue components of a color
        ma = ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;
        mr = ddsd.ddpfPixelFormat.dwRBitMask;
        mg = ddsd.ddpfPixelFormat.dwGBitMask;
        mb = ddsd.ddpfPixelFormat.dwBBitMask;

        // Calculate shift values for getting at the alpha, 
        // red, green, and blue components of a color
        if (ma) {
    	    for (sa = 0, s = ma; !(s & 0x1); sa++, s >>= 1);
        }
    	for (sr = 0, s = mr; !(s & 0x1); sr++, s >>= 1);
    	for (sg = 0, s = mg; !(s & 0x1); sg++, s >>= 1);
    	for (sb = 0, s = mb; !(s & 0x1); sb++, s >>= 1);

        dwPixel = ((BYTE)((float)(ma >> sa) * ((float)a / 255.0f) + 0.5f) << sa) |
                  ((BYTE)((float)(mr >> sr) * ((float)r / 255.0f) + 0.5f) << sr) |
                  ((BYTE)((float)(mg >> sg) * ((float)g / 255.0f) + 0.5f) << sg) |
                  ((BYTE)((float)(mb >> sb) * ((float)b / 255.0f) + 0.5f) << sb);
    }

    return dwPixel;
}

//******************************************************************************
//
// Function:
//
//     ReduceResolution
//
// Description:
//
//     Reduce the resolution of the given mipmap surface by a factor of two and 
//     copy the lower resolution image into the next level of the mipmap.
//
// Arguments:
//
//     LPDIRECTDRAWSURFACE7 pddsSrc    - Mipmap surface to be reduced
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
static BOOL ReduceResolution(LPDIRECTDRAWSURFACE7 pddsSrc) {

    LPDIRECTDRAWSURFACE7 pddsDst;
    DDSURFACEDESC2       ddsdSrc,
                         ddsdDst;
    DDSCAPS2             ddscaps;
    DDCOLORKEY           ddck;
    BOOL                 bColorKey;
    UINT                 uPixels;
    UINT                 i, j, k;
    BOOL                 bRet;
    HRESULT              hr;

    // Parameter validation
    if (!pddsSrc) {
        return FALSE;
    }

    memset(&ddscaps, 0, sizeof(DDSCAPS2));
    ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;

    // Get the next level in the mipmap chain
    hr = pddsSrc->GetAttachedSurface(&ddscaps, &pddsDst);
    if (hr == DDERR_NOTFOUND) {
        // There are no more levels in the mipmap chain
        return TRUE;
    }
    if (ResultFailed(hr, TEXT("IDirectDrawSurface4::GetAttachedSurface"))) {
        return FALSE;
    }

    // Get the colorkey (if one was set)
    if (g_pdrvdCurrent->ddcHAL.dwCKeyCaps & DDCKEYCAPS_SRCBLT
        || g_pdrvdCurrent->ddcHEL.dwCKeyCaps & DDCKEYCAPS_SRCBLT) 
    {
        hr = pddsSrc->GetColorKey(DDCKEY_SRCBLT, &ddck);
        bColorKey = SUCCEEDED(hr);
        if (bColorKey) {
            // Set the colorkey for the destination
            hr = pddsDst->SetColorKey(DDCKEY_SRCBLT, &ddck);
            if (ResultFailed(hr, TEXT("IDirectDrawSurface4::SetColorKey"))) {
                pddsDst->Release();
                return FALSE;
            }
        }
    }

    // Lock the higher resolution (source) surface
    memset(&ddsdSrc, 0, sizeof(DDSURFACEDESC2));
    ddsdSrc.dwSize = sizeof(DDSURFACEDESC2);
    hr = pddsSrc->Lock(NULL, &ddsdSrc, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL);
    if (ResultFailed(hr, TEXT("IDirectDrawSurface4::Lock"))) {
        pddsDst->Release();
        return FALSE;
    }

    // Lock the lower resolution (destination) surface
    memset(&ddsdDst, 0, sizeof(DDSURFACEDESC2));
    ddsdDst.dwSize = sizeof(DDSURFACEDESC2);
    hr = pddsDst->Lock(NULL, &ddsdDst, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL);
    if (ResultFailed(hr, TEXT("IDirectDrawSurface4::Lock"))) {
        pddsDst->Release();
        pddsSrc->Unlock(NULL);
        return FALSE;
    }

    // Reduce the resolution
    if (ddsdDst.ddpfPixelFormat.dwRGBBitCount < 16) {

        LPDIRECTDRAWPALETTE pddp;
        PALETTEENTRY        ppe[256];
        UINT                uNumEntries = (0x1 << ddsdDst.ddpfPixelFormat.dwRGBBitCount);
        BOOL                bPal8 = (BOOL)(ddsdDst.ddpfPixelFormat.dwRGBBitCount == 8);
        BOOL                bAlphaPal;
        DWORD               dwCaps;
        LPBYTE              psrc = (LPBYTE)ddsdSrc.lpSurface,
                            pdstRow = (LPBYTE)ddsdDst.lpSurface,
                            pdst;
        BYTE                c[4], match;
        PALETTEENTRY        ppePixel[4];
        int                 nRed, nGreen, nBlue, 
                            nRedDiff, nGreenDiff, nBlueDiff, 
                            nDiff, nLast;
        BOOL                bMatchFound;
        const UINT          uCacheEntries = 5;
        UINT                uNextCacheEntry = 0;
        struct {
            int             nRed, nGreen, nBlue;
            BYTE            match;
        } mcMatchCache[uCacheEntries];

        // Initialize the cache
        for (i = 0; i < uCacheEntries; i++) {
            mcMatchCache[i].nRed = mcMatchCache[i].nGreen = mcMatchCache[i].nBlue = -1;
            mcMatchCache[i].match = 0;
        }

        // Get the palette from the source
        hr = pddsSrc->GetPalette(&pddp);
        if (ResultFailed(hr, TEXT("IDirectDrawSurface4::GetPalette"))) {
            pddsSrc->Unlock(NULL);
            pddsDst->Unlock(NULL);
            pddsDst->Release();
            return FALSE;
        }

        // Set the palette for the destination
        hr = pddsDst->SetPalette(pddp);
        if (ResultFailed(hr, TEXT("IDirectDrawSurface4::SetPalette"))) {
            pddp->Release();
            pddsSrc->Unlock(NULL);
            pddsDst->Unlock(NULL);
            pddsDst->Release();
            return FALSE;
        }

        // Check if the palette contains alpha information
        hr = pddp->GetCaps(&dwCaps);
        if (ResultFailed(hr, TEXT("IDirectDrawPalette::GetCaps"))) {
            pddp->Release();
            pddsSrc->Unlock(NULL);
            pddsDst->Unlock(NULL);
            pddsDst->Release();
            return FALSE;
        }

        bAlphaPal = (dwCaps & DDPCAPS_ALPHA) == DDPCAPS_ALPHA;

        // Obtain the palette entries
        hr = pddp->GetEntries(0, 0, uNumEntries, ppe);
        pddp->Release();
        if (ResultFailed(hr, TEXT("IDirectDrawPalette::GetEntries"))) {
            pddsSrc->Unlock(NULL);
            pddsDst->Unlock(NULL);
            pddsDst->Release();
            return FALSE;
        }

        for (i = 0; i < ddsdDst.dwHeight; i++) {

            pdst = pdstRow;

            for (j = 0; j < ddsdDst.dwWidth; j++) {

                // Get a four pixel group from the high resolution surface.
                // These pixels will be interpolated into a single pixel in
                // the low resolution surface
                if (!bPal8) {
                    c[0] = psrc[(ddsdSrc.lPitch * i * 2) + j] >> 4;
                    c[1] = psrc[(ddsdSrc.lPitch * i * 2) + j] & 0xF; 
                    c[2] = psrc[(ddsdSrc.lPitch * (i * 2 + 1)) + j] >> 4;
                    c[3] = psrc[(ddsdSrc.lPitch * (i * 2 + 1)) + j] & 0xF;
                }
                else {
                    c[0] = psrc[(ddsdSrc.lPitch * i * 2) + j * 2];
                    c[1] = psrc[(ddsdSrc.lPitch * i * 2) + (j * 2 + 1)]; 
                    c[2] = psrc[(ddsdSrc.lPitch * (i * 2 + 1)) + j * 2];
                    c[3] = psrc[(ddsdSrc.lPitch * (i * 2 + 1)) + (j * 2 + 1)];
                }

                // If a pixel is colorkeyed (using SetColorKey or alpha blending), 
                // exclude it from the interpolation
                uPixels = 0;

                for (k = 0; k < 4; k++) {
                    if ((bColorKey && 
                        c[k] == ddck.dwColorSpaceLowValue) ||
                        (bAlphaPal && !ppe[c[k]].peFlags)) 
                    {
                        memset(&ppePixel[k], 0, sizeof(PALETTEENTRY));
                    }
                    else {
                        ppePixel[k] = ppe[c[k]];
                        uPixels++;
                    }
                }

                // If at least three of the four pixels to be combined are colorkeyed,
                // the combined pixel should also be colorkeyed
                if (uPixels < 2) {
                    if (bColorKey) {
                        if (bPal8) {
                            *pdst = (BYTE)ddck.dwColorSpaceLowValue;
                        }
                        else {
                            if (j % 2) {
                                *pdst |= (BYTE)ddck.dwColorSpaceLowValue;
                            }
                            else {
                                *pdst = (BYTE)ddck.dwColorSpaceLowValue << 4;
                            }
                        }
                    }
                    else {
                        for (k = 0; k < 4; k++) {
                            if (!ppe[c[k]].peFlags) {
                                if (bPal8) {
                                    *pdst = c[k];
                                }
                                else {
                                    if (j % 2) {
                                        *pdst |= c[k];
                                    }
                                    else {
                                        *pdst = c[k] << 4;
                                    }
                                }
                                break;
                            }
                        }
                    }
                }

                // Otherwise perform the interpolation
                else {

                    nRed   = ((int)ppePixel[0].peRed + 
                                           ppePixel[1].peRed +
                                           ppePixel[2].peRed + 
                                           ppePixel[3].peRed) / uPixels;

                    nGreen = ((int)ppePixel[0].peGreen + 
                                           ppePixel[1].peGreen +
                                           ppePixel[2].peGreen + 
                                           ppePixel[3].peGreen) / uPixels;

                    nBlue  = ((int)ppePixel[0].peBlue + 
                                           ppePixel[1].peBlue +
                                           ppePixel[2].peBlue + 
                                           ppePixel[3].peBlue) / uPixels;

                    // First check the cache for a match
                    bMatchFound = false;
                    for (k = 0; k < uCacheEntries; k++) {
                        if (nRed == mcMatchCache[i].nRed && 
                            nGreen == mcMatchCache[i].nGreen && 
                            nBlue == mcMatchCache[i].nBlue)
                        {
                            match = mcMatchCache[i].match;
                            bMatchFound = true;
                            break;
                        }
                    }

                    if (!bMatchFound) {

                        nLast = INT_MAX;

                        // Find the entry in the palette that most closely matches the
                        // interpolated pixel
                        for (k = 0; k < uNumEntries; k++) {
                            nRedDiff   = (int)ppe[k].peRed - nRed;
                            nGreenDiff = (int)ppe[k].peGreen - nGreen;
                            nBlueDiff  = (int)ppe[k].peBlue - nBlue;
                            nDiff = nRedDiff * nRedDiff + 
                                    nGreenDiff * nGreenDiff + 
                                    nBlueDiff * nBlueDiff;
                            if (nDiff < nLast) {
                                match = k;
                                nLast = nDiff;
                                if (nDiff == 0) {
                                    break;
                                }
                            }
                        }

                        // Update the cache
                        mcMatchCache[uNextCacheEntry].nRed = nRed;
                        mcMatchCache[uNextCacheEntry].nGreen = nGreen;
                        mcMatchCache[uNextCacheEntry].nBlue = nBlue;
                        mcMatchCache[uNextCacheEntry].match = match;
                        if (++uNextCacheEntry >= uCacheEntries) {
                            uNextCacheEntry = 0;
                        }
                    }

                    if (bPal8) {
                        *pdst = match;
                    }
                    else {
                        if (j % 2) {
                            *pdst |= match;
                        }
                        else {
                            *pdst = match << 4;
                        }
                    }
                }

                if (bPal8 || j % 2) {
                    pdst++;
                }
            }

            pdstRow += ddsdDst.lPitch;
        }
    }

    else if (ddsdDst.ddpfPixelFormat.dwRGBBitCount == 16) {

        LPWORD          pwSrc = (LPWORD)ddsdSrc.lpSurface,
                        pwDst = (LPWORD)ddsdDst.lpSurface;
        DWORD           dwPitchSrc = ddsdSrc.lPitch 
                                     / (sizeof(WORD) / sizeof(BYTE)),
                        dwPitchDst = ddsdDst.lPitch 
                                     / (sizeof(WORD) / sizeof(BYTE));
        WORD            w[4];
        UINT            sa, sr, sg, sb, s;
        DWORD           ma, mr, mg, mb;

        // Calculate mask values for getting at the alpha, 
        // red, green, and blue components of a color
        ma = ddsdSrc.ddpfPixelFormat.dwRGBAlphaBitMask;
        mr = ddsdSrc.ddpfPixelFormat.dwRBitMask;
        mg = ddsdSrc.ddpfPixelFormat.dwGBitMask;
        mb = ddsdSrc.ddpfPixelFormat.dwBBitMask;

        // Calculate shift values for getting at the alpha, 
        // red, green, and blue components of a color
        if (ma) {
    	    for (sa = 0, s = ma; !(s & 0x1); sa++, s >>= 1);
        }
    	for (sr = 0, s = mr; !(s & 0x1); sr++, s >>= 1);
    	for (sg = 0, s = mg; !(s & 0x1); sg++, s >>= 1);
    	for (sb = 0, s = mb; !(s & 0x1); sb++, s >>= 1);

        // Reduce the resolution by taking groups of four pixels from the high 
        // resolution surface and interpolating them to produce the 
        // corresponding pixel in the low resolution surface
        for (i = 0; i < ddsdDst.dwHeight; i++) {

            for (j = 0; j < ddsdDst.dwWidth; j++) {

                // Get a four pixel group from the high resolution surface.
                // These pixels will be interpolated into a single pixel in
                // the low resolution surface
                w[0] = pwSrc[(dwPitchSrc * i * 2) + j * 2];
                w[1] = pwSrc[(dwPitchSrc * i * 2) + (j * 2 + 1)]; 
                w[2] = pwSrc[(dwPitchSrc * (i * 2 + 1)) + j * 2];
                w[3] = pwSrc[(dwPitchSrc * (i * 2 + 1)) + (j * 2 + 1)];

                // If a pixel is colorkeyed (using SetColorKey or alpha blending), 
                // exclude it from the interpolation
                uPixels = 0;

                for (k = 0; k < 4; k++) {
                    if (bColorKey) {
                        if ((w[k] & ~ma) == (ddck.dwColorSpaceLowValue & ~ma)) {
                            w[k] = 0;
                        }
                        else {
                            uPixels++;
                        }
                    }
                    else {
                        if (!ma || w[k] & ma) {
                            uPixels++;
                        }
                        else {
                            w[k] = 0;
                        }
                    }
                }

                // If at least three of the four pixels to be combined are colorkeyed,
                // the combined pixel should also be colorkeyed
                if (uPixels < 2) {
                    if (bColorKey) {
                        pwDst[j] = (WORD)ddck.dwColorSpaceLowValue;
                    }
                    else {
                        pwDst[j] &= ~ddsdDst.ddpfPixelFormat.dwRGBAlphaBitMask;
                    }
                }

                // Otherwise perform the interpolation
                else {
                    pwDst[j] = (WORD)(
                                   (((((w[0] & ma) >> sa) + 
                                      ((w[1] & ma) >> sa) + 
                                      ((w[2] & ma) >> sa) + 
                                      ((w[3] & ma) >> sa)) / uPixels) << sa) |
                                   (((((w[0] & mr) >> sr) + 
                                      ((w[1] & mr) >> sr) + 
                                      ((w[2] & mr) >> sr) + 
                                      ((w[3] & mr) >> sr)) / uPixels) << sr) |
                                   (((((w[0] & mg) >> sg) + 
                                      ((w[1] & mg) >> sg) + 
                                      ((w[2] & mg) >> sg) + 
                                      ((w[3] & mg) >> sg)) / uPixels) << sg) |
                                   (((((w[0] & mb) >> sb) + 
                                      ((w[1] & mb) >> sb) + 
                                      ((w[2] & mb) >> sb) + 
                                      ((w[3] & mb) >> sb)) / uPixels) << sb)
                               );
                }
            }

            pwDst += dwPitchDst;
        }
    }

    else if (ddsdDst.ddpfPixelFormat.dwRGBBitCount == 24) {

        LPBYTE          pDst;
        DWORD           dwPixel;
        DWORD           dw[4];
        UINT            sr, sg, sb, s;
        DWORD           mr, mg, mb;

        // Set mask values for getting at the 
        // red, green, and blue components of a color
        mr = ddsdSrc.ddpfPixelFormat.dwRBitMask << 8;
        mg = ddsdSrc.ddpfPixelFormat.dwGBitMask << 8;
        mb = ddsdSrc.ddpfPixelFormat.dwBBitMask << 8;

        // Set shift values for getting at the
        // red, green, and blue components of a color
    	for (sr = 0, s = mr; !(s & 0x1); sr++, s >>= 1);
    	for (sg = 0, s = mg; !(s & 0x1); sg++, s >>= 1);
    	for (sb = 0, s = mb; !(s & 0x1); sb++, s >>= 1);

        // Reduce the resolution by taking groups of four pixels from the high 
        // resolution surface and interpolating them to produce the 
        // corresponding pixel in the low resolution surface
        for (i = 0; i < ddsdDst.dwHeight; i++) {

            for (j = 0; j < ddsdDst.dwWidth; j++) {

                // REVIEW: This method will step past the surface by one byte

                // Get a four pixel group from the high resolution surface.
                // These pixels will be interpolated into a single pixel in
                // the low resolution surface
                dw[0] = *(LPDWORD)((LPBYTE)ddsdSrc.lpSurface + (ddsdSrc.lPitch * i * 2) + (j * 2 * 3));
                dw[1] = *(LPDWORD)((LPBYTE)ddsdSrc.lpSurface + (ddsdSrc.lPitch * i * 2) + ((j * 2 + 1) * 3));
                dw[2] = *(LPDWORD)((LPBYTE)ddsdSrc.lpSurface + (ddsdSrc.lPitch * (i * 2 + 1)) + (j * 2 * 3));
                dw[3] = *(LPDWORD)((LPBYTE)ddsdSrc.lpSurface + (ddsdSrc.lPitch * (i * 2 + 1)) + ((j * 2 + 1) * 3));

                // Perform the interpolation
                dwPixel = (DWORD)(
                               (((((dw[0] & mr) >> sr) + 
                                  ((dw[1] & mr) >> sr) + 
                                  ((dw[2] & mr) >> sr) + 
                                  ((dw[3] & mr) >> sr)) / 4) << sr) |
                               (((((dw[0] & mg) >> sg) + 
                                  ((dw[1] & mg) >> sg) + 
                                  ((dw[2] & mg) >> sg) + 
                                  ((dw[3] & mg) >> sg)) / 4) << sg) |
                               (((((dw[0] & mb) >> sb) + 
                                  ((dw[1] & mb) >> sb) + 
                                  ((dw[2] & mb) >> sb) + 
                                  ((dw[3] & mb) >> sb)) / 4) << sb)
                           );

                pDst = (LPBYTE)ddsdDst.lpSurface + (ddsdDst.lPitch * i) + (j * 3);
                if (sr > sb) {
                    *pDst++ = (BYTE)(dwPixel >> sr);
                    *pDst++ = (BYTE)(dwPixel >> sg);
                    *pDst++ = (BYTE)(dwPixel >> sb);
                }
                else {
                    *pDst++ = (BYTE)(dwPixel >> sb);
                    *pDst++ = (BYTE)(dwPixel >> sg);
                    *pDst++ = (BYTE)(dwPixel >> sr);
                }
            }
        }
    }

    else if (ddsdDst.ddpfPixelFormat.dwRGBBitCount == 32) {

        LPDWORD         pdwSrc = (LPDWORD)ddsdSrc.lpSurface,
                        pdwDst = (LPDWORD)ddsdDst.lpSurface;
        DWORD           dwPitchSrc = ddsdSrc.lPitch 
                                     / (sizeof(DWORD) / sizeof(BYTE)),
                        dwPitchDst = ddsdDst.lPitch 
                                     / (sizeof(DWORD) / sizeof(BYTE));
        DWORD           dw[4];
        UINT            sa, sr, sg, sb, s;
        DWORD           ma, mr, mg, mb;

        // Calculate mask values for getting at the alpha, 
        // red, green, and blue components of a color
        ma = ddsdSrc.ddpfPixelFormat.dwRGBAlphaBitMask;
        mr = ddsdSrc.ddpfPixelFormat.dwRBitMask;
        mg = ddsdSrc.ddpfPixelFormat.dwGBitMask;
        mb = ddsdSrc.ddpfPixelFormat.dwBBitMask;

        // Calculate shift values for getting at the alpha, 
        // red, green, and blue components of a color
        if (ma) {
    	    for (sa = 0, s = ma; !(s & 0x1); sa++, s >>= 1);
        }
    	for (sr = 0, s = mr; !(s & 0x1); sr++, s >>= 1);
    	for (sg = 0, s = mg; !(s & 0x1); sg++, s >>= 1);
    	for (sb = 0, s = mb; !(s & 0x1); sb++, s >>= 1);

        // Reduce the resolution by taking groups of four pixels from the high 
        // resolution surface and interpolating them to produce the 
        // corresponding pixel in the low resolution surface
        for (i = 0; i < ddsdDst.dwHeight; i++) {

            for (j = 0; j < ddsdDst.dwWidth; j++) {

                // Get a four pixel group from the high resolution surface.
                // These pixels will be interpolated into a single pixel in
                // the low resolution surface
                dw[0] = pdwSrc[(dwPitchSrc * i * 2) + j * 2];
                dw[1] = pdwSrc[(dwPitchSrc * i * 2) + (j * 2 + 1)]; 
                dw[2] = pdwSrc[(dwPitchSrc * (i * 2 + 1)) + j * 2];
                dw[3] = pdwSrc[(dwPitchSrc * (i * 2 + 1)) + (j * 2 + 1)];

                // If a pixel is colorkeyed (using SetColorKey or alpha blending), 
                // exclude it from the interpolation
                uPixels = 0;

                for (k = 0; k < 4; k++) {
                    if (bColorKey) {
                        if ((dw[k] & ~ma) == (ddck.dwColorSpaceLowValue & ~ma)) {
                            dw[k] = 0;
                        }
                        else {
                            uPixels++;
                        }
                    }
                    else {
                        if (!ma || dw[k] & ma) {
                            uPixels++;
                        }
                        else {
                            dw[k] = 0;
                        }
                    }
                }

                // If at least three of the four pixels to be combined are colorkeyed,
                // the combined pixel should also be colorkeyed
                if (uPixels < 2) {
                    if (bColorKey) {
                        pdwDst[j] = (WORD)ddck.dwColorSpaceLowValue;
                    }
                    else {
                        pdwDst[j] &= ~ddsdDst.ddpfPixelFormat.dwRGBAlphaBitMask;
                    }
                }

                // Otherwise perform the interpolation
                else {
                    pdwDst[j] = (DWORD)(
                                   (((((dw[0] & ma) >> sa) + 
                                      ((dw[1] & ma) >> sa) + 
                                      ((dw[2] & ma) >> sa) + 
                                      ((dw[3] & ma) >> sa)) / uPixels) << sa) |
                                   (((((dw[0] & mr) >> sr) + 
                                      ((dw[1] & mr) >> sr) + 
                                      ((dw[2] & mr) >> sr) + 
                                      ((dw[3] & mr) >> sr)) / uPixels) << sr) |
                                   (((((dw[0] & mg) >> sg) + 
                                      ((dw[1] & mg) >> sg) + 
                                      ((dw[2] & mg) >> sg) + 
                                      ((dw[3] & mg) >> sg)) / uPixels) << sg) |
                                   (((((dw[0] & mb) >> sb) + 
                                      ((dw[1] & mb) >> sb) + 
                                      ((dw[2] & mb) >> sb) + 
                                      ((dw[3] & mb) >> sb)) / uPixels) << sb)
                               );
                }
            }

            pdwDst += dwPitchDst;
        }
    }

    // Unlock the destination surface
    hr = pddsDst->Unlock(NULL);
    if (ResultFailed(hr, TEXT("IDirectDrawSurface4::Unlock"))) {
        pddsDst->Release();
        pddsSrc->Unlock(NULL);
        return FALSE;
    }

    // Unlock the source surface
    hr = pddsSrc->Unlock(NULL);
    if (ResultFailed(hr, TEXT("IDirectDrawSurface4::Unlock"))) {
        pddsDst->Release();
        return FALSE;
    }

    // Recursively reduce the resolution on the chain
    bRet = ReduceResolution(pddsDst);
    
    pddsDst->Release();

    return bRet;
}

//******************************************************************************
//
// Function:
//
//     InitPalette
//
// Description:
//
//     Initialize a given number of palette entries with evenly spaced
//     color values.
//
// Arguments:
//
//     LPPALETTEENTRY ppe              - Pointer to an array of palette entries
//                                       to intialize
//
//     UINT uNumEntries                - Number of palette entries to initialize
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
static BOOL InitPalette(LPPALETTEENTRY ppe, UINT uNumEntries) {

    UINT    i;
    BYTE    m = 1,
            c;
    float   f = 256.0f / ((float)uNumEntries / 7.0f),
            t = 0;

    // Parameter validation
    if (!ppe || uNumEntries <= 0) {
        return FALSE;
    }

    // The first entry will be black
    memset(ppe, 0, sizeof(PALETTEENTRY));

    // Take a basic iterative approach to filling the
    // palette entries with some evenly spaced color values
    for (i = 1; i < uNumEntries; i++) {

        if (m == 1) {
            t += f;
            c = (BYTE)t;
        }

        ppe[i].peRed = (m & 0x4) ? c : 0;
        ppe[i].peGreen = (m & 0x2) ? c : 0;
        ppe[i].peBlue = (m & 0x1) ? c : 0;
        ppe[i].peFlags = 0xFF;

        if (++m > 7) {
            m = 1;
        }
    }

    return TRUE;
}
*/

} // namespace DXCONIO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\noise.h ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    noise.h

Description:

    Noise functions.

*******************************************************************************/

#ifndef __NOISE_H__
#define __NOISE_H__

#define PRIME_TABLE_ENTRIES     256
#define MAX_OCTAVES             20

namespace DXCONIO {

class CPerlinNoise;
class CPerlinNoise1D;
class CPerlinNoise2D;
class CPerlinNoise3D;

typedef float (CPerlinNoise::* INTERPOLATEPROC)(float f1, float f2, float fBeta);
typedef float (CPerlinNoise1D::* NOISE1DPROC)(int x);
typedef float (CPerlinNoise2D::* NOISE2DPROC)(int x, int y);
typedef float (CPerlinNoise3D::* NOISE3DPROC)(int x, int y, int z);

typedef enum _INTERPOLATIONTYPE {
    INTERPOLATE_LINEAR = 0,
    INTERPOLATE_COSINE = 1,
} INTERPOLATIONTYPE, *PINTERPOLATIONTYPE;

//******************************************************************************
class CPerlinNoise {

protected:

    static UINT         m_puPrimes[3][PRIME_TABLE_ENTRIES];
    float               m_fPersistence;
    UINT                m_uOctaves;
    DWORD               m_dwSeed;
    INTERPOLATEPROC     m_pfnInterpolate;
    BOOL                m_bClamp;
    float               m_fRangeBase;
    float               m_fRangeMagnitude;
    DWORD               m_uOctave;
    struct
    {
        UINT            uPrime1;
        UINT            uPrime2;
        UINT            uPrime3;
    }                   m_plPrimesList[MAX_OCTAVES];

public:

                        CPerlinNoise(float fPersistence, UINT uOctaves, DWORD dwSeed, INTERPOLATIONTYPE irp, BOOL bClamp);
                        ~CPerlinNoise();

    void                SetPersistence(float fPersistence);
    void                SetOctaves(UINT uOctaves);
    void                SetSeed(DWORD dwSeed);
    void                SetInterpolation(INTERPOLATIONTYPE irp);
    void                EnableClamp(BOOL bEnable);
    void                SetRange(float fMin, float fMax);

protected:

    float               InterpolateLinear(float f1, float f2, float fBeta);
    float               InterpolateCosine(float f1, float f2, float fBeta);
    DWORD               Rand32(DWORD dwSeed);
    BOOL                IsPrime(UINT u);
    void                InitPrimesList(UINT uOctaves, DWORD dwSeed);
};

//******************************************************************************
class CPerlinNoise1D : public CPerlinNoise {

protected:

    NOISE1DPROC         m_pfnNoise;

public:

                        CPerlinNoise1D(float fPersistence, UINT uOctaves, DWORD dwSeed, INTERPOLATIONTYPE irp, BOOL bClamp, BOOL bSmooth);
                        ~CPerlinNoise1D();

    float               GetIntensity(float x);
    void                EnableSmoothing(BOOL bEnable);

protected:

    float               Noise1D(int x);
    float               SmoothNoise1D(int x);
    float               InterpolatedNoise1D(float x);
};

//******************************************************************************
class CPerlinNoise2D : public CPerlinNoise {

protected:

    NOISE2DPROC         m_pfnNoise;

public:

                        CPerlinNoise2D(float fPersistence, UINT uOctaves, DWORD dwSeed, INTERPOLATIONTYPE irp, BOOL bClamp, BOOL bSmooth);
                        ~CPerlinNoise2D();

    float               GetIntensity(float x, float y);
    void                EnableSmoothing(BOOL bEnable);

protected:

    float               Noise2D(int x, int y);
    float               SmoothNoise2D(int x, int y);
    float               InterpolatedNoise2D(float x, float y);
};

//******************************************************************************
class CPerlinNoise3D : public CPerlinNoise {

protected:

    NOISE3DPROC         m_pfnNoise;

public:

                        CPerlinNoise3D(float fPersistence, UINT uOctaves, DWORD dwSeed, INTERPOLATIONTYPE irp, BOOL bClamp, BOOL bSmooth);
                        ~CPerlinNoise3D();

    float               GetIntensity(float x, float y, float z);
    void                EnableSmoothing(BOOL bEnable);

protected:

    float               Noise3D(int x, int y, int z);
    float               SmoothNoise3D(int x, int y, int z);
    float               InterpolatedNoise3D(float x, float y, float z);
};

} // namespace DXCONIO

#endif // __NOISE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\util.cpp ===
/*******************************************************************************

Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

File Name:

    util.cpp

Description:

    Utility functions.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <d3dx8.h>
#include <tchar.h>
#include <stdio.h>
#include <math.h>
#include "util.h"

namespace DXCONIO {

//******************************************************************************
// Function prototypes
//******************************************************************************

//******************************************************************************
// Globals
//******************************************************************************

static HANDLE           g_hHeap = NULL;

//******************************************************************************
// Debugging functions
//******************************************************************************

#if defined(DEBUG) || defined(_DEBUG)
//******************************************************************************
//
// Function:
//
//     DebugString
//
// Description:
//
//     Take the formatted output, prepend the application name, and send the
//     output to the debugger.
//
// Arguments:
//
//     LPCTSTR szFormat         - Formatting string describing the output
//
//     Variable argument list   - Data to be placed in the output string
//
// Return Value:
//
//     None.
//
//******************************************************************************
void DebugString(LPCTSTR szFormat, ...) {

    TCHAR       szBuffer[2048];
    va_list     vl;

    _tcscpy(szBuffer, TEXT("D3DAPP: "));

    va_start(vl, szFormat);
#ifdef UNDER_CE
    wvsprintf(szBuffer+8, szFormat, vl);
#else
    _vstprintf(szBuffer+8, szFormat, vl);
#endif // DRAGON
    va_end(vl);

    _tcscat(szBuffer, TEXT("\r\n"));

    OutputDebugString(szBuffer);
}

//******************************************************************************
//
// Function:
//
//     ResultFailed
//
// Description:
//
//     Test a given return code: if the code is an error, output a debug 
//     message with the error value.  If the code is a warning, output
//     a debug message with the warning value.
//
// Arguments:
//
//     HRESULT hr               - Return code to test for an error
//
//     LPCTSTR sz               - String describing the method that produced 
//                                the return code
//
// Return Value:
//
//     TRUE if the given return code is an error, FALSE otherwise.
//
//******************************************************************************
BOOL ResultFailed(HRESULT hr, LPCTSTR sz) {

    TCHAR szError[512];

    if (SUCCEEDED(hr)) {
        return FALSE;
    }

    D3DXGetErrorString(hr, szError, 512);

    if (FAILED(hr)) {
        DebugString(TEXT("%s failed with %s [0x%X]"), sz, szError, hr);
        return TRUE;
    }
    else {
        DebugString(TEXT("Warning - %s returned %s [0x%X]"), sz, szError, hr);
    }

    return FALSE;
}
#endif // DEBUG || _DEBUG

//******************************************************************************
// Vertex transformation routine
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     TransformVertices
//
// Description:
//
//     Transform a set of vertices using the current world, view, and projection
//     matrices set in the device. 
//
// Arguments:
//
//     LPDIRECT3DDEVICE7 pd3dd  - Pointer to the device object
//
//     LPVOID pvDst (Out)       - A pointer to the first vertex in the set
//                                that will contain the transformed vertices.
//                                (These vertices must consist of a D3DVECTOR
//                                to contain the position followed by a
//                                float to contain the reciprocal of 
//                                homogeneous w)
//
//     LPVOID pvSrc             - A pointer to the first position vector 
//                                in the set of vertices to be transformed
//
//     DWORD dwNumVertices      - Number of vertices to be transformed
//
//     DWORD dwStrideDst        - Size (in bytes) from one destination vertex
//                                to the next
//
//     DWORD dwStrideSrc        - Size (in bytes) from one source vertex
//                                (position vector) to the next
//
//     LPDWORD pdwClip (Out)    - A pointer to an array of DWORDs which, on
//                                return, will contain clip flags for each of
//                                the transformed vertices
//
// Return Value:
//
//     An HRESULT set to D3D_OK if the transformation is successful, or the error
//     code of the failed method if a failure occurs.
//
//******************************************************************************
/*
HRESULT TransformVertices(LPDIRECT3DDEVICE8 pd3dd, LPVOID pvDst, LPVOID pvSrc, 
                          DWORD dwNumVertices, DWORD dwStrideDst, DWORD dwStrideSrc, 
                          LPDWORD pdwClip) 
{
    D3DMATRIX               mWorld, mView, mProj, mClip, mR1, mR2;
    D3DVIEWPORT7            viewport;
    UINT                    i;
    HRESULT                 hr;
    float                   fW;
    LPBYTE                  pdst, psrc;
    LPD3DVECTOR             prSrc;
    struct _TVERTEX {
        D3DVECTOR v;
        float     fRHW;
    }                       *prDst;

    // Get the viewport dimensions
    memset(&viewport, 0, sizeof(D3DVIEWPORT7));
    hr = pd3dd->GetViewport(&viewport);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetViewport"))) {
        return hr;
    }

    // Build a transformation matrix from the current world, view, and
    // projection matrices

    hr = pd3dd->GetTransform(D3DTRANSFORMSTATE_PROJECTION, &mProj);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetTransform"))) {
        return hr;
    }

    InitMatrix(&mClip,
         0.5f,  0.0f,  0.0f,  0.0f,
         0.0f,  0.5f,  0.0f,  0.0f,
         0.0f,  0.0f,  1.0f,  0.0f,
         0.5f,  0.5f,  0.0f,  1.0f
    );

    MultiplyMatrix(&mR1, &mProj, &mClip);

    hr = pd3dd->GetTransform(D3DTRANSFORMSTATE_VIEW, &mView);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetTransform"))) {
        return hr;
    }

    MultiplyMatrix(&mR2, &mView, &mR1);

    hr = pd3dd->GetTransform(D3DTRANSFORMSTATE_WORLD, &mWorld);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetTransform"))) {
        return hr;
    }

    MultiplyMatrix(&mR1, &mWorld, &mR2);

    // Clear the clipping flags
    if (pdwClip) {
        memset(pdwClip, 0, dwNumVertices * sizeof(DWORD));
    }

    // Apply the transformation matrix to the given vertices
    for (i = 0, pdst = (LPBYTE)pvDst, psrc = (LPBYTE)pvSrc; 
         i < dwNumVertices; 
         i++, pdst += dwStrideDst, psrc += dwStrideSrc) 
    {
        prSrc = (LPD3DVECTOR)psrc;
        prDst = (struct _TVERTEX*)pdst;

        // Calculate the homogeneous coordinates
        fW = mR1._14 * prSrc->x + mR1._24 * prSrc->y + mR1._34 * prSrc->z + mR1._44;
        prDst->fRHW = 1.0f / fW;
        prDst->v.x = (prSrc->x * mR1._11 + prSrc->y * mR1._21 + prSrc->z * mR1._31 + mR1._41) * prDst->fRHW;
        prDst->v.y = (prSrc->x * mR1._12 + prSrc->y * mR1._22 + prSrc->z * mR1._32 + mR1._42) * prDst->fRHW;
        prDst->v.z = (prSrc->x * mR1._13 + prSrc->y * mR1._23 + prSrc->z * mR1._33 + mR1._43) * prDst->fRHW;

        // Clip test the coordinates
        if (pdwClip) {
            pdwClip[i] |= (prDst->v.x > 0.0f) ? 0 : D3DCLIP_LEFT;
            pdwClip[i] |= (prDst->v.x < fW)   ? 0 : D3DCLIP_RIGHT;
            pdwClip[i] |= (prDst->v.y > 0.0f) ? 0 : D3DCLIP_BOTTOM;
            pdwClip[i] |= (prDst->v.y < fW)   ? 0 : D3DCLIP_TOP;
            pdwClip[i] |= (prDst->v.z > 0.0f) ? 0 : D3DCLIP_FRONT;
            pdwClip[i] |= (prDst->v.z < fW)   ? 0 : D3DCLIP_BACK;
        }

        // Scale and offset x and y into screen coordinates
        prDst->v.x = prDst->v.x *  (float)viewport.dwWidth  + (float)viewport.dwX;
        prDst->v.y = prDst->v.y * -(float)viewport.dwHeight + (float)viewport.dwHeight + (float)viewport.dwY;
    }

    return hr;
}
*/

//******************************************************************************
// Memory allocation routines
//******************************************************************************

//******************************************************************************
BOOL CreateHeap() {

    if (g_hHeap) {
        return FALSE;
    }

    g_hHeap = HeapCreate(0, 0, 0);
    if (!g_hHeap) {
        DebugString(TEXT("HeapCreate failed [%d]"), GetLastError());
        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
void ReleaseHeap() {

    if (g_hHeap) {
        if (!HeapDestroy(g_hHeap)) {
            DebugString(TEXT("HeapDestroy failed [%d]"), GetLastError());
        }
        g_hHeap = NULL;
    }
}

//******************************************************************************
LPVOID MemAlloc(UINT uNumBytes) {

    LPVOID pvMem = NULL;
    if (g_hHeap) {
        pvMem = HeapAlloc(g_hHeap, 0, uNumBytes);
    }
    return pvMem;
}

//******************************************************************************
void MemFree(LPVOID pvMem) {

    if (g_hHeap) {
        if (!HeapFree(g_hHeap, 0, pvMem)) {
            DebugString(TEXT("HeapFree failed [%d]"), GetLastError());
        }
    }
}

//******************************************************************************
//
// Function:
//
//     MemAlloc32
//
// Description:
//
//     Allocate a given amount of memory whose base address is
//     aligned along a 32 byte boundary.  This memory must later be freed
//     using the MemFree32 function.
//
// Arguments:
//
//     UINT uNumBytes           - Number of bytes to allocate
//
// Return Value:
//
//     Base address of the allocated memory.
//
//******************************************************************************
LPVOID MemAlloc32(UINT uNumBytes)
{
	LPBYTE pbyAllocated, pbyAligned = NULL;

	pbyAllocated = (LPBYTE)MemAlloc(uNumBytes + 32);
    if (pbyAllocated) {
	    pbyAligned   = (LPBYTE)((((DWORD)pbyAllocated) + 32) & ~31);
	    *(((LPDWORD)pbyAligned)-1) = (DWORD)pbyAllocated;
    }
	return pbyAligned;
}

//******************************************************************************
//
// Function:
//
//     MemFree32
//
// Description:
//
//     Free an aligned block of memory that was allocated using the MemAlloc32
//     function.
//
// Arguments:
//
//     LPVOID pvAligned         - Base address of the aligned memory
//
// Return Value:
//
//     None.
//
//******************************************************************************
void MemFree32(LPVOID pvMem)
{
	LPBYTE pbyFree;

    if (pvMem) {
	    pbyFree = (LPBYTE)*(((LPDWORD)pvMem)-1);
	    MemFree(pbyFree);
    }
}

//******************************************************************************
// Matrix utility functions
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     InitMatrix
//
// Description:
//
//     Initialize the given matrix with the given values.
//
// Arguments:
//
//     LPD3DMATRIX pd3dm        - Matrix to initialize
//
//     float _11 to _44         - Initialization values
//
// Return Value:
//
//     None.
//
//******************************************************************************
void InitMatrix(LPD3DMATRIX pd3dm,
                float _11, float _12, float _13, float _14,
                float _21, float _22, float _23, float _24,
                float _31, float _32, float _33, float _34,
                float _41, float _42, float _43, float _44) 
{
    if (pd3dm) {

        pd3dm->_11 = _11;
        pd3dm->_12 = _12;
        pd3dm->_13 = _13;
        pd3dm->_14 = _14;
        pd3dm->_21 = _21;
        pd3dm->_22 = _22;
        pd3dm->_23 = _23;
        pd3dm->_24 = _24;
        pd3dm->_31 = _31;
        pd3dm->_32 = _32;
        pd3dm->_33 = _33;
        pd3dm->_34 = _34;
        pd3dm->_41 = _41;
        pd3dm->_42 = _42;
        pd3dm->_43 = _43;
        pd3dm->_44 = _44;
    }
}

//******************************************************************************
//
// Function:
//
//     SetView
//
// Description:
//
//     Align the given view matrix along the given direction and up vectors with
//     the position vector as the origin.
//
// Arguments:
//
//     LPD3DXMATRIX pd3dm       - View matrix to initialize
//
//     LPD3DXVECTOR3 pvPos      - View origin
//
//     LPD3DXVECTOR3 pvAt       - View interest vector
//
//     LPD3DXVECTOR3 pvUp       - View up vector
//
// Return Value:
//
//     Initialized view matrix.
//
//******************************************************************************
void SetView(LPD3DXMATRIX pd3dm, LPD3DXVECTOR3 pvPos, LPD3DXVECTOR3 pvAt, 
                                                      LPD3DXVECTOR3 pvUp) 
{
    D3DXVECTOR3  d, u, r;

    if (pd3dm && pvPos && pvAt && pvUp && !(*pvPos == *pvAt) 
                                 && !(*pvUp == D3DXVECTOR3(0.0f, 0.0f, 0.0f))) {

        D3DXVec3Normalize(&d, &(*pvAt - *pvPos));
        u = *pvUp;

        // Project the up vector into the plane of the direction vector
        D3DXVec3Normalize(&u, &(u - (d * D3DXVec3Dot(&u, &d))));

        // Get the cross product
        D3DXVec3Cross(&r, &u, &d);

        // Initialize the view transform
        InitMatrix(pd3dm,
            r.x, u.x, d.x, 0.0f,
            r.y, u.y, d.y, 0.0f,
            r.z, u.z, d.z, 0.0f,
            -(pvPos->x * r.x + pvPos->y * r.y + pvPos->z * r.z), 
            -(pvPos->x * u.x + pvPos->y * u.y + pvPos->z * u.z), 
            -(pvPos->x * d.x + pvPos->y * d.y + pvPos->z * d.z), 
            1.0f
        );
    }
}

//******************************************************************************
//
// Function:
//
//     SetPerspectiveProjection
//
// Description:
//
//     Initialize the given projection matrix using the given front and back
//     clipping planes, field of view, and aspect ratio.
//
// Arguments:
//
//     LPD3DMATRIX pd3dm        - Projection matrix to initialize
//
//     float fFront             - Front clipping plane
//
//     float fBack              - Back clipping plane
//
//     float fFieldOfView       - Angle, in radians, of the field of view
//
//     float fAspect            - Aspect ratio (y / x) of the view plane
//
// Return Value:
//
//     Initialized projection matrix.
//
//******************************************************************************
void SetPerspectiveProjection(LPD3DMATRIX pd3dm, float fFront, float fBack, 
                                    float fFieldOfView, float fAspect) {

    float fTanHalfFOV = (float)tan((double)fFieldOfView / 2.0);
    float fFar = fBack / (fBack - fFront);

    InitMatrix(pd3dm,
        1.0f, 0.0f,           0.0f,                         0.0f,
        0.0f, 1.0f / fAspect, 0.0f,                         0.0f,
        0.0f, 0.0f,           fTanHalfFOV * fFar,           fTanHalfFOV,
        0.0f, 0.0f,           -fFront * fTanHalfFOV * fFar, 0.0f
    );
}

//******************************************************************************
//
// Function:
//
//     SetParallelProjection
//
// Description:
//
//     Initialize the given projection matrix using the given front and back
//     clipping planes, field of view, and aspect ratio.
//
// Arguments:
//
//     LPD3DMATRIX pd3dm        - Projection matrix to initialize
//
//     float fFront             - Front clipping plane
//
//     float fBack              - Back clipping plane
//
//     float fFieldOfView       - Angle, in radians, of the field of view
//
//     float fAspect            - Aspect ratio (y / x) of the view plane
//
// Return Value:
//
//     Initialized projection matrix.
//
//******************************************************************************
void SetParallelProjection(LPD3DMATRIX pd3dm, float fFront, float fBack, 
                                    float fFieldOfView, float fAspect) {

//    float    f2FOV = fFieldOfView + fFieldOfView;
//    float    fFar = fBack - fFront;

    InitMatrix(pd3dm,
        1.0f, 0.0f, 0.0f,   0.0f,
        0.0f, 1.0f, 0.0f,   0.0f,
        0.0f, 0.0f, 0.001f, 0.0f,
        0.0f, 0.0f, 0.5f,   1.0f
    );
/*
    InitMatrix(pd3dm,
        2.0f / f2FOV, 0.0f, 0.0f, 0.0f,
        0.0f, 2.0f / f2FOV, 0.0f, 0.0f,
        0.0f, 0.0f, 1.0f / fFar, 0.0f,
        0.0f, 0.0f, -fFront / fFar, 1.0f
    );
*/
}

} // namespace DXCONIO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\util.h ===
/*******************************************************************************

Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

File Name:

    util.h

Description:

    Utility functions.

*******************************************************************************/

#ifndef __UTIL_H__
#define __UTIL_H__

#ifndef LPD3DMATRIX
#define LPD3DMATRIX D3DMATRIX*
#endif

//******************************************************************************
// Precomputed fractions of pi
//******************************************************************************

#define M_PI        3.14159265359f
#define M_2PI       6.28318530718f
#define M_PIDIV2    1.57079632680f
#define M_3PIDIV2   4.71238898039f
#define M_PIDIV4    0.78539816340f
#define M_3PIDIV4   2.35619449019f
#define M_5PIDIV4   3.92699081699f
#define M_7PIDIV4   5.49778714378f

//******************************************************************************
// Macros
//******************************************************************************

#define RND()       ((float)rand() / (float)RAND_MAX)
#define FRND(x)     (RND() * x)
#define FABS(x)     (x < 0.0f ? -x : x)

#ifndef RGB_MAKE
/*
 * Format of CI colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |         color index           |   fraction    |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define CI_GETALPHA(ci)    ((ci) >> 24)
#define CI_GETINDEX(ci)    (((ci) >> 8) & 0xffff)
#define CI_GETFRACTION(ci) ((ci) & 0xff)
#define CI_ROUNDINDEX(ci)  CI_GETINDEX((ci) + 0x80)
#define CI_MASKALPHA(ci)   ((ci) & 0xffffff)
#define CI_MAKE(a, i, f)    (((a) << 24) | ((i) << 8) | (f))

/*
 * Format of RGBA colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGBA_GETALPHA(rgb)      ((rgb) >> 24)
#define RGBA_GETRED(rgb)        (((rgb) >> 16) & 0xff)
#define RGBA_GETGREEN(rgb)      (((rgb) >> 8) & 0xff)
#define RGBA_GETBLUE(rgb)       ((rgb) & 0xff)
#define RGBA_MAKE(r, g, b, a)   ((D3DCOLOR) (((a) << 24) | ((r) << 16) | ((g) << 8) | (b)))

/* D3DRGB and D3DRGBA may be used as initialisers for D3DCOLORs
 * The float values must be in the range 0..1
 */
#define D3DRGB(r, g, b) \
    (0xff000000L | ( ((long)((r) * 255)) << 16) | (((long)((g) * 255)) << 8) | (long)((b) * 255))
#define D3DRGBA(r, g, b, a) \
    (   (((long)((a) * 255)) << 24) | (((long)((r) * 255)) << 16) \
    |   (((long)((g) * 255)) << 8) | (long)((b) * 255) \
    )

/*
 * Format of RGB colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    ignored    |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGB_GETRED(rgb)         (((rgb) >> 16) & 0xff)
#define RGB_GETGREEN(rgb)       (((rgb) >> 8) & 0xff)
#define RGB_GETBLUE(rgb)        ((rgb) & 0xff)
#define RGBA_SETALPHA(rgba, x) (((x) << 24) | ((rgba) & 0x00ffffff))
#define RGB_MAKE(r, g, b)       ((D3DCOLOR) (((r) << 16) | ((g) << 8) | (b)))
#define RGBA_TORGB(rgba)       ((D3DCOLOR) ((rgba) & 0xffffff))
#define RGB_TORGBA(rgb)        ((D3DCOLOR) ((rgb) | 0xff000000))

#endif

namespace DXCONIO {

//******************************************************************************
// Debugging function prototypes
//******************************************************************************

#if defined(DEBUG) || defined(_DEBUG)
void                DebugString(LPCTSTR szFormat, ...);
BOOL                ResultFailed(HRESULT hr, LPCTSTR sz);
#else
inline void         DebugString(LPCTSTR szFormat, ...) {}
inline BOOL         ResultFailed(HRESULT hr, LPCTSTR sz) {return FALSE;};
#endif

//******************************************************************************
// Vertex transformation routine
//******************************************************************************
/*
HRESULT TransformVertices(LPDIRECT3DDEVICE8 pd3dd, LPVOID pvDst, LPVOID pvSrc, 
                        DWORD dwNumVertices, 
                        DWORD dwStrideDst = sizeof(D3DTLVERTEX), 
                        DWORD dwStrideSrc = sizeof(D3DVERTEX), 
                        LPDWORD pdwClip = NULL);
*/
//******************************************************************************
// Memory allocation prototypes
//******************************************************************************

BOOL                CreateHeap();
void                ReleaseHeap();
LPVOID              MemAlloc(UINT uNumBytes);
void                MemFree(LPVOID pvMem);
LPVOID              MemAlloc32(UINT uNumBytes);
void                MemFree32(LPVOID pvMem);

//******************************************************************************
// Matrix utility function prototypes
//******************************************************************************

void                InitMatrix(LPD3DMATRIX pd3dm,
                        float _11, float _12, float _13, float _14,
                        float _21, float _22, float _23, float _24,
                        float _31, float _32, float _33, float _34,
                        float _41, float _42, float _43, float _44);

void                SetView(LPD3DXMATRIX pd3dm, LPD3DXVECTOR3 pvPos, 
                        LPD3DXVECTOR3 pvAt, LPD3DXVECTOR3 pvUp);

void                SetPerspectiveProjection(LPD3DMATRIX pd3dm, float fFront, 
                        float fBack, float fFieldOfView, float fAspect);

void                SetParallelProjection(LPD3DMATRIX pd3dm, float fFront, 
                        float fBack, float fFieldOfView, float fAspect);

//******************************************************************************
// Miscellaneous functions
//******************************************************************************

inline DWORD        F2DW(float f) {return *((LPDWORD)&f);}

} // namespace DXCONIO

#endif // __UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\framework\framework.cpp ===
#include <xtl.h>
//------------------------------------------------------------------------------
//	Global Variables:
//------------------------------------------------------------------------------
HANDLE g_hLog = NULL;
LPSTR g_szComponent = NULL;
LPSTR g_szSubComp = NULL;
LPSTR g_szFunction = NULL;
LPSTR g_szVariation = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\vrttypes.h ===
/*******************************************************************************

Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

File Name:

    vrttypes.h

Description:

    Various vertex type definitions.

*******************************************************************************/

#ifndef __VRTTYPES_H__
#define __VRTTYPES_H__

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#define FVF_VERTEX              (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1)
#define FVF_BVERTEX             (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX2)
#define FVF_LVERTEX             (D3DFVF_XYZ | D3DFVF_DIFFUSE | \
                                 D3DFVF_SPECULAR | D3DFVF_TEX1)
#define FVF_TLVERTEX            (D3DFVF_XYZRHW | D3DFVF_DIFFUSE | \
                                 D3DFVF_SPECULAR | D3DFVF_TEX1)
#define FVF_TLBVERTEX           (D3DFVF_XYZRHW | D3DFVF_DIFFUSE | \
                                 D3DFVF_SPECULAR | D3DFVF_TEX2)

namespace DXCONIO {

//******************************************************************************
// Structures
//******************************************************************************

//******************************************************************************
typedef struct _VERTEX {
    D3DXVECTOR3 vPosition;
    D3DXVECTOR3 vNormal;
    float       u0, v0;

    _VERTEX() {}
    _VERTEX(const D3DVECTOR& v, const D3DVECTOR& n, float _u0, float _v0) { 
        vPosition.x = v.x; vPosition.y = v.y; vPosition.z = v.z;
        vNormal.x = n.x; vNormal.y = n.y; vNormal.z = n.z;
        u0 = _u0; v0 = _v0;
    }
} VERTEX, *PVERTEX;

//******************************************************************************
typedef struct _BVERTEX {
    D3DXVECTOR3 vPosition;
    D3DXVECTOR3 vNormal;
    float       u0, v0;
    float       u1, v1;

    _BVERTEX() {}
    _BVERTEX(const D3DVECTOR& v, const D3DVECTOR& n, float _u0, float _v0, float _u1, float _v1) { 
        vPosition.x = v.x; vPosition.y = v.y; vPosition.z = v.z;
        vNormal.x = n.x; vNormal.y = n.y; vNormal.z = n.z;
        u0 = _u0; v0 = _v0; u1 = _u1; v1 = _v1;
    }
} BVERTEX, *PBVERTEX;

//******************************************************************************
typedef struct _LVERTEX {
    D3DXVECTOR3 vPosition;
    D3DCOLOR    cDiffuse;
    D3DCOLOR    cSpecular;
    float       u0, v0;

    _LVERTEX() { }
    _LVERTEX(const D3DVECTOR& v, D3DCOLOR _cDiffuse, D3DCOLOR _cSpecular, float _u0, float _v0) { 
        vPosition.x = v.x; vPosition.y = v.y; vPosition.z = v.z;
        cDiffuse = _cDiffuse; cSpecular = _cSpecular;
        u0 = _u0; v0 = _v0;
    }
} LVERTEX, *PLVERTEX;

//******************************************************************************
typedef struct _TLVERTEX {
    D3DXVECTOR3 vPosition;
    float       fRHW;
    D3DCOLOR    cDiffuse;
    D3DCOLOR    cSpecular;
    float       u0, v0;

    _TLVERTEX() {}
    _TLVERTEX(const D3DVECTOR& v, float _fRHW, D3DCOLOR _cDiffuse, 
              D3DCOLOR _cSpecular, float _u0, float _v0) 
    { 
        vPosition.x = v.x; vPosition.y = v.y; vPosition.z = v.z; fRHW = _fRHW;
        cDiffuse = _cDiffuse; cSpecular = _cSpecular;
        u0 = _u0; v0 = _v0;
    }
} TLVERTEX, *PTLVERTEX;

//******************************************************************************
typedef struct _TLBVERTEX {
    D3DXVECTOR3 vPosition;
    float       fRHW;
    D3DCOLOR    cDiffuse;
    D3DCOLOR    cSpecular;
    float       u0, v0;
    float       u1, v1;

    _TLBVERTEX() {}
    _TLBVERTEX(const D3DVECTOR& v, float _fRHW, D3DCOLOR _cDiffuse, 
              D3DCOLOR _cSpecular, float _u0, float _v0, float _u1, float _v1) 
    { 
        vPosition.x = v.x; vPosition.y = v.y; vPosition.z = v.z; fRHW = _fRHW;
        cDiffuse = _cDiffuse; cSpecular = _cSpecular;
        u0 = _u0; v0 = _v0; u1 = _u1; v1 = _v1;
    }
} TLBVERTEX, *PTLBVERTEX;

} // namespace DXCONIO

#endif //__VRTTYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\dxconio\test\main.cpp ===
#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "dxconio.h"

#define countof(x)      (sizeof(x) / sizeof(*(x)))

static LPTSTR g_pszText[] = {

    {TEXT("The Masque of the Red Death")},
    {TEXT("")},
    {TEXT("by Edgar Allan Poe (1842)")},
    {TEXT("")},
    {TEXT("The 'RED DEATH' had long devastated the country. No pestilence had ever been ")},
    {TEXT("so fatal or so hideous. Blood was its Avatar and its seal--the redness and the ")},
    {TEXT("horror of blood. There were sharp pains, and sudden dizziness, and then profuse ")},
    {TEXT("bleeding at the pores, with dissolution. The scarlet stains upon the body, and ")},
    {TEXT("especially upon the face of the victim, were the pest ban which shut him out ")},
    {TEXT("from the aid and from the sympathy of his fellow-men; and the whole seizure, ")},
    {TEXT("progress, and termination of the disease, were the incidents of half-an-hour. ")},
    {TEXT("")},
    {TEXT("But Prince Prospero was happy and hauntless and sagacious. When his dominions ")},
    {TEXT("were half-depopulated, he summoned to his presence a thousand hale and light-")},
    {TEXT("hearted friends from among the knights and dames of his court, and with these ")},
    {TEXT("retired to the deep seclusion of one of his castellated abbeys. This was an ")},
    {TEXT("extensive and magnificent structure, the creation of the prince's own ")},
    {TEXT("eccentric yet august taste. A strange and lofty wall girdled it in. This wall ")},
    {TEXT("had gates of iron. The courtiers, having entered, brought furnaces and massy ")},
    {TEXT("hammers and welded the bolts. They resolved to leave means neither of ingress ")},
    {TEXT("or egress to the sudden impulses of despair from without or of frenzy from ")},
    {TEXT("within. The abbey was amply provisioned. With such precautions the courtiers ")},
    {TEXT("might bid defiance to contagion. The external world could take care of itself. ")},
    {TEXT("In the meantime it was folly to grieve or to think. The prince had provided ")},
    {TEXT("all the appliances of pleasure. There were buffoons, there were improvisatori, ")},
    {TEXT("there were ballet dancers, there were musicians, there was beauty, there was ")},
    {TEXT("wine. All these and security were within. Without was the 'Red Death.' ")},
    {TEXT("")},
    {TEXT("It was toward the close of the fifth or sixth month of his seclusion, and ")},
    {TEXT("while the pestilence raged most furiously abroad, that the Prince Prospero ")},
    {TEXT("entertained his thousand friends at a masked ball of the most unusual ")},
    {TEXT("magnificence. ")},
    {TEXT("")},
    {TEXT("It was a voluptuous scene that masquerade. But first let me tell of the rooms ")},
    {TEXT("in which it was held. There were seven--an imperial suite. In many places, ")},
    {TEXT("however, such suites form a long and straight vista, while the folding doors ")},
    {TEXT("slide back nearly to the walls on either hand, so that the view of the whole ")},
    {TEXT("extent is scarcely impeded. Here the case was very different, as might have ")},
    {TEXT("been expected from the duke's love of the bizarre. The apartments were so ")},
    {TEXT("irregularly disposed that the vision embraced but little more than one at a ")},
    {TEXT("time. There was a sharp turn at every twenty or thirty yards, and at each turn ")},
    {TEXT("a novel effect. To the right and left, in the middle of each wall, a tall and ")},
    {TEXT("narrow Gothic window looked out upon a closed corridor which pursued the ")},
    {TEXT("windings of the suite. These windows were of stained glass whose colour varied ")},
    {TEXT("in accordance with the prevailing hue of the decorations of the chamber into ")},
    {TEXT("which it opened. That at the eastern extremity was hung, for example, in blue, ")},
    {TEXT("and vividly blue were its windows. The second chamber was purple in its ")},
    {TEXT("ornaments and tapestries, and here the panes were purple. The third was green ")},
    {TEXT("throughout, and so were the casements. The fourth was furnished and lighted ")},
    {TEXT("with orange, the fifth with white, the sixth with violet. The seventh apartment ")},
    {TEXT("was closely shrouded in black velvet tapestries that hung all over the ceiling ")},
    {TEXT("and down the walls, falling in heavy folds upon a carpet of the same material ")},
    {TEXT("and hue. But in this chamber only the colour of the windows failed to ")},
    {TEXT("correspond with the decorations. The panes here were scarlet--a deep blood-")},
    {TEXT("colour. Now in no one of the seven apartments was there any lamp or candelabrum ")},
    {TEXT("amid the profusion of golden ornaments that lay scattered to and from or ")},
    {TEXT("depended from the roof. There was no light of any kind emanating from lamp or ")},
    {TEXT("candle within the suite of chambers; but in the corridors that followed the ")},
    {TEXT("suite there stood opposite to each window a heavy tripod bearing a brazier of ")},
    {TEXT("fire that projected its rays through the tinted glass and so glaringly ")},
    {TEXT("illumined the room. And thus were produced a multitude of gaudy and fantastic ")},
    {TEXT("appearances. But in the western or black chamber the effect of the firelight ")},
    {TEXT("that streamed upon the dark hangings, through the blood-tinted panes, was ")},
    {TEXT("ghastly in the extreme, and produced so wild a look upon the countenances of ")},
    {TEXT("those who entered that there were few of the company bold enough to set foot ")},
    {TEXT("within its precincts at all. ")},
    {TEXT("")},
    {TEXT("It was in this apartment also that there stood against the western wall a ")},
    {TEXT("gigantic clock of ebony. Its pendulum swung to and fro with a dull, heavy, ")},
    {TEXT("monotonous clang; and when the minute-hand made the circuit of the face, ")},
    {TEXT("and the hour was to be stricken, there came from the brazen lungs of the ")},
    {TEXT("clock a sound which was clear and loud, and deep, and exceedingly musical, ")},
    {TEXT("but of so peculiar a note and emphasis that, at each lapse of an hour, the ")},
    {TEXT("musicians of the orchestra were constrained to pause momentarily in their ")},
    {TEXT("performance to hearken to the sound; and thus the waltzers perforce ceased ")},
    {TEXT("their evolutions, and there was a brief disconcert of the whole gay company, ")},
    {TEXT("and while the chimes of the clock yet rang it was observed that the giddiest ")},
    {TEXT("grew pale, and the more aged and sedate passed their hands over their brows as ")},
    {TEXT("if in confused reverie or meditation; but when the echoes had fully ceased a ")},
    {TEXT("light laughter at once pervaded the assembly; the musicians looked at each ")},
    {TEXT("other and smiled as if at their own nervousness and folly and made whispering ")},
    {TEXT("vows each to the other that the next chiming of the clock should produce in ")},
    {TEXT("them no similar emotion, and then, after the lapse of sixty minutes (which ")},
    {TEXT("embrace three thousand and six hundred seconds of the time that flies), there ")},
    {TEXT("came yet another chiming of the clock, and then were the same disconcert and ")},
    {TEXT("tremulousness and meditation as before. ")},
    {TEXT("")},
    {TEXT("But in spite of these things it was a gay and magnificent revel. The tastes of ")},
    {TEXT("the duke were peculiar. He had a fine eye for colours and effects. He ")},
    {TEXT("disregarded the decora of mere fashion. His plans were bold and fiery, and his ")},
    {TEXT("conceptions glowed with barbaric luster. There are some who would have thought ")},
    {TEXT("him mad. His followers felt that he was not. It was necessary to hear, and see, ")},
    {TEXT("and touch him to be sure that he was not. ")},
    {TEXT("")},
    {TEXT("He had directed, in great part, the moveable embellishments of the seven ")},
    {TEXT("chambers, upon occasion of this great fete; and its was his own guiding taste ")},
    {TEXT("which had given character to the masqueraders. Be sure they were grotesque. ")},
    {TEXT("There were much glare and glitter and piquancy and phantasm--much of what has ")},
    {TEXT("been since see in 'Hernani.' There were arabesque figures with unsuited limbs ")},
    {TEXT("and appointments. There were delirious fancies such as the madman fashions. ")},
    {TEXT("There were much of the beautiful, much of the wanton, much of the bizarre, ")},
    {TEXT("something of the terrible, and not a little of that which might excited ")},
    {TEXT("disgust. To and from in the seven chambers there stalked, in fact, a multitude ")},
    {TEXT("of dreams. And these--the dreams--writhed in and about, taking hue from the ")},
    {TEXT("rooms, and causing the wild music of the orchestra to seem as the echo of their ")},
    {TEXT("steps. And, anon, there strikes the ebony clock which stands in the hall of the ")},
    {TEXT("velvet; and then, for a moment, all is still, and all is silent save the voice ")},
    {TEXT("of the clock. The dreams are stiff-frozen as they stand. But the echoes of the ")},
    {TEXT("chime die away--they have endured but an instant--and a light, half-subdued ")},
    {TEXT("laughter floats after them as they depart. And now again the music swells, and ")},
    {TEXT("the dreams live, and writhe to and fro more merrily than ever, taking hue from ")},
    {TEXT("the many tinted windows through which stream the rays from the tripods. But to ")},
    {TEXT("the chamber which lies most eastwardly of the seven, there are now none of the ")},
    {TEXT("maskers who venture; for the night is waning away; and there flows a ruddier ")},
    {TEXT("light through the blood-coloured panes; and the blackness of the sable drapery ")},
    {TEXT("appalls; and to him whose foot falls upon the sable carpet, there comes from ")},
    {TEXT("the near clock of ebony a muffled peal more solemnly emphatic than any which ")},
    {TEXT("reaches their ears who indulge in the more remote gaieties of the other ")},
    {TEXT("apartments. ")},
    {TEXT("")},
    {TEXT("But these other apartments were densely crowded, and in them beat feverishly ")},
    {TEXT("the heart of life. And the revel went whirlingly on, until at length there ")},
    {TEXT("commenced the sounding of midnight upon the clock. And then the music ceased, ")},
    {TEXT("as I have told; and the evolutions of the waltzers were quieted; and there was ")},
    {TEXT("an uneasy cessation of all things as before. But now there were twelve strokes ")},
    {TEXT("to be sounded by the bell of the clock; and thus it happened, perhaps that more ")},
    {TEXT("of thought crept, with more of time, into the meditations of the thoughtful ")},
    {TEXT("among those who reveled. And thus, too, it happened, perhaps, that before the ")},
    {TEXT("last echoes of the last chime had utterly sunk into silence, there were many ")},
    {TEXT("individuals in the crowd who had found leisure to became aware of the presence ")},
    {TEXT("of a masked figure which had arrested the attention of no single individual ")},
    {TEXT("before. And the rumour of this new presence having spread itself whisperingly ")},
    {TEXT("around, there arose at length from the whole company a buzz, or murmur, ")},
    {TEXT("expressive of disapprobation and surprise--then, finally, of terror, of horror, ")},
    {TEXT("and of disgust. ")},
    {TEXT("")},
    {TEXT("In an assembly of phantasms such as I have painted, it may well be supposed ")},
    {TEXT("that no ordinary appearance could have excited such sensation. In truth the ")},
    {TEXT("masquerade licence of the night was nearly unlimited; but the figure in ")},
    {TEXT("question had out-Heroded Herod, and gone beyond the bounds of even the most ")},
    {TEXT("reckless which cannot be touched without emotion. Even with the utterly lost, ")},
    {TEXT("to whom life and death are equally jests, there are matters of which no jest ")},
    {TEXT("can be made. The whole company indeed seemed now deeply to feel that in the ")},
    {TEXT("costume and bearing of the stranger neither wit nor propriety existed. The ")},
    {TEXT("figure was tall and gaunt, and shrouded from head to foot in the habiliments ")},
    {TEXT("of the grave. The mask which concealed the visage was made so nearly to ")},
    {TEXT("resemble the countenance of a stiffened corpse that the closest scrutiny must ")},
    {TEXT("have had difficulty in detecting the cheat. And yet all this might have been ")},
    {TEXT("endured, if not approved, by the mad revellers around. But the mummer had ")},
    {TEXT("gone so far as to assume the type of the Red Death. His vesture was dabbled ")},
    {TEXT("in blood--and his broad brow with all the features of the face, was ")},
    {TEXT("besprinkled with the scarlet horror. ")},
    {TEXT("")},
    {TEXT("When the eyes of Prince Prospero fell upon this spectral image (which with a ")},
    {TEXT("slow and solemn movement, as if more fully to sustain its rle, stalked to and ")},
    {TEXT("from among the waltzers) he was seen to be convulsed in the first moment with ")},
    {TEXT("a strong shudder either of terror or distaste; but in the next his brow ")},
    {TEXT("reddened with rage. ")},
    {TEXT("")},
    {TEXT("'Who dares?' he demanded hoarsely of the courtiers who stood near him-- 'who ")},
    {TEXT("dares insult us with this blasphemous mockery? Seize him and unmask him, that ")},
    {TEXT("we may know whom we have to hang at sunrise from the battlements!' ")},
    {TEXT("")},
    {TEXT("It was in the eastern or blue chamber in which stood the Prince Prospero as he ")},
    {TEXT("uttered these words. They rang throughout the seven rooms loudly and clearly--")},
    {TEXT("for the prince was a bold and robust man, and the music had become hushed at ")},
    {TEXT("the waving of his hand. ")},
    {TEXT("")},
    {TEXT("It was in the blue room where stood the prince, with a group of pale courtiers ")},
    {TEXT("by his side. At first, as he spoke, there was a slight rushing movement of this ")},
    {TEXT("group in the direction of the intruder, who, at the moment was also near at ")},
    {TEXT("hand, and now, with deliberate and stately step, made closer approach to the ")},
    {TEXT("speaker. But, from a certain nameless awe with which the mad assumptions of the ")},
    {TEXT("mummer had inspired the whole party, there were found none who put forth hand ")},
    {TEXT("to seize him; so that unimpeded he passed within a yard of the prince's person; ")},
    {TEXT("and while the vast assembly, as if with one impulse, shrank from the centres ")},
    {TEXT("of the rooms to the walls, he made his way uninterruptedly, but with the same ")},
    {TEXT("solemn and measured step which had distinguished him from the first, through ")},
    {TEXT("the blue chamber to the purple--through the purple to the green--through the ")},
    {TEXT("green to the orange--through this again to the white--and even thence to the ")},
    {TEXT("velvet, ere a decided movement had been made to arrest him. It was then, ")},
    {TEXT("however, that Prince Prospero, maddening with rage and the shame of his own ")},
    {TEXT("momentary cowardice, rushed hurriedly through the sib chambers, while none ")},
    {TEXT("followed him on account of a deadly terror that had seized upon all. He bore ")},
    {TEXT("aloft a drawn dagger, and had approached in rapid impetuosity, to within three ")},
    {TEXT("or four feet of the retreating figure, when the latter, having attained the ")},
    {TEXT("extremity of the velvet apartment, turned suddenly and confronted his pursuer. ")},
    {TEXT("There was a sharp cry--and the dagger dropped gleaming upon the sable carpet, ")},
    {TEXT("upon which, instantly afterwards, fell prostrate in death the Prince Prospero. ")},
    {TEXT("Then summoning the wild courage of despair, a throng of the revellers at once ")},
    {TEXT("threw themselves into the black apartment, and, seizing the mummer, whose tall ")},
    {TEXT("figure stood erect and motionless within the shadows of the ebony clock, gasped ")},
    {TEXT("in unutterable horror at finding the grave cerements and corpse-like mask which ")},
    {TEXT("they handled with so violent a rudeness, untenanted by any tangible form. ")},
    {TEXT("")},
    {TEXT("And now was acknowledged the presence of the Red Death. He had come like a ")},
    {TEXT("thief in the night; and one by one dropped the revellers in the blood-bedewed ")},
    {TEXT("halls of their revel, and died each in the despairing posture of his fall; and ")},
    {TEXT("the life of the ebony clock went out with that of the last of the gay; and the ")},
    {TEXT("flames of the tripods expired; and darkness and decay and the Red Death held ")},
    {TEXT("illimitable dominion over all. ")},
};

//******************************************************************************
//
// Function:
//
//     main
//
// Description:
//
//     Entry point for the application.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
#ifndef XBOX
int APIENTRY wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR szCmdLine, int nCmdShow) 
#else
void __cdecl main()
#endif
{
    UINT i, len;

    xCreateConsole(NULL);

    // Don't use the default background texture
//    xSetBackgroundImage(NULL);

//    xSetTextColor(68, 255, 68, 255);
//    xSetBackgroundColor(255, 255, 255);
//    xSetDisplayWidth(80);
//    xSetOutputBufferSize(15600);
//    xSetBackgroundImage(TEXT("t:\\texture.bmp"));

    len = countof(g_pszText);

    while (TRUE) {
        for (i = 0; i < len; i++) {
            _tprintf(TEXT("%s\n"), g_pszText[i]);
        }
    }

    xReleaseConsole();

#ifndef XBOX
    return 0;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\gamepusher\PcClient\pcclient.h ===
/*************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

	pcclient.h

  Abstract:

	Defines the PC client side for the GamePusher tool

  Author:

	Mabel Santos (t-msanto) 03-Dec-2001

  Revision History:

*************************************************************************************************/

#ifndef _PCCLIENT_H_
#define _PCCLIENT_H_

#define NTLEANANDMEAN
#define _X86_
#define _WIN32_WINNT 0x0500

#include <windows.h>
#include <winsock2.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdio.h>
#include <stdarg.h>
#include <xboxdbg.h>

#define BUFFLEN 1024

// network packet structures

struct FilePacketHeader
{
	unsigned char PacketType;
	unsigned long SequenceNo;
	unsigned long FileSize;
	unsigned short DataSize;
	unsigned long Crc;
};

struct FilePacket : public FilePacketHeader
{
	char Data[BUFFLEN];
};

struct Xbox
{
	char Name[BUFFLEN];
	int State;
	int Thread;
	Xbox* Next;
};

class PcClient
{
private:
	
	// list of Xboxes
	Xbox* XboxList;
	Xbox* LastXbox;
	
	// socket for network communication
	SOCKET ClientSock;

	// flag to indicate whether WinSock has been initialized
	BOOL WsaInitialized;

	// byte counter
	unsigned long ByteCount;

	// packet counter
	unsigned long PacketCount;

public:
	PcClient(void);
	~PcClient(void);
	BOOL PrepareWinSock(void);
	BOOL PrepareXboxes(void);	
	BOOL CheckExclList(char* List, char* Name);
	BOOL GetTotalBytes(void);
	void GetFileBytes(char* File);
	BOOL SendQuery(int QueryType);
	BOOL SendFiles(void);
	BOOL SendFile(char* FileName);
	BOOL SendFinishMsg(void);
	void RebootXboxes(void);	
	void ReportResults(void);
	BOOL SendPacket(BYTE PacketType, DWORD FileSize, WORD DataSize, char* Data);
	DWORD GetCRC(unsigned char* Data, WORD Size);
	void AddXbox(char* Name, int Thread);
	void SetXboxState(char* Name, int State);
	void GetXboxes(int State);
	void ClearXboxes(void);
	
	friend DWORD WINAPI PrepareXboxThread(void* ClientPtr);
	friend DWORD WINAPI RebootXboxThread(void* ClientPtr);

};

struct ThreadParam 
{
	PcClient* Client;
	int ThreadNum;
};

void StringTrim(char* String);
void LogPrint(char* Format, ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\gamepusher\XbServer\mapdrives.cpp ===
/*****************************************************************************

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    mapdrives.cpp

	Derived from \private\test\ui\tools\memoryareas\memoryarea.cpp

	Author: Jim Helm (jimhelm)

Abstract:

    Defines functions needed to map Xbox hard disk partitions to drive 
	letters.

*****************************************************************************/

#include "xbserver.h"

extern "C"
    {
	NTSYSCALLAPI
	NTSTATUS
	NTAPI
	IoCreateSymbolicLink(
		IN POBJECT_STRING SymbolicLinkName,
		IN POBJECT_STRING DeviceName
		);

	NTSYSCALLAPI
	NTSTATUS
	NTAPI
	IoDeleteSymbolicLink(
		IN POBJECT_STRING SymbolicLinkName
		);
    }

DWORD MapDrive( char cDriveLetter, char* pszPartition )
{
    char pszDrive[20];
    ZeroMemory( pszDrive, 20 );
 
    sprintf( pszDrive, "\\??\\%c:", cDriveLetter );
 
    ANSI_STRING ostDrive, ostPath;
 
    RtlInitObjectString( &ostDrive, pszDrive );
    RtlInitObjectString( &ostPath, pszPartition );
    NTSTATUS status = IoCreateSymbolicLink( &ostDrive, &ostPath );
 
    return RtlNtStatusToDosError( status );
}
  
DWORD UnMapDrive( char cDriveLetter )
{
    char pszDrive[20];
    ZeroMemory( pszDrive, 20 );
 
    sprintf( pszDrive, "\\??\\%c:", cDriveLetter );
 
    ANSI_STRING ostDrive;
 
    RtlInitObjectString( &ostDrive, pszDrive );
    NTSTATUS status = IoDeleteSymbolicLink(&ostDrive);
 
    return RtlNtStatusToDosError( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\gamepusher\XbServer\graphics.cpp ===
/*****************************************************************************

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    graphics.cpp

	Derived from \private\test\tools\dvdread\bitfont.cpp
	             \private\test\tools\dvdread\gui.cpp
			     \private\test\tools\dvdread\utils.cpp

	Author: Josh Poley (jpoley)

Abstract:

    Defines functions needed to display graphics output on the Xbox.

*****************************************************************************/

#include "xbserver.h"

IDirect3D8*		    g_d3d;
IDirect3DDevice8*	g_pDevice;
BitFont				g_font;
IDirect3DTexture8*	g_pd3dtText;
TVertex				g_prText[4];
D3DLOCKED_RECT		g_d3dlr;


DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef _XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef _XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef _XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

/*****************************************************************************

Routine Description:

    Ansi2UnicodeHack

    In-place Pseudo Ansi to Unicode (char to wide char) conversion.

Arguments:

    IN char* str - char string to convert to wide char string

Return Value:

    WCHAR* - pointer to Unicode string

Note:
    
    Because a bunch of Unicode functions expect a WCHAR string to be on an
    even boundry, the returned string may be moved 1 character over.

*****************************************************************************/

WCHAR* Ansi2UnicodeHack(char *str)
    {
    if(!str) return NULL;

    int align = 0;
    int len = strlen(str)+1;

    // put string on an even boundry because some freak put a bunch of ASSERTs
    // that check for even boundries in Unicode functions like 
    // RtlEqualUnicodeString()
    if(((DWORD)str & 1) != 0)
        {
        align = 1;
        }

    for(; len>=0; len--)
        {
        str[len*2+align] = str[len];
        str[len*2+align+1] = '\0';
        }

    str += align;

    return (WCHAR*)str;
    }

HRESULT InitGraphics(void)
    {
    HRESULT	hr;
    D3DPRESENT_PARAMETERS d3dpp;
    int i;
    
    // Create an instance of a Direct3D8 object 
    g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
    if(g_d3d == NULL)
        return E_FAIL;
    
    // Setup the present parameters: 640x480x24
    ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth					= 640;
    d3dpp.BackBufferHeight					= 480;
    d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount					= 1;
    d3dpp.Flags								= 0;
    d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
    d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow						= NULL;
    d3dpp.Windowed							= FALSE;
    d3dpp.EnableAutoDepthStencil			= TRUE;
    d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
    d3dpp.Flags								= 0;
    d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;
    
    // Create the device
    hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDevice);
    if(FAILED(hr))
        return hr;
    
    // Create a buffer for the text
    hr = g_pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &g_pd3dtText);
    if(FAILED(hr))
        return hr;
    
    // Text plane
    g_prText[0].x = 0.0f;
    g_prText[0].y = 480.0f;
    g_prText[0].u = 0.0f;
    g_prText[0].v = 240.0f;
    g_prText[1].x = 0.0f;
    g_prText[1].y = 0.0f;
    g_prText[1].u = 0.0f;
    g_prText[1].v = 0.0f;
    g_prText[2].x = 640.0f;
    g_prText[2].y = 0.0f;
    g_prText[2].u = 320.0f;
    g_prText[2].v = 0.0f;
    g_prText[3].x = 640.0f;
    g_prText[3].y = 480.0f;
    g_prText[3].u = 320.0f;
    g_prText[3].v = 240.0f;
    
    for(i=0; i<4; i++) 
        {
        g_prText[i].z	= 0.0f;
        g_prText[i].rhw	= 1.0f;
        }
    
    // Setup stuff
    g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
    g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
    g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
    g_pDevice->SetTexture(0, g_pd3dtText);
    g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);
    
    return S_OK;
    }

void GraphicPrint(char* format, ...)
    {
    IDirect3DSurface8*	pd3ds;

    // Clear the device
    g_pDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff000000, 1.0f, 0);

    // Clear the texture
    g_pd3dtText->LockRect(0, &g_d3dlr, NULL, 0);
    for(unsigned i=0; i<240; i++)
        memset((LPBYTE)g_d3dlr.pBits + i * g_d3dlr.Pitch, 0, 320 * 4);
    g_pd3dtText->UnlockRect(0);

    // Get the surface to draw the text to
    g_pd3dtText->GetSurfaceLevel(0, &pd3ds);

	char szBuffer[256];

    va_list args;
    va_start(args, format);

    vsprintf(szBuffer, format, args);

    WCHAR *ptr = Ansi2UnicodeHack(szBuffer);

    g_font.DrawText(pd3ds, ptr, 25, 20, 0, 0xFFFFFFFF, 0);

    // Release the surface
    pd3ds->Release();

    // Draw the textured primitive (with the text)
    g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));

    // End the scene and present it
    g_pDevice->EndScene();
    g_pDevice->Present(NULL, NULL, NULL, NULL);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\gamepusher\PcClient\pcclient.cpp ===
/*************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

	pcclient.cpp

  Abstract:

	Defines the GamePusher PC "client" side functions which allow file data and commands to be
	broadcasted to listening Xboxes.

  Author:

	Mabel Santos (t-msanto) 03-Dec-2001

  Revision History:

*************************************************************************************************/

#include "pcclient.h"

#define PORT 2000

enum PacketTypes{ FILEDESC = 1, FILEDATA, FILEDONE };
enum QueryTypes{ REBOOTQUERY = 1, RECEIVEQUERY };
enum XboxStates{ REBOOTSTATE = 1, RECEIVESTATE, FINISHSTATE, GAMESTATE };

// number of threads to use for rebooting Xboxes
unsigned short NumThreads;

// number of seconds to wait before query timeout
unsigned short QueryTime;

// number of seconds to sleep between file sends
unsigned short FileSleep;

// number of seconds to sleep between packet sends
unsigned short PacketSleep;

// Xbox server app source path
char XbAppSrc[BUFFLEN];

// Xbox server app destination path
char XbAppDst[BUFFLEN];

// name of app to reboot into when finished 
char RebootApp[BUFFLEN];

// date/time identifier for log file
char FileStamp[BUFFLEN];

// log file name
char LogName[BUFFLEN];

// thread synchronization variables
CRITICAL_SECTION ThreadLock;
BOOL ThreadExitFlag;
unsigned short ThreadExitCount;

// CRC table
static const unsigned long CRCs[] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

/*************************************************************************************************

Routine Description:

	Default PcClient constructor.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

PcClient::PcClient(void)
{	
	// initialize Xbox list and tail pointer to NULL
	XboxList = NULL;
	LastXbox = NULL;
	
	//LogPrint("Initialized Xbox list to null\n");

	// set byte counter to 0
	ByteCount = 0;
	//LogPrint("Initialized byte counter to 0\n");

	// set packet counter to 0
	PacketCount = 0;
	//LogPrint("Initialized packet counter to 0\n");

	// set socket to invalid
	ClientSock = INVALID_SOCKET;
	//LogPrint("Set socket to invalid\n");

	// set WinSock flag to false
	WsaInitialized = false;
	//LogPrint("Set WinSock flag to false\n");
}

/*************************************************************************************************

Routine Description:

	Default PcClient destructor.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

PcClient::~PcClient(void)
{
	// close socket and clean up if needed
	if(ClientSock != INVALID_SOCKET)
	{
		closesocket(ClientSock);
	}

	if(WsaInitialized)
	{
		WSACleanup();
	}
}

/*************************************************************************************************

Routine Description:

	PrepareWinSock

	Initializes WinSock. Creates a UDP socket for broadcast use and binds the PC client to it.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::PrepareWinSock(void)
{
	// initialize WinSock
	WORD Version = MAKEWORD(2,2);
	WSADATA WsaData;
	WSAStartup(Version, &WsaData);
	WsaInitialized = true;
	//LogPrint("Initialized WinSock\n");

	// create a UDP datagram socket
	ClientSock = socket(AF_INET, SOCK_DGRAM, 0);
	//LogPrint("Created UDP datagram socket\n");

	if(ClientSock == INVALID_SOCKET && WSAGetLastError() == WSANOTINITIALISED) // 10093
	{
		WSAStartup(Version, &WsaData);
		WsaInitialized = true;
		//LogPrint("Initialized WinSock a second time\n");
		ClientSock = socket(AF_INET, SOCK_DGRAM, 0);
		//LogPrint("Created UDP datagram socket a second time\n");
	}

	// set socket up for broadcast use
	BOOL val = true;
	if(setsockopt(ClientSock, SOL_SOCKET, SO_BROADCAST, (char*)&val, sizeof(BOOL)) == SOCKET_ERROR) 
	{
		LogPrint("SOCKET ERROR in setsockopt()\n");
		return false;
	}
	else 
	{
		//LogPrint("Set socket up for broadcast use\n");
	}

	// try to increase send buffer size
	int Size, BufSize = 0;
	int Err, Res;
	
	// start with 64K, then cut buffer size in half if necessary until request is granted
	for(Size = 65536; Size > 16384; Size >>=1)
	{
		// if got a socket error, try again with a smaller size
		if(setsockopt(ClientSock, SOL_SOCKET, SO_SNDBUF, (char*)&Size, sizeof(int)) == SOCKET_ERROR)
		{
			Err = WSAGetLastError();
			// if option is not supported, break out of loop
			if(Err == WSAENOPROTOOPT || Err == WSAEINVAL) break;
		}
		else
		{
			// reaching here means buffer size was successfully changed
			break;
		}
	}
	Res = sizeof(int);
	getsockopt(ClientSock, SOL_SOCKET, SO_SNDBUF, (char*)&BufSize, &Res);
	//LogPrint("Send buffer size = %d bytes\n", BufSize);

	// fill in address structure
	SOCKADDR_IN ClientAddr;
	ClientAddr.sin_family = AF_INET;
	ClientAddr.sin_port = htons(0);
	ClientAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	//LogPrint("Filled in address structure\n");

	// bind name to socket
	if(bind(ClientSock, (SOCKADDR*)&ClientAddr, sizeof(SOCKADDR)) == SOCKET_ERROR)
	{
		LogPrint("SOCKET ERROR in bind()\n");
		return false;
	}
	else 
	{
		//LogPrint("Bound name to socket\n");
	}
	return true;
}

/*************************************************************************************************

Routine Description:

	PrepareXboxes

	Assigns and starts threads to put each Xbox listed in the gamepusher.ini file in a listening
	state.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::PrepareXboxes(void)
{
	int CurrThread = 0;

	//LogPrint("XbAppSrc: %s\n", XbAppSrc);
	//LogPrint("XbAppDst: %s\n", XbAppDst);

	FILE* f = fopen("C:\\GamePusher\\gamepusher.ini", "r");
	//FILE* f = fopen("D:\\GamePusher\\gamepusher.ini", "r");
	
	BOOL XboxFlag = false;

	if(f)
	{
		char line[BUFFLEN];
		char Xbox[BUFFLEN];
		char strtemp[BUFFLEN];
		int inttemp = 0;

		while(fgets(line, BUFFLEN, f))
		{
			// find start of Xboxlist section
			if(sscanf(line, "XboxList=%s", Xbox) == 1)
			{
				// set flag to indicate that we've found it
				XboxFlag = true;

				// if first Xbox is not on the exclude list, assign it to a thread
				if(!CheckExclList("C:\\GamePusher\\xboxexclude.txt", Xbox))
				//if(!CheckExclList("D:\\GamePusher\\xboxexclude.txt", Xbox))
				{
					AddXbox(Xbox, (CurrThread % NumThreads) + 1);
					++CurrThread;
				}
				else
				{
					//LogPrint("Xbox %s found on exclude list. Skipping...\n", Xbox);
				}
				break;
			}
		}

		while(XboxFlag && fgets(line, BUFFLEN, f))
		{
			// check if we've reached end of Xboxlist section
			if((sscanf(line, "%[^=]=%s", Xbox, strtemp) == 2) ||
				(sscanf(line, "%[^=]=%d", Xbox, inttemp) == 2))
			{
				// set flag to indicate that we're finished
				XboxFlag = false;
				break;
			}
			// reaching here means there's another Xbox on the list
			StringTrim(line);

			// if this Xbox is not on the exclude list, assign it to a thread
			if(!CheckExclList("C:\\GamePusher\\xboxexclude.txt", line))
			//if(!CheckExclList("D:\\GamePusher\\xboxexclude.txt", line))
			{
				AddXbox(line, (CurrThread % NumThreads) + 1);
				++CurrThread;
			}
			else
			{
				//LogPrint("Xbox %s found on exclude list. Skipping...\n", line);
			}
		}
		fclose(f);
	}
	else
	{
		LogPrint("ERROR: Could not open gamepusher.ini file\n");
		return false;
	}

	// initialize critical section variables
	InitializeCriticalSection(&ThreadLock);
	ThreadExitFlag = false;
	ThreadExitCount = 0;

	// start specified number of threads
	int ThreadCount;
	for(ThreadCount = 1; ThreadCount <= NumThreads; ++ThreadCount)
	{
		ThreadParam* ThreadArg = new ThreadParam;
		ThreadArg->Client = this;
		ThreadArg->ThreadNum = ThreadCount;
		CreateThread(NULL, 0, PrepareXboxThread, ThreadArg, 0, NULL);
	}

	// wait for all threads to finish
	while(!ThreadExitFlag)
	{
		Sleep(100);
		EnterCriticalSection(&ThreadLock);
		if(ThreadExitCount == NumThreads) ThreadExitFlag = true;
		LeaveCriticalSection(&ThreadLock);
	}

	DeleteCriticalSection(&ThreadLock);
	return true;
}

/*************************************************************************************************

Routine Description:

	PrepareXboxThread

	Puts Xboxes in a listening state by copying the XbServer app into each Xbox and rebooting it
	into the app.

Arguments:

	none

Return Value:

	DWORD	-	returns 1 after thread exits

*************************************************************************************************/

DWORD WINAPI
PrepareXboxThread(void* ThreadArg)
{
	// get thread number
	int ThreadNum = ((ThreadParam*)ThreadArg)->ThreadNum;

	// get Xbox list
	Xbox* Curr;
	for(Curr = ((ThreadParam*)ThreadArg)->Client->XboxList; Curr != NULL; Curr = Curr->Next)
	{
		// if current Xbox belongs to this thread, prepare it
		if(Curr->Thread == ThreadNum)
		{	
			//LogPrint("CurrXbox: %s\n", Curr->Name);
			//LogPrint("Thread: %u\n", Curr->Thread);
			int Res;
		
			// resolve Xbox name into its IP addresses
			DmSetXboxName(Curr->Name);
			DWORD HostAddr;
			struct in_addr NetAddr;
			LPSTR IpAddr;

			// get debug IP
			DmResolveXboxName(&HostAddr);
			NetAddr.s_addr = htonl(HostAddr);
			IpAddr = inet_ntoa(NetAddr);
			//LogPrint("DebugIp: %s\n", IpAddr);
		
			// reboot Xbox
			char Cmd1[BUFFLEN];
			strcpy(Cmd1, "xbreboot -x ");
			strcat(Cmd1, Curr->Name);

			//LogPrint("%s\n", Cmd1);
			Res = system(Cmd1);
			if(Res)
			{
				LogPrint("WARNING: Could not reboot %s\n", Curr->Name);
				continue;
			}
			//LogPrint("Rebooted %s\n", Curr->Name);
		
			// sleep for 1 sec to make sure box has been rebooted
			Sleep(1000);

			// copy over Xbox application
			char Cmd2[BUFFLEN];
			strcpy(Cmd2, "xbcp -x ");
			strcat(Cmd2, Curr->Name);
			strcat(Cmd2, " -ty "); // options: create dest dir if it does not exist, don't prompt to overwrite
			strcat(Cmd2, XbAppSrc);
			strcat(Cmd2, " ");
			strcat(Cmd2, XbAppDst);

			//LogPrint("%s\n", Cmd2);
			Res = system(Cmd2);
			if(Res)
			{
				LogPrint("WARNING: Could not copy %s into %s\n", XbAppSrc, Curr->Name);
				continue;
			}
			//LogPrint("Copied %s into %s\n", XbAppSrc, XbAppDst);

			// sleep for 1 sec to make sure app has been copied over
			Sleep(1000);

			// reboot Xbox into application
			char Cmd3[BUFFLEN];
			strcpy(Cmd3, "xbreboot -x ");
			strcat(Cmd3, Curr->Name);
			strcat(Cmd3, " ");
			strcat(Cmd3, XbAppDst);

			//LogPrint("%s\n", Cmd3);
			Res = system(Cmd3);
			if(Res)
			{
				LogPrint("WARNING: Could not reboot %s into %s\n", Curr->Name, XbAppDst);
				continue;
			}
			//LogPrint("Rebooted %s into %s\n", Curr->Name, XbAppDst);
		}
	}

	// increment count of exited threads
	EnterCriticalSection(&ThreadLock);
	++ThreadExitCount;
	LeaveCriticalSection(&ThreadLock);

	delete ((ThreadParam*)ThreadArg);
	return 1;
}

/*************************************************************************************************

Routine Description:

	CheckExclList

	Checks if a given name is on a specified exclude list.

Arguments:

	char* List	-	list to search
	char* Name	-	name to look for

Return Value:

	BOOL	-	 true if name is found on list; false otherwise

*************************************************************************************************/

BOOL
PcClient::CheckExclList(char* List, char* Name)
{
	FILE* f = fopen(List, "r");

	if(f)
	{
		char line[BUFFLEN];

		// check if any names on exclude list match given name
		while(fgets(line, BUFFLEN, f))
		{
			StringTrim(line);
			if(_stricmp(line, Name) == 0)
			{
				return true;
			}
		}
		fclose(f);
	}
	// reaching here means name was not found
	return false;
}

/*************************************************************************************************

Routine Description:

	GetTotalBytes

	Adds up the size of each file listed in the gamepusher.ini file to determine the total number
	of bytes to be sent over the network.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::GetTotalBytes(void)
{
	FILE* f = fopen("C:\\GamePusher\\gamepusher.ini", "r");
	//FILE* f = fopen("D:\\GamePusher\\gamepusher.ini", "r");
	BOOL FileFlag = false;

	if(f)
	{
		char line[BUFFLEN];
		char file[BUFFLEN];
		char strtemp[BUFFLEN];
		int inttemp = 0;
		
		while(fgets(line, BUFFLEN, f))
		{
			// find start of filelist section
			if(sscanf(line, "FileList=%s", file) == 1)
			{
				// set flag to indicate that we've found it
				FileFlag = true;
		
				// if first file is not on the exclude list, add its size to the byte counter
				if(!CheckExclList("C:\\GamePusher\\fileexclude.txt", file))
				//if(!CheckExclList("D:\\GamePusher\\fileexclude.txt", file))
				{
					GetFileBytes(file);
					
				}
				break;
			}
		}

		while(FileFlag && fgets(line, BUFFLEN, f))
		{
			// check if we've reached end of filelist section
			if((sscanf(line, "%[^=]=%s", file, strtemp) == 2) ||
			(sscanf(line, "%[^=]=%d", file, inttemp) == 2))
			{
				// set flag to indicate that we're finished
				FileFlag = false;
				break;
			}
			// reaching here means there's another file on the list
			StringTrim(line);
			
			// if this file is not on the exclude list, add its size to the byte counter
			if(!CheckExclList("C:\\GamePusher\\fileexclude.txt", line))
			//if(!CheckExclList("D:\\GamePusher\\fileexclude.txt", line))
			{
				GetFileBytes(line);
			}
		}
		fclose(f);
		//LogPrint("Total bytes to be sent: %u\n", ByteCount);
		return true;
	}
	else
	{
		LogPrint("ERROR: Could not open gamepusher.ini file\n");
		return false;
	}
}

/*************************************************************************************************

Routine Description:

	GetFileBytes

	Determines the size of a specified file in bytes.

Arguments:

	char* File	-	name of file whose size is to be determined

Return Value:

	none

*************************************************************************************************/

void
PcClient::GetFileBytes(char* File)
{
	char PcFile[BUFFLEN];
	
	int Mid = strcspn(File, ",");
	int End = strcspn(File, "\n");

	// copy source filename into a temp buffer
	memmove(PcFile, File, Mid);
	memset(PcFile+Mid, '\0', BUFFLEN-Mid);
	
	HANDLE FileHandle;
	DWORD FileSize;
	
	// get file size
	FileHandle = CreateFile(PcFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	FileSize = GetFileSize(FileHandle, NULL);
	ByteCount += FileSize;
	CloseHandle(FileHandle);
}

/*************************************************************************************************

Routine Description:

	SendQuery

	Sends a broadcast message and waits for responses to see which Xboxes are in a listening
	state.

Arguments:

	int QueryType	-	type of query being sent
						REBOOTQUERY: sent after Xboxes reboot into XbServer app
						RECEIVEQUERY: sent after Xboxes receive file data

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::SendQuery(int QueryType)
{
	int Result;
	SOCKADDR_IN DestAddr;
	int AddrSize = sizeof(SOCKADDR);

	DestAddr.sin_family = AF_INET;
	DestAddr.sin_port = htons(PORT);
	DestAddr.sin_addr.s_addr = htonl(INADDR_BROADCAST);

	// Send broadcast query to servers
	char QueryBuf[BUFFLEN];

	if(QueryType == REBOOTQUERY)
	{
		// if this is the first query, include total byte count so Xboxes know how much data to expect
		_ultoa(ByteCount, QueryBuf, 10);

		if(sendto(ClientSock, QueryBuf, strlen(QueryBuf), 0, (SOCKADDR*)&DestAddr, AddrSize) == SOCKET_ERROR)
		{
			LogPrint("SOCKET ERROR in sendto()\n");
			return false;
		}
	}
	else
	{
		if(sendto(ClientSock, NULL, 0, 0, (SOCKADDR*)&DestAddr, AddrSize) == SOCKET_ERROR)
		{
			LogPrint("SOCKET ERROR in sendto()\n");
			return false;
		}
	}

	//LogPrint("Sent broadcast query to servers\n");

	// wait for reply from each server
	//LogPrint("Waiting for reply from servers\n");

	TIMEVAL Timeout;
	FD_SET Bucket;

	// timeout after number of seconds specified in .INI file
	time_t Start, Curr;

	for(time(&Start), time(&Curr); difftime(Curr, Start) <= QueryTime; time(&Curr))
	{
		Bucket.fd_count = 1;
		Bucket.fd_array[0] = ClientSock;
		Timeout.tv_sec = 5;
		Timeout.tv_usec = 0;

		// clear buffer
		memset(QueryBuf, '\0', sizeof(QueryBuf));

		// wait for response
		Result = select(0, &Bucket, NULL, NULL, &Timeout);

		if(Result == 0) continue; // timed out so try again
		
		if(Result == SOCKET_ERROR)
		{
			LogPrint("SOCKET ERROR in select()\n");
			return false;
		}

		// grab response
		Result = recvfrom(ClientSock, QueryBuf, sizeof(QueryBuf), 0, (SOCKADDR*)&DestAddr, &AddrSize);	  
		
		if(Result == 0) 
		{
			// no more data
			//LogPrint("No more data. Breaking out of loop...\n");
			break;
		}

		if(Result == SOCKET_ERROR)
		{
			LogPrint("SOCKET ERROR in recvfrom()\n");
			return false;
		}

		// reaching here means we got a valid response	
		/*LogPrint("Received reply from server %u.%u.%u.%u \"%s\"\n", 
					DestAddr.sin_addr.S_un.S_un_b.s_b1, DestAddr.sin_addr.S_un.S_un_b.s_b2,
					DestAddr.sin_addr.S_un.S_un_b.s_b3, DestAddr.sin_addr.S_un.S_un_b.s_b4,
					QueryBuf);*/

		// change Xbox state according to the query type
		switch(QueryType)
		{
			// Xboxes that respond are rebooted into listening app and ready to receive files
			case REBOOTQUERY:

				SetXboxState(QueryBuf, RECEIVESTATE);
				break;

			// Xboxes that respond are done receiving files
			case RECEIVEQUERY:

				SetXboxState(QueryBuf, FINISHSTATE);
				break;
		}
	}

	// reaching here means we've timed out, so report which Xboxes responded in time and which ones did not
	switch(QueryType)
	{
		case REBOOTQUERY:
	
			LogPrint("Boxes that responded after rebooting:\n");
			//LogPrint("Got a response from the following Xboxes:\n");
			GetXboxes(RECEIVESTATE);
			LogPrint("Boxes that did NOT respond after rebooting:\n");
			//LogPrint("Did NOT get a response from the following Xboxes:\n");
			GetXboxes(REBOOTSTATE);
			break;

		case RECEIVEQUERY:

			LogPrint("Boxes that responded after receiving files:\n");
			//LogPrint("Got a response from the following Xboxes:\n");
			GetXboxes(FINISHSTATE);
			LogPrint("Boxes that did NOT respond after receiving files:\n");
			//LogPrint("Did NOT get a response from the following Xboxes:\n");
			GetXboxes(RECEIVESTATE);
			break;
	}
	return true;
}

/*************************************************************************************************

Routine Description:

	SendFiles

	Sends files listed in the gamepusher.ini file over the network.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::SendFiles(void)
{
	FILE* f = fopen("C:\\GamePusher\\gamepusher.ini", "r");
	//FILE* f = fopen("D:\\GamePusher\\gamepusher.ini", "r");
	BOOL FileFlag = false;

	if(f)
	{
		char line[BUFFLEN];
		char file[BUFFLEN];
		char strtemp[BUFFLEN];
		int inttemp = 0;
		
		while(fgets(line, BUFFLEN, f))
		{
			// find start of filelist section
			if(sscanf(line, "FileList=%s", file) == 1)
			{
				// set flag to indicate that we've found it
				FileFlag = true;
		
				// if first file is not on the exclude list, send it
				if(!CheckExclList("C:\\GamePusher\\fileexclude.txt", file))
				//if(!CheckExclList("D:\\GamePusher\\fileexclude.txt", file))
				{
					if(!SendFile(file))
					{
						return false;
					}
				}
				else
				{
					//LogPrint("File %s found on exclude list. Skipping...\n", file);
				}
				break;
			}
		}

		while(FileFlag && fgets(line, BUFFLEN, f))
		{
			// check if we've reached end of filelist section
			if((sscanf(line, "%[^=]=%s", file, strtemp) == 2) ||
			(sscanf(line, "%[^=]=%d", file, inttemp) == 2))
			{
				// set flag to indicate that we're finished
				FileFlag = false;
				break;
			}
			// reaching here means there's another file on the list
			StringTrim(line);
			
			// if this file is not on the exclude list, send it
			if(!CheckExclList("C:\\GamePusher\\fileexclude.txt", line))
			//if(!CheckExclList("D:\\GamePusher\\fileexclude.txt", line))
			{
				if(!SendFile(line))
				{
					return false;
				}
			}
			else
			{
				//LogPrint("File %s found on exclude list. Skipping...\n", line);
			}
		}
		fclose(f);
		return true;
	}
	else
	{
		LogPrint("ERROR: Could not open gamepusher.ini file\n");
		return false;
	}
}

/*************************************************************************************************

Routine Description:

	SendFile

	Sends a specified file over the network.

Arguments:

	char* File	-	 name of file to be sent

Return Value:

	BOOL	-	 true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::SendFile(char* File)
{
	// sleep before sending another file to allow Xboxes to receive previous data
	if(FileSleep > 0)
	{
		Sleep(FileSleep);
	}

	char PcFile[BUFFLEN];
	char XbFile[BUFFLEN];
	
	int Mid = strcspn(File, ",");
	int End = strcspn(File, "\n");

	// copy source filename into a temp buffer
	memmove(PcFile, File, Mid);
	memset(PcFile+Mid, '\0', BUFFLEN-Mid);
	//LogPrint("Source: %s\n", PcFile);

	// copy destination filename into a temp buffer
	memmove(XbFile, File+(Mid+1), End-(Mid+1));
	memset(XbFile+(End-(Mid+1)), '\0', BUFFLEN-(End-(Mid+1)));
	//LogPrint("Destination: %s\n", XbFile);

	HANDLE FileHandle;
	DWORD FileSize;
	char SendBuf[BUFFLEN];
	size_t ReadRes;
	
	// get file size
	FileHandle = CreateFile(PcFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	FileSize = GetFileSize(FileHandle, NULL);
	//LogPrint("Size: %d bytes\n", FileSize);
	CloseHandle(FileHandle);

	// open infile for reading in binary mode
	FILE* InFile = fopen(PcFile, "rb");

	// skip file if we can't find/open it
	if(InFile == NULL)
	{
		LogPrint("WARNING: Could not open file %s\n", PcFile);
		LogPrint("WARNING: File %s not sent\n", PcFile);
		return true;
	}
	
	// send file description packet
	if(!SendPacket(FILEDESC, FileSize, strlen(XbFile), XbFile))
	{
		LogPrint("ERROR: File description not sent\n");
		LogPrint("ERROR: File %s not sent\n", PcFile);
		return false;
	}
	//LogPrint("Sent file description packet\n");

	while(!feof(InFile))
	{
		// clear buffer and read 1K of data from infile
		memset(SendBuf, '\0', sizeof(SendBuf));
		ReadRes = fread(SendBuf, sizeof(char), BUFFLEN, InFile);

		// if there is a problem with reading from the file, return
		if(ferror(InFile))
		{
			LogPrint("ERROR: Could not read data from file\n");
			LogPrint("ERROR: File %s not sent\n", PcFile);
			return false;
		}

		// if read 0 bytes, end of file has been reached so break out of loop
		if(ReadRes == 0)
		{
			break;
		}

		//LogPrint("Read %dB of data from file\n", ReadRes);

		// send file data packet
		if(!SendPacket(FILEDATA, FileSize, ReadRes, SendBuf))
		{
			LogPrint("ERROR: Could not send file data\n");
			LogPrint("ERROR: File %s not sent\n", PcFile);
			return false;
		}
		//LogPrint("Sent file data packet\n");
	}
	
	// close infile stream
	fclose(InFile);
	//LogPrint("Sent file %s successfully\n", PcFile);
	return true;
}

/*************************************************************************************************

Routine Description:

	SendFlashCmd

	Sends a command for Xboxes to flash ROM over the network.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::SendFinishMsg(void)
{	
	if(!SendPacket(FILEDONE, 0, 0, NULL))
	{
		LogPrint("ERROR: Finish message not sent\n");
		return false;
	}

	//LogPrint("Sent finish message\n");
	return true;
}

/*************************************************************************************************

Routine Description:

	RebootXboxes

	Assigns and starts threads to reboot each Xbox listed in the gamepusher.ini file that is in a
	listening state.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

void
PcClient::RebootXboxes(void)
{
	if(strcmp(RebootApp, "NONE") != 0)
	{
		//LogPrint("RebootApp: %s\n", RebootApp);
	}

	// initialize critical section variables
	InitializeCriticalSection(&ThreadLock);
	ThreadExitFlag = false;
	ThreadExitCount = 0;

	// start specified number of threads
	int ThreadCount;
	for(ThreadCount = 1; ThreadCount <= NumThreads; ++ThreadCount)
	{
		ThreadParam* ThreadArg = new ThreadParam;
		ThreadArg->Client = this;
		ThreadArg->ThreadNum = ThreadCount;
		CreateThread(NULL, 0, RebootXboxThread, ThreadArg, 0, NULL);
	}

	// wait for all threads to finish
	while(!ThreadExitFlag)
	{
		Sleep(100);
		EnterCriticalSection(&ThreadLock);
		if(ThreadExitCount == NumThreads) ThreadExitFlag = true;
		LeaveCriticalSection(&ThreadLock);
	}

	DeleteCriticalSection(&ThreadLock);
}

/*************************************************************************************************

Routine Description:

	RebootXboxThread

	Reboots Xboxes into app listed in the gamepusher.ini file, or into the XDK launcher if there is
	no app specified.

Arguments:

	none

Return Value:

	DWORD	-	returns 1 after thread exits

*************************************************************************************************/

DWORD WINAPI
RebootXboxThread(void* ThreadArg)
{
	// get thread number
	int ThreadNum = ((ThreadParam*)ThreadArg)->ThreadNum;

	if(strcmp(RebootApp, "NONE") != 0)
	{
		// get Xbox list
		Xbox* Curr;
		for(Curr = ((ThreadParam*)ThreadArg)->Client->XboxList; Curr != NULL; Curr = Curr->Next)
		{
			// reboot each Xbox that recovered successfully into specified application
			if(Curr->State == FINISHSTATE && Curr->Thread == ThreadNum)
			//if(Curr->Thread == ThreadNum)
			{
				//LogPrint("CurrXbox: %s\n", Curr->Name);
				//LogPrint("Thread: %u\n", Curr->Thread);
				int Res;
				char XboxName[BUFFLEN];
				strcpy(XboxName, Curr->Name);
				char Cmd1[BUFFLEN];
				strcpy(Cmd1, "xbreboot -xc ");
				strcat(Cmd1, XboxName);
				strcat(Cmd1, " ");
				strcat(Cmd1, RebootApp);

				//LogPrint("%s\n", Cmd1);

				Res = system(Cmd1);
				if(Res)
				{
					LogPrint("WARNING: Could not reboot %s into %s\n", XboxName, RebootApp);
				}
				else
				{
					//LogPrint("Rebooted %s into %s\n", XboxName, RebootApp);
				
					// set Xbox state to indicate that it's been rebooted
					((ThreadParam*)ThreadArg)->Client->SetXboxState(XboxName, GAMESTATE);
				}
			}
		}
	}
	else
	{
		Xbox* Curr;
		for(Curr = ((ThreadParam*)ThreadArg)->Client->XboxList; Curr != NULL; Curr = Curr->Next)
		{
			// reboot each Xbox that recovered successfully into XDK launcher
			if(Curr->State == FINISHSTATE && Curr->Thread == ThreadNum)
			//if(Curr->Thread == ThreadNum)
			{
				//LogPrint("CurrXbox: %s\n", Curr->Name);
				//LogPrint("Thread: %u\n", Curr->Thread);
				int Res;
				char XboxName[BUFFLEN];
				strcpy(XboxName, Curr->Name);
				char Cmd1[BUFFLEN];
				strcpy(Cmd1, "xbreboot -xc ");
				strcat(Cmd1, XboxName);

				//LogPrint("%s\n", Cmd1);

				Res = system(Cmd1);
				if(Res)
				{
					LogPrint("WARNING: Could not reboot %s\n", XboxName);
				}
				else
				{
					//LogPrint("Rebooted %s\n", XboxName);
				
					// set Xbox state to indicate that it's been rebooted
					((ThreadParam*)ThreadArg)->Client->SetXboxState(XboxName, GAMESTATE);
				}
			}
		}
	}

	// increment count of exited threads
	EnterCriticalSection(&ThreadLock);
	++ThreadExitCount;
	LeaveCriticalSection(&ThreadLock);

	delete ((ThreadParam*)ThreadArg);
	return 1;
}

/*************************************************************************************************

Routine Description:

	ReportResults

	Lists which boxes successfully received data and commands, and which ones failed.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
PcClient::ReportResults(void)
{
/*
	LogPrint("Boxes that did not respond after rebooting:\n");
	GetXboxes(REBOOTSTATE);

	LogPrint("Boxes that did not respond after receiving files:\n");
	GetXboxes(RECEIVESTATE);
*/
	if(strcmp(RebootApp, "NONE") != 0)
	{
		LogPrint("Boxes that have been rebooted into %s:\n", RebootApp);
		GetXboxes(GAMESTATE);

		LogPrint("Boxes that could NOT be rebooted into %s:\n", RebootApp);
		GetXboxes(FINISHSTATE);
	}
	else
	{
		LogPrint("Boxes that have been rebooted into XDK launcher:\n");
		GetXboxes(GAMESTATE);
		
		LogPrint("Boxes that could NOT be rebooted into XDK launcher:\n");
		GetXboxes(FINISHSTATE);
	}
}

/*************************************************************************************************

Routine Description:

	SendPacket

	Sends a data packet over the network.

Arguments:

	BYTE PacketType	-	type of packet being sent
						FILEDESC: file description and path
						FILEDATA: file data
						FILEDONE: notification that all files have been sent
	DWORD FileSize	-	total size of current file in bytes
	WORD DataSize	-	size of data being sent in bytes
	char* Data		-	data being sent

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::SendPacket(BYTE PacketType, DWORD FileSize, WORD DataSize, char* Data)
{
	// sleep before sending another packet to allow Xboxes to receive previous data
	if(PacketSleep > 0)
	{
		Sleep(PacketSleep);
	}

	int Result;
	SOCKADDR_IN dest;
	dest.sin_family = AF_INET;
	dest.sin_addr.s_addr = htonl(INADDR_BROADCAST);
	dest.sin_port = htons(PORT);

	// increment packet count
	++PacketCount;
	//LogPrint("Incremented packet count to %d\n", PacketCount);

	char SendBuf[sizeof(FilePacketHeader) + BUFFLEN];
	memset(SendBuf, '\0', sizeof(SendBuf));
	FilePacket* Packet = (FilePacket*)SendBuf;
	Packet->PacketType = PacketType;
	Packet->SequenceNo = PacketCount;
	Packet->FileSize = FileSize;
	Packet->DataSize = DataSize;
	memmove(Packet->Data, Data, DataSize);
	Packet->Crc = GetCRC((unsigned char*)Packet->Data, Packet->DataSize);
	

	// display packet info
	//LogPrint("PacketType: %d\n", Packet->PacketType);
	//LogPrint("SequenceNo: %d\n", Packet->SequenceNo);
	//LogPrint("DataSize: %d\n", Packet->DataSize);
	//LogPrint("Crc: %d\n", Packet->Crc);

	// send packet
	Result = sendto(ClientSock, SendBuf, DataSize + sizeof(FilePacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR));
	if(Result == SOCKET_ERROR)
	{
		LogPrint("SOCKET ERROR in sendto()\n");
		return false;
	}
	return true;
}

/*************************************************************************************************

Routine Description:

	GetCRC

	Determines the CRC for the specified data.

Arguments:

	unsigned char* Data	-	data whose CRC is to be determined
	WORD Size			-	size of data

Return Value:

	DWORD	-	CRC for data

*************************************************************************************************/

DWORD
PcClient::GetCRC(unsigned char* Data, WORD Size)
{
	DWORD Result = 0;
	DWORD Shift = 0;
	DWORD Index = 0;

	while(Size--)
	{
		Result = (Result >> 8) ^ CRCs[(BYTE)(Result ^ *Data++)];
	}
	return Result;
}

/*************************************************************************************************

Routine Description:

	AddXbox

	Adds an Xbox to the Xbox list and assigns it to a thread.

Arguments:

	char* Name	-	name of Xbox
	int Thread	-	thread number assigned to Xbox

Return Value:

	none

*************************************************************************************************/

void
PcClient::AddXbox(char* Name, int Thread)
{
	// make new node
	Xbox* NewXbox = new Xbox;
	strcpy(NewXbox->Name, Name);
	NewXbox->State = REBOOTSTATE;
	NewXbox->Thread = Thread;
	NewXbox->Next = NULL;

	// if the list is currently empty, make this node the first and last
	if(XboxList == NULL && LastXbox == NULL)
	{
		XboxList = NewXbox;
		LastXbox = NewXbox;
	}
	else // else just add this node to the tail of the list
	{
		LastXbox->Next = NewXbox;
		LastXbox = NewXbox;
	}
}

/*************************************************************************************************

Routine Description:

	SetXboxState

	Sets the state of an Xbox on the Xbox list to a new value.

Arguments:

	char* Name	-	name of Xbox whose state is to be changed
	int State	-	new Xbox state
					REBOOTSTATE: box needs to reboot into listening app
					RECEIVESTATE: box needs to receive file data
					FINISHSTATE: box has finished receiving files and needs to be rebooted
					GAMESTATE: box has been rebooted

Return Value:

	none

*************************************************************************************************/

void
PcClient::SetXboxState(char* Name, int State)
{
	Xbox* Curr;
	for(Curr = XboxList; Curr != NULL; Curr = Curr->Next)
	{
		if(_stricmp(Curr->Name, Name) == 0) // we've found the node we're looking for
		{
			Curr->State = State;
		}
	}
}

/*************************************************************************************************

Routine Description:

	GetXboxes

	Lists Xboxes on the Xbox list with the specified state.

Arguments:

	int State	-	state to search for

Return Value:

	none

*************************************************************************************************/

void
PcClient::GetXboxes(int State)
{
	BOOL Found = false;
	Xbox* Curr;
	for(Curr = XboxList; Curr != NULL; Curr = Curr->Next)
	{
		// if current Xbox has the state we're looking for, print it out
		if(Curr->State == State)
		{
			LogPrint("%s\n", Curr->Name);
			Found = true;
		}
	}
	if(!Found)
	{
		LogPrint("NONE\n");
	}
}

/*************************************************************************************************

Routine Description:

	ClearXboxes

	Deletes all Xboxes on the Xbox list.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
PcClient::ClearXboxes(void)
{
	while(XboxList != NULL)
	{
		// delete all nodes on the list
		Xbox* Curr = XboxList;
		XboxList = Curr->Next;
		delete Curr;
	}
	LastXbox = NULL;
}

/*************************************************************************************************

Routine Description:

	StringTrim

	Trims off tabs and newlines from a given string.

Arguments:

	char* String	-	string to be trimmed

Return Value:

	none

*************************************************************************************************/

void
StringTrim(char* String)
{
	// trim off tabs and/or newlines
	int Pos = strcspn(String, "\t\n");
	String[Pos] = '\0';
}

/*************************************************************************************************

Routine Description:

	LogPrint

	Prints a line to standard output and to a logfile.

Arguments:

	char* Format, ...	-	format string	

Return Value:

	none

*************************************************************************************************/

void
LogPrint(char* Format, ...)
{
	va_list ArgList;
	va_start(ArgList, Format);
	
	// print to stdout
	vprintf(Format, ArgList);

	// print to logfile
	FILE* LogFile = fopen(LogName, "a");

	if(LogFile)
	{
		vfprintf(LogFile, Format, ArgList);
		fclose(LogFile);
	}

	va_end(ArgList);
}

/*************************************************************************************************

Routine Description:

	main function

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
main(void)
{
	char DateBuf[9];
	char TimeBuf[9];

	_strdate(DateBuf);
	_strtime(TimeBuf);

	// get date without year for file stamp
	DateBuf[5] = '\0';
	// change '/' in date to '-' so fopen is happy
	DateBuf[2] = '-';

	// get time without secs for file stamp
	TimeBuf[5] = '\0';
	// change ':' in time to '-' so fopen is happy
	TimeBuf[2] = '-';

	// set date/time file stamp
	strcpy(FileStamp, DateBuf);
	strcat(FileStamp, "_");
	strcat(FileStamp, TimeBuf);

	// set log file name
	strcpy(LogName, "log_");
	strcat(LogName, FileStamp);
	strcat(LogName, ".txt");

	// restore original date
	DateBuf[2] = '/';
	DateBuf[5] = '/';

	// restore original time
	TimeBuf[2] = ':';
	TimeBuf[5] = ':';

	// get start time
	LogPrint("Start Time: %s %s\n", DateBuf, TimeBuf);

	// get number of threads to use for rebooting Xboxes from .INI file
	NumThreads = GetPrivateProfileIntA("Settings", "NumThreads", 5, "C:\\GamePusher\\gamepusher.ini");
	//NumThreads = GetPrivateProfileIntA("Settings", "NumThreads", 5, "D:\\GamePusher\\gamepusher.ini");
	//LogPrint("NumThreads: %d\n", NumThreads);

	// get number of seconds to wait before query timeout from .INI file
	QueryTime = GetPrivateProfileIntA("Settings", "QueryTime", 30, "C:\\GamePusher\\gamepusher.ini");
	//QueryTime = GetPrivateProfileIntA("Settings", "QueryTime", 30, "D:\\GamePusher\\gamepusher.ini");
	//LogPrint("QueryTime: %d\n", QueryTime);

	// get number of seconds to sleep before file sends from .INI file
	FileSleep = GetPrivateProfileIntA("Settings", "FileSleep", 2, "C:\\GamePusher\\gamepusher.ini");
	//FileSleep = GetPrivateProfileIntA("Settings", "FileSleep", 2, "D:\\GamePusher\\gamepusher.ini");
	//LogPrint("FileSleep: %d\n", FileSleep);

	// get number of seconds to sleep before packet sends from .INI file
	PacketSleep = GetPrivateProfileIntA("Settings", "PacketSleep", 1, "C:\\GamePusher\\gamepusher.ini");
	//PacketSleep = GetPrivateProfileIntA("Settings", "PacketSleep", 1, "D:\\GamePusher\\gamepusher.ini");
	//LogPrint("PacketSleep: %d\n", PacketSleep);

	// get Xbox app source path from .INI file
	GetPrivateProfileStringA("Settings", "XbAppSrc", "C:\\GamePusher\\XbServer.xbe", XbAppSrc, BUFFLEN, "C:\\GamePusher\\gamepusher.ini");
	//GetPrivateProfileStringA("Settings", "XbAppSrc", "D:\\GamePusher\\XbServer.xbe", XbAppSrc, BUFFLEN, "D:\\GamePusher\\gamepusher.ini");
	
	// get Xbox app destination path from .INI file
	GetPrivateProfileStringA("Settings", "XbAppDst", "xE:\\GamePusher\\XbServer.xbe", XbAppDst, BUFFLEN, "C:\\GamePusher\\gamepusher.ini");
	//GetPrivateProfileStringA("Settings", "XbAppDst", "xE:\\GamePusher\\XbServer.xbe", XbAppDst, BUFFLEN, "D:\\GamePusher\\gamepusher.ini");

	// get app to reboot into when finished from .INI file
	GetPrivateProfileStringA("Settings", "RebootApp", "NONE", RebootApp, BUFFLEN, "C:\\GamePusher\\gamepusher.ini");
	//GetPrivateProfileStringA("Settings", "RebootApp", "NONE", RebootApp, BUFFLEN, "D:\\GamePusher\\gamepusher.ini");

	// make a PcClient object
	PcClient* Client = new PcClient;

	// set up network stuff
	if(!Client->PrepareWinSock())
	{
		Client->ClearXboxes();
		delete Client;
		return;
	}

	LogPrint("Preparing Xboxes...\n");
	// set up Xbox servers
	if(!Client->PrepareXboxes())
	{
		Client->ClearXboxes();
		delete Client;
		return;
	}

	// add up total number of data bytes to send over the network
	if(!Client->GetTotalBytes())
	{
		Client->ClearXboxes();
		delete Client;
		return;
	}

	// sleep for 10 secs to make sure Xboxes are ready to receive query
	Sleep(10000);

	LogPrint("Pinging Xboxes...\n");
	// send reboot query to servers and wait for response
	if(!Client->SendQuery(REBOOTQUERY))
	{
		Client->ClearXboxes();
		delete Client;
		return;
	}

	LogPrint("Sending files...\n");
	// send files
	if(!Client->SendFiles())
	{
		Client->ClearXboxes();
		delete Client;
		return;
	}

	LogPrint("Sending finish message...\n");
	// send finish message
	if(!Client->SendFinishMsg())
	{
		Client->ClearXboxes();
		delete Client;
		return;
	}

	// sleep for 10 secs to make sure Xboxes are ready to receive query
	Sleep(10000);

	LogPrint("Pinging Xboxes...\n");
	// send receive query to servers and wait for response 
	if(!Client->SendQuery(RECEIVEQUERY))
	{
		Client->ClearXboxes();
		delete Client;
		return;
	}

	LogPrint("Rebooting Xboxes...\n");
	// reboot Xboxes into specified application
	Client->RebootXboxes();

	// report which Xboxes recovered successfully and which ones did not
	Client->ReportResults();

	// get end time
	_strdate(DateBuf);
	_strtime(TimeBuf);
	LogPrint("End Time: %s %s\n", DateBuf, TimeBuf);

	// return memory to heap
	Client->ClearXboxes();
	delete Client;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\gamepusher\XbServer\setled.cpp ===
/*****************************************************************************

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    setled.cpp

	Derived from \private\test\kernel\smc\smc.cpp

	Author:

Abstract:

    Defines functions needed to change LED colors on the Xbox.

*****************************************************************************/

#include "xbserver.h"

extern "C"
    {
	DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );
    }

NTSTATUS WriteSMC(unsigned char addr, unsigned char value)
    {
    return HalWriteSMBusValue(0x20, addr, FALSE, value);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\gamepusher\XbServer\xbserver.h ===
/*************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

	xbserver.h

  Abstract:

	Defines the Xbox server side for the GamePusher tool.

  Author:

	Mabel Santos (t-msanto) 03-Dec-2001

  Revision History:

*************************************************************************************************/

#ifndef _XBSERVER_H_
#define _XBSERVER_H_

#define NTLEANANDMEAN
#define _X86_
#define _WIN32_WINNT 0x0500

#define _HAL_
#define _MM_
#define _IO_
#define _FSCACHE_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <scsi.h>
#include <ntddscsi.h>
#include <ntos.h>
#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <xbdm.h>
#include <winsockx.h>
#include "..\..\..\..\ntos\recovery\recovpch.h"
#include "..\..\dvdread\bitfont.h"

#include <assert.h>
#include <D3DX8Math.h>
#ifdef _XBOX
#include <xgraphics.h>
#endif

#define PORT 2000
#define BUFFLEN 1024
#define ROM_SIZE (1024 * 1024)
#define ROM_FLASH_RETRIES 25

enum PacketTypes{ FILEDESC = 1, FILEDATA, FILEDONE };
enum ErrorCodes{ PKTERROR = 1, CHKSMERROR, DIRERROR, FILEERROR, KRNLERROR, FLASHERROR };

// network packet structures

struct FilePacketHeader
{
	unsigned char PacketType;
	unsigned long SequenceNo;
	unsigned long FileSize;
	unsigned short DataSize;
	unsigned long Crc;
};

struct FilePacket : public FilePacketHeader
{
	char Data[BUFFLEN];
};

class XbServer
{
private:
	// socket for network communication
	SOCKET ServerSock;

	// flag to indicate whether WinSock has been initialized
	BOOL WsaInitialized;

	// flag to indicate whether an error has occurred
	int ErrorFlag;

	// flag to indicate when a successful ROM flash has occurred
	BOOL ExitFlag;

	// total number of bytes to be received
	unsigned long TotalBytes;

	// number of bytes received so far
	unsigned long RecvdBytes;

	// sequence number of current file's description packet
	DWORD BasePkt;

	// number of packets needed for current file
	DWORD NumPkts;
	
	// number of packets received for current file
	DWORD RecvdPkts;

	// stream for writing files to hard drive
	FILE* OutFile;

	// buffer for holding Xbox name
	char NameBuf[BUFFLEN];

public:
	XbServer(void);
	~XbServer(void);
	BOOL PrepareWinSock(void);
	void MapDrives(void);
	BOOL SendReply(void);
	void RecvFiles(void);
	void ReadPacket(FilePacket* Packet);
	BOOL CheckPkts(void);
	void StartFile(DWORD FileSize, DWORD PktNum);
	BOOL CreateDirs(char* PathName);
	void UnMapDrives(void);
	void FlashLED(void);
	DWORD GetCRC(unsigned char* Data, WORD Size);
};

extern XbServer* Server;
extern int DebugOn;

// debug output
void DebugPrint(char* ptszFormat, ...);

// setting LED colors
NTSTATUS WriteSMC(unsigned char addr, unsigned char value);

// mapping drives
DWORD MapDrive( char cDriveLetter, char* pszPartition );
DWORD UnMapDrive( char cDriveLetter );

// graphics output
WCHAR* Ansi2UnicodeHack(char *str);
HRESULT InitGraphics(void);
void GraphicPrint(char* format, ...);

extern IDirect3D8*		    g_d3d;
extern IDirect3DDevice8*	g_pDevice;
extern BitFont				g_font;
extern IDirect3DTexture8*	g_pd3dtText;
extern TVertex				g_prText[4];
extern D3DLOCKED_RECT		g_d3dlr;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\ghprofiler\ghprofiler.cpp ===
// GhProfiler.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

int GetSymbol(char *map, DWORD address, char *symbol)
    {
    char hex[32];
    char sym[1024];
    sprintf(hex, "%08x", address);
    char *addr = strstr(map, hex);

    if(!addr) return 0;

    do { --addr; } while(*addr == ' ');
    do { --addr; } while(*addr != ' ');

    sscanf(addr, "%s", sym);

    UnDecorateSymbolName(sym, symbol, 1024, UNDNAME_COMPLETE);

    return 1;
    }

int __cdecl main(int argc, char* argv[])
    {
    DWORD address, count, exit, error, avgTime, maxTime, minTime, penterTime, childTime, freq=0;
    const unsigned MAX_BUFF = 1024;
    char buffer[MAX_BUFF];
    char *symbolMap = new char[4*1024*1024];
    char symbol[MAX_BUFF];
    unsigned columns;

    // read in the map file
    FILE *map = fopen("harness.map", "r");
    if(!map)
        {
        delete[] symbolMap;
        printf("ERROR: harness.map must exist in the current directory.\n");
        return 1;
        }
    DWORD length = _filelength(_fileno(map));
    fread(symbolMap, 1, length, map);
    fclose(map);
    symbolMap[length] = '\0';

    // parse the log and generate the report
    FILE *log = fopen("GhProf.log", "r");
    if(!log)
        {
        delete[] symbolMap;
        printf("ERROR: ghprof.log must exist in the current directory.\n");
        return 1;
        }

    FILE *out = fopen("GhReport.txt", "w+");
    FILE *xml = fopen("GhReport.xml", "w+");
    fprintf(xml, "<GhProfiler>\n");
    fprintf(xml, "    <Report>\n");
    while(fgets(buffer, MAX_BUFF, log))
        {
        if(9 == sscanf(buffer, "%x, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu", &address, &count, &exit, &error, &avgTime, &maxTime, &minTime, &penterTime, &childTime))
            {
            if(!GetSymbol(symbolMap, address, symbol)) strcpy(symbol, "(no symbol)");
            fprintf(out, "%08x, %5lu, %5lu, %5lu, %8lu, %8lu, %8lu, %8lu, %8lu,  %s\n", address, count, exit, error, avgTime, maxTime, minTime, penterTime, childTime, symbol);
            fprintf(xml, "        <Call address=\"%08x\"><Name><![CDATA[%s]]></Name><HitCount>%lu</HitCount><AvgTime>%lu</AvgTime><ChildTime>%lu</ChildTime></Call>\n", address, symbol, count, avgTime, childTime);
            }
        else if(1 == sscanf(buffer, "Freq=%lu", &freq))
            {
            fprintf(out, "%s", buffer);
            }
        else
            {
            fprintf(out, "%s", buffer);
            }
        }
    fprintf(xml, "    </Report>\n");
    
    if(freq)
        {
        fprintf(xml, "<Resolution Note='ticks per second'>%lu</Resolution>\n", freq);
        }

    fprintf(xml, "</GhProfiler>\n");
    fclose(xml);
    fclose(out);
    fclose(log);

    delete[] symbolMap;

    printf("Done. GhReport.txt created.\n");
    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\ghprof\ghprof.h ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    GhProf.h

Abstract:

    The /Gh compiler flag inserts a call to __penter() at the beginning 
    of each function. 

    The __pexit() function is not explicitly called by the /Gh flag. So
    inside of __penter() we modify the return address to jump inside of our
    __pexit, call our cleanup function, then jump back to where it was 
    supposed to go in the first place. Note that __pexit should NEVER be
    called, only jumped to and only with the proper setup via our __penter
    method.

    WARNING!
        1.  penterAddStats MODIFIES the stack at where the return address 
            should be in relation to the base pointer.
        2.  This means that FPO (Frame-Pointer Omission) must NOT be enabled

Author:

    jpoley

Environment:

    XBox

Revision History:

*/

#ifndef _GHPROF_H_
#define _GHPROF_H_

#include <xtl.h>

#ifndef DISPATCH_LEVEL
#define DISPATCH_LEVEL 2
#endif

extern "C"
    {
    ULONG DebugPrint(char* Format, ...);
    UCHAR KeGetCurrentIrql();

    // from wdm.h
    void* ExAllocatePool(size_t NumberOfBytes);
    void ExFreePool(void* P);
    }



//
// publics
//
void __stdcall penterDumpStats(void);

//
// privates
//
void __stdcall penterAddStats(void);
unsigned __stdcall penterCleanup(void);
extern "C" void __cdecl _pexit(void);



/*****************************************************************************

Routine Description:

    new & delete
    
    We override new and delete to use Pools instead of the heap because we
    dont want to be doing "pageable" heap operations in "nonpageable" OS calls

*****************************************************************************/
static void* __cdecl operator new(size_t memSize)
    {
    return ExAllocatePool(memSize);
    }
static void __cdecl operator delete(void* p)
    {
    if(!p) return;
    ExFreePool(p);
    }
static void __cdecl operator delete[](void* p)
    {
    if(!p) return;
    ExFreePool(p);
    }


//
// internal structures
//
namespace GhProfiler {
/*
class PerfTimer
    {
    public:
        LARGE_INTEGER time;

    public:
        PerfTimer()         {}
        PerfTimer(int a)    { time.QuadPart = a; }
        void GetTime(void)  { QueryPerformanceCounter(&time); }
        void GetSpan(void)  { LARGE_INTEGER temp; QueryPerformanceCounter(&temp); time.QuadPart = temp.QuadPart - time.QuadPart; }
        operator unsigned __int64() { return (unsigned __int64)time.QuadPart; }
    };
*/
class MethodStats
    {
    public:
        DWORD hitCount;
        DWORD exitCount;
        DWORD failures;
        LARGE_INTEGER runningTime;
        LARGE_INTEGER maxTime;
        LARGE_INTEGER minTime;
        LARGE_INTEGER penterTime;
        LARGE_INTEGER childTime;

    public:
        MethodStats();
    };

static void DestroyMethodStats(DWORD key, void *p, void *param);
static void PrintStats(DWORD key, void *p, void *param);

struct PenterCallStack
    {
    unsigned returnAddress;
    unsigned methodAddress;
    LARGE_INTEGER startTime;
    LARGE_INTEGER penterTime;
    LARGE_INTEGER childTime;
    };

#define MAX_ADDR_STACKS 25
class RetAddrStack
    {
    public:
        DWORD threadContext;
        unsigned length;
        PenterCallStack *stack;

    public:
        RetAddrStack();
        ~RetAddrStack();
        inline void Init(void);

    public:
        unsigned Push(void);
        unsigned Pop(void);
        unsigned GetAddress(void);

    private:
        unsigned maxLength;
        void Grow(void);
    };
RetAddrStack* FindThreadAddrStack(void);




/*****************************************************************************

Class Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
typedef void (*HASHOBJ_FUNC)(DWORD, void*, void*);
template <class T> class HashEntry
    {
    public:
        DWORD key;
        T obj;
        HashEntry <T> *next;

    public:
        HashEntry();
        HashEntry(DWORD k, T o);
        ~HashEntry();
    };

/*****************************************************************************

Class Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T, size_t SIZE> class HashTable
    {
    public:
        HashTable();
        HashTable(HASHOBJ_FUNC c) { clean = c; }
        ~HashTable();

        HASHOBJ_FUNC clean;
        size_t m_size;

    public:
        HashEntry<T> *table[SIZE];
    
        BOOL Get(DWORD key, T& out);
        T Add(DWORD key, T o);
        BOOL ForAll(HASHOBJ_FUNC fn, void *param);
        void SetCleanupFunct(HASHOBJ_FUNC c) { clean = c; }
    };

/*****************************************************************************

Routine Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T>
HashEntry<T>::HashEntry()
    {
    clean = NULL;
    key = NULL;
    next = NULL;
    }


/*****************************************************************************

Routine Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T>
HashEntry<T>::HashEntry(DWORD k, T o)
    {
    key = k;
    obj = o;
    next = NULL;
    }

/*****************************************************************************

Routine Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T>
HashEntry<T>::~HashEntry()
    {
    if(next) delete next;
    }

/*****************************************************************************

Routine Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T, size_t SIZE>
HashTable<T, SIZE>::HashTable()
    {
    m_size = SIZE;
    clean = NULL;
    for(size_t i=0; i<SIZE; i++)
        {
        table[i] = NULL;
        }
    }


/*****************************************************************************

Routine Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T, size_t SIZE>
HashTable<T, SIZE>::~HashTable()
    {
    if(clean) ForAll(clean, NULL);
    for(size_t i=0; i<SIZE; i++)
        {
        if(table[i]) delete table[i];
        }
    }

/*****************************************************************************

Routine Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T, size_t SIZE>
BOOL HashTable<T, SIZE>::Get(DWORD key, T& out)
    {
    size_t i = key % SIZE;

    if(!table[i]) return FALSE;

    for(HashEntry<T> *h = table[i]; h; h=h->next)
        {
        if(h->key == key)
            {
            out = h->obj;
            return TRUE;
            }
        }

    return FALSE;
    }

/*****************************************************************************

Routine Description:

    Add the key and the associated object. Add the new HashEntry at the end 
    of the list to give precedence to items added first.

Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T, size_t SIZE>
T HashTable<T, SIZE>::Add(DWORD key, T o)
    {
    size_t i = key % SIZE;
    
    if(!table[i])
        {
        table[i] = new HashEntry<T>(key, o);
        return o;
        }
    else
        {
        HashEntry<T> *h = table[i];
        do
            {
            // replace entry with the same key
            if(h->key == key)
                {
                if(clean) clean(h->key, &(h->obj), NULL);
                h->obj = o;
                return o;
                }

            // otherwise add it to the end
            if(!h->next)
                {
                h->next = new HashEntry<T>(key, o);
                return o;
                }

            h=h->next;
            } while(h);
        }

    return NULL;
    }

/*****************************************************************************

Routine Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T, size_t SIZE>
BOOL HashTable<T, SIZE>::ForAll(HASHOBJ_FUNC fn, void *param)
    {
    for(size_t i=0; i<SIZE; i++)
        {
        if(table[i]) 
            {
            for(HashEntry<T> *h = table[i]; h; h=h->next)
                {
                fn(h->key, &(h->obj), param);
                }
            }
        }
    return TRUE;
    }

} // namespace GhProfiler


#endif // _GHPROF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\ghprof\ghprof.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    GhProf.cpp

Abstract:

    The /Gh compiler flag inserts a call to __penter() at the beginning 
    of each function. 

    The __pexit() function is not explicitly called by the /Gh flag. So
    inside of __penter() we modify the return address to jump inside of our
    __pexit, call our cleanup function, then jump back to where it was 
    supposed to go in the first place. 

    WARNING!
        1.  penterAddStats MODIFIES the stack at where the return address 
            should be in relation to the base pointer.
        2.  This means that FPO (Frame-Pointer Omission) must NOT be enabled
        3.  Nothing is protected via semaphores, but here are the resons:
            a.  Blocking threads on our objects could drastically change the 
                normal behaviour of the code (we want to be as minimalistic 
                as possible).
            b.  Blocking the threads could easily intruduce deadlocks because
                of locks in the code we instrument.
            c.  We are on a single processor system so trashing of our 
                internal structures will be difficult.
        4.  Note that __pexit should NEVER be explicitly called, only jumped 
            to and only with the proper setup via our penterAddStats method.

    NOTES:
        1.  The following APIs will not be profiled:
                QueryPerformanceCounter
                GetCurrentThreadId
                DebugPrint
                ExAllocatePool
                ExFreePool
            Or any call from a high IRQ priority.

Author:

    jpoley

Environment:

    XBox

Revision History:

*/


#include <stdio.h>
#include <time.h>

#include "GhProf.h"

namespace GhProfiler {

//
// globals
//
static RetAddrStack addressStack[MAX_ADDR_STACKS];
static HashTable<MethodStats*, 64> penterStats(DestroyMethodStats);

/*****************************************************************************

Object Description:

    MethodStats

    This class keeps track of how many times an API has been called, as well
    as timing information
    
Methods:


Properties:


Notes:

    DestroyMethodStats and PrintStats are non-member helper functions.    

*****************************************************************************/
MethodStats::MethodStats()
    {
    hitCount = 0;
    exitCount = 0;
    failures = 0;
    runningTime.QuadPart = 0;
    penterTime.QuadPart = 0;
    childTime.QuadPart = 0;
    maxTime.QuadPart = 0;
    minTime.QuadPart = ~0;
    }


// Called by the HashTable to clean up the entries
// As per the cleanup function
static void DestroyMethodStats(DWORD key, void *p, void *param)
    {
    if(!p) return;
    MethodStats *v = *(MethodStats**)p;
    delete v;
    }

static void PrintStats(DWORD key, void *p, void *param)
    {
    if(!p) return;

    MethodStats *v = *(MethodStats**)p;
    FILE* f = (FILE*)param;
    fprintf(f, "%08x, %5lu, %5lu, %5lu, %8I64u, %8I64u, %8I64u, %8I64u, %8I64u\n", key, v->hitCount, v->exitCount, v->failures, v->runningTime.QuadPart/v->hitCount, v->maxTime.QuadPart, v->minTime.QuadPart==~0?0:v->minTime.QuadPart, v->penterTime.QuadPart/v->hitCount, v->childTime.QuadPart/v->hitCount);
    }


/*****************************************************************************

Object Description:

    RetAddrStack

    This class contains a stack of return addresses. We need to save this 
    information so we can modify the return value on the stack and then later
    jump to that address.

    This class is used in an array so we can keep thread call stacks seperate.
    
Methods:


Properties:


Notes:

    DestroyMethodStats and PrintStats are non-member helper functions.    

*****************************************************************************/
RetAddrStack::RetAddrStack()
    {
    threadContext = 0;
    length = 0;
    maxLength = 0;
    }

RetAddrStack::~RetAddrStack()
    {
    delete[] stack;
    }

inline void RetAddrStack::Init(void)
    {
    maxLength = 32;
    stack = new PenterCallStack[maxLength];
    }

void RetAddrStack::Grow(void)
    {
    unsigned i;
    PenterCallStack *temp;

    maxLength *= 2;

    temp = new PenterCallStack[maxLength];
    for(i=0; i<length; i++)
        {
        temp[i] = stack[i];
        }
    delete[] stack;
    stack = temp;
    }

unsigned RetAddrStack::Push(void)
    {
    if(length >= maxLength)
        {
        if(maxLength == 0) Init();
        else Grow();
        }

    return length++;
    }

unsigned RetAddrStack::Pop(void)
    {
    if(length == 0)
        {
        return ~0;
        }

    if(length == 1)
        {
        threadContext = 0;
        }

    return --length;
    }

unsigned RetAddrStack::GetAddress(void)
    {
    if(length < 1)
        {
        return 0;
        }

    return stack[length-1].methodAddress;
    }

RetAddrStack* FindThreadAddrStack(void)
    {
    DWORD thread = GetCurrentThreadId();
    RetAddrStack *firstBlank = NULL;

    // scan through the entire list looking for a match
    for(unsigned i=0; i<MAX_ADDR_STACKS; i++)
        {
        if(addressStack[i].threadContext == thread)
            {
            return &addressStack[i];
            }
        if(!firstBlank && addressStack[i].threadContext == 0)
            {
            firstBlank = &addressStack[i];
            }
        }

    if(firstBlank) firstBlank->threadContext = thread;
    return firstBlank;
    }

} // namespace GhProfiler


/*****************************************************************************

Routine Description:

    penterAddStats
    
    This method is called via __penter() which logs the calling API address,
    and modifies the return addresses on the stack to call __pexit().

        stack[0] == the address of the calling API (+ a small offset)
        stack[1] == is where the API was called from (the return address)

Arguments:

    None

Return Value:

    No return value

*****************************************************************************/
void __stdcall penterAddStats(void)
    {
    using namespace GhProfiler;
    unsigned base;
    unsigned index;
    LARGE_INTEGER time1, time2;

    // skip high priority items
    if(KeGetCurrentIrql() > DISPATCH_LEVEL) return;

    __asm mov base, ebp; // grab our base pointer

    base += 40; // +40 moves from our base ptr to __penter's stack ptr
                // 32 from pushad in __penter, 8 from stack offset in this api

    unsigned *stack = (unsigned*)base;
    unsigned callerAddress = stack[0]-5; // -5 for the "call __penter" offset

    // any API that we call cannot be instrumented - if it is we bail
    if(callerAddress == (unsigned)QueryPerformanceCounter) return;
    if(callerAddress == (unsigned)GetCurrentThreadId) return;
    if(callerAddress == (unsigned)DebugPrint) return;
    if(callerAddress == (unsigned)ExAllocatePool) return;
    if(callerAddress == (unsigned)ExFreePool) return;

    QueryPerformanceCounter(&time1);

    // log the API call
    MethodStats* method;
    if(!penterStats.Get(callerAddress, method))
        {
        method = penterStats.Add(callerAddress, new MethodStats());
        }
    ++method->hitCount;

    // modify the return address on the stack to merge in the __pexit() code
    RetAddrStack *addrStack = FindThreadAddrStack();
    if(addrStack)
        {
        index = addrStack->Push();
        addrStack->stack[index].returnAddress = stack[1];
        addrStack->stack[index].methodAddress = callerAddress;
        stack[1] = (unsigned)&_pexit;

        QueryPerformanceCounter(&time2);
        addrStack->stack[index].startTime.QuadPart = time2.QuadPart;
        addrStack->stack[index].penterTime.QuadPart = (unsigned __int64)time2.QuadPart - (unsigned __int64)time1.QuadPart;
        }
    else
        {
        ++method->failures;
        }
    }


/*****************************************************************************

Routine Description:

    penterCleanup
    
    This method is called via __pexit() which logs the calling API end time,
    and returns to the appropriate caller.

Arguments:

    None

Return Value:

    unsigned - returns the original return address of the function this
        value gets passed back to __pexit() so it can restore the program
        flow.

*****************************************************************************/
unsigned __stdcall penterCleanup(void)
    {
    using namespace GhProfiler;
    LARGE_INTEGER curTime, penterTime, time1, time2;

    QueryPerformanceCounter(&time1);

    // find the return address
    unsigned index;
    RetAddrStack *addrStack = FindThreadAddrStack();
    if(!addrStack || (index=addrStack->Pop()) == ~0)
        {
        // We got to penterCleanup, so the stack was modified. But we were
        // unable to get the actual return address, so something very very
        // bad happened, and we dont know where to return to.
        DebugPrint("penterCleanup: ABOUT TO JUMP TO OZ!!!!!\n");
        __asm int 3;
        return 0;
        }

    // update the stats for the method
    MethodStats* method;
    if(penterStats.Get(addrStack->stack[index].methodAddress, method))
        {
        ++method->exitCount;

        curTime.QuadPart = (unsigned __int64)time1.QuadPart - (unsigned __int64)addrStack->stack[index].startTime.QuadPart;
        method->runningTime.QuadPart += (unsigned __int64)curTime.QuadPart;
        if((unsigned __int64)curTime.QuadPart > (unsigned __int64)method->maxTime.QuadPart) method->maxTime.QuadPart = curTime.QuadPart;
        if((unsigned __int64)curTime.QuadPart < (unsigned __int64)method->minTime.QuadPart) method->minTime.QuadPart = curTime.QuadPart;

        MethodStats *parent = NULL;
        penterStats.Get(addrStack->GetAddress(), parent);

        QueryPerformanceCounter(&time2);
        penterTime.QuadPart = (unsigned __int64)time2.QuadPart - (unsigned __int64)time1.QuadPart + (unsigned __int64)addrStack->stack[index].penterTime.QuadPart;
        method->penterTime.QuadPart += penterTime.QuadPart;

        if(parent)
            {
            parent->childTime.QuadPart += (unsigned __int64)penterTime.QuadPart + (unsigned __int64)curTime.QuadPart;
            }
        }

    // __pexit will jump to the 'pexitRetAddr' address 
    return addrStack->stack[index].returnAddress;
    }


/*****************************************************************************

Routine Description:

    penterDumpStats
    
    This method logs out all the stats currently in memory

Arguments:

    None

Return Value:

    No return value

*****************************************************************************/
void __stdcall penterDumpStats(void)
    {
    using namespace GhProfiler;
    char dbuffer[9];
    char tbuffer[9];
    _strdate(dbuffer);
    _strtime(tbuffer);

    LARGE_INTEGER freq;
    freq.QuadPart = 0;
    QueryPerformanceFrequency(&freq);

    FILE *f = fopen("t:\\GhProf.log", "a+");
    if(f)
        {
        fprintf(f, "[%s, %s] *********************************************************\n", dbuffer, tbuffer);
        fprintf(f, "Freq=%I64u\n", (unsigned __int64)freq.QuadPart);
        fprintf(f, " Address, Count,  Exit, Error, Avg Time, Max Time, Min Time,  Gh Time, ChldTime\n");
        penterStats.ForAll(PrintStats, (void*)f);
        fclose(f);
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\gamepusher\XbServer\xbserver.cpp ===
/*************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

	xbserver.cpp

  Abstract:

	Defines the GamePusher Xbox "server" side functions which allow file data and information to be
	received from a broadcasting PC.

  Author:

	Mabel Santos (t-msanto) 03-Dec-2001

  Revision History:

*************************************************************************************************/

#include "xbserver.h"

XbServer* Server;
int DebugOn;

// CRC table
static const unsigned long CRCs[] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

/*************************************************************************************************

Routine Description:

	Default XbServer constructor.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

XbServer::XbServer(void)
{
	GraphicPrint("Creating XbServer object\n");

	// flash LED green to indicate that app has started
	WriteSMC(0x08, 0x0A);
	WriteSMC(0x07, 0x01);
	
	// set socket to invalid
	ServerSock = INVALID_SOCKET;
	DebugPrint("Set socket to invalid\n");

	// set WinSock flag to false
	WsaInitialized = false;
	DebugPrint("Set WinSock flag to false\n");

	// set error flag to 0
	ErrorFlag = 0;
	DebugPrint("Set error flag to 0\n");

	// set exit flag to false
	ExitFlag = false;
	DebugPrint("Set exit flag to false\n");

	// set byte counters to 0
	TotalBytes = 0;
	RecvdBytes = 0;
	DebugPrint("Set byte counters to 0\n");

	// set packet-tracking variables to 0
	BasePkt = 0;
	NumPkts = 0;
	RecvdPkts = 0;
	DebugPrint("Set packet-tracking variables to 0\n");

	// set filestream to null
	OutFile = NULL;
	DebugPrint("Set filestream to null\n");
	
	// set name buffer contents to null
	memset(NameBuf, '\0', sizeof(NameBuf));
	DebugPrint("Set name buffer contents to null\n");
}

/*************************************************************************************************

Routine Description:

	Default XbServer destructor.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

XbServer::~XbServer(void)
{
	GraphicPrint("Deleting XbServer object\n");

	// close socket and clean up if needed
	if(ServerSock != INVALID_SOCKET)
	{
		closesocket(ServerSock);
	}

	if(WsaInitialized)
	{
		WSACleanup();
	}
}

/*************************************************************************************************

Routine Description:

	PrepareWinSock

	Initializes WinSock.  Creates a UDP socket for listening on port 2000 and binds the Xbox
	server to it.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
XbServer::PrepareWinSock(void)
{
	GraphicPrint("Preparing WinSock\n");

	// initialize WinSock
	WORD Version = MAKEWORD(2,2);
	WSADATA WsaData;
	WSAStartup(Version, &WsaData);
	WsaInitialized = true;
	DebugPrint("Initialized WinSock\n");

	// create a UDP datagram socket
	ServerSock = socket(AF_INET, SOCK_DGRAM, 0);
	DebugPrint("Created UDP datagram socket\n");
	
	if(ServerSock == INVALID_SOCKET && WSAGetLastError() == WSANOTINITIALISED) // 10093
	{
		WSAStartup(Version, &WsaData);
		WsaInitialized = true;
		DebugPrint("Initialized WinSock a second time\n");
		ServerSock = socket(AF_INET, SOCK_DGRAM, 0);
		DebugPrint("Created UDP datagram socket a second time\n");
	}

	// try to increase receive buffer size
	int Size, BufSize = 0;
	int Err, Res;
	
	// start with 64K, then cut buffer size in half if necessary until request is granted
	for(Size = 65536; Size > 16384; Size >>=1)
	{
		// if got a socket error, try again with a smaller size
		if(setsockopt(ServerSock, SOL_SOCKET, SO_RCVBUF, (char*)&Size, sizeof(int)) == SOCKET_ERROR)
		{
			Err = WSAGetLastError();
			// if option is not supported, break out of loop
			if(Err == WSAENOPROTOOPT || Err == WSAEINVAL) break;
		}
		else
		{
			// reaching here means buffer size was successfully changed
			break;
		}
	}
	Res = sizeof(int);
	getsockopt(ServerSock, SOL_SOCKET, SO_RCVBUF, (char*)&BufSize, &Res);
	DebugPrint("Receive buffer size = %d bytes\n", BufSize);

	// fill in address structure
	SOCKADDR_IN ServerAddr;
	ServerAddr.sin_family = AF_INET;
	ServerAddr.sin_port = htons(PORT);
	ServerAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	DebugPrint("Filled in address structure\n");

	// bind name to socket
	if(bind(ServerSock, (SOCKADDR*)&ServerAddr, sizeof(SOCKADDR)) == SOCKET_ERROR)
	{
		DebugPrint("SOCKET ERROR in PrepareWinSock(): bind()\n");
		OutputDebugString("SOCKET ERROR in PrepareWinSock(): bind()\n");
		return false;
	}
	else 
	{
		DebugPrint("Bound name to socket\n");
	}
	return true;
}

/*************************************************************************************************

Routine Description:

	MapDrives

	Creates symbolic links to areas on the hard disk so they can be accessed using drive letters.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
XbServer::MapDrives(void)
{
	GraphicPrint("Mapping drives\n");

	DWORD Res;

	// map C drive
	Res = MapDrive('C', "\\Device\\Harddisk0\\Partition1");
	if(Res == 0)
	{
		DebugPrint("Mapped Drive C\n");
	}
	else
	{
		DebugPrint("Mapping drive C failed with error code %d\n", Res);
	}

	// map Y drive
	Res = MapDrive('Y', "\\Device\\Harddisk0\\Partition2");
	if(Res == 0)
	{
		DebugPrint("Mapped Drive Y\n");
	}
	else
	{
		DebugPrint("Mapping drive Y failed with error code %d\n", Res);
	}

	// create directories needed to map drives E and S
	CreateDirectory("C:\\devkit", NULL);
	CreateDirectory("C:\\TDATA", NULL);

	// map E drive
	Res = MapDrive('E', "\\Device\\Harddisk0\\Partition1\\devkit");
	if(Res == 0)
	{
		DebugPrint("Mapped Drive E\n");
	}
	else
	{
		DebugPrint("Mapping drive E failed with error code %d\n", Res);
	}

	// map S drive
	Res = MapDrive('S', "\\Device\\Harddisk0\\Partition1\\TDATA");
	if(Res == 0)
	{
		DebugPrint("Mapped Drive S\n");
	}
	else
	{
		DebugPrint("Mapping drive S failed with error code %d\n", Res);
	}
}

/*************************************************************************************************

Routine Description:

	SendReply

	Waits for a message and sends a response to let the PC know that this Xbox is in a listening
	state.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
XbServer::SendReply(void)
{
	char ReplyBuf[BUFFLEN];
	SOCKADDR_IN DestAddr;
	int Result;
	int AddrSize = sizeof(SOCKADDR_IN);
	DebugPrint("Waiting for message from GamePusher\n");
	GraphicPrint("Waiting for message from GamePusher\n");

	TIMEVAL Timeout;
	FD_SET Bucket;

	do
	{ 
		Bucket.fd_count = 1;
		Bucket.fd_array[0] = ServerSock;
		Timeout.tv_sec = 5;
		Timeout.tv_usec = 0;

		// wait for message from client
		Result = select(0, &Bucket, NULL, NULL, &Timeout);
		
		if(Result == SOCKET_ERROR)
		{
			DebugPrint("SOCKET ERROR in select()\n");
			OutputDebugString("SOCKET ERROR in SendReply(): select()\n");
			return false;
		}
		
	} while(Result == 0); // try again if hit timeout

	// grab message
	Result = recvfrom(ServerSock, ReplyBuf, sizeof(ReplyBuf), 0, (SOCKADDR*)&DestAddr, &AddrSize);	  
	
	if(Result == SOCKET_ERROR)
	{
		DebugPrint("SOCKET ERROR in recvfrom()\n");
		OutputDebugString("SOCKET ERROR in SendReply(): recvfrom()\n");
		return false;
	}

	DebugPrint("Received message from GamePusher\n");
	GraphicPrint("Received message from GamePusher\n");

	if(ReplyBuf)
	{
		// if message contains total number of bytes to be received, store the value
		TotalBytes = strtoul(ReplyBuf, NULL, 10);
		GraphicPrint("Total bytes to be received: %u\n", TotalBytes);
	}
	
	// reply with machine name so client knows which Xbox responded
	DWORD Len = BUFFLEN;

	// keep track of machine name so we can rename the box later
	DmGetXboxName(NameBuf, &Len);
	DebugPrint("Got Xbox name: %s\n", NameBuf);
	GraphicPrint("Got Xbox name: %s\n", NameBuf);
	
	Result = sendto(ServerSock, NameBuf, strlen(NameBuf), 0, (SOCKADDR*)&DestAddr, sizeof(SOCKADDR));	

	if(Result == SOCKET_ERROR)
	{
		DebugPrint("SOCKET ERROR in recvfrom()\n");
		OutputDebugString("SOCKET ERROR in SendReply(): recvfrom()\n");
		return false;
	}

	DebugPrint("Sent response back to GamePusher\n");
	GraphicPrint("Sent response back to GamePusher\n");
	return true;
}

/*************************************************************************************************

Routine Description:

	RecvFiles

	Receives file data and commands through the network.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
XbServer::RecvFiles(void)
{
	char RecvBuf[sizeof(FilePacketHeader) + BUFFLEN];
	FilePacket* RecvPkt = (FilePacket*)RecvBuf;
	SOCKADDR_IN SrcAddr;
	int Result;
	int AddrSize = sizeof(SOCKADDR_IN);
	DebugPrint("Waiting to receive files\n");
	GraphicPrint("Waiting to receive files\n");

	TIMEVAL Timeout;
	FD_SET Bucket;

	while(!ErrorFlag && !ExitFlag) // keep going as long as error condition hasn't occurred
								   // and there is still more data to be received
	{
		Bucket.fd_count = 1;
		Bucket.fd_array[0] = ServerSock;
		Timeout.tv_sec = 5;
		Timeout.tv_usec = 0;

		// clear buffer
		memset(RecvBuf, '\0', sizeof(RecvBuf));

		// wait for data packet from client
		Result = select(0, &Bucket, NULL, NULL, &Timeout);

		if(Result == 0) continue; // timed out so try again
		
		if(Result == SOCKET_ERROR)
		{
			DebugPrint("SOCKET ERROR in select()\n");
			OutputDebugString("SOCKET ERROR in RecvFiles(): select()\n");
			break;
		}

		// grab data packet
		Result = recvfrom(ServerSock, RecvBuf, sizeof(RecvBuf), 0, (SOCKADDR*)&SrcAddr, &AddrSize);	  
		
		if(Result == 0)
		{
			// no more data
			DebugPrint("No more data. Breaking out of loop...\n");
			break;
		}

		if(Result == SOCKET_ERROR)
		{
			DebugPrint("SOCKET ERROR in recvfrom()\n");
			OutputDebugString("SOCKET ERROR in RecvFiles(): recvfrom()\n");
			break;
		}

		// process data packet
		ReadPacket(RecvPkt);
	}

	// check if we broke out of loop prematurely because of an error condition
	if(ErrorFlag)
	{
		// if so, flash the LED
		FlashLED();
	}
}

/*************************************************************************************************

Routine Description:

	ReadPacket

	Reads a data packet and responds according to its packet type.
	FILEDESC: create directories if needed and start new file
	FILEDATA: write file data to hard drive
	FILEDONE: close filestream and check if all packets have been received

Arguments:

	FilePacket* Packet	-	packet to be read
							
Return Value:

	none

*************************************************************************************************/

void
XbServer::ReadPacket(FilePacket* Packet)
{
	// display packet contents
	//DebugPrint("PacketType: %d\n", Packet->PacketType);
	//DebugPrint("SequenceNo: %d\n", Packet->SequenceNo);
	//DebugPrint("DataSize: %d\n", Packet->DataSize);
	//DebugPrint("Crc: %d\n", Packet->Crc);
	//if(Packet->Data) DebugPrint("Data: %s\n", Packet->Data);

	// if CRC does not match, set flag and return
	int Crc = GetCRC((unsigned char*)Packet->Data, Packet->DataSize);
	if(Crc != Packet->Crc)
	{
		DebugPrint("ERROR: GetCRC(Packet->Data, Packet->DataSize)(%d) != Packet->Crc(%d)\n", Crc, Packet->Crc);
		DebugPrint("Setting error flag to indicate checksum error...\n");
		ErrorFlag = CHKSMERROR;
		OutputDebugString("ERROR in ReadPacket(): CRCs do not match\n");
		return;
	}

	switch(Packet->PacketType)
	{
		case FILEDONE: // packet contains finish message

			// check if all previous packets have been received
			if(!CheckPkts()) return;

			// set exit flag to indicate that we're done
			ExitFlag = true;
			
			// unmap drives
			UnMapDrives();
			break;

		case FILEDESC: // packet contains file description
			
			// check if all previous packets have been received
			if(!CheckPkts()) return;

			// create any directories in the file path that do not exist
			// if there is a problem with creating a directory, set flag and return
			if(!CreateDirs(Packet->Data)) return;

			// open new filestream
			OutFile = fopen(Packet->Data, "wb");

			// if there is a problem with opening the file, set flag and return
			if(!OutFile)
			{
				DebugPrint("ERROR: Could not start new file %s\n", Packet->Data);
				DebugPrint("Setting error flag to indicate file error...\n");
				ErrorFlag = FILEERROR;
				OutputDebugString("ERROR in ReadPacket(): Could not start new file\n");
				return;	
			}

			// reaching here means file was opened successfully
			DebugPrint("Started new file: %s\n", Packet->Data);
			//GraphicPrint("%s\n", Packet->Data);

			// reset packet-tracking variables
			StartFile(Packet->FileSize, Packet->SequenceNo);
			break;
			
		case FILEDATA: // packet contains file data

			// check if packet belongs to the same file
			DWORD Offset = Packet->SequenceNo - BasePkt - 1;
			//DebugPrint("Offset: %d\n", Offset);
			if(Offset >= NumPkts)
			{
				// if packet is from another file, set error flag and return
				DebugPrint("ERROR: Packet belongs to another file\n");
				DebugPrint("Setting error flag to indicate packet error...\n");
				ErrorFlag = PKTERROR;
				OutputDebugString("ERROR in ReadPacket(): Packet belongs to another file\n");
				return;
			}

			// write file data to hard drive
			// set file position according to packet's sequence number
			fseek(OutFile, Offset*BUFFLEN, SEEK_SET);
			size_t WriteRes = fwrite(Packet->Data, sizeof(char), Packet->DataSize, OutFile);

			// if there is a problem with writing to the file, set flag and return
			if(WriteRes < Packet->DataSize) 
			{
				DebugPrint("ERROR: Could not write data to file\n");
				DebugPrint("Setting error flag to indicate file error...\n");
				ErrorFlag = FILEERROR;
				OutputDebugString("ERROR in ReadPacket(): Could not write data to file\n");
				return;
			}
			// reaching here means data was properly written
			//DebugPrint("Wrote %dB of data to file\n", WriteRes);
			//DebugPrint("Wrote %dB of data to file: %s\n", WriteRes, Packet->Data);

			// increment received byte counter
			RecvdBytes += Packet->DataSize;

			if(TotalBytes > 0)
				GraphicPrint("Receiving files: %.2f%% done\n", RecvdBytes/(TotalBytes*0.01));

			// increment received packet counter
			++RecvdPkts;
			//DebugPrint("Incremented received packet counter to %d\n", RecvdPkts);
			break;
	}
}

/*************************************************************************************************

Routine Description:

	CheckPkts

	Checks if all data packets for the most recent file have been received.

Arguments:

	none

Return Value:

	BOOL	-	true if all packets have been received; false otherwise

*************************************************************************************************/

BOOL
XbServer::CheckPkts(void)
{
	// if there is an open filestream, close it
	if(OutFile) 
	{
		fclose(OutFile);
		OutFile = NULL;
	}

    // check if all packets for the previous file have been received
    if(RecvdPkts != NumPkts)
    {
		DebugPrint("ERROR: Not all packets received for previous file\n");
		DebugPrint("Setting error flag to indicate packet error...\n");
		ErrorFlag = PKTERROR;
		OutputDebugString("ERROR in CheckPkts(): Not all packets received for previous file\n");
		return false;
    }

	// reaching here means all packets have been received
	DebugPrint("Done receiving file\n");
	//GraphicPrint("Done receiving file\n");
	return true;
}

/*************************************************************************************************

Routine Description:

	StartFile

	Prepares to receive a new file by resetting all packet-tracking variables.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
XbServer::StartFile(DWORD FileSize, DWORD PktNum)
{
	BasePkt = PktNum;
	DebugPrint("BasePkt: %d\n", BasePkt);
	DebugPrint("FileSize: %d bytes\n", FileSize);
	NumPkts = FileSize/BUFFLEN + (FileSize%BUFFLEN > 0 ? 1 : 0);
	DebugPrint("NumPkts: %d\n", NumPkts);
	RecvdPkts = 0;
	//DebugPrint("RecvdPkts: %d\n", RecvdPkts);
}

/*************************************************************************************************

Routine Description:

	CreateDirs

	Steps through a given path and creates any directories that do not already exist.

Arguments:

	char* PathName	-	path to be traversed

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
XbServer::CreateDirs(char* PathName)
{
	unsigned int Start, End;
	
	// step through each directory in the path
	for(Start = 0, End = strcspn(PathName, "\\") + 1;
		End < strlen(PathName);
		Start = End, End = strcspn(PathName+Start, "\\") + Start + 1)
	{
		char Temp = PathName[End];
		PathName[End] = '\0';
		DebugPrint("CurrDir: %s\n", PathName);
		
		// try to create directory
		if(!CreateDirectory(PathName, NULL))
		{	
			// if directory does not exist but can not be created, set error flag and return
			if(GetLastError() != ERROR_ALREADY_EXISTS)
			{
				DebugPrint("ERROR: Could not create directory %s\n", PathName);
				ErrorFlag = DIRERROR;
				OutputDebugString("ERROR in CreateDirs(): Could not create directory\n");
				return false;
			}
			else // directory already exists, so no harm done
			{
				//DebugPrint("Directory %s already exists\n", PathName);
			}
		}
		else
		{
			// reaching here means directory did not exist and was created successfully
			DebugPrint("Created new directory: %s\n", PathName);
			//GraphicPrint("Created new directory: %s\n", PathName);
		}
		PathName[End] = Temp;
	}
	return true;
}

/*************************************************************************************************

Routine Description:

	UnMapDrives

	Removes symbolic links to areas on the hard disk that allow them to be accessed using drive
	letters.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
XbServer::UnMapDrives(void)
{
	GraphicPrint("Unmapping drives\n");

	DWORD Res;

	// unmap C drive
	Res = UnMapDrive('C');
	if(Res == 0)
	{
		DebugPrint("Unmapped Drive C\n");
	}
	else
	{
		DebugPrint("Unmapping drive C failed with error code %d\n", Res);
	}
	
	// unmap Y drive
	Res = UnMapDrive('Y');
	if(Res == 0)
	{
		DebugPrint("Unmapped Drive Y\n");
	}
	else
	{
		DebugPrint("Unmapping drive Y failed with error code %d\n", Res);
	}

	// unmap E drive
	Res = UnMapDrive('E');
	if(Res == 0)
	{
		DebugPrint("Unmapped Drive E\n");
	}
	else
	{
		DebugPrint("Unmapping drive E failed with error code %d\n", Res);
	}

	// unmap S drive
	Res = UnMapDrive('S');
	if(Res == 0)
	{
		DebugPrint("Unmapped Drive S\n");
	}
	else
	{
		DebugPrint("Unmapping drive S failed with error code %d\n", Res);
	}
}

/*************************************************************************************************

Routine Description:

	FlashLED

	Makes the Xbox LED flash red to indicate that an error has occurred.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
XbServer::FlashLED(void)
{
	DebugPrint("Error encountered:\n");
	OutputDebugString("Error encountered:\n");

	switch(ErrorFlag)
	{

	case PKTERROR:
		DebugPrint("Packet missing or out of order\n");
		OutputDebugString("Packet missing or out of order\n");
		GraphicPrint("Packet missing or out of order\n");
		// flash LED red
		//WriteSMC(0x08, 0xA0);
		//WriteSMC(0x07, 0x01);
		break;
	
	case CHKSMERROR:
		DebugPrint("Packet CRCs do not match\n");
		OutputDebugString("Packet CRCs do not match\n");
		GraphicPrint("Packet CRCs do not match\n");
		// flash LED orange
		//WriteSMC(0x08, 0xAA);
		//WriteSMC(0x07, 0x01);
		break;

	case DIRERROR:
		DebugPrint("Directory not created\n");
		OutputDebugString("Directory not created\n");
		GraphicPrint("Directory not created\n");
		// flash LED green
		//WriteSMC(0x08, 0x0A);
		//WriteSMC(0x07, 0x01);
		break;

	case FILEERROR:
		DebugPrint("File not written\n");
		OutputDebugString("File not written\n");
		GraphicPrint("File not written\n");
		// flash LED red and orange
		//WriteSMC(0x08, 0xF5);
		//WriteSMC(0x07, 0x01);
		break;

	case KRNLERROR:
		DebugPrint("Kernel not received\n");
		OutputDebugString("Kernel not received\n");
		GraphicPrint("Kernel not received\n");
		// flash LED orange and green
		//WriteSMC(0x08, 0xAF);
		//WriteSMC(0x07, 0x01);
		break;

	case FLASHERROR:
		DebugPrint("ROM not flashed\n");
		OutputDebugString("ROM not flashed\n");
		GraphicPrint("ROM not flashed\n");
		// flash LED red and green
		//WriteSMC(0x08, 0xA5);
		//WriteSMC(0x07, 0x01);
		break;

	default:
		DebugPrint("Socket error, format error or flash error\n");
		OutputDebugString("Socket error, format error or flash error\n");
		GraphicPrint("Socket error, format error or flash error\n");
		break;
	}
	// flash LED red to indicate that an error has been encountered
	WriteSMC(0x08, 0xA0);
	WriteSMC(0x07, 0x01);
	UnMapDrives();
	Sleep(INFINITE);
}

/*************************************************************************************************

Routine Description:

	GetCRC

	Determines the CRC for the specified data.

Arguments:

	unsigned char* Data	-	data whose CRC is to be determined
	WORD Size			-	size of data

Return Value:

	DWORD	-	CRC for data

*************************************************************************************************/

DWORD
XbServer::GetCRC(unsigned char* Data, WORD Size)
{
	DWORD Result = 0;
	DWORD Shift = 0;
	DWORD Index = 0;

	while(Size--)
	{	
		Result = (Result >> 8) ^ CRCs[(BYTE)(Result ^ *Data++)];
	}
	return Result;
}

/*************************************************************************************************

Routine Description:

	DebugPrint

	Prints a line to standard output if the DebugOn flag is set.

Arguments:

	char* ptszFormat, ...	-	format string	

Return Value:

	none

*************************************************************************************************/

void
DebugPrint(char *ptszFormat, ...)
{
	if(DebugOn)
	{
		char tszBuf[BUFFLEN];
		va_list arglist;

		va_start( arglist, ptszFormat );
		_vsnprintf( tszBuf, sizeof(tszBuf), ptszFormat, arglist );
		OutputDebugStringA( tszBuf );
		va_end(arglist);
	}
}

/*************************************************************************************************

Routine Description:

	main function

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void main(void)
{	
	DebugOn = 0;

	InitGraphics();

	XNetStartupParams xnsp = { sizeof(XNetStartupParams), XNET_STARTUP_BYPASS_SECURITY, 255};
    int nXnetResult = XNetStartup( &xnsp );
    if(nXnetResult != NO_ERROR)
    {
		DebugPrint("XNetStartup() Error: %u\n", nXnetResult);
		GraphicPrint("XNetStartup() Error: %u\n", nXnetResult);
    }
	// sleep for 5 secs because sockets are not fully initialized immediately after call to
	// XNetStartup()
    Sleep(5000);

	// make an XbServer object
	Server = new XbServer;

	// set up network stuff
	if(!Server->PrepareWinSock())
	{
		Server->FlashLED();
		Sleep(INFINITE);
	}

	// map drives
	Server->MapDrives();

	// notify client that this box is listening
	if(!Server->SendReply())
	{
		Server->FlashLED();
		Sleep(INFINITE);
	}

	// wait to receive files from network
	Server->RecvFiles();

	// notify client that this box is done receiving files
	if(!Server->SendReply())
	{
		Server->FlashLED();
		Sleep(INFINITE);
	}

	// delete XbServer object
	delete Server;

	GraphicPrint("Done receiving files. Waiting for reboot...\n");
	Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\ghprofiler\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	GhProfiler.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\ghprofiler\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__60722720_7F94_4103_9FFA_6ED768717F89__INCLUDED_)
#define AFX_STDAFX_H__60722720_7F94_4103_9FFA_6ED768717F89__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <stdio.h>
#include <io.h>
#include <windows.h>
#include <Dbghelp.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__60722720_7F94_4103_9FFA_6ED768717F89__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\ghprof\i386\ghentry.asm ===
;*****************************************************************************
;Copyright (c) 2000  Microsoft Corporation
;
;Module Name:
;
;    GhEntry.asm
;
;Abstract:
;
;       The /Gh compiler flag inserts a call to __penter() at the beginning 
;   of each function. The catch is that it follows the __stdcall naming 
;   convention, but requires the __cdecl stack cleanup.
;       Thus we must write it in asm. And for my own sanity we just call a C
;   function.
;
;       The __pexit() function is not explicitly called by the /Gh flag. So
;   inside of __penter() we modify the return address to jump inside of our
;   __pexit, call our cleanup function, then jump back to where it was 
;   supposed to go in the first place. Note that __pexit should NEVER be
;   called, only jumped to and only with the proper setup via our __penter
;   method.
;
;Author:
;
;    jpoley
;
;Environment:
;
;    XBox
;
;Revision History:
;
;*****************************************************************************

.586p

    ; extern C++ worker functions
    EXTRN ?penterAddStats@@YGXXZ:PROC
    EXTRN ?penterCleanup@@YGIXZ:PROC

    ; function declarations
    PUBLIC __penter
    PUBLIC __pexit

_TEXT SEGMENT WORD PUBLIC 'CODE'


__penter PROC
    pushad                          ; push the registers
    call ?penterAddStats@@YGXXZ     ; call our worker function
    popad                           ; restore the registers
    ret                             ; all done
__penter ENDP


__pexit PROC
    sub esp, 4                  ; save room for the return address
    pushad                      ; we save the registers and flags cause we
    pushfd                      ; need to act like we were never here
    call ?penterCleanup@@YGIXZ  ; call the api that does all the work
    mov [esp+36], eax           ; save the return addr on the stack for 'ret'
    popfd                       ; restore flags
    popad                       ; and registers
    ret                         ; jump to the original return address
__pexit ENDP


_TEXT ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\harness\logging.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    logging.h

Abstract:

    This module contains routine to initialize logging engine

--*/

#ifndef __LOGGING_H__
#define __LOGGING_H__

#ifdef __cplusplus
extern "C" {
#endif

BOOL
WINAPI
HarnessInitializeLogging(
    VOID
    );

BOOL
WINAPI
HarnessShutdownLogging(
    VOID
    );

BOOL
HarnessLog(
    DWORD LogLevel,
    LPSTR Format,
    ...
    );

#ifdef __cplusplus
}
#endif

#endif // __LOGGING_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\harness\precomp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    precomp.h

Abstract:

    Pre-compile header file

--*/

#define _XBDM_ // we do this so we can poke at some debugger flags in the kernel

#include <ntos.h>
#include <bldr.h>
#include <bldr32.h>
#include <xapip.h>
#include <xboxp.h>
#include <xboxverp.h>

#include <stdio.h>
#include <xtl.h>
#include "xtestlib.h"
#include "xlog.h"
#include "harnessapi.h"

#define HARNESS_POOLTAG     'nraH'
#define ARRAY_SIZE( a )     (sizeof(a)/sizeof((a)[0]))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\harness\init.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    init.c

Abstract:

    Entry point and initialization routines for test harness

--*/

#include "precomp.h"
#include "loader.h"
#include "logging.h"
#include "xlaunch.h"

volatile BOOL HarnessQuitFlag = FALSE;
SIZE_T DriveCount = 0;

//
// Unhandled Exception Filter
//

LPTOP_LEVEL_EXCEPTION_FILTER PreviousExceptionFilter;

//
// Current fscache size in bytes
//

SIZE_T HarnessCurrentCacheSize;

LONG
WINAPI
HarnessUnhandledExceptionFilter(
    LPEXCEPTION_POINTERS ExceptionInfo
    )
{
    int x = 0;
    int offset = 0;
    DWORD probe;
    BOOL ProbeFlag = FALSE;

    DbgPrint(
        "HARNESS: Unhandled exception 0x%x (%s)\n  type \"!cxr 0x%p; !kb\" to get stack trace\n\n",
        ExceptionInfo->ExceptionRecord->ExceptionCode,
        NtStatusSymbolicName(ExceptionInfo->ExceptionRecord->ExceptionCode),
        ExceptionInfo->ContextRecord
        );

    //
    // print out the entire excetion record and context to make debugging easier 
    // if a machine barfs and the serial dies
    // the exception information in the msvc system has more info, explore using this if neccessary
    //
    
    DbgPrint(
        "HARNESS: complete exception information:\nException Record:\n"   \
        "\tExceptionCode        0x%8.8x (%s)\n"    \
        "\tContextRecord:       0x%8.8x\n"         \
        "\tExceptionRecord:     0x%8.8x\n",
        ExceptionInfo->ExceptionRecord->ExceptionCode,
        NtStatusSymbolicName(ExceptionInfo->ExceptionRecord->ExceptionCode),
        ExceptionInfo->ContextRecord,
        ExceptionInfo->ExceptionRecord);
    
    DbgPrint(
        "HARNESS: Context Record:\n"  \
        "\tEax=%8.8x Ebx=%8.8x Ecx=%8.8x Edx=%8.8x Esi=%8.8x Edi=%8.8x\n" \
        "\tEip=%8.8x Esp=%8.8x Ebp=%8.8x EFlags=%8.8x\n" \
        "\tContextFlags=%8.8x\n" \
        "\tSegCs=%8.8x\n" \
        "\tSegSs=%8.8x\n" \
        "\tFloatSave=%8.8x\n",
        ExceptionInfo->ContextRecord->Eax,
        ExceptionInfo->ContextRecord->Ebx,
        ExceptionInfo->ContextRecord->Ecx,
        ExceptionInfo->ContextRecord->Edx,
        ExceptionInfo->ContextRecord->Esi,
        ExceptionInfo->ContextRecord->Edi,
        ExceptionInfo->ContextRecord->Eip,
        ExceptionInfo->ContextRecord->Esp,
        ExceptionInfo->ContextRecord->Ebp,
        ExceptionInfo->ContextRecord->EFlags,
        ExceptionInfo->ContextRecord->ContextFlags,
        ExceptionInfo->ContextRecord->SegCs,
        ExceptionInfo->ContextRecord->SegSs,
        ExceptionInfo->ContextRecord->FloatSave);

    //
    // stack dump from context ESP
    // probe it first
    // lots of hardcoded stuff, make flexable later
    //
    
    _try {
        probe = *(DWORD *)(ExceptionInfo->ContextRecord->Esp);
        probe = *(DWORD *)(ExceptionInfo->ContextRecord->Esp + 156);
    }
    _except(EXCEPTION_EXECUTE_HANDLER ) {
        ProbeFlag = TRUE;
    }
    
    if (FALSE == ProbeFlag) {
        DbgPrint("HARNESS: stack dump from context:\n");
        for (x = 0; x < 10; x++) {
            offset = 16*x;
            DbgPrint("\t%8.8x  %8.8x %8.8x %8.8x %8.8x\n",
                     ExceptionInfo->ContextRecord->Esp + offset,
                     *(DWORD *)(ExceptionInfo->ContextRecord->Esp + offset),
                     *(DWORD *)(ExceptionInfo->ContextRecord->Esp + offset + 4),
                     *(DWORD *)(ExceptionInfo->ContextRecord->Esp + offset + 8),
                     *(DWORD *)(ExceptionInfo->ContextRecord->Esp + offset + 12));
        }
    }

    //
    // so we have some idea of how long we have been running
    //

    DbgPrint( "HARNESS: the system has been running for %lu seconds\n", GetTickCount()/1000 );

    //
    // Use in-line assembly so that we can turn it off easier under
    // kernel debugger ("eb eip 90")
    //
    __asm int 3;

    if ( PreviousExceptionFilter ) {
        return PreviousExceptionFilter( ExceptionInfo );
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

VOID
QueryDriveSymbolicLink(
    OCHAR DriveLetter
    )
{
    OCHAR Drive[7];
    NTSTATUS Status;
    OBJECT_STRING NtFileName, Result;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE LinkHandle;
    OCHAR ResultBuffer[256];

    //
    // Convert DOS style path name to NT style path name
    //

    Drive[0] = OTEXT('\\');
    Drive[1] = OTEXT('?');
    Drive[2] = OTEXT('?');
    Drive[3] = OTEXT('\\');
    Drive[4] = DriveLetter;
    Drive[5] = OTEXT(':');
    Drive[6] = 0;

    RtlInitObjectString( &NtFileName, Drive );

    InitializeObjectAttributes(
        &ObjA,
        &NtFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenSymbolicLinkObject(
                &LinkHandle,
                &ObjA
                );

    if ( !NT_SUCCESS(Status) ) {
        return;
    }

    Result.Buffer = ResultBuffer;
    Result.Length = 0;
    Result.MaximumLength = sizeof(ResultBuffer);

    Status = NtQuerySymbolicLinkObject(
                LinkHandle,
                &Result,
                NULL
                );

    if ( NT_SUCCESS(Status) ) {
        DbgPrint( "HARNESS: found logical drive %c: (%Z)\n", DriveLetter, &Result );
        ++DriveCount;
    }

    NtClose( LinkHandle );
}

VOID
WINAPI
HarnessHangDetection(
    VOID
    )
/*++

Routine Description:

    This is a background thread used for detecting hung threads.

Arguments:

    None

Return Value:

    None, the thread never returns

--*/
{
    KIRQL Irql;
    PKPROCESS Process;
    PKTHREAD Thread;
    PLIST_ENTRY Next;
    ULONG CurrentTicks;
    ULONG DetectInterval;
    ULONG Timeout;

    Timeout = GetProfileIntA( "GeneralSettings", "HungTimeout", 300000 );

    DetectInterval = GetProfileIntA( "GeneralSettings",
                                     "HungDetectInterval", 60000 );

    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_HIGHEST );

    for (;;) {

        KeRaiseIrql( DISPATCH_LEVEL, &Irql );
        Process = KeGetCurrentThread()->ApcState.Process;
        Next = Process->ThreadListHead.Flink;
        CurrentTicks = *KeTickCount;

        while ( Next != &Process->ThreadListHead ) {
            Thread = CONTAINING_RECORD( Next, KTHREAD, ThreadListEntry );
            if ( Thread->TlsData && Thread->State == Waiting && \
                 Thread->WaitMode == KernelMode && \
                 CurrentTicks-Thread->WaitTime > Timeout ) {
                DbgPrint( "HARNESS: thread %p seems to be hung for more than %d seconds\n",
                          Thread, (CurrentTicks-Thread->WaitTime)/1000 );
                if ( (HarnessCurrentCacheSize/PAGE_SIZE) > 16 ) {
                    __asm int 3
                }
            }
            Next = Thread->ThreadListEntry.Flink;
        }

        KeLowerIrql(Irql);
        Sleep( DetectInterval );
    }
}

VOID
WINAPI
HarnessFscSizerThread(
    VOID
    )
/*++

Routine Description:

    This is a thread that performs neccessay background processing. It
    randomly changes file cache size every one minute. It is useful for
    stress testing

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG Seed;
    SIZE_T DefaultCacheSize;
    FILETIME SystemTime, LocalTime;
    CONST SmallFileCacheThresholdPages = DriveCount * 4;
    SYSTEMTIME xSystemTime;
    
    HarnessCurrentCacheSize = XGetFileCacheSize();
    DefaultCacheSize = HarnessCurrentCacheSize;
    GetSystemTimeAsFileTime( &SystemTime );
    FileTimeToLocalFileTime( &SystemTime, &LocalTime );
    Seed = LocalTime.dwHighDateTime + LocalTime.dwLowDateTime;

    for (;;) {

        //
        // Refresh settings from .ini file to see if it has been changed
        // We only do this in stress mode
        //

        if ( XTestLibIsStressTesting() ) {

            //
            // we want to avoid starving threads in low cache in stress
            // to do this, we use the total number of drives (DriveCount)
            // and multiply that by a wild guess (we'll start with 4) at the 
            // number of threads that will be accessing this device. We want to avoid
            // dropping below this number...
            //
            // stress has been running with very few pages, and this results in many 
            // threads getting blocked for long periods of time, whicc lessens the stress
            // load on the storage hardware
            //
            // we'll still do the minimum size, but we'll only do it a maximum of 25% of the time
            // note : we could get stuck at the minimum in low-memory situations
            //
            
            // the old way
            //if ( (RtlRandom(&Seed) % 100) > 50 ) {
            //    HarnessCurrentCacheSize = (RtlRandom(&Seed) % SmallFileCacheThresholdPages) + 1;
            //} else {
            //    HarnessCurrentCacheSize = (RtlRandom(&Seed) % (2048-SmallFileCacheThresholdPages)) + 1;
            //}

            // the new way
            switch(RtlRandom(&Seed) % 11)    {
                
                //
                // maximum cache size
                //

                case 0:
                    HarnessCurrentCacheSize = 2048;
                break;

                //
                // random but at least 'Minimum adequate' cache size
                //

                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    HarnessCurrentCacheSize = (RtlRandom(&Seed) % (2048-SmallFileCacheThresholdPages)) + SmallFileCacheThresholdPages;
                break;

                //
                // 'Minimum adequate' cache size
                //

                case 10:
                    HarnessCurrentCacheSize = SmallFileCacheThresholdPages;
                break;
                
                //
                // Minimum cache size - we may not want to do this!
                // we could get stuck here, remove if private testing shows this wedging the box
                //
                //
                //case 11:
                //    HarnessCurrentCacheSize = 1;
                //break;
            }

            HarnessCurrentCacheSize *= PAGE_SIZE;
            XSetFileCacheSize( HarnessCurrentCacheSize );
            HarnessCurrentCacheSize = XGetFileCacheSize();

        } else {

            //
            // just get the current size - don't mess with it outside of stressmode
            //

            HarnessCurrentCacheSize = XGetFileCacheSize();

        }

        //
        // try to force debugger to reconnect
        //

        *KdDebuggerNotPresent = FALSE;

        Sleep( 60 * 1000 );

        GetSystemTime(&xSystemTime);
        DbgPrint( "HARNESS: system running for %lu seconds. Date:%2.2d\\%2.2d\\%2.2d Time:%2.2d:%2.2d:%2.2d : Cache: %d bytes\n",
                  GetTickCount()/1000,
                  xSystemTime.wYear,
                  xSystemTime.wMonth,
                  xSystemTime.wDay,
                  xSystemTime.wHour,
                  xSystemTime.wMinute,
                  xSystemTime.wSecond,
                  HarnessCurrentCacheSize);
    }
}

VOID
HarnessCreateBackgroundThreads(
    VOID
    )
/*++

Routine Description:

    This routine create thread to randomly change file cache size. This is
    useful for stress testing

Arguments:

    None

Return Value:

    None

--*/
{
    HANDLE ThreadHandle;

    ThreadHandle = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE) \
                                 HarnessHangDetection, NULL, 0,
                                 NULL );

    if ( !ThreadHandle ) {
        KdPrint((
            "HARNESS: unable to create hang detection thread (%s)\n",
            WinErrorSymbolicName(GetLastError())
            ));
        HarnessLog(
            XLL_WARN,
            "Unable to create hang detection thread (%s)",
            WinErrorSymbolicName(GetLastError())
            );
    } else {
        CloseHandle( ThreadHandle );
    }

    ThreadHandle = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE) \
                                 HarnessFscSizerThread, NULL, 0,
                                 NULL );

    if ( !ThreadHandle ) {
        KdPrint((
            "HARNESS: unable to create fsc sizer thread (%s)\n",
            WinErrorSymbolicName(GetLastError())
            ));
        HarnessLog(
            XLL_WARN,
            "Unable to create fsc sizer thread (%s)",
            WinErrorSymbolicName(GetLastError())
            );
    } else {
        CloseHandle( ThreadHandle );
    }
}

VOID
HarnessMountAvailableMUs(
    VOID
    ) 
{
    INT Port, Slot;
    OCHAR Drive;
    BOOL bFormatSuccessful = FALSE;
    ANSI_STRING ostMU;
    char pszMU[64];
    ostMU.Length = 0;
    ostMU.MaximumLength = 63;
    ostMU.Buffer = pszMU;

    if ( GetProfileIntA("GeneralSettings", "DontMountMUs", FALSE) ) {
        return;
    }

    Sleep( 2000 );

    for ( Port=0; Port<XGetPortCount(); Port++ ) {

        //
        // if formatting of MUs was needed, do it here before we mount them
        //

        if ( FormatAllMUs ) {
            for ( Slot = 0; Slot < 2; Slot++ ) {
                if ( NT_SUCCESS( MU_CreateDeviceObject( Port, Slot, &ostMU ) ) ) {

                    bFormatSuccessful = XapiFormatFATVolume( &ostMU );
                    MU_CloseDeviceObject( Port, Slot );

                    if ( bFormatSuccessful ) {
                        DbgPrint( "HARNESS: success formatting MU Port:%d Slot:%d\n", Port, Slot );
                    } else {
                        DbgPrint( "HARNESS: failure formatting MU Port:%d Slot:%d\n", Port, Slot );
                    }
                }
            }
        }

        XMountMU( Port, XDEVICE_TOP_SLOT, &Drive );
        XMountMU( Port, XDEVICE_BOTTOM_SLOT, &Drive );
    }
}

NTSTATUS
WINAPI
HarnessEntryPoint(
    VOID
    )
{
    OCHAR drive;
#if DBG
    CHAR SystemVersion[16];
    CHAR XTLVersion[16];
#endif

#if 0
    //
    // Initialize Trap03 stuff (currenty disabled)
    //

    HarnessTrap03TlsIndex = TlsAlloc();
    if ( HarnessTrap03TlsIndex == (DWORD)-1 ) {
        DbgPrint( "HARNESS: couldn't allocate thread local storage\n" );
        return STATUS_NO_MEMORY;
    }

    HarnessInitializeTrap03Handler();
#endif

    PreviousExceptionFilter = SetUnhandledExceptionFilter( HarnessUnhandledExceptionFilter );

    DbgPrint( "\nHARNESS: Start testing\n" );

#if DBG
    XDebugGetSystemVersion( SystemVersion, ARRAY_SIZE(SystemVersion) );
    XDebugGetXTLVersion( XTLVersion, ARRAY_SIZE(XTLVersion) );
    DbgPrint( "HARNESS: system version %s, XTL version %s\n", SystemVersion, XTLVersion );
#endif

    //
    // Load and initialize global settings from testini.ini
    //

    HarnessInitGlobalVars();

    //
    // 1.) we may only want to run with a matched kernel
    // 2.) and with a later box in some circumstances
    //
    
    if ( GetProfileIntA("GeneralSettings", "ForceMatchedKernel", FALSE) == TRUE ) {

        //
        // compare our build number to the kernel build number
        // reboot to default title if no match
        //
        
        if (XboxKrnlVersion->Build != VER_PRODUCTBUILD) {

            //
            // reboot to default title
            //

            XLaunchNewImage(
                NULL,
                NULL);
        }
    }

    if ( GetProfileIntA("GeneralSettings", "ForceNewInitTable", FALSE) == TRUE ) {

        //
        // compare our init table version to the latest one
        // Note: this is ugly, hard coded, and will have to change fro time to time
        // this case should only be hit if someone is running a new build on an old black box
        //
    
    }
    
    if ( GetProfileIntA("GeneralSettings", "DisableAutoOff", TRUE) == TRUE ) {
        XAutoPowerDownSet(FALSE);
    }

    //
    // Initialize core peripheral port support
    //

    if ( GetProfileIntA("GeneralSettings", "DontInitDevices", FALSE) == 0 ) {

        XInitDevices( 0, NULL );

        //
        // Mount all inserted MUs, and format MUs if needed
        //

        HarnessMountAvailableMUs();
    }

    //
    // Display logical drives settings
    //

    for ( drive='A'; drive<='Z'; drive++ ) {
        QueryDriveSymbolicLink( drive );
    }

    //
    // Create thread to randomly change the file cache size
    //

    HarnessCreateBackgroundThreads();

    //
    // Initialize logging engine
    //

    if ( !HarnessInitializeLogging() ) {
        DbgPrint( "HARNESS: Unable to initialize logging engine, all tests blocked\n" );
        return STATUS_NO_LOG_SPACE;
    }

    //
    // Load and run test modules from TESTINI.INI
    //

    HarnessLoadTestModules();

    //
    // Close and clean up logging
    //

    HarnessShutdownLogging();
    DbgPrint( "HARNESS: Finish testing\n" );

    FlushDiskCache();

    DbgPrint(
        "HARNESS: sleep indefinitely, you may start file transfer using xbcp.exe\n"
        "  or press Ctrl+C and enter \'ed harness!HarnessQuitFlag 1;g\' to terminate\n"
        );

    while ( HarnessQuitFlag == FALSE ) {
        Sleep( 2000 );
    }

    DbgPrint( "HARNESS: terminating\n" );
    FlushDiskCache();
    SetUnhandledExceptionFilter( PreviousExceptionFilter );

    return STATUS_SUCCESS;
}

#if 0

#define PAGE_START(address) (((ULONG_PTR)address) & ~((ULONG_PTR)PAGE_SIZE - 1))

DWORD HarnessTrap03TlsIndex;


//
// External Trap03 handler in assembly module
//

BOOL
HarnessInitializeTrap03Handler(
    VOID
    );


VOID
GetStackLimits(
   OUT PULONG LowLimit,
   OUT PULONG HighLimit
   );


PVOID
GetRegistrationHead(
    VOID
    );


EXCEPTION_DISPOSITION
RtlpExecuteHandlerForException (
   IN PEXCEPTION_RECORD ExceptionRecord,
   IN PVOID EstablisherFrame,
   IN OUT PCONTEXT ContextRecord,
   IN OUT PVOID DispatcherContext,
   IN PEXCEPTION_ROUTINE ExceptionRoutine
   );


LPVOID
WINAPI
SafeTlsGetValue(
    DWORD Index
    )

/*++

Routine Description:

    This function is used to retrive the value in the TLS storage
    associated with the specified index. This function will be called
    inside trap handler so checking for valid XapiThread pointer is
    necessary as system threads don't have XapiThread pointer

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.

Return Value:

    NON-NULL - The function was successful. The value is the data stored
        in the TLS slot associated with the specified index.

    NULL - The operation failed, or the value associated with the
        specified index was NULL.

--*/

{
    if ( PsGetCurrentThread()->XapiThread ) {
        return TlsGetValue( Index );
    }

    return NULL;
}


ULONG
EspFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine fetches the correct esp from a trapframe, accounting
    for whether the frame is a user or kernel mode frame, and whether
    it has been edited.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

Return Value:

    Value of Esp.

--*/

{
    if ((TrapFrame->SegCs & FRAME_EDITED) == 0) {

        //  Kernel mode frame which has had esp edited,
        //  value of Esp is in TempEsp.

        return TrapFrame->TempEsp;

    } else {

        //  Kernel mode frame has has not had esp edited, compute esp.

        return (ULONG)&TrapFrame->HardwareEsp;
    }
}


VOID
EspToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG Esp
    )

/*++

Routine Description:

    This routine sets the specified value Esp into the trap frame,
    accounting for whether the frame is a user or kernel mode frame,
    and whether it has been edited before.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    Esp - New value for Esp.

Return Value:

    None.

--*/

{
    ULONG   OldEsp;

    OldEsp = EspFromTrapFrame(TrapFrame);

    //
    //  Kernel mode esp can't be lowered or iret emulation will fail
    //

    if (Esp < OldEsp)
        KeBugCheck(SET_OF_INVALID_CONTEXT);

    //
    //  Edit frame, setting edit marker as needed.
    //

    if ((TrapFrame->SegCs & FRAME_EDITED) == 0) {

        //  Kernel frame that has already been edited,
        //  store value in TempEsp.

        TrapFrame->TempEsp = Esp;

    } else {

        //  Kernel frame for which Esp is being edited first time.
        //  Save real SegCs, set marked in SegCs, save Esp value.

        if (OldEsp != Esp) {
            TrapFrame->TempSegCs = TrapFrame->SegCs;
            TrapFrame->SegCs = TrapFrame->SegCs & ~FRAME_EDITED;
            TrapFrame->TempEsp = Esp;
        }
    }
}


VOID
ContextFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified trap and exception frames
    frames into the specified context frame according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    ContextFrame - Supplies a pointer to the context frame that receives the
        context copied from the trap and exception frames.

Return Value:

    None.

--*/

{
    //
    // Set registers ebp, eip, cs, eflag, esp and ss.
    //

    ContextFrame->Ebp = TrapFrame->Ebp;
    ContextFrame->Eip = TrapFrame->Eip;

    if (((TrapFrame->SegCs & FRAME_EDITED) == 0) &&
        ((TrapFrame->EFlags & EFLAGS_V86_MASK) == 0)) {
        ContextFrame->SegCs = TrapFrame->TempSegCs & SEGMENT_MASK;
    } else {
        ContextFrame->SegCs = TrapFrame->SegCs & SEGMENT_MASK;
    }
    ContextFrame->EFlags = TrapFrame->EFlags;
    ContextFrame->SegSs = KGDT_R0_DATA;
    ContextFrame->Esp = EspFromTrapFrame(TrapFrame);

    //
    // Set integer registers edi, esi, ebx, edx, ecx, eax
    //

    ContextFrame->Edi = TrapFrame->Edi;
    ContextFrame->Esi = TrapFrame->Esi;
    ContextFrame->Ebx = TrapFrame->Ebx;
    ContextFrame->Ecx = TrapFrame->Ecx;
    ContextFrame->Edx = TrapFrame->Edx;
    ContextFrame->Eax = TrapFrame->Eax;
}


VOID
ContextToTrapFrame(
    IN OUT PKTRAP_FRAME TrapFrame,
    IN PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified context frame into
    the specified trap and exception frames according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that receives the volatile
        context from the context record.

    ContextFrame - Supplies a pointer to a context frame that contains the
        context that is to be copied into the trap and exception frames.

    ContextFlags - Supplies the set of flags that specify which parts of the
        context frame are to be copied into the trap and exception frames.

Return Value:

    None.

--*/

{
    //
    // Set registers eflag, ebp, eip, cs, esp and ss.
    // Eflags is set first, so that the auxilliary routines
    // can check the v86 bit to determine as well as cs, to
    // determine if the frame is kernel or user mode. (v86 mode cs
    // can have any value)
    //

    TrapFrame->EFlags = SANITIZE_FLAGS(ContextFrame->EFlags);
    TrapFrame->Ebp = ContextFrame->Ebp;
    TrapFrame->Eip = ContextFrame->Eip;
    EspToTrapFrame(TrapFrame, ContextFrame->Esp);

    //
    // Set integer registers edi, esi, ebx, edx, ecx, eax.
    //
    //  Can NOT call RtlMoveMemory here because the regs aren't
    //  contiguous in pusha frame, and we don't want to export
    //  bits of junk into context record.
    //

    TrapFrame->Edi = ContextFrame->Edi;
    TrapFrame->Esi = ContextFrame->Esi;
    TrapFrame->Ebx = ContextFrame->Ebx;
    TrapFrame->Ecx = ContextFrame->Ecx;
    TrapFrame->Edx = ContextFrame->Edx;
    TrapFrame->Eax = ContextFrame->Eax;
}


//
// Dispatcher context structure definition.
//

typedef struct _DISPATCHER_CONTEXT {
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    } DISPATCHER_CONTEXT;


BOOLEAN
DispatchException(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function attempts to dispatch an exception to a call frame based
    handler by searching backwards through the stack based call frames. The
    search begins with the frame specified in the context record and continues
    backward until either a handler is found that handles the exception, the
    stack is found to be invalid (i.e., out of limits or unaligned), or the end
    of the call hierarchy is reached.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    If the exception is handled by one of the frame based handlers, then
    a value of TRUE is returned. Otherwise a value of FALSE is returned.

--*/

{

    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    PEXCEPTION_REGISTRATION_RECORD NestedRegistration;
    ULONG HighAddress;
    ULONG HighLimit;
    ULONG LowLimit;
    EXCEPTION_RECORD ExceptionRecord1;

    //
    // Get current stack limits.
    //

    GetStackLimits(&LowLimit, &HighLimit);

    //
    // Start with the frame specified by the context record and search
    // backwards through the call frame hierarchy attempting to find an
    // exception handler that will handler the exception.
    //

    RegistrationPointer = GetRegistrationHead();
    NestedRegistration = 0;

    while (RegistrationPointer != EXCEPTION_CHAIN_END) {

        //
        // If the call frame is not within the specified stack limits or the
        // call frame is unaligned, then set the stack invalid flag in the
        // exception record and return FALSE. Else check to determine if the
        // frame has an exception handler.
        //

        HighAddress = (ULONG)RegistrationPointer +
            sizeof(EXCEPTION_REGISTRATION_RECORD);

        if ( ((ULONG)RegistrationPointer < LowLimit) ||
             (HighAddress > HighLimit) ||
             (((ULONG)RegistrationPointer & 0x3) != 0) ) {

#if defined(NTOS_KERNEL_RUNTIME)

            //
            // Allow for the possibility that the problem occured on the
            // DPC stack.
            //

            ULONG TestAddress = (ULONG)RegistrationPointer;

            if (((TestAddress & 0x3) == 0) &&
                KeGetCurrentIrql() >= DISPATCH_LEVEL) {

                PKPRCB Prcb = KeGetCurrentPrcb();
                ULONG DpcStack = (ULONG)Prcb->DpcStack;

                if ((Prcb->DpcRoutineActive) &&
                    (HighAddress <= DpcStack) &&
                    (TestAddress >= DpcStack - KERNEL_STACK_SIZE)) {

                    //
                    // This error occured on the DPC stack, switch
                    // stack limits to the DPC stack and restart
                    // the loop.
                    //

                    HighLimit = DpcStack;
                    LowLimit = DpcStack - KERNEL_STACK_SIZE;
                    continue;
                }
            }

#endif

            ExceptionRecord->ExceptionFlags |= EXCEPTION_STACK_INVALID;
            return FALSE;
        }

        Disposition = RtlpExecuteHandlerForException(
            ExceptionRecord,
            (PVOID)RegistrationPointer,
            ContextRecord,
            (PVOID)&DispatcherContext,
            (PEXCEPTION_ROUTINE)RegistrationPointer->Handler);

        //
        // If the current scan is within a nested context and the frame
        // just examined is the end of the context region, then clear
        // the nested context frame and the nested exception in the
        // exception flags.
        //

        if (NestedRegistration == RegistrationPointer) {
            ExceptionRecord->ExceptionFlags &= (~EXCEPTION_NESTED_CALL);
            NestedRegistration = 0;
        }

        //
        // Case on the handler disposition.
        //

        switch (Disposition) {

            //
            // The disposition is to continue execution. If the
            // exception is not continuable, then raise the exception
            // STATUS_NONCONTINUABLE_EXCEPTION. Otherwise return
            // TRUE.
            //

        case ExceptionContinueExecution :
            if ((ExceptionRecord->ExceptionFlags &
               EXCEPTION_NONCONTINUABLE) != 0) {
                ExceptionRecord1.ExceptionCode =
                                        STATUS_NONCONTINUABLE_EXCEPTION;
                ExceptionRecord1.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                ExceptionRecord1.ExceptionRecord = ExceptionRecord;
                ExceptionRecord1.NumberParameters = 0;
                RtlRaiseException(&ExceptionRecord1);
            } else {
                return TRUE;
            }

            //
            // The disposition is to continue the search. Get next
            // frame address and continue the search.
            //

        case ExceptionContinueSearch :
            break;

            //
            // The disposition is nested exception. Set the nested
            // context frame to the establisher frame address and set
            // nested exception in the exception flags.
            //

        case ExceptionNestedException :
            ExceptionRecord->ExceptionFlags |= EXCEPTION_NESTED_CALL;
            if (DispatcherContext.RegistrationPointer > NestedRegistration) {
                NestedRegistration = DispatcherContext.RegistrationPointer;
            }
            break;

            //
            // All other disposition values are invalid. Raise
            // invalid disposition exception.
            //

        default :
            ExceptionRecord1.ExceptionCode = STATUS_INVALID_DISPOSITION;
            ExceptionRecord1.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            ExceptionRecord1.ExceptionRecord = ExceptionRecord;
            ExceptionRecord1.NumberParameters = 0;
            RtlRaiseException(&ExceptionRecord1);
            break;
        }

        //
        // If chain goes in wrong direction or loops, report an
        // invalid exception stack, otherwise go on to the next one.
        //

        RegistrationPointer = RegistrationPointer->Next;
    }
    return FALSE;
}


VOID
WINAPI
HarnessDispatchBreakpointException(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This function is called to dispatch an int 3 exception to the proper mode
    and to cause the exception dispatcher to be called.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame. For NT386,
        this should be NULL.

    TrapFrame - Supplies a pointer to a trap frame.

    FirstChance - Supplies a boolean value that specifies whether this is
        the first (TRUE) or second (FALSE) chance for the exception.

Return Value:

    None.

--*/

{
    CONTEXT ContextFrame;
    ASSERT( ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT );
    ContextFromTrapFrame( TrapFrame, &ContextFrame );
    DispatchException(ExceptionRecord, &ContextFrame);
    ContextToTrapFrame( TrapFrame, &ContextFrame );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\harness\runner.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    runner.c

Abstract:

    This module contains routine that run each test module

--*/

#include "precomp.h"
#include "loader.h"
#include "logging.h"
#include "harnessapi.h"

//
// Counter for running ModuleRunnerThread in serial, stress and parallel test mode
//

ULONG NumberOfRunningModules;

//
// Event to signal main thread that all module runners are terminated
//

HANDLE DoneAllModulesEventHandle;

//
// Sutdown notification event when we want to shutdown the stress/test
//

HANDLE ShutdownEventHandle;

//
// Pointer to the head of test modules list
//

LIST_ENTRY HarnessTestListHead;

BOOL StressTestMode = FALSE;
BOOL RunningInSerialMode = FALSE;

#if DBG
extern ULONG XDebugOutLevel;
extern DWORD g_dwDirectSoundDebugLevel;
extern DWORD g_dwDirectSoundDebugBreakLevel;
#endif

DWORD
WINAPI
TestRunnerThreadProc(
    IN CONST PHARNESS_TEST_LIST_ENTRY p
    )
/*++

Routine Description:

    This is the wrapper routine that will run the StartTest. After StartTest
    returns, if we are the last thread, the end test event will be signaled
    to notify the module runner

Arguments:

    p - Pointer to HARNESS_TEST_LIST_ENTRY structure

Return Value:

    NT status code

--*/
{
    ULONG ExceptionCode = STATUS_SUCCESS;
    HANDLE EventHandles[2];
    DWORD WaitStatus;
    BOOL b;

    if ( DebugVerbose ) {
        DbgPrint( "HARNESS: test runner of %s is starting\n",
            p->FullTestPath );
    }

    //
    // Waits for the start test signal from module runner
    //

    ASSERT( p->StartTestEventHandle != NULL );
    ASSERT( ShutdownEventHandle != NULL );

    EventHandles[0] = ShutdownEventHandle;
    EventHandles[1] = p->StartTestEventHandle;
    WaitStatus = WaitForMultipleObjects( 2, EventHandles, FALSE, INFINITE );

    //
    // The harness wants to shutdown, just set the end event and return
    //

    if ( WaitStatus == WAIT_OBJECT_0 ) {
        goto EndTestRunner;
    }

    if ( WaitStatus != WAIT_OBJECT_0+1 ) {
        HarnessLog(
            XLL_WARN,
            "WaitForMultipleObjects returned 0x%x in test runner of %s (%s)",
            WaitStatus,
            p->FullTestPath,
            WinErrorSymbolicName(GetLastError())
            );
    }

    ASSERT( WaitStatus == WAIT_OBJECT_0+1 );

    try {

        ASSERT( p->LogHandle != INVALID_HANDLE_VALUE );
        ASSERT( p->LogHandle != NULL );
        p->pStartupProc( StressTestMode ? INVALID_HANDLE_VALUE : p->LogHandle );

    } except( HarnessUnhandledExceptionFilter(GetExceptionInformation()) ) {

        ExceptionCode = GetExceptionCode();
        HarnessLog(
            XLL_EXCEPTION,
            "Exception %s is not handled while calling StartTest of %s\n",
            NtStatusSymbolicName(ExceptionCode),
            p->FullTestPath
            );
    }

    if ( DebugVerbose ) {
        DbgPrint( "HARNESS: test runner of %s is done\n", p->FullTestPath
); }

EndTestRunner:

    //
    // Set the end test event if we are the last thread
    //

    ASSERT( p->NumberOfRunningThreads != 0);

    if ( InterlockedDecrement((PULONG)&p->NumberOfRunningThreads) == 0 ) {
        ASSERT( p->EndTestEventHandle != NULL );
        b = SetEvent( p->EndTestEventHandle );
        if ( !b ) {
            HarnessLog(
                XLL_WARN,
                "SetEvent returned FALSE in test runner of %s (%s)",
                p->FullTestPath,
                WinErrorSymbolicName(GetLastError())
                );
        }
        ASSERT( b );
    }

    if ( DebugVerbose ) {
        DbgPrint( "HARNESS: returning from test runner of %s\n",
            p->FullTestPath );
    }

    return ExceptionCode;
}

DWORD
WINAPI
ModuleRunnerThreadProc(
    IN PHARNESS_TEST_LIST_ENTRY p
    )
/*++

Routine Description:

    This is a wrapper routine that will run the entire test module

Arguments:

    p - Pointer to HARNESS_TEST_LIST_ENTRY structure

Return Value:

    NT status code

--*/
{
    ULONG Iterations, Threads;
    ULONG ExceptionCode = STATUS_SUCCESS;
    HANDLE Handles[2], ThreadHandle;
    DWORD WaitStatus;
    BOOL b, DllMainReturnCode = TRUE;
    BOOL NeedToCallEndTest;

    Handles[0] = ShutdownEventHandle;
    Handles[1] = p->EndTestEventHandle;

    do {

        while ( !HarnessLoadTestModule(p, INVALID_SOCKET, TRUE) ) {

            //
            // Sometimes there is not enough memory to re-load the test, if it
            // happens, wait for a while and try again unless we have to shutdown
            //

            if ( WAIT_OBJECT_0 == WaitForSingleObject( ShutdownEventHandle, 1000 ) ) {
                goto EndModuleRunner;
            }
        }

        //
        // Call DllMain of test module if necessary
        //

        if ( p->pDllMain ) {
            ASSERT( p->ModuleHandle );
            DllMainReturnCode = p->pDllMain( p->ModuleHandle, DLL_PROCESS_ATTACH, NULL );
        }

        if ( DllMainReturnCode ) {
            ASSERT( p->Iterations != 0 );
            NeedToCallEndTest = FALSE;

            for ( Iterations=0; Iterations<p->Iterations; Iterations++ ) {

                ASSERT( p->StartTestEventHandle != NULL );
                ASSERT( p->EndTestEventHandle != NULL );
                b = ResetEvent( p->StartTestEventHandle );
                b &= ResetEvent( p->EndTestEventHandle );

                if ( !b ) {
                    HarnessLog(
                        XLL_WARN,
                        "ResetEvent returned FALSE in module runner of %s (%s)",
                        p->FullTestPath,
                        WinErrorSymbolicName(GetLastError())
                        );
                }

                ASSERT( p->NumberOfThreads != 0 );
                ASSERT( p->NumberOfRunningThreads == 0 );

                for ( Threads=0; Threads<p->NumberOfThreads; Threads++ ) {

                    ThreadHandle = CreateThread(
                                        NULL,               // No security attributes
                                        p->ThreadStackSize,
                                        (LPTHREAD_START_ROUTINE)TestRunnerThreadProc,
                                        (LPVOID)p,
                                        0,
                                        NULL
                                        );

                    if ( !ThreadHandle ) {
                        HarnessLog(
                            XLL_WARN,
                            "Unable to create runner thread #%d for %s (%s)",
                            Threads,
                            p->FullTestPath,
                            WinErrorSymbolicName(GetLastError())
                            );
                    } else {
                        InterlockedIncrement( (PLONG)&p->NumberOfRunningThreads );
                        CloseHandle( ThreadHandle );
                    }
                }

                if ( p->NumberOfRunningThreads ) {

                    NeedToCallEndTest = TRUE;

                    //
                    // Signal threads to start to run their test and wait
                    //
                    b = SetEvent( p->StartTestEventHandle );
                    if ( !b ) {
                        HarnessLog(
                            XLL_WARN,
                            "ResetEvent returned FALSE in module runner of %s (%s)",
                            p->FullTestPath,
                            WinErrorSymbolicName(GetLastError())
                            );
                    }

                    WaitStatus = WaitForMultipleObjects( 2, Handles, FALSE, INFINITE );

                    //
                    // If the harness want to shutdown, we must stop now
                    //

                    if ( WaitStatus == WAIT_OBJECT_0 ) {
                        if ( DebugVerbose ) {
                            DbgPrint( "HARNESS: Shutdown event received, terminating\n" );
                        }
                        goto EndModuleRunner;
                    }

                    if ( WaitStatus != WAIT_OBJECT_0+1 ) {
                        HarnessLog(
                            XLL_WARN,
                            "WaitForMultipleObjects returned 0x%x in ModuleRunnerThreadProc (%s)",
                            WaitStatus,
                            WinErrorSymbolicName(GetLastError())
                            );
                    }

                    ASSERT( WaitStatus == WAIT_OBJECT_0+1 );

                    if ( DebugVerbose ) {
                        DbgPrint( "HARNESS: All test runner of %s has terminated\n",
                                  p->FullTestPath );
                    }
                }
            } // Iteration loop

            if ( NeedToCallEndTest ) {

                //
                // The StartTest has finished, call EndTest now
                //
                //

                if ( DebugVerbose ) {
                    DbgPrint( "HARNESS: calling EndTest of %s\n", p->FullTestPath );
                }

                try {
                    p->pCleanupProc();
                } except( HarnessUnhandledExceptionFilter(GetExceptionInformation()) ) {
                    ExceptionCode = GetExceptionCode();
                    HarnessLog(
                        XLL_EXCEPTION,
                        "Exception %s is not handled while calling EndTest of %s\n",
                        NtStatusSymbolicName( ExceptionCode ),
                        p->FullTestPath
                        );
                }
            }

            if ( StressTestMode ) {
                if ( DebugVerbose ) {
                    DbgPrint(
                        "HARNESS: sleep %d msec before running %s again\n",
                        p->SleepBetweenRun,
                        p->FullTestPath );
                }

                if ( WAIT_OBJECT_0 == WaitForSingleObject(
                                        ShutdownEventHandle,
                                        p->SleepBetweenRun ) ) {
                    break;
                }
            }

            if ( p->pDllMain ) {
                ASSERT( p->ModuleHandle );
                p->pDllMain( p->ModuleHandle, DLL_PROCESS_DETACH, NULL );
            }
        } else {
            HarnessLog(
                XLL_WARN,
                "DllMain of %s returned FALSE",
                p->FullTestPath
                );
        }

        HarnessUnloadTestModule( p, StressTestMode == FALSE );

    } while ( StressTestMode );

EndModuleRunner:

    ASSERT( p->NumberOfRunningThreads == 0 );
    ASSERT( NumberOfRunningModules != 0 );

    if ( InterlockedDecrement((PLONG)&NumberOfRunningModules) == 0 ) {
        ASSERT( DoneAllModulesEventHandle != NULL );
        b = SetEvent( DoneAllModulesEventHandle );
        if ( !b ) {
            HarnessLog(
                XLL_WARN,
                "ResetEvent returned FALSE at the end of module runner of %s (%s)",
                p->FullTestPath,
                WinErrorSymbolicName(GetLastError())
                );
        }
        ASSERT( b );
    }

    if ( DebugVerbose ) {
        DbgPrint( "HARNESS: module runner of %s end\n", p->FullTestPath );
    }

    return ExceptionCode;
}

BOOL
RunModule(
    PHARNESS_TEST_LIST_ENTRY p,
    BOOL Wait
    )
{
    DWORD WaitStatus;
    HANDLE Handles[2];

    Handles[1] = CreateThread(
                    NULL,
                    16 * 1024,
                    (LPTHREAD_START_ROUTINE)ModuleRunnerThreadProc,
                    (LPVOID)p,
                    0,
                    NULL
                    );
    if ( !Handles[1] ) {
        HarnessLog(
            XLL_WARN,
            "Unable to create module runner thread for %s (%s)\n",
            p->FullTestPath,
            WinErrorSymbolicName(GetLastError())
            );
    } else {
        InterlockedIncrement( (PLONG)&NumberOfRunningModules );
        if ( Wait ) {
            ASSERT( ShutdownEventHandle != NULL );
            Handles[0] = ShutdownEventHandle;
            WaitStatus = WaitForMultipleObjects( 2, Handles, FALSE, INFINITE );
            if ( WaitStatus != WAIT_OBJECT_0 && WaitStatus != WAIT_OBJECT_0+1 ) {
                HarnessLog(
                    XLL_WARN,
                    "WaitForMultipleObjects returned 0x%x in RunModule (%s)",
                    WaitStatus,
                    WinErrorSymbolicName(GetLastError())
                    );
            }
            ASSERT( WaitStatus == WAIT_OBJECT_0 || WaitStatus == WAIT_OBJECT_0+1 );
        }
        CloseHandle( Handles[1] );
    }

    return Handles[1] != NULL;
}

VOID
RunSerialTest(
    VOID
    )
/*++

Routine Description:

    This routine will run the test module in modules list serially

Arguments:

    None

Return Value:

    None

--*/
{
    PLIST_ENTRY NextEntry;
    PHARNESS_TEST_LIST_ENTRY p;
    HANDLE Handles[2];
    BOOL Running = TRUE;

    ASSERT( RunningInSerialMode == FALSE );
    RunningInSerialMode = TRUE;

    ASSERT( ShutdownEventHandle != NULL );
    Handles[0] = ShutdownEventHandle;
    NextEntry = HarnessTestListHead.Flink;

    while ( Running && NextEntry != &HarnessTestListHead ) {
        p = CONTAINING_RECORD( NextEntry, HARNESS_TEST_LIST_ENTRY, List );
        ASSERT( NumberOfRunningModules == 0 );
        RunModule( p, TRUE );
        NextEntry = NextEntry->Flink;
    }

    if ( DebugVerbose ) {
        DbgPrint( "HARNESS: Serial test end\n\n" );
    }

    RunningInSerialMode = FALSE;
}

VOID
RunParallelTest(
    VOID
    )
/*++

Routine Description:

    This routine will run the test module in modules list in parallel mode

Arguments:

    None

Return Value:

    None

--*/
{
    PLIST_ENTRY NextEntry;
    PHARNESS_TEST_LIST_ENTRY p;
    HANDLE Handles[2];
    ULONG ModulesCount;

    ModulesCount = 0;

    NextEntry = HarnessTestListHead.Flink;
    while ( NextEntry != &HarnessTestListHead ) {
        ModulesCount++;
        NextEntry = NextEntry->Flink;
    }

    if ( DebugVerbose ) {
        DbgPrint( "HARNESS: parallel test found %d module(s)\n", ModulesCount );
    }

    if ( ModulesCount == 0 ) {
        return;
    }

    ASSERT( DoneAllModulesEventHandle != NULL );
    ResetEvent( DoneAllModulesEventHandle );
    Handles[0] = ShutdownEventHandle;
    Handles[1] = DoneAllModulesEventHandle;

    NextEntry = HarnessTestListHead.Flink;

    while ( NextEntry != &HarnessTestListHead ) {
        p = CONTAINING_RECORD( NextEntry, HARNESS_TEST_LIST_ENTRY, List );
        RunModule( p, FALSE );
        NextEntry = NextEntry->Flink;
    }

    if ( StressTestMode ) {

        WaitForSingleObject( ShutdownEventHandle, INFINITE );

    } else {

        DWORD WaitStatus = WaitForMultipleObjects( 2, Handles, FALSE, INFINITE );

        //
        // If the harness want to shutdown, we must stop now
        //

        if ( WaitStatus == WAIT_OBJECT_0 ) {
            goto EndParallelTest;
        }

        if ( WaitStatus != WAIT_OBJECT_0+1 ) {
            HarnessLog(
                XLL_WARN,
                "WaitForMultipleObjects returned 0x%x in RunParallelTest (%s)",
                WaitStatus,
                WinErrorSymbolicName(GetLastError())
                );
        }
        ASSERT( WaitStatus == WAIT_OBJECT_0+1 );
    }

EndParallelTest:

    if ( DebugVerbose ) {
        DbgPrint( "HARNESS: Parallel test end\n" );
    }
}

BOOL
WINAPI
RunTestA(
    SOCKET Socket,
    LPCSTR TestName
    )
{
    BOOL b;
    HARNESS_TEST_LIST_ENTRY ModuleInfo;

    //
    // Currently only work in serial mode
    //
    if ( !RunningInSerialMode ) {
        return FALSE;
    }

    if ( !HarnessInitializeModule(TestName, Socket, &ModuleInfo) ) {
        return FALSE;
    }

    b = RunModule( &ModuleInfo, TRUE );
    HarnessCleanupModule( &ModuleInfo );
    return b;
}

BOOL
WINAPI
RunTestW(
    SOCKET  Socket,
    LPCWSTR TestName
    )
{
    CHAR ModuleName[MAX_PATH];
    wsprintfA( ModuleName, "%ls", TestName );
    return RunTestA( Socket, ModuleName );
}

BOOL
HarnessLoadTestModules(
    VOID
    )
/*++

Routine Description:

    This routine will read TESTINI.INI and enumerate for loadable test
    modules and load them

Arguments:

    None

Return Value:

    TRUE if at least one test module is loaded, otherwise return FALSE

--*/
{
    PSTR psz, Buffer = NULL;
    ULONG AllocationSize = 0;
    ULONG LengthReturned;
    ULONG ModulesCount = 0;
    PLIST_ENTRY NextEntry;
    PHARNESS_TEST_LIST_ENTRY p;

    ShutdownEventHandle = CreateEvent( NULL, TRUE, FALSE, NULL );
    DoneAllModulesEventHandle = CreateEvent( NULL, TRUE, FALSE, NULL );

    if ( !ShutdownEventHandle || !DoneAllModulesEventHandle ) {
        DbgPrint( "HARNESS: Unable to create event (%s)\n", WinErrorSymbolicName(GetLastError()) );
        return FALSE;
    }

    //
    // We don't know how big of the test list, so we try to allocate the buffer
    // starting from 64K characters and try to get the whole section. If the
    // buffer is not big enough we will try to increase the buffer every 50K
    // until we can get all the section in the buffer
    //

    do {

        AllocationSize += ( 64 * 1024 );
        if ( Buffer ) {
            ExFreePool( Buffer );
        }

        //
        // If verifier is turned on with DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES
        // sometimes ExAllocatePool will return NULL
        //

        do {
            Buffer = ExAllocatePoolWithTag( AllocationSize * sizeof(CHAR), HARNESS_POOLTAG );
        } while ( !Buffer );

        LengthReturned = GetProfileSectionA( "TestList", Buffer, AllocationSize );

    } while ( LengthReturned == AllocationSize - 2 );


    //
    // Enumerate the test list that we retrieved from [TestList] section
    // and create loaded modules list
    //

    InitializeListHead( &HarnessTestListHead );

    psz = Buffer;
    if ( DebugVerbose ) {
        DbgPrint(( "HARNESS: Enumerating [TestList] section from TESTINI.INI...\n" ));
    }

    while ( *psz ) {

        p = (PHARNESS_TEST_LIST_ENTRY)\
            ExAllocatePoolWithTag( sizeof(HARNESS_TEST_LIST_ENTRY), HARNESS_POOLTAG );

        if ( p ) {
            RtlZeroMemory( p, sizeof(HARNESS_TEST_LIST_ENTRY) );
            if ( HarnessInitializeModule(psz, INVALID_SOCKET, p) ) {
                InsertTailList( &HarnessTestListHead, &p->List );
            } else {
                ExFreePool( p );
            }
        } else {
            DbgPrint(( "HARNESS: Unable to allocate buffer for HARNESS_TEST_LIST_ENTRY\n" ));
        }

        psz += strlen( psz );
        psz++;
    }

    ExFreePool( Buffer );

    NextEntry = HarnessTestListHead.Flink;
    while ( NextEntry != &HarnessTestListHead ) {

        ModulesCount++;

        p = CONTAINING_RECORD( NextEntry, HARNESS_TEST_LIST_ENTRY, List );

        if ( DebugVerbose ) {
            DbgPrint( "  FullTestPath = \"%s\"\n", p->FullTestPath );
            DbgPrint( "  FullLogPath = \"%s\"\n", p->FullLogPath );
            DbgPrint( "  LogLevel = %d\n", p->LogLevel );
            DbgPrint( "  LogOptions = %d\n", p->LogOptions );
            DbgPrint( "  Iterations = %d\n", p->Iterations );
            DbgPrint( "  NumberOfThreads = %d\n", p->NumberOfThreads );
            DbgPrint( "  ThreadStackSize = %d\n", p->ThreadStackSize );
            DbgPrint( "  SleepBetweenRun = %d\n", p->SleepBetweenRun );
            DbgPrint( "  Shutdown aware = %s\n", p->pShutdownProc ? "TRUE" : "FALSE" );
            DbgPrint( "\n" );
        }

        NextEntry = NextEntry->Flink;
    }

    if ( !ModulesCount ) {
        DbgPrint(( "HARNESS: WARNING! TestList is empty, there is no test to run\n" ));
    }

    StressTestMode = GetProfileIntA( GeneralSettingsSectionName, "StressTestMode", FALSE );

#if DBG
	g_dwDirectSoundDebugLevel  = GetProfileIntA( "GeneralSettings", "DirectSoundDebugLevel", 1 );
	g_dwDirectSoundDebugBreakLevel  = GetProfileIntA( "GeneralSettings", "DirectSoundDebugBreakLevel", 1 );
#endif // DBG

    if ( StressTestMode ) {

#if DBG
        //
        // Read XDebugOutLevel for stress
        //

        XDebugOutLevel = GetProfileIntA( "GeneralSettings", "XDebugOutLevel",
                                         XDBG_WARNING );

#endif

        RunParallelTest();
    } else {
        if ( GetProfileIntA(GeneralSettingsSectionName, "SerialTestMode", TRUE) ) {
            RunSerialTest();
        }
        if ( GetProfileIntA(GeneralSettingsSectionName, "ParallelTestMode", FALSE) ) {
            RunParallelTest();
        }
    }

    NextEntry = HarnessTestListHead.Flink;

    while ( NextEntry != &HarnessTestListHead ) {
        p = CONTAINING_RECORD( NextEntry, HARNESS_TEST_LIST_ENTRY, List );
        NextEntry = NextEntry->Flink;
        HarnessCleanupModule( p );
        ExFreePool( p );
    }

    CloseHandle( ShutdownEventHandle );
    CloseHandle( DoneAllModulesEventHandle );
    return ModulesCount;
}

BOOL
WINAPI
Shutdown(
    SOCKET socket,
    ULONG  Reserved
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\harness\i386\trap03.asm ===
title  "Trap 03 Processing"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;    trap03.asm
;
; Abstract:
;
;    This module implements the code necessary to process i386
;    break point trap.
;
;--

.386p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list


        extrn   _HarnessTrap03TlsIndex:DWORD
        EXTRNP  _SafeTlsGetValue,1
        EXTRNP  _HarnessDispatchBreakpointException,4


SET_DEBUG_DATA  macro

ife FPO

;
; This macro is used by ENTER_SYSTEM_CALL, ENTER_TRAP and ENTER_INTERRUPT
; and is used at the end of above macros.  It is safe to destroy ebx, edi.
;

        mov     ebx,[ebp]+TsEbp
        mov     edi,[ebp]+TsEip
        mov     [ebp]+TsDbgArgPointer,edx
        mov     [ebp]+TsDbgArgMark,0BADB0D00h
        mov     [ebp]+TsDbgEbp,ebx
        mov     [ebp]+TsDbgEip,edi
endif

endm


;++
;
;   ENTER_TRAP
;
;   Macro Description:
;
;       Build the frame and set registers needed by a trap or exception.
;
;       Save:
;           Non-volatile regs,
;           FS,
;           ExceptionList,
;           PreviousMode,
;           Volatile regs
;           Seg Regs from V86 mode
;           DS, ES, GS
;
;       Don't Save:
;           Floating point state
;
;       Set:
;           FS,
;           Direction,
;           DS, ES
;
;       Don't Set:
;           PreviousMode,
;           ExceptionList
;
;   Arguments:
;       None.
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax
;
;--

ENTER_TRAP macro

;
;   Fill in parts of frame we care about
;

        mov     word ptr [esp+2], 0 ; Clear upper word of ErrorCode

        push    ebp                 ; Save the non-volatile registers
        push    ebx
        push    esi
        push    edi

        mov     ebx, fs:[0]         ; Save ExceptionList
        push    ebx
        push    eax                 ; Save the volatile registers
        push    ecx
        push    edx

;
;   Skip allocate reset of trap frame.
;

        sub     esp,TsEdx

        mov     ebp,esp

        cld
        SET_DEBUG_DATA

        endm

;++
;
;   EXIT_ALL    NoRestoreSegs, NoRestoreVolatiles, NoPreviousMode
;
;   Macro Description:
;
;       Load a syscall frame back into the machine.
;
;       Restore:
;           Volatile regs, IF NoRestoreVolatiles blank
;           NoPreviousMode,
;           ExceptionList,
;           FS,
;           Non-volatile regs
;
;       If the frame is a kernel mode frame, AND esp has been edited,
;       then TsSegCs will have a special value.  Test for that value
;       and execute special code for that case.
;
;       N.B. This macro generates an IRET!  (i.e. It exits!)
;
;   Arguments:
;
;       NoRestoreSegs - non-blank if DS, ES, GS are NOT to be restored
;
;       NoRestoreVolatiles - non-blank if Volatile regs are NOT to be restored
;
;       NoPreviousMode - if nb pop ThPreviousMode
;
;   Entry-conditions:
;
;       (esp)->base of trap frame
;       (ebp)->Base of trap frame
;
;   Exit-conditions:
;
;       Does not exit, returns.
;       Preserves eax, ecx, edx, IFF NoRestoreVolatiles is set
;
;--

?adjesp = 0
?RestoreAll = 1

EXIT_ALL macro  NoRestoreSegs, NoRestoreVolatiles, NoPreviousMode
local   a, b, f, x
local   Db_NotATrapFrame, Db_A, Db_NotValidEntry

;
; Sanity check some values and setup globals for macro
;

?adjesp = TsEdx
?RestoreAll = 1

ifnb <NoRestoreSegs>
    ?RestoreAll = 0
endif

ifnb <NoRestoreVolatiles>
    if ?RestoreAll eq 1
        %out "EXIT_ALL NoRestoreVolatiles requires NoRestoreSegs"
        .err
    endif
    ?adjesp = ?adjesp + 12
endif

ifb <NoPreviousMode>
ifndef KERNELONLY
        %out    EXIT_ALL can not restore previousmode outside kernel
        .err
endif
endif

; All callers are responsible for getting here with interrupts disabled.

if DBG
        pushfd
        pop     edx

        test    edx, EFLAGS_INTERRUPT_MASK
        jnz     Db_NotValidEntry

        cmp     esp, ebp                    ; make sure esp = ebp
        jne     Db_NotValidEntry

; Make sure BADB0D00 sig is present.  If not this isn't a trap frame!
Db_A:   sub     [esp]+TsDbgArgMark,0BADB0D00h
        jne     Db_NotATrapFrame
endif

        mov     edx, [esp]+TsExceptionList
if DBG
        or      edx, edx
        jnz     short @f
    int 3
@@:
endif
        mov     dword ptr fs:[0], edx       ; Restore ExceptionList

        test    word ptr [esp]+TsSegCs,FRAME_EDITED
        jz      b                           ; Edited frame pop out.

ifb <NoRestoreVolatiles>
ifb <NoRestoreSegs>                         ; must restore eax before any
        mov     eax, [esp].TsEax            ; selectors! (see trap0e handler)
endif
endif

ifb <NoRestoreVolatiles>
        mov     edx, [ebp]+TsEdx            ; Restore volitales
        mov     ecx, [ebp]+TsEcx
ifb <NoRestoreSegs>
else
        mov     eax, [ebp]+TsEax
endif
endif   ; NoRestoreVolatiles

        lea     esp, [ebp]+TsEdi            ; Skip PreMode, ExceptList and fs

        pop     edi                         ; restore non-volatiles
        pop     esi
        pop     ebx
        pop     ebp

;
; Esp MUST point to the Error Code on the stack.  Because we use it to
; store the entering esp.
;

        add     esp, 4              ; remove error code from trap frame
        iretd                       ; return

if DBG
Db_NotATrapFrame:
        add     [esp]+TsDbgArgMark,0BADB0D00h   ; put back the orig value
Db_NotValidEntry:
        int 3
        jmp     Db_A
endif

;
;   TsSegCs contains the special value that means the frame was edited
;   in a way that affected esp, AND it's a kernel mode frame.
;   (Special value is null selector except for RPL.)
;
;   Put back the real CS.
;   push eflags, eip onto target stack
;   restore
;   switch to target stack
;   iret
;

b:      mov     ebx,[esp]+TsTempSegCs
        mov     [esp]+TsSegCs,ebx

;
;   There is no instruction that will load esp with an arbitrary value
;   (i.e. one out of a frame) and do a return, if no privledge transition
;   is occuring.  Therefore, if we are returning to kernel mode, and
;   esp has been edited, we must "emulate" a kind of iretd.
;
;   We do this by logically pushing the eip,cs,eflags onto the new
;   logical stack, loading that stack, and doing an iretd.  This
;   requires that the new logical stack is at least 1 dword higher
;   than the unedited esp would have been.  (i.e.  It is not legal
;   to edit esp to have a new value < the old value.)
;
;   KeContextToKframes enforces this rule.
;

;
;   Compute new logical stack address
;

        mov     ebx,[esp]+TsTempEsp
        sub     ebx,12
        mov     [esp]+TsErrCode,ebx

;
;   Copy eip,cs,eflags to new stack.  note we do this high to low
;

        mov     esi,[esp]+TsEflags
        mov     [ebx+8],esi
        mov     esi,[esp]+TsSegCs
        mov     [ebx+4],esi
        mov     esi,[esp]+TsEip
        mov     [ebx],esi

;
;   Do a standard restore sequence.
;
;   Observe that RestoreVolatiles is honored.  Editing a volatile
;   register has no effect when returning from a system call.
;
ifb     <NoRestoreVolatiles>
        mov     eax,[esp].TsEax
endif
;        add     esp,TsSegGs
;
;ifb     <NoRestoreSegs>
;        pop     gs
;        pop     es
;        pop     ds
;else
;        add     esp,12
;endif

ifb     <NoRestoreVolatiles>
        mov     edx, [esp]+TsEdx
        mov     ecx, [esp]+TsEcx
endif

;ifnb <NoPreviousMode>
;        add     esp, 4              ; Skip previous mode
;else
;        pop     ebx                 ; Restore PreviousMode
;        mov     esi,fs:[PcPrcbData+PbCurrentThread]
;        mov     ss:[esi]+ThPreviousMode,bl
;endif
;
;       pop     ebx
;
;       mov     fs:[PcExceptionList], ebx ;Restore ExceptionList
;       pop     fs

        add     esp, TsEdi
        pop     edi                 ; restore non-volatiles
        pop     esi
        pop     ebx
        pop     ebp

;
;   (esp)->TsErrCode, where we saved the new esp
;

        mov     esp,[esp]           ; Do move not push to avoid increment
        iretd

        endm


_DATA   SEGMENT PARA PUBLIC 'DATA'

PrevTrap03Handler   dd  0

_DATA   ENDS


_TEXT$00   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING
align dword


;++
;
; Routine Description:
;
;    Handle INT 3 breakpoint.
;
;    The trap is caused by a single byte INT 3 instruction.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the instruction immediately
;    following the INT 3 instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--

align dword

        public  HarnessTrap03Handler

HarnessTrap03Handler    proc

        pushfd
        pushad
        mov     eax, _HarnessTrap03TlsIndex
        stdCall _SafeTlsGetValue, <eax>
        test    eax, eax
        jnz     @F
        popad
        popfd
        jmp     dword ptr PrevTrap03Handler
@@:
        popad
        popfd

;
; Build the trap frame and set registers needed by a trap
;
                                        ; control registers are at TOS already
        push    0                       ; dummy error code
        ENTER_TRAP

;
; Set up exception record and arguments for raising breakpoint exception
;

        mov     esi, ecx                ; ExceptionInfo 2
        mov     edi, edx                ; ExceptionInfo 3
        mov     edx, eax                ; ExceptionInfo 1

        mov     ebx, [ebp]+TsEip
        dec     ebx                     ; (ebx)-> int3 instruction
        mov     ecx, 3
        mov     eax, STATUS_BREAKPOINT

        sub     esp, ExceptionRecordLength
        mov     dword ptr [esp]+ErExceptionCode, eax
        xor     eax, eax
        mov     dword ptr [esp]+ErExceptionFlags, eax
        mov     dword ptr [esp]+ErExceptionRecord, eax
        mov     dword ptr [esp]+ErExceptionAddress, ebx
        mov     dword ptr [esp]+ErNumberParameters, ecx

        lea     ebx, [esp + ErExceptionInformation]
        mov     [ebx], edx
        mov     [ebx+4], esi
        mov     [ebx+8], edi

;
; Set up arguments and call _HarnessDispatchBreakpointException
;

        mov     ecx, esp
        stdCall _HarnessDispatchBreakpointException, <ecx, 0, ebp, 1>

        mov     esp, ebp
        cli
        EXIT_ALL    ,,NoPreviousMode

HarnessTrap03Handler    endp


;++
;
; VOID
; HarnessInitializeTrap03Handler(
;     VOID
;     )
;
; Routine Description:
;
;    This routine installs trap03 handler
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None
;
;--

align dword

cPublicProc _HarnessInitializeTrap03Handler ,0

        push    ebp
        mov     ebp, esp
        sub     esp, 8

        sidt    fword ptr [ebp-8]       ; get IDT address
        mov     ecx, dword ptr [ebp-6]  ; ecx now point to IDT
        mov     eax, 3                  ; trap03
        shl     eax, 3                  ; 8 bytes per IDT entry
        add     ecx, eax                ; ecx now point to IDT entry of trap03

        mov     ax, word ptr [ecx+6]    ; save original trap03 handler
        shl     eax, 16
        mov     ax, word ptr [ecx]
        mov     PrevTrap03Handler, eax

        mov     eax, offset FLAT:HarnessTrap03Handler

        mov     word ptr [ecx], ax      ; install new handler
        shr     eax, 16
        mov     word ptr [ecx+6], ax

        mov     esp, ebp
        pop     ebp
        stdRET  _HarnessInitializeTrap03Handler

stdENDP _HarnessInitializeTrap03Handler


;++
;
; VOID
; GetStackLimits(
;    OUT PULONG LowLimit,
;    OUT PULONG HighLimit
;    )
;
; Routine Description:
;
;    This function returns the current stack limits based on the current
;    processor mode.
;
;    On the 386 we always store the stack limits in the PCR, and address
;    both PCR and TEB the same way, so this code is mode independent.
;
; Arguments:
;
;    LowLimit (esp+4) - Supplies a pointer to a variable that is to receive
;       the low limit of the stack.
;
;    HighLimit (esp+8) - Supplies a pointer to a variable that is to receive
;       the high limit of the stack.
;
; Return Value:
;
;    None.
;
;--

align dword

cPublicProc _GetStackLimits ,2

        mov     eax,fs:PcStackLimit
        mov     ecx,[esp+4]
        mov     [ecx],eax               ; Save low limit

        mov     eax,fs:PcStackBase
        mov     ecx,[esp+8]
        mov     [ecx],eax               ; Save high limit

        stdRET    _GetStackLimits

stdENDP _GetStackLimits


;++
;
;   PVOID
;   GetRegistrationHead()
;
;   Routine Description:
;
;       This function returns the address of the first Exception
;       registration record for the current context.
;
;   Arguments:
;
;       None.
;
;   Return Value:
;
;       The address of the first registration record.
;
;--

align dword

cPublicProc _GetRegistrationHead    ,0

        mov     eax,fs:PcExceptionList
        stdRET  _GetRegistrationHead

stdENDP _GetRegistrationHead


;++
;
; EXCEPTION_DISPOSITION
; RtlpExecuteHandlerForException (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext,
;    IN PEXCEPTION_ROUTINE ExceptionRoutine
;    )
;
; Routine Description:
;
;    This function allocates a call frame, stores the handler address and
;    establisher frame pointer in the frame, establishes an exception
;    handler, and then calls the specified exception handler as an exception
;    handler. If a nested exception occurs, then the exception handler of
;    of this function is called and the handler address and establisher
;    frame pointer are returned to the exception dispatcher via the dispatcher
;    context parameter. If control is returned to this routine, then the
;    frame is deallocated and the disposition status is returned to the
;    exception dispatcher.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (ebp+12) - Supplies the frame pointer of the establisher
;       of the exception handler that is to be called.
;
;    ContextRecord (ebp+16) - Supplies a pointer to a context record.
;
;    DispatcherContext (ebp+20) - Supplies a pointer to the dispatcher context
;       record.
;
;    ExceptionRoutine (ebp+24) - supplies a pointer to the exception handler
;       that is to be called.
;
; Return Value:
;
;    The disposition value returned by the specified exception handler is
;    returned as the function value.
;
;--

align dword

cPublicProc _RtlpExecuteHandlerForException,5

        mov     edx,offset FLAT:ExceptionHandler    ; Set who to register
        jmp     ExecuteHandler                      ; jump to common code

stdENDP _RtlpExecuteHandlerForException


;
;   ExecuteHandler is the common tail for RtlpExecuteHandlerForException
;   and RtlpExecuteHandlerForUnwind.
;
;   (edx) = handler (Exception or Unwind) address
;


ExceptionRecord     equ [ebp+8]
EstablisherFrame    equ [ebp+12]
ContextRecord       equ [ebp+16]
DispatcherContext   equ [ebp+20]
ExceptionRoutine    equ [ebp+24]


cPublicProc   ExecuteHandler,5

        push    ebp
        mov     ebp,esp

        push    EstablisherFrame        ; Save context of exception handler
                                        ; that we're about to call.

    .errnz   ErrHandler-4
        push    edx                     ; Set Handler address

    .errnz   ErrNext-0
        push    fs:PcExceptionList                      ; Set next pointer


        mov     fs:PcExceptionList,esp                  ; Link us on

; Call the specified exception handler.

        push    DispatcherContext
        push    ContextRecord
        push    EstablisherFrame
        push    ExceptionRecord

        mov     ecx,ExceptionRoutine
        call    ecx
        mov     esp,fs:PcExceptionList

; Don't clean stack here, code in front of ret will blow it off anyway

; Disposition is in eax, so all we do is deregister handler and return

    .errnz  ErrNext-0
        pop     fs:PcExceptionList

        mov     esp,ebp
        pop     ebp
        stdRET  ExecuteHandler

stdENDP ExecuteHandler


;++
;
; EXCEPTION_DISPOSITION
; ExceptionHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext
;    )
;
; Routine Description:
;
;    This function is called when a nested exception occurs. Its function
;    is to retrieve the establisher frame pointer and handler address from
;    its establisher's call frame, store this information in the dispatcher
;    context record, and return a disposition value of nested exception.
;
; Arguments:
;
;    ExceptionRecord (exp+4) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (esp+8) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;    ContextRecord (esp+12) - Supplies a pointer to a context record.
;
;    DispatcherContext (esp+16) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;    A disposition value ExceptionNestedException is returned if an unwind
;    is not in progress. Otherwise a value of ExceptionContinueSearch is
;    returned.
;
;--

stdPROC   ExceptionHandler,4

        mov     ecx,dword ptr [esp+4]           ; (ecx) -> ExceptionRecord
        test    dword ptr [ecx.ErExceptionFlags], (EXCEPTION_UNWINDING OR EXCEPTION_EXIT_UNWIND)
        mov     eax,ExceptionContinueSearch     ; Assume unwind
        jnz     eh10                            ; unwind, go return

;
; Unwind is not in progress - return nested exception disposition.
;

        mov     ecx,[esp+8]             ; (ecx) -> EstablisherFrame
        mov     edx,[esp+16]            ; (edx) -> DispatcherContext
        mov     eax,[ecx+8]             ; (eax) -> EstablisherFrame for the
                                        ;          handler active when we
                                        ;          nested.
        mov     [edx],eax               ; Set DispatcherContext field.
        mov     eax,ExceptionNestedException

eh10:   stdRET    ExceptionHandler

stdENDP ExceptionHandler


_TEXT$00   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\harness\loader.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    loader.h

Abstract:

    This module contains loader routine that loads and initializes test modules

--*/

#ifndef __LOADER_H__
#define __LOADER_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef VOID (WINAPI * LPTEST_STARTUP_PROC)( HANDLE );
typedef VOID (WINAPI * LPTEST_CLEANUP_PROC)( VOID );
typedef BOOL (WINAPI * LPTEST_DLLMAIN_PROC)( HINSTANCE, DWORD, PVOID );

//
// Structure to keep track of module list that the harness has loaded
// from TESTINI.INI. It also keeps any per-module data, handles, etc.
//

typedef struct _HARNESS_TEST_LIST_ENTRY {

    LIST_ENTRY List;

    //
    // The below fields are per-module, there is no global settings
    // equivalent
    //

    CHAR    FullTestPath[MAX_PATH];     // Full DOS-style path of test module
    HMODULE ModuleHandle;               // Module handle
    CHAR    FullLogPath[MAX_PATH];      // Full DOS-style path of log file
    HANDLE  LogHandle;
    HANDLE  StartTestEventHandle;       // Event to start calling StartTest
    HANDLE  EndTestEventHandle;         // Event to start calling EndTest
    ULONG   NumberOfRunningThreads;     // Number of threads running for this module

    LPTEST_STARTUP_PROC pStartupProc;   // Test startup routine
    LPTEST_CLEANUP_PROC pCleanupProc;   // Test cleanup routine
    LPTEST_CLEANUP_PROC pShutdownProc;  // Optional test shutdown routine
    LPTEST_DLLMAIN_PROC pDllMain;       // Optional DllMain

    //
    // The below fields are per-module and there are global settings
    // equivalent. Per-module settings always override global settings
    //

    ULONG ThreadStackSize;              // Similar to GlobalThreadStackSize
    ULONG LogLevel;                     // Similar to GlobalLogLevel
    ULONG LogOptions;                   // Similar to GlobalLogOptions
    ULONG Iterations;                   // Similar to GlobalIterations
    ULONG NumberOfThreads;              // Similar to GlobalNumberOfThreads
    ULONG SleepBetweenRun;              // Similar to GlobalSleepBetweenRun

} HARNESS_TEST_LIST_ENTRY, *PHARNESS_TEST_LIST_ENTRY;

BOOL
HarnessLoadTestModule(
    PHARNESS_TEST_LIST_ENTRY p,
    SOCKET Socket,
    BOOL CreateLog
    );

VOID
HarnessUnloadTestModule(
    PHARNESS_TEST_LIST_ENTRY p,
    BOOL CloseLogFile
    );

BOOL
HarnessLoadTestModules(
    VOID
    );

BOOL
HarnessInitializeModule(
    LPCSTR ModuleName,
    SOCKET Socket,
    PHARNESS_TEST_LIST_ENTRY ModuleInfo
    );

VOID
HarnessCleanupModule(
    PHARNESS_TEST_LIST_ENTRY ModuleInfo
    );

VOID
HarnessInitGlobalVars(
    VOID
    );

VOID
HarnessPostLog(
    VOID
    );

LONG
WINAPI
HarnessUnhandledExceptionFilter(
    LPEXCEPTION_POINTERS ExceptionInfo
    );

extern ULONG DebugVerbose;
extern BOOL TrackAllocation;
extern BOOL BreaksBeforeLoadTestModule;
extern BOOL FormatAllMUs;
extern const CHAR GeneralSettingsSectionName[];

#ifdef __cplusplus
}
#endif

#endif // __LOADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\harness\logging.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    logging.c

Abstract:

    This module contains routine to initialize logging engine

--*/

#include "precomp.h"
#include "logging.h"

HANDLE HarnessLogHandle;
extern WEB_SERVER_INFO_A WebServerInfo;

BOOL
WINAPI
HarnessInitializeLogging(
    VOID
    )
{
    HarnessLogHandle = xCreateLog_A(
                            "t:\\harness.txt",
                            &WebServerInfo,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG
                            );
    if ( HarnessLogHandle == INVALID_HANDLE_VALUE ) {
        DbgPrint( "HARNESS: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()) );
    } else {
        xSetComponent( HarnessLogHandle, "Harness", "Harness" );
        xSetFunctionName( HarnessLogHandle, "This is not a test result" );
        xSetOwnerAlias( HarnessLogHandle, "schanbai" );
        xStartVariation( HarnessLogHandle, "Internal Logging" );
    }

    return HarnessLogHandle != INVALID_HANDLE_VALUE;
}

BOOL
WINAPI
HarnessShutdownLogging(
    VOID
    )
{
    ASSERT( HarnessLogHandle != INVALID_HANDLE_VALUE );
    xEndVariation( HarnessLogHandle );
    xCloseLog( HarnessLogHandle );
    return TRUE;
}

BOOL
HarnessLog(
    DWORD LogLevel,
    LPSTR Format,
    ...
    )
{
    BOOL b;
    va_list arg_ptr;

    ASSERT( HarnessLogHandle != INVALID_HANDLE_VALUE );

    va_start( arg_ptr, Format );
    b = xLog_va( HarnessLogHandle, LogLevel, Format, arg_ptr );
    va_end( arg_ptr );
    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\harness\loader.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    loader.c

Abstract:

    This module contains loader routine that loads and initializes test
    modules (statically linked).

--*/

#include "precomp.h"
#include "loader.h"
#include "logging.h"

#pragma data_seg( ".EXP$A" )
EXP_TABLE_DIRECTORY __export_table_directory_start[] = { NULL };

#pragma data_seg( ".EXP$Z" )
EXP_TABLE_DIRECTORY __export_table_directory_end[] = { NULL };

#pragma data_seg()

#pragma comment(linker, "/merge:.EXP=.export")

//
// Section names that we use in TESTINI.INI
//

const CHAR GeneralSettingsSectionName[] = "GeneralSettings";
const CHAR ServersSectionName[]         = "Servers";

//
// Key name that we use in both global setting and per-module settings
//

const CHAR LogLevelKeyName[]        = "LogLevel";
const CHAR LogOptionsKeyName[]      = "LogOptions";
const CHAR IterationsKeyName[]      = "Iterations";
const CHAR NumberOfThreadsKeyName[] = "NumberOfThreads";
const CHAR ThreadStackSizeKeyName[] = "ThreadStackSize";
const CHAR SleepBetweenRunKeyName[] = "SleepBetweenRun";
const CHAR ServerKeyName[]          = "Server";
const CHAR FormatAllMUsKeyName[]    = "FormatAllMUs";

//
// The followings are global settings. However per-module settings will
// always override global settings. We will use global settings only if
// there is no per-module settings specified
//

ULONG GlobalThreadStackSize;
ULONG GlobalLogLevel;
ULONG GlobalIterations;
ULONG GlobalNumberOfThreads;
ULONG GlobalLogOptions;
ULONG GlobalSleepBetweenRun;

ULONG DebugVerbose;
BOOL  BreaksBeforeLoadTestModule;
BOOL  FormatAllMUs;

//
// Web server and web pages information for web posting
//

WEB_SERVER_INFO_A WebServerInfo;
CHAR HttpServer[1024];
CHAR ConfigPage[1024];
CHAR StatePage[1024];
CHAR LogPage[1024];
CHAR WebPostFileName[MAX_PATH];

HANDLE
FindModuleHandle(
    LPCSTR ModuleName
    )
{
    PEXP_TABLE_DIRECTORY _ptbegin = __export_table_directory_start;
    PEXP_TABLE_DIRECTORY _ptend = __export_table_directory_end;

    while ( _ptbegin < _ptend ) {
        if ( _ptbegin->ModuleName && _stricmp(_ptbegin->ModuleName, ModuleName) == 0 ) {
            return (HANDLE)_ptbegin;
        }
        _ptbegin++;
    }

    return NULL;
}

DWORD
WINAPI
GetModuleFileNameA(
    HANDLE ModuleHandle,
    LPSTR FileName,
    DWORD Size
    )
{
    PEXP_TABLE_DIRECTORY _ptbegin = __export_table_directory_start;
    PEXP_TABLE_DIRECTORY _ptend = __export_table_directory_end;

    while ( _ptbegin < _ptend ) {
        if ( _ptbegin->ModuleName && ModuleHandle == (HANDLE)_ptbegin ) {
            lstrcpynA( FileName, _ptbegin->ModuleName, Size );
            return lstrlenA( FileName );
        }
        _ptbegin++;
    }

    return 0;
}

PROC
FindProcAddress(
    PCHAR ModuleName,
    PCHAR ProcName
    )
{
    PEXP_TABLE_DIRECTORY _ptbegin = __export_table_directory_start;
    PEXP_TABLE_DIRECTORY _ptend = __export_table_directory_end;
    PROC Proc = NULL;

    while ( _ptbegin < _ptend ) {
        if ( _ptbegin->ModuleName && _stricmp(_ptbegin->ModuleName, ModuleName) == 0 ) {
            PEXP_TABLE_ENTRY p = _ptbegin->TableEntry;
            while ( p->pProcName && p->pfnProc ) {
                if ( _stricmp(p->pProcName, ProcName) == 0 ) {
                    Proc = p->pfnProc;
                    goto done;
                }
                p++;
            }
        }
        _ptbegin++;
    }

done:
    return Proc;
}

VOID
HarnessInitGlobalVars(
    VOID
    )
{
    DebugVerbose = GetProfileIntA( GeneralSettingsSectionName, "DebugVerbose", 0 );
    BreaksBeforeLoadTestModule = GetProfileIntA( GeneralSettingsSectionName, "BreaksBeforeLoadTestModule", FALSE );

    //
    // Get global setting of stack size of thread, the per-module settings
    // will however override this global value (if exists)
    //

    GlobalThreadStackSize = GetProfileIntA( GeneralSettingsSectionName, ThreadStackSizeKeyName, 16384 );

    //
    // Get global setting of SleepBetweenRun, the per-module settings
    // will however override this global value (if exists)
    //

    GlobalSleepBetweenRun = GetProfileIntA( GeneralSettingsSectionName, SleepBetweenRunKeyName, 10000 );

    //
    // Get global setting of log level, the per-module settings
    // will however override this global value (if exists)
    //
    GlobalLogLevel = GetProfileIntA( GeneralSettingsSectionName, LogLevelKeyName, XLL_LOGALL );

    //
    // Get global setting of log level, the per-module settings
    // will however override this global value (if exists)
    //

    GlobalLogOptions = GetProfileIntA(
                            GeneralSettingsSectionName,
                            LogOptionsKeyName,
                            XLO_DEBUG | XLO_CONFIG | XLO_STATE | XLO_REFRESH
                            );

    //
    // Get global setting of iterations, the per-module settings
    // will however override this global value (if exists)
    //

    GlobalIterations = GetProfileIntA( GeneralSettingsSectionName, IterationsKeyName, 1 );

    //
    // Get global setting of number of threads, the per-module settings
    // will however override this global value (if exists)
    //

    GlobalNumberOfThreads = GetProfileIntA( GeneralSettingsSectionName, NumberOfThreadsKeyName, 1 );

    if ( GlobalIterations == 0 ) {
        GlobalIterations = 1;
    }

    if ( GlobalNumberOfThreads == 0 ) {
        GlobalNumberOfThreads = 1;
    }
    
    //
    // Get global setting of whether ot not to format all attached MUs
    //

    FormatAllMUs = GetProfileIntA( GeneralSettingsSectionName, FormatAllMUsKeyName, 0 );

    GetProfileStringA( ServersSectionName, "HttpServer", "", HttpServer, ARRAY_SIZE(HttpServer) );
    IniRemoveStringCommentA( HttpServer );

    GetProfileStringA( ServersSectionName, "ConfigPage", "", ConfigPage, ARRAY_SIZE(ConfigPage) );
    IniRemoveStringCommentA( ConfigPage );

    GetProfileStringA( ServersSectionName, "StatePage", "", StatePage, ARRAY_SIZE(StatePage) );
    IniRemoveStringCommentA( StatePage );

    GetProfileStringA( ServersSectionName, "LogPage", "", LogPage, ARRAY_SIZE(LogPage) );
    IniRemoveStringCommentA( LogPage );

    GetProfileStringA( ServersSectionName, "WebPostFileName", "", WebPostFileName, ARRAY_SIZE(WebPostFileName) );
    IniRemoveStringCommentA( WebPostFileName );

    ZeroMemory( &WebServerInfo, sizeof(WebServerInfo) );
    WebServerInfo.lpszHttpServer      = HttpServer[0] ? HttpServer : NULL;
    WebServerInfo.lpszConfigPage      = ConfigPage[0] ? ConfigPage : NULL;
    WebServerInfo.lpszStatePage       = StatePage[0]  ? StatePage  : NULL;
    WebServerInfo.lpszLogPage         = LogPage[0]    ? LogPage    : NULL;
    WebServerInfo.lpszWebPostFileName = WebPostFileName[0] ? WebPostFileName : NULL;

    if ( DebugVerbose ) {
        DbgPrint(
            "HARNESS: HttpServer = \"%s\"\n"
            "         ConfigPage = \"%s\"\n"
            "         StatePage  = \"%s\"\n"
            "         LogPage    = \"%s\"\n",
            HttpServer,
            ConfigPage,
            StatePage,
            LogPage
            );
    }
}

VOID
HarnessInitPerModuleVars(
    PHARNESS_TEST_LIST_ENTRY p,
    PCSTR LogPath
    )
{
    p->LogLevel = GetProfileIntA( p->FullTestPath, LogLevelKeyName, GlobalLogLevel );
    p->LogOptions = GetProfileIntA( p->FullTestPath, LogOptionsKeyName, GlobalLogOptions );
    p->Iterations = GetProfileIntA( p->FullTestPath, IterationsKeyName, GlobalIterations );
    p->NumberOfThreads = GetProfileIntA( p->FullTestPath, NumberOfThreadsKeyName, GlobalNumberOfThreads );
    p->ThreadStackSize = GetProfileIntA( p->FullTestPath, ThreadStackSizeKeyName, GlobalThreadStackSize );
    p->SleepBetweenRun = GetProfileIntA( p->FullTestPath, SleepBetweenRunKeyName, GlobalSleepBetweenRun );

    if ( p->Iterations == 0 ) {
        p->Iterations = 1;
    }

    if ( p->NumberOfThreads == 0 ) {
        p->NumberOfThreads = 1;
    }

    //
    // If full log file path is specified, we will use that path
    //

    GetProfileStringA( p->FullTestPath, "LogFile", "", p->FullLogPath, ARRAY_SIZE(p->FullLogPath) );
    p->LogHandle = INVALID_HANDLE_VALUE;

    if ( p->FullLogPath[0] == 0 ) {

        PSTR DotPtr;

        strcpy( p->FullLogPath, "t:\\" );
        strcat( p->FullLogPath, LogPath );
        IniRemoveStringCommentA( p->FullLogPath );
        DotPtr = strrchr( p->FullLogPath, '.' );
        if ( DotPtr ) {
            strcpy( DotPtr, ".log" );
        } else {
            strcat( p->FullLogPath, ".log" );
        }

    } else if ( p->FullLogPath[0] && p->FullLogPath[1] != ':' ) {

        RtlMoveMemory(
            &p->FullLogPath[ sizeof("t:\\")-1 ],
            p->FullLogPath,
            sizeof(CHAR) * (strlen(p->FullLogPath) + 1)
            );

        RtlMoveMemory( p->FullLogPath, "t:\\", sizeof("t:\\")-1 );
    }

    IniRemoveStringCommentA( p->FullLogPath );
}

VOID
HarnessUnloadTestModule(
    PHARNESS_TEST_LIST_ENTRY p,
    BOOL CloseLogFile
    )
/*++

Routine Description:

    Unload the test module section to free up memory. This routine will
    close log file if requested

Arguments:

    p - Pointer to HARNESS_TEST_LIST_ENTRY structure

Return Value:

    None

--*/
{
    p->pStartupProc = NULL;
    p->pCleanupProc = NULL;
    p->pShutdownProc = NULL;
    p->pDllMain = NULL;
    p->ModuleHandle = NULL;

    if ( CloseLogFile && p->LogHandle != INVALID_HANDLE_VALUE ) {
        xCloseLog( p->LogHandle );
        p->LogHandle = INVALID_HANDLE_VALUE;
    }
}

BOOL
HarnessLoadTestModule(
    PHARNESS_TEST_LIST_ENTRY p,
    SOCKET Socket,
    BOOL CreateLog
    )
/*++

Routine Description:

    This routine will load the test module

Arguments:

    p - Pointer to HARNESS_TEST_LIST_ENTRY structure

Return Value:

    TRUE/FALSE

--*/
{
    ASSERT( p->pStartupProc == NULL );
    ASSERT( p->pCleanupProc == NULL );
    ASSERT( p->pShutdownProc == NULL );
    ASSERT( p->pDllMain == NULL );
    ASSERT( p->ModuleHandle == NULL );

    if ( BreaksBeforeLoadTestModule ) {
        __asm int 3
    }

    //
    // TODO: add code to load XE section later
    //

    p->ModuleHandle = FindModuleHandle( p->FullTestPath );
    p->pStartupProc = (LPTEST_STARTUP_PROC)FindProcAddress( p->FullTestPath, "StartTest" );
    p->pCleanupProc = (LPTEST_CLEANUP_PROC)FindProcAddress( p->FullTestPath, "EndTest" );
    p->pShutdownProc = (LPTEST_CLEANUP_PROC)FindProcAddress( p->FullTestPath, "ShutdownTest" );
    p->pDllMain = (LPTEST_DLLMAIN_PROC)FindProcAddress( p->FullTestPath, "DllMain" );

    if ( !p->pStartupProc || !p->pCleanupProc) {
        HarnessLog( XLL_WARN, "Unable to locate StartTest or EndTest in %s", p->FullTestPath );
        HarnessUnloadTestModule( p, FALSE );
        return FALSE;
    }

    //
    // Create log file for this module
    //

    if ( CreateLog && p->LogHandle == INVALID_HANDLE_VALUE ) {
        p->LogHandle = xCreateLog_A(
                            p->FullLogPath,
                            &WebServerInfo,
                            Socket,
                            p->LogLevel,
                            p->LogOptions
                            );
    }

    if ( CreateLog && p->LogHandle == INVALID_HANDLE_VALUE ) {
        HarnessLog(
            XLL_WARN,
            "Unable to create log object for log file %s (%s)\n",
            p->FullLogPath,
            WinErrorSymbolicName(GetLastError())
            );
        HarnessUnloadTestModule( p, FALSE );
        return FALSE;
    }

    return TRUE;
}

BOOL
HarnessCreateSynchronizationObjects(
    IN PHARNESS_TEST_LIST_ENTRY p
    )
{
    p->StartTestEventHandle = CreateEvent( NULL, TRUE, FALSE, NULL );
    p->EndTestEventHandle = CreateEvent( NULL, TRUE, FALSE, NULL );

    if ( !p->StartTestEventHandle || !p->EndTestEventHandle ) {
        return FALSE;
    }

    return TRUE;
}

VOID
HarnessDestroySynchronizationObjects(
    IN PHARNESS_TEST_LIST_ENTRY p
    )
{
    if ( p->StartTestEventHandle ) {
        CloseHandle( p->StartTestEventHandle );
        p->StartTestEventHandle = NULL;
    }

    if ( p->EndTestEventHandle ) {
        CloseHandle( p->EndTestEventHandle );
        p->EndTestEventHandle = NULL;
    }
}

VOID
HarnessCleanupModule(
    PHARNESS_TEST_LIST_ENTRY ModuleInfo
    )
{
    HarnessDestroySynchronizationObjects( ModuleInfo );

#if DBG
    if ( !GetProfileIntA( GeneralSettingsSectionName, "StressTestMode", FALSE ) ) {
        ASSERT( ModuleInfo->LogHandle == INVALID_HANDLE_VALUE );
    }
#endif

    if ( ModuleInfo->LogHandle != INVALID_HANDLE_VALUE ) {
        xCloseLog( ModuleInfo->LogHandle );
        ModuleInfo->LogHandle = INVALID_HANDLE_VALUE;
    }
}

BOOL
HarnessInitializeModule(
    LPCSTR ModuleName,
    SOCKET  Socket,
    PHARNESS_TEST_LIST_ENTRY ModuleInfo
    )
/*++

Routine Description:

    This routine will load the test module, create synchronization objects

Arguments:

    p - Pointer to HARNESS_TEST_LIST_ENTRY structure

Return Value:

    TRUE/FALSE

--*/
{
    RtlZeroMemory( ModuleInfo, sizeof(HARNESS_TEST_LIST_ENTRY) );
    ModuleInfo->LogHandle = INVALID_HANDLE_VALUE;
    strncpy( ModuleInfo->FullTestPath, ModuleName, MAX_PATH );
    ModuleInfo->FullTestPath[MAX_PATH-1] = 0;
    IniRemoveStringCommentA( ModuleInfo->FullTestPath );

    HarnessInitPerModuleVars( ModuleInfo, ModuleName );

    if ( HarnessLoadTestModule(ModuleInfo, Socket, FALSE) ) {
        if ( !HarnessCreateSynchronizationObjects(ModuleInfo) ) {
            HarnessLog(
                XLL_WARN,
                "Unable to create synchronization objects for %s (%s)\n",
                ModuleInfo->FullTestPath,
                WinErrorSymbolicName(GetLastError())
                );
        } else {
            // Unload test module here because module runner will load it again
            HarnessUnloadTestModule( ModuleInfo, FALSE );
            return TRUE;
        }
    }

    HarnessUnloadTestModule( ModuleInfo, FALSE );
    HarnessDestroySynchronizationObjects( ModuleInfo );

    if ( ModuleInfo->LogHandle != INVALID_HANDLE_VALUE ) {
        xCloseLog( ModuleInfo->LogHandle );
        ModuleInfo->LogHandle = INVALID_HANDLE_VALUE;
        DeleteFile( ModuleInfo->FullLogPath );
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\harnskdx\harnskdx.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved

Module Name:

    harnskdx.c

Abstract:

    This module is kernel debugger extension for harness. It contains useful
    commands for debugging Xbox test harness

Author:

    Sakphong Chanbai (schanbai) 5-Jul-2000

Environment:

    XBox

Revision History:

--*/


#include "precomp.h"
#include "loader.h"
#include "leak.h"
#include "xtestlib.h"
#include <stdio.h>
#include <xboxverp.h>
#include <ldr.h>
#include <heap.h>

WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };

CONST CHAR * AllocationTypeString[] = {
    "malloc",
    "calloc",
    "realloc",
    "LocalAlloc",
    "GlobalAlloc",
    "HeapAlloc",
    "C++ new",
    "C++ new[]",
    "VirtualAlloc",
    "CreateEvent",
    "OpenMutex",
    "CreateSemaphore",
    "OpenSemaphore",
    "CreateWaitableTimer",
    "OpenWaitableTimer",
    "FindFirstFileA",
    "FindFirstFileW",
};

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?

BOOL
GetData(
    LPVOID ptr,
    PVOID  dwAddress,
    LONG   size,
    PCSTR  type
    )
/*++

Routine Description:

    Get 'size' bytes from the debuggee program at 'dwAddress' and place it
    in our address space at 'ptr'.  Use 'type' in an error printout if necessary

Arguments:

Return Value:

--*/
{
    BOOL b;
    LONG BytesRead;
    LONG count = size;
    ULONG_PTR dwAddr = (ULONG_PTR)dwAddress;

    while( size > 0 ) {

        if (count >= 3000) {
            count = 3000;
        }

        b = ReadMemory(dwAddr, ptr, count<size ? count : size, &BytesRead );

        if (!b || BytesRead != (count<size ? count : size)) {
            dprintf( "Unable to read %u bytes at %X, for %s\n", count<size ? count : size, dwAddress, type );
            return FALSE;
        }

        dwAddr += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
    }

    return TRUE;
}

BOOL
GetString(
    IN  LPSTR dwAddress,
    OUT LPSTR buf,
    IN  ULONG MaxChars
    )
{
    do {
        if( !GetData( buf, dwAddress, sizeof( *buf ), "Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( (--MaxChars) != 0 && *buf++ != '\0' );

    return TRUE;
}

BOOL
GetStringFromLPSTR(
    LPVOID dwAddress,
    LPSTR buf,
    ULONG MaxChars
    )
{
    LPSTR lpAddress;
    *buf = 0;

    if ( !GetData( &lpAddress, dwAddress, sizeof(LPVOID), "LPVOID" ) ) {
        return FALSE;
    }

    return GetString( lpAddress, buf, MaxChars );
}

DECLARE_API( help )
{
    dprintf( "Harness kernel debugger extensions:\n" );
    dprintf( "\n" );
    dprintf( "  testlist    - dumps list of test modules\n" );
    dprintf( "  leakdump    - dumps allocation tracking\n" );
    dprintf( "  heaplist    - dumps all private heap created by test modules\n" );
    dprintf( "  heap        - dumps memory allocated from heap handle\n" );
    dprintf( "\n" );
}

DECLARE_API( testlist )
{
    PVOID HarnessTestListHead;
    LIST_ENTRY ListEntry;
    PLIST_ENTRY NextEntry;
    HARNESS_TEST_LIST_ENTRY ModuleEntry;
    PHARNESS_TEST_LIST_ENTRY p;
    ULONG ModuleCount = 0;
    ULONG Flags = 0;
    CHAR ListEntrySymbol[256];

    HarnessTestListHead = (PVOID)GetExpression( "harness!HarnessTestListHead" );

    sscanf( args, "%s %d", ListEntrySymbol, &Flags );

    if ( !HarnessTestListHead ) {
        HarnessTestListHead = (PVOID)GetExpression( ListEntrySymbol );
    }

    if ( !HarnessTestListHead ) {
        dprintf( "unable to resolve symbol \"HarnessTestListHead\"\n" );
        return;
    }

    if ( !GetData(&ListEntry, HarnessTestListHead, sizeof(LIST_ENTRY), "LIST_ENTRY") ) {
        return;
    }

    NextEntry = ListEntry.Flink;

    while ( NextEntry != HarnessTestListHead ) {

        if ( CheckControlC() ) {
            break;
        }

        p = CONTAINING_RECORD( NextEntry, HARNESS_TEST_LIST_ENTRY, List );

        if ( !GetData(&ModuleEntry, p, sizeof(HARNESS_TEST_LIST_ENTRY), "HARNESS_TEST_LIST_ENTRY") ) {
            break;
        }

        ModuleCount++;

        p = &ModuleEntry;
        dprintf( "Entry #%lu (%p): %s\n", ModuleCount, NextEntry, p->FullTestPath );

        if ( Flags & 1 ) {
            dprintf( "  FullTestPath           = %s\n",  p->FullTestPath );
            dprintf( "  ModuleHandle           = %p\n",  p->ModuleHandle );
            dprintf( "  FullLogPath            = %s\n",  p->FullLogPath );
            dprintf( "  LogLevel               = %d\n",  p->LogLevel );
            dprintf( "  LogOptions             = %d\n",  p->LogOptions );
            dprintf( "  LogHandle              = %p\n",  p->LogHandle );
            dprintf( "  Iterations             = %d\n",  p->Iterations );
            dprintf( "  NumberOfThreads        = %d\n",  p->NumberOfThreads );
            dprintf( "  ThreadStackSize        = %d\n",  p->ThreadStackSize );
            dprintf( "  SleepBetweenRun        = %d\n",  p->SleepBetweenRun );
            dprintf( "  StartTestEventHandle   = %p\n",  p->StartTestEventHandle );
            dprintf( "  StartTest address      = %p\n",  p->pStartupProc );
            dprintf( "  EndTestTest address    = %p\n",  p->pCleanupProc );
            dprintf( "  ShutdownTest address   = %p\n",  p->pShutdownProc );
            dprintf( "\n" );
        }

        NextEntry = p->List.Flink;
    }

    dprintf( "%lu module(s) found in the list\n\n", ModuleCount );
}

VOID
DumpOutstandingAllocation(
    AllocationType AllocType,
    ULONG Caller,
    ULONG Occurrences,
    ULONG TotalSize,
    PVOID *StackBackTrace OPTIONAL
    )
{
    CHAR CallerSymbol[256];
    ULONG Stacks[MAX_STACK_DEPTH];
    ULONG i, Displacement;
    BOOL b;

    GetSymbol( (PVOID)Caller, CallerSymbol, &Displacement );
    if ( !CallerSymbol[0] ) {
        sprintf( CallerSymbol, "0x%p", Caller );
    }

    dprintf(
        "\r%s allocated by %s, stack back trace %p, %lu occurence(s), total %lu bytes\n",
        AllocationTypeString[AllocType],
        CallerSymbol,
        StackBackTrace,
        Occurrences,
        TotalSize
        );

    // Display stack back trace
    b = GetData( Stacks, StackBackTrace, MAX_STACK_DEPTH*sizeof(ULONG_PTR), "ULONG_PTR" );

    for ( i=0; b && i<MAX_STACK_DEPTH && Stacks[i]; i++ ) {
        GetSymbol( (PVOID)Stacks[i], CallerSymbol, &Displacement );
        if ( CallerSymbol[0] ) {
            dprintf( "\t%s+0x%x\n", CallerSymbol, Displacement );
        } else {
            dprintf( "\t0x%x\n", Stacks[i] );
        }
    }

    dprintf( "\n" );
}

DECLARE_API( leakdump )
{
    PVOID HistoryDatabase;
    PVOID HistoryEntriesCountPtr;
    ULONG HistoryEntriesCount;
    LIST_ENTRY ListEntry;
    PLIST_ENTRY NextEntry;
    ALLOCATION_HISTORY LeakEntry;
    PALLOCATION_HISTORY p;
    ULONG StartEntry;
    ULONG Occurrences = 0;
    ULONG LastCaller = 0;
    ULONG LastSize = 0;
    AllocationType LastAllocType = 0;
    PVOID *LastBackTrace = NULL;

    sscanf( args, "%ld", &StartEntry );

    HistoryDatabase = (PVOID)GetExpression( "xtestlib!HistoryDatabase" );
    if ( !HistoryDatabase ) {
        dprintf( "unable to resolve symbol \"xtestlib!HistoryDatabase\"\n" );
        return;
    }

    HistoryEntriesCountPtr = (PVOID)GetExpression( "xtestlib!HistoryEntriesCount" );
    if ( !HistoryEntriesCountPtr ) {
        dprintf( "unable to resolve symbol \"xtestlib!HistoryEntriesCount\"\n" );
        return;
    }

    if ( !GetData(&ListEntry, HistoryDatabase, sizeof(LIST_ENTRY), "LIST_ENTRY") ) {
        return;
    }

    if ( !GetData(&HistoryEntriesCount, HistoryEntriesCountPtr, sizeof(ULONG), "ULONG") ) {
        return;
    }

    dprintf( "%lu allocation(s) found in the list\n\n", HistoryEntriesCount );

    if ( !HistoryEntriesCount ) {
        return;
    }

    NextEntry = ListEntry.Flink;
    dprintf( "Searching..." );

    while ( NextEntry != HistoryDatabase ) {

        if ( CheckControlC() ) {
            break;
        }

        p = CONTAINING_RECORD( NextEntry, ALLOCATION_HISTORY, List );

        if ( !GetData(&LeakEntry, p, sizeof(ALLOCATION_HISTORY), "ALLOCATION_HISTORY") ) {
            break;
        }

        p = &LeakEntry;

        if ( !LastCaller ) {
            Occurrences = 0;
            LastCaller = p->Caller;
            LastAllocType = p->AllocType;
            LastSize = p->Size;
            LastBackTrace = p->StackBackTrace;
        }

        if ( LastCaller != p->Caller ) {
            DumpOutstandingAllocation( LastAllocType, LastCaller, Occurrences, LastSize, LastBackTrace );
            LastAllocType = p->AllocType;
            LastCaller = p->Caller;
            Occurrences = 1;
            LastSize = p->Size;
            LastBackTrace = p->StackBackTrace;
            dprintf( "Searching..." );
        } else {
            Occurrences++;
            LastSize += p->Size;
        }

        NextEntry = p->List.Flink;
    }

    // Dump the last one
    DumpOutstandingAllocation( LastAllocType, LastCaller, Occurrences, LastSize, LastBackTrace );
}

VOID
DisplayVirtualAllocLists(
    PHEAP HeapPtr,
    SIZE_T *TotalCommittedSize
    )
{
    LIST_ENTRY ListEntry;
    PLIST_ENTRY NextEntry;
    HEAP_VIRTUAL_ALLOC_ENTRY HeapVirtualAllocEntry;
    PHEAP_VIRTUAL_ALLOC_ENTRY p;
    SIZE_T CommittedSize;

    if ( !GetData(&ListEntry, &HeapPtr->VirtualAllocdBlocks, sizeof(LIST_ENTRY), "LIST_ENTRY") ) {
        return;
    }

    NextEntry = ListEntry.Flink;
    while ( NextEntry != &HeapPtr->VirtualAllocdBlocks ) {
        if ( CheckControlC() ) {
            break;
        }

        p = CONTAINING_RECORD( NextEntry, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

        if ( !GetData(&HeapVirtualAllocEntry, p, sizeof(HEAP_VIRTUAL_ALLOC_ENTRY), "HEAP_VIRTUAL_ALLOC_ENTRY") ) {
            break;
        }

        p = &HeapVirtualAllocEntry;
        CommittedSize = p->CommitSize - p->BusyBlock.Size;
        *TotalCommittedSize += CommittedSize;

        dprintf(
            "  Virtual Alloc List: %p, bytes committed: %lu\n",
            NextEntry,
            CommittedSize
            );

        NextEntry = p->Entry.Flink;
    }
}


VOID
DisplayHeapSegments(
    PHEAP HeapPtr,
    SIZE_T *TotalBytesCommitted
    )
{
    ULONG i;
    HEAP Heap;
    HEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];
    SIZE_T SizeCommitted;

    if ( !GetData(&Heap, HeapPtr, sizeof(HEAP), "HEAP") ) {
        return;
    }

    for ( i=0; i<HEAP_MAXIMUM_SEGMENTS; i++ ) {

        if ( Heap.Segments[ i ] != NULL ) {

            if ( !GetData(&Segments[i], Heap.Segments[i], sizeof(HEAP_SEGMENT), "HEAP_SEGMENT") ) {
                continue;
            }

            SizeCommitted = (DWORD_PTR)(Segments[ i ].LastValidEntry) - \
                            (DWORD_PTR)(i == 0 ? (DWORD_PTR)HeapPtr : (DWORD_PTR)Heap.Segments[ i ]) - \
                            (Segments[ i ].NumberOfUnCommittedPages * PAGE_SIZE);

            dprintf(
                "  Segment at %p to %p, bytes committed: %lu\n",
                i == 0 ? (PVOID)HeapPtr : (PVOID)Heap.Segments[ i ],
                Segments[ i ].LastValidEntry,
                SizeCommitted
                );

            *TotalBytesCommitted += SizeCommitted;
        }
    }
}

DECLARE_API( heap )
{
    PHEAP HeapPtr;
    SIZE_T TotalBytesCommitted = 0;

    HeapPtr = (PHEAP)GetExpression( args );
    DisplayHeapSegments( HeapPtr, &TotalBytesCommitted );
    DisplayVirtualAllocLists( HeapPtr, &TotalBytesCommitted );
    dprintf( "\nTotal bytes committed: %ld\n", TotalBytesCommitted );
}

DECLARE_API( heaplist )
{
    PVOID HeapHandleDatabasePtr, HeapHandleDatabase;
    PRIVATE_HEAP_RECORD HeapRecord[MAX_HEAP_HANDLE_TRACKING];
    PPRIVATE_HEAP_RECORD HeapRecordPtr;
    LDR_CURRENT_IMAGE XeLdrCurrentImage;
    PLDR_CURRENT_IMAGE XeLdrCurrentImagePtr;
    XIMAGE_HEADER ImageHeader;
    ULONG i, NumberOfModules;
    PXIMAGE_MODULE_HEADER ModuleHeader;
    PHEAP HeapPtr;
    SIZE_T TotalBytesCommitted = 0;
    CHAR ModuleName[MAX_PATH];
    PVOID MiscData;

    HeapHandleDatabasePtr = (PVOID)GetExpression( "xtestlib!HeapHandleDatabase" );
    if ( !HeapHandleDatabasePtr ) {
        dprintf( "unable to resolve symbol \"xtestlib!HeapHandleDatabase\"\n" );
        return;
    }

    if ( !GetData(&HeapHandleDatabase, HeapHandleDatabasePtr, sizeof(PVOID), "PVOID") ) {
        return;
    }

    XeLdrCurrentImagePtr = (PLDR_CURRENT_IMAGE)GetExpression( "nt!XeLdrCurrentImage" );
    if ( !XeLdrCurrentImagePtr ) {
        dprintf( "unable to resolve symbol \"nt!XeLdrCurrentImage\"\n" );
        return;
    }

    if ( !GetData(&XeLdrCurrentImage, XeLdrCurrentImagePtr, sizeof(XeLdrCurrentImage), "LDR_CURRENT_IMAGE") ) {
        return;
    }

    if ( !GetData(&ImageHeader, XeLdrCurrentImage.ImageHeader, sizeof(ImageHeader), "XIMAGE_HEADER") ) {
        return;
    }

    if ( ImageHeader.Signature != XIMAGE_XBOX_SIGNATURE ) {
        dprintf( "Invalid XE image header\n" );
    }

    NumberOfModules = ImageHeader.OptionalHeader.NumberOfModules;
    ModuleHeader = (PXIMAGE_MODULE_HEADER)_alloca(NumberOfModules * sizeof(XIMAGE_MODULE_HEADER));
    if ( !ModuleHeader ) {
        dprintf( "unable to allocate memory for XIMAGE_MODULE_HEADER\n" );
    }

    if ( !GetData(
            ModuleHeader,
            XeLdrCurrentImage.FirstModuleHeader,
            NumberOfModules * sizeof(XIMAGE_MODULE_HEADER),
            "XIMAGE_MODULE_HEADER"
            ) ) {
        return;
    }

    if ( !GetData(
                HeapRecord,
                HeapHandleDatabase,
                sizeof(HeapRecord),
                "PRIVATE_HEAP_RECORD"
                ) ) {
        return;
    }

    MiscData = XIMAGE_MISCDATA( &ImageHeader, XeLdrCurrentImage.VarImageHeader );

    for ( i=0, HeapRecordPtr=HeapRecord; i<MAX_HEAP_HANDLE_TRACKING; i++, HeapRecordPtr++ ) {
        if ( HeapRecordPtr->HeapHandle ) {
            HeapPtr = (PHEAP)HeapRecordPtr->HeapHandle;

            ModuleName[0] = 0;
            GetString(
                (PCHAR)MiscData + ModuleHeader[HeapRecordPtr->OwnerModuleIndex].NameOfs,
                ModuleName,
                sizeof(ModuleName)
                );

            dprintf(
                "\nHeap handle: 0x%p (%s)\n",
                HeapRecordPtr->HeapHandle,
                ModuleName
                );
            DisplayHeapSegments( HeapRecordPtr->HeapHandle, &TotalBytesCommitted );
            DisplayVirtualAllocLists( HeapRecordPtr->HeapHandle, &TotalBytesCommitted );
        }
    }

    dprintf( "\nTotal bytes committed: %ld\n", TotalBytesCommitted );
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s harness extension dll for build %d debugging %s kernel for build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "checked" : "free",
        SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\harnskdx\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This module is kernel debugger extension for harness. It contains useful
    commands for debugging Xbox test harness

Author:

    Sakphong Chanbai (schanbai) 5-Jul-2000

Environment:

    XBox

Revision History:

--*/



#include <ntos.h>
#include <nturtl.h>
#include <windows.h>
#pragma warning( disable : 4214 )
#include <wdbgexts.h>
#include <stdlib.h>
#include <winsockx.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\kernel32\fileapis.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fileapis.c

Abstract:

    This module contains APIs for KERNEL32. We want to use MSVCRT.DLL 
    but it couldn't be built from NT source tree. So we wrap all calls 
    required by MSVCRT.DLL here since in XBox we don't need KERNEL32.DLL

Author:

    Sakphong Chanbai (schanbai) 28-Mar-2000

Environment:

    XBox

Revision History:

--*/


#include "precomp.h"
#include <stdio.h>


BOOL
APIENTRY
CreateDirectoryA(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    ANSI thunk to CreateDirectoryW

--*/

{
    UNICODE_STRING Unicode;
    ANSI_STRING Ansi;
    NTSTATUS Status;
    BOOL b = FALSE;
    WCHAR Buffer[MAX_PATH];

    RtlInitAnsiString( &Ansi, lpPathName );
    Unicode.Buffer = Buffer;
    Unicode.Length = 0;
    Unicode.MaximumLength = MAX_PATH * sizeof(WCHAR);
    Status = RtlAnsiStringToUnicodeString( &Unicode, &Ansi, FALSE );

    if ( NT_SUCCESS(Status) ) {
        b = CreateDirectoryW( Unicode.Buffer, lpSecurityAttributes );
    } else {
        SetLastError( RtlNtStatusToDosError(Status) );
    }

    return b;
}


BOOL
APIENTRY
DeleteFileA(
    LPCSTR lpFileName
    )

/*++

Routine Description:

    ANSI thunk to DeleteFileW

--*/

{
    UNICODE_STRING Unicode;
    ANSI_STRING Ansi;
    NTSTATUS Status;
    BOOL b = FALSE;
    WCHAR Buffer[MAX_PATH];

    RtlInitAnsiString( &Ansi, lpFileName );
    Unicode.Buffer = Buffer;
    Unicode.Length = 0;
    Unicode.MaximumLength = MAX_PATH * sizeof(WCHAR);
    Status = RtlAnsiStringToUnicodeString( &Unicode, &Ansi, FALSE );

    if ( NT_SUCCESS(Status) ) {
        b = DeleteFileW( Unicode.Buffer );
    } else {
        SetLastError( RtlNtStatusToDosError(Status) );
    }

    return b;
}


BOOL
APIENTRY
SetFileAttributesA(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
    )
{
    UNICODE_STRING Unicode;
    ANSI_STRING Ansi;
    NTSTATUS Status;
    BOOL b = FALSE;
    WCHAR Buffer[MAX_PATH];

    RtlInitAnsiString( &Ansi, lpFileName );
    Unicode.Buffer = Buffer;
    Unicode.Length = 0;
    Unicode.MaximumLength = MAX_PATH * sizeof(WCHAR);
    Status = RtlAnsiStringToUnicodeString( &Unicode, &Ansi, FALSE );

    if ( NT_SUCCESS(Status) ) {
        b = SetFileAttributesW( Unicode.Buffer, dwFileAttributes );
    } else {
        SetLastError( RtlNtStatusToDosError(Status) );
    }

    return b;
}


DWORD
APIENTRY
GetFileAttributesA(
    LPCSTR lpFileName
    )
{
    UNICODE_STRING Unicode;
    ANSI_STRING Ansi;
    WCHAR FileName[MAX_PATH];
    NTSTATUS Status;

    RtlInitAnsiString( &Ansi, lpFileName );
    Unicode.Buffer = FileName;
    Unicode.Length = 0;
    Unicode.MaximumLength = MAX_PATH * sizeof(WCHAR);
    Status = RtlAnsiStringToUnicodeString( &Unicode, &Ansi, FALSE );

    if ( NT_SUCCESS(Status) ) {
        return GetFileAttributesW( FileName );
    }

    return ~0ul;
}


HANDLE
APIENTRY
FindFirstFileA(
    LPCSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    )

/*++

Routine Description:

    ANSI thunk to FindFirstFileW

--*/

{
    HANDLE ReturnValue;
    UNICODE_STRING Unicode;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    WIN32_FIND_DATAW FindFileData;
    ANSI_STRING AnsiString;
    WCHAR Buffer[MAX_PATH];

    RtlInitAnsiString( &AnsiString, lpFileName );
    Unicode.Buffer = Buffer;
    Unicode.Length = 0;
    Unicode.MaximumLength = MAX_PATH * sizeof(WCHAR);
    Status = RtlAnsiStringToUnicodeString( &Unicode, &AnsiString, FALSE );

    if ( !NT_SUCCESS(Status) ) {
        return INVALID_HANDLE_VALUE;
    }

    ReturnValue = FindFirstFileW(
                    Unicode.Buffer,
                    &FindFileData
                    );

    if ( ReturnValue == INVALID_HANDLE_VALUE ) {
        return ReturnValue;
        }
    RtlMoveMemory(
        lpFindFileData,
        &FindFileData,
        sizeof(WIN32_FIND_DATAA)
        );
    RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cFileName);
    AnsiString.Buffer = lpFindFileData->cFileName;
    AnsiString.MaximumLength = MAX_PATH;
    Status = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,FALSE);
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cAlternateFileName);
        AnsiString.Buffer = lpFindFileData->cAlternateFileName;
        AnsiString.MaximumLength = 14;
        Status = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,FALSE);
    }
    if ( !NT_SUCCESS(Status) ) {
        FindClose(ReturnValue);
        SetLastError( RtlNtStatusToDosError(Status) );
        return INVALID_HANDLE_VALUE;
        }
    return ReturnValue;
}


BOOL
APIENTRY
FindNextFileA(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    )

/*++

Routine Description:

    ANSI thunk to FindFileDataW

--*/

{

    BOOL ReturnValue;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    WIN32_FIND_DATAW FindFileData;

    ReturnValue = FindNextFileW(hFindFile,&FindFileData);
    if ( !ReturnValue ) {
        return ReturnValue;
        }
    RtlMoveMemory(
        lpFindFileData,
        &FindFileData,
        sizeof(WIN32_FIND_DATAA)
        );
    RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cFileName);
    AnsiString.Buffer = lpFindFileData->cFileName;
    AnsiString.MaximumLength = MAX_PATH;
    Status = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,FALSE);
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cAlternateFileName);
        AnsiString.Buffer = lpFindFileData->cAlternateFileName;
        AnsiString.MaximumLength = 14;
        Status = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,FALSE);
    }
    if ( !NT_SUCCESS(Status) ) {
        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
        }
    return ReturnValue;
}


UINT
WINAPI
GetTempFileNameA(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
    )
{
    char Slash[2];

    if ( !lpPathName ) {
        return 0;
    }

    if ( !uUnique ) {
        uUnique = NtGetTickCount();
    }

    if ( *lpPathName == '.' || *lpPathName != '\\' ) {
        lpPathName = "Z:\\";
    }

    if ( lpPathName[strlen(lpPathName) - 1] != '\\' ) {
        Slash[0] = '\\';
        Slash[1] = 0;
    } else {
        Slash[0] = 0;
    }

    sprintf( lpTempFileName, "%s%s%s%u", lpPathName, Slash, lpPrefixString, uUnique );
    return uUnique;
}


UINT
WINAPI
GetTempFileNameW(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    )
{
    WCHAR Slash[2];

    if ( !lpPathName ) {
        return 0;
    }

    if ( !uUnique ) {
        uUnique = NtGetTickCount();
    }

    if ( *lpPathName == '.' || *lpPathName != L'\\' ) {
        lpPathName = L"Z:\\";
    }

    if ( lpPathName[wcslen(lpPathName) - 1] != L'\\' ) {
        Slash[0] = L'\\';
        Slash[1] = 0;
    } else {
        Slash[0] = 0;
    }

    swprintf( lpTempFileName, L"%s%s%s%u", lpPathName, Slash, lpPrefixString, uUnique );
    return uUnique;
}


BOOL
APIENTRY
GetDiskFreeSpaceW(
    LPCWSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )

/*++

Routine Description:

    The free space on a disk and the size parameters can be returned
    using GetDiskFreeSpace.

Arguments:

    lpRootPathName - An optional parameter, that if specified, supplies
        the root directory of the disk whose free space is to be
        returned for.  If this parameter is not specified, then the root
        of the current directory is used.

    lpSectorsPerCluster - Returns the number of sectors per cluster
        where a cluster is the allocation granularity on the disk.

    lpBytesPerSector - Returns the number of bytes per sector.

    lpNumberOfFreeClusters - Returns the total number of free clusters
        on the disk.

    lpTotalNumberOfClusters - Returns the total number of clusters on
        the disk.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION SizeInfo;
    WCHAR DefaultPath[8];

    if ( ARGUMENT_PRESENT(lpRootPathName) ) {
        wcscpy( DefaultPath, L"\\??\\T:\\" );
        DefaultPath[4] = *lpRootPathName;
    } else {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    RtlInitUnicodeString( &FileName, DefaultPath );

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );
    if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError(Status) );

        //
        // Prior releases of NT where these parameters were not optional
        // zeroed out this field even in the failure case.  Some applications
        // failed to check the return value from this function and instead
        // relied on this side effect.  I'm putting that back now so the apps
        // can still treat an unformatted volume as a zero size volume.
        //

        if (ARGUMENT_PRESENT( lpBytesPerSector )) {
            *lpBytesPerSector = 0;
            }
        return FALSE;
        }

    //
    // Determine the size parameters of the volume.
    //

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                &SizeInfo,
                sizeof(SizeInfo),
                FileFsSizeInformation
                );
    NtClose(Handle);
    if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError(Status) );
        return FALSE;
        }

    //
    // Deal with 64 bit sizes
    //

    if ( SizeInfo.TotalAllocationUnits.HighPart ) {
        SizeInfo.TotalAllocationUnits.LowPart = (ULONG)-1;
        }
    if ( SizeInfo.AvailableAllocationUnits.HighPart ) {
        SizeInfo.AvailableAllocationUnits.LowPart = (ULONG)-1;
        }

    if (ARGUMENT_PRESENT( lpSectorsPerCluster )) {
        *lpSectorsPerCluster = SizeInfo.SectorsPerAllocationUnit;
        }
    if (ARGUMENT_PRESENT( lpBytesPerSector )) {
        *lpBytesPerSector = SizeInfo.BytesPerSector;
        }
    if (ARGUMENT_PRESENT( lpNumberOfFreeClusters )) {
        *lpNumberOfFreeClusters = SizeInfo.AvailableAllocationUnits.LowPart;
        }
    if (ARGUMENT_PRESENT( lpTotalNumberOfClusters )) {
        *lpTotalNumberOfClusters = SizeInfo.TotalAllocationUnits.LowPart;
        }

    return TRUE;
}


BOOL
WINAPI
GetDiskFreeSpaceA(
    LPCSTR  lpRootPathName,          // root path
    LPDWORD lpSectorsPerCluster,     // sectors per cluster
    LPDWORD lpBytesPerSector,        // bytes per sector
    LPDWORD lpNumberOfFreeClusters,  // free clusters
    LPDWORD lpTotalNumberOfClusters  // total clusters
    )
{
    BOOL b = FALSE;
    NTSTATUS Status;
    ANSI_STRING Ansi;
    UNICODE_STRING Unicode;
    WCHAR Buffer[MAX_PATH];

    RtlInitAnsiString( &Ansi, lpRootPathName );
    Unicode.Buffer = Buffer;
    Unicode.Length = 0;
    Unicode.MaximumLength = MAX_PATH * sizeof(WCHAR);
    Status = RtlAnsiStringToUnicodeString( &Unicode, &Ansi, FALSE );

    if ( NT_SUCCESS(Status) ) {
        b = GetDiskFreeSpaceW(
                Unicode.Buffer,
                lpSectorsPerCluster,
                lpBytesPerSector,
                lpNumberOfFreeClusters,
                lpTotalNumberOfClusters
                );
    } else {
        SetLastError( RtlNtStatusToDosError(Status) );
    }

    return b;
}


BOOL
WINAPI
MoveFileA(
    LPCSTR lpExistingFileName, // file name
    LPCSTR lpNewFileName       // new file name
    )
{
    UNICODE_STRING ExistingFileName, NewFileName;
    ANSI_STRING Ansi;
    NTSTATUS Status;
    BOOL b = FALSE;
    WCHAR FileName1[MAX_PATH];
    WCHAR FileName2[MAX_PATH];

    ExistingFileName.Buffer = FileName1;
    ExistingFileName.Length = 0;
    ExistingFileName.MaximumLength = sizeof(FileName1);

    NewFileName.Buffer = FileName2;
    NewFileName.Length = 0;
    NewFileName.MaximumLength = sizeof(FileName2);

    RtlInitAnsiString( &Ansi, lpExistingFileName );
    Status = RtlAnsiStringToUnicodeString( &ExistingFileName, &Ansi, FALSE );

    if ( NT_SUCCESS(Status) ) {
        RtlInitAnsiString( &Ansi, lpNewFileName );
        Status = RtlAnsiStringToUnicodeString( &NewFileName, &Ansi, FALSE );

        if ( NT_SUCCESS(Status) ) {
            b = MoveFileW( ExistingFileName.Buffer, NewFileName.Buffer );
        }
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\kernel32\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compile header file

Author:

    Sakphong Chanbai (schanbai) 07-Mar-2000

Environment:

    XBox

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef __cplusplus
}
#endif

#include <xtl.h>
#include "xtestlib.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\kernel32\modules.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    modules.c

Abstract:

    This module contains APIs for KERNEL32. We want to use MSVCRT.DLL 
    but it couldn't be built from NT source tree. So we wrap all calls 
    required by MSVCRT.DLL here since in XBox we don't need KERNEL32.DLL

Author:

    Sakphong Chanbai (schanbai) 27-Mar-2000

Environment:

    Xbox

Revision History:

--*/


#include "precomp.h"


DWORD
WINAPI
GetModuleFileNameA(
    HMODULE hModule,
    LPSTR   lpFileName,
    DWORD   nSize
    )
{
    PCHAR ModuleName;
    SIZE_T StringLength;

    //
    // Try to get the module file name of main program
    //
    if ( hModule == NULL ) {
        ModuleName = XeModuleNameFromModuleIndex( 0 );
    } else {
        //
        // Check to see if the hInstance (or hModule) is really an image base
        // or PXIMAGE_MODULE_HEADER
        //
        PWORD p = (PWORD)hModule;
        if ( *p == IMAGE_DOS_SIGNATURE ) {
            ULONG ModuleIndex = XeModuleIndexFromAddress( (ULONG_PTR)hModule );
            ModuleName = XeModuleNameFromModuleIndex( ModuleIndex );
        } else {
            ModuleName = XeModuleNameFromModuleHeader( hModule );
        }
    }

    if ( !ModuleName ) {
        SetLastError( ERROR_MOD_NOT_FOUND );
        return 0;
    }

    StringLength = strlen(ModuleName);

    if (  StringLength >= nSize ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return 0;
    }

    try {
        strcpy( lpFileName, ModuleName );
        SetLastError( ERROR_SUCCESS );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( RtlNtStatusToDosError(GetExceptionCode()) );
        StringLength = 0;
    }

    return StringLength;
}


DWORD
WINAPI
GetModuleFileNameW(
    HMODULE hModule,
    LPWSTR  lpFileName,
    DWORD   nSize
    )
{
    CHAR ModuleName[MAX_PATH];
    DWORD i, Length = GetModuleFileNameA( hModule, ModuleName, sizeof(ModuleName) );

    if ( Length ) {
        try {
            for ( i=0; i<=Length; i++ ) {
                lpFileName[i] = (WCHAR)ModuleName[i];
            }
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            Length = 0;
            SetLastError( RtlNtStatusToDosError(GetExceptionCode()) );
        }
    }

    return Length;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\kernel32\thread.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    thread.c

Abstract:

    This module contains APIs for KERNEL32. We want to use MSVCRT.DLL 
    but it couldn't be built from NT source tree. So we wrap all calls 
    required by MSVCRT.DLL here since in XBox we don't need KERNEL32.DLL

Author:

    Sakphong Chanbai (schanbai) 27-Mar-2000

Environment:

    XBox

Revision History:

--*/


#include "precomp.h"


BOOL
WINAPI
TerminateThread(
    HANDLE hThread,
    DWORD dwExitCode
    )
{
    UNREFERENCED_PARAMETER( hThread );
    UNREFERENCED_PARAMETER( dwExitCode );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\bugcheck.h ===
#ifndef _BUGCHECK_
	#define _BUGCHECK_ 

BOOL HandleBugCheck();
BOOL HandleWDMBugCheck();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\exe\triage.c ===
#include "trisupp.h"

void Usage() 
    {
    _tprintf(_T("\nUsage: Triage <debuggername> <pipename> [-nosym] [-ini:inifile]\n\n")
        _T("       Triage is a utility provided by the NtStress team to simplify debugging\n")
        _T("       and problem diagnosis.\n\n")
        _T("       Simply specify debugger name and pipename on the triage command line and\n")
        _T("       it will connect to the remote debugger and return a problem diagnosis,\n")
        _T("       stack trace and suggested followup.\n\n")
        _T("       The problem assignment is based on the module and function names in the\n")
        _T("       stack which are mapped into the triage.ini file (located with the exe).\n\n")
        _T("       -nosym turns off symbols checking and fixing.\n")
        _T("       -ini:filename sets the inifile name to 'filename' default = triage.ini\n\n")
        _T("       For more information on triage or feature requests, please mail NtStress.\n"));
    }


void __cdecl main(int argc, TCHAR **argv)
    {
    PTCHAR TextBuffer = NULL;
    PTCHAR iniFile = NULL;
    DWORD dwFlags = 0;
    DWORD debugarg = 1;
    INT i = 0;
    BOOL DebFound = FALSE;
    
    if ((argc<3)||(argc>5)) 
        {
        Usage();
        return;
        }
    
    for (i=1; i<argc; i++)
        {
        if ((argv[i][0] == _T('-'))||(argv[i][0] == _T('/')))
            {
            if ((!_tcsicmp(_T("-nosym"), argv[i]))||(!_tcsicmp(_T("/nosym"), argv[i])))
                dwFlags = (dwFlags | FLAG_NO_SYMBOLS);
            else if ((!_tcsnicmp(_T("-ini:"), argv[i], 5))||(!_tcsnicmp(_T("/ini:"), argv[i], 5)))
                {
                if ((*((argv[i])+5)) != _T('\0'))
                    iniFile = (argv[i])+5;
                }
            else
                {
                Usage();
                return;
                }
            }
        else
            {
            if (((i+1) < argc)&&(!DebFound))
                {
                debugarg = i;
                i++;
                DebFound = TRUE;
                }
            else
                {
                Usage();
                return;
                }
            }
        }
    
    if (TextBuffer = Triage(argv[debugarg],argv[debugarg +1], dwFlags, iniFile))
        _tprintf("%s\n", TextBuffer);
    else 
        _tprintf(_T("No Buffer Returned from Trisupp.dll\n\n \n\nFOLLOWUP: xstress\n"));
    
    TriageCleanup();
    
    return;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\inc\trisupp.h ===
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <tchar.h>

//These flags are OR'ed for the 3rd parameter to triage
#define FLAG_NO_SYMBOLS (DWORD)1        //It tells triage not to try to fix symbols
                                    

// For people who want to dynamically link
typedef PCHAR (*TRIAGEACALL)(PCHAR, PCHAR, DWORD, PCHAR);
typedef PWCHAR (*TRIAGEWCALL)(PWCHAR, PWCHAR, DWORD, PWCHAR);

// Lets make life easier for them
#ifdef UNICODE
    typedef PWCHAR (*TRIAGECALL)(PWCHAR, PWCHAR, DWORD, PWCHAR);
#else
    typedef PCHAR (*TRIAGECALL)(PCHAR, PCHAR, DWORD, PCHAR);
#endif

// This should be called to release any memory that triage allocated on your behalf.(ie. return buffer)
typedef VOID  (*TRIAGECLEANUP)();

/*
#ifndef MYLIBAPI
    #define MYLIBAPI __declspec(dllimport)
#else
    #define MYLIBAPI __declspec(dllexport)
#endif
*/

// The actual prototype
// Parameter    1 - Debugger Name.  Do not include the '\\'.  Just csdbg not \\csdbg.
//              2 - NamedPipe name.  This is the second parameter on the remote line.
//              3 - A bit mask.  The only bit defined now is FLAG_NO_SYMBOLS.  See Above
//              4 - An alternate ini file name.  Currently triage.ini is the default.  NULL is OK.
// Returns - A buffer containing the formatted failure infomation.  This should be freed using TriageCleanup()


#if defined(__cplusplus)
extern "C"
{
	__declspec( dllexport ) PCHAR TriageA(PCHAR, PCHAR, DWORD, PCHAR);
	__declspec( dllexport ) PWCHAR TriageW(PWCHAR, PWCHAR, DWORD, PWCHAR);
	__declspec( dllexport ) VOID TriageCleanup();
//	MYLIBAPI PCHAR TriageA(PCHAR, PCHAR, DWORD, PCHAR);
//	MYLIBAPI PWCHAR TriageW(PWCHAR, PWCHAR, DWORD, PWCHAR);
//	MYLIBAPI VOID TriageCleanup();
}
#else 
	__declspec( dllexport ) PCHAR TriageA(PCHAR, PCHAR, DWORD, PCHAR);
	__declspec( dllexport ) PWCHAR TriageW(PWCHAR, PWCHAR, DWORD, PWCHAR);
	__declspec( dllexport ) VOID TriageCleanup();
//	MYLIBAPI PCHAR TriageA(PCHAR, PCHAR, DWORD, PCHAR);
//	MYLIBAPI PWCHAR TriageW(PWCHAR, PWCHAR, DWORD, PWCHAR);
//	MYLIBAPI VOID TriageCleanup();
#endif

// Let them be flexible
#ifdef UNICODE
#define Triage  TriageW
#else
#define Triage  TriageA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\dbgr.h ===
#ifndef _DBGR_
	#define _DBGR_ 

HRESULT ConnectEngine(CHAR *server, CHAR *srvpipename);
HRESULT DisconnectEngine(VOID);
//HRESULT NewSendMyCommand(const CHAR *theCommand, CHAR **RetBuffer, ULONG Output = DEBUG_OUTCTL_ALL_CLIENTS, ULONG ulTimeout = 30000);

ULONG DbgGetProcType(VOID);
BOOL IsThereNTSDPropt(CHAR *InBuff);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\dbgr.cpp ===
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "utils.h"
#include "failure.h"
#include "dbgr.h"

//IMAGE_FILE_MACHINE_I386              0x014c
//IMAGE_FILE_MACHINE_IA64              0x0200
//IMAGE_FILE_MACHINE_ALPHA             0x0184
//IMAGE_FILE_MACHINE_ALPHA64           0x0284
/*
class DefOutputCallbacks :
    public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
};
class ConOutputCallbacks : public DefOutputCallbacks
{
public:
    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

// My interface Pointers
IDebugClient* g_DbgClient = NULL;
IDebugControl* g_DbgControl = NULL;

// Output callback class object
ConOutputCallbacks* g_ConOutputCb = NULL;
*/
/*
//Buffer Transfer variables
BOOL gbGotFirst = FALSE;
CHAR *gFirstBuffer = NULL;
CHAR *gTransferBuffer = NULL;

//Global State Variables
DWORD gPromptType = PROMPT_UNK;

ULONG DbgGetProcType(VOID)
{
	ULONG Type = IMAGE_FILE_MACHINE_UNKNOWN;
	
	if (g_DbgControl)
		g_DbgControl->GetActualProcessorType(&Type);

	return Type;
}


//----------------------------------------------------------------------------
//
// Default output callbacks implementation, provides IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP 
DefOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface)
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugOutputCallbacks))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) 
DefOutputCallbacks::AddRef(THIS)
{
    return 1;
}

STDMETHODIMP_(ULONG)
DefOutputCallbacks::Release(THIS)
{
    return 0;
}

//----------------------------------------------------------------------------
//
// Console output callbacks.
//
//----------------------------------------------------------------------------

STDMETHODIMP
ConOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text)
{
	HRESULT hRes = S_OK;
	if (!gbGotFirst)
	{
		CHAR *sdstring = NULL;

		if (!gFirstBuffer)
			gFirstBuffer = _strdup(Text);
		else
		{
			DWORD dwLength = strlen(Text) + strlen(gFirstBuffer) + 1;
			CHAR *temp = (CHAR *)malloc(dwLength);
			if (temp)
			{
				strcpy(temp, gFirstBuffer);
				strcat(temp, Text);
				free(gFirstBuffer);
				gFirstBuffer = temp;
			}
			else
				return E_FAIL;
		}

		sdstring = strstr(gFirstBuffer, "Stress has been shutdown.");
		while (sdstring)
		{
			CHAR *spare = (CHAR *)malloc(strlen(sdstring + strlen("Stress has been shutdown.")) + 1);
			if (!spare)
				break;
			strcpy(spare, (sdstring + strlen("Stress has been shutdown.")));
			free(gFirstBuffer);
			gFirstBuffer = spare;
			sdstring = strstr(gFirstBuffer, "Stress has been shutdown.");
		}

		sdstring = strstr(gFirstBuffer, "Page Avail=");
		while (sdstring)
		{
			CHAR *spare = (CHAR *)malloc(strlen(sdstring + strlen("Page Avail=")) + 1);
			if (!spare)
				break;
			strcpy(spare, (sdstring + strlen("Page Avail=")));
			free(gFirstBuffer);
			gFirstBuffer = spare;
			sdstring = strstr(gFirstBuffer, "Page Avail=");
		}

		sdstring = strstr(gFirstBuffer, "Waiting to Reconnect...");
		while (sdstring)
		{
			CHAR *spare = (CHAR *)malloc(strlen(sdstring + strlen("Waiting to Reconnect...")) + 1);
			if (!spare)
				break;
			strcpy(spare, (sdstring + strlen("Waiting to Reconnect...")));
			free(gFirstBuffer);
			gFirstBuffer = spare;
			sdstring = strstr(gFirstBuffer, "Waiting to Reconnect...");
		}

		sdstring = strstr(gFirstBuffer, "Send Break in");
		while (sdstring)
		{
			CHAR *spare = (CHAR *)malloc(strlen(sdstring + strlen("Send Break in")) + 1);
			if (!spare)
				break;
			strcpy(spare, (sdstring + strlen("Send Break in")));
			free(gFirstBuffer);
			gFirstBuffer = spare;
			sdstring = strstr(gFirstBuffer, "Send Break in");
		}

		sdstring = strstr(gFirstBuffer, "Loaded dbghelp extension DLL");
		while (sdstring)
		{
			CHAR *spare = (CHAR *)malloc(strlen(sdstring + strlen("Loaded dbghelp extension DLL")) + 1);
			if (!spare)
				break;
			strcpy(spare, (sdstring + strlen("Loaded dbghelp extension DLL")));
			free(gFirstBuffer);
			gFirstBuffer = spare;
			sdstring = strstr(gFirstBuffer, "Loaded dbghelp extension DLL");
		}

	}
	else
	{
		if (!gTransferBuffer)
			gTransferBuffer = _strdup(Text);
		else
		{
			DWORD dwLength = strlen(Text) + strlen(gTransferBuffer) + 1;
			CHAR *temp = (CHAR *)malloc(dwLength);
			if (temp)
			{
				strcpy(temp, gTransferBuffer);
				strcat(temp, Text);
				free(gTransferBuffer);
				gTransferBuffer = temp;
			}
			else
				return E_FAIL;
		}

//		if (gPromptType == PROMPT_NTSD)
//		{
//			if (IsThereNTSDPropt(gTransferBuffer))
//				hRes = g_DbgClient->ExitDispatch(g_DbgClient);
//		}
	}

    return S_OK;
}


VOID AdjustPromptTypeBasedOnInitialBuffer(VOID)
{
	CHAR *sol = NULL;

	if (!gFirstBuffer)
		return;

	sol = strrchr(gFirstBuffer, '>');
	if (sol)
	{
		sol--;
		if (isdigit(*sol))
		{
			while (isdigit(*sol))
				sol--;

			if ((*sol) == ':')
			{
				sol--;
				if (isdigit(*sol))
				gPromptType = PROMPT_NTSD;				
				return;
			}
		}
	}
	else
	{
		// Put Assert stuff in here
	}

	return;
}

BOOL IsThereNTSDPropt(CHAR *InBuff)
{
	CHAR *sol = NULL;

	if (!InBuff)
		return FALSE;

	sol = strrchr(InBuff, '>');
	if (sol)
	{
		if (sol > InBuff)
			sol--;
		if (isdigit(*sol))
		{
			while ((isdigit(*sol))&&(sol > InBuff))
				sol--;

			if ((*sol) == ':')
			{
				if (sol > InBuff)
					sol--;
				if (isdigit(*sol))
				return TRUE;
			}
		}
	}

	return FALSE;
}
HRESULT ConnectEngine(CHAR *server, CHAR *srvpipename)
{
    HRESULT hRes = S_OK;
	CHAR RemoteOptions[MAX_PATH + 1];
    ULONG OutMask = 0;
	ULONG Class = DEBUG_CLASS_UNINITIALIZED;
	ULONG Qualifier = DEBUG_KERNEL_CONNECTION;

	gFirstBuffer = NULL;
	gTransferBuffer = NULL;
	g_DbgClient = NULL;
	// -remote npipe:server=yourmachine,pipe=foobar
	sprintf(RemoteOptions, "npipe:server=%s,pipe=%s", server, srvpipename);

    hRes = DebugConnect(RemoteOptions, 
						IID_IDebugClient,
                        (void **)&g_DbgClient);
	if FAILED(hRes)
        return hRes;

    hRes = g_DbgClient->QueryInterface(IID_IDebugControl,
                                         (void **)&g_DbgControl);
	if FAILED(hRes)
        return hRes;

       
	// Set our callbacks
    g_ConOutputCb = new ConOutputCallbacks;
    hRes = g_DbgClient->SetOutputCallbacks(g_ConOutputCb);
    
	// Shut off Verbose
    hRes = g_DbgClient->GetOutputMask(&OutMask);
    OutMask &= ~DEBUG_OUTPUT_VERBOSE;
    OutMask |= DEBUG_OUTPUT_PROMPT;
    OutMask |= DEBUG_OUTPUT_DEBUGGEE;
    OutMask |= DEBUG_OUTPUT_DEBUGGEE_PROMPT;
    hRes = g_DbgClient->SetOutputMask(OutMask);

	// Connect the session. This will cause the output callback
	// to be fired with hte initial buffer.
	gbGotFirst = FALSE;
//    hRes = g_DbgClient->ConnectSession(DEBUG_CONNECT_SESSION_DEFAULT);
	gbGotFirst = TRUE;

	// Figure out if this is KD or NTSD piped to KD.
	hRes = g_DbgControl->GetDebuggeeType(&Class, &Qualifier);
	if (Class == DEBUG_CLASS_USER_WINDOWS)
		gPromptType = PROMPT_NTSD;
	else
	{
		gPromptType = PROMPT_KD;
		AdjustPromptTypeBasedOnInitialBuffer();
	}

	return hRes;
}

HRESULT DisconnectEngine(VOID)
{
	if (g_DbgClient)
	{
        if (g_ConOutputCb)
        {
            delete g_ConOutputCb;
            g_ConOutputCb = NULL;
        }
		g_DbgClient->Release();
		if (g_DbgControl)
			g_DbgControl->Release();
	}
	g_DbgClient = NULL;
	g_DbgControl = NULL;

	if (gFirstBuffer)
		free(gFirstBuffer);
	gFirstBuffer = NULL;

	if (gTransferBuffer)
		free(gTransferBuffer);
	gTransferBuffer = NULL;

	return S_OK;
}
*/
/*
// This function actually sends commands to the pipe and gets back the results
// Options:
// 1.theCommand = NULL && theBuffer = NULL = EmptyPipe
// 2.theCommand = NULL && theBuffer ! NULL = Get existing pipe data
// 3.theCommand ! NULL && theBuffer = NULL = Send command, dont want results
//							(They are still cleared from pipe)
// 4.theCommand ! NULL && theBuffer ! NULL = Send Command get Results
HRESULT NewSendMyCommand(const CHAR *theCommand, 
						 CHAR **RetBuffer, 
						 ULONG Output,
						 ULONG ulTimeout)
{
	CHAR *temp = NULL;
	HRESULT hRes = S_OK;

	// Get rid of the special(easy) cases
	if (theCommand == NULL)
	{
		if (RetBuffer == NULL)
		{
			if (gFirstBuffer)
				free(gFirstBuffer);
			gFirstBuffer = NULL;
			
			goto exit;
		}
		else
		{
			*RetBuffer = gFirstBuffer;
			gFirstBuffer = NULL;

			goto addprompt;
		}
	}

	if (RetBuffer == NULL)
	{
		if (gPromptType == PROMPT_KD)
		{
			g_DbgControl->Execute(DEBUG_OUTCTL_ALL_OTHER_CLIENTS, 
								  theCommand,
								  DEBUG_EXECUTE_ECHO);
			g_DbgControl->OutputPrompt(DEBUG_OUTCTL_ALL_OTHER_CLIENTS, NULL);
		}
		else
		{
			g_DbgControl->ReturnInput(theCommand);
		}

		goto exit;
	}
	else
	{
		if (gPromptType == PROMPT_KD)
		{
			g_DbgControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, 
								  theCommand,
								  DEBUG_EXECUTE_ECHO);
			g_DbgControl->OutputPrompt(DEBUG_OUTCTL_ALL_OTHER_CLIENTS, NULL);
		}
		else
		{
			hRes = g_DbgControl->ReturnInput(theCommand);
			while (!IsThereNTSDPropt(gTransferBuffer))
				hRes = g_DbgClient->DispatchCallbacks(100);
			// This is because we get a empty string as the last callback
			g_DbgClient->DispatchCallbacks(100);
		}

		*RetBuffer = gTransferBuffer;
		gTransferBuffer = NULL;
		
		goto addprompt;
	}

addprompt:
	// We need to put a debug prompt in here to make this 
	// work with the old stuff.
	if (gPromptType == PROMPT_KD)
	{
		temp = (CHAR *)malloc(strlen(*RetBuffer) + 1 + 3);
		if (temp)
		{
			strcpy(temp, *RetBuffer);
			strcat(temp, "kd>");
			free(*RetBuffer);
			*RetBuffer = temp;
		}
	}

exit:
	return S_OK;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\direct.cpp ===
#include <windows.h>
#include "utils.h"
#include "failure.h"
#include "dbgr.h"
#include "direct.h"


DWORD DrctGetMachineType(VOID)
{
	ULONG Type = DbgGetProcType();

	//IMAGE_FILE_MACHINE_I386              0x014c
	//IMAGE_FILE_MACHINE_IA64              0x0200
	//IMAGE_FILE_MACHINE_ALPHA             0x0184
	//IMAGE_FILE_MACHINE_ALPHA64           0x0284

	if (Type == IMAGE_FILE_MACHINE_IA64)
		return MACH_IA64;
	else if (Type == IMAGE_FILE_MACHINE_ALPHA64)
		return MACH_ALPHA64;
	else if (Type == IMAGE_FILE_MACHINE_ALPHA)
		return MACH_ALPHA;
	else
		return MACH_X86;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\bugcheck.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "failure.h"
#include "utils.h"
#include "owner.h"
#include "getutils.h"
#include "stacks.h"
#include "isdoutils.h"
#include "bugcheck.h"

extern Cfailure *Failure;

// stolen from ntstatus.h
#define STATUS_INSUFFICIENT_RESOURCES    0xC000009AL     // ntsubauth
#define STATUS_DEVICE_DATA_ERROR         0xC000009CL
#define STATUS_DISK_OPERATION_FAILED     0xC000016AL

#define THE7B_STRING "Please see instructions located at http://winweb/setup/debug/bugcheck7b.htm\n"
#define THE77RES_STRING "STATUS_INSUFFICIENT_RESOURCES:\nPlease do a !vm, a !poolused 3, a !poolused 4 and send the output\nto the owner of the leaking pooltags or to xstress if you need\nadditional assistance.\n"
#define THE77DATA_STRING "STATUS_DEVICE_DATA_ERROR OR STATUS_DISK_OPERATION_FAILED:\nPlease run chkdsk /r on the machine and reboot.\n"
#define THEED_STRING "If your machines Boot Volume is NTFS please assign this to ntfsdev.  If it is FAT please assign it to Danlo.\n"

BOOL Handle1E();
BOOL HandleD7(CHAR *Followup, DWORD FollowupSize);
BOOL HandleC4(CHAR *Followup, DWORD FollowupSize);
BOOL HandleC0000034(ULARGE_INTEGER p1, ULARGE_INTEGER p3);
BOOL BugCheckAnalyzer(DWORD BugCode, ULARGE_INTEGER p1, ULARGE_INTEGER p2, ULARGE_INTEGER p3, ULARGE_INTEGER p4);

CHAR *BugcodeNames[255]={
    "",							//00
        "APC_INDEX_MISMATCH",
        "DEVICE_QUEUE_NOT_BUSY",
        "INVALID_AFFINITY_SET",
        "INVALID_DATA_ACCESS_TRAP",
        "INVALID_PROCESS_ATTACH_ATTEMPT",
        "INVALID_PROCESS_DETACH_ATTEMPT",
        "INVALID_SOFTWARE_INTERRUPT",
        "IRQL_NOT_DISPATCH_LEVEL",
        "IRQL_NOT_GREATER_OR_EQUAL",
        "IRQL_NOT_LESS_OR_EQUAL",
        "NO_EXCEPTION_HANDLING_SUPPORT",
        "MAXIMUM_WAIT_OBJECTS_EXCEEDED",
        "MUTEX_LEVEL_NUMBER_VIOLATION",
        "NO_USER_MODE_CONTEXT",
        "SPIN_LOCK_ALREADY_OWNED",
        "SPIN_LOCK_NOT_OWNED",			//10
        "THREAD_NOT_MUTEX_OWNER",
        "TRAP_CAUSE_UNKNOWN",
        "EMPTY_THREAD_REAPER_LIST",
        "CREATE_DELETE_LOCK_NOT_LOCKED",
        "LAST_CHANCE_CALLED_FROM_KMODE",
        "CID_HANDLE_CREATION",
        "CID_HANDLE_DELETION",
        "REFERENCE_BY_POINTER",
        "BAD_POOL_HEADER",
        "MEMORY_MANAGEMENT",
        "PFN_SHARE_COUNT",
        "PFN_REFERENCE_COUNT",
        "NO_SPIN_LOCK_AVAILABLE",
        "KMODE_EXCEPTION_NOT_HANDLED",
        "SHARED_RESOURCE_CONV_ERROR",
        "KERNEL_APC_PENDING_DURING_EXIT",  //20
        "QUOTA_UNDERFLOW",
        "FILE_SYSTEM",
        "FAT_FILE_SYSTEM",
        "NTFS_FILE_SYSTEM",
        "NPFS_FILE_SYSTEM",
        "CDFS_FILE_SYSTEM",
        "RDR_FILE_SYSTEM",
        "CORRUPT_ACCESS_TOKEN",
        "SECURITY_SYSTEM",
        "INCONSISTENT_IRP",
        "PANIC_STACK_SWITCH",
        "PORT_DRIVER_INTERNAL",			//2c
        "SCSI_DISK_DRIVER_INTERNAL",	//2d
        "DATA_BUS_ERROR",				//2e
        "INSTRUCTION_BUS_ERROR",
        "SET_OF_INVALID_CONTEXT",
        "PHASE0_INITIALIZATION_FAILED",
        "PHASE1_INITIALIZATION_FAILED",
        "UNEXPECTED_INITIALIZATION_CALL",
        "CACHE_MANAGER",
        "NO_MORE_IRP_STACK_LOCATIONS",
        "DEVICE_REFERENCE_COUNT_NOT_ZERO",
        "FLOPPY_INTERNAL_ERROR",
        "SERIAL_DRIVER_INTERNAL",
        "SYSTEM_EXIT_OWNED_MUTEX",
        "SYSTEM_UNWIND_PREVIOUS_USER",
        "SYSTEM_SERVICE_EXCEPTION",
        "INTERRUPT_UNWIND_ATTEMPTED",
        "INTERRUPT_EXCEPTION_NOT_HANDLED",
        "MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED",
        "NO_MORE_SYSTEM_PTES",
        "TARGET_MDL_TOO_SMALL",
        "MUST_SUCCEED_POOL_EMPTY",
        "ATDISK_DRIVER_INTERNAL",
        "NO_SUCH_PARTITION",
        "MULTIPLE_IRP_COMPLETE_REQUESTS",
        "INSUFFICIENT_SYSTEM_MAP_REGS",
        "DEREF_UNKNOWN_LOGON_SESSION",
        "REF_UNKNOWN_LOGON_SESSION",
        "CANCEL_STATE_IN_COMPLETED_IRP",
        "PAGE_FAULT_WITH_INTERRUPTS_OFF",
        "IRQL_GT_ZERO_AT_SYSTEM_SERVICE",
        "STREAMS_INTERNAL_ERROR",
        "FATAL_UNHANDLED_HARD_ERROR",
        "NO_PAGES_AVAILABLE",
        "PFN_LIST_CORRUPT",
        "NDIS_INTERNAL_ERROR",
        "PAGE_FAULT_IN_NONPAGED_AREA",
        "REGISTRY_ERROR",
        "MAILSLOT_FILE_SYSTEM",
        "NO_BOOT_DEVICE",
        "LM_SERVER_INTERNAL_ERROR",
        "DATA_COHERENCY_EXCEPTION",
        "INSTRUCTION_COHERENCY_EXCEPTION",
        "XNS_INTERNAL_ERROR",
        "FTDISK_INTERNAL_ERROR",
        "PINBALL_FILE_SYSTEM",
        "CRITICAL_SERVICE_FAILED",
        "SET_ENV_VAR_FAILED",
        "HAL_INITIALIZATION_FAILED",
        "HEAP_INITIALIZATION_FAILED",
        "OBJECT_INITIALIZATION_FAILED",
        "SECURITY_INITIALIZATION_FAILED",
        "PROCESS_INITIALIZATION_FAILED",
        "HAL1_INITIALIZATION_FAILED",
        "OBJECT1_INITIALIZATION_FAILED",
        "SECURITY1_INITIALIZATION_FAILED",
        "SYMBOLIC_INITIALIZATION_FAILED",
        "MEMORY1_INITIALIZATION_FAILED",
        "CACHE_INITIALIZATION_FAILED",
        "CONFIG_INITIALIZATION_FAILED",
        "FILE_INITIALIZATION_FAILED",
        "IO1_INITIALIZATION_FAILED",
        "LPC_INITIALIZATION_FAILED",
        "PROCESS1_INITIALIZATION_FAILED",
        "REFMON_INITIALIZATION_FAILED",
        "SESSION1_INITIALIZATION_FAILED",
        "SESSION2_INITIALIZATION_FAILED",
        "SESSION3_INITIALIZATION_FAILED",
        "SESSION4_INITIALIZATION_FAILED",
        "SESSION5_INITIALIZATION_FAILED",
        "ASSIGN_DRIVE_LETTERS_FAILED",
        "CONFIG_LIST_FAILED",
        "BAD_SYSTEM_CONFIG_INFO",
        "CANNOT_WRITE_CONFIGURATION",
        "PROCESS_HAS_LOCKED_PAGES",
        "KERNEL_STACK_INPAGE_ERROR",
        "PHASE0_EXCEPTION",
        "MISMATCHED_HAL",
        "KERNEL_DATA_INPAGE_ERROR",	
        "INACCESSIBLE_BOOT_DEVICE",
        "BUGCODE_PSS_MESSAGE",
        "INSTALL_MORE_MEMORY",
        "WINDOWS_NT_BANNER",
        "UNEXPECTED_KERNEL_MODE_TRAP",
        "NMI_HARDWARE_FAILURE",
        "SPIN_LOCK_INIT_FAILURE",
        "DFS_FILE_SYSTEM", //82
        "OFS_FILE_SYSTEM",
        "RECOM_DRIVER",
        "SETUP_FAILURE", //85
        "AUDIT_FAILURE",
        "WINDOWS_NT_CSD_STRING",
        "WINDOWS_NT_INFO_STRING",
        "WINDOWS_NT_MP_STRING",
        "THREAD_TERMINATE_HELD_MUTEX",
        "MBR_CHECKSUM_MISMATCH", //8b
        "BUGCODE_PSS_CRASH_INIT",
        "BUGCODE_PSS_CRASH_PROGRESS",
        "BUGCODE_PSS_CRASH_DONE",
        "PP0_INITIALIZATION_FAILED",  //8f
        "PP1_INITIALIZATION_FAILED",  //90
        "WIN32K_INIT_OR_RIT_FAILURE",
        "UP_DRIVER_ON_MP_SYSTEM",	//92
        "INVALID_KERNEL_HANDLE",
        "KERNEL_STACK_LOCKED_AT_EXIT",  //94
        "PNP_INTERNAL_ERROR",
        "INVALID_WORK_QUEUE_ITEM",		//96
        "BOUND_IMAGE_UNSUPPORTED",
        "END_OF_NT_EVALUATION_PERIOD",
        "INVALID_REGION_OR_SEGMENT",
        "SYSTEM_LICENSE_VIOLATION",
        "UDFS_FILE_SYSTEM",
        "MACHINE_CHECK_EXCEPTION",	//9c
        "WINDOWS_NT_INFO_STRING_PLURAL",
        "WINDOWS_NT_RC_STRING",
        "DRIVER_POWER_STATE_FAILURE", //9f
        "INTERNAL_POWER_ERROR",
        "PCI_BUS_DRIVER_INTERNAL",			//a1
        "MEMORY_IMAGE_CORRUPT",
        "ACPI_DRIVER_INTERNAL",
        "CNSS_FILE_SYSTEM_FILTER",
        "ACPI_BIOS_ERROR",
        "FP_EMULATION_ERROR",			//a6
        "BAD_EXHANDLE",
        "BOOTING_IN_SAFEMODE_MINIMAL",	//a8
        "BOOTING_IN_SAFEMODE_NETWORK", //a9
        "BOOTING_IN_SAFEMODE_DSREPAIR",	//aa
        "SESSION_HAS_VALID_POOL_ON_EXIT",
        "HAL_MEMORY_ALLOCATION",	//ac
        "BUGCODE_PSS_MESSAGE_A",	//ad
        "BUGCODE_PSS_MESSAGE_1E",	//ae
        "BUGCODE_PSS_MESSAGE_23",	//af
        "BUGCODE_PSS_MESSAGE_2E",	//b0
        "BUGCODE_PSS_MESSAGE_3F",	//b1
        "BUGCODE_PSS_MESSAGE_7B",	//b2
        "BUGCODE_PSS_MESSAGE_7F",	//b3
        "VIDEO_DRIVER_INIT_FAILURE",	//b4
        "BOOTLOG_LOADED",	//b5
        "BOOTLOG_NOT_LOADED",	//b6
        "BOOTLOG_ENABLED",	//b7
        "ATTEMPTED_SWITCH_FROM_DPC",	//b8
        "CHIPSET_DETECTED_ERROR",
        "SESSION_HAS_VALID_VIEWS_ON_EXIT",
        "NETWORK_BOOT_INITIALIZATION_FAILED",
        "NETWORK_BOOT_DUPLICATE_ADDRESS",
        "INVALID_HIBERNATED_STATE",
        "ATTEMPTED_WRITE_TO_READONLY_MEMORY",	//be
        "MUTEX_ALREADY_OWNED",
        "PCI_CONFIG_SPACE_ACCESS_FAILURE",
        "SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION",	//c1
        "BAD_POOL_CALLER",		//c2
        "BUGCODE_PSS_MESSAGE_SIGNATURE",	//c3
        "DRIVER_VERIFIER_DETECTED_VIOLATION",	//c4
        "DRIVER_CORRUPTED_EXPOOL",	//c5
        "DRIVER_CAUGHT_MODIFYING_FREED_POOL",	//c6
        "TIMER_OR_DPC_INVALID",	//c7
        "IRQL_UNEXPECTED_VALUE",	//c8
        "DRIVER_VERIFIER_IOMANAGER_VIOLATION",	//c9
        "PNP_DETECTED_FATAL_ERROR",	//ca
        "DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS",	//cb
        "PAGE_FAULT_IN_FREED_SPECIAL_POOL",	//cc
        "PAGE_FAULT_BEYOND_END_OF_ALLOCATION",	//cd
        "DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS",	//ce
        "TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE",	//cf
        "DRIVER_CORRUPTED_MMPOOL",	//d0
        "DRIVER_IRQL_NOT_LESS_OR_EQUAL",	//d1
        "BUGCODE_ID_DRIVER",		//d2
        "DRIVER_PORTION_MUST_BE_NONPAGED",	//d3
        "SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD",	//d4
        "DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL",	//d5
        "DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION",  //d6
        "DRIVER_UNMAPPING_INVALID_VIEW",  //d7
        "DRIVER_USED_EXCESSIVE_PTES",//d8
        "LOCKED_PAGES_TRACKER_CORRUPTION",//d9
        "SYSTEM_PTE_MISUSE",//da
        "DRIVER_CORRUPTED_SYSPTES",//db
        "DRIVER_INVALID_STACK_ACCESS",//dc
        "BUGCODE_PSS_MESSAGE_A5",//dd
        "POOL_CORRUPTION_IN_FILE_AREA",//de
        "IMPERSONATING_WORKER_THREAD",//df
        "ACPI_BIOS_FATAL_ERROR",//e0
        "WORKER_THREAD_RETURNED_AT_BAD_IRQL",//e1
        "MANUALLY_INITIATED_CRASH",//e2
        "RESOURCE_NOT_OWNED",//e3
        "WORKER_INVALID",//e4
        "POWER_FAILURE_SIMULATE",//e5
        "DRIVER_VERIFIER_DMA_VIOLATION",//e6
        "INVALID_FLOATING_POINT_STATE",//e7
        "INVALID_CANCEL_OF_FILE_OPEN",//e8
        "ACTIVE_EX_WORKER_THREAD_TERMINATION", // e9
        "THREAD_STUCK_IN_DEVICE_DRIVER", //ea
        "",
        "",
        "UNMOUNTABLE_BOOT_VOLUME"
};


BOOL HandleBugCheck()
    {
    BOOL bRet = TRUE; 
    INT numLines = 0, i = 0;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    ULARGE_INTEGER Addr = {0}, BCData[5] = {0};
    CHAR *buffer;
    CHAR szTempBuf[512];
    CHAR szCommand[64];
    CHAR szStringBuf[512];
    CHAR Followup[128];
    DWORD FollowupSize = sizeof(Followup);
    
    if ((Failure->Architecture()) == MACH_X86)
        strcpy(szCommand, "dd ");
    else
        strcpy(szCommand, "dq ");
    
    if (stristr(Failure->Description(), "wdbugcheck"))
        strcat(szCommand, "watchdog!g_WdBugCheckData l5\n");
    else
        strcat(szCommand, "nt!KiBugCheckData l5\n");
    
    bRet = Failure->SendCommand(szCommand, &buffer);
    if (!bRet)
        return bRet;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    for (i=0;i<numLines;i++) 
        {
        if (IsHex(LineHeads[i])) 
            break;
        }
    if (i >= numLines)
        {
        free(buffer);
        return FALSE;
        }
    
   	if ((Failure->Architecture()) == MACH_X86)
        {
        if (5 == sscanf(LineHeads[i], "%x  %x %x %x %x", &Addr.LowPart, &(BCData[0].LowPart),
            &(BCData[1].LowPart), &(BCData[2].LowPart), &(BCData[3].LowPart)))
            {
            if (i < numLines - 1) 
                {
                if (2 != sscanf(LineHeads[i+1], "%x  %x", &Addr.LowPart, &(BCData[4].LowPart)))
                    {
                    free(buffer);
                    return FALSE;
                    }
                }
            }
        }
    else if ((Failure->Architecture()) == MACH_IA64)
        {
        if (6 == sscanf(LineHeads[i], "%x`%x  %x`%x %x`%x", &Addr.HighPart, &Addr.LowPart, &(BCData[0].HighPart),
            &(BCData[0].LowPart), &(BCData[1].HighPart), &(BCData[1].LowPart)))
            {
            if (i < numLines-1) 
                {
                if (6 == sscanf(LineHeads[i+1], "%x`%x  %x`%x %x`%x", &Addr.HighPart, &Addr.LowPart, 
                    &(BCData[2].HighPart), &(BCData[2].LowPart),
                    &(BCData[3].HighPart), &(BCData[3].LowPart)))
                    {
                    if (i < numLines-2) 
                        {
                        if (4 != sscanf(LineHeads[i+2], "%x`%x  %x`%x", &Addr.HighPart, &Addr.LowPart, &(BCData[4].HighPart),
                            &(BCData[4].LowPart)))
                            {
                            free(buffer);
                            return FALSE;
                            }
                        }
                    }
                }
            }
        }
    
    free(buffer);
    BugCheckAnalyzer(BCData[0].LowPart, 
        BCData[1], BCData[2],
        BCData[3], BCData[4]);
    
    switch(BCData[0].LowPart)
        {
        case 0x1e:
            Handle1E();
            break;
            
        case 0x4d:
            if (BCData[3].LowPart == 0)
                {
                bRet = GetSpecial("bugcheck!4d3p0", Followup, FollowupSize);
                if (bRet)
                    Failure->SetFollowup(Followup);
                
                return bRet;
                }
            break;
            
        case 0xd7:
            bRet = HandleD7(Followup, FollowupSize);
            if (bRet)
                Failure->SetFollowup(Followup);
            
            return bRet;
            break;
            
        case 0xea:
            Failure->SendBangThreadStack(BCData[1].LowPart, BCData[1].HighPart);
            break;
            
        case 0xed:
            Failure->AppendDescription(THE77RES_STRING);
            Failure->SetFollowup("Machine Owner");
            return TRUE;
            break;
            
        case 0xc4:
            if (BCData[1].LowPart == 0x60)
                {
                bRet = HandleC4(Followup, FollowupSize);
                if (bRet)
                    Failure->SetFollowup(Followup);
                
                return bRet;
                }
            break;
            
        case 0x77:
            switch(BCData[1].LowPart)
                {
                case STATUS_INSUFFICIENT_RESOURCES:
                    {
                    Failure->AppendDescription(THE77RES_STRING);
                    Failure->SetFollowup("Machine Owner");
                    return TRUE;
                    break;
                    }
                case STATUS_DEVICE_DATA_ERROR:
                case STATUS_DISK_OPERATION_FAILED:
                    {
                    Failure->AppendDescription(THE77DATA_STRING);
                    Failure->SetFollowup("Machine Owner");
                    return TRUE;
                    break;
                    }
                default:
                    {
                    break;
                    }
                }
            break;
            
                case 0x7a:
                    switch(BCData[2].LowPart)
                        {
                        case STATUS_INSUFFICIENT_RESOURCES:
                            {
                            Failure->AppendDescription(THE77RES_STRING);
                            Failure->SetFollowup("Machine Owner");
                            return TRUE;
                            break;
                            }
                        case STATUS_DEVICE_DATA_ERROR:
                        case STATUS_DISK_OPERATION_FAILED:
                            {
                            Failure->AppendDescription(THE77DATA_STRING);
                            Failure->SetFollowup("Machine Owner");
                            return TRUE;
                            break;
                            }
                        default:
                            {
                            break;
                            }
                        }
                    break;
                    
                        case 0x7b:
                            Failure->AppendDescription(THE7B_STRING);
                            Failure->SetFollowup("Machine Owner");
                            return TRUE;
                            break;
                            
                        case 0x9c:
                            if ((Failure->Architecture()) == MACH_X86)
                                {
                                Failure->SendCommand("!mca\n", &buffer);
                                Failure->AppendMisc(buffer);
                                free(buffer);
                                if (!(strstr(Failure->Misc(), "Intel")))
                                    return TRUE;
                                }
                            break;
                            
                        case 0xc000026c:
                            if (GetStringAtAddress(BCData[1], szStringBuf, sizeof(szStringBuf), FALSE))
                                {
                                sprintf(szTempBuf, 
                                    "The driver %s is bad.  Please replace this driver or contact its owner.\n", 
                                    szStringBuf);
                                }
                            else
                                sprintf(szTempBuf, 
                                "You have a bad driver at address %x. Type 'dc %x' and replace the driver specified or contact its owner.\n", 
                                BCData[1].LowPart, BCData[1].LowPart);
                            
                            Failure->AppendDescription(szTempBuf);
                            Failure->SetFollowup("Machine Owner");
                            return TRUE;
                            break;
                            
                        case 0xc0000034:
                            return HandleC0000034(BCData[1], BCData[3]);
                            
                            break;
                            
                            
                        default:
                            break;
    }
    
    bRet = GetSpecial(Failure->Description(), Followup, FollowupSize);
    if (bRet)
        Failure->SetFollowup(Followup);
    
    return bRet;
}


BOOL HandleC0000034(ULARGE_INTEGER p1, ULARGE_INTEGER p3)
    {
    CHAR *szStringBuf = NULL;
    CHAR Followup[64];
    CHAR *temp = NULL;
    BOOL Assigned = FALSE;
    
    if (!(szStringBuf = (CHAR *)malloc(512)))
        return FALSE;
    
    Failure->AppendMisc("The following Drivers image was not found:\n");
    if (GetStringAtAddress(p3, szStringBuf, 512, FALSE))
        {
        Failure->AppendMisc(szStringBuf);
        Failure->AppendMisc("\n");
        
        temp = strrchr(szStringBuf, '.');
        if (NULL != temp)
            temp[0] = '\0';
        
        temp = strrchr(szStringBuf, '\\');
        if (NULL != temp)
            {
            temp++;
            if (GetOwner(temp, Followup, sizeof(Followup)))
                {
                if (!stristr(Followup, "xstress"))
                    {
                    Assigned = TRUE;
                    Failure->SetFollowup(Followup);
                    }
                }
            }
        
        }
    
    if (GetStringAtAddress(p1, szStringBuf, 512, FALSE))
        {
        Failure->AppendMisc("Load Attempted by:\n");
        Failure->AppendMisc(szStringBuf);
        Failure->AppendMisc("\n");
        
        if (!Assigned)
            {
            temp = strrchr(szStringBuf, '.');
            if (NULL != temp)
                temp[0] = '\0';
            
            temp = strrchr(szStringBuf, '\\');
            if (NULL != temp)
                {
                temp++;
                if (GetOwner(temp, Followup, sizeof(Followup)))
                    Failure->SetFollowup(Followup);
                else
                    {
                    free(szStringBuf);
                    return FALSE;
                    }
                }
            }
        }
    
    free(szStringBuf);
    return TRUE;
    }

//
// Handles a bugcheck 1E
//
BOOL Handle1E()
    {
    ULARGE_INTEGER exr = {0,0};
    ULARGE_INTEGER cxr = {0,0};
    ULARGE_INTEGER Address = {0,0};
    CHAR *buffer = NULL;
    
    if (!GetParamFromStackBuffer("KeBugCheckEx", EBP, &Address))
        return FALSE;
    
    GetDxLongNumber(Address, 30, &exr);
    GetDxLongNumber(Address, 32, &cxr);
    
    GetExceptionBuffer(exr, cxr);
    
    DoEXR(exr);
    return Failure->SendCXRStack(cxr);
    }

//
// Handles a bugcheck c4
//
BOOL HandleC4(CHAR *Followup, DWORD FollowupSize)
    {
    CHAR BadDriver[129];
    CHAR *inbuff = NULL;
    
    if (!GetViBadDriverString(BadDriver, 129))
        return FALSE;
    
    Failure->AppendMisc("ViBadDriver = ");
    Failure->AppendMisc(BadDriver);
    Failure->AppendMisc("\n");
    
    inbuff = strchr(BadDriver, '.');
    if (inbuff)
        inbuff[0] = '\0';
    
    GetOwner(BadDriver, Followup, FollowupSize);
    return TRUE;
    }

// bugcheck D7 always goes to the line under ntkrnlmp!MmUnmapViewInSessionSpace - per landyw
BOOL HandleD7(CHAR *Followup, DWORD FollowupSize)
    {
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    CHAR *sidebuff = NULL;
    DWORD numLines = 0;
    DWORD i=0;
    
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if (!strstr(Failure->StackBuffer(), "!MmUnmapViewInSessionSpace"))
        return FALSE;
    
    sidebuff = (CHAR *)malloc(strlen(Failure->StackBuffer()) + 1);
    if (!sidebuff)
        return FALSE;
    
    strcpy(sidebuff, Failure->StackBuffer());
    
    numLines = GetLinesFromString(sidebuff, LineHeads);
    StripStack(LineHeads, &numLines);
    
    for (i=0; i<numLines; i++)
        {
        if (strstr(LineHeads[i], "!MmUnmapViewInSessionSpace"))
            {
            AssignStack(&(LineHeads[i+1]),
                (UINT) numLines, 
                Followup, FollowupSize);
            free(sidebuff);
            return TRUE;
            
            }
        
        }
    free(sidebuff);
    return FALSE;
    }

BOOL BugCheckAnalyzer(DWORD BugCode, ULARGE_INTEGER p1, ULARGE_INTEGER p2, ULARGE_INTEGER p3, ULARGE_INTEGER p4)
    {
    CHAR buf[256];
    
    if ((BugCode > 0) && (BugCode <= 0xff)) 
        {
        sprintf(buf, "Bugcheck %x - %s ", BugCode, BugcodeNames[BugCode]);
        } 
    else 
        {
        if (BugCode == 0xc000026c)
            sprintf(buf, "Bugcheck %x - STATUS_DRIVER_UNABLE_TO_LOAD", BugCode);
        else
            sprintf(buf, "Bugcheck %x - ", BugCode);
        }
    
    Failure->SetDescription(buf);
    
    if ((Failure->Architecture()) == MACH_X86)
        {
        sprintf(buf, "%08x %08x %08x %08x", p1.LowPart, p2.LowPart, p3.LowPart, p4.LowPart);
        Failure->AppendDescription(buf);    
        }    
    else if ((Failure->Architecture()) == MACH_IA64)
        {
        if ((Failure->Architecture()) == MACH_IA64)
            {
            sprintf(buf, "BC Parameters: %016I64x %016I64x \n               %016I64x %016I64x\n", 
                p1.QuadPart, p2.QuadPart, p3.QuadPart, p4.QuadPart);
            Failure->AppendMisc(buf);
            }        
        }
    
    return TRUE;
    }

BOOL HandleWDMBugCheck()
    {
    ULARGE_INTEGER dwESI = {0,0};
    ULARGE_INTEGER dwStruct = {0,0};
    ULARGE_INTEGER dwStrLoc = {0,0};
    CHAR buffer[128];
    CHAR ownerBuf[1024];
    CHAR *tmp = NULL;
    
    if (!GetESI(&dwESI))
        return FALSE;
    
    if (!GetDxLongNumber(dwESI, 6, &dwStruct))
        return FALSE;
    
    if (!GetDxLongNumber(dwStruct, 2, &dwStrLoc))
        return FALSE;
    
    if (!GetStringAtAddress(dwStrLoc, buffer, sizeof(buffer), TRUE))
        return FALSE;
    
    sprintf(ownerBuf, "Driver %s has caused a WDM assert.\n", buffer);
    Failure->AppendMisc(ownerBuf);
    
    // Get assertion text
    if (!GetDxLongNumber(dwESI, 11, &dwStruct))
        return FALSE;
    
    if (GetStringAtAddress(dwStruct, ownerBuf, sizeof(ownerBuf), FALSE))
        {
        Failure->AppendMisc(ownerBuf);
        Failure->AppendMisc("\n");
        }
    
    if (tmp = strchr(buffer, '.'))
        {
        tmp[0] = '\0';
        }
    
    if (GetOwner(buffer, ownerBuf, sizeof(ownerBuf)) != NULL)
        Failure->SetFollowup(ownerBuf);
    
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\direct.h ===
#ifndef _DIRECT_
	#define _DIRECT_ 



DWORD DrctGetMachineType(VOID);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\failure.cpp ===
#include <windows.h>
#include "rmtcli.h"
#include "utils.h"
#include "triage.h"
#include "stacks.h"
#include "failure.h"

VOID Cfailure::AppendDescription(CHAR *Addition)
    {
    DynamicAppend(&pszDescription, Addition);
    }

VOID Cfailure::AppendMisc(CHAR *Addition)       
    {
    DynamicAppend(&pszMisc, Addition);
    }

BOOL Cfailure::ShutOffVerbose()
    {
    CHAR *pszBuffer = NULL;
    BOOL fReturn = TRUE;

    /* // commented out because verbose is off by default on xbox
    // '\026' gives you a ctrl-v character
    fReturn = SendMyCommand("\026\n", &pszBuffer, 20);
    if (pszBuffer == NULL)
    {
    return FALSE;
    }
    
      if (strstr(pszBuffer, " ON"))
      {
      free(pszBuffer);
      SendMyCommand("\026\n", &pszBuffer, 20);
      }
      free(pszBuffer);

    // Lets turn off that annoying noist symbols stuff!!!
    SendMyCommand("!sym quiet\n", NULL, 30);
    */
    
    return fReturn;
    }

BOOL Cfailure::DoAResync()
    {
    BOOL fReturn = TRUE;
    CHAR *pszBuffer = NULL;
    
    SendMyCommand("\04\n", NULL, 5);
    
    // '\022' gives you a ctrl-r character in octal
    if (!SendMyCommand("\022\n", &pszBuffer, 20))
        {
        SendMyCommand("\04\n", NULL, 5);
        return FALSE;
        }
    
    if (pszBuffer != NULL)
        {
        if (stristr(pszBuffer, "SYNCTARGET: Timeout."))
            fReturn = FALSE;
        
        free(pszBuffer);
        }
    else
        fReturn = FALSE;
    
    SendMyCommand("\04\n", NULL, 5);
    
    return fReturn;
    }

BOOL Cfailure::SetTitleOnLastEvent()
    {
    CHAR *pszBuffer = NULL;
    BOOL fReturn = TRUE;
    /* 
    // no .lastevent on xbox debugger
    fReturn = SendMyCommand(".lastevent\n", &pszBuffer, TIMEOUTPERIOD);
    if ((pszBuffer == NULL) || (!fReturn))
        {
        return FALSE;
        }
    
    if (stristr(pszBuffer, "C000001D"))
        {
        dwFailType = FT_INVALID_INSTRUCTION;
        SetDescription("Invalid Instruction");
        }
    else if (stristr(pszBuffer, "C0000005"))
        {
        dwFailType = FT_ACCESS_VIOLATION;
        SetDescription("Access Violation");
        }
    else if (stristr(pszBuffer, "C0000008"))
        {
        dwFailType = FT_INVALID_HANDLE;
        SetDescription("Invalid Handle");
        }
    else if (stristr(pszBuffer, "C0000096"))
        {
        dwFailType = FT_INVALID_INSTRUCTION;
        SetDescription("PRIVILEGED INSTRUCTION");
        }
    else if (stristr(pszBuffer, "C00000FD"))
        {
        dwFailType = FT_STACK_OVERFLOW;
        SetDescription("Stack OverFlow");
        }
    else if (stristr(pszBuffer, "C0000194"))
        {
        dwFailType = FT_CRITICAL_SECTION_TIMEOUT;
        SetDescription("Critical Section Timeout");
        }
    else
        fReturn = FALSE;
    
    free(pszBuffer);
    return fReturn;
    */
    return FALSE;
    }


VOID Cfailure::FindIniFile(CHAR *pName)
    {
    CHAR szIniFileName[MAX_PATH];
    CHAR *slash = NULL;
    
    // The buffersize - (the length of the filename + "\" + "\n")
    if (GetCurrentDirectory((sizeof(szIniFileName)) - strlen(pName) - 2,
        szIniFileName)) 
        {
        strcat(szIniFileName,"\\");
        strcat(szIniFileName, pName);
        // if its 0xffffffff then we had file not found or another error
        if (GetFileAttributes(szIniFileName) == 0xffffffff) 
            {
            // This will cause it to check the dir the exe is in if they are not the same
            if (GetModuleFileName(NULL, szIniFileName, MAX_PATH)) 
                {
                slash = strrchr(szIniFileName, '\\');
                
                if (slash) 
                    {
                    slash[1]= '\0';
                    strcat(szIniFileName, pName);
                    SetIniFile(szIniFileName);
                    return;
                    }
                }
            } 
        else 
            {
            SetIniFile(szIniFileName);
            return;
            }
        }
    strcpy(szIniFileName, pName);
    SetIniFile(szIniFileName);
    }

Cfailure::Cfailure()
    {
    fConnected          = FALSE;
    pszDebugger         = NULL;
    pszPipe             = NULL;
    
    fFixSymbols         = TRUE;
    pszIniFile          = NULL;
    
    dwFailType          = FT_UNK;
    dwWeBrokeIn         = 0;
    dwDebugger          = PROMPT_UNK;
    
    dwBuild             = 0;
    dwSP                = 0;
    dwBuildDot          = 0;
    dwVBL               = 0;
    fLB6RI              = FALSE;
    pszVBL_Stamp        = NULL;
    dwBuildType         = BUILD_FREE;
    dwArchitecture      = MACH_X86;
    dwCPUType           = CPU_UNKNOWN;
    
    pszFirstBuffer      = NULL;
    pszCurrentStackBuffer    = NULL;
    pszStackCommand     = NULL;
    
    pszDescription      = NULL;
    pszMisc             = NULL;
    pszStack            = NULL;
    
    fIsAssigned         = FALSE;
    pszFollowup         = NULL;
    }

Cfailure::~Cfailure()
    {
    SAFEFREE(pszVBL_Stamp);
    SAFEFREE(pszFirstBuffer);
    SAFEFREE(pszCurrentStackBuffer);
    SAFEFREE(pszStackCommand);;
    SAFEFREE(pszDescription);
    SAFEFREE(pszMisc);
    SAFEFREE(pszStack);
    SAFEFREE(pszFollowup);
    SAFEFREE(pszIniFile);
    
    CloseRemote();
    }

DWORD Cfailure::Init(CHAR *pszNewDebugger, CHAR *pszNewPipe, CHAR *IniFile, DWORD dwFlags)
    {
    DWORD dwReturn = ERROR_SUCCESS;
    
    dwReturn = InitRemote(pszNewDebugger, 
        pszNewPipe, 
        IniFile, 
        dwFlags);
    /*
    if (dwReturn == ERROR_SUCCESS)
        dwReturn = GetSessionData();
    */
    return dwReturn;
    }

DWORD Cfailure::InitRemote(CHAR *pszNewDebugger, CHAR *pszNewPipe, CHAR *IniFile, DWORD dwFlags)
    {
    DWORD dwReturn = ERROR_SUCCESS;
    CHAR *pszBuffer = NULL;
    
    SAFEFREE(pszDebugger);
    SAFEFREE(pszPipe);
    fConnected = FALSE;
    
    fFixSymbols = !(dwFlags & FLAG_NO_SYMBOLS);
    
    FindIniFile(IniFile);
    
    // Connect to the machine
    dwReturn = rmConnectToRemote(pszNewDebugger, pszNewPipe);
    
    if (dwReturn != ERROR_SUCCESS) 
        {
        CHAR szErrCode[8];
        
        _snprintf(szErrCode, sizeof(szErrCode), "%u", GetLastError());
        
        SetFailureType(FT_UNRESPONSIVE);
        SetDescription("Unable to connect");
        SetStack(szErrCode);
        SetFollowup("Machine owner");
        
        return dwReturn;
        }
    else
        {
        pszDebugger = _strdup(pszNewDebugger);
        pszPipe = _strdup(pszNewPipe);
        fConnected = TRUE;
        }
    
    // Lets get the initial screen spew
    SAFEFREE(pszFirstBuffer);
    SendCommand(NULL, &pszFirstBuffer, (time_t)20);
    
    // figure out weather its KD or NTSD
    SendCommand("\n", NULL, (time_t)1); // clear out our connect message so we just see the prompt
    SetPromptType(pszFirstBuffer);
    
    // Asserts need to be broken before we can do anything more with them..
    if (dwDebugger == PROMPT_ASSERT)
        {
        dwFailType = FT_ASSERTION_FAILURE;
        SetDescription("Assertion Failure");
        
        // Not quite sure why I do this?
        SendCommand("\n", NULL, (time_t)1);
        if (SendCommand("b\n", &pszBuffer))
            {
            SendCommand(" \n", NULL);
            SetPromptType(pszBuffer);
            SAFEFREE(pszBuffer);
            }
        
        // See if we can get some assert spew.
        TryForAssertData(); 
        }
    
    // Make sure we have a prompt and there is nothing in the command buffer
    if (!SendMyCommand(" \n", &pszBuffer, 20)) 
        {
        if (!DoAResync())
            {
            SetFailureType(FT_UNRESPONSIVE);
            SetDescription("Not broken into debugger");
            SetStack("Try a ctrl-r");
            SetFollowup("xstress");
            return ERROR_BAD_ENVIRONMENT;
            }
        else
            {
            CHAR *pszTempBuffer = NULL;
            
            if (!SendCommand(" \n", &pszTempBuffer))
                {
                if (NULL != pszTempBuffer)
                    free(pszTempBuffer);
                
                SetFailureType(FT_UNRESPONSIVE);
                SetDescription("Not broken into debugger");
                SetStack("Try a ctrl-r");
                SetFollowup("xstress");
                return ERROR_BAD_ENVIRONMENT;
                }
            
            if (NULL != pszTempBuffer)
                {
                SetPromptType(pszTempBuffer);
                free(pszTempBuffer);
                }
            }
        }
    
    if (dwDebugger == PROMPT_UNK)
        SetPromptType(pszBuffer);
    
    SAFEFREE(pszBuffer);
    
    if (!ShutOffVerbose())
        {
        SetFailureType(FT_UNRESPONSIVE);
        SetDescription("Not broken into debugger");
        SetStack("Try a ctrl-r");
        SetFollowup("xstress");
        return ERROR_BAD_ENVIRONMENT;
        }
    
    // Something strange going on if we can't tell by here
    if (dwDebugger == PROMPT_UNK)
        {
        SetFailureType(FT_UNRESPONSIVE);
        SetDescription("Unknown Prompt");
        SetStack("");
        SetFollowup("xstress");
        return ERROR_BAD_ENVIRONMENT;
        }
    return dwReturn;
}

VOID Cfailure::SetPromptType(CHAR *buffer)
    {
    CHAR *rbuf = buffer;
    CHAR *cbuf = NULL;
    
    if (buffer == NULL)
        return;
    
    cbuf = strrchr(rbuf, '>');
    if (cbuf)
        {
        cbuf--;
        if ((*cbuf) == 'd')
            {
            if (*(--cbuf) == 'k')
                {
                dwDebugger = PROMPT_KD;
                }
            }
        else if (isdigit(*cbuf))
            {
            while (isdigit(*cbuf))
                {
                cbuf--;
                }
            if ((*cbuf) == ':')
                {
                cbuf--;
                if (isdigit(*cbuf))
                    {
                    dwDebugger = PROMPT_NTSD;
                    }
                }
            }
        
        if (dwDebugger != PROMPT_UNK)
            {
            cbuf = strrchr(rbuf, '>') + 1;	
            }
        }
    
    while ((cbuf = strstr(rbuf, "bipt"))||
        (cbuf = strstr(rbuf, "gbwxpft?"))||
        (cbuf = strstr(rbuf, "boipt"))||
        (cbuf = strstr(rbuf, "bizro"))||
        (cbuf = strstr(rbuf, "bizrd"))||
        (cbuf = strstr(rbuf, "Assertion failed")))  
        {
        rbuf = cbuf + 1;
        dwDebugger = PROMPT_ASSERT;
        } 
    }

VOID Cfailure::TryForAssertData()
    {
    CHAR *lowbuff = pszFirstBuffer;
    CHAR *curbuff = NULL;
    CHAR Desc[256] = "\0";
    CHAR xbuff[2048] = "\0";
    CHAR *it = NULL;
    CHAR save;
    
    
    if (pszFirstBuffer == NULL)
        return;    
    
    while (curbuff = stristr(lowbuff, "bipt"))
        {
        lowbuff = curbuff + 1;
        }
    
    while (curbuff = stristr(lowbuff, "boipt"))
        {
        lowbuff = curbuff + 1;
        }
    
    while (curbuff = stristr(lowbuff, "gbwxpft?"))
        {
        lowbuff = curbuff + 1;
        }
    
    while (curbuff = stristr(lowbuff, "Assertion failed"))
        {
        lowbuff = curbuff + 1;
        }

    while (curbuff = stristr(lowbuff, "(bizro)?"))
        {
        lowbuff = curbuff + 1;
        if ((it = strchr(curbuff, '\r'))||(it = strchr(curbuff, '\n')))
            {
            CHAR *startptr = curbuff;
            DWORD Count = 5;
            
            save = *it;
            *it = '\0';
            // rewindto get the previous 4 lines
            while ((startptr >= pszFirstBuffer) && (Count > 0))
                {
                startptr--;
                if (startptr[0] == '\r')
                    Count--;
                }
            
            while ((strchr(curbuff, '\r'))||(strchr(curbuff, '\n')))
                startptr++;
            
            strcpy(xbuff, startptr);
            *it = save;
            }
        } 
    
    // leave this last
    while (curbuff = stristr(lowbuff, "(bizrd)?"))
        {
        lowbuff = curbuff + 1;
        dwFailType = FT_WDM_BUGCHECK;
        SetDescription("WDM Driver Error");
        }
    
    if (strlen(xbuff))
        SetMisc(xbuff);
    }

BOOL Cfailure::GetMeSystemInfo()
    {
    return TRUE;
    CHAR *buffer = NULL;
    CHAR *temp = NULL;
    CHAR *temp2 = NULL;
    
    if (!SendCommand("version\n", &buffer))
        return FALSE;
    
    if ((!strstr(buffer, "Built by:"))&&(!strstr(buffer, "Kernel Version 2195")))
        {
        dwDebugger = PROMPT_NTSD;
        }
    else 
        dwDebugger = PROMPT_KD;
    
    // Get the achitecture
    if (strstr(buffer, "x86 compatible"))
        {
        dwArchitecture = MACH_X86;
        }
    else if (strstr(buffer, "Intel IA64"))
        {
        dwArchitecture = MACH_IA64;
        }
    
    // Checked or free
    if ((strstr(buffer, "Checked Intel")) || (strstr(buffer, "Checked x86")))
        dwBuildType = BUILD_CHECKED;
    
    if (dwDebugger != PROMPT_NTSD)
        {
        if (temp = strstr(buffer, "Kernel Version"))
            {
            if (!(1 == sscanf(temp, "Kernel Version %4d", &dwBuild)))
                dwBuild = 0;	
            }
        
        if (temp = strstr(buffer, "Service Pack"))
            {
            if (temp = strstr(buffer, "RC "))
                {
                if (!(2 == sscanf(temp, "RC %d.%d", &dwSP, &dwBuildDot)))
                    dwBuildDot = 0;
                }
            }
        else if (dwBuild == 2195)
            {
            temp = strstr(buffer, "2195.");
            if (temp)
                {
                if (!(1 == sscanf(temp, "2195.%d\\", &dwBuildDot)))
                    dwBuildDot = 0;
                }
            }
        
        if ((stristr(buffer, "built by:")) && (temp = stristr(buffer, ".lab")))
            {
            CHAR *stuff = NULL;
            temp = temp + 2;
            
            if ((1 == sscanf(temp, "ab%d_n.", &dwVBL)) || (1 == _stscanf(temp, "ab%d_N.", &dwVBL)))
                {
                if (stuff = stristr(temp, "_n."))
                    SetVBLString(stuff + 3);
                else 
                    {
                    dwVBL = 0;
                    fFixSymbols = FALSE;
                    }
                }
            else
                {
                dwVBL = 0;
                fFixSymbols = FALSE;
                }
            }
        else if (stristr(buffer, "LB6RI."))
            {
            CHAR *stuff = NULL;
            
            dwVBL = 6;
            
            if (stuff = strstr(buffer, "LB6RI."))
                {
                SetVBLString(stuff + 6);
                SetLB6RI(TRUE);
                }
            else 
                {
                dwVBL = 0;
                fFixSymbols = FALSE;
                }
            }
        
        }
    else
        {
        if (temp = strstr(buffer, "Build"))
            {
            temp2 = temp + strlen("Build ");
            while ((temp2[0] >= '0') && (temp2[0] <= '9'))
                temp2++;
            temp2[0] = '\0';
            
            if (!(1 == sscanf(temp, "Build %d", &dwBuild)))
                dwBuild = 0;
            }
        else if ((temp = strstr(buffer, "Whistler Version")))
            {
            if (!(1 == sscanf(temp, "Whistler Version %4d", &dwBuild)))
                dwBuild = 0;	
            }
        
        
        if ((stristr(buffer, "kernel32.dll version:"))&&(temp = stristr(buffer, "(lab")))
            {
            CHAR *stuff = NULL;
            
            temp = temp + 2;
            
            if ((1 == sscanf(temp, "ab%d_N.", &dwVBL)) || (1 == sscanf(temp, "ab%d_n.", &dwVBL)))
                {
                if (stuff = stristr(temp, "_n."))
                    SetVBLString(stuff + 3);
                else 
                    {
                    dwVBL = 0;
                    fFixSymbols = FALSE;
                    }
                
                }
            else
                {
                dwVBL = 0;
                fFixSymbols = FALSE;
                }
            }
        else if (stristr(buffer, "LB6RI."))
            {
            CHAR *stuff = NULL;
            
            dwVBL = 6;
            
            if (stuff = strstr(buffer, "LB6RI."))
                {
                SetVBLString(stuff + 6);
                SetLB6RI(TRUE);
                }
            else 
                {
                dwVBL = 0;
                fFixSymbols = FALSE;
                }
            }
        
        }
    
    free(buffer);
    return TRUE;
}

DWORD Cfailure::GetSessionData()
    {
    // Get out machines stats
    if (!GetMeSystemInfo())
        {
        return ERROR_BAD_ENVIRONMENT;
        }
    
   	if (!SendCommand("!cxr\n", NULL))
        {
        return ERROR_BAD_ENVIRONMENT;
        }
    
    return ERROR_SUCCESS;
    }

BOOL Cfailure::CloseRemote() 
    {
    SAFEFREE(pszDebugger);
    SAFEFREE(pszPipe);
    fConnected = FALSE;
    
    return rmCloseRemote();
    }


BOOL Cfailure::SendCommand(const CHAR *pszCommand, CHAR **ppszRetBuffer, time_t tWaitTime)
    {
    BOOL fReturn = TRUE;
    
    if (!fConnected)
        {
        SetDescription("Connection Not Initialized!");
        SetStack("Retry connection or contact xstress");
        SetFollowup("xstress");
        return FALSE;
        }
    
    fReturn = SendMyCommand(pszCommand, ppszRetBuffer, tWaitTime);
    
    if ((fReturn == FALSE) && (pszCommand != NULL) && (0 == dwBuild))
        {
        SetDescription("Debugger Unresponsive");
        SetStack("Try a ctrl-r");
        }
    
    return fReturn;
    }

BOOL Cfailure::SendStackCommand(const CHAR *pszCommand, BOOL fTwoPart, BOOL fDoFixups)
    {
    BOOL fReturn = TRUE;
    CHAR *pszRetBuffer = NULL;
    
    if (pszCommand == NULL)
        {
        if (StackCommand() == NULL)
            {
            SetStackCommand("kb\n");
            fTwoPartCommand = FALSE;
            }
        
        fReturn = SendCommand(StackCommand(), 
            &pszRetBuffer, 
            (dwDebugger == PROMPT_NTSD) ? (time_t)(TIMEOUTPERIOD * 1.5) : TIMEOUTPERIOD);
        }
    else
        {
        fReturn = SendCommand(pszCommand, 
            &pszRetBuffer, 
            (dwDebugger == PROMPT_NTSD) ? (time_t)(TIMEOUTPERIOD * 1.5) : TIMEOUTPERIOD);
        
        
        if (fReturn == TRUE)
            {
            SetStackCommand(pszCommand);
            fTwoPartCommand = fTwoPart;
            }
        }
    
    if ((fReturn == TRUE) && (fTwoPartCommand == TRUE))
        {
        if (pszRetBuffer != NULL)
            SAFEFREE(pszRetBuffer);
        
        if(strncmp(pszCommand, "!cxr", 4) == 0)
            {
            fReturn = SendCommand("!kb\n", 
                &pszRetBuffer, 
                (dwDebugger == PROMPT_NTSD) ? (time_t)(TIMEOUTPERIOD * 1.5) : TIMEOUTPERIOD);
            }
        else
            {
            fReturn = SendCommand("kb\n", 
                &pszRetBuffer, 
                (dwDebugger == PROMPT_NTSD) ? (time_t)(TIMEOUTPERIOD * 1.5) : TIMEOUTPERIOD);
            }
        }
    
    if (fReturn == TRUE)
        {
        SetStackBuffer(pszRetBuffer);
        SAFEFREE(pszRetBuffer);
        
        if (fDoFixups == TRUE)
            DoNecessaryStackFixUps();
        }
    return fReturn;
    }

BOOL Cfailure::SendUserThreadStack(DWORD dwUserThread)
    {
    CHAR command[16];
    
    if (dwDebugger != PROMPT_NTSD)
        return FALSE;
    
    sprintf(command, "~%ukb\n", dwUserThread);
    return SendStackCommand(command, TRUE);
    }

BOOL Cfailure::SendDotThreadStack(DWORD dwThread)
    {
    CHAR command[18];
    
    sprintf(command, ".thread %x\n", dwThread);
    return SendStackCommand(command, TRUE);
    }

BOOL Cfailure::SendBangThreadStack(ULARGE_INTEGER dwThread)
    {
    CHAR command[26];
    
    sprintf(command, "!thread %I64x\n", dwThread.QuadPart);
    
    return SendStackCommand(command, FALSE);
    }

BOOL Cfailure::SendBangThreadStack(DWORD dwThread, DWORD dwHighPart)
    {
    CHAR command[26];
    
    if (dwHighPart == 0)
        sprintf(command, "!thread %x\n", dwThread);
    else
        sprintf(command, "!thread %x%x\n", dwHighPart, dwThread);
    
    return SendStackCommand(command, FALSE);
    }

BOOL Cfailure::SendCXRStack(ULARGE_INTEGER uliCxr)
    {
    CHAR command[24];
    
    sprintf(command, "!cxr %I64x\n", uliCxr.QuadPart);
    return SendStackCommand(command, TRUE);
    }

BOOL Cfailure::DoKernelBreakin()
    {
    CHAR *buffer = NULL;
    
    if (dwDebugger == PROMPT_NTSD)
        {
        if (SendCommand(".breakin\n", &buffer))
            {
            if (strstr(buffer, "kd>"))
                {
                free(buffer);
                SetDebuggerType(PROMPT_KD);
                FixSymbolPath();
                dwWeBrokeIn++;
                return TRUE;
                }
            else
                {
                free(buffer);
                if (SendCommand("\n", &buffer))
                    {
                    if (strstr(buffer, "kd>"))
                        {
                        free(buffer);
                        SetDebuggerType(PROMPT_KD);
                        FixSymbolPath();
                        dwWeBrokeIn++;
                        return TRUE;
                        }
                    else
                        {
                        free(buffer);
                        return FALSE;
                        }
                    }
                }
            }
        }
    else
        return TRUE;
    
    return FALSE;
    }

BOOL Cfailure::GetReturnBuffer(CHAR ** ppRetBuf)
    {
    DWORD dwLength = 0;
    CHAR *tp = NULL;
    
    if (ppRetBuf == NULL)
        return FALSE;
    
    *ppRetBuf = NULL;
    
    // Make sure we have a description
    if ((pszDescription == NULL) || (dwFailType == FT_BREAKPOINT) || (dwFailType == FT_UNK))
        SetTitleOnLastEvent();
    
    if (pszDescription == NULL)
        SetDescription("Breakpoint");
    
    // Something went wrong - Need a stack of some sort
    if ((pszStack == NULL) && (pszMisc == NULL))
        SetStack("Couldn't Get Stack.  Manual Triaging Required.");
    
    // Default Followup
    if (pszFollowup == NULL)
        SetFollowup("xstress");
    //if (dwBuild == 1381)
    //    SetFollowup("spstress");
    
    if ((pszDescription == NULL) || ((pszStack == NULL) && (pszMisc == NULL)) || (pszFollowup == NULL))
        return FALSE;
    
    if (dwBuild)
        {
        // Let them know if its a VBL build
        if (dwVBL)
            {
            CHAR tVBL[4];
            
            _itot(dwVBL, tVBL, 10);
            
            // -bbbb VBLnn:- 4 for build num, 4 for ' VBL', 1 for ':', 1 for '.'
            // and 1 for NULL terminate (the nn is strlen(tVBL))
            dwLength = strlen(pszDescription) + strlen(tVBL) + 11;
            if (pszVBL_Stamp != NULL)
                dwLength += strlen(pszVBL_Stamp);
            
            tp = (CHAR *)malloc(dwLength);
            if (tp)
                {
                _itot(dwBuild, tp, 10);
                strcat(tp, " VBL");
                strcat(tp, tVBL);
                strcat(tp, ".");
                strcat(tp, pszVBL_Stamp);
                strcat(tp, ":");
                strcat(tp, pszDescription);
                SetDescription(tp);;
                }
            }
        else
            {
            tp = (CHAR *)malloc(strlen(pszDescription) + 6);
            if (tp)
                {
                _itot(dwBuild, tp, 10);
                strcat(tp, ":");
                strcat(tp, pszDescription);
                SetDescription(tp);;
                }
            }
        }
    
    
    dwLength = strlen(pszDescription) + 
        strlen(pszFollowup) + 17;
    
    if (pszStack != NULL)
        dwLength += strlen(pszStack);
    
    if (pszMisc != NULL)
        dwLength += strlen(pszMisc);
    
    if (*ppRetBuf = (CHAR *)malloc(dwLength)) 
        {
        if (pszMisc == NULL)
            sprintf(*ppRetBuf,"%s\n\n%s\n\nFOLLOWUP: %s\n", //15
            pszDescription, pszStack, pszFollowup);
        else if (pszStack == NULL)
            sprintf(*ppRetBuf,"%s\n\n%s\n\nFOLLOWUP: %s\n", //15
            pszDescription, pszMisc, pszFollowup);
        else
            sprintf(*ppRetBuf,"%s\n\n%s\n%s\n\nFOLLOWUP: %s\n", //16
            pszDescription, pszMisc, pszStack, pszFollowup);
        }
    
    return TRUE;
    }


VOID Cfailure::DoNecessaryStackFixUps()
    {
    ULARGE_INTEGER BadAddress = {0};
    BOOL Again = TRUE;
    
    while (Again == TRUE)
        {
        Again = FALSE;
        BadAddress.QuadPart = 0;
        
        if (DoesStackNeedManualReload(this, &BadAddress))
            {
            if (GetRepairedStack(this, BadAddress))
                Again = TRUE;
            }
        }
    
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\getutils.cpp ===
#include <windows.h>
#include <stdio.h>
#include "utils.h"
#include "IsDoUtils.h"
#include "owner.h"
#include "failure.h"
#include "stacks.h"
#include "GetUtils.h"

extern Cfailure *Failure;

BOOL GetESI(ULARGE_INTEGER *Value)
    {
    CHAR *buffer = NULL;
    CHAR *tmp = NULL;
    
    if ((Failure->Architecture()) != MACH_X86)
        return FALSE;
    
    if (!Failure->SendCommand("resi\n", &buffer))
        return FALSE;
    
    if (tmp = strstr(buffer, "esi="))
        {
        if (1 == sscanf(tmp, "esi=%8x", &(Value->LowPart)))
            return TRUE;
        }
    
    return FALSE;
    
    }

BOOL GetAssertDataFromStack(const CHAR *buffer)
    {
    CHAR Procname[64];
    CHAR tmpbuff[512];
    ULARGE_INTEGER Address = {0,0};
    
    Procname[0] = '\0';
    if (strstr(buffer, "RtlAssert"))
        strcpy(Procname, "RtlAssert");
    else if (strstr(buffer, "DsysAssertEx"))
        strcpy(Procname, "DsysAssertEx");
    else if (strstr(buffer, "_DsysAssertEx"))
        strcpy(Procname, "_DsysAssertEx");
    else if (strstr(buffer, "RDAssertReport"))
        strcpy(Procname, "RDAssertReport");
    
    if (Procname[0] != '\0')
        {
        // Get the Assert
        if (!GetParamFromStackBuffer(Procname, PARAM3, &Address))
            return FALSE;
        
        if (!GetStringAtAddress(Address, tmpbuff, (size_t)512, FALSE))
            return FALSE;
        
        if (!strstr(tmpbuff, "Assertion Failed:"))
            Failure->AppendMisc("Assertion Failed: ");
        
        Failure->AppendMisc(tmpbuff);
        Failure->AppendMisc("\n");
        
        // Get the source File
        if (!GetParamFromStackBuffer(Procname, PARAM2, &Address))
            return FALSE;
        
        if (!GetStringAtAddress(Address, tmpbuff, (size_t)512, FALSE))
            return FALSE;
        
        if (!strstr(tmpbuff, "Source File:"))
            Failure->AppendMisc("Source File: ");
        
        if ((tmpbuff)[strlen(tmpbuff) - 1] == '\n')
            (tmpbuff)[strlen(tmpbuff) - 1] = '\0';
        
        Failure->AppendMisc(tmpbuff);
        
        // Get the line number
        if (!GetParamFromStackBuffer(Procname, PARAM1, &Address))
            return FALSE;
        
        Failure->AppendMisc(", line ");
        
        sprintf(tmpbuff, "%u", Address.LowPart);
        
        Failure->AppendMisc(tmpbuff);
        Failure->AppendMisc("\n");
        }
    return TRUE;
    
    }

DWORD ScanStackForFailureType(const CHAR *buffer)
    {
    CHAR Name[128] = "\0";
    CHAR Desc[256] = "\0";
    CHAR *tbuf = NULL;
    
    if (stristr(buffer, "bugcheck")) 
        {
        if (stristr(buffer, "ViBugcheckPrompt"))
            {
            Failure->SetDescription("WDM Driver Error");
            return FT_WDM_BUGCHECK;
            }
        else if (stristr(buffer, "WdBugCheck"))
            {
            Failure->SetDescription("WdBugCheck");
            }
        else
            {
            Failure->SetDescription("BugCheck");
            }
        return FT_BUGCHECK;
        } 
    else if ((stristr(buffer, "!UnhandledExceptionFilter")) || 
        (stristr(buffer, "!RtlUnhandledExceptionFilter")) ||
        (stristr(buffer, "Unhandled exception")) ||             // XBOX Test harness
        (stristr(buffer, "HarnessUnhandledExceptionFilter")) || // XBOX Test harness
        (stristr(buffer, "!.UnhandledExceptionFilter")) ||
        (stristr(buffer, "!__CxxUnhandledExceptionFilter")) ||
        (stristr(buffer, "!.RtlUnhandledExceptionFilter")))
        {
        //disabled because of slowness in !process because of the new symbol handler
        /*	    if (GetProcessName(Name))
        {
        if (!strcmp(Name, "services.exe"))
        {
        Failure->SetDescription("Unhandled Exception hit in services.exe");
        return FT_UNH_EXCEPTION_SERVICES;
        }
        else if (!strcmp(Name, "lsass.exe"))
        {
        Failure->SetDescription("LSA Top level exception handler hit");
        return FT_LSA_TOP_LEVEL_EXCEPTION;
        }
        else if (!strcmp(Name, "winlogon.exe"))
        {
        Failure->SetDescription("Unhandled Exception hit in winlogon");
        return FT_UNH_EXCEPTION_WINLOGON;
        }
        else if (!strcmp(Name, "svchost.exe"))
        {
        Failure->SetDescription("Unhandled Exception hit in svchost.exe");
        return FT_UNH_EXCEPTION_SVCHOST;
        }
        else if (!strcmp(Name, "csrss.exe"))
        {
        Failure->SetDescription("Unhandled Exception hit in csrss.exe");
        return FT_UNH_EXCEPTION_CSRSS;
        }
        else
        {
        Failure->SetDescription("Unhandled Exception in ");
        Failure->AppendDescription(Name);
        return FT_UNK;
        }
        }
        else
        */        {
        Failure->SetDescription("Unhandled Exception hit");
        return FT_UNH_EXCEPTION;
        }
        }
    else if (stristr(buffer, "assert")) 
        {        
        Failure->SetDescription("Assertion Failure");
        return FT_ASSERTION_FAILURE;
        } 
    else if ((stristr(buffer, "ExpWaitForResource"))||
        (stristr(buffer, "ExAcquireResourceExclusiveLite")))
        {
        Failure->SetDescription("Resource Timeout");
        return FT_RESOURCE_TIMEOUT;
        } 
    else if (stristr(buffer, "WaitForCriticalSection")) 
        {
        Failure->SetDescription("Critical Section Timeout");
        return FT_CRITICAL_SECTION_TIMEOUT;
        } 
    else if (stristr(buffer, "NMI")) 
        {
        Failure->SetDescription("Hardware Failure");
        return FT_HARDWARE_FAILURE;
        }
    else if (((stristr(buffer, "KeUpdateSystemTime"))&&
        ((stristr(buffer, "KiIdleLoop")) || (stristr(buffer, "DbgBreakPointWithStatus"))))||
        (stristr(buffer, "KeBreakinBreakpoint")))
        {
        Failure->SetDescription("User hit Ctrl-c");
        Failure->SetStack("If you did this because the machine was hung,\nplease do a '!vm' and a '!poolused 2' and send it to xstress.\nOtherwise hit 'g' to go.\n");
        Failure->SetFollowup("Machine Owner");
        return FT_HIT_CTRL_C;
        }
    else if ((stristr(buffer, "I8042KeyboardInterruptService"))&&
        ((stristr(buffer, "KiInterruptTemplateDispatch"))||
        (stristr(buffer, "KiInterruptDispatch")))) 
        {
        Failure->SetDescription("User hit SysRq/Print Screen");
        Failure->SetStack("If you did this because the machine was hung,\nplease do a '!vm' and a '!poolused 2' and send it to xstress.\nOtherwise hit 'g' to go.\n");		
        Failure->SetFollowup("Machine Owner");
        return FT_HIT_SYSRQ;
        }
    else if ((stristr(buffer, "DbgBreakPoint"))&&
        ((stristr(buffer, "BaseAttachComplete"))&&
        (stristr(buffer, "BaseAttachCompleteThunk")))&&
        (Failure->DebuggerType() == PROMPT_NTSD)) 
        {
        Failure->SetDescription("User hit SysRq/Print Screen");
        Failure->SetStack("If you did this because the machine was hung,\nplease do a '!vm' and a '!poolused 2' and send it to xstress.\nOtherwise hit 'g' to go.\n");		
        Failure->SetFollowup("Machine Owner");
        return FT_HIT_SYSRQ;
        }
    else if ((stristr(buffer, "!SrvActivateDebugger "))||
        (stristr(buffer, "!.SrvActivateDebugger ")))
        {
        Failure->SetDescription("User hit Shift-f12");
        Failure->SetStack("If you did this because the machine was hung,\nplease do a '!vm' and a '!poolused 2' and send it to xstress.\nOtherwise hit 'g' to go.\n");		
        Failure->SetFollowup("Machine Owner");
        return FT_HIT_SHIFTF12;
        }
    else
        {
        if (GetProcessName(Name))
            {
            strcpy(Desc, "Breakpoint in ");
            strcat(Desc, Name);
            Failure->SetDescription(Desc);
            }
        }
    
    return FT_UNK;
}


DWORD GetProblemTitle()
    {
    const CHAR *lowbuff = Failure->BackSpew();
    CHAR *curbuff = NULL;
    DWORD dwFail = FT_UNK;
    CHAR Desc[256] = "\0";
    CHAR xbuff[1024] = "\0";
    CHAR *it = NULL;
    CHAR save;
    
    if (lowbuff == NULL)
        return dwFail;    
    
    while (curbuff = stristr(lowbuff, "waiting to reconnect")) 
        {
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "THIS IS NOT A BUG OR A SYSTEM CRASH")) 
        {
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "Invalid Address specified to RtlFreeHeap")) 
        {
        dwFail = FT_HEAP_ASSERT;
        strcpy(Desc, "Heap Assert");
        lowbuff = curbuff + 1;
        } 
    
    //   Access Violation - code: c0000005  (second chance)804138a7 6683790c00
    while (curbuff = stristr(lowbuff, "Access Violation")) 
        {
        dwFail = FT_ACCESS_VIOLATION;
        strcpy(Desc, "Access Violation");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "Resource @")) 
        {
        dwFail = FT_RESOURCE_TIMEOUT;
        strcpy(Desc, "Resource Timeout");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "Critical Section Timeout")) 
        {
        dwFail = FT_CRITICAL_SECTION_TIMEOUT;
        strcpy(Desc, "Critical Section Timeout");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "Invalid handle")) 
        {
        dwFail = FT_INVALID_HANDLE;
        strcpy(Desc, "Invalid Handle");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "deadlock")) 
        {
        dwFail = FT_POSSIBLE_DEADLOCK;
        strcpy(Desc, "Possible Deadlock");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "maka")) 
        {
        dwFail = FT_CACHE_COHERENCY_BP;
        strcpy(Desc, "Cache Coherency Breakpoint");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "*** Fatal System Error:")) 
        {
        dwFail = FT_BUGCHECK;
        strcpy(Desc, "BugCheck");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "LSA Top level exception handler hit")) 
        {
        dwFail = FT_LSA_TOP_LEVEL_EXCEPTION;
        strcpy(Desc, "LSA Top level exception handler hit");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "Unhandled Exception hit in winlogon")) 
        {
        dwFail = FT_UNH_EXCEPTION_WINLOGON;
        strcpy(Desc, "Unhandled Exception hit in winlogon");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "Unhandled Exception hit in services.exe")) 
        {
        dwFail = FT_UNH_EXCEPTION_SERVICES;
        strcpy(Desc, "Unhandled Exception hit in services.exe");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "Unhandled Exception hit in csrss.exe")) 
        {
        dwFail = FT_UNH_EXCEPTION_CSRSS;
        strcpy(Desc, "Unhandled Exception hit in csrss.exe");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "Unhandled Exception hit in svchost.exe")) 
        {
        dwFail = FT_UNH_EXCEPTION_SVCHOST;
        strcpy(Desc, "Unhandled Exception hit in svchost.exe");
        lowbuff = curbuff + 1;
        } 
    
    while ((curbuff = stristr(lowbuff, "Sparse files,"))
        &&(it = stristr(curbuff, "found corruption!"))) 
        {
        dwFail = FT_SPARSE_FILE_CORRUPT;
        strcpy(Desc, "Sparse File Corruption");
        
        
        it[strlen("found corruption")] = '\0';
        
        Failure->AppendMisc(curbuff);
        Failure->AppendMisc("!\n");
        
        it[strlen("found corruption")] = '!';
        
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "SYSCACHE failure on a Remote volume"))
        {
        dwFail = FT_SYSCACHE_FAILURE;
        strcpy(Desc, "SysCache Failure");
        
        Failure->AppendMisc("SYSCACHE failure on a Remote volume!\n");
        
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "SYSCACHE failure on a Local volume"))
        {
        dwFail = FT_SYSCACHE_FAILURE;
        strcpy(Desc, "SysCache Failure");
        
        Failure->AppendMisc("SYSCACHE failure on a Local volume!\n");
        
        lowbuff = curbuff + 1;
        } 
    
    while ((curbuff = stristr(lowbuff, "in page io error"))||
        (curbuff = stristr(lowbuff, "In-page I/O error"))) 
        {
        dwFail = FT_INPAGE_IO_ERROR;
        if ((it = strchr(curbuff, '\r'))||(it = strchr(curbuff, '\n')))
            {
            save = *it;
            *it = '\0';
            strcpy(Desc, curbuff);
            *it = save;
            }
        else
            strcpy(Desc, "In Page IO Error");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "Unknown Exception")) 
        {
        dwFail = FT_UNKNOWN_EXCEPTION;
        if ((it = strchr(curbuff, '\r'))||(it = strchr(curbuff, '\n')))
            {
            save = *it;
            *it = '\0';
            strcpy(Desc, curbuff);
            *it = save;
            Desc[34] = '\0';
            }
        else
            strcpy(Desc, "Unknown Exception Code");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "exception number")) 
        {
        dwFail = FT_NTSD_EXCEPTION;
        if ((it = strchr(curbuff, '\r'))||(it = strchr(curbuff, '\n')))
            {
            save = *it;
            *it = '\0';
            strcpy(Desc, curbuff);
            *it = save;
            }
        else
            strcpy(Desc, "NTSD Exception");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "misalign ")) 
        {
        dwFail = FT_MISALIGN;
        if ((it = strchr(curbuff, '\r'))||(it = strchr(curbuff, '\n')))
            {
            save = *it;
            *it = '\0';
            strcpy(Desc, curbuff);
            *it = save;
            }
        else
            strcpy(Desc, "Misalign");
        lowbuff = curbuff + 1;
        } 
    
    while (curbuff = stristr(lowbuff, "Assertion")) 
        {
        dwFail = FT_ASSERTION_FAILURE;
        xbuff[0] = '\0';
        strcpy(Desc, "Assertion Failure");
        lowbuff = curbuff + 1;
        if ((it = strchr(curbuff, '\r'))||(it = strchr(curbuff, '\n')))
            {
            save = *it;
            *it = '\0';
            strcpy(xbuff, curbuff);
            *it = save;
            
            if (curbuff = stristr(lowbuff, "Source File"))
                {
                if ((it = strchr(curbuff, '\r'))||(it = strchr(curbuff, '\n')))
                    {
                    save = *it;
                    *it = '\0';
                    strcat(xbuff, curbuff);
                    *it = save;
                    lowbuff = it;
                    }
                }
            
            }
        } 
    
    while (curbuff = stristr(lowbuff, "(bizro)?")) 
        {
        dwFail = FT_ASSERTION_FAILURE;
        strcpy(Desc, "Assertion Failure");
        lowbuff = curbuff + 1;
        if ((it = strchr(curbuff, '\r'))||(it = strchr(curbuff, '\n')))
            {
            CHAR *startptr = curbuff;
            DWORD Count = 5;
            save = *it;
            *it = '\0';
            // rewindto get the previous 4 lines
            while ((startptr >= Failure->BackSpew()) && (Count > 0))
                {
                startptr--;
                if (startptr[0] == '\r')
                    {
                    Count--;
                    }
                }
            while ((strchr(curbuff, '\r'))||(strchr(curbuff, '\n')))
                startptr++;
            
            strcpy(xbuff, startptr);
            *it = save;
            
            }
        } 
    
    while (curbuff = stristr(lowbuff, "(bizrd)?")) 
        {
        dwFail = FT_ASSERTION_FAILURE;
        strcpy(Desc, "Assertion Failure");
        lowbuff = curbuff + 1;
        if ((it = strchr(curbuff, '\r'))||(it = strchr(curbuff, '\n')))
            {
            CHAR *startptr = curbuff;
            DWORD Count = 5;
            save = *it;
            *it = '\0';
            // rewindto get the previous 4 lines
            while ((startptr >= Failure->BackSpew()) && (Count > 0))
                {
                startptr--;
                if (startptr[0] == '\r')
                    {
                    Count--;
                    }
                }
            while ((strchr(curbuff, '\r'))||(strchr(curbuff, '\n')))
                startptr++;
            
            strcpy(xbuff, startptr);
            *it = save;
            
            }
        } 
    
    if (dwFail != FT_UNK)
        {
        if (Desc[0] != '\0')
            Failure->SetDescription(Desc);
        
        if (strlen(xbuff))
            Failure->AppendMisc(xbuff);
        }
    
    return dwFail;
}


// Does a dd on hte address specifed and returns the requested longword
BOOL GetDxLongNumber(ULARGE_INTEGER Address, DWORD LNum, ULARGE_INTEGER *Value)
    {
    CHAR TheString[32];
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD vals[5] = {0,0,0,0,0};
    DWORD numLines = 0, i = 0;
    CHAR x = '\0';
    
    if ((LNum == 0)||(Value == NULL)||(Address.QuadPart == 0)||(LNum > ((MAXLINES-1) * 4)))
        return FALSE;
    
    Value->QuadPart = 0;
    if ((Failure->Architecture()) == MACH_X86)
        sprintf(TheString, "dd %x l%x\n", Address.LowPart, LNum);
    else
        sprintf(TheString, "dq %I64x l%x\n", Address.QuadPart, LNum);
    
    if (!Failure->SendCommand(TheString, &buffer))
        return FALSE;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    for (i=0; i < numLines; i++)
        {
        if (sscanf(LineHeads[i], "%8x ", &vals[0]) > 0)
            {
            if (LNum > 4)
                {
                if ((Failure->Architecture()) == MACH_X86)
                    {
                    if (5 == sscanf(LineHeads[i], "%8x %8x %8x %8x %8x", &vals[0], &vals[0],
                        &vals[0], &vals[0], &vals[0]))
                        LNum = LNum - 4;
                    }
                else
                    {
                    if (6 == sscanf(LineHeads[i], "%8x`%8x  %8x`%8x %8x`%8x", &vals[0], &vals[0],
                        &vals[0], &vals[0], &vals[0], &vals[0]))
                        LNum = LNum - 2;
                    }
                }
            else
                {
                if ((Failure->Architecture()) == MACH_X86)
                    {
                    INT iRet = 0;
                    
                    iRet = sscanf(LineHeads[i], "%8x %c", &vals[0], &x);
                    if ((x == '?')||(iRet != 2))
                        {
                        free(buffer);
                        return FALSE;
                        }
                    
                    if ((INT)(LNum + 1) == sscanf(LineHeads[i], "%8x %8x %8x %8x %8x", &vals[0], &vals[1],
                        &vals[2], &vals[3], &vals[4]))
                        {
                        Value->LowPart = vals[LNum];
                        free(buffer);
                        if ((vals[0] == 0) && (vals[1] == 0))  //What was I thinking?
                            return FALSE;
                        return TRUE;
                        }
                    }
                else
                    {
                    INT iRet = 0;
                    iRet = sscanf(LineHeads[i], "%8x`%8x %c", &vals[0], &vals[0], &x);
                    if ((x == '?') || (iRet != 3))
                        {
                        free(buffer);
                        return FALSE;
                        }
                    
                    if ((INT)((LNum * 2) + 2) == sscanf(LineHeads[i], "%8x`%8x  %8x`%8x %8x`%8x", 
                        &vals[0], &vals[0], &vals[1],
                        &vals[2], &vals[3], &vals[4]))
                        {
                        Value->LowPart = vals[(LNum * 2)];
                        Value->HighPart = vals[((LNum * 2) - 1)];
                        free(buffer);
                        return TRUE;
                        }
                    }
                }
            }
        }
    
    free(buffer);
    return FALSE;
    }

// Does a dd on hte address specifed and returns the requested longword
BOOL GetDxLongNumber(DWORD Address, DWORD LNum, DWORD *Value)
    {	
    ULARGE_INTEGER uliAddress = {0,0};
    ULARGE_INTEGER uliValue = {0,0};
    
    uliAddress.LowPart = Address;
    
    if (!GetDxLongNumber(uliAddress, LNum, &uliValue))
        return FALSE;
    
    *Value = uliValue.LowPart;
    
    return TRUE;
    }

//  This does a dd on the string specified and returns the dd asked for.  For example
// dd nwin32k!gpresuser l1 will get you the gpresuser
BOOL GetStringLongNumber(CHAR *StringName, DWORD LNum, ULARGE_INTEGER *Value)
    {
    CHAR TheString[128];
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD vals[5] = {0,0,0,0,0};
    DWORD numLines = 0, i = 0;
    CHAR x;
    
    if ((LNum == 0)||(Value == NULL)||(StringName == NULL)||(LNum > ((MAXLINES-1) * 4)))
        return FALSE;
    
    Value->QuadPart = 0;
    
    if ((Failure->Architecture()) == MACH_X86)
        sprintf(TheString, "dd %s l%x\n", StringName, LNum);
    else
        sprintf(TheString, "dq %s l%x\n", StringName, LNum);
    
    if (!Failure->SendCommand(TheString, &buffer))
        return FALSE;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    for (i=0; i < numLines; i++)
        {
        if (LNum > 4)
            {
            if ((Failure->Architecture()) == MACH_X86)
                {
                if (5 == sscanf(LineHeads[i], "%8x %8x %8x %8x %8x", &vals[0], &vals[0],
                    &vals[0], &vals[0], &vals[0]))
                    LNum = LNum - 4;
                }
            else
                {
                if (6 == sscanf(LineHeads[i], "%8x`%8x  %8x`%8x %8x`%8x", &vals[0], &vals[0],
                    &vals[0], &vals[0], &vals[0], &vals[0]))
                    LNum = LNum - 2;
                }
            }
        else
            {
            if ((Failure->Architecture()) == MACH_X86)
                {
                INT iRet = 0;
                
                iRet = sscanf(LineHeads[i], "%8x %c", &vals[0], &x);
                if ((x == '?') || (iRet != 2))
                    {
                    free(buffer);
                    return FALSE;
                    }
                
                if ((INT)(LNum + 1) == sscanf(LineHeads[i], "%8x %8x %8x %8x %8x", &vals[0], &vals[1],
                    &vals[2], &vals[3], &vals[4]))
                    {
                    Value->LowPart = vals[LNum];
                    free(buffer);
                    if ((vals[0] == 0) && (vals[1] == 0))  //What was I thinking?
                        return FALSE;
                    return TRUE;
                    }
                }
            else
                {
                INT iRet = 0;
                
                iRet = sscanf(LineHeads[i], "%8x`%8x %c", &vals[0], &vals[0], &x);
                if ((x == '?') || (iRet != 3))
                    {
                    free(buffer);
                    return FALSE;
                    }
                
                if ((INT)((LNum * 2) + 2) == sscanf(LineHeads[i], "%8x`%8x  %8x`%8x %8x`%8x", 
                    &vals[0], &vals[0], &vals[1],
                    &vals[2], &vals[3], &vals[4]))
                    {
                    Value->LowPart = vals[(LNum * 2)];
                    Value->HighPart = vals[((LNum * 2) - 1)];
                    free(buffer);
                    return TRUE;
                    }
                }
            }
        }
    
    free(buffer);
    return FALSE;
    }
// Will provide the thread address of the specified TID in the current process
BOOL GetThreadNumberOfCurrentProcTID(ULARGE_INTEGER TID, ULARGE_INTEGER *Thread)
    {
    CHAR TheString[32];
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD numLines = 0, i = 0;
    
    if ((TID.QuadPart == 0)||(Thread == NULL))
        return FALSE;
    
    Thread->QuadPart = 0;
    if (!Failure->SendCommand("!process -1 4\n", &buffer))
        return FALSE;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    sprintf(TheString, ".%I64x  Teb:", TID.QuadPart);
    
    for (i=0; i < numLines; i++)
        {
        if (strstr(LineHeads[i], TheString))
            {
            if ((Failure->Architecture()) == MACH_X86)
                {
                if (sscanf(LineHeads[i], " THREAD %8x", &(Thread->LowPart)) == 1)
                    {
                    free(buffer);
                    return TRUE;
                    }
                }
            else
                {
                if (sscanf(LineHeads[i], " THREAD %I64x", &(Thread->QuadPart)) == 1)
                    {
                    free(buffer);
                    return TRUE;
                    }
                }
            }
        }
    
    free(buffer);
    return FALSE;
    }

// Will provide the thread address of the specified TID in the specified process
BOOL GetThreadNumberOfPIDsTID(DWORD TID, DWORD PID, DWORD *Thread)
    {
    CHAR TheString[35];
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD numLines = 0, i = 0;
    
    if ((TID == 0)||(Thread == NULL))
        return FALSE;
    
    *Thread = 0;
    
    sprintf(TheString, "!process %x 4\n", PID);
    
    if (!Failure->SendCommand(TheString, &buffer))
        return FALSE;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    sprintf(TheString, ".%x  Teb:", TID);
    
    for (i=0; i < numLines; i++)
        {
        if (strstr(LineHeads[i], TheString))
            {
            if (sscanf(LineHeads[i], " THREAD %8x", Thread) == 1)
                {
                free(buffer);
                return TRUE;
                }
            }
        }
    
    free(buffer);
    return FALSE;
    }


BOOL GetProcedureParamNumber(CHAR *Command, CHAR *ProcName, DWORD PNum, DWORD *Value)
    {
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD numLines = 0, i = 0;
    DWORD num[5];
    
    if ((ProcName == NULL)||(Value == NULL)||(Command == NULL)||(PNum < 1)||(PNum > 5))
        return FALSE;
    
    *Value = 0;
    
    if (!Failure->SendCommand(Command, &buffer))
        return FALSE;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    for (i=0; i < numLines; i++)
        {
        if (strstr(LineHeads[i], ProcName))
            {
            if (sscanf(LineHeads[i], "%8x %8x %8x %8x %8x ", 
                &num[4], &num[3], &num[2], &num[1], &num[0]) == 5)
                {
                free(buffer);
                *Value = num[PNum-1];
                return TRUE;
                }
            }
        }
    
    free(buffer);
    return FALSE;
    }

BOOL GetParamFromStackBuffer(CHAR *ProcName, DWORD PNum, ULARGE_INTEGER *Value)
    {
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD numLines = 0, i = 0;
    DWORD num[8];
    
    if ((ProcName == NULL)||(Value == NULL)||(PNum < 1)||(PNum > 5))
        return FALSE;
    
    Value->QuadPart = 0;
    
    buffer = _strdup(Failure->StackBuffer());
    if (!buffer)
        return FALSE;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    for (i=0; i < numLines; i++)
        {
        if (stristr(LineHeads[i], ProcName))
            {
            if ((Failure->Architecture()) == MACH_X86)
                {
                if (sscanf(LineHeads[i], "%8x %8x %8x %8x %8x ", 
                    &num[4], &num[3], &num[2], &num[1], &num[0]) == 5)
                    {
                    free(buffer);
                    Value->LowPart = num[PNum-1];
                    return TRUE;
                    }
                }
            else
                {
                if (PNum <= 4)
                    {
                    if (sscanf(LineHeads[i], "%8x`%8x : %8x`%8x %8x`%8x %8x`%8x", 
                        &num[7], &num[6], &num[5], &num[4], &num[3], &num[2], &num[1], &num[0]) == 8)
                        {
                        free(buffer);
                        Value->HighPart = num[(PNum * 2) - 1];
                        Value->LowPart = num[(PNum * 2) - 2];
                        return TRUE;
                        }
                    }
                }
            }
        }
    
    free(buffer);
    return FALSE;
    }

BOOL GetParamFromStackBuffer(CHAR *ProcName, DWORD PNum, DWORD *Value)
    {
    ULARGE_INTEGER uliValue = {0,0};
    
    if (!GetParamFromStackBuffer(ProcName, PNum, &uliValue))
        return FALSE;
    
    *Value = uliValue.LowPart;
    
    return TRUE;
    }

BOOL GetThreadHoldingLoaderLock(ULARGE_INTEGER *Thread)
    {	
    ULARGE_INTEGER Value = {0,0};
    
    if (Thread == NULL)
        return FALSE;
    
    Thread->QuadPart = 0;
    
    if (!GetStringLongNumber("ntdll!loaderlock", 4, &Value))
        return FALSE;
    
   	// Get the thread address of the TID
    if (!GetThreadNumberOfCurrentProcTID(Value, Thread))
        return FALSE;
    
    return TRUE;
    }

BOOL GetThreadHoldingLock(DWORD Lock, DWORD *Thread)
    {	
    CHAR Command[32];
    CHAR *pTidStart = NULL;
    CHAR *buffer = NULL;
    DWORD Garb = 0;
    
    if ((Thread == NULL)||(Lock < 2))
        return FALSE;
    
    *Thread = 0;
    
    sprintf(Command, "!locks %08x\n", Lock);
    
    if (!(Failure->SendCommand(Command, &buffer)))
        return FALSE;
    
    if (!(pTidStart = strstr(buffer, "Threads: ")))
        {
        free(buffer);
        return FALSE;
        }
    
    if (sscanf(pTidStart, "Threads: %8x-%2d", Thread, &Garb) == 2)
        {
        free(buffer);
        return TRUE;
        }
    
    free(buffer);
    return FALSE;
    }

BOOL GetEXRAndCXRFromDx(ULARGE_INTEGER Address, ULARGE_INTEGER *Exr, ULARGE_INTEGER *Cxr)
    {
    CHAR TheString[32];
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD vals[5] = {0,0,0};
    DWORD numLines = 0, i = 0;
    CHAR x;
    
    if ((Address.QuadPart == 0)||(Exr == NULL)||(Cxr == NULL))
        return FALSE;
    
    Exr->QuadPart = 0;
    Cxr->QuadPart = 0;
    
    if ((Failure->Architecture()) == MACH_X86)
        sprintf(TheString, "dd %x l2\n", Address.LowPart);
    else
        sprintf(TheString, "dq %I64x l2\n", Address.QuadPart);
    
    if (!Failure->SendCommand(TheString, &buffer))
        return FALSE;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    for (i=0; i < numLines; i++)
        {
        if ((Failure->Architecture()) == MACH_X86)
            {
            INT iRet = 0;
            
            iRet = sscanf(LineHeads[i], "%8x %c", &vals[0], &x);
            if ((x == '?') || (iRet != 2))
                {
                free(buffer);
                return FALSE;
                }
            
            if (3 == sscanf(LineHeads[i], "%8x %8x %8x", &vals[0], &vals[1], &vals[2]))
                {
                Exr->LowPart = vals[1];
                Cxr->LowPart = vals[2];
                free(buffer);
                return TRUE;
                }
            }
        else
            {
            INT iRet = 0;
            
            iRet = sscanf(LineHeads[i], "%8x`%8x %c", &vals[0], &vals[0], &x);
            if ((x == '?') || (iRet != 3))
                {
                free(buffer);
                return FALSE;
                }
            
            if (6 == sscanf(LineHeads[i], "%8x`%8x  %8x`%8x %8x`%8x", &vals[0], &vals[0],
                &vals[1], &vals[2],
                &vals[3], &vals[4]))
                {
                Exr->LowPart = vals[2];
                Exr->HighPart = vals[1];
                Cxr->LowPart = vals[4];
                Cxr->HighPart = vals[3];
                free(buffer);
                return TRUE;
                }
            }
        
        }
    
    free(buffer);
    return FALSE;
    }

    /*BOOL GetEXRAndCXRFromBackSpew(DWORD *Exr, DWORD *Cxr)
    {
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD numLines = 0, i = 0, j = 0;
    CHAR *tptr = NULL;
    
      if ((Exr == NULL)||(Cxr == NULL))
      return FALSE;
      
        *Exr=0;
        *Cxr=0;
        
          tptr = strstr(Failure->BackSpew(), "!exr");
          if (tptr)
          {
          if (1 == sscanf(Failure->BackSpew(), "!exr %X", Exr))
          {
          tptr = strstr(Failure->BackSpew(), "!cxr");
          if (tptr)
          {
          if (1 == sscanf(Failure->BackSpew(), "!cxr %X", Cxr))
          return TRUE;
          }
          }
          }
          
            buffer = _strdup(Failure->BackSpew());
            
              if (!buffer)
              return FALSE;
              
                numLines = GetLinesFromString(buffer, LineHeads);
                
                  for (i=numLines; i > 0; i--)
                  {
                  // Deal with lsass
                  if (tptr = strstr(LineHeads[i-1], "LSA Top level exception handler hit:"))
                  {
                  DWORD Address = 0;
                  LineHeads[i-1] = tptr;
                  if (1 == sscanf(LineHeads[i-1], 
                  "LSA Top level exception handler hit: Exception record = %8x", &Address))
                  {
                  if (GetEXRAndCXRFromDx(Address, Exr, Cxr))
                  {
                  free(buffer);
                  return TRUE;
                  }
                  }
                  else
                  {
                  free(buffer);
                  return FALSE;
                  }
                  }
                  
                    if (tptr = strstr(LineHeads[i-1], "Unhandled Exception hit in"))
                    {
                    for (j=i; j < numLines; j++)
                    {
                    if (tptr = strstr(LineHeads[j], "first, enter !exr"))
                    {
                    LineHeads[j] = tptr;
                    if (1 == sscanf(LineHeads[j], "first, enter !exr %8x", Exr))
                    {
                    
                      }
                      else
                      {
                      free(buffer);
                      return FALSE;
                      }
                      }
                      
                        if (tptr = strstr(LineHeads[j], "next, enter !cxr"))
                        {
                        LineHeads[j] = tptr;
                        if (1 == sscanf(LineHeads[j], "next, enter !cxr %8x", Cxr))
                        {
                        free(buffer);
                        if (*Exr)
                        return TRUE;
                        else
                        return FALSE;
                        }
                        else
                        {
                        free(buffer);
                        return FALSE;
                        }
                        }
                        }
                        }
                        }
                        
                          free(buffer);
                          return FALSE;
                          }
*/
BOOL GetEXRAndCXR(ULARGE_INTEGER *Exr, ULARGE_INTEGER *Cxr)
    {
    ULARGE_INTEGER Address = {0,0};
    DWORD ParamNumber = 3;
    //	CHAR ReloadString[128];
    //	CHAR ProcString[256];
    CHAR *buffer = NULL;
    
    if ((Exr == NULL)||(Cxr == NULL))
        return FALSE;
    

    // Search for the test harness exception handler help text
    char *info = strstr(Failure->BackSpew(), "type \"!cxr");
    if(info)
        {
        info += 11;
        sscanf(info, "%X", &(Cxr->QuadPart));
        return TRUE;
        }




    if (!stristr(Failure->StackBuffer(), "UnhandledExceptionFilter"))
        {	
        if (!Failure->SendCommand("!reload\n", NULL))
            return FALSE;
        if (!Failure->SendStackCommand("kb\n"))
            return FALSE;
        }
    
    if ((!GetParamFromStackBuffer("MSVCRT!__CxxUnhandledExceptionFilter", 
        (DWORD)3, 
        &Address)) || (Address.QuadPart == 0))
        {
        if ((!GetParamFromStackBuffer("!RtlUnhandledExceptionFilter", 
            (DWORD)3, 
            &Address))||(Address.QuadPart == 0))
            {
            if (!GetParamFromStackBuffer("!UnhandledExceptionFilter", 
                (DWORD)3, 
                &Address))
                {
                free(buffer);
                return FALSE;
                }
            }
        }
    
    free(buffer);
    
    return GetEXRAndCXRFromDx(Address, Exr, Cxr);
    }

BOOL GetGPResUser(DWORD *Lock)
    {
    ULARGE_INTEGER temp = {0,0};
    
    if (!GetStringLongNumber("win32k!gpresUser", (DWORD) 1, &temp))
        {
        if (!ReloadWin32k())
            return FALSE;
        else if (!GetStringLongNumber("win32k!gpresUser", (DWORD) 1, &temp))
            return FALSE;
        }
    
    *Lock = temp.LowPart;
    return TRUE;
    }

BOOL GetViBadDriverAddress(ULARGE_INTEGER *Address)
    {
    ULARGE_INTEGER first = {0,0};
    
    if (!GetStringLongNumber("nt!vibaddriver", (DWORD) 1, &first))
        return FALSE;
    
    if (!GetDxLongNumber(first, (DWORD) 2, Address))
        return FALSE;
    
    return TRUE;
    }

BOOL GetViBadDriverString(CHAR *BadString, DWORD len)
    {
    CHAR Command[128];
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD numLines = 0, i = 0;
    DWORD excess = 0;
    ULARGE_INTEGER Address = {0,0};
    CHAR *tp = NULL;
    
    if (BadString == NULL)
        return FALSE;
    
    if (!GetViBadDriverAddress(&Address))
        return FALSE;
    
    sprintf(Command, "du %I64x\n", Address.QuadPart);
    
    if (!(Failure->SendCommand(Command, &buffer)))
        return FALSE;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    for (i=0; i < numLines; i++)
        {
        if ((sscanf(LineHeads[i], "%8x \"%s", 
            &excess, Command) == 2) || (sscanf(LineHeads[i], "%8x`%8x \"%s", 
            &excess, &excess, Command) == 3))
            {
            free(buffer);
            strncpy(BadString, Command, len);
            tp = strchr(BadString, '"');
            if (tp)
                tp[0] = '\0';
            sprintf(Command, "!verifier 3 %s\n", BadString);
            Failure->SendCommand(Command, NULL);
            return TRUE;
            }
        }
    
    free(buffer);
    return FALSE;
    }

BOOL GetProcessName(CHAR *Name)
    {
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD numLines = 0, i = 0;
    CHAR tempName[128];
    
    if (Name == NULL)
        return FALSE;
    
    if ((Failure->DebuggerType()) == PROMPT_KD)
        {
        if (!(Failure->SendCommand("!process -1 0\n", &buffer)))
            return FALSE;
        
        numLines = GetLinesFromString(buffer, LineHeads);
        
        for (i=0; i < numLines; i++)
            {
            if (sscanf(LineHeads[i], " Image: %s", 
                tempName) == 1)
                {
                strcpy(Name, tempName);
                free(buffer);
                return TRUE;
                }
            }
        free(buffer);
        }
    else if ((Failure->DebuggerType()) == PROMPT_NTSD)
        {
        DWORD excess =0;
        
        //   0     id: 2bc name: av.exe
        if (!(Failure->SendCommand("|\n", &buffer)))
            return FALSE;
        
        numLines = GetLinesFromString(buffer, LineHeads);
        
        for (i=0; i < numLines; i++)
            {
            if (sscanf(LineHeads[i], " %x id: %x name: %s", &excess, &excess, 
                tempName) == 3)
                {
                strcpy(Name, tempName);
                free(buffer);
                return TRUE;
                }
            }
        free(buffer);
        }
    
    return FALSE;
    }



BOOL GetExceptionBuffer(ULARGE_INTEGER Exr, ULARGE_INTEGER Cxr)
    {
    CHAR TempBuff[256];
    
    if ((Exr.QuadPart == 0)||(Cxr.QuadPart == 0))
        return FALSE;
    
    sprintf(TempBuff, 
        "first, enter !exr %I64x for the exception record\nnext, enter !cxr %I64x for the context\nfollowed by kb to get the faulting stack\n!cxr will reset to the original context\n", 
        Exr.QuadPart, Cxr.QuadPart);
    
    Failure->AppendMisc(TempBuff);
    return TRUE;
    }


BOOL GetThreadHoldingCriticalSectionStack()
    {
    ULARGE_INTEGER HoldingTID = {0,0};
    ULARGE_INTEGER Address = {0,0};
    ULARGE_INTEGER Thread = {0,0};
    CHAR TempCommand[32];
    
    // Get the address from the stack
    if (!GetParamFromStackBuffer("ntdll!RtlpWaitForCriticalSection", 
								(DWORD) 1, 
                                &Address))
                                return FALSE;
    
    // Get the tid from the address
    if (!GetDxLongNumber(Address, (DWORD)4, &HoldingTID))
        return FALSE;
    
    // Get the thread address of the TID
    if (!GetThreadNumberOfCurrentProcTID(HoldingTID, &Thread))
        return FALSE;
    
    // Avoid Thread waiting on themselves
    // Format the command string
    sprintf(TempCommand, "!thread %I64x\n", Thread.QuadPart);
    if (!strcmp(Failure->StackCommand(), TempCommand))
        return FALSE;
    
    return Failure->SendBangThreadStack(Thread);
    }

BOOL GetThreadHoldingLoaderLockStack()
    {
    ULARGE_INTEGER Thread = {0,0};
    CHAR TempCommand[32];
    
    if (!GetThreadHoldingLoaderLock(&Thread))
        return FALSE;
    
    sprintf(TempCommand, "!thread %I64x\n", Thread.QuadPart);
    
    return Failure->SendBangThreadStack(Thread);
    }

BOOL GetThreadHoldingRtlCriticalSectionStack()
    {
    ULARGE_INTEGER HoldingTID = {0,0};
    ULARGE_INTEGER Address = {0,0};
    ULARGE_INTEGER Thread = {0,0};
    CHAR TempCommand[32];
    CHAR *TempBuffer = NULL;
    
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    // Get the address from the stack
    if (!GetParamFromStackBuffer("ntdll!RtlAcquireResourceExclusive", 
        (DWORD) 3, 
        &Address))
        return FALSE;
    
    // Get the tid from the address
    if (!GetDxLongNumber(Address, (DWORD)12, &HoldingTID))
        return FALSE;
    
    // Get the thread address of the TID
    if (!GetThreadNumberOfCurrentProcTID(HoldingTID, &Thread))
        return FALSE;
    
    // Avoid Thread waiting on themselves
    // Format the command string
    sprintf(TempCommand, "!thread %I64x\n", Thread.QuadPart);
    if (!strcmp(Failure->StackCommand(), TempCommand))
        return FALSE;
    
    return Failure->SendBangThreadStack(Thread);
    }

BOOL GetLPCMessageFromBuffer(const CHAR *buffer, DWORD *Message)
    {
    CHAR *tptr = NULL;
    
    if ((buffer == NULL)||(Message == NULL))
        return FALSE;
    
    if (!(tptr = strstr(buffer, "LPC MessageId")))
        return FALSE;
    
    if (sscanf(tptr, "LPC MessageId %8x:", Message) == 1)
        return TRUE;
    
    return FALSE;
    }

BOOL GetServerThreadFromBuffer(CHAR *buffer, DWORD *Thread)
    {
    CHAR *tptr = NULL;
    
    if ((buffer == NULL)||(Thread == NULL))
        return FALSE;
    
    if (!(tptr = strstr(buffer, "Server thread")))
        return FALSE;
    
    if (sscanf(tptr, "Server thread %8x", Thread) == 1)
        return TRUE;
    
    return FALSE;
    }


BOOL GetLPCThreadStack()
    {
    DWORD MessageId = 0;
    DWORD Thread = 0;
    CHAR TempCommand[32];
    CHAR *TempBuffer = NULL;
    
    if (!GetLPCMessageFromBuffer(Failure->StackBuffer(), &MessageId))
        return FALSE;
    
    // Format the command string
    sprintf(TempCommand, "!lpc message %x\n", MessageId);
    
    // Get our message id
    if (!Failure->SendCommand(TempCommand, &TempBuffer))
        return FALSE;
    
    if (!GetServerThreadFromBuffer(TempBuffer, &Thread))
        {
        free(TempBuffer);
        return FALSE;
        }
    
    free(TempBuffer);
    return Failure->SendBangThreadStack(Thread);   
    }


BOOL GetMutantThreadFromBuffer(DWORD *Thread)
    {
    CHAR *tptr = NULL;
    
    if (((Failure->StackBuffer()) == NULL)||(Thread == NULL))
        return FALSE;
    
    if (!(tptr = strstr(Failure->StackBuffer(), "Mutant - owning thread")))
        return FALSE;
    
    if (sscanf(tptr, "Mutant - owning thread %8x", Thread) == 1)
        return TRUE;
    
    return FALSE;
    }

BOOL GetMutantThreadOwnerStack()
    {
    DWORD Thread = 0;
    CHAR *TempBuffer = NULL;
    
    if (!GetMutantThreadFromBuffer(&Thread))
        return FALSE;
    
    return Failure->SendBangThreadStack(Thread);
    }

BOOL GetThreadHoldingResourceStack()
    {
    DWORD Lock = 0, Object = 0;
    DWORD Thread = 0;
    CHAR TempCommand[32];
    CHAR *TempBuffer = NULL;
    
    // Lets try working from the lock first
    if (GetParamFromStackBuffer("!ExAcquireResourceExclusiveLite", 
								(DWORD) 3, 
                                &Lock))
        {
        if (!GetThreadHoldingLock(Lock, &Thread))
            {
            Lock = 0;
            }
        }
    
    
    if (!Lock)
        {
        if (!GetParamFromStackBuffer("!ExpAcquireResourceExclusiveLite", 
            (DWORD) 3, 
            &Object))
            return FALSE;
        
        if (!GetDxLongNumber(Object, (DWORD)7, &Thread))
            return FALSE;
        }
    
    // Avoid Thread waiting on themselves
    // Format the command string
    sprintf(TempCommand, "!thread %x\n", Thread);
    if (!strcmp(Failure->StackCommand(), TempCommand))
        return FALSE;
    
    return Failure->SendBangThreadStack(Thread);
    }

BOOL GetThreadHoldingSharedResourceStack()
    {
    DWORD Lock = 0, Object = 0;
    DWORD Thread = 0;
    CHAR TempCommand[32];
    CHAR *TempBuffer = NULL;
    
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    // Lets try working from the lock first
    if (GetParamFromStackBuffer("!ExAcquireResourceSharedLite", 
								(DWORD) 3, 
                                &Lock))
        {
        if (!GetThreadHoldingLock(Lock, &Thread))
            {
            Lock = 0;
            }
        }
    
    
    if (!Lock)
        {
        if (!GetParamFromStackBuffer("!ExAcquireResourceSharedLite", 
            (DWORD) 3, 
            &Object))
            return FALSE;
        
        if (!GetDxLongNumber(Object, (DWORD)7, &Thread))
            return FALSE;
        }
    
    // Avoid Thread waiting on themselves
    // Format the command string
    sprintf(TempCommand, "!thread %x\n", Thread);
    if (!strcmp(Failure->StackCommand(), TempCommand))
        return FALSE;
    
    return Failure->SendBangThreadStack(Thread);
    }

BOOL GetThreadHoldingVerifierResourceStack()
    {
    DWORD Lock = 0, Object = 0;
    DWORD Thread = 0;
    CHAR TempCommand[32];
    CHAR *TempBuffer = NULL;
    
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    // Lets try working from the lock first
    if (GetParamFromStackBuffer("!VerifierExAcquireResourceExclusive", 
								(DWORD) 3, 
                                &Lock))
        {
        if (!GetThreadHoldingLock(Lock, &Thread))
            {
            Lock = 0;
            }
        }
    
    
    if (!Lock)
        {
        if (!GetParamFromStackBuffer("!VerifierExAcquireResourceExclusive", 
            (DWORD) 3, 
            &Object))
            return FALSE;
        
        if (!GetDxLongNumber(Object, (DWORD)7, &Thread))
            return FALSE;
        }
    
    // Avoid Thread waiting on themselves
    // Format the command string
    sprintf(TempCommand, "!thread %x\n", Thread);
    if (!strcmp(Failure->StackCommand(), TempCommand))
        return FALSE;
    
    return Failure->SendBangThreadStack(Thread);
    }


BOOL GetInteruptVectorBuffer(DWORD IV, CHAR **outbuffer)
    {
    CHAR TempCommand[256];
    CHAR *buffer = NULL;
    CHAR *pszTemp = NULL;
    
    sprintf(TempCommand, "!idt %x\n", IV);
    
    if (!Failure->SendCommand(TempCommand, &buffer, TIMEOUTPERIOD*2))
        return FALSE;
    
    if (strstr(buffer, "Unable to load"))
        {
        free(buffer);
        return FALSE;
        }
    
    sprintf(TempCommand, "%x", IV);
    
    pszTemp = (strstr(buffer, "kd>") - 1);
    
    while ((pszTemp[0] != '\n')&&(pszTemp > buffer))
        pszTemp--;
    pszTemp[0] = '\0';
    
    pszTemp = strstr(buffer, TempCommand);
    
    *outbuffer = _strdup(pszTemp);
    free(buffer);
    
    if (*outbuffer == NULL)
        return FALSE;
    
    return TRUE;
    }


BOOL TryToAssignVectorBuffer(CHAR *inbuffer, CHAR *Followup, DWORD FollowupSize)
    {
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD numLines = 0, i = 0;
    CHAR *pszTemp = NULL;
    
    if (inbuffer == NULL)
        return FALSE;
    
    buffer = _strdup(inbuffer);
    
    if (strstr(inbuffer, "Hal Internal: "))
        pszTemp = strstr(inbuffer, "Hal Internal: ") + strlen("Hal Internal: ");
    
    if (pszTemp)
        {
        if (GetOwner(pszTemp, Followup, FollowupSize))
            {
            free(buffer);
            return TRUE;
            }
        }
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    if (numLines == 2)
        {
        pszTemp = LineHeads[1];
        
        while ((pszTemp[0] == ' ')||(pszTemp[0] == '\t'))
            pszTemp++;
        
        if (GetOwner(pszTemp, Followup, FollowupSize))
            {
            free(buffer);
            return TRUE;
            }		
        }
    else
        {
        strcpy(Followup, "arbiters");
        free(buffer);
        return TRUE;
        }	
    
    return FALSE;
    }



BOOL DoSpecialCasesBasedOnStack(CHAR *Followup, DWORD FollowupSize)
    {
    BOOL Again = FALSE;
    BOOL bRet = FALSE;
    CHAR *buffer = NULL;
    
    
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    do 
        {
        if (IsStuckInChainedDispatch())
            {
            DWORD dwInteruptVector = 0;
            
            if (GetParamFromStackBuffer("!KiChainedDispatch", 2, &dwInteruptVector))
                {
                if (GetInteruptVectorBuffer(dwInteruptVector, &buffer))
                    {
                    bRet = TryToAssignVectorBuffer(buffer, Followup, FollowupSize);
                    
                    _strlwr(Followup);
                    if (!strcmp(Followup, "ignore"))
                        bRet = FALSE;
                    
                    if (!strcmp(Followup, "arbiters"))
                        {
                        Failure->AppendMisc(ABITER_MSG);
                        Failure->AppendMisc("\r\n");
                        Failure->AppendMisc(buffer);
                        SAFEFREE(buffer);
                        }
                    }
                }			
            }
        } while (Again);
        
        return bRet;
    }



DWORD GetDeeperStacks()
    {
    BOOL Again = FALSE;
    DWORD BadAddress = 0;
    CHAR Name[128];
    BOOL ExcludeW32Crit = FALSE;
    DWORD dwLoopCount = 0;
    
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    do 
        {
        dwLoopCount++;
        
        Again = FALSE;
        
        // Check for critical sections
        if (IsWaitingOnCriticalSection())
            {
            if (!GetThreadHoldingCriticalSectionStack())
                break;
            Again = TRUE;
            }
        
        //This must go before IsAquireResourceExclusive
        if ((IsContaingW32EnterCritical())&&(!ExcludeW32Crit))
            {
            if (!GetGPResUserStack())
                break;
            ExcludeW32Crit = TRUE;
            Again = TRUE;
            }
        
        if ((IsRtlEnterCriticalSection()) && (GetProcessName(Name)))
            {
            if (!strcmp(Name, "csrss.exe"))
                {
                if (!GetGPResUserStack())
                    break;
                Again = TRUE;
                }
            }
        
        //This must also go before IsAquireResourceExclusive
        if (IsGreLockDisplay())
            {
            if (!GetLockDisplayStack())
                break;
            Again = TRUE;
            }
        
        if (IsVerifierAquireResource())
            {
            if (!GetThreadHoldingVerifierResourceStack())
                break;
            Again = TRUE;
            }
        
        if (IsRtlAquireResourceExclusive())
            {
            if (!GetThreadHoldingRtlCriticalSectionStack())
                break;
            Again = TRUE;
            }
        
        if (IsAquireResourceExclusive())
            {
            if (!GetThreadHoldingResourceStack())
                break;
            Again = TRUE;
            }
        
        if (IsAquireResourceShared())
            {
            if (!GetThreadHoldingSharedResourceStack())
                break;
            Again = TRUE;
            }
        
        
        // Make sure we done have that Mutant Stuff
        if (IsAMutant())
            {
            if (!GetMutantThreadOwnerStack())
                break;
            Again = TRUE;
            }
        
        // Make sure we done have that LPC Stuff
        if (IsWaitingOnLPC())
            {
            if (!GetLPCThreadStack())
                break;
            Again = TRUE;
            }
        
        // Check for critical sections
        if (IsWaitingOnLoaderLock())
            {
            if (!GetThreadHoldingLoaderLockStack())
                break;
            Again = TRUE;
            }
        
        } while ((Again) && (dwLoopCount < (DEEPER_LOOPCOUNT + 1)));
        
        if ((dwLoopCount - 1) == DEEPER_LOOPCOUNT)
            Failure->AppendMisc("WARNING:May be a circular dependancy!!!\n");
        
        return dwLoopCount - 1;
}



BOOL GetResTimeoutThreadFromBuffer(DWORD *TheThread)
    {
    const CHAR *pResStart = Failure->BackSpew();
    CHAR *pTempPtr = NULL;
    
    if (TheThread == NULL)
        return FALSE;
    
    while (pTempPtr = strstr(pResStart, "Resource @"))
        {
        pResStart = pTempPtr;
        pResStart++;
        }
    
    if (pResStart == Failure->BackSpew())
        return FALSE;
    
    *TheThread = 0;
    
    while ((*TheThread) < 1000)
        {
        if (!(pResStart = strstr(pResStart, "Thread = ")))
            return FALSE;
        
        if (!sscanf(pResStart, "Thread = %8x", TheThread))
            return FALSE;
        
        pResStart++;
        }
    
    if (*TheThread == 0)
        return FALSE;
    else
        return TRUE;
    }

BOOL GetGPResUserStack()
    {
    int loops = 0;
    CHAR *buffer = NULL;
    DWORD Lock = 0;
    DWORD Thread = 0;
    
    if ((Failure->DebuggerType()) == PROMPT_NTSD)
        {
        if (!Failure->DoKernelBreakin())
            return FALSE;
        }
    
    if (!GetGPResUser(&Lock))
        {
        Failure->SendCommand("!locks\n", NULL, 0);
        return FALSE;
        }
    
    if (!GetThreadHoldingLock(Lock, &Thread))
        return FALSE;
    
    return Failure->SendBangThreadStack(Thread);
    }

BOOL GetLockDisplayStack()
    {
    DWORD Lock = 0;
    DWORD Address = 0;
    DWORD Thread = 0;
    CHAR *buffer = NULL;
    
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if (!GetParamFromStackBuffer("win32k!GreLockDisplay", 
								(DWORD) 3, 
                                &Address))
                                return FALSE;
    
    // Get the display lock here
    if (!GetDxLongNumber(Address, (DWORD) 11, &Lock))
        return FALSE;
    
    if (!GetThreadHoldingLock(Lock, &Thread))
        return FALSE;
    
    return Failure->SendBangThreadStack(Thread);
    }

// Pid.Tid 7c.444, owner tid 3b8 Critical Section 00C333D8 - ContentionCount == 119
BOOL GetCriticalSectionInfoFromBuffer(DWORD *Pid, DWORD *OwnerTid)
    {
    const CHAR *pCritStart = Failure->BackSpew();
    CHAR *pTempPtr = NULL;
    DWORD Garb = 0, dwRet = 0;
    
    while (pTempPtr = strstr(pCritStart, "Pid.Tid "))
        {
        pCritStart = pTempPtr;
        pCritStart++;
        }
    
    if (pTempPtr == NULL)
        return FALSE;
    
    if (3 != sscanf((pCritStart - 1), "Pid.Tid %x.%x, owner tid %x", 
        Pid, &Garb, OwnerTid))
        return FALSE;
    
    return TRUE;
    }


BOOL GetUserThreadId(DWORD Pid, DWORD Tid, DWORD *UserThreadId)
    {
    CHAR *buffer;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD numLines = 0, i = 0, dwRet = 0;
    DWORD tmpTid = 0, tmpPid = 0;
    
    if (!(Failure->SendCommand("~\n", &buffer)))
        return FALSE;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    for (i=0;i<numLines;i++) 
        {
        if (3 == sscanf(LineHeads[i], "%u  id: %x.%x ", UserThreadId, &tmpPid, &tmpTid))
            {
            if ((tmpTid == Tid)&&(tmpPid == Pid))
                {
                free(buffer);
                return TRUE;
                }
            }
        }
    
    *UserThreadId = 0;
    free(buffer);
    return FALSE;
    }

// 2: kd> !dso kmutant ownerthread nt!ObpInitKillMutant
// Structure KMUTANT - Size: 0x20
// Field: OwnerThread - Offset: 0x18
// Address   Value
// 804748F8  82de1db0 -- if zero, the mutant is available.
BOOL GetKMutantOwnerThread(DWORD *Thread)
    {
    CHAR *buffer;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD numLines = 0, i = 0, Garb = 0;
    
    if ((Failure->DebuggerType()) == PROMPT_NTSD)
        {
        if (!Failure->DoKernelBreakin())
            return FALSE;
        }
    
    if (!(Failure->SendCommand("!dso kmutant ownerthread nt!ObpInitKillMutant\n", &buffer)))
        return FALSE;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    for (i=0;i<numLines;i++) 
        {
        if (2 == sscanf(LineHeads[i], "%8x %8x -- if", &Garb, Thread))
            {
            free(buffer);
            return TRUE;
            }
        }
    free(buffer);
    return FALSE;
    }

BOOL GetStringAtAddress(ULARGE_INTEGER Address, CHAR *StringBuffer, size_t StringLen, BOOL fUnicode)
    {
    CHAR TempLine[33];
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD numLines = 0, i = 0;
    
    StringBuffer[0] = '\0';
    
    // Format the command string
    if (fUnicode == TRUE)
        sprintf(TempLine, "du %I64x\n", Address.QuadPart);
    else
        sprintf(TempLine, "da %I64x\n", Address.QuadPart);
    
    // Get our new stack
    if (!Failure->SendCommand(TempLine, &buffer))
        return FALSE;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    for (i=0;i<numLines;i++) 
        {
        if (ExtractString(LineHeads[i], TempLine, 33))
            strncat(StringBuffer, TempLine, (StringLen - strlen(StringBuffer)));
        else
            break;
        }
    
    StringBuffer[StringLen - 1] = '\0';
    
    free(buffer);
    return TRUE;
    }

BOOL ExtractString(CHAR *InString, CHAR *OutString, size_t OutLen)
    {
    CHAR StringData[33];
    DWORD addr = 0;
    CHAR *first = NULL;
    
    first = strchr(InString, '"');
    if (first != NULL)
        {
        strncpy(OutString, (first + 1), OutLen);
        OutString[OutLen - 1] = '\0';
        if (first = strrchr(OutString, '"'))
            first[0] = '\0';
        }
    else
        {
        if (2 != sscanf(InString, "%8x  \"%s\"", &addr, StringData))
            return FALSE;
        
        if (StringData[strlen(StringData) - 1] == '"')
            StringData[strlen(StringData) - 1] = '\0';
        
        strncpy(OutString, StringData, OutLen);
        OutString[OutLen - 1] = '\0';
        }
    
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\getutils.h ===
#ifndef _GETUTILS_
#define _GETUTILS_

#define ABITER_MSG "Arbiters please triage this failure, Triage was unable to determine the followup for this Interupt Vector!"

#define EBP 5
#define RETADR 4
#define PARAM3 3
#define PARAM2 2
#define PARAM1 1

#define DEEPER_LOOPCOUNT 10

DWORD GetProblemTitle();
DWORD ScanStackForFailureType(const CHAR *buffer);
BOOL GetAssertDataFromStack(const CHAR *buffer);

BOOL GetESI(ULARGE_INTEGER *Value);

// Does dd on address and gets value at Longword #LNum
BOOL GetDxLongNumber(ULARGE_INTEGER Address, DWORD LNum, ULARGE_INTEGER *Value);
BOOL GetDxLongNumber(DWORD Address, DWORD LNum, DWORD *Value);
// Does a dd on the name and gets longward #X.  eg.  "nt!vibaddriver"
BOOL GetStringLongNumber(CHAR *StringName, DWORD LNum, ULARGE_INTEGER *Value);

// Does Command and gets param1-3 ,EBP or ReturnAddr of ProcName.  (Right to Left)
BOOL GetProcedureParamNumber(CHAR *Command, CHAR *ProcName, DWORD PNum, DWORD *Value);
// Same as GetProcedureParamNumber except takes a buffer you already have
BOOL GetParamFromStackBuffer(CHAR *ProcName, DWORD PNum, DWORD *Value);
BOOL GetParamFromStackBuffer(CHAR *ProcName, DWORD PNum, ULARGE_INTEGER *Value);

// Does a !process -1 4 and gets the Thread ID of the TID passed in.
BOOL GetThreadNumberOfCurrentProcTID(ULARGE_INTEGER TID, ULARGE_INTEGER *Thread);
// Does a !process TID 4 and gets the Thread ID of the TID Passed in.
BOOL GetThreadNumberOfPIDsTID(DWORD TID, DWORD PID, DWORD *Thread);

BOOL GetThreadHoldingLoaderLock(ULARGE_INTEGER *Thread);
// Does a !locks on the Lock supplied and gets holding Thread
BOOL GetThreadHoldingLock(DWORD Lock, DWORD *TheThread);
// Get the Address of the BadDriver address
BOOL GetViBadDriverAddress(ULARGE_INTEGER *Address);
// Gets the unicode string supplied by nt!vibaddriver
BOOL GetViBadDriverString(CHAR *BadString, DWORD len);
// Gets the name of the current process
BOOL GetProcessName(CHAR *Name);
//Tries to determine the failure type based on process name
DWORD GetFailTypeFromProcess(CHAR **descbuff);

// Gets Exr and Cxr by calling wBuffer and FromDD below
BOOL GetEXRAndCXR(ULARGE_INTEGER *Exr, ULARGE_INTEGER *Cxr);
// Given an address it gets the exr and cxr if the address is true
BOOL GetEXRAndCXRFromDx(ULARGE_INTEGER Address, ULARGE_INTEGER *Exr, ULARGE_INTEGER *Cxr);
// Given the initial screen buffer it tries to get the exr and cxr
//BOOL GetEXRAndCXRFromBackSpew(DWORD *Exr, DWORD *Cxr);
//Gets the formated buffer from the exr and cxr
BOOL GetExceptionBuffer(ULARGE_INTEGER Exr, ULARGE_INTEGER Cxr);

// Takes a stack buffer and checks for WaitOn Resource and Critical Sections
// and tries to get the stacks of the holders.  Also follows mutants to owners.
// Returns number of levels we followed down.
DWORD GetDeeperStacks();
// Takes a stack waiting on a Exclusive Resource and tries to replace with its holder
BOOL GetThreadHoldingResourceStack();
BOOL GetThreadHoldingLoaderLockStack();
//Takes a stack waiting on a critical section and replaces it with the holder
BOOL GetThreadHoldingCriticalSectionStack();
// Gets the Thread number of the mutant owning thread
BOOL GetMutantThreadFromBuffer(DWORD *Thread);
// Replaces the buffer and command with the mutant owner
BOOL GetMutantThreadOwnerStack();
BOOL GetThreadHoldingVerifierResourceStack();
BOOL GetThreadHoldingSharedResourceStack();


//Takes the Initial buffer and tries to get the holding thread
BOOL GetResTimeoutThreadFromBuffer(DWORD *TheThread);

// Gets the GPResUser Lock
BOOL GetGPResUser(DWORD *Lock);
// Drops to KernelMode, Gets GPResUser and returns holders stack
BOOL GetGPResUserStack();
//Gets the thread that is holding the kmutant object
BOOL GetKMutantOwnerThread(DWORD *Thread);

//Tries to get the PID and TID of the owner of the Critical Section
BOOL GetCriticalSectionInfoFromBuffer(DWORD *Pid, DWORD *OwnerTid);
// Get the Thread ID of the PID and TID pair
BOOL GetUserThreadId(DWORD Pid, DWORD Tid, DWORD *UserThreadId);
BOOL GetThreadHoldingRtlCriticalSectionStack();

//Tries to get the stack that is holding the display lock
BOOL GetLockDisplayStack();

BOOL GetStringAtAddress(ULARGE_INTEGER Address, CHAR *StringBuffer, size_t StringLen, BOOL fUnicode);
BOOL ExtractString(CHAR *InString, CHAR *OutString, size_t OutLen);

// Some special stuff I added for JoshR
BOOL DoSpecialCasesBasedOnStack(CHAR *Followup, DWORD FollowupSize);

BOOL GetLPCThreadStack();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\isdoutils.cpp ===
#include <windows.h>
#include <stdio.h>
#include "utils.h"
#include "failure.h"
#include "stacks.h"
#include "IsDoUtils.h"

extern Cfailure *Failure;

BOOL DoEXR(ULARGE_INTEGER exr)
    {
    CHAR command[24];
    CHAR *TempBuffer = NULL;
    
    sprintf(command, "!exr %I64x\n", exr.QuadPart);
    if (!(Failure->SendCommand(command, &TempBuffer)))
        return FALSE;
    
    if (strstr(TempBuffer, "c0000005"))
        {
        Failure->SetDescription("Access Violation");
        Failure->SetFailureType(FT_ACCESS_VIOLATION);
        }
    else if (strstr(TempBuffer, "c0000194"))
        {
        Failure->SetDescription("Critical Section Timeout");
        Failure->SetFailureType(FT_CRITICAL_SECTION_TIMEOUT);
        }
    else if (strstr(TempBuffer, "c0000008"))
        {
        Failure->SetDescription("Invalid Handle");
        Failure->SetFailureType(FT_INVALID_HANDLE);
        }
    else if (strstr(TempBuffer, "c00000fd"))
        Failure->SetDescription("Stack Overflow");
    
    free(TempBuffer);
    return TRUE;
    }

BOOL ResetCXR()
    {
    return Failure->SendCommand("!cxr\n", NULL);
    }

BOOL DoTilde()
    {
    return Failure->SendCommand("~\n", NULL);
    }

BOOL ReloadWin32k()
    {
    if (!(Failure->SendCommand("!reload win32k.sys=a0000000\n", NULL)))
        return FALSE;
    
    return TRUE;
    }

BOOL IsUserFailure()
    {
    // no user code on xbox
    return FALSE;
    /*
    if ((Failure->StackBuffer()) != NULL)
        {
        if ((stristr(Failure->StackBuffer(), "winsrv")) || 
            (stristr((Failure->StackBuffer()), "csrsrv")) || 
            (stristr((Failure->StackBuffer()), "user32")))
            {
            if (((Failure->DebuggerType()) == PROMPT_NTSD)&&
                (!(stristr((Failure->StackBuffer()), "ntdll!RtlpWaitForCriticalSection"))))
                return TRUE;
            }
        }
    return FALSE;
    */
    }

BOOL IsWaitingOnCriticalSection()
    {
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if (strstr(Failure->StackBuffer(), "!RtlpWaitForCriticalSection"))
        return TRUE;
    
    return FALSE;
    }

BOOL IsWaitingOnLoaderLock()
    {
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if (stristr(Failure->StackBuffer(), "!BaseCreateThreadPoolThread"))
        if ((((Failure->FailureType()) == FT_CRITICAL_SECTION_TIMEOUT)||
            ((Failure->FailureType()) == FT_RESOURCE_TIMEOUT)))
            return TRUE;
        
        return FALSE;
    }

BOOL IsWaitingOnLPC()
    {
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if (strstr(Failure->StackBuffer(), "Waiting for reply to LPC MessageId"))
        return TRUE;
    
    return FALSE;
    }


BOOL IsAMutant()
    {
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if (strstr(Failure->StackBuffer(), "Mutant - owning thread"))
        return TRUE;
    
    return FALSE;
    }

BOOL IsAquireResourceExclusive()
    {
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if ((strstr(Failure->StackBuffer(), "!ExpAcquireResourceExclusiveLite"))||
        (strstr(Failure->StackBuffer(), "!ExAcquireResourceExclusiveLite")))
        return TRUE;
    
    return FALSE;
    }

BOOL IsRtlEnterCriticalSection()
    {
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if (strstr(Failure->StackBuffer(), "!RtlEnterCriticalSection"))
        return TRUE;
    
    return FALSE;
    }

BOOL IsAquireResourceShared()
    {
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if (strstr(Failure->StackBuffer(), "!ExAcquireResourceSharedLite"))
        return TRUE;
    
    return FALSE;
    }

BOOL IsVerifierAquireResource()
    {
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if (strstr(Failure->StackBuffer(), "!VerifierExAcquireResourceExclusive"))
        return TRUE;
    
    return FALSE;
    }

BOOL IsRtlAquireResourceExclusive()
    {
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if (strstr(Failure->StackBuffer(), "!RtlAcquireResourceExclusive"))
        return TRUE;
    
    return FALSE;
    }

BOOL IsGreLockDisplay()
    {
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if (strstr(Failure->StackBuffer(), "!GreLockDisplay"))
        return TRUE;
    
    return FALSE;
    }


BOOL IsContaingW32EnterCritical()
    {
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if (strstr(Failure->StackBuffer(), "win32k!EnterCrit"))
        return TRUE;
    
    return FALSE;
    }

BOOL IsStuckInDuplicateObject()
    {
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if (strstr(Failure->StackBuffer(), "!NtDuplicateObject"))
        return TRUE;
    
    return FALSE;
    }

BOOL IsStuckInChainedDispatch()
    {
    if ((Failure->StackBuffer()) == NULL)
        return FALSE;
    
    if (strstr(Failure->StackBuffer(), "!KiChainedDispatch"))
        return TRUE;
    
    return FALSE;
    }



DWORD GetCPUType()
    {
    CHAR *buffer = NULL;
    DWORD mytype = UNKNOWN_CPU;
    
    if (!(Failure->SendCommand("!cpuinfo\n", &buffer)))
        return UNKNOWN_CPU;
    
    if (strstr(buffer, "GenuineIntel"))
        mytype = INTEL;
    else if (strstr(buffer, "AuthenticAMD"))
        mytype = AMD;
    else if (strstr(buffer, "CyrixInstead"))
        mytype = CYRIX;
    
    free(buffer);
    return mytype;
    }

BOOL Is1541HostBridge()
    {
    CHAR *buffer = NULL;
    
    if (!(Failure->SendCommand("!pci 0 0 0\n", &buffer)))
        return FALSE;
    
    if (strstr(buffer, ":1541"))
        {
        free(buffer);
        return TRUE;
        }
    
    free(buffer);
    return FALSE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\owner.cpp ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "owner.h"
#include "failure.h"

extern Cfailure *Failure;

#define INIDELTA 256
#define MAX_CANDIDATES 8
#define MAX_OWNER_SIZE 64

typedef struct _OwnerCandidate 
    {
    CHAR Name[MAX_OWNER_SIZE];
    int count;
    } OwnerCandidate;


BOOL OOF(CHAR *name, int cBuf)
    {
    return FALSE;

    /* // owners looked up in db no ini file
    BOOL ret=FALSE;
    CHAR *tmpbuf;
    
    if (!name || !cBuf) 
        {
        return FALSE;
        }
    if (tmpbuf=(CHAR *)malloc(cBuf+1)) 
        {
        if (ret=GetPrivateProfileString("OOF", name, "", tmpbuf, cBuf, Failure->IniFile())) 
            {
            strcpy(name, tmpbuf);
            }
        free(tmpbuf);
        }
    return ret;
    */
    }

CHAR *GetSubOwner(CHAR *modName, CHAR *funcName, CHAR *ownerBuf, int cBuf)
    {
    CHAR *iniSection=NULL,*bptr = NULL, *aftereq = NULL, *pPattern = NULL, *pSym = NULL;
    int iniSize=0,actualSize=0;
    
    
    if (NULL==modName || NULL==funcName || NULL==ownerBuf || 0==cBuf) 
        {
        return NULL;
        }
    *ownerBuf='\0';
    
    while ('_'==*funcName || '.'==*funcName) 
        {
        funcName++;
        }
    
    while (actualSize>=iniSize-2) 
        {
        if (iniSection) 
            free(iniSection);
        iniSize+=INIDELTA;
        if (iniSection=(CHAR *)malloc(iniSize)) 
            {
            actualSize=GetPrivateProfileSection(modName, iniSection, iniSize, Failure->IniFile());
            } 
        else 
            {
            return NULL;
            }
        }
    
    bptr=iniSection;
    if (bptr == NULL)
        return NULL;
    
    while (*bptr != 0) 
        {
        if (aftereq=strchr(bptr,'=')) 
            {
            *aftereq='\0';
            pSym=funcName;
            pPattern=bptr;
#ifdef UNICODE
            while (*pPattern!='\0' && towlower(*pPattern)==towlower(*pSym)) 
#else
                while (*pPattern!='\0' && tolower(*pPattern)==tolower(*pSym)) 
#endif			
                    {
                    pPattern++;
                    pSym++;
                    }
                if ('\0'==*pPattern) 
                    {
                    strncpy(ownerBuf, aftereq+1, cBuf);
                    free(iniSection);
                    return ownerBuf;
                    }
                *aftereq='=';
            }
        bptr+=strlen(bptr)+1;
        }
    
    free(iniSection);
    if (GetPrivateProfileString(modName, "default", "", ownerBuf, cBuf, Failure->IniFile())) 
        {
        return ownerBuf;
        } 
    else 
        {
        return NULL;
        }
    }

BOOL UnknownExcept(const CHAR * desc)
    {
    if (desc == NULL)
        return FALSE;
    
    if (strstr(desc, "Unknown Exception - code:")) 
        {
        return TRUE;
        }
    else
        return FALSE;
    }

BOOL InPageIo(const CHAR * desc)
    {
    if (desc == NULL)
        return FALSE;
    
    if ((strstr(desc, "NTSD: in page io error"))||
        (strstr(desc, "In Page IO Error"))||
        (strstr(desc, "In-page I/O error"))) 
        {
        return TRUE;
        }
    else
        return FALSE;
    }

BOOL Bugcheck(const CHAR * desc)
    {
    if (desc == NULL)
        return FALSE;
    
    if (strstr(desc, "Bugcheck ")) 
        {
        return TRUE;
        }
    else
        return FALSE;
    }

CHAR *GetOwner(CHAR *symbol, CHAR *ownerBuf, int cBuf)
    {
    CHAR *after = NULL;
    CHAR replaced='\0';
    
    if (NULL==symbol || NULL==ownerBuf || 0==cBuf) 
        {
        return NULL;
        }

    // we look up owners from the db, so just return the default
    strcpy(ownerBuf, "xstress");
    return ownerBuf;

/*
    *ownerBuf='\0';
    if ((after=strchr(symbol, replaced='!')) || (after=strchr(symbol, replaced='+'))) 
        {
        *after='\0';
        if (0==GetPrivateProfileString("owners", symbol, "", ownerBuf, cBuf, Failure->IniFile())) 
            {
            GetPrivateProfileString("owners", "default", "", ownerBuf, cBuf, Failure->IniFile());
            } 
        else 
            {
            if ('['==ownerBuf[0]) 
                {
                CHAR *tmpBuf;
                if (tmpBuf=(CHAR *)malloc(cBuf)) 
                    {
                    ownerBuf[strlen(ownerBuf)-1]='\0';
                    GetSubOwner(ownerBuf+1, after+1, tmpBuf, cBuf);
                    strcpy(ownerBuf, tmpBuf);
                    free(tmpBuf);
                    }
                }
            }
        *after=replaced;
        }
    else
        {
        if (0==GetPrivateProfileString("owners", symbol, "", ownerBuf, cBuf, Failure->IniFile())) 
            {
            GetPrivateProfileString("owners", "default", "", ownerBuf, cBuf, Failure->IniFile());
            } 
        }
    
    if (*ownerBuf) 
        {
        return ownerBuf;
        } 
    else 
        {
        return NULL;
        }
        */
    }

CHAR *AssignStack(CHAR **StackEntries, UINT numEntries, CHAR *ownerBuf, int cBuf)
    {
    OwnerCandidate Owners[MAX_CANDIDATES];
    UINT numOwners=0, i, j;
    UINT NumMatches, MaxLinesToRead, NumSuggestions;
    
    if (!StackEntries || !numEntries || !StackEntries[numEntries-1] || !ownerBuf || !cBuf) 
        {
        return NULL;
        }
    NumMatches=GetPrivateProfileInt("sensitivity", "nummatches", numEntries, Failure->IniFile());
    MaxLinesToRead=GetPrivateProfileInt("sensitivity", "MaxLines", numEntries, Failure->IniFile());
    NumSuggestions=GetPrivateProfileInt("sensitivity", "suggestions", 1, Failure->IniFile());
    
    for (i=0;i<numEntries && i<MaxLinesToRead;i++) 
        {
        GetOwner(StackEntries[i], Owners[numOwners].Name, MAX_OWNER_SIZE);
        if (Owners[numOwners].Name[0] && strcmp(Owners[numOwners].Name, "ignore")) 
            {
            Owners[numOwners].count=1;
            if (0==numOwners) 
                {
                numOwners++;
                } 
            else if (strstr(Owners[numOwners].Name, "maybe")) 
                {
                continue;
                } 
            else if (1==numOwners && strstr(Owners[0].Name, "maybe")) 
                {
                Owners[0]=Owners[numOwners];
                } 
            else 
                {
                for (j=0;j<numOwners;j++) 
                    {
                    if (0==strcmp(Owners[j].Name, Owners[numOwners].Name)) 
                        {
                        Owners[j].count++;
                        break;
                        }
                    }
                if (j==numOwners) 
                    {
                    numOwners++;
                    }
                }
            }
        }
    
    if (0==numOwners) 
        {
        GetPrivateProfileString("owners", "default", "", ownerBuf, cBuf, Failure->IniFile());
        } 
    else 
        {
        j=0;
        for (i=1;i<numOwners && i<NumMatches;i++) 
            {
            if (Owners[i].count>Owners[j].count) 
                {
                j=i;
                }
            }
        
        if (strstr(Owners[j].Name, "maybe")) 
            {
            if (1 != sscanf(Owners[j].Name, "maybe %s", ownerBuf))
                strncpy(ownerBuf, Owners[j].Name, cBuf);
            } 
        else 
            {
            strncpy(ownerBuf, Owners[j].Name, cBuf);
            }
        }
    OOF(ownerBuf, cBuf);
    return ownerBuf;
    }

BOOL GetSpecial(const CHAR *symbol, CHAR *ownerBuf, int cBuf)
    {
    
    if ((symbol == NULL) || (ownerBuf == NULL) || (cBuf == 0)) 
        {
        return FALSE;
        }
    
    if (InPageIo(symbol))
        {
        CHAR mystring[9] = {'\0'};
        if (strstr(symbol, "error "))
            {
            strncpy(mystring, strstr(symbol, "error ") + strlen("error "), 8);
            mystring[8] = '\0';
            if (GetPrivateProfileString("ioerrors", mystring, "", ownerBuf, cBuf, Failure->IniFile()) == 0) 
                return FALSE;
            else
                return TRUE;
            }
        else
            return FALSE;
        
        }
    else if (UnknownExcept(symbol))
        {
        CHAR mystring[9] = {'\0'};
        if (strstr(symbol, "- code: "))
            {
            strncpy(mystring, strstr(symbol, "- code: ") + strlen("- code: "), 8);
            mystring[8] = '\0';
            if (GetPrivateProfileString("ioerrors", mystring, "", ownerBuf, cBuf, Failure->IniFile()) == 0) 
                return FALSE;
            else
                return TRUE;
            }
        else
            return FALSE;
        }
    else if (Bugcheck(symbol))
        {
        //Bugcheck cc - PAGE_FAULT_BEYOND_END_OF_ALLOCATION fd365fe0 00000001 804fca53 00000001
        CHAR mystring[3] = {'\0'};
        if (strstr(symbol, "Bugcheck "))
            {
            strncpy(mystring, strstr(symbol, "Bugcheck ") + strlen("Bugcheck "), 2);
            mystring[2] = '\0';
            if (GetPrivateProfileString("bugchecks", mystring, "", ownerBuf, cBuf, Failure->IniFile()) == 0) 
                return FALSE;
            else
                return TRUE;
            }
        else
            return FALSE;
        }
    else
        {
        if (GetPrivateProfileString("owners", symbol, "", ownerBuf, cBuf, Failure->IniFile()) == 0) 
            return FALSE;
        else
            return TRUE;
        }
    
    return FALSE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\failure.h ===
#ifndef _FAILURE_
	#define _FAILURE_ 

#include <time.h>
#include <stdlib.h>

#define TIMEOUTPERIOD (time_t)210

#define MACH_X86		0
#define MACH_ALPHA		1
#define MACH_IA64		2
#define MACH_ALPHA64	3

#define BUILD_FREE		0
#define BUILD_CHECKED	1

#define PROMPT_KD         0
#define PROMPT_WINDBG     1
#define PROMPT_NTSD       2
#define PROMPT_ASSERT     3
#define PROMPT_USERASSERT 4
#define PROMPT_NOPROMPT   5
#define PROMPT_UNK        6

#define CPU_UNKNOWN     0
#define CPU_INTEL       1
#define CPU_AMD	        2
#define CPU_CYRIX       3

#define FT_UNK                      0
#define FT_BREAKPOINT               1
#define FT_ASSERTION_FAILURE        2
#define FT_ACCESS_VIOLATION         3
#define FT_INPAGE_IO_ERROR          4
#define FT_RESOURCE_TIMEOUT         5
#define FT_CRITICAL_SECTION_TIMEOUT 6
#define FT_POSSIBLE_DEADLOCK        7
#define FT_LSA_TOP_LEVEL_EXCEPTION  8
#define FT_NTSD_EXCEPTION           9
#define FT_BUGCHECK                 10
#define FT_UNH_EXCEPTION_WINLOGON   11
#define FT_UNH_EXCEPTION_SERVICES   12
#define FT_UNH_EXCEPTION_SVCHOST    13
#define FT_UNH_EXCEPTION_CSRSS      14
#define FT_HARDWARE_FAILURE         15
#define FT_MACHINE_SHUTDOWN         16
#define FT_CACHE_COHERENCY_BP       17
#define FT_MISALIGN                 18
#define FT_SPARSE_FILE_CORRUPT      19
#define FT_SYSCACHE_FAILURE         20
#define FT_UNKNOWN_EXCEPTION        21
#define FT_HIT_CTRL_C               22
#define FT_HIT_SYSRQ                23
#define FT_HIT_SHIFTF12             24
#define FT_INVALID_HANDLE           25
#define FT_HEAP_ASSERT              26
#define FT_INVALID_INSTRUCTION      27
#define FT_STACK_OVERFLOW           28
#define FT_WDM_BUGCHECK             29
#define FT_UNH_EXCEPTION            30
#define FT_UNRESPONSIVE             31


#define SAFEFREE(a) \
	{ \
		if (a != NULL) \
			free(a); \
		a = NULL; \
	}

class Cfailure
{
private:
    BOOL    fConnected;
    CHAR *  pszDebugger;
    CHAR *  pszPipe;

    BOOL    fFixSymbols;
    CHAR *  pszIniFile;

    DWORD   dwFailType;
    DWORD   dwWeBrokeIn;
    DWORD   dwDebugger;

    DWORD   dwBuild;
    DWORD   dwSP;
    DWORD   dwBuildDot;
    DWORD   dwVBL;
    BOOL    fLB6RI;
    CHAR *  pszVBL_Stamp;
    DWORD   dwBuildType;
    DWORD   dwArchitecture;
    DWORD   dwCPUType;
    
    CHAR *  pszFirstBuffer;
    CHAR *  pszCurrentStackBuffer;

    BOOL    fTwoPartCommand;
    CHAR *  pszStackCommand;

    CHAR *  pszDescription;
	CHAR *  pszMisc;
    CHAR *  pszStack;
    BOOL    fIsAssigned;
    CHAR *  pszFollowup;

    VOID SetPromptType(CHAR *buffer);
    BOOL SetTitleOnLastEvent();
    VOID TryForAssertData();
    BOOL GetMeSystemInfo();
    VOID FindIniFile(CHAR *pName);
    DWORD InitRemote(CHAR *pszNewDebugger, CHAR *pszNewPipe, CHAR *IniFile, DWORD dwFlags);
    DWORD GetSessionData();
    VOID DoNecessaryStackFixUps();

public:
    Cfailure();
    ~Cfailure();
    
    DWORD Init(CHAR *pszNewDebugger, CHAR *pszNewPipe, CHAR *IniFile, DWORD dwFlags = 0);

    BOOL SendCommand(const CHAR *pszCommand, CHAR **ppszRetBuffer, time_t tWaitTime = TIMEOUTPERIOD);
    BOOL SendStackCommand(const CHAR *pszCommand, BOOL fTwoPart = FALSE, BOOL fDoFixups = TRUE);
    BOOL SendCXRStack(ULARGE_INTEGER uliCxr);
    BOOL SendDotThreadStack(DWORD dwThread);
    BOOL SendBangThreadStack(ULARGE_INTEGER dwThread);
    BOOL SendBangThreadStack(DWORD dwThread, DWORD dwHighPart=0);
    BOOL SendUserThreadStack(DWORD dwUserThread);

    BOOL DoKernelBreakin();

    BOOL CloseRemote();
    BOOL GetReturnBuffer(CHAR ** ppRetBuf);

    BOOL ShutOffVerbose();
    BOOL DoAResync();

    DWORD FailureType()     {return dwFailType;}
    DWORD DebuggerType()    {return dwDebugger;}
    DWORD BuildNumber()     {return dwBuild;}
    DWORD SP()              {return dwSP;}
    DWORD BuildDot()        {return dwBuildDot;}
    DWORD VBL()             {return dwVBL;}
    DWORD BuildType()       {return dwBuildType;}
    DWORD Architecture()    {return dwArchitecture;}
    DWORD CPUType()         {return dwCPUType;}
    
    BOOL FixSymbols()       {return fFixSymbols;}
    BOOL IsStackAssigned()  {return fIsAssigned;}
    BOOL IsLB6RI()          {return fLB6RI;}

    const CHAR *StackCommand()  {return pszStackCommand;}
    const CHAR *VBLString()     {return pszVBL_Stamp;}
    const CHAR *BackSpew()      {return pszFirstBuffer;}
    const CHAR *StackBuffer()   {return pszCurrentStackBuffer;}
    const CHAR *IniFile()       {return pszIniFile;}

    const CHAR *Description()   {return pszDescription;}
    const CHAR *Misc()          {return pszMisc;}
    const CHAR *Stack()         {return pszStack;}
    const CHAR *Followup()      {return pszFollowup;}

    VOID SetFailureType(DWORD NewFT)   {dwFailType = NewFT;}
    VOID SetDebuggerType(DWORD NewDT)   {dwDebugger = NewDT;}
    VOID SetBuildNumber(DWORD NewBN)    {dwBuild = NewBN;}
    VOID SetSP(DWORD NewSP)             {dwSP = NewSP;}
    VOID SetBuildDot(DWORD NewDB)       {dwBuildDot = NewDB;}
    VOID SetVBL(DWORD NewVBL)           {dwVBL = NewVBL;}
    VOID SetLB6RI(BOOL NewRI)           {fLB6RI = NewRI;}
    VOID SetBuildType(DWORD NewBT)      {dwBuildType = NewBT;}
    VOID SetArchitecture(DWORD NewArch) {dwArchitecture = NewArch;}
    VOID SetCPUType(DWORD NewCPU)       {dwCPUType = NewCPU;}
    
    VOID SetFixSymbols(BOOL fFix)           {fFixSymbols = fFix;}

    VOID SetStackCommand(const CHAR *NewValue)  {SAFEFREE(pszStackCommand);pszStackCommand = _strdup(NewValue);}
    VOID SetVBLString(CHAR *NewValue)     {SAFEFREE(pszVBL_Stamp);pszVBL_Stamp = _strdup(NewValue); if ((pszVBL_Stamp) && (strlen(pszVBL_Stamp) >= 11)) pszVBL_Stamp[11] = '\0';}
    VOID SetBackSpew(CHAR *NewValue)      {SAFEFREE(pszFirstBuffer);pszFirstBuffer = _strdup(NewValue);}
    VOID SetStackBuffer(CHAR *NewValue)   {SAFEFREE(pszCurrentStackBuffer);pszCurrentStackBuffer = _strdup(NewValue);}
    VOID SetIniFile(CHAR *NewValue)       {SAFEFREE(pszIniFile);pszIniFile = _strdup(NewValue);}

    VOID SetDescription(CHAR *NewValue)   {SAFEFREE(pszDescription);pszDescription = _strdup(NewValue);}
    VOID SetMisc(CHAR *NewValue)          {SAFEFREE(pszMisc);pszMisc = _strdup(NewValue);}
    VOID SetStack(CHAR *NewValue)         {SAFEFREE(pszStack);pszStack = _strdup(NewValue);}
    VOID SetFollowup(CHAR *NewValue)      {SAFEFREE(pszFollowup);pszFollowup = _strdup(NewValue);fIsAssigned = TRUE;}

    VOID AppendDescription(CHAR *Addition);    
    VOID AppendMisc(CHAR *Addition);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\owner.h ===
#ifndef _MYOWNER_
	#define _MYOWNER_


CHAR *AssignStack(CHAR **StackEntries, UINT numEntries, CHAR *ownerBuf, int cBuf);
CHAR *GetOwner(CHAR *symbol, CHAR *ownerBuf, int cBuf);
BOOL GetSpecial(const CHAR *symbol, CHAR *ownerBuf, int cBuf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\isdoutils.h ===
#ifndef _ISDOUTILS_
	#define _ISDOUTILS_

#define UNKNOWN_CPU (DWORD) 0
#define INTEL (DWORD)1
#define AMD	  (DWORD)2
#define CYRIX (DWORD)3

BOOL DoEXR(ULARGE_INTEGER exr);
BOOL ResetCXR();
BOOL DoTilde();
BOOL ReloadWin32k();

BOOL IsWaitingOnLoaderLock();
BOOL IsWaitingOnCriticalSection();
BOOL IsRtlEnterCriticalSection();
BOOL IsAquireResourceExclusive();
BOOL IsVerifierAquireResource();
BOOL IsAquireResourceShared();
BOOL IsRtlAquireResourceExclusive();
BOOL IsContaingW32EnterCritical();
BOOL IsStuckInDuplicateObject();
BOOL IsStuckInChainedDispatch();
BOOL IsAMutant();
BOOL IsWaitingOnLPC();
BOOL IsUserFailure();
BOOL IsGreLockDisplay();
DWORD GetCPUType();
BOOL Is1541HostBridge();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\remote.h ===
#define VERSION 	    4
#define SERVER_READ_PIPE    _T("\\\\%s\\PIPE\\%sIN")   //Client Writes and Server Reads
#define SERVER_WRITE_PIPE   _T("\\\\%s\\PIPE\\%sOUT")  //Server Reads  and Client Writes

#define MAGICNUMBER     0x31109000

typedef struct
{
    DWORD    Size;
    DWORD    Version;
    char     ClientName[15];
    DWORD    LinesToSend;
    DWORD    Flag;
}   SESSION_STARTUPINFO;

typedef struct
{
    DWORD MagicNumber;      //New Remote
    DWORD Size;             //Size of structure
    DWORD FileSize;         //Num bytes sent
}   SESSION_STARTREPLY;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\stacks.h ===
#ifndef _STACKS_
	#define _STACKs_ 
#include "failure.h"

CHAR *StoreStack(CHAR **Lines, DWORD numLines);
VOID StripStack(CHAR **StackLines, DWORD *numLines);
// Tries to repair stack line at address. Returns new buffer if successful
BOOL GetRepairedStack(Cfailure *Fail, ULARGE_INTEGER Address);
BOOL DoesStackNeedManualReload(Cfailure * Fail, ULARGE_INTEGER* BadAddress);
// Given an address it does a !dlls -c and gets the dll name and base
BOOL GetDllAndBase(Cfailure * Fail, ULARGE_INTEGER Address, CHAR *DllName, ULARGE_INTEGER *Base);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\rmtcli.h ===
#ifndef _RMTCLI_
	#define _RMTCLI_

#include <time.h>

DWORD rmConnectToRemote(CHAR *server, CHAR *srvpipename);
BOOL rmCloseRemote();
BOOL SendMyCommand(const CHAR *theCommand, CHAR **RetBuffer, time_t tWaitTime);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\stacks.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "utils.h"
#include "getutils.h"
#include "stacks.h"

extern Cfailure *Failure;

DWORD GetDepthNeeded(DWORD numlines)
    {
    if (numlines > 10)
        return 8;
    if (numlines == 10)
        return 7;
    if (numlines == 9)
        return 7;
    if (numlines == 8)
        return 6;
    if (numlines == 7)
        return 5;
    if (numlines == 6)
        return 5;
    if (numlines == 5)
        return 4;
    if (numlines == 4)
        return 3;
    
    return numlines;
    }

BOOL DoesLineNeedReload(CHAR *Line, ULARGE_INTEGER *BadAddress)
    {
    
    if ((!_strnicmp(Line, "0x", 2)) ||
        (!_strnicmp(Line, "+0x", 3)))
        {
        if ((Failure->Architecture()) == MACH_X86)
            {
            if ((sscanf(Line, "0x%x", &(BadAddress->LowPart)))||
                (sscanf(Line, "+0x%x", &(BadAddress->LowPart))))
                return TRUE;
            }
        else
            {
            if ((2 == sscanf(Line, "0x%x`%x", &(BadAddress->HighPart), &(BadAddress->LowPart)))||
                (2 == sscanf(Line, "+0x%x`%x", &(BadAddress->HighPart), &(BadAddress->LowPart))))
                return TRUE;
            
            }
        }
    
    return FALSE;
    }

BOOL DoesStackNeedManualReload(Cfailure * Fail, ULARGE_INTEGER* BadAddress)
    {
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD numLines = 0, i = 0;
    DWORD DepthNeeded = 0;
    ULARGE_INTEGER NewBad = {0};
    BOOL SeenBefore = FALSE;
    
    if ((Fail->StackBuffer()) == NULL)
        return FALSE;
    
    if (!(buffer = _strdup(Fail->StackBuffer())))	
        return FALSE;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    StripStack(LineHeads, &numLines);
    
    DepthNeeded = GetDepthNeeded(numLines);
    
    for (i=0; i < DepthNeeded; i++)
        {
        if ((strstr(LineHeads[i], "ntdll!RtlpWaitForCriticalSection"))||
            (strstr(LineHeads[i], "!ExpAcquireResourceExclusiveLite"))||
            (strstr(LineHeads[i], "!ExAcquireResourceExclusiveLite")))
            {
            BadAddress->QuadPart = 0;
            free(buffer);
            return FALSE;
            }
        
        if (DoesLineNeedReload(LineHeads[i], &NewBad))
            {
            //Avoid printscreen stack stuff
            if (NewBad.QuadPart == 0xffffffff)
                {
                BadAddress->QuadPart = 0;
                free(buffer);
                return FALSE;
                }
            
            
            if (BadAddress->QuadPart == NewBad.QuadPart)
                {
                //Avoid stacks with repeated lines
                if (SeenBefore)
                    {
                    BadAddress->QuadPart = 0;
                    free(buffer);
                    return FALSE;
                    }
                else
                    SeenBefore = TRUE;
                }
            else
                {
                BadAddress->QuadPart = NewBad.QuadPart;
                free(buffer);
                return TRUE;
                }
            }
        }
    
    BadAddress->QuadPart = 0;
    free(buffer);
    return FALSE;
    }

BOOL TrySomeKnownAddresses(Cfailure * Fail, ULARGE_INTEGER Address, CHAR *DllName, ULARGE_INTEGER *Base)
    {
    Base->QuadPart = 0;

    // xbox addresses
    if ((Address.QuadPart > 0x80100000) && (Address.QuadPart < 0x801CABE0))
        {
        strcpy(DllName, "xboxkrnl.exe");
        return TRUE;
        }
    if ((Address.QuadPart > 0xd002a000) && (Address.QuadPart < 0xd0045520))
        {
        strcpy(DllName, "xbdm.dll");
        return TRUE;
        }
    if ((Address.QuadPart > 0xd005d000) && (Address.QuadPart < 0xd005d1e0))
        {
        strcpy(DllName, "cydrive.dxt");
        return TRUE;
        }


    /*
    if (Fail->Architecture() == MACH_X86)
        {
        if ((Fail->BuildType()) == BUILD_FREE)
            {
            if ((Address.QuadPart > 0x77f00000) && (Address.QuadPart < 0x78000000))
                {
                strcpy(DllName, "ntdll.dll");
                return TRUE;
                }
            if ((Address.QuadPart > 0x77e00000) && (Address.QuadPart < 0x77f00000))
                {
                strcpy(DllName, "kernel32.dll");
                return TRUE;
                }
            if ((Address.QuadPart > 0x77d00000) && (Address.QuadPart < 0x77e00000))
                {
                strcpy(DllName, "rpcrt4.dll");
                return TRUE;
                }
            if ((Address.QuadPart > 0x77c00000) && (Address.QuadPart < 0x77d00000))
                {
                strcpy(DllName, "clbcatq.dll");
                return TRUE;
                }
            }
        else
            {
            if ((Address.QuadPart > 0x77f00000) && (Address.QuadPart < 0x78000000))
                {
                strcpy(DllName, "ntdll.dll");
                return TRUE;
                }
            if ((Address.QuadPart > 0x77e00000) && (Address.QuadPart < 0x77f00000))
                {
                strcpy(DllName, "kernel32.dll");
                return TRUE;
                }
            if ((Address.QuadPart > 0x77c50000) && (Address.QuadPart < 0x77e00000))
                {
                strcpy(DllName, "rpcrt4.dll");
                return TRUE;
                }
            if ((Address.QuadPart > 0x77c00000) && (Address.QuadPart < 0x77c50000))
                {
                strcpy(DllName, "clbcatq.dll");
                return TRUE;
                }
            }
        
        if ((Address.QuadPart > 0xa0000000) && (Address.QuadPart < 0xa1000000))
            {
            strcpy(DllName, "win32k.sys");
            return TRUE;
            }
        }
        */
    return FALSE;
    }

BOOL GetDllAndBase(Cfailure * Fail, ULARGE_INTEGER Address, CHAR *DllName, ULARGE_INTEGER *Base)
    {
    CHAR TheString[32];
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD numLines = 0, i = 0;
    DWORD tempBase = 0;
    ULARGE_INTEGER excess = {0};
    CHAR tempDllName[MAX_PATH];
    
    if ((Address.QuadPart == 0)||(DllName == NULL)||(Base == NULL))
        return FALSE;
    
    Base->QuadPart = 0;
    DllName[0] = '\0';
    
    if ((Address.QuadPart > 0x1000000) && (Address.QuadPart < 0x2000000))
        {
        GetProcessName(DllName);
        Base->QuadPart = 0x1000000;
        return TRUE;
        }
    
    sprintf(TheString, "!dlls -c %I64x\n", Address.QuadPart);
    
    if (!Fail->SendCommand(TheString, &buffer))
        return FALSE;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    for (i=0; i < numLines; i++)
        {
        if (sscanf(LineHeads[i], " Base 0x%8x", &tempBase) == 1)
            {
            if (i > 0)
                {
                if (sscanf(LineHeads[i-1], "0x%I64x: %s", &(excess.QuadPart), tempDllName) == 2)
                    {
                    CHAR *tptr = NULL;
                    
                    tptr =strrchr(tempDllName, '\\');
                    if (tptr)
                        {
                        strcpy(DllName, (tptr + 1));
                        Base->QuadPart = tempBase;
                        free(buffer);
                        return TRUE;
                        }
                    }
                }
            }
        }
    free(buffer);
    
    return TrySomeKnownAddresses(Fail, Address, DllName, Base);
    }

VOID StripStack(CHAR **StackLines, DWORD *numLines)
    {
    DWORD i = 0, next = 0, firstLine = 0;
    CHAR *symStart = NULL;
    
    if (*numLines == 0)
        return;
    
    for (i = 0; i < *numLines; i++) 
        {
        if ((strstr(StackLines[i], "0x"))||
            (strstr(StackLines[i], "except_handler3"))||
            (strstr(StackLines[i], "Kernel stack not resident."))||
            (strstr(StackLines[i], "ProgressWndProc")))
            {
            if ((symStart = strstr(StackLines[i], "+0x"))||
                (symStart = strstr(StackLines[i], "except_handler3"))||
                (symStart = strstr(StackLines[i], "ProgressWndProc"))) 
                {
                // MSCTF!CStub__`scalar deleting destructor'
                if (strchr(StackLines[i], '!'))
                    symStart = strchr(StackLines[i], '!');
                
                while ((symStart > StackLines[i]) && 
                    (*symStart != ' ')) 
                    {
                    symStart--;
                    }
                
                if (*symStart == ' ') 
                    {
                    symStart++;
                    }
                
                StackLines[i] = symStart;
                
                // bad:5d5ec68b 00000000 00000000 00000000 00000000 0xffffffff`8b0020c2
                // good: MSCTF!CStub__`scalar deleting destructor'+0x8
                if ((symStart = strchr(StackLines[i], '`')) && (!strchr(StackLines[i], '!')))
                    {	    
                    if ((Failure->Architecture()) == MACH_X86)
                        symStart[0] = '\0';
                    }
                
                if (symStart = strstr(StackLines[i], " (FPO"))
                    symStart[0] = '\0';
                if (symStart = strstr(StackLines[i], " ["))
                    symStart[0] = '\0';
                
                }
            else if (symStart = strstr(StackLines[i], "Kernel stack not resident."))
                {
                StackLines[i] = symStart;
                //                for (i =  i + 1; i < *numLines; i++)
                //                    StackLines[i] = NULL;
                }
            else if (symStart = strstr(StackLines[i], "0x"))
                {
                DWORD dwValue = 0;
                
                if ((symStart - 9) < StackLines[i])
                    {
                    StackLines[i] = NULL;
                    continue;
                    }
                else if (stristr(StackLines[i], "Start Address"))
                    {
                    StackLines[i] = NULL;
                    continue;
                    }
                else
                    {
                    if (1 != sscanf((symStart - 9), "%8x", &dwValue))
                        {
                        StackLines[i] = NULL;
                        continue;
                        }
                    }
                
                StackLines[i] = symStart;
                if (symStart = strchr(StackLines[i], '`'))
                    StackLines[i] = (symStart + 1);
                if (symStart = strstr(StackLines[i], " (FPO"))
                    symStart[0] = '\0';
                if (symStart = strstr(StackLines[i], " ["))
                    symStart[0] = '\0';
                if (symStart = strchr(StackLines[i], ' '))
                    symStart[0] = '\0';
                
                if (1 == sscanf(StackLines[i], "0x%x", &dwValue))
                    {
                    if (dwValue < 1000000)
                        StackLines[i] = NULL;
                    }
                }
            else
                StackLines[i] = NULL;
            }
        else
            StackLines[i] = NULL;
        }
    
    // Not overly eliquent but it compacts the linelist
    // make more efficient when you have time
    for (i = 0; i < *numLines; i++) 
        {
        if (StackLines[i] != NULL)
            {
            StackLines[next] = StackLines[i];
            if (i != next)
                StackLines[i] = NULL;
            next++;
            }
        }
    *numLines = next;
    
    firstLine = 0;
    for (i = 0; i < *numLines; i++)
        {
        // this a kludge added for JohnC.  We must return on this because
        // if there is a Trap0E below it we will lose this line.
        if (strstr(StackLines[i], "!MiWaitForInPageComplete"))
            {
            firstLine = i;
            break;
            }
        
        // this a kludge added for GerardoB for popup failures.
        if (strstr(StackLines[i], "ole32!Win4AssertEx"))
            {
            firstLine = i+1;
            break;
            }
        
        if (strstr(StackLines[i], "!KiTrap0E"))
            {
            if ((i == 0)||(!strstr(StackLines[i-1], "!MmAccessFault")))
                {
                firstLine = i+1;
                break;
                }
            }
        
        //  If dont return on these ones because messageBoxA and W
        // seem to come in bunches and I want to get to the lowest one
        // With trap0e sometimes there are 2 and I want to stop at the top one
        // not necessarily with this one but lets try it and see
        // who screams
        if (strstr(StackLines[i], "USER32!MessageBoxA+"))
            {
            firstLine = i+1;
            }
        
        if (strstr(StackLines[i], "USER32!MessageBoxW+"))
            {
            firstLine = i+1;
            }
        }
    
    if (firstLine)
        {
        next = 0;
        for (i=firstLine; i < *numLines; i++)
            {
            StackLines[next++]=StackLines[i];
            }
        *numLines = *numLines - firstLine;
        }
}



//
// Allocates memory for and stores the failures stack
//
CHAR *StoreStack(CHAR **Lines, DWORD numLines)
    {
    UINT i = 0;
    DWORD numBytes = 1;
    CHAR *stackbuff = NULL;
    
    if ((numLines > MAXLINES) || (Lines[0] == NULL))
        {
        return NULL;
        }
    
    for (i = 0; i < numLines; i++) 
        {
        if (Lines[i] != NULL)
            numBytes += strlen(Lines[i])+2;
        }
    
    stackbuff=(CHAR *)malloc(numBytes);
    stackbuff[0]='\0';
    
    for (i = 0; i < numLines; i++) 
        {
        if (Lines[i] != NULL)
            {
            strcat(stackbuff, Lines[i]);
            if (i < numLines - 1) 
                {
                strcat(stackbuff, "\n");
                }
            }
        }
    return stackbuff;
    }


BOOL GetRepairedStack(Cfailure *Fail, ULARGE_INTEGER Address)
    {
    CHAR DllName[MAX_PATH];
    CHAR SendString[MAX_PATH];
    CHAR AddressString[11];
    ULARGE_INTEGER Base = {0};
    CHAR *buffer = NULL;
    
    
    if (!GetDllAndBase(Fail, Address, DllName, &Base))
        return FALSE;
    
    if (Base.QuadPart == 0)
        sprintf(SendString, "!reload %s\n", DllName);
    else
        sprintf(SendString, "!reload %s=%I64x\n", DllName, Base.QuadPart);
    
    if (!Fail->SendCommand(SendString, NULL))
        return FALSE;
    
    if (!Fail->SendStackCommand(NULL, FALSE, FALSE))
        return FALSE;
    
    sprintf(AddressString, "0x%I64x", Address.QuadPart);
    
    if (strstr(Fail->StackBuffer(), AddressString))
        return FALSE;
    
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\symbol.h ===
#ifndef _MYSYMBOLS_
	#define _MYSYMBOLS_

#define DEFAULT_USERPATH "%SystemRoot%" 
#define DEFAULT_CHKKERNEL "\\\\ntstress\\symbols\\usa\\##BLD##\\##ARCH##chk;\\\\winbuilds\\release\\main\\usa\\##BLD##\\##ARCH##chk\\bin"
#define DEFAULT_FREKERNEL "\\\\ntstress\\symbols\\usa\\##BLD##\\##ARCH##fre;\\\\winbuilds\\release\\main\\usa\\##BLD##\\##ARCH##fre\\bin"

// \\robsvbl1\release\2223.x86fre.Lab01_N.000412-2227\symbols.pri
#define VBL1X86FRE "\\\\robsvbl1\\release\\##BLD##.x86fre.Lab01_N.##STMP##\\symbols.pri\\retail;\\\\robsvbl1\\release\\##BLD##.x86fre.Lab01_N.##STMP##"
#define VBL1X86CHK "\\\\robsvbl2\\release\\##BLD##.x86chk.Lab01_N.##STMP##\\symbols.pri\\retail;\\\\robsvbl2\\release\\##BLD##.x86chk.Lab01_N.##STMP##"
#define VBL1IA64FRE "\\\\robsvbl3\\release\\##BLD##.ia64fre.Lab01_N.##STMP##\\symbols.pri\\retail;\\\\robsvbl3\\release\\##BLD##.ia64fre.Lab01_N.##STMP##"
#define VBL1IA64CHK "\\\\robsvbl4\\release\\##BLD##.ia64chk.Lab01_N.##STMP##\\symbols.pri\\retail;\\\\robsvbl4\\release\\##BLD##.ia64chk.Lab01_N.##STMP##"

#define VBL2X86FRE "\\\\netvbl1\\release\\##BLD##.x86fre.Lab02_N.##STMP##\\symbols.pri\\retail;\\\\netrel1\\release\\usa\\##BLD##.x86fre.Lab02_N.##STMP##\\symbols.pri\\retail;\\\\netvbl1\\release\\##BLD##.x86fre.Lab02_N.##STMP##;\\\\netrel1\\release\\usa\\##BLD##.x86fre.Lab02_N.##STMP##"
#define VBL2X86CHK "\\\\netvbl2\\release\\##BLD##.x86chk.Lab02_N.##STMP##\\symbols.pri\\retail;\\\\netrel2\\release\\usa\\##BLD##.x86chk.Lab02_N.##STMP##\\symbols.pri\\retail;\\\\netvbl2\\release\\##BLD##.x86chk.Lab02_N.##STMP##;\\\\netrel2\\release\\usa\\##BLD##.x86chk.Lab02_N.##STMP##"
#define VBL2IA64FRE "\\\\netvbl3\\release\\##BLD##.ia64fre.Lab02_N.##STMP##\\symbols.pri\\retail;\\\\netrel1\\release\\usa\\##BLD##.ia64fre.Lab02_N.##STMP##\\symbols.pri\\retail;\\\\netvbl3\\release\\##BLD##.ia64fre.Lab02_N.##STMP##;\\\\netrel1\\release\\usa\\##BLD##.ia64fre.Lab02_N.##STMP##"
#define VBL2IA64CHK "\\\\netvbl4\\release\\##BLD##.ia64chk.Lab02_N.##STMP##\\symbols.pri\\retail;\\\\netrel2\\release\\usa\\##BLD##.ia64chk.Lab02_N.##STMP##\\symbols.pri\\retail;\\\\netvbl4\\release\\##BLD##.ia64chk.Lab02_N.##STMP##;\\\\netrel2\\release\\usa\\##BLD##.ia64chk.Lab02_N.##STMP##"

#define VBL3X86FRE "\\\\dsys-rel-fre\\release\\usa\\##BLD##.x86fre.Lab03_N.##STMP##\\symbols.pri\\retail;\\\\dsys-rel-fre\\release\\usa\\##BLD##.x86fre.Lab03_N.##STMP##"
#define VBL3X86CHK "\\\\dsys-rel-chk\\release\\usa\\##BLD##.x86chk.Lab03_N.##STMP##\\symbols.pri\\retail;\\\\dsys-rel-chk\\release\\usa\\##BLD##.x86chk.Lab03_N.##STMP##"
#define VBL3IA64FRE "\\\\dsys-rel-fre\\release\\usa\\##BLD##.ia64fre.Lab03_N.##STMP##\\symbols.pri\\retail;\\\\dsys-rel-fre\\release\\usa\\##BLD##.ia64fre.Lab03_N.##STMP##"
#define VBL3IA64CHK "\\\\dsysi64chkp\\release\\##BLD##.ia64chk.Lab03_N.##STMP##\\symbols.pri\\retail;\\\\dsysi64chkp\\release\\##BLD##.ia64chk.Lab03_N.##STMP##"

#define VBL4X86FRE "\\\\MGMTx86FRE\\release\\##BLD##.x86fre.Lab04_N.##STMP##\\symbols.pri\\retail;\\\\MGMTrel1\\release\\usa\\##BLD##.x86fre.Lab04_N.##STMP##\\symbols.pri\\retail;\\\\MGMTx86FRE\\release\\##BLD##.x86fre.Lab04_N.##STMP##;\\\\MGMTrel1\\release\\usa\\##BLD##.x86fre.Lab04_N.##STMP##"
#define VBL4X86CHK "\\\\MGMTx86CHK\\release\\##BLD##.x86chk.Lab04_N.##STMP##\\symbols.pri\\retail;\\\\MGMTrel1\\release\\usa\\##BLD##.x86fre.Lab04_N.##STMP##\\symbols.pri\\retail;\\\\MGMTx86CHK\\release\\##BLD##.x86chk.Lab04_N.##STMP##;\\\\MGMTrel1\\release\\usa\\##BLD##.x86fre.Lab04_N.##STMP##"
#define VBL4IA64FRE "\\\\MGMTIA64FRE\\release\\##BLD##.ia64fre.Lab04_N.##STMP##\\symbols.pri\\retail;\\\\MGMTrel1\\release\\usa\\##BLD##.x86fre.Lab04_N.##STMP##\\symbols.pri\\retail;\\\\MGMTIA64FRE\\release\\##BLD##.ia64fre.Lab04_N.##STMP##;\\\\MGMTrel1\\release\\usa\\##BLD##.ia64fre.Lab04_N.##STMP##"
#define VBL4IA64CHK "\\\\MGMTIA64CHK\\release\\##BLD##.ia64chk.Lab04_N.##STMP##\\symbols.pri\\retail;\\\\MGMTrel1\\release\\usa\\##BLD##.x86fre.Lab04_N.##STMP##\\symbols.pri\\retail;\\\\MGMTIA64CHK\\release\\##BLD##.ia64chk.Lab04_N.##STMP##;\\\\MGMTrel1\\release\\usa\\##BLD##.ia64chk.Lab04_N.##STMP##"

#define VBL6X86FRE "\\\\homerj\\release\\usa\\##BLD##.x86fre.Lab06_N.##STMP##\\symbols.pri\\retail;\\\\homerj\\release\\usa\\##BLD##.x86fre.Lab06_N.##STMP##"
#define VBL6X86CHK "\\\\homerj\\release\\usa\\##BLD##.x86chk.Lab06_N.##STMP##\\symbols.pri\\retail;\\\\homerj\\release\\usa\\##BLD##.x86chk.Lab06_N.##STMP##"
#define VBL6IA64FRE "\\\\homerj\\release\\usa\\##BLD##.ia64fre.Lab06_N.##STMP##\\symbols.pri\\retail;\\\\homerj\\release\\usa\\##BLD##.ia64fre.Lab06_N.##STMP##"
#define VBL6IA64CHK "\\\\homerj\\release\\usa\\##BLD##.ia64chk.Lab06_N.##STMP##\\symbols.pri\\retail;\\\\homerj\\release\\usa\\##BLD##.ia64chk.Lab06_N.##STMP##"

#define VBL7X86FRE "\\\\COMBUILD8\\release\\##BLD##.x86fre.Lab07_N.##STMP##\\symbols.pri\\retail;\\\\COMBUILD8\\release\\##BLD##.x86fre.Lab07_N.##STMP##;\\\\combuild4\\release\\##BLD##.x86fre.Lab07_N.##STMP##\\symbols.pri\\retail;\\\\combuild4\\release\\##BLD##.x86fre.Lab07_N.##STMP##"
#define VBL7X86CHK "\\\\COMBUILD9\\release\\##BLD##.x86chk.Lab07_N.##STMP##\\symbols.pri\\retail;\\\\COMBUILD9\\release\\##BLD##.x86chk.Lab07_N.##STMP##"
#define VBL7IA64FRE "\\\\COMBUILD10\\release\\##BLD##.ia64fre.Lab07_N.##STMP##\\symbols.pri\\retail;\\\\COMBUILD10\\release\\##BLD##.ia64fre.Lab07_N.##STMP##"
#define VBL7IA64CHK "\\\\COMBUILD11\\release\\##BLD##.ia64chk.Lab07_N.##STMP##\\symbols.pri\\retail;\\\\COMBUILD11\\release\\##BLD##.ia64chk.Lab07_N.##STMP##"

BOOL FixSymbolPath();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\rmtcli.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "rmtcli.h"
#include "dbgr.h"

#define BUFFSIZE 4096
#define MAX_RETRIES 5
#define LINES_TO_READ 150

#define READEND 0
#define WRITEEND 1

#define VERSION 4

#define SERVER_READ_PIPE    "\\\\%s\\PIPE\\%sIN"   //Client Writes and Server Reads
#define SERVER_WRITE_PIPE   "\\\\%s\\PIPE\\%sOUT"  //Server Reads  and Client Writes

#define MAGICNUMBER     0x31109000

typedef struct
    {
    DWORD    Size;
    DWORD    Version;
    CHAR     ClientName[15];
    DWORD    LinesToSend;
    DWORD    Flag;
    }   SESSION_STARTUPINFO;

typedef struct
    {
    DWORD MagicNumber;      //New Remote
    DWORD Size;             //Size of structure
    DWORD FileSize;         //Num bytes sent
    }   SESSION_STARTREPLY;

HANDLE hPipes[2] = {NULL, NULL};
BOOL UseNewPipe = FALSE;

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

DWORD ReadFixBytes(CHAR *Buffer, DWORD ToRead, DWORD TimeOut)
    {
    DWORD xyzBytesRead=0;
    DWORD xyzBytesToRead=ToRead;
    CHAR  *xyzbuff=Buffer;
    
    while(xyzBytesToRead!=0) {
        if (!ReadFile(hPipes[READEND],xyzbuff,xyzBytesToRead,&xyzBytesRead,NULL)) {
            return(xyzBytesToRead);
            }
        
        xyzBytesToRead-=xyzBytesRead;
        xyzbuff+=xyzBytesRead;
        }
    return(0);
    }

BOOL SendInfo(int LinesToSend)
    {
    DWORD  hostlen=14;
    WORD   BytesToSend=sizeof(SESSION_STARTUPINFO);
    DWORD  tmp = 15;
    SESSION_STARTUPINFO ssi;
    SESSION_STARTREPLY  ssr;
    
    RtlZeroMemory(&ssi,sizeof(ssi));
    RtlZeroMemory(&ssr,sizeof(ssr));
    
    ssi.Size=BytesToSend;
    ssi.Version=VERSION;
    
    tmp=sizeof(ssi.ClientName);
    //GetUserNameA(ssi.ClientName, &tmp);
    strcpy(ssi.ClientName, "xstress");
    ssi.ClientName[14]=0;
    ssi.LinesToSend=LinesToSend;
    
        {
        DWORD NewCode=MAGICNUMBER;
        char  Name[15];
        
        strcpy(Name,(char *)ssi.ClientName);
        memcpy(&Name[11],(char *)&NewCode,sizeof(NewCode));
        
        if (!WriteFile(hPipes[WRITEEND],(char *)Name,15,&tmp,NULL))
            return FALSE;
        if (!ReadFile(hPipes[READEND] ,(char *)&ssr.MagicNumber,sizeof(ssr.MagicNumber),&tmp,NULL))
            return FALSE;
        
        if (ssr.MagicNumber!=MAGICNUMBER) 
            {
            return FALSE;
            }
        
        //Get Rest of the info-its not the old server
        
        ReadFixBytes((char *)&ssr.Size,sizeof(ssr.Size),0);
        ReadFixBytes((char *)&ssr.FileSize,sizeof(ssr)-sizeof(ssr.FileSize)-sizeof(ssr.MagicNumber),0);
        
        }
        ssi.Flag=0x80000000;
        if (!WriteFile(hPipes[WRITEEND],(char *)&ssi,BytesToSend,&tmp,NULL)) {
            return(FALSE);
            }
        
        return(TRUE);
    }

DWORD rmConnectToRemote(CHAR *server, CHAR *srvpipename)
    {
    CHAR	pipenameSrvIn[200];
    CHAR	pipenameSrvOut[200];
    int		tries = 0;
    BOOL	ret = TRUE;
    DWORD   dwOldPipeError = 0;
    HRESULT hRes = S_OK;
    
    if ((server == NULL)||(srvpipename == NULL))
        return ERROR_INVALID_FUNCTION;
    
    hPipes[READEND] = INVALID_HANDLE_VALUE;
    hPipes[WRITEEND] = INVALID_HANDLE_VALUE;
    
    /*	UseNewPipe = TRUE;
    
      hRes = ConnectEngine(server, srvpipename);  
      if (SUCCEEDED(hRes))
      return(ERROR_SUCCESS);
      
        UseNewPipe = FALSE;
    */
    sprintf(pipenameSrvIn ,SERVER_READ_PIPE ,server,srvpipename);
    sprintf(pipenameSrvOut,SERVER_WRITE_PIPE,server,srvpipename);
    
    hPipes[READEND]=CreateFile(pipenameSrvOut,GENERIC_READ ,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    if (hPipes[READEND]==INVALID_HANDLE_VALUE) 
        {
        tries = 1;
        while ((hPipes[READEND]==INVALID_HANDLE_VALUE) && (tries <= MAX_RETRIES))
            {
            hPipes[READEND]=CreateFile(pipenameSrvOut,GENERIC_READ ,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
            tries++;
            }
        
        if (hPipes[READEND]==INVALID_HANDLE_VALUE) 
            {
            dwOldPipeError = GetLastError();
            goto failed;
            }
        }
    
    hPipes[WRITEEND]=CreateFile(pipenameSrvIn ,GENERIC_WRITE,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    if (hPipes[WRITEEND]==INVALID_HANDLE_VALUE) 
        {
        tries = 1;
        while ((hPipes[WRITEEND]==INVALID_HANDLE_VALUE) && (tries <= MAX_RETRIES))
            {
            hPipes[WRITEEND]=CreateFile(pipenameSrvIn ,GENERIC_WRITE,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
            tries++;
            }
        if (hPipes[WRITEEND]==INVALID_HANDLE_VALUE) 
            {
            CloseHandle(hPipes[READEND]);
            dwOldPipeError = GetLastError();
            goto failed;
            }
        }
    
    if (!(ret = SendInfo(LINES_TO_READ))) 
        {
        tries =1;
        while ((tries <= MAX_RETRIES)&&(!ret))
            {
            ret = SendInfo(LINES_TO_READ);
            tries++;
            }
        if (!ret)
            {
            CloseHandle(hPipes[READEND]);
            CloseHandle(hPipes[WRITEEND]);
            dwOldPipeError = GetLastError();
            goto failed;
            }
        }
    return(ERROR_SUCCESS);
    
failed:
    
    hPipes[READEND] = INVALID_HANDLE_VALUE;
    hPipes[WRITEEND] = INVALID_HANDLE_VALUE;
    
    return dwOldPipeError;
    }

BOOL rmCloseRemote()
    {
    if (hPipes[READEND] != INVALID_HANDLE_VALUE)
        CloseHandle(hPipes[READEND]);
    if (hPipes[WRITEEND] != INVALID_HANDLE_VALUE)
        CloseHandle(hPipes[WRITEEND]);
    
    hPipes[READEND] = INVALID_HANDLE_VALUE;
    hPipes[WRITEEND] = INVALID_HANDLE_VALUE;
    
    //DisconnectEngine();
    
    return TRUE;
    }

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

BOOL mPeekNamedPipe(LPVOID lpBuffer, DWORD nBufferSize,  
                    LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
    {
    BOOL ret = TRUE, ret2 = TRUE;
    DWORD x = 0;
    DWORD BytesLeftThisMessage = 0;
    
    *lpTotalBytesAvail = 0;
    
    ret = PeekNamedPipe(hPipes[READEND], lpBuffer, nBufferSize, lpBytesRead, lpTotalBytesAvail, &BytesLeftThisMessage);
    
    if (lpBytesLeftThisMessage)
        *lpBytesLeftThisMessage = BytesLeftThisMessage;
    
    x = GetLastError();
    return TRUE;
    }

BOOL EmptyPipe()
    {
    CHAR tempbuff[BUFFSIZE] = {'\0'};
    DWORD bytesAvailable = 0;
    DWORD bytesRead = 0;
    
    // we do this to clean up the pipe
    mPeekNamedPipe(NULL, 0, NULL, &bytesAvailable, NULL);
    while (bytesAvailable)
        {
        if (!ReadFile(hPipes[READEND], &tempbuff, BUFFSIZE - 1, &bytesRead, NULL))
            return FALSE;
        mPeekNamedPipe(NULL, 0, NULL, &bytesAvailable, NULL);
        }
    
    return TRUE;
    }

BOOL WriteOutCommand(const CHAR *theCommand)
    {
    DWORD bytesWritten = 0;
    
    if (!WriteFile(hPipes[WRITEEND], theCommand, strlen(theCommand), &bytesWritten, NULL)) 
        {
        return FALSE;
        }
    Sleep(1000);
    return TRUE;
    }

BOOL WeHaveAPrompt(CHAR *theBuffer)
    {
    CHAR *sol = NULL;
    
    sol = strrchr(theBuffer, '>');
    if (sol)
        {
        sol--;
        if ((*sol) == 'd')
            {
            if (*(--sol) == 'k')
                return TRUE;
            }
        else if (isdigit(*sol))
            {
            while (isdigit(*sol))
                sol--;
            
            if ((*sol) == ':')
                {
                sol--;
                if (isdigit(*sol))
                    return TRUE;
                }
            }
        }
    return FALSE;
    }

    
/*
DWORD ReadData(char *buffer, unsigned bytesToRead, unsigned maxBuffSize)
    {
    DWORD bytesAvailable = bytesToRead;
    DWORD bytesRead;

    while(bytesAvailable)
        {
        if(!ReadFile(hPipes[READEND], buffer, bytesAvailable, &bytesRead, NULL))
            break;
        bytesAvailable = bytesAvailable - bytesRead;
        buffer += bytesRead;
        buffer[0] = '\0';
        }

    return bytesToRead-bytesAvailable;
    }
*/


// This function actually sends commands to the pipe and gets back the results
// Options:
// 1.theCommand = NULL && theBuffer = NULL then EmptyPipe
// 2.theCommand = NULL && theBuffer ! NULL then Get existing pipe data
// 3.theCommand ! NULL && theBuffer = NULL then Send command, dont want results
//							(They are still cleared from pipe)
// 4.theCommand ! NULL && theBuffer ! NULL then Send Command get Results
BOOL SendMyCommand(const CHAR *theCommand, CHAR **RetBuffer, time_t tWaitTime)
    {
    time_t	tTheTime = 0;
    CHAR *pcurr = NULL;
    CHAR *buf2 = NULL;
    DWORD bytesRead = 0;
    DWORD bytesAvailable = 0;
    BOOL done = FALSE;
    CHAR *theBuffer = NULL;	
    unsigned maxChunks = 5;

    // NO pipes no send
    if((hPipes[READEND] == NULL) || (hPipes[WRITEEND] == NULL))
        return FALSE;
    
    if(RetBuffer != NULL)
        *RetBuffer = NULL;
    
    // Get rid of the special(easy) case
    if((theCommand == NULL) && (RetBuffer == NULL))
        {
        EmptyPipe();
        return TRUE;
        }
    
    if(theCommand != NULL)
        {
        EmptyPipe();
        if(!WriteOutCommand(theCommand))
            return FALSE;
        }
    
    tTheTime = time(NULL) + tWaitTime;
    
    // Lets wait for some bytes to come available
    while(!bytesAvailable)
        {
        mPeekNamedPipe(NULL, 0, NULL, &bytesAvailable, NULL);
        if(time(NULL) > tTheTime)
            return FALSE;
        if(!bytesAvailable)
            Sleep(500);
        }
    
    // Get That first chunk
    if(pcurr = theBuffer = (CHAR *)malloc(bytesAvailable + 1))
        {
        while(bytesAvailable)
            {
            if(!ReadFile(hPipes[READEND], pcurr, bytesAvailable, &bytesRead, NULL))
                return FALSE;
            bytesAvailable = bytesAvailable - bytesRead;
            pcurr+=bytesRead;
            pcurr[0] = '\0';
            }
        }
    else
        return FALSE;
    
    // below code will max processor for tWaitTime on unbroken boxes
    // There could be some more coming
    do
        {
        bytesAvailable = 0;
        mPeekNamedPipe(NULL, 0, NULL, &bytesAvailable, NULL);
        
        while (bytesAvailable)
            {
            if (buf2 = (CHAR *)malloc((strlen(theBuffer) * sizeof(CHAR)) + 1 + bytesAvailable)) 
                {
                ZeroMemory(buf2, ((strlen(theBuffer) * sizeof(CHAR)) + 1 + bytesAvailable));
                strcpy(buf2, theBuffer);
                free(theBuffer);
                theBuffer=buf2;
                pcurr = theBuffer + strlen(theBuffer);
                
                while (bytesAvailable)
                    {
                    if (!ReadFile(hPipes[READEND], pcurr, bytesAvailable, &bytesRead, NULL))
                        {
                        free(theBuffer);
                        return FALSE;
                        }
                    bytesAvailable = bytesAvailable - bytesRead;
                    pcurr+=bytesRead;
                    pcurr[0] = '\0';
                    }	// while
                }
            else
                {
                free(theBuffer);
                return FALSE;
                }
            mPeekNamedPipe(NULL, 0, NULL, &bytesAvailable, NULL);
            if (time(NULL) > (tTheTime + tWaitTime))
                break;
            }
        
        // this should get kd> and #:{###}#>
        if (time(NULL) > tTheTime)
            done = TRUE;
        else
            done = WeHaveAPrompt(theBuffer);
        } while (!done);
        

    if((time(NULL) >= tTheTime)&& !WeHaveAPrompt(theBuffer))
        {
        // ctrl-v wont get a prompt but we want the buffer
        if((theCommand != NULL)&&(!strcmp(theCommand, "\026\n")))
            {
            if (RetBuffer != NULL)
                *RetBuffer = theBuffer;
            return FALSE;
            }

        // a breakpoint wont have a prompt but it will be waiting for a reply
        else if((strstr((theBuffer), "(bipt)?"))||
            (strstr((theBuffer), "[gbwxpft?]"))||
            (strstr((theBuffer), "(boipt)?"))||
            (strstr((theBuffer), "(bizro)?"))||
            (strstr((theBuffer), "(bizrd)?"))||
            (strstr((theBuffer), "Assertion failed")))
            {}
        else
            {
            free(theBuffer);
            return FALSE;
            }
        }
    
    if(RetBuffer != NULL)
        {
        *RetBuffer = theBuffer;
        }
    else
        {
        if (theBuffer)
            free(theBuffer);
        }
    
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\triage.h ===
//#define MYLIBAPI __declspec(dllexport)

#include "trisupp.h"
#include "symbol.h"
#include "utils.h"
#include "bugcheck.h"
#include "IsDoUtils.h"
#include "owner.h"
#include "GetUtils.h"
#include "failure.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\symbol.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "failure.h"
#include "utils.h"
#include "symbol.h"

extern Cfailure *Failure;

BOOL DoReload()
    {
    CHAR *buffer;
    
    if ((Failure->SendCommand("!reload\n", NULL)))
        {
        return TRUE;
        }
    
    if (!Failure->SendCommand(NULL, &buffer))
        return FALSE;
    
    free(buffer);
    return TRUE;
    }

BOOL StayLocal()
    {
    CHAR *buffer = NULL;
    
    if (!Failure->SendCommand("|\n", &buffer))
        return TRUE;
    
    if ((stristr(buffer, "lsass.exe"))||(stristr(buffer, "pdwssp.dll"))||
        (stristr(buffer, "csrss.exe"))||(stristr(buffer, "csrsrv.dll"))||
        (stristr(buffer, "webclnt.exe")))
        {
        free (buffer);
        return TRUE;
        }
    
    free (buffer);
    return FALSE;
    }

CHAR *GetUserPath()
    {
    CHAR UserPath[MAX_PATH + 1];
    
    GetPrivateProfileString("PATHS",
        "USERPATH", 
        DEFAULT_USERPATH,
        UserPath, 
        sizeof(UserPath), 
        Failure->IniFile());
    
    if (UserPath[strlen(UserPath) - 1] == ';')
        UserPath[strlen(UserPath) - 1] = '\0';
    
    return _strdup(UserPath);
    }

CHAR *GetSymbolServerPath()
    {
    return _strdup("symsrv*symsrv.dll*\\\\symbols\\symbols");
    }

CHAR *GetVBLPath()
    {
    CHAR buff[48];
    CHAR UserPath[MAX_PATH * 2];
    CHAR pathbuffer[MAX_PATH *2];
    CHAR *tmp = NULL, *tmp2 = NULL;
    
    UserPath[0] = '\0';
    
    switch(Failure->VBL())
        {
        case 1:
            if ((Failure->Architecture()) == MACH_X86)	
                {
                if ((Failure->BuildType()) == BUILD_CHECKED)
                    strncpy(UserPath, VBL1X86CHK, sizeof(UserPath)-1);
                else 
                    strncpy(UserPath, VBL1X86FRE, sizeof(UserPath)-1);
                }
            else if ((Failure->Architecture()) == MACH_IA64)
                {
                if ((Failure->BuildType()) == BUILD_CHECKED)
                    strncpy(UserPath, VBL1IA64CHK, sizeof(UserPath)-1);
                else 
                    strncpy(UserPath, VBL1IA64FRE, sizeof(UserPath)-1);
                }
            else
                return NULL;
            break;
        case 2:
            if ((Failure->Architecture()) == MACH_X86)
                {
                if ((Failure->BuildType()) == BUILD_CHECKED)
                    strncpy(UserPath, VBL2X86CHK, sizeof(UserPath)-1);
                else 
                    strncpy(UserPath, VBL2X86FRE, sizeof(UserPath)-1);
                }
            else if ((Failure->Architecture()) == MACH_IA64)
                {
                if ((Failure->BuildType()) == BUILD_CHECKED)
                    strncpy(UserPath, VBL2IA64CHK, sizeof(UserPath)-1);
                else 
                    strncpy(UserPath, VBL2IA64FRE, sizeof(UserPath)-1);
                }
            else
                return NULL;
            break;
        case 3:
            if ((Failure->Architecture()) == MACH_X86)
                {
                if ((Failure->BuildType()) == BUILD_CHECKED)
                    strncpy(UserPath, VBL3X86CHK, sizeof(UserPath)-1);
                else 
                    strncpy(UserPath, VBL3X86FRE, sizeof(UserPath)-1);
                }
            else if ((Failure->Architecture()) == MACH_IA64)
                {
                if ((Failure->BuildType()) == BUILD_CHECKED)
                    strncpy(UserPath, VBL3IA64CHK, sizeof(UserPath)-1);
                else 
                    strncpy(UserPath, VBL3IA64FRE, sizeof(UserPath)-1);
                }
            else
                return NULL;
            break;
        case 4:
            if ((Failure->Architecture()) == MACH_X86)
                {
                if ((Failure->BuildType()) == BUILD_CHECKED)
                    strncpy(UserPath, VBL4X86CHK, sizeof(UserPath)-1);
                else 
                    strncpy(UserPath, VBL4X86FRE, sizeof(UserPath)-1);
                }
            else if ((Failure->Architecture()) == MACH_IA64)
                {
                if ((Failure->BuildType()) == BUILD_CHECKED)
                    strncpy(UserPath, VBL4IA64CHK, sizeof(UserPath)-1);
                else 
                    strncpy(UserPath, VBL4IA64FRE, sizeof(UserPath)-1);
                }
            else
                return NULL;
            break;
        case 6:
            if ((Failure->Architecture()) == MACH_X86)
                {
                if ((Failure->BuildType()) == BUILD_CHECKED)
                    strncpy(UserPath, VBL6X86CHK, sizeof(UserPath)-1);
                else 
                    strncpy(UserPath, VBL6X86FRE, sizeof(UserPath)-1);
                }
            else if ((Failure->Architecture()) == MACH_IA64)
                {
                if ((Failure->BuildType()) == BUILD_CHECKED)
                    strncpy(UserPath, VBL6IA64CHK, sizeof(UserPath)-1);
                else 
                    strncpy(UserPath, VBL6IA64FRE, sizeof(UserPath)-1);
                }
            else
                return NULL;
            break;
        case 7:
            if ((Failure->Architecture()) == MACH_X86)
                {
                if ((Failure->BuildType()) == BUILD_CHECKED)
                    strncpy(UserPath, VBL7X86CHK, sizeof(UserPath)-1);
                else 
                    strncpy(UserPath, VBL7X86FRE, sizeof(UserPath)-1);
                }
            else if ((Failure->Architecture()) == MACH_IA64)
                {
                if ((Failure->BuildType()) == BUILD_CHECKED)
                    strncpy(UserPath, VBL7IA64CHK, sizeof(UserPath)-1);
                else 
                    strncpy(UserPath, VBL7IA64FRE, sizeof(UserPath)-1);
                }
            else
                return NULL;
            break;
            
        default:
            return NULL;
    }
    
    if (UserPath[0] == '\0')
        return NULL;
    
    UserPath[sizeof(UserPath) - 1] = '\0';
    
    strcpy(pathbuffer, UserPath);
    
    while (tmp = strstr(pathbuffer, "##BLD##"))
        {
        tmp2 = strstr(UserPath, "##BLD##") + strlen("##BLD##");
        tmp[0] = '\0';
        
        if ((Failure->BuildNumber()) == 0)
            Failure->SetBuildNumber(2195);
        
        _itoa(Failure->BuildNumber(), buff, 10);
        strcat(pathbuffer, buff);
        
        if (((Failure->SP()) <= 1) && (Failure->BuildDot() > 0))
            {
            strcat(pathbuffer, ".");
            sprintf(buff, "%03u", Failure->BuildDot());
            strcat(pathbuffer, buff);
            }
        
        strcat(pathbuffer, tmp2);
        
        tmp2 = strstr(UserPath, "##BLD##");
        
        tmp2[0] = '\0';
        strcat(tmp2, tmp);
        }
    
    while (tmp = strstr(pathbuffer, "##STMP##"))
        {
        tmp2 = strstr(UserPath, "##STMP##") + strlen("##STMP##");
        tmp[0] = '\0';
        
        strcat(pathbuffer, Failure->VBLString());
        
        strcat(pathbuffer, tmp2);
        
        tmp2 = strstr(UserPath, "##STMP##");
        tmp2[0] = '\0';
        strcat(tmp2, tmp);
        }
    
    if ((Failure->IsLB6RI()) == TRUE)
        {
        while (tmp = strstr(pathbuffer, "Lab06_N"))
            {
            tmp2 = strstr(UserPath, "Lab06_N") + strlen("Lab06_N");
            tmp[0] = '\0';
            
            strcat(pathbuffer, "LB6RI");
            
            strcat(pathbuffer, tmp2);
            
            tmp2 = strstr(UserPath, "Lab06_N");
            tmp2[0] = '\0';
            strcat(tmp2, tmp);
            }
        }
    
    return _strdup(pathbuffer);
}

CHAR *GetStressPath()
    {
    CHAR buff[48];
    CHAR UserPath[MAX_PATH + 1];
    CHAR pathbuffer[MAX_PATH + 1];
    CHAR *tmp = NULL, *tmp2 = NULL;
    
    if (((Failure->BuildDot()) > 0) && ((Failure->SP()) > 0))
        {
        if ((Failure->BuildType()) == BUILD_CHECKED)
            {
            strcpy(UserPath, "\\\\spstress\\symbols\\##ARCH##\\##BLD##sp##SP##.chk\\##SP##.##DOT##");
            }
        else
            {
            strcpy(UserPath, "\\\\spstress\\symbols\\##ARCH##\\##BLD##sp##SP##\\##SP##.##DOT##");
            }
        }
    else
        {
        if ((Failure->BuildType()) == BUILD_CHECKED)
            {
            GetPrivateProfileString("PATHS", 
                "CHKKERNELPATH", 
                DEFAULT_CHKKERNEL,
                UserPath, 
                sizeof(UserPath), 
                Failure->IniFile());
            }
        else
            {
            GetPrivateProfileString("PATHS", 
                "FREEKERNELPATH", 
                DEFAULT_FREKERNEL,
                UserPath, 
                sizeof(UserPath), 
                Failure->IniFile());
            }
        }
    
    strncpy(pathbuffer, UserPath, sizeof(pathbuffer) - 1);
    
    while (tmp = strstr(pathbuffer, "##ARCH##"))
        {
        tmp2 = strstr(UserPath, "##ARCH##") + strlen("##ARCH##");
        tmp[0] = '\0';
        
        if ((Failure->Architecture()) == MACH_IA64)
            strcat(pathbuffer, "ia64");
        else
            strcat(pathbuffer, "x86");
        
        strcat(pathbuffer, tmp2);
        
        tmp2 = strstr(UserPath, "##ARCH##");
        tmp2[0] = '\0';
        strcat(tmp2, tmp);
        }
    
    while (tmp = strstr(pathbuffer, "##BLD##"))
        {
        tmp2 = strstr(UserPath, "##BLD##") + strlen("##BLD##");
        tmp[0] = '\0';
        
        if ((Failure->BuildNumber()) == 0)
            Failure->SetBuildNumber(2195);
        
        _itoa(Failure->BuildNumber(), buff, 10);
        strcat(pathbuffer, buff);
        
        
        if (((Failure->SP()) == 0) && ((Failure->BuildDot()) > 0))
            {
            strcat(pathbuffer, ".");
            sprintf(buff, "%03u", Failure->BuildDot());
            strcat(pathbuffer, buff);
            }
        
        strcat(pathbuffer, tmp2);
        
        tmp2 = strstr(UserPath, "##BLD##");
        
        tmp2[0] = '\0';
        strcat(tmp2, tmp);
        }
    
    while (tmp = strstr(pathbuffer, "##SP##"))
        {
        tmp2 = strstr(UserPath, "##SP##") + strlen("##SP##");
        tmp[0] = '\0';
        
        if ((Failure->SP()) == 0)
            Failure->SetSP(2);
        
        _itoa(Failure->SP(), buff, 10);
        strcat(pathbuffer, buff);
        
        strcat(pathbuffer, tmp2);
        
        tmp2 = strstr(UserPath, "##SP##");
        
        tmp2[0] = '\0';
        strcat(tmp2, tmp);
        }
    
    while (tmp = strstr(pathbuffer, "##DOT##"))
        {
        tmp2 = strstr(UserPath, "##DOT##") + strlen("##DOT##");
        tmp[0] = '\0';
        
        sprintf(buff, "%03u", Failure->BuildDot());
        strcat(pathbuffer, buff);
        
        tmp2 = strstr(UserPath, "##DOT##");
        
        tmp2[0] = '\0';
        strcat(tmp2, tmp);
        }
    
    return _strdup(pathbuffer);
}

CHAR *GetKernelPath()
    {
    
    if ((Failure->VBL()) > 0)
        return GetVBLPath();
    else
        return GetStressPath();
    }

CHAR *GetSymbolsPath()
    {
    DWORD dwLength = 0;
    CHAR *pszUserPath = NULL;
    CHAR *pszSymSrvPath = NULL;
    CHAR *pszKernelPath = NULL;
    CHAR *FullPath = NULL;
    
    if ((Failure->DebuggerType()) == PROMPT_NTSD)
        {
        if (pszUserPath = GetUserPath())
            dwLength += (strlen(pszUserPath) + 1);
        
        if (StayLocal())
            return pszUserPath;
        }
    
    if (pszSymSrvPath = GetSymbolServerPath())
        dwLength += (strlen(pszSymSrvPath) + 1);
    
    if (pszKernelPath = GetKernelPath())
        dwLength += (strlen(pszKernelPath) + 1);
    
    
    if (FullPath = (CHAR *)malloc(dwLength))
        {
        FullPath[0] = '\0';
        
        if (pszUserPath != NULL)
            strcat(FullPath, pszUserPath);
        
        if (pszSymSrvPath != NULL)
            {
            if (pszUserPath != NULL)
                strcat(FullPath, ";");
            
            strcat(FullPath, pszSymSrvPath);
            }
        
        if (pszKernelPath != NULL)
            {
            if ((pszUserPath != NULL) || (pszSymSrvPath != NULL))
                strcat(FullPath, ";");
            
            strcat(FullPath, pszKernelPath);            
            }
        }
    
    SAFEFREE(pszUserPath);
    SAFEFREE(pszSymSrvPath);
    SAFEFREE(pszKernelPath);
    
    return (FullPath);
    }

#define PREAMBLE ".sympath "
BOOL FixSymbolPath()
    {
    DWORD dwLength = strlen(PREAMBLE) + 1;
    DWORD dwIterations = 0;
    CHAR *SymPath = NULL;
    CHAR *SymCommand = NULL;
    CHAR *Buffer = NULL;
    
    if (!Failure->SendCommand(".sympath\n", NULL))
        return FALSE;
    
    if (SymPath = GetSymbolsPath())
        {
        dwLength += (strlen(SymPath) + 1);
        if (SymCommand = (CHAR *)malloc(dwLength))
            {
            strcpy(SymCommand, PREAMBLE);
            strcat(SymCommand, SymPath);
            if (SymCommand[strlen(SymCommand) - 1] != '\n')
                strcat(SymCommand, "\n");
            
            SAFEFREE(SymPath);
            
            if (!Failure->SendCommand(SymCommand, &Buffer))
                {
                free(SymCommand);
                return FALSE;
                }
            
            SAFEFREE(SymCommand);
            
            while ((dwIterations < 3) && (strstr(Buffer, "WARNING:")) && (strstr(Buffer, "accessible")))
                {
                if ((Failure->DebuggerType()) == PROMPT_NTSD)
                    {   
                    if (!Failure->SendCommand(".sleep 5000\n", NULL))
                        return FALSE;
                    
                    SAFEFREE(Buffer);
                    if (!Failure->SendCommand(".sympath\n", &Buffer))
                        return FALSE;
                    
                    dwIterations++;
                    }
                else
                    break;
                }
            SAFEFREE(Buffer);
            }
        }
    
    return DoReload();
    }

//
// Determines weather the symbols on a machine are good or bad
//
BOOL GoodSymbols()
    {
    DWORD numLines = 0, i = 0;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD firstLine = 0;
    CHAR *buffer;
    BOOL done = TRUE;
    
    if (!Failure->SendCommand("lm l\n", &buffer))
        return FALSE;
    
    numLines = GetLinesFromString(buffer, LineHeads);
    
    for (i=0; i < numLines; i++)
        {
        if ((strstr(LineHeads[i], "(no symbolic information)"))||
            (strstr(LineHeads[i], "(export symbols)")))
            {
            free(buffer);
            return FALSE;
            }
        }
    
    free(buffer);
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\trisupp.cpp ===
#include <windows.h>
#include "stacks.h"
#include "triage.h"

Cfailure *Failure;
HANDLE ghMutex = NULL;
WCHAR *gOpReturnBuffer = NULL;
CHAR *gszReturnBuffer = NULL; 

//---------------------------------------------------------------------
// DllEntryPoint()
//---------------------------------------------------------------------
BOOL __cdecl DllMain(
                     HINSTANCE	  Instance,
                     DWORD		  Reason,
                     PVOID		  Reserved
                     )
    {
    switch(Reason)
        {
        case DLL_PROCESS_ATTACH:
            break;
            
        case DLL_PROCESS_DETACH:
            break;
            
        case DLL_THREAD_ATTACH:
            break;
            
        case DLL_THREAD_DETACH:
            break;
            
        default:
            break;
        }
    
    return(TRUE);
    }


CHAR *TriageEx(CHAR *Debugger, CHAR *Machine, DWORD dwFlags, CHAR *inifile)
    {
    CHAR *buffer = NULL;
    CHAR *LineHeads[MAXLINES] = {NULL, NULL};
    DWORD numLines = 0;
    CHAR Followup[128] = {0};
    DWORD FollowupSize = sizeof(Followup);
    
    Failure = new Cfailure;
    
    if ((Failure->Init(Debugger, 
        Machine, 
        (inifile == NULL) ? "triage.ini" : inifile, 
        dwFlags)) != ERROR_SUCCESS)
        goto exit;
    
    if ((Failure->FixSymbols()) == TRUE)
        FixSymbolPath();
    
    if (!Failure->SendStackCommand(NULL))
        goto exit;
    
    // if there was no reasonable failure type description
    if ((Failure->FailureType()) == FT_UNK) 
        {
        // lets see if a stack gives us a clue.
        Failure->SetFailureType(ScanStackForFailureType(Failure->StackBuffer()));
        
        if ((Failure->FailureType()) == FT_UNK)
            Failure->SetFailureType(GetProblemTitle());
        }
    
    // at this point we should;
    //	1. know the failure type - might still be unknown
    //	2. have good symbols 
    //	3. know the debugger type, architecture, build number, build type
    //	4. have no unbroken asserts
    //	5. Have verbose off
    //	6. Still have the original buffer saved
    
    switch(Failure->FailureType())
        {
        case FT_HIT_SHIFTF12:
        case FT_HIT_CTRL_C:
        case FT_HIT_SYSRQ:
            goto exit;
            break;
            
        case FT_SPARSE_FILE_CORRUPT:
        case FT_SYSCACHE_FAILURE:
            if ((Failure->FailureType()) == FT_SYSCACHE_FAILURE)
                GetSpecial("syscachefail", Followup, FollowupSize);
            else
                GetSpecial("sparsecorrupt", Followup, FollowupSize);
            Failure->SetFollowup(Followup);
            break;
            
        case FT_UNKNOWN_EXCEPTION:
        case FT_INPAGE_IO_ERROR:
            if (GetSpecial(Failure->Description(), Followup, FollowupSize))
                Failure->SetFollowup(Followup);    
            break;
            
        case FT_BUGCHECK:
            HandleBugCheck();
            break;
            
        case FT_WDM_BUGCHECK:
            HandleWDMBugCheck();
            break;
            
        case FT_ASSERTION_FAILURE:
            GetAssertDataFromStack(Failure->StackBuffer());
            break;
            
        case FT_UNH_EXCEPTION:
        case FT_UNH_EXCEPTION_SVCHOST:
        case FT_UNH_EXCEPTION_WINLOGON:
        case FT_LSA_TOP_LEVEL_EXCEPTION:
        case FT_UNH_EXCEPTION_SERVICES:
        case FT_UNH_EXCEPTION_CSRSS:
            {
            ULARGE_INTEGER exr = {0,0};
            ULARGE_INTEGER cxr = {0,0};
            
            if (GetEXRAndCXR(&exr, &cxr))
                {
                GetExceptionBuffer(exr, cxr);
                
                //DoEXR(exr);
                Failure->SendCXRStack(cxr);
                }
            else
                {
                CHAR Name[128];
                if (GetProcessName(Name))
                    {
                    Failure->SetDescription("Breakpoint in ");
                    Failure->AppendDescription(Name);
                    }
                
                }
            
            GetDeeperStacks();
            }
            break;
            
        case FT_RESOURCE_TIMEOUT:
            {
            DWORD thread = 0;
            
            if (GetResTimeoutThreadFromBuffer(&thread))
                {
                if (!Failure->SendBangThreadStack(thread))
                    break;
                }
            GetDeeperStacks();	
            }	
            break;
            
        case FT_CRITICAL_SECTION_TIMEOUT:
        case FT_POSSIBLE_DEADLOCK:
            {
            if (IsUserFailure())
                {
                DWORD Pid =0, OwnerTid = 0, UserThread = 0;
                if (GetCriticalSectionInfoFromBuffer(&Pid, &OwnerTid))
                    {
                    if (GetUserThreadId(Pid, OwnerTid, &UserThread))
                        Failure->SendUserThreadStack(UserThread);
                    }
                DoTilde();
                
                GetGPResUserStack();
                }	//Is user failure
            
            GetDeeperStacks();	
            }
            break;
            
        default:
            GetDeeperStacks();	
            break;
            
    }
    /*
    if (!Failure->IsStackAssigned())
        {
        if (DoSpecialCasesBasedOnStack(Followup, FollowupSize))
            Failure->SetFollowup(Followup);
        }
    */
    buffer = _strdup(Failure->StackBuffer());
    numLines = GetLinesFromString(buffer, LineHeads);
    StripStack(LineHeads, &numLines);
    Failure->SetStack(StoreStack(&(LineHeads[0]), numLines));
    /*
    if (!Failure->IsStackAssigned())
        {
        // get assigned based on the stack we currently have stored in buffer
        if (AssignStack(&(LineHeads[0]),
            (UINT) numLines, 
            Followup, FollowupSize))
            
            Failure->SetFollowup(Followup);
        }*/
exit:
        
        Failure->GetReturnBuffer(&gszReturnBuffer);
        
        SAFEFREE(buffer);
        
        delete(Failure);
        return(gszReturnBuffer);
}

__declspec( dllexport ) PCHAR TriageA(PCHAR Debugger, PCHAR Machine, DWORD dwFlags, PCHAR inifile)
    {
    if (!ghMutex)
        ghMutex = CreateMutex(NULL, TRUE, NULL);
    
    if (ghMutex)
        WaitForSingleObject(ghMutex, INFINITE);
    
    return TriageEx(Debugger, Machine, dwFlags, inifile);
    }

__declspec( dllexport ) PWCHAR TriageW(PWCHAR Debugger, PWCHAR Machine, DWORD dwFlags, PWCHAR inifile)
    {
    CHAR aDebugger[MAX_PATH];
    CHAR aMachine[MAX_PATH];
    CHAR *ainifile = NULL;
    CHAR *retbuf = NULL;
    
    if (!ghMutex)
        ghMutex = CreateMutex(NULL, TRUE, NULL);
    
    if (ghMutex)
        WaitForSingleObject(ghMutex, INFINITE);
    
    wcstombs(aDebugger, Debugger, MAX_PATH);
    wcstombs(aMachine, Machine, MAX_PATH);
    if (inifile)
        {
        ainifile = (CHAR *)malloc((wcslen(inifile) + 1));
        wcstombs(ainifile, inifile, (wcslen(inifile) + 1));
        }
    
    retbuf = TriageEx(aDebugger, aMachine, dwFlags, ainifile);
    
    gOpReturnBuffer = (WCHAR *)malloc((strlen(retbuf) + 1)*sizeof(WCHAR));
    
    if (gOpReturnBuffer)
        {
        mbstowcs(gOpReturnBuffer, retbuf, (strlen(retbuf) + 1));
        }
    
    SAFEFREE(ainifile);
    
    return gOpReturnBuffer;
    }


//extern "C"
__declspec( dllexport ) void TriageCleanup()
    {
    
    SAFEFREE(gszReturnBuffer);
    SAFEFREE(gOpReturnBuffer);
    
    if (ghMutex)
        ReleaseMutex(ghMutex);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\wintriage\mapistuff.h ===
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <malloc.h>
#include <mapi.h>	

BOOL SendOffFailure(HWND hWnd, TCHAR *pszToList, TCHAR *pszTitle, TCHAR *pszMessage);
DWORD CountRecips(PTCHAR pszToList);
BOOL GetLibraryPointers(HWND hWnd);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\utils.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "utils.h"

// Removes the lines in the lm output that have deferred in them.
// This isn't really necessary anymore because we have lm l but
// it doesnt hurt to leave it in here.
DWORD RemoveDeferred(CHAR **LineList)
    {
    DWORD i = 0, nextline = 0;
    
    for (i=0;i<MAXLINES;i++)
        {
        if (strstr(LineList[i], "(deferred)"))
            {
            LineList[i] = NULL;
            }
        }
    
    for (i=0;i<MAXLINES;i++)
        {
        if (LineList[i] != NULL)
            {
            LineList[nextline] = LineList[i];
            if (nextline != i)
                LineList[i] = NULL;
            nextline++;
            }
        }
    return nextline;
    }


// Takes a buffer and breaks it into lines.  Linelist is returned
// as a list of pointers into the buffer with each pointer being one line.
// This procedure has the side effect of changing the buffer.
DWORD GetLinesFromString(CHAR *theString, CHAR **LineList)
    {
    DWORD i=0;
    CHAR *p=theString;
    
    if (!LineList)
        return 0;
    
    if (p == NULL)
        {
        LineList[0] = NULL;
        return 0;
        }
    
    while ((p) && (*p)) 
        {
        LineList[i++] = p;
        
        p += strcspn(p, "\r\n");
        
        if (p && *p) 
            {
            *p = '\0';
            p++;
            if ((*p == '\r') || (*p == '\n')) 
                {
                p++;
                }
            }
        
        if (i == MAXLINES)
            {
            i = RemoveDeferred(LineList);
            if (i == MAXLINES)
                return i;
            }
        }
    
    return i;
    }

// Return a BOOL denoting whether the pointer is pointing at a Hex value
BOOL IsHex(CHAR *theStr)
    {
    DWORD x;
    return ((theStr) && 
        (*theStr) && 
        (strchr(theStr, ' ') >= theStr + 8) && 
        (0 != sscanf(theStr, "%x", &x)));
    }

// Case insensative strstr()
CHAR *stristr(const CHAR *s1, const CHAR *s2)
    {
    DWORD len1 = 0;
    DWORD len2 = 0;
    DWORD i = 0;
    CHAR *s1c = NULL;
    CHAR *s2c = NULL;
    CHAR *where = NULL;
    CHAR *retval = NULL;
    
    if ((s1 == NULL) || (s2 == NULL))
        return NULL;
    
    len1 = strlen(s1);
    len2 = strlen(s2);
    
    if (len2 > len1)
        return NULL;
    
    s1c = _strdup(s1);
    if (s1c == NULL)
        return NULL;
    
    s2c = _strdup(s2);
    if (s2c == NULL)
        return NULL;
    
    _strlwr(s1c);
    _strlwr(s2c);
    
    where = strstr(s1c, s2c);
    if (where != NULL)
        {
        retval = (CHAR *)(s1 + (where - s1c));
        }
    
    free(s1c);
    free(s2c);
    
    return retval;
    }



BOOL DynamicAppend(CHAR **ppBuffer, CHAR *AppendString)
    {
    CHAR *temp = NULL;
    
    if (!AppendString)
        return TRUE;
    
    if (!(*ppBuffer))
        {
        *ppBuffer = _strdup(AppendString);
        if (*ppBuffer)
            return TRUE;
        else
            return FALSE;
        }
    
    temp = (CHAR *) malloc((strlen(*ppBuffer) + strlen(AppendString) + 1) * sizeof(CHAR));
    if (!temp)
        return FALSE;
    
    strcpy(temp, *ppBuffer);
    strcat(temp, AppendString);
    
    free(*ppBuffer);
    
    *ppBuffer = temp;
    
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\trisupp\utils.h ===
#ifndef _UTILS_
	#define _UTILS_ 

#define MAXLINES (DWORD) 512

DWORD GetLinesFromString(CHAR *theString, CHAR **LineList);
BOOL IsHex(CHAR *theStr);
CHAR *stristr(const CHAR *s1, const CHAR *s2);
BOOL DynamicAppend(CHAR **ppBuffer, CHAR *AppendString);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\wintriage\wintriage.h ===
#define STRICT

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <process.h>
#include "resource.h"
#include "mapistuff.h"
#include <trisupp.h>

#define HEADER "This mail has been sent by WinTriage.  Please reply to the failure, or reassign as appropriate.\n\n"
#define ERROR_STRING_LENGTH 255
#define DEFAULT_REMOTE_LINES (DWORD)1000

HINSTANCE ghInstance;
HWND ghwndMain;

INT_PTR CALLBACK TriageDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID ErrorHandler(TCHAR *szCall, DWORD dwErrorCode);
DWORD WINAPI DoTriage(LPVOID lpParameter);
BOOL SetBoxesFromTextBuffer(HWND hWnd, PTCHAR TextBuffer);
BOOL DoRemote(HWND hWnd);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\wintriage\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wintriage.rc
//
#define IDR_MAINMENU                    102
#define IDR_ACCELERATOR                 103
#define ID_TRIAGE                       1000
#define ID_SENDMAIL                     1001
#define ID_REMOTE                       1002
#define ID_EXIT                         1003
#define ID_NOSYM                        1004
#define IDC_DEBUGGER_TXT                1010
#define IDC_DEBUGGEE_TXT                1011
#define IDC_TITLE_TXT                   1012
#define IDC_FOLLOWUP_TXT                1013
#define IDC_DEBUGGER_EDIT               1020
#define IDC_DEBUGGEE_EDIT               1021
#define IDC_TITLE_EDIT                  1022
#define IDC_STACK_EDIT                  1023
#define IDC_FOLLOWUP_EDIT               1024
#define ID_FILE_EXIT                    40001
#define ID_MAIL_SENDFAILUREMAIL         40002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        108
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\wintriage\mapistuff.c ===
#include "mapistuff.h"

ULONG (FAR PASCAL *lpfnMAPILogon)(ULONG_PTR, LPSTR, LPSTR, FLAGS, ULONG, LPLHANDLE);
ULONG (PASCAL *lpfnMAPISendMail)(ULONG, ULONG_PTR, MapiMessage*, FLAGS, ULONG);
ULONG (PASCAL *lpfnMAPIResolveName)(LHANDLE, ULONG_PTR, LPTSTR, FLAGS, ULONG, MapiRecipDesc **);
ULONG (FAR PASCAL *lpfnMAPILogoff)(LHANDLE, ULONG_PTR, FLAGS, ULONG);
ULONG (FAR PASCAL *lpfnMAPIFreeBuffer)(LPVOID);
HINSTANCE hInstMapi = NULL;

BOOL SendOffFailure(HWND hWnd, TCHAR *pszToList, TCHAR *pszTitle, TCHAR *pszMessage)
{
	LHANDLE lhSession;
	ULONG lResult = 0;
	MapiMessage mmmessage;
	lpMapiRecipDesc rdList = NULL;
	DWORD i = 0;

	memset(&mmmessage, 0, sizeof(mmmessage));

	// Set up procedure pointers
	if (!GetLibraryPointers(hWnd))
		return FALSE;

	// Log on to existing session
	lResult = lpfnMAPILogon(0, NULL, NULL, 0, 0, &lhSession);
	if (lResult != SUCCESS_SUCCESS)
	{
		// We need outlook up and running to send mail
		// Maybe I write the code to do the connect when I get some time
		MessageBox(hWnd, 
					TEXT("Unable to Logon to an existing MAPI session.  Make sure you have Outlook started!!!"), 
					TEXT("Send Mail Error!"), 
					MB_OK|MB_ICONERROR);
		FreeLibrary(hInstMapi);
		return FALSE;
	}

	mmmessage.ulReserved = 0;
	mmmessage.lpszMessageType = NULL;
	mmmessage.lpszSubject = pszTitle;
	mmmessage.lpszNoteText = pszMessage;
	mmmessage.flFlags = MAPI_SENT;
	mmmessage.lpOriginator = NULL;
	mmmessage.nFileCount = 0;

	mmmessage.nRecipCount = CountRecips(pszToList);
	if (mmmessage.nRecipCount == 0)
	{
		MessageBox(hWnd, 
					TEXT("No Valid Names where specifed!!!"), 
					TEXT("Send Mail Failure!"), 
					MB_OK|MB_ICONERROR);
		lpfnMAPILogoff(0, lhSession, 0, 0);
		FreeLibrary(hInstMapi);
		return FALSE;
	}
	else if (mmmessage.nRecipCount == 1)
	{
		lResult = lpfnMAPIResolveName(lhSession,
										0,
										pszToList,
										0,
										0,
										&mmmessage.lpRecips);
		if (lResult != SUCCESS_SUCCESS)
		{
			TCHAR ErrorString[256];
			sprintf(ErrorString, "Unable to Resolve Names properly!!! Got 0x%08x", lResult);
			MessageBox(hWnd, 
						ErrorString, 
						TEXT("Fatal Error!"), 
						MB_OK|MB_ICONERROR);
			lpfnMAPILogoff(0, lhSession, 0, 0);
			FreeLibrary(hInstMapi);
			return FALSE;
		}
	}
	else
	{
		TCHAR *token = NULL;
		DWORD index = 0;

		rdList = (lpMapiRecipDesc) calloc(mmmessage.nRecipCount, sizeof (MapiRecipDesc));
		if (!rdList)
		{
			MessageBox(hWnd, 
						TEXT("Unable to allocate memory for names!!!"), 
						TEXT("Fatal Error!"), 
						MB_OK|MB_ICONERROR);
			lpfnMAPILogoff(0, lhSession, 0, 0);
			FreeLibrary(hInstMapi);
			return FALSE;
		}

		
		token = _tcstok(pszToList, _T(";"));
		while( token != NULL )
		{
			lResult = lpfnMAPIResolveName(lhSession,
											0,
											token,
											0,
											0,
											&mmmessage.lpRecips);
			if (lResult != SUCCESS_SUCCESS)
			{
				TCHAR BadNames[MAX_PATH];

				_stprintf(BadNames, _T("Unable to resolve %s properly! Failing Send"), token);

				MessageBox(hWnd, 
							BadNames, 
							TEXT("Name Resolution Error"), 
							MB_OK|MB_ICONERROR);
				
				lpfnMAPILogoff(0, lhSession, 0, 0);
				FreeLibrary(hInstMapi);
				for (i = 0; i < mmmessage.nRecipCount; i++)
				{
					if (rdList[i].lpEntryID)
						free(rdList[i].lpEntryID);
					if (rdList[i].lpszAddress)
						free(rdList[i].lpszAddress);
					if (rdList[i].lpszName)
						free(rdList[i].lpszName);
				}
				free(rdList);
				return FALSE;
			}
			else
			{
				if (mmmessage.lpRecips->lpEntryID)
				{
					rdList[index].lpEntryID = malloc(mmmessage.lpRecips->ulEIDSize);
					if (!rdList[index].lpEntryID)
					{
						MessageBox(hWnd, 
									TEXT("Unable to allocate memory for lpEntryID"), 
									TEXT("Memory Allocation Error"), 
									MB_OK|MB_ICONERROR);

						lpfnMAPILogoff(0, lhSession, 0, 0);
						FreeLibrary(hInstMapi);
						free(rdList);
						return FALSE;
					}
					memcpy(rdList[index].lpEntryID, mmmessage.lpRecips->lpEntryID, mmmessage.lpRecips->ulEIDSize);
				}

				if (mmmessage.lpRecips->lpszAddress)
				{
					rdList[index].lpszAddress = _tcsdup(mmmessage.lpRecips->lpszAddress);
					if (!rdList[index].lpszAddress)
					{
						MessageBox(hWnd, 
									TEXT("Unable to allocate memory for lpszAddress"), 
									TEXT("Memory Allocation Error"), 
									MB_OK|MB_ICONERROR);

						lpfnMAPILogoff(0, lhSession, 0, 0);
						FreeLibrary(hInstMapi);
						for (i = 0; i < mmmessage.nRecipCount; i++)
						{
							if (rdList[i].lpEntryID)
								free(rdList[i].lpEntryID);
							if (rdList[i].lpszAddress)
								free(rdList[i].lpszAddress);
							if (rdList[i].lpszName)
								free(rdList[i].lpszName);
						}
						free(rdList);
						return FALSE;
					}
				}

				if (mmmessage.lpRecips->lpszName)
				{
					rdList[index].lpszName = _tcsdup(mmmessage.lpRecips->lpszName);
					if (!rdList[index].lpszName)
					{
						MessageBox(hWnd, 
									TEXT("Unable to allocate memory for lpszName"), 
									TEXT("Memory Allocation Error"), 
									MB_OK|MB_ICONERROR);

						lpfnMAPILogoff(0, lhSession, 0, 0);
						FreeLibrary(hInstMapi);
						for (i = 0; i < mmmessage.nRecipCount; i++)
						{
							if (rdList[i].lpEntryID)
								free(rdList[i].lpEntryID);
							if (rdList[i].lpszAddress)
								free(rdList[i].lpszAddress);
							if (rdList[i].lpszName)
								free(rdList[i].lpszName);
						}
						free(rdList);
						return FALSE;
					}
				}

				rdList[index].ulEIDSize = mmmessage.lpRecips->ulEIDSize;
				rdList[index].ulRecipClass = MAPI_TO;
				rdList[index].ulReserved = mmmessage.lpRecips->ulReserved;
				lpfnMAPIFreeBuffer(mmmessage.lpRecips);
			}

			index++;			
			token = _tcstok(NULL, _T(";"));
		}

		mmmessage.lpRecips = rdList;		
	}

	// Send the message
	lResult = lpfnMAPISendMail(0, 0, &mmmessage, 0, 0);

	// Cleanup
	lpfnMAPILogoff(0, lhSession, 0, 0);

	if (mmmessage.nRecipCount == 1)
		lpfnMAPIFreeBuffer(mmmessage.lpRecips);
	else
	{
		for (i = 0; i < mmmessage.nRecipCount; i++)
		{
			if (rdList[i].lpEntryID)
				free(rdList[i].lpEntryID);
			if (rdList[i].lpszAddress)
				free(rdList[i].lpszAddress);
			if (rdList[i].lpszName)
				free(rdList[i].lpszName);
		}
		free(rdList);
	}

	FreeLibrary(hInstMapi);

	if (lResult != SUCCESS_SUCCESS)
	{
		MessageBox(hWnd, 
					TEXT("SendMail Failed!!!"), 
					TEXT("Fatal Error!"), 
					MB_OK|MB_ICONERROR);
		return FALSE;
	}
	else
    {  
		MessageBox(hWnd, 
					TEXT("Your Mail was sent successfully."), 
					TEXT("Mail Send Successful"), 
					MB_OK);
		return TRUE;
    }

}

BOOL GetLibraryPointers(HWND hWnd)
{

	hInstMapi = LoadLibrary("Mapi32.dll");
	if(hInstMapi == NULL)
	{
		MessageBox(hWnd, 
					TEXT("Unable to Load MAPI32.dll!!!"), 
					TEXT("Fatal Error!"), 
					MB_OK|MB_ICONERROR);
		return FALSE;
	}

	// Find the addresses of functions 
	(FARPROC)lpfnMAPILogon = GetProcAddress(hInstMapi, "MAPILogon");
	if (lpfnMAPILogon == NULL)
	{
		MessageBox(hWnd, 
					TEXT("Unable to find function MAPILogon!!!"), 
					TEXT("Fatal Error!"), 
					MB_OK|MB_ICONERROR);
		FreeLibrary(hInstMapi);
		return FALSE;
	}
	
		(FARPROC)lpfnMAPILogoff = GetProcAddress(hInstMapi, "MAPILogoff");
	if (lpfnMAPILogoff == NULL)
	{
		MessageBox(hWnd, 
					TEXT("Unable to find function MAPILogoff!!!"), 
					TEXT("Fatal Error!"), 
					MB_OK|MB_ICONERROR);
		FreeLibrary(hInstMapi);
		return FALSE;
	}

	(FARPROC)lpfnMAPIFreeBuffer = GetProcAddress(hInstMapi, "MAPIFreeBuffer");
	if (lpfnMAPIFreeBuffer == NULL)
	{
		MessageBox(hWnd, 
					TEXT("Unable to find function MAPIFreeBuffer!!!"), 
					TEXT("Fatal Error!"), 
					MB_OK|MB_ICONERROR);
		FreeLibrary(hInstMapi);
		return FALSE;
	}

	(FARPROC)lpfnMAPIResolveName = GetProcAddress(hInstMapi, "MAPIResolveName");
	if (lpfnMAPIResolveName == NULL)
	{
		MessageBox(hWnd, 
					TEXT("Unable to find function MAPIResolveName!!!"), 
					TEXT("Fatal Error!"), 
					MB_OK|MB_ICONERROR);
		FreeLibrary(hInstMapi);
		return FALSE;
	} 

	(FARPROC)lpfnMAPISendMail = GetProcAddress(hInstMapi, "MAPISendMail");
	if (lpfnMAPISendMail == NULL)
	{
		MessageBox(hWnd, 
					TEXT("Unable to find function MAPIResolveName!!!"), 
					TEXT("Fatal Error!"), 
					MB_OK|MB_ICONERROR);
		FreeLibrary(hInstMapi);
		return FALSE;
	}

	return TRUE;	
}

DWORD CountRecips(PTCHAR pszToList)
{
	DWORD i = 0;
	PTCHAR ptr = pszToList;

	if ((!ptr)||(ptr[0] == TEXT('\0')))
		return 0;

	ptr = pszToList + _tcslen(pszToList) - 1;
	// rear trim
	while ((ptr >= pszToList)&&((ptr[0] == TEXT(';'))||(ptr[0] == TEXT(' '))||
			(ptr[0] == TEXT('/r'))||(ptr[0] == TEXT('/n'))||
			(ptr[0] == TEXT('/t'))||(ptr[0] == TEXT(':'))))
	{
		ptr[0] = TEXT('\0');
		ptr--;
	}

	ptr = pszToList;
	// front trim
	while ((ptr[0] == TEXT(';'))||(ptr[0] == TEXT(' '))||
			(ptr[0] == TEXT('/r'))||(ptr[0] == TEXT('/n'))||
			(ptr[0] == TEXT('/t'))||(ptr[0] == TEXT(':')))
		_tcscpy(ptr, ptr + 1);

	// remove spaces
	while (ptr = _tcschr(pszToList, TEXT(' ')))
		_tcscpy(ptr, ptr + 1);

	ptr = pszToList;
	while (ptr = _tcschr(ptr, TEXT(';')))
	{
		i++;
		ptr++;
	}

	if (!_tcslen(pszToList))
		return 0;

	return i + 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labmon\triage\wintriage\wintriage.c ===
#include "wintriage.h"

VOID ErrorHandler(TCHAR *szCall, 
				  DWORD dwErrorCode)
{
	TCHAR szErrString[ERROR_STRING_LENGTH];

	_stprintf(szErrString, TEXT("%s Failed with %d\n"), szCall, dwErrorCode);

	MessageBox(NULL, szErrString, TEXT("Fatal Error!"), MB_OK|MB_ICONERROR);
}


int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
	MSG msg;
	HACCEL hAccel;

	ghInstance = hInstance;

    if (!(ghwndMain = CreateDialog(ghInstance, 
                       MAKEINTRESOURCE(100), 
                       NULL, 
                       TriageDlgProc)))
	{
		ErrorHandler(TEXT("CreateDialog"), GetLastError());
		return GetLastError();
	}

    // Load the accelerator table resource
	if (!(hAccel = LoadAccelerators(ghInstance, 
							MAKEINTRESOURCE(IDR_ACCELERATOR))))
	{
		ErrorHandler(TEXT("LoadAccelerators"), GetLastError());
		return GetLastError();
	}

    while (GetMessage(&msg, NULL, 0, 0)) 
    {
        if ((ghwndMain == 0) ||(!IsDialogMessage(ghwndMain, &msg)))
        {
            if (!TranslateAccelerator(ghwndMain, hAccel, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
	
    return (int) msg.wParam;
}

INT_PTR CALLBACK TriageDlgProc(HWND hWnd,  // handle to dialog box
                               UINT uMsg,     // message
                               WPARAM wParam, // first message parameter
                               LPARAM lParam)  // second message parameter
{
	switch(uMsg)
	{
       	case WM_CLOSE:
			TriageCleanup();
			DestroyWindow(hWnd);	// Generates a WM_DESTROY
			return FALSE;
			break;

		case WM_DESTROY:
			PostQuitMessage(0);
			return FALSE;
			break;

        case WM_INITDIALOG:
            SendMessage(GetDlgItem(hWnd, ID_NOSYM), BM_SETCHECK, 1, 0);
            return FALSE;
            break;

		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
			case ID_EXIT:
			case ID_FILE_EXIT:
				SendMessage(hWnd, WM_CLOSE, (WPARAM)0, (LPARAM)0);
				return TRUE;
				break;
			
			case ID_SENDMAIL:
			case ID_MAIL_SENDFAILUREMAIL:
				{
					PTCHAR pszFollowup = NULL;
					PTCHAR pszTitle = NULL;
                    PTCHAR pszBody = NULL;
					DWORD dwFollowup = 0, dwTitle = 0, dwBody = 0;

					// Get the followup string                          
					if (dwFollowup = GetWindowTextLength(GetDlgItem(hWnd, IDC_FOLLOWUP_EDIT)))
					{
						if (!(pszFollowup = malloc((dwFollowup + 1) * sizeof(TCHAR))))
						{
							MessageBox(ghwndMain, 
										TEXT("Malloc Failed to Allocate Memory for Followup!"),
										TEXT("Can Not Send Mail!"), 
										MB_OK|MB_ICONEXCLAMATION);
							return TRUE;
						}

						GetWindowText(GetDlgItem(hWnd, IDC_FOLLOWUP_EDIT),
										pszFollowup,
										dwFollowup + 1);
					
						if (_tcsstr(_tcslwr(pszFollowup), TEXT("machine owner")))
						{
							free(pszFollowup);
							MessageBox(ghwndMain, 
										TEXT("Can't send mail to Machine Owner!"),
										TEXT("Can Not Send Mail!"), 
										MB_OK|MB_ICONEXCLAMATION);
							return TRUE;
						}

					}
					else
					{
							MessageBox(ghwndMain, 
										TEXT("There are no followups specified!"),
										TEXT("Can Not Send Mail!"), 
										MB_OK|MB_ICONEXCLAMATION);
							return TRUE;
					}

					// Get the body string
					if ((dwBody = GetWindowTextLength(GetDlgItem(hWnd, IDC_STACK_EDIT))))
					{
						dwBody += (_tcslen(HEADER) + 2); // 2 /n/n
						dwBody += (_tcslen(TEXT("Remote /c ")) + 3);  //space between names and 2 \n
						dwBody += GetWindowTextLength(GetDlgItem(hWnd, IDC_DEBUGGER_EDIT));
						dwBody += GetWindowTextLength(GetDlgItem(hWnd, IDC_DEBUGGEE_EDIT));
						dwBody += (_tcslen(TEXT("\nFollowup: ")) + 2);  //space between names and 2 \n
						dwBody += GetWindowTextLength(GetDlgItem(hWnd, IDC_FOLLOWUP_EDIT));

						if (!(pszBody = malloc((dwBody + 1) * sizeof(TCHAR))))
						{
							MessageBox(ghwndMain, 
										TEXT("Malloc Failed to Allocate Memory for Stack Trace!"),
										TEXT("Can Not Send Mail!"), 
										MB_OK|MB_ICONEXCLAMATION);
							if (pszFollowup)
								free(pszFollowup);
							return TRUE;
						}

						_tcscpy(pszBody, HEADER);
						_tcscat(pszBody, TEXT("Remote /c "));

						GetWindowText(GetDlgItem(hWnd, IDC_DEBUGGER_EDIT),
										pszBody + _tcslen(pszBody),
										dwBody + 1 - _tcslen(pszBody));
						
						_tcscat(pszBody, TEXT(" "));

						GetWindowText(GetDlgItem(hWnd, IDC_DEBUGGEE_EDIT),
										pszBody + _tcslen(pszBody),
										dwBody + 1 - _tcslen(pszBody));

						_tcscat(pszBody, TEXT("\n\n"));

						GetWindowText(GetDlgItem(hWnd, IDC_STACK_EDIT),
										pszBody + _tcslen(pszBody),
										dwBody + 1 - _tcslen(pszBody));

						_tcscat(pszBody, TEXT("\nFollowup: "));

						GetWindowText(GetDlgItem(hWnd, IDC_FOLLOWUP_EDIT),
										pszBody + _tcslen(pszBody),
										dwBody + 1 - _tcslen(pszBody));

						_tcscat(pszBody, TEXT("\n\n"));

					}
					
					// Get the title string
					if ((dwTitle = GetWindowTextLength(GetDlgItem(hWnd, IDC_TITLE_EDIT))))
					{
						dwTitle += _tcslen(TEXT("WINTRIAGE:"));
						if (!(pszTitle = malloc((dwTitle + 1) * sizeof(TCHAR))))
						{
							MessageBox(ghwndMain, 
										TEXT("Malloc Failed to Allocate Memory for Title!"),
										TEXT("Can Not Send Mail!"), 
										MB_OK|MB_ICONEXCLAMATION);
							if (pszFollowup)
								free(pszFollowup);
							if (pszBody)
								free(pszBody);
							return TRUE;
						}

						_tcscpy(pszTitle, TEXT("WINTRIAGE:"));
						GetWindowText(GetDlgItem(hWnd, IDC_TITLE_EDIT),
										pszTitle + _tcslen(pszTitle),
										dwTitle + 1 - _tcslen(pszTitle));
					}

					SendOffFailure(hWnd, pszFollowup, pszTitle, pszBody);
					if (pszFollowup)
						free(pszFollowup);
					if (pszBody)
						free(pszBody);
					if (pszTitle)
						free(pszTitle);
					return TRUE;
				}
				break;

			case ID_REMOTE:
				DoRemote(hWnd);
				return TRUE;
				break;
						
			case ID_TRIAGE:
				{
					HANDLE hThread = INVALID_HANDLE_VALUE;
					DWORD dwTID = 0;

					//Make sure debugger and debuggee are specifed
					if (!(GetWindowTextLength(GetDlgItem(hWnd, IDC_DEBUGGER_EDIT))))
					{
						MessageBox(ghwndMain, 
									TEXT("You Must Supply a Debugger Name"),
									TEXT("Can Not Triage!"), 
									MB_OK|MB_ICONEXCLAMATION);

						SetFocus(GetDlgItem(hWnd, IDC_DEBUGGER_EDIT));
						return TRUE;
					}

					if (!(GetWindowTextLength(GetDlgItem(hWnd, IDC_DEBUGGEE_EDIT))))
					{
						MessageBox(ghwndMain, 
									TEXT("You Must Supply a Debuggee Name"),
									TEXT("Can Not Triage!"), 
									MB_OK|MB_ICONEXCLAMATION);
						SetFocus(GetDlgItem(hWnd, IDC_DEBUGGEE_EDIT));
						return TRUE;					}

					SetWindowText(GetDlgItem(hWnd, IDC_FOLLOWUP_EDIT), TEXT(""));
					SetWindowText(GetDlgItem(hWnd, IDC_TITLE_EDIT), TEXT(""));
					SetWindowText(GetDlgItem(hWnd, IDC_STACK_EDIT), TEXT(""));

					hThread = CreateThread(NULL,
											0,
											(LPTHREAD_START_ROUTINE)DoTriage,
											(LPVOID)hWnd,
											0,
											&dwTID);

					if (hThread == INVALID_HANDLE_VALUE)
					{
						ErrorHandler(TEXT("Triage Command - CreateThread"), 
									GetLastError());
					}
					else
						CloseHandle(hThread);
					
					return TRUE;
					break;
				}
			case IDC_DEBUGGER_EDIT:
				switch (HIWORD(wParam))
				{
				case EN_CHANGE:
					SetWindowText(GetDlgItem(hWnd, IDC_FOLLOWUP_EDIT), TEXT(""));
					SetWindowText(GetDlgItem(hWnd, IDC_TITLE_EDIT), TEXT(""));
					SetWindowText(GetDlgItem(hWnd, IDC_STACK_EDIT), TEXT(""));
					EnableWindow(GetDlgItem(hWnd, ID_SENDMAIL), FALSE);
                    EnableMenuItem(GetMenu(hWnd), ID_MAIL_SENDFAILUREMAIL, MF_GRAYED);

					if ((GetWindowTextLength(GetDlgItem(hWnd, IDC_DEBUGGER_EDIT)))&&
							(GetWindowTextLength(GetDlgItem(hWnd, IDC_DEBUGGEE_EDIT))))
					{
						EnableWindow(GetDlgItem(hWnd, ID_TRIAGE), TRUE);
						EnableWindow(GetDlgItem(hWnd, ID_REMOTE), TRUE);
					}
					else
					{
						EnableWindow(GetDlgItem(hWnd, ID_TRIAGE), FALSE);
						EnableWindow(GetDlgItem(hWnd, ID_REMOTE), FALSE);
					}
					return TRUE;
					break;

				}
				break;

			case IDC_DEBUGGEE_EDIT:
				switch (HIWORD(wParam))
				{
				case EN_CHANGE:	
					SetWindowText(GetDlgItem(hWnd, IDC_FOLLOWUP_EDIT), TEXT(""));
					SetWindowText(GetDlgItem(hWnd, IDC_TITLE_EDIT), TEXT(""));
					SetWindowText(GetDlgItem(hWnd, IDC_STACK_EDIT), TEXT(""));
					EnableWindow(GetDlgItem(hWnd, ID_SENDMAIL), FALSE);
                    EnableMenuItem(GetMenu(hWnd), ID_MAIL_SENDFAILUREMAIL, MF_GRAYED);
					
                    if ((GetWindowTextLength(GetDlgItem(hWnd, IDC_DEBUGGER_EDIT)))&&
							(GetWindowTextLength(GetDlgItem(hWnd, IDC_DEBUGGEE_EDIT))))
					{
						EnableWindow(GetDlgItem(hWnd, ID_TRIAGE), TRUE);
						EnableWindow(GetDlgItem(hWnd, ID_REMOTE), TRUE);
					}
					else
					{
						EnableWindow(GetDlgItem(hWnd, ID_TRIAGE), FALSE);
						EnableWindow(GetDlgItem(hWnd, ID_REMOTE), FALSE);
					}
					return TRUE;
					break;

				}
				break;

			}
			break;
	}
    return FALSE;
}


DWORD WINAPI DoTriage(LPVOID lpParameter)
{
	DWORD	dwDebuggerLength = 0;
	DWORD	dwDebuggeeLength = 0;
	PTCHAR	pszDebugger = NULL;
	PTCHAR	pszDebuggee = NULL;
	PTCHAR	TextBuffer = NULL;
	DWORD	dwFlags = 0;
	HWND	hWnd = (HWND) lpParameter;

	//Get the String Lengths
	(INT) dwDebuggerLength = GetWindowTextLength(GetDlgItem(hWnd, IDC_DEBUGGER_EDIT));
	(INT) dwDebuggeeLength = GetWindowTextLength(GetDlgItem(hWnd, IDC_DEBUGGEE_EDIT));

	// Allocate the memory
	if (!(pszDebugger = malloc((dwDebuggerLength + 1) * sizeof(TCHAR))))
	{
		MessageBox(ghwndMain, TEXT("Malloc Failed to Allocate Memory!"),
				TEXT("Can Not Triage!"), MB_OK|MB_ICONEXCLAMATION);
		return FALSE;
	}
	
	if (!(pszDebuggee = malloc((dwDebuggeeLength + 1) * sizeof(TCHAR))))
	{
		MessageBox(ghwndMain, TEXT("Malloc Failed to Allocate Memory!"),
				TEXT("Can Not Triage!"), MB_OK|MB_ICONEXCLAMATION);
		free(pszDebugger);
		return FALSE;
	}

	// Make sure the buttons are disabled
	EnableWindow(GetDlgItem(hWnd, ID_TRIAGE), FALSE);
	EnableWindow(GetDlgItem(hWnd, ID_SENDMAIL), FALSE);

	// Do we need to disable symbol fixing
	if (SendMessage(GetDlgItem(hWnd, ID_NOSYM),
					BM_GETSTATE,
					(WPARAM)0,
					(LPARAM)0) == BST_UNCHECKED)
		dwFlags = dwFlags | FLAG_NO_SYMBOLS;

	// Get the actual strings
	GetWindowText(GetDlgItem(hWnd, IDC_DEBUGGER_EDIT),
				pszDebugger,
				dwDebuggerLength + 1);


	GetWindowText(GetDlgItem(hWnd, IDC_DEBUGGEE_EDIT),
				pszDebuggee,
				dwDebuggeeLength + 1);

	// Triage the failure
	TextBuffer = Triage(pszDebugger,
						pszDebuggee,
						dwFlags, 
						NULL);

	SetBoxesFromTextBuffer(lpParameter, TextBuffer);
	
	EnableWindow(GetDlgItem(hWnd, ID_SENDMAIL), TRUE);
	EnableMenuItem(GetMenu(hWnd), ID_MAIL_SENDFAILUREMAIL, MF_ENABLED);
	EnableWindow(GetDlgItem(hWnd, ID_TRIAGE), TRUE);

	TriageCleanup();
	free(pszDebugger);
	free(pszDebuggee);

	return TRUE;
}

BOOL SetBoxesFromTextBuffer(HWND hWnd, PTCHAR TextBuffer)
{
	PTCHAR ptr1 = NULL, ptr2 = NULL;
	DWORD BufferLen = (_tcslen(TextBuffer) + 1);

	TCHAR *temp = malloc((_tcslen(TextBuffer) + 1) * sizeof(TCHAR));

	ptr1 = _tcsstr(TextBuffer, TEXT("FOLLOWUP:"));

	if (ptr1)
	{
		// Clean up the crap in the followup string
		while ((ptr2 = _tcschr(ptr1, TEXT('\r')))||
				(ptr2 = _tcschr(ptr1, TEXT('\n')))||
				(ptr2 = _tcschr(ptr1, TEXT('\t'))))
		{
			ptr2[0] = TEXT('\0');
		}

		ptr2 = ptr1 + 1 + _tcslen(TEXT("FOLLOWUP:"));

		SetWindowText(GetDlgItem(hWnd, IDC_FOLLOWUP_EDIT),
						ptr2);
		ptr1[0] = TEXT('\0');
		
		// Clean any trailing crap while we are here
		while ((*(ptr1 - 1) == TEXT('\r'))||
				(*(ptr1 - 1) == TEXT('\n'))||
				(*(ptr1 - 1) == TEXT('\t')))
		{
			*(ptr1 - 1) = TEXT('\0');
			ptr1--;
		}
	}

	ptr1 = _tcschr(TextBuffer, TEXT('\n'));
	if (ptr1)
	{
		ptr1[0] = TEXT('\0');
	}

	SetWindowText(GetDlgItem(hWnd, IDC_TITLE_EDIT),
				TextBuffer);


	if (ptr1)
	{
		while ((*(ptr1 + 1) == TEXT('\r'))||
			(*(ptr1 + 1) == TEXT('\n'))||
			(*(ptr1 + 1) == TEXT('\t')))
			ptr1++;

		ptr1++;
		_tcscpy(TextBuffer, ptr1);

		// Royal Hack
		BufferLen -= (_tcslen(TextBuffer) + 1);
		_tcscpy(temp, TextBuffer);
		TextBuffer[0] = TEXT('\0');
		ptr2 = temp;

		ptr1 = _tcschr(ptr2, TEXT('\n'));

		while ((ptr1)&&(BufferLen > 1)&&(temp))
		{
			ptr1[0] = TEXT('\0');
			_tcscat(TextBuffer, ptr2);
			_tcscat(TextBuffer, TEXT("\r\n"));

			ptr2 = ptr1 + 1;
			ptr1 = _tcschr(ptr2, TEXT('\n'));
			BufferLen--;
		}
		_tcscat(TextBuffer, ptr2);
		_tcscat(TextBuffer, TEXT("\r\n"));

		SetWindowText(GetDlgItem(hWnd, IDC_STACK_EDIT),
						TextBuffer);
	}
	
	if (temp)
		free(temp);

	return TRUE;
}


BOOL DoRemote(HWND hWnd)
{
	DWORD	dwDebuggerLength = 0;
	DWORD	dwDebuggeeLength = 0;
	PTCHAR	pszDebugger = NULL;
	PTCHAR	pszDebuggee = NULL;
	TCHAR	szRemoteLines[10];

	//Get the String Lengths
	if (!((INT) dwDebuggerLength = GetWindowTextLength(GetDlgItem(hWnd, IDC_DEBUGGER_EDIT))))
	{
		MessageBox(ghwndMain, TEXT("You Must Supply a Debugger Name"),
				TEXT("Can Not Remote!"), MB_OK|MB_ICONEXCLAMATION);
		SetFocus(GetDlgItem(hWnd, IDC_DEBUGGER_EDIT));
		return FALSE;
	}

	if (!((INT) dwDebuggeeLength = GetWindowTextLength(GetDlgItem(hWnd, IDC_DEBUGGEE_EDIT))))
	{
		MessageBox(ghwndMain, TEXT("You Must Supply a Debuggee Name"),
				TEXT("Can Not Remote!"), MB_OK|MB_ICONEXCLAMATION);
		SetFocus(GetDlgItem(hWnd, IDC_DEBUGGEE_EDIT));
		return FALSE;
	}

	// Allocate the memory
	if (!(pszDebugger = malloc((dwDebuggerLength + 1) * sizeof(TCHAR))))
	{
		MessageBox(ghwndMain, TEXT("Malloc Failed to Allocate Memory!"),
				TEXT("Can Not Remote!"), MB_OK|MB_ICONEXCLAMATION);
		return FALSE;
	}
	
	if (!(pszDebuggee = malloc((dwDebuggeeLength + 1) * sizeof(TCHAR))))
	{
		MessageBox(ghwndMain, TEXT("Malloc Failed to Allocate Memory!"),
				TEXT("Can Not Remote!"), MB_OK|MB_ICONEXCLAMATION);
		free(pszDebugger);
		return FALSE;
	}

	// Get the actual strings
	GetWindowText(GetDlgItem(hWnd, IDC_DEBUGGER_EDIT),
				pszDebugger,
				dwDebuggerLength + 1);


	GetWindowText(GetDlgItem(hWnd, IDC_DEBUGGEE_EDIT),
				pszDebuggee,
				dwDebuggeeLength + 1);

	//Eventually this will come from the registry.
	_stprintf(szRemoteLines, TEXT("%u"), DEFAULT_REMOTE_LINES);

	// Spawn the remote process
	_tspawnlp(_P_NOWAIT, TEXT("cmd"), TEXT("/K"), 
		TEXT("remote"), TEXT("/C"), pszDebugger, pszDebuggee, TEXT("/L"), szRemoteLines, NULL);

	free(pszDebugger);
	free(pszDebuggee);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labpusher\pcclient\pcclient.h ===
/*************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

	pcclient.h

  Abstract:

	Defines the PC client side for the LabPusher tool

  Author:

	Mabel Santos (t-msanto) 03-Dec-2001

  Revision History:

*************************************************************************************************/

#ifndef _PCCLIENT_H_
#define _PCCLIENT_H_

#define NTLEANANDMEAN
#define _X86_
#define _WIN32_WINNT 0x0500

#include <windows.h>
#include <winsock2.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdio.h>
#include <stdarg.h>
#include <xboxdbg.h>

#define BUFFLEN 1024

// network packet structures

struct FilePacketHeader
{
	unsigned char PacketType;
	unsigned long SequenceNo;
	unsigned long FileSize;
	unsigned short DataSize;
	unsigned long Crc;
};

struct FilePacket : public FilePacketHeader
{
	char Data[BUFFLEN];
};

struct Xbox
{
	char Name[BUFFLEN];
	int State;
	int Thread;
	Xbox* Next;
};

class PcClient
{
private:
	
	// list of Xboxes
	Xbox* XboxList;
	Xbox* LastXbox;
	
	// socket for network communication
	SOCKET ClientSock;

	// flag to indicate whether WinSock has been initialized
	BOOL WsaInitialized;

	// byte counter
	unsigned long ByteCount;

	// packet counter
	unsigned long PacketCount;

public:
	PcClient(void);
	~PcClient(void);
	BOOL PrepareWinSock(void);
	BOOL PrepareXboxes(void);	
	BOOL CheckExclList(char* List, char* Name);
	BOOL GetTotalBytes(void);
	void GetFileBytes(char* File);
	BOOL SendQuery(int QueryType);
	BOOL SendFiles(void);
	BOOL SendFile(char* FileName);
	BOOL SendKernel(void);
	BOOL SendFlashCmd(void);
    BOOL SendFinishCmd(void);
	void RebootXboxes(void);	
	void ReportResults(void);
	BOOL SendPacket(BYTE PacketType, DWORD FileSize, WORD DataSize, char* Data);
	DWORD GetCRC(unsigned char* Data, WORD Size);
	void AddXbox(char* Name, int Thread);
	void SetXboxState(char* Name, int State);
	void GetXboxes(int State);
	void ClearXboxes(void);
	
	friend DWORD WINAPI PrepareXboxThread(void* ClientPtr);
	friend DWORD WINAPI RebootXboxThread(void* ClientPtr);

};

struct ThreadParam 
{
	PcClient* Client;
	int ThreadNum;
};

void StringTrim(char* String);
void LogPrint(char* Format, ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labpusher\XbServer\mapdrives.cpp ===
/*****************************************************************************

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    mapdrives.cpp

	Derived from \private\test\ui\tools\memoryareas\memoryarea.cpp

	Author: Jim Helm (jimhelm)

Abstract:

    Defines functions needed to map Xbox hard disk partitions to drive 
	letters.

*****************************************************************************/

#include "xbserver.h"

extern "C"
    {
	NTSYSCALLAPI
	NTSTATUS
	NTAPI
	IoCreateSymbolicLink(
		IN POBJECT_STRING SymbolicLinkName,
		IN POBJECT_STRING DeviceName
		);

	NTSYSCALLAPI
	NTSTATUS
	NTAPI
	IoDeleteSymbolicLink(
		IN POBJECT_STRING SymbolicLinkName
		);
    }

DWORD MapDrive( char cDriveLetter, char* pszPartition )
{
    char pszDrive[20];
    ZeroMemory( pszDrive, 20 );
 
    sprintf( pszDrive, "\\??\\%c:", cDriveLetter );
 
    ANSI_STRING ostDrive, ostPath;
 
    RtlInitObjectString( &ostDrive, pszDrive );
    RtlInitObjectString( &ostPath, pszPartition );
    NTSTATUS status = IoCreateSymbolicLink( &ostDrive, &ostPath );
 
    return RtlNtStatusToDosError( status );
}
  
DWORD UnMapDrive( char cDriveLetter )
{
    char pszDrive[20];
    ZeroMemory( pszDrive, 20 );
 
    sprintf( pszDrive, "\\??\\%c:", cDriveLetter );
 
    ANSI_STRING ostDrive;
 
    RtlInitObjectString( &ostDrive, pszDrive );
    NTSTATUS status = IoDeleteSymbolicLink(&ostDrive);
 
    return RtlNtStatusToDosError( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labpusher\pcclient\pcclient.cpp ===
/*************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

	pcclient.cpp

  Abstract:

	Defines the LabPusher PC "client" side functions which allow file data and commands to be
	broadcasted to listening Xboxes.

  Author:

	Mabel Santos (t-msanto) 03-Dec-2001

  Revision History:

*************************************************************************************************/

#include "pcclient.h"

#define PORT 2000

enum PacketTypes{ FLASHCMD = 1, KRNLNOTE, FILEDESC, FILEDATA, FINISHCMD };
enum QueryTypes{ FORMATQUERY = 1, FLASHQUERY };
enum XboxStates{ FORMATSTATE = 1, FLASHSTATE, FINISHSTATE, REBOOTSTATE };

// number of threads to use for rebooting Xboxes
unsigned short NumThreads;

// number of seconds to wait before query timeout
unsigned short QueryTime;

// number of seconds to sleep between file sends
unsigned short FileSleep;

// number of seconds to sleep between packet sends
unsigned short PacketSleep;

// Xbox server app source path
char XbAppSrc[BUFFLEN];

// Xbox server app destination path
char XbAppDst[BUFFLEN];

// kernel source path
char KernelSrc[BUFFLEN];

// name of app to reboot into when finished 
char RebootApp[BUFFLEN];

// date/time identifier for log file
char FileStamp[BUFFLEN];

// log file name
char LogName[BUFFLEN];

// flag to indicate whether new kernel image will be flashed
int RecoveryOn;

// thread synchronization variables
CRITICAL_SECTION ThreadLock;
BOOL ThreadExitFlag;
unsigned short ThreadExitCount;

// CRC table
static const unsigned long CRCs[] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

/*************************************************************************************************

Routine Description:

	Default PcClient constructor.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

PcClient::PcClient(void)
{	
	// initialize Xbox list and tail pointer to NULL
	XboxList = NULL;
	LastXbox = NULL;
	
	//LogPrint("Initialized Xbox list to null\n");

	// set byte counter to 0
	ByteCount = 0;
	//LogPrint("Initialized byte counter to 0\n");

	// set packet counter to 0
	PacketCount = 0;
	//LogPrint("Initialized packet counter to 0\n");

	// set socket to invalid
	ClientSock = INVALID_SOCKET;
	//LogPrint("Set socket to invalid\n");

	// set WinSock flag to false
	WsaInitialized = false;
	//LogPrint("Set WinSock flag to false\n");
}

/*************************************************************************************************

Routine Description:

	Default PcClient destructor.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

PcClient::~PcClient(void)
{
	// close socket and clean up if needed
	if(ClientSock != INVALID_SOCKET)
	{
		closesocket(ClientSock);
	}

	if(WsaInitialized)
	{
		WSACleanup();
	}
}

/*************************************************************************************************

Routine Description:

	PrepareWinSock

	Initializes WinSock. Creates a UDP socket for broadcast use and binds the PC client to it.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::PrepareWinSock(void)
{
	// initialize WinSock
	WORD Version = MAKEWORD(2,2);
	WSADATA WsaData;
	WSAStartup(Version, &WsaData);
	WsaInitialized = true;
	//LogPrint("Initialized WinSock\n");

	// create a UDP datagram socket
	ClientSock = socket(AF_INET, SOCK_DGRAM, 0);
	//LogPrint("Created UDP datagram socket\n");

	if(ClientSock == INVALID_SOCKET && WSAGetLastError() == WSANOTINITIALISED) // 10093
	{
		WSAStartup(Version, &WsaData);
		WsaInitialized = true;
		//LogPrint("Initialized WinSock a second time\n");
		ClientSock = socket(AF_INET, SOCK_DGRAM, 0);
		//LogPrint("Created UDP datagram socket a second time\n");
	}

	// set socket up for broadcast use
	BOOL val = true;
	if(setsockopt(ClientSock, SOL_SOCKET, SO_BROADCAST, (char*)&val, sizeof(BOOL)) == SOCKET_ERROR) 
	{
		LogPrint("SOCKET ERROR in setsockopt()\n");
		return false;
	}
	else 
	{
		//LogPrint("Set socket up for broadcast use\n");
	}

	// try to increase send buffer size
	int Size, BufSize = 0;
	int Err, Res;
	
	// start with 64K, then cut buffer size in half if necessary until request is granted
	for(Size = 65536; Size > 16384; Size >>=1)
	{
		// if got a socket error, try again with a smaller size
		if(setsockopt(ClientSock, SOL_SOCKET, SO_SNDBUF, (char*)&Size, sizeof(int)) == SOCKET_ERROR)
		{
			Err = WSAGetLastError();
			// if option is not supported, break out of loop
			if(Err == WSAENOPROTOOPT || Err == WSAEINVAL) break;
		}
		else
		{
			// reaching here means buffer size was successfully changed
			break;
		}
	}
	Res = sizeof(int);
	getsockopt(ClientSock, SOL_SOCKET, SO_SNDBUF, (char*)&BufSize, &Res);
	//LogPrint("Send buffer size = %d bytes\n", BufSize);

	// fill in address structure
	SOCKADDR_IN ClientAddr;
	ClientAddr.sin_family = AF_INET;
	ClientAddr.sin_port = htons(0);
	ClientAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	//LogPrint("Filled in address structure\n");

	// bind name to socket
	if(bind(ClientSock, (SOCKADDR*)&ClientAddr, sizeof(SOCKADDR)) == SOCKET_ERROR)
	{
		LogPrint("SOCKET ERROR in bind()\n");
		return false;
	}
	else 
	{
		//LogPrint("Bound name to socket\n");
	}
	return true;
}

/*************************************************************************************************

Routine Description:

	PrepareXboxes

	Assigns and starts threads to put each Xbox listed in the labpusher.ini file in a listening
	state.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::PrepareXboxes(void)
{
	int CurrThread = 0;

	//LogPrint("XbAppSrc: %s\n", XbAppSrc);
	//LogPrint("XbAppDst: %s\n", XbAppDst);

	FILE* f = fopen("\\\\xstress\\stress\\LabPusher\\labpusher.ini", "r");
	
	BOOL XboxFlag = false;

	if(f)
	{
		char line[BUFFLEN];
		char Xbox[BUFFLEN];
		char strtemp[BUFFLEN];
		int inttemp = 0;

		while(fgets(line, BUFFLEN, f))
		{
			// find start of Xboxlist section
			if(sscanf(line, "XboxList=%s", Xbox) == 1)
			{
				// set flag to indicate that we've found it
				XboxFlag = true;

				// if first Xbox is not on the exclude list, assign it to a thread
				if(!CheckExclList("\\\\xstress\\stress\\LabPusher\\xboxexclude.txt", Xbox))
				{
					AddXbox(Xbox, (CurrThread % NumThreads) + 1);
					++CurrThread;
				}
				else
				{
					//LogPrint("Xbox %s found on exclude list. Skipping...\n", Xbox);
				}
				break;
			}
		}

		while(XboxFlag && fgets(line, BUFFLEN, f))
		{
			// check if we've reached end of Xboxlist section
			if((sscanf(line, "%[^=]=%s", Xbox, strtemp) == 2) ||
				(sscanf(line, "%[^=]=%d", Xbox, inttemp) == 2))
			{
				// set flag to indicate that we're finished
				XboxFlag = false;
				break;
			}
			// reaching here means there's another Xbox on the list
			StringTrim(line);

			// if this Xbox is not on the exclude list, assign it to a thread
			if(!CheckExclList("\\\\xstress\\stress\\LabPusher\\xboxexclude.txt", line))
			{
				AddXbox(line, (CurrThread % NumThreads) + 1);
				++CurrThread;
			}
			else
			{
				//LogPrint("Xbox %s found on exclude list. Skipping...\n", line);
			}
		}
		fclose(f);
	}
	else
	{
		LogPrint("ERROR: Could not open labpusher.ini file\n");
		return false;
	}

	// initialize critical section variables
	InitializeCriticalSection(&ThreadLock);
	ThreadExitFlag = false;
	ThreadExitCount = 0;

	// start specified number of threads
	int ThreadCount;
	for(ThreadCount = 1; ThreadCount <= NumThreads; ++ThreadCount)
	{
		ThreadParam* ThreadArg = new ThreadParam;
		ThreadArg->Client = this;
		ThreadArg->ThreadNum = ThreadCount;
		CreateThread(NULL, 0, PrepareXboxThread, ThreadArg, 0, NULL);
	}

	// wait for all threads to finish
	while(!ThreadExitFlag)
	{
		Sleep(100);
		EnterCriticalSection(&ThreadLock);
		if(ThreadExitCount == NumThreads) ThreadExitFlag = true;
		LeaveCriticalSection(&ThreadLock);
	}

	DeleteCriticalSection(&ThreadLock);
	return true;
}

/*************************************************************************************************

Routine Description:

	PrepareXboxThread

	Puts Xboxes in a listening state by copying the XbServer app into each Xbox and rebooting it
	into the app.

Arguments:

	none

Return Value:

	DWORD	-	returns 1 after thread exits

*************************************************************************************************/

DWORD WINAPI
PrepareXboxThread(void* ThreadArg)
{
	// get thread number
	int ThreadNum = ((ThreadParam*)ThreadArg)->ThreadNum;

	// get Xbox list
	Xbox* Curr;
	for(Curr = ((ThreadParam*)ThreadArg)->Client->XboxList; Curr != NULL; Curr = Curr->Next)
	{
		// if current Xbox belongs to this thread, prepare it
		if(Curr->Thread == ThreadNum)
		{	
			//LogPrint("CurrXbox: %s\n", Curr->Name);
			//LogPrint("Thread: %u\n", Curr->Thread);
			int Res;
		
			// resolve Xbox name into its IP addresses
			DmSetXboxName(Curr->Name);
			DWORD HostAddr;
			struct in_addr NetAddr;
			LPSTR IpAddr;

			// get debug IP
			DmResolveXboxName(&HostAddr);
			NetAddr.s_addr = htonl(HostAddr);
			IpAddr = inet_ntoa(NetAddr);
			//LogPrint("DebugIp: %s\n", IpAddr);
		
			// reboot Xbox
			char Cmd1[BUFFLEN];
			strcpy(Cmd1, "xbreboot -x ");
			strcat(Cmd1, Curr->Name);

			//LogPrint("%s\n", Cmd1);
			Res = system(Cmd1);
			if(Res)
			{
				LogPrint("WARNING: Could not reboot %s\n", Curr->Name);
				continue;
			}
			//LogPrint("Rebooted %s\n", Curr->Name);
		
			// sleep for 1 sec to make sure box has been rebooted
			Sleep(1000);

			// copy over Xbox application
			char Cmd2[BUFFLEN];
			strcpy(Cmd2, "xbcp -x ");
			strcat(Cmd2, Curr->Name);
			strcat(Cmd2, " -ty "); // options: create dest dir if it does not exist, don't prompt to overwrite
			strcat(Cmd2, XbAppSrc);
			strcat(Cmd2, " ");
			strcat(Cmd2, XbAppDst);

			//LogPrint("%s\n", Cmd2);
			Res = system(Cmd2);
			if(Res)
			{
				LogPrint("WARNING: Could not copy %s into %s\n", XbAppSrc, Curr->Name);
				continue;
			}
			//LogPrint("Copied %s into %s\n", XbAppSrc, XbAppDst);

			// sleep for 1 sec to make sure app has been copied over
			Sleep(1000);

			// reboot Xbox into application
			char Cmd3[BUFFLEN];
			strcpy(Cmd3, "xbreboot -x ");
			strcat(Cmd3, Curr->Name);
			strcat(Cmd3, " ");
			strcat(Cmd3, XbAppDst);

			//LogPrint("%s\n", Cmd3);
			Res = system(Cmd3);
			if(Res)
			{
				LogPrint("WARNING: Could not reboot %s into %s\n", Curr->Name, XbAppDst);
				continue;
			}
			//LogPrint("Rebooted %s into %s\n", Curr->Name, XbAppDst);
		}
	}

	// increment count of exited threads
	EnterCriticalSection(&ThreadLock);
	++ThreadExitCount;
	LeaveCriticalSection(&ThreadLock);

	delete ((ThreadParam*)ThreadArg);
	return 1;
}

/*************************************************************************************************

Routine Description:

	CheckExclList

	Checks if a given name is on a specified exclude list.

Arguments:

	char* List	-	list to search
	char* Name	-	name to look for

Return Value:

	BOOL	-	 true if name is found on list; false otherwise

*************************************************************************************************/

BOOL
PcClient::CheckExclList(char* List, char* Name)
{
	FILE* f = fopen(List, "r");

	if(f)
	{
		char line[BUFFLEN];

		// check if any names on exclude list match given name
		while(fgets(line, BUFFLEN, f))
		{
			StringTrim(line);
			if(_stricmp(line, Name) == 0)
			{
				return true;
			}
		}
		fclose(f);
	}
	// reaching here means name was not found
	return false;
}

/*************************************************************************************************

Routine Description:

	GetTotalBytes

	Adds up the size of each file listed in the labpusher.ini file to determine the total number
	of bytes to be sent over the network.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::GetTotalBytes(void)
{
	FILE* f = fopen("\\\\xstress\\stress\\LabPusher\\labpusher.ini", "r");
	BOOL FileFlag = false;

	if(f)
	{
		char line[BUFFLEN];
		char file[BUFFLEN];
		char strtemp[BUFFLEN];
		int inttemp = 0;
		
		while(fgets(line, BUFFLEN, f))
		{
			// find start of filelist section
			if(sscanf(line, "FileList=%s", file) == 1)
			{
				// set flag to indicate that we've found it
				FileFlag = true;
		
				// if first file is not on the exclude list, add its size to the byte counter
				if(!CheckExclList("\\\\xstress\\stress\\LabPusher\\fileexclude.txt", file))
				{
					GetFileBytes(file);
					
				}
				break;
			}
		}

		while(FileFlag && fgets(line, BUFFLEN, f))
		{
			// check if we've reached end of filelist section
			if((sscanf(line, "%[^=]=%s", file, strtemp) == 2) ||
			(sscanf(line, "%[^=]=%d", file, inttemp) == 2))
			{
				// set flag to indicate that we're finished
				FileFlag = false;
				break;
			}
			// reaching here means there's another file on the list
			StringTrim(line);
			
			// if this file is not on the exclude list, add its size to the byte counter
			if(!CheckExclList("\\\\xstress\\stress\\LabPusher\\fileexclude.txt", line))
			{
				GetFileBytes(line);
			}
		}

		// add kernel file, if needed
		if(RecoveryOn)
		{
			GetFileBytes(KernelSrc);
		}
		fclose(f);
		//LogPrint("Total bytes to be sent: %u\n", ByteCount);
		return true;
	}
	else
	{
		LogPrint("ERROR: Could not open labpusher.ini file\n");
		return false;
	}
}

/*************************************************************************************************

Routine Description:

	GetFileBytes

	Determines the size of a specified file in bytes.

Arguments:

	char* File	-	name of file whose size is to be determined

Return Value:

	none

*************************************************************************************************/

void
PcClient::GetFileBytes(char* File)
{
	char PcFile[BUFFLEN];

	int Mid = strcspn(File, ",");
	int End = strcspn(File, "\n");

	// copy source filename into a temp buffer
	memmove(PcFile, File, Mid);
	memset(PcFile+Mid, '\0', BUFFLEN-Mid);
	
	HANDLE FileHandle;
	DWORD FileSize;
	
	// get file size
	FileHandle = CreateFile(PcFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	FileSize = GetFileSize(FileHandle, NULL);
	ByteCount += FileSize;
	CloseHandle(FileHandle);
}

/*************************************************************************************************

Routine Description:

	SendQuery

	Sends a broadcast message and waits for responses to see which Xboxes are in a listening
	state.

Arguments:

	int QueryType	-	type of query being sent
						FORMATQUERY: sent after Xboxes reboot into XbServer app and format drives
						FLASHQUERY: sent after Xboxes receive file data and flash ROM

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::SendQuery(int QueryType)
{
	int Result;
	SOCKADDR_IN DestAddr;
	int AddrSize = sizeof(SOCKADDR);

	DestAddr.sin_family = AF_INET;
	DestAddr.sin_port = htons(PORT);
	DestAddr.sin_addr.s_addr = htonl(INADDR_BROADCAST);

	// Send broadcast query to servers
	char QueryBuf[BUFFLEN];

	if(QueryType == FORMATQUERY)
	{
		// if this is the first query, include total byte count so Xboxes know how much data to expect
		_ultoa(ByteCount, QueryBuf, 10);

		if(sendto(ClientSock, QueryBuf, strlen(QueryBuf), 0, (SOCKADDR*)&DestAddr, AddrSize) == SOCKET_ERROR)
		{
			LogPrint("SOCKET ERROR in sendto()\n");
			return false;
		}
	}
	else
	{
		if(sendto(ClientSock, NULL, 0, 0, (SOCKADDR*)&DestAddr, AddrSize) == SOCKET_ERROR)
		{
			LogPrint("SOCKET ERROR in sendto()\n");
			return false;
		}
	}

	//LogPrint("Sent broadcast query to servers\n");

	// wait for reply from each server
	//LogPrint("Waiting for reply from servers\n");

	TIMEVAL Timeout;
	FD_SET Bucket;

	// timeout after number of seconds specified in .INI file
	time_t Start, Curr;

	for(time(&Start), time(&Curr); difftime(Curr, Start) <= QueryTime; time(&Curr))
	{
		Bucket.fd_count = 1;
		Bucket.fd_array[0] = ClientSock;
		Timeout.tv_sec = 5;
		Timeout.tv_usec = 0;

		// clear buffer
		memset(QueryBuf, '\0', sizeof(QueryBuf));

		// wait for response
		Result = select(0, &Bucket, NULL, NULL, &Timeout);

		if(Result == 0) continue; // timed out so try again
		
		if(Result == SOCKET_ERROR)
		{
			LogPrint("SOCKET ERROR in select()\n");
			return false;
		}

		// grab response
		Result = recvfrom(ClientSock, QueryBuf, sizeof(QueryBuf), 0, (SOCKADDR*)&DestAddr, &AddrSize);	  
		
		if(Result == 0) 
		{
			// no more data
			//LogPrint("No more data. Breaking out of loop...\n");
			break;
		}

		if(Result == SOCKET_ERROR)
		{
			LogPrint("SOCKET ERROR in recvfrom()\n");
			return false;
		}

		// reaching here means we got a valid response	
		/*LogPrint("Received reply from server %u.%u.%u.%u \"%s\"\n", 
					DestAddr.sin_addr.S_un.S_un_b.s_b1, DestAddr.sin_addr.S_un.S_un_b.s_b2,
					DestAddr.sin_addr.S_un.S_un_b.s_b3, DestAddr.sin_addr.S_un.S_un_b.s_b4,
					QueryBuf);*/

		// change Xbox state according to the query type
		switch(QueryType)
		{
			// Xboxes that respond are finished formatting drives, so the next step is to
			// receive files and flash ROM
			case FORMATQUERY:

				SetXboxState(QueryBuf, FLASHSTATE);
				break;

			// Xboxes that respond are done flashing ROM, so they've successfully finished
			// recovery
			case FLASHQUERY:

				SetXboxState(QueryBuf, FINISHSTATE);
				break;
		}
	}

	// reaching here means we've timed out, so report which Xboxes responded in time and which ones did not
	switch(QueryType)
	{
		case FORMATQUERY:
	
			LogPrint("Boxes that responded after rebooting/formatting drives:\n");
			//LogPrint("Got a response from the following Xboxes:\n");
			GetXboxes(FLASHSTATE);
			LogPrint("Boxes that did NOT respond after rebooting/formatting drives:\n");
			//LogPrint("Did NOT get a response from the following Xboxes:\n");
			GetXboxes(FORMATSTATE);
			break;

		case FLASHQUERY:

			LogPrint("Boxes that responded after receiving files/flashing ROM:\n");
			//LogPrint("Got a response from the following Xboxes:\n");
			GetXboxes(FINISHSTATE);
			LogPrint("Boxes that did NOT respond after receiving files/flashing ROM:\n");
			//LogPrint("Did NOT get a response from the following Xboxes:\n");
			GetXboxes(FLASHSTATE);
			break;
	}
	return true;
}

/*************************************************************************************************

Routine Description:

	SendFiles

	Sends files listed in the labpusher.ini file over the network.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::SendFiles(void)
{
	FILE* f = fopen("\\\\xstress\\stress\\LabPusher\\labpusher.ini", "r");
	BOOL FileFlag = false;

	if(f)
	{
		char line[BUFFLEN];
		char file[BUFFLEN];
		char strtemp[BUFFLEN];
		int inttemp = 0;
		
		while(fgets(line, BUFFLEN, f))
		{
			// find start of filelist section
			if(sscanf(line, "FileList=%s", file) == 1)
			{
				// set flag to indicate that we've found it
				FileFlag = true;
		
				// if first file is not on the exclude list, send it
				if(!CheckExclList("\\\\xstress\\stress\\LabPusher\\fileexclude.txt", file))
				{
					if(!SendFile(file))
					{
						return false;
					}
				}
				else
				{
					//LogPrint("File %s found on exclude list. Skipping...\n", file);
				}
				break;
			}
		}

		while(FileFlag && fgets(line, BUFFLEN, f))
		{
			// check if we've reached end of filelist section
			if((sscanf(line, "%[^=]=%s", file, strtemp) == 2) ||
			(sscanf(line, "%[^=]=%d", file, inttemp) == 2))
			{
				// set flag to indicate that we're finished
				FileFlag = false;
				break;
			}
			// reaching here means there's another file on the list
			StringTrim(line);
			
			// if this file is not on the exclude list, send it
			if(!CheckExclList("\\\\xstress\\stress\\LabPusher\\fileexclude.txt", line))
			{
				if(!SendFile(line))
				{
					return false;
				}
			}
			else
			{
				//LogPrint("File %s found on exclude list. Skipping...\n", line);
			}
		}
		fclose(f);
		return true;
	}
	else
	{
		LogPrint("ERROR: Could not open labpusher.ini file\n");
		return false;
	}
}

/*************************************************************************************************

Routine Description:

	SendFile

	Sends a specified file over the network.

Arguments:

	char* File	-	 name of file to be sent

Return Value:

	BOOL	-	 true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::SendFile(char* File)
{
	// sleep before sending another file to allow Xboxes to receive previous data
	if(FileSleep > 0)
	{
		Sleep(FileSleep);
	}
	
	char PcFile[BUFFLEN];
	char XbFile[BUFFLEN];

	int Mid = strcspn(File, ",");
	int End = strcspn(File, "\n");

	// copy source filename into a temp buffer
	memmove(PcFile, File, Mid);
	memset(PcFile+Mid, '\0', BUFFLEN-Mid);
	//LogPrint("Source: %s\n", PcFile);

	// copy destination filename into a temp buffer, if there is one
	if(Mid < End)
	{
		memmove(XbFile, File+(Mid+1), End-(Mid+1));
		memset(XbFile+(End-(Mid+1)), '\0', BUFFLEN-(End-(Mid+1)));
		//LogPrint("Destination: %s\n", XbFile);
	}
	else
	{
		memset(XbFile, '\0', sizeof(XbFile));
	}

	HANDLE FileHandle;
	DWORD FileSize;
	char SendBuf[BUFFLEN];
	size_t ReadRes;
	
	// get file size
	FileHandle = CreateFile(PcFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	FileSize = GetFileSize(FileHandle, NULL);
	//LogPrint("Size: %d bytes\n", FileSize);
	CloseHandle(FileHandle);

	// open infile for reading in binary mode
	FILE* InFile = fopen(PcFile, "rb");

	// skip file if we can't find/open it
	if(InFile == NULL)
	{
		LogPrint("WARNING: Could not open file %s\n", PcFile);
		LogPrint("WARNING: File %s not sent\n", PcFile);
		return false;
	}
	
	// send file description packet if needed
	if(XbFile[0] != '\0')
	{
		if(!SendPacket(FILEDESC, FileSize, strlen(XbFile), XbFile))
		  {
			LogPrint("ERROR: File description not sent\n");
			LogPrint("ERROR: File %s not sent\n", PcFile);
			return false;
		}
		//LogPrint("Sent file description packet\n");
	}

	else // else send kernel notification
	{
		if(!SendPacket(KRNLNOTE, FileSize, 0, NULL))
		{
			LogPrint("ERROR: Kernel notification not sent\n");
			return false;
		}
		//LogPrint("Sent kernel notification\n");
	}
	
	while(!feof(InFile))
	{
		// clear buffer and read 1K of data from infile
		memset(SendBuf, '\0', sizeof(SendBuf));
		ReadRes = fread(SendBuf, sizeof(char), BUFFLEN, InFile);

		// if there is a problem with reading from the file, return
		if(ferror(InFile))
		{
			LogPrint("ERROR: Could not read data from file\n");
			LogPrint("ERROR: File %s not sent\n", PcFile);
			return false;
		}

		// if read 0 bytes, end of file has been reached so break out of loop
		if(ReadRes == 0)
		{
			break;
		}

		//LogPrint("Read %dB of data from file\n", ReadRes);

		// send file data packet
		if(!SendPacket(FILEDATA, FileSize, ReadRes, SendBuf))
		{
			LogPrint("ERROR: Could not send file data\n");
			LogPrint("ERROR: File %s not sent\n", PcFile);
			return false;
		}
		//LogPrint("Sent file data packet\n");
	}
	
	// close infile stream
	fclose(InFile);
	//LogPrint("Sent file %s successfully\n", PcFile);
	return true;
}

/*************************************************************************************************

Routine Description:

	SendKernel

	Sends kernel data over the network.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::SendKernel(void)
{
	//LogPrint("KernelSrc: %s\n", KernelSrc);

	if(!SendFile(KernelSrc))
	{
		LogPrint("ERROR: Kernel data not sent\n");
		return false;
	}

	//LogPrint("Sent kernel file\n");
	return true;
}

/*************************************************************************************************

Routine Description:

	SendFlashCmd

	Sends a command for Xboxes to flash ROM over the network.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::SendFlashCmd(void)
{	
	if(!SendPacket(FLASHCMD, 0, 0, NULL))
	{
		LogPrint("ERROR: Flash command not sent\n");
		return false;
	}

	//LogPrint("Sent flash command\n");
	return true;
}

/*************************************************************************************************

Routine Description:

	SendFinishCmd

	Sends a command for Xboxes to finish receiving files

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::SendFinishCmd(void)
{	
	if(!SendPacket(FINISHCMD, 0, 0, NULL))
	{
		LogPrint("ERROR: Finish command not sent\n");
		return false;
	}

	//LogPrint("Sent flash command\n");
	return true;
}


/*************************************************************************************************

Routine Description:

	RebootXboxes

	Assigns and starts threads to reboot each Xbox listed in the labpusher.ini file that is in a
	listening state.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

void
PcClient::RebootXboxes(void)
{
	if(strcmp(RebootApp, "NONE") != 0)
	{
		//LogPrint("RebootApp: %s\n", RebootApp);
	}

	// initialize critical section variables
	InitializeCriticalSection(&ThreadLock);
	ThreadExitFlag = false;
	ThreadExitCount = 0;

	// start specified number of threads
	int ThreadCount;
	for(ThreadCount = 1; ThreadCount <= NumThreads; ++ThreadCount)
	{
		ThreadParam* ThreadArg = new ThreadParam;
		ThreadArg->Client = this;
		ThreadArg->ThreadNum = ThreadCount;
		CreateThread(NULL, 0, RebootXboxThread, ThreadArg, 0, NULL);
	}

	// wait for all threads to finish
	while(!ThreadExitFlag)
	{
		Sleep(100);
		EnterCriticalSection(&ThreadLock);
		if(ThreadExitCount == NumThreads) ThreadExitFlag = true;
		LeaveCriticalSection(&ThreadLock);
	}

	DeleteCriticalSection(&ThreadLock);
}

/*************************************************************************************************

Routine Description:

	RebootXboxThread

	Reboots Xboxes into app listed in the labpusher.ini file, or into the XDK launcher if there is
	no app specified.

Arguments:

	none

Return Value:

	DWORD	-	returns 1 after thread exits

*************************************************************************************************/

DWORD WINAPI
RebootXboxThread(void* ThreadArg)
{
	// get thread number
	int ThreadNum = ((ThreadParam*)ThreadArg)->ThreadNum;

	if(strcmp(RebootApp, "NONE") != 0)
	{
		// get Xbox list
		Xbox* Curr;
		for(Curr = ((ThreadParam*)ThreadArg)->Client->XboxList; Curr != NULL; Curr = Curr->Next)
		{
			// reboot each Xbox that recovered successfully into specified application
			if(Curr->State == FINISHSTATE && Curr->Thread == ThreadNum)
			//if(Curr->Thread == ThreadNum)
			{
				//LogPrint("CurrXbox: %s\n", Curr->Name);
				//LogPrint("Thread: %u\n", Curr->Thread);
				int Res;
				char XboxName[BUFFLEN];
				strcpy(XboxName, Curr->Name);
				char Cmd1[BUFFLEN];
				strcpy(Cmd1, "xbreboot -xc ");
				strcat(Cmd1, XboxName);
				strcat(Cmd1, " ");
				strcat(Cmd1, RebootApp);

				//LogPrint("%s\n", Cmd1);

				Res = system(Cmd1);
				if(Res)
				{
					LogPrint("WARNING: Could not reboot %s into %s\n", XboxName, RebootApp);
				}
				else
				{
					//LogPrint("Rebooted %s into %s\n", XboxName, RebootApp);
				
					// set Xbox state to indicate that it's been rebooted
					((ThreadParam*)ThreadArg)->Client->SetXboxState(XboxName, REBOOTSTATE);

					// register box with lab database
					char Cmd2[BUFFLEN];
					strcpy(Cmd2, "\\\\xstress\\stress\\registerBox.wsf /box=");
					strcat(Cmd2, XboxName);
					strcat(Cmd2, " /debugger=");
					char DebugName[BUFFLEN];
					strcpy(DebugName, "xdebug");
					
					// get debug machine name from Xbox name
					strcat(DebugName, &XboxName[4]);
					DebugName[8] = '\0';
					strcat(Cmd2, DebugName);
					strcat(Cmd2, " /owner=joex");

					//LogPrint("%s\n", Cmd2);

					Res = system(Cmd2);
					if(Res)
					{
						LogPrint("WARNING: Could not register %s with lab database\n", XboxName);
					}
					else
					{
						//LogPrint("Registered %s with lab database\n", XboxName);
					}
				}
			}
		}
	}
	else
	{
		Xbox* Curr;
		for(Curr = ((ThreadParam*)ThreadArg)->Client->XboxList; Curr != NULL; Curr = Curr->Next)
		{
			// reboot each Xbox that recovered successfully into XDK launcher
			if(Curr->State == FINISHSTATE && Curr->Thread == ThreadNum)
			//if(Curr->Thread == ThreadNum)
			{
				//LogPrint("CurrXbox: %s\n", Curr->Name);
				//LogPrint("Thread: %u\n", Curr->Thread);
				int Res;
				char XboxName[BUFFLEN];
				strcpy(XboxName, Curr->Name);
				char Cmd1[BUFFLEN];
				strcpy(Cmd1, "xbreboot -xc ");
				strcat(Cmd1, XboxName);

				//LogPrint("%s\n", Cmd1);

				Res = system(Cmd1);
				if(Res)
				{
					LogPrint("WARNING: Could not reboot %s\n", XboxName);
				}
				else
				{
					//LogPrint("Rebooted %s\n", XboxName);
				
					// set Xbox state to indicate that it's been rebooted
					((ThreadParam*)ThreadArg)->Client->SetXboxState(XboxName, REBOOTSTATE);
				}
			}
		}
	}

	// increment count of exited threads
	EnterCriticalSection(&ThreadLock);
	++ThreadExitCount;
	LeaveCriticalSection(&ThreadLock);

	delete ((ThreadParam*)ThreadArg);
	return 1;
}

/*************************************************************************************************

Routine Description:

	ReportResults

	Lists which boxes successfully received data and commands, and which ones failed.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
PcClient::ReportResults(void)
{
/*
	LogPrint("Boxes that did not respond after rebooting/formatting drives:\n");
	GetXboxes(FORMATSTATE);

	LogPrint("Boxes that did not respond after receiving files/flashing ROM:\n");
	GetXboxes(FLASHSTATE);
*/
	if(strcmp(RebootApp, "NONE") != 0)
	{
		LogPrint("Boxes that have been rebooted into stress:\n");
		GetXboxes(REBOOTSTATE);

		LogPrint("Boxes that could NOT be rebooted into stress:\n");
		GetXboxes(FINISHSTATE);
	}
	else
	{
		LogPrint("Boxes that have been rebooted into launcher:\n");
		GetXboxes(REBOOTSTATE);
		
		LogPrint("Boxes that could NOT be rebooted into launcher:\n");
		GetXboxes(FINISHSTATE);
	}
}

/*************************************************************************************************

Routine Description:

	SendPacket

	Sends a data packet over the network.

Arguments:

	BYTE PacketType	-	type of packet being sent
						FLASHCMD: command to flash ROM
						KRNLNOTE: notification that kernel data is about to be sent
						FILEDESC: file description and path
						FILEDATA: file data
	DWORD FileSize	-	total size of current file in bytes
	WORD DataSize	-	size of data being sent in bytes
	char* Data		-	data being sent

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
PcClient::SendPacket(BYTE PacketType, DWORD FileSize, WORD DataSize, char* Data)
{
	// sleep before sending another packet to allow Xboxes to receive previous data
	if(PacketSleep > 0)
	{
		Sleep(PacketSleep);
	}

	int Result;
	SOCKADDR_IN dest;
	dest.sin_family = AF_INET;
	dest.sin_addr.s_addr = htonl(INADDR_BROADCAST);
	dest.sin_port = htons(PORT);

	// increment packet count
	++PacketCount;
	//LogPrint("Incremented packet count to %d\n", PacketCount);

	char SendBuf[sizeof(FilePacketHeader) + BUFFLEN];
	memset(SendBuf, '\0', sizeof(SendBuf));
	FilePacket* Packet = (FilePacket*)SendBuf;
	Packet->PacketType = PacketType;
	Packet->SequenceNo = PacketCount;
	Packet->FileSize = FileSize;
	Packet->DataSize = DataSize;
	memmove(Packet->Data, Data, DataSize);
	Packet->Crc = GetCRC((unsigned char*)Packet->Data, Packet->DataSize);
	

	// display packet info
	//LogPrint("PacketType: %d\n", Packet->PacketType);
	//LogPrint("SequenceNo: %d\n", Packet->SequenceNo);
	//LogPrint("DataSize: %d\n", Packet->DataSize);
	//LogPrint("Crc: %d\n", Packet->Crc);

	// send packet
	Result = sendto(ClientSock, SendBuf, DataSize + sizeof(FilePacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR));
	if(Result == SOCKET_ERROR)
	{
		LogPrint("SOCKET ERROR in sendto()\n");
		return false;
	}
	return true;
}

/*************************************************************************************************

Routine Description:

	GetCRC

	Determines the CRC for the specified data.

Arguments:

	unsigned char* Data	-	data whose CRC is to be determined
	WORD Size			-	size of data

Return Value:

	DWORD	-	CRC for data

*************************************************************************************************/

DWORD
PcClient::GetCRC(unsigned char* Data, WORD Size)
{
	DWORD Result = 0;
	DWORD Shift = 0;
	DWORD Index = 0;

	while(Size--)
	{
		Result = (Result >> 8) ^ CRCs[(BYTE)(Result ^ *Data++)];
	}
	return Result;
}

/*************************************************************************************************

Routine Description:

	AddXbox

	Adds an Xbox to the Xbox list and assigns it to a thread.

Arguments:

	char* Name	-	name of Xbox
	int Thread	-	thread number assigned to Xbox

Return Value:

	none

*************************************************************************************************/

void
PcClient::AddXbox(char* Name, int Thread)
{
	// make new node
	Xbox* NewXbox = new Xbox;
	strcpy(NewXbox->Name, Name);
	NewXbox->State = FORMATSTATE;
	NewXbox->Thread = Thread;
	NewXbox->Next = NULL;

	// if the list is currently empty, make this node the first and last
	if(XboxList == NULL && LastXbox == NULL)
	{
		XboxList = NewXbox;
		LastXbox = NewXbox;
	}
	else // else just add this node to the tail of the list
	{
		LastXbox->Next = NewXbox;
		LastXbox = NewXbox;
	}
}

/*************************************************************************************************

Routine Description:

	SetXboxState

	Sets the state of an Xbox on the Xbox list to a new value.

Arguments:

	char* Name	-	name of Xbox whose state is to be changed
	int State	-	new Xbox state
					FORMATSTATE: box needs to reboot into listening app and format drives
					FLASHSTATE: box needs to receive file data and flash ROM
					FINISHSTATE: box has finished recovery and needs to be rebooted
					REBOOTSTATE: box has been rebooted

Return Value:

	none

*************************************************************************************************/

void
PcClient::SetXboxState(char* Name, int State)
{
	Xbox* Curr;
	for(Curr = XboxList; Curr != NULL; Curr = Curr->Next)
	{
		if(_stricmp(Curr->Name, Name) == 0) // we've found the node we're looking for
		{
			Curr->State = State;
		}
	}
}

/*************************************************************************************************

Routine Description:

	GetXboxes

	Lists Xboxes on the Xbox list with the specified state.

Arguments:

	int State	-	state to search for

Return Value:

	none

*************************************************************************************************/

void
PcClient::GetXboxes(int State)
{
	BOOL Found = false;
	Xbox* Curr;
	for(Curr = XboxList; Curr != NULL; Curr = Curr->Next)
	{
		// if current Xbox has the state we're looking for, print it out
		if(Curr->State == State)
		{
			LogPrint("%s\n", Curr->Name);
			Found = true;
		}
	}
	if(!Found)
	{
		LogPrint("NONE\n");
	}
}

/*************************************************************************************************

Routine Description:

	ClearXboxes

	Deletes all Xboxes on the Xbox list.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
PcClient::ClearXboxes(void)
{
	while(XboxList != NULL)
	{
		// delete all nodes on the list
		Xbox* Curr = XboxList;
		XboxList = Curr->Next;
		delete Curr;
	}
	LastXbox = NULL;
}

/*************************************************************************************************

Routine Description:

	StringTrim

	Trims off tabs and newlines from a given string.

Arguments:

	char* String	-	string to be trimmed

Return Value:

	none

*************************************************************************************************/

void
StringTrim(char* String)
{
	// trim off tabs and/or newlines
	int Pos = strcspn(String, "\t\n");
	String[Pos] = '\0';
}

/*************************************************************************************************

Routine Description:

	LogPrint

	Prints a line to standard output and to a logfile.

Arguments:

	char* Format, ...	-	format string	

Return Value:

	none

*************************************************************************************************/

void
LogPrint(char* Format, ...)
{
	va_list ArgList;
	va_start(ArgList, Format);
	
	// print to stdout
	vprintf(Format, ArgList);

	// print to logfile
	FILE* LogFile = fopen(LogName, "a");

	if(LogFile)
	{
		vfprintf(LogFile, Format, ArgList);
		fclose(LogFile);
	}

	va_end(ArgList);
}

/*************************************************************************************************

Routine Description:

	main function

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
main(void)
{
	char DateBuf[9];
	char TimeBuf[9];

	_strdate(DateBuf);
	_strtime(TimeBuf);

	// get date without year for file stamp
	DateBuf[5] = '\0';
	// change '/' in date to '-' so fopen is happy
	DateBuf[2] = '-';

	// get time without secs for file stamp
	TimeBuf[5] = '\0';
	// change ':' in time to '-' so fopen is happy
	TimeBuf[2] = '-';

	// set date/time file stamp
	strcpy(FileStamp, DateBuf);
	strcat(FileStamp, "_");
	strcat(FileStamp, TimeBuf);

	// set log file name
	strcpy(LogName, "log_");
	strcat(LogName, FileStamp);
	strcat(LogName, ".txt");

	// restore original date
	DateBuf[2] = '/';
	DateBuf[5] = '/';

	// restore original time
	TimeBuf[2] = ':';
	TimeBuf[5] = ':';

	// get start time
	LogPrint("Start Time: %s %s\n", DateBuf, TimeBuf);

	// get number of threads to use for rebooting Xboxes from .INI file
	NumThreads = GetPrivateProfileIntA("Settings", "NumThreads", 5, "\\\\xstress\\stress\\LabPusher\\labpusher.ini");
	//LogPrint("NumThreads: %d\n", NumThreads);

	// get number of seconds to wait before query timeout from .INI file
	QueryTime = GetPrivateProfileIntA("Settings", "QueryTime", 30, "\\\\xstress\\stress\\LabPusher\\labpusher.ini");
	//LogPrint("QueryTime: %d\n", QueryTime);

	// get number of seconds to sleep before file sends from .INI file
	FileSleep = GetPrivateProfileIntA("Settings", "FileSleep", 2, "\\\\xstress\\stress\\LabPusher\\labpusher.ini");
	//LogPrint("FileSleep: %d\n", FileSleep);

	// get number of seconds to sleep before packet sends from .INI file
	PacketSleep = GetPrivateProfileIntA("Settings", "PacketSleep", 1, "\\\\xstress\\stress\\LabPusher\\labpusher.ini");
	//LogPrint("PacketSleep: %d\n", PacketSleep);

	// get Xbox app source path from .INI file
	GetPrivateProfileStringA("Settings", "XbAppSrc", "\\\\xstress\\stress\\LabPusher\\XbServer.xbe", XbAppSrc, BUFFLEN, "\\\\xstress\\stress\\LabPusher\\labpusher.ini");
	
	// get Xbox app destination path from .INI file
	GetPrivateProfileStringA("Settings", "XbAppDst", "xE:\\LabPusher\\XbServer.xbe", XbAppDst, BUFFLEN, "\\\\xstress\\stress\\LabPusher\\labpusher.ini");

	// get kernel source path from .INI file
	GetPrivateProfileStringA("Settings", "KernelSrc", "\\\\xbuilds\\release\\usa\\3944\\checked\\boot\\xboxrom_dvt4.bin", KernelSrc, BUFFLEN, "\\\\xstress\\stress\\LabPusher\\labpusher.ini");
	
	// get app to reboot into when finished from .INI file
	GetPrivateProfileStringA("Settings", "RebootApp", "NONE", RebootApp, BUFFLEN, "\\\\xstress\\stress\\LabPusher\\labpusher.ini");

	// get recovery indicator value from .INI file
	RecoveryOn = GetPrivateProfileIntA("Settings", "RecoveryOn", 1, "\\\\xstress\\stress\\LabPusher\\labpusher.ini");

	// make a PcClient object
	PcClient* Client = new PcClient;

	// set up network stuff
	if(!Client->PrepareWinSock())
	{
		Client->ClearXboxes();
		delete Client;
		return;
	}

	LogPrint("Preparing Xboxes...\n");
	// set up Xbox servers
	if(!Client->PrepareXboxes())
	{
		Client->ClearXboxes();
		delete Client;
		return;
	}

	// add up total number of data bytes to send over the network
	if(!Client->GetTotalBytes())
	{
		Client->ClearXboxes();
		delete Client;
		return;
	}

	// sleep for 10 secs to make sure Xboxes are ready to receive query
	Sleep(10000);

	LogPrint("Pinging Xboxes...\n");
	// send format query to servers and wait for response
	if(!Client->SendQuery(FORMATQUERY))
	{
		Client->ClearXboxes();
		delete Client;
		return;
	}

	LogPrint("Sending files...\n");
	// send files
	if(!Client->SendFiles())
	{
		Client->ClearXboxes();
		delete Client;
		return;
	}

	if(RecoveryOn)
	{
		LogPrint("Sending kernel...\n");
		// send kernel
		if(!Client->SendKernel())
		{
			Client->ClearXboxes();
			delete Client;
			return;
		}

		LogPrint("Sending flash command...\n");
		// send flash command
		if(!Client->SendFlashCmd())
		{
			Client->ClearXboxes();
			delete Client;
			return;
		}
	}
    else
        {
        Client->SendFinishCmd();
        }

	// sleep for 1 min to make sure Xboxes are ready to receive query
	Sleep(60000);
	
	LogPrint("Pinging Xboxes...\n");
	// send flash query to servers and wait for response 
	if(!Client->SendQuery(FLASHQUERY))
	{
		Client->ClearXboxes();
		delete Client;
		return;
	}

	LogPrint("Rebooting Xboxes...\n");
	// reboot Xboxes into specified application
	Client->RebootXboxes();

	// report which Xboxes recovered successfully and which ones did not
	Client->ReportResults();

	// get end time
	_strdate(DateBuf);
	_strtime(TimeBuf);
	LogPrint("End Time: %s %s\n", DateBuf, TimeBuf);

	// return memory to heap
	Client->ClearXboxes();
	delete Client;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labpusher\XbServer\setled.cpp ===
/*****************************************************************************

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    setled.cpp

	Derived from \private\test\kernel\smc\smc.cpp

	Author:

Abstract:

    Defines functions needed to change LED colors on the Xbox.

*****************************************************************************/

#include "xbserver.h"

extern "C"
    {
	DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );
    }

NTSTATUS WriteSMC(unsigned char addr, unsigned char value)
    {
    return HalWriteSMBusValue(0x20, addr, FALSE, value);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labpusher\XbServer\flashrom.cpp ===
/*****************************************************************************

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    flashrom.cpp
	
	Derived from \private\ntos\recovery\flash.cpp

    Author:
	
Abstract:

    Defines functions needed to program the Xbox flash ROM with a new kernel 
	image.

*****************************************************************************/

#include "xbserver.h"
#include <pci.h>

//
// Manufacturer and chip identifiers
//

#define SST_ID                  0xBF
#define SST_49LF040             0x53

#define AMD_ID                  0x01
#define FUJITSU_ID              0x04
#define HYUNDAI_ID              0xAD
#define GENERIC_29F080          0xD5

#define ST_ID                   0x20
#define M29F080A                0xF1

typedef enum {
    FlashUnknownDevice = 0,
    FlashSST49LF040,
    FlashGeneric29F080
} FlashDeviceID;

typedef enum {
    FlashStatusReady,
    FlashStatusBusy,
    FlashStatusEraseSuspended,
    FlashStatusTimeout,
    FlashStatusError
} FlashStatus;

extern "C"
{
	VOID
    WINAPI
    KeStallExecutionProcessor (
        IN ULONG MicroSeconds
        );

	DECLSPEC_IMPORT
    void
    WINAPI
    HalReadWritePCISpace(
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG RegisterNumber,
        IN PVOID Buffer,
        IN ULONG Length,
        IN BOOLEAN WritePCISpace
        );
    #define HalReadPCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length) \
        HalReadWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length, FALSE)
	#define HalWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length) \
		HalReadWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length, TRUE)

	DECLSPEC_IMPORT
    void*
    WINAPI
    MmMapIoSpace(
        IN ULONG_PTR PhysicalAddress,
        IN SIZE_T NumberOfBytes,
        IN ULONG Protect
        );

    DECLSPEC_IMPORT
    void
    WINAPI
    MmUnmapIoSpace(
        IN PVOID BaseAddress,
        IN SIZE_T NumberOfBytes
        );
}

//
// Mapped virtual address of ROM region
//

PVOID KernelRomBase;

// SIZE_T
// FlashSize(
//     IN FlashDeviceID ID
//     )
// ++
//
// Routine Description:
//
//     This macro returns size of flash ROM specified by device identifier id
//
// Arguments:
//
//     ID - Device identifier returned by FlashDetectDevice
//
// Return Value:
//
//     Size of flash ROM for specified device
//
// --

#define FlashSize( ID )         FlashSizeMap[(ID)]

SIZE_T FlashSizeMap[] = {
    0,
    512 * 1024,     // SST 49LF040 Firmware Hub
    1024 * 1024     // Generic 29F080
};

// ULONG_PTR
// FlashBaseAddress(
//     IN FlashDeviceID ID
//     )
// ++
//
// Routine Description:
//
//     This macro calculates the base address of flash ROM specified by ID,
//     based on the size of the chip
//
// Arguments:
//
//     ID - Device identifier returned by FlashDetectDevice
//
// Return Value:
//
//     Base address of flash ROM from top 4GB
//
// --

#define FlashBaseAddress( ID )  ((ULONG_PTR)(0xFFFFFFFF-FlashSize(ID)+1))

//
// Lowest possible base address of flash ROM and region size
//

#define FLASH_BASE_ADDRESS      0xFFF00000
#define FLASH_REGION_SIZE       (0xFFFFFFFF-FLASH_BASE_ADDRESS-1)

// BYTE
// FlashReadByte(
//     IN ULONG_PTR Physical
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and reads one byte from mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
// Return Value:
//
//     A read byte from specified address
//
// --

#define FlashReadByte(a) \
    (*(PBYTE)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

// VOID
// FlashWriteByte(
//     IN ULONG_PTR Physical,
//     IN BYTE Byte
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and writes one byte to mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
//     Byte - Data to be written to
//
// Return Value:
//
//     None
//
// --

#define FlashWriteByte(a, d) \
    (*(PBYTE)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS) = d)

// WORD
// FlashReadWord(
//     IN ULONG_PTR Physical
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and reads two bytes from mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
// Return Value:
//
//     Two byte from specified address
//
// --

#define FlashReadWord(a) \
    (*(PWORD)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

// VOID
// FlashWriteWord(
//     IN ULONG_PTR Physical,
//     IN WORD Word
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and writes two bytes to mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
//     Word - Data to be written to
//
// Return Value:
//
//     None
//
// --

#define FlashWriteWord(a, d) \
    (*(PWORD)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS) = d)

FlashStatus
FlashGetStatus(
    IN FlashDeviceID ID,
    IN ULONG_PTR Address OPTIONAL,
    IN BYTE Data
    )
/*++

Routine Description:

    This routine checks status of flash chip using data# polling method.
    The data# polling bit, DQ7, indicates whether the Embeded Algorithm
    is in progress or completed.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

    Address - Physical address of flash ROM to be checked

    Data - Expected data at specified address

Return Value:

    Status of flash chip, see the definition of FlashStatus above.

--*/
{
    UCHAR retry=1, d, t;

    if ( !ARGUMENT_PRESENT(Address) ) {
        Address = FlashBaseAddress( ID );
    }

    if ( ID == FlashSST49LF040 ) {

        //
        // SST doesn't support Exceeded Timing Limits, DQ5
        //

        d = FlashReadByte(Address) & 0x80;
        t = Data & 0x80;

        if ( t == d ) {
            return FlashStatusReady;
        } else {
            return FlashStatusBusy;
        }

    } else {

again:
        d = FlashReadByte(Address) & 0x80;
        t = Data & 0x80;

        if ( t == d ) {
            return FlashStatusReady;        // data matches
        } else if ( d & 0x20 ) {            // Timeout?
            d = FlashReadByte(Address) & 0x80;
            if ( t == d ) {
                return FlashStatusReady;    // data matches
            }
            if ( retry-- ) {
                goto again;                 // may have been write completion
            }
            return FlashStatusTimeout;
        }

        if ( retry-- ) {
            goto again;                     // may have been write completion
        } else {
            return FlashStatusError;
        }
    }
}

VOID
FlashResetDevice(
    VOID
    )
/*++

Routine Description:

    This routine resets flash ROM back to read mode if device is in ID command
    mode or during a program or erase operation

Arguments:

    None

Return Value:

    None

--*/
{
    FlashWriteByte( 0xFFFF5555, 0xAA );
    FlashWriteByte( 0xFFFF2AAA, 0x55 );
    FlashWriteByte( 0xFFFF5555, 0xF0 );
    KeStallExecutionProcessor( 150000 );
}

FlashDeviceID
FlashDetectDevice(
    VOID
    )
/*++

Routine Description:

    This routine detects the device and manufacturer id of flash device on
    the system.  The device on Xbus will be detected first and if no device
    detected, LPC bus will be next.

Arguments:

    None

Return Value:

    Type of flash id installed in the system or FlashUnknownDevice

--*/
{
    BYTE byte;
    BYTE id1=0, id2=0;
    BOOL FirstTime = TRUE;
    PCI_SLOT_NUMBER PCISlotNumber;
    PCI_COMMON_CONFIG Configuration;

detect:

    FlashWriteByte( 0xFFFF5555, 0xAA );
    FlashWriteByte( 0xFFFF2AAA, 0x55 );
    FlashWriteByte( 0xFFFF5555, 0x90 );

    KeStallExecutionProcessor( 1 );

    id1 = FlashReadByte( 0xFFFF0000 );
    id2 = FlashReadByte( 0xFFFF0001 );

    FlashResetDevice();

    if ( id1 == SST_ID && id2 == SST_49LF040 ) {
        return FlashSST49LF040;
    }

    if ( (id1 == AMD_ID || id1 == HYUNDAI_ID || id1 == FUJITSU_ID) && \
         id2 == GENERIC_29F080 ) {
        return FlashGeneric29F080;
    }

    if ( id1 == ST_ID && id2 == M29F080A ) {
        return FlashGeneric29F080;
    }

    if ( FirstTime == TRUE ) {

        //
        // We are here because we couldn't find any flash ROM on Xbus.
        // Next thing is to see if this is a EVT board and enable ROM
        // write bus cycle to LPC interface.  By default the write cycle
        // to ROM will drop.
        //

        FirstTime = FALSE;

        //
        // Looking for PCI-to-LPC bridge
        //

        for ( byte=0x00; byte<=0xff; byte++ ) {
            PCISlotNumber.u.AsULONG = byte;
            HalReadPCISpace( 0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration) );
            if ( Configuration.BaseClass == 6 && Configuration.SubClass == 1 ) {
                break;
            }
        }

        //
        // If it is Nvidia PCI-to-LPC bridge, enable LPC ROM write
        //

        if ( Configuration.VendorID == 0x10DE && Configuration.DeviceID == 0x01B2 ) {
            byte = 0x01;
            HalWritePCISpace( 0, PCISlotNumber.u.AsULONG, 0x45, &byte, sizeof(byte) );
            goto detect;
        }

    } else {

        //
        // If we still couldn't find any flash ROM on LPC bus, disable LPC
        // ROM write
        //

        byte = 0x00;
        HalWritePCISpace( 0, PCISlotNumber.u.AsULONG, 0x45, &byte, sizeof(byte) );
    }

    return FlashUnknownDevice;
}

BOOL
FlashEraseChip(
    FlashDeviceID ID
    )
/*++

Routine Description:

    This routine erase the content of entire flash ROM to 0xFF.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

Return Value:

    TRUE if operation success, FALSE otherwise

--*/
{
    ULONG_PTR FlashPtr;
    BOOL fBlank = FALSE;
    SIZE_T Count, Retries=5;

    while ( Retries-- ) {

        FlashWriteByte( 0xFFFF5555, 0xAA );
        FlashWriteByte( 0xFFFF2AAA, 0x55 );
        FlashWriteByte( 0xFFFF5555, 0x80 );
        FlashWriteByte( 0xFFFF5555, 0xAA );
        FlashWriteByte( 0xFFFF2AAA, 0x55 );
        FlashWriteByte( 0xFFFF5555, 0x10 );

        FlashPtr = ~0L;

        //
        // Wait until flash chip is ready and completely erased.
        //

        Count = 0x100000;
        while ( FlashGetStatus(ID, FlashPtr, 0xFF) != FlashStatusReady && Count ) {
            Count--;
        }

        //
        // For some reasons in the FIB DVT, even the flash status is
        // ready but the actual data is not written to the chip.
        // We just have to poll the actual data and spin for a while
        // if it didn't get through.
        //

        Count = 0x100000;
        while ( FlashReadByte(FlashPtr) != 0xFF && Count ) {
            KeStallExecutionProcessor( 150000 );
            Count--;
        }

        //
        // Perform a blank check by compare all the content with 0xFF
        //

        Count = FlashSize( ID );
        FlashResetDevice();
        FlashPtr = FlashBaseAddress( ID );

        ASSERTMSG( "Size of flash ROM must be power of two", (Count & (Count-1)) == 0 );

        while ( Count ) {
            if ( FlashReadWord(FlashPtr) != 0xFFFF ) {
                DbgPrint( "FLASH: blank check failed (retries=%d)\n", Retries );
                break;
            }

            Count -= sizeof(WORD);
            FlashPtr += sizeof(WORD);
        }

        if ( Count == 0 ) {
            fBlank = TRUE;
            break;
        }

        FlashResetDevice();
    }

    return fBlank;
}

BOOL
FlashProgramImage(
    IN FlashDeviceID ID,
    IN PVOID ImageBuffer
    )
/*++

Routine Description:

    This routine programs the content of flash ROM with new image.  The flash
    ROM has to be blank first before programming.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

    ImageBuffer - Buffer contains the content to be programmed

Return Value:

    TRUE if operation success, FALSE otherwise

--*/
{
    BYTE b;
    PBYTE pb;
    PWORD pw;
    //ULONG TimeOut;
    ULONG_PTR FlashPtr;
    //BYTE TrueData, CurrData;
    //BOOL Loop, 
	BOOL fSuccess = FALSE;
    SIZE_T Count, Retries = 5;
    SIZE_T Again;

    while ( Retries-- ) {

        Count = FlashSize( ID );
        pb = (PBYTE)ImageBuffer;
        FlashPtr = FlashBaseAddress( ID );

        while ( Count-- ) {

            b = *pb++;

            if ( b != 0xFF ) {
                FlashWriteByte( 0xFFFF5555, 0xAA );
                FlashWriteByte( 0xFFFF2AAA, 0x55 );
                FlashWriteByte( 0xFFFF5555, 0xA0 );
                FlashWriteByte( FlashPtr, b );

                //
                // Wait until flash chip is ready for next command
                //

                Again = 0x100000;
                while ( FlashGetStatus(ID, FlashPtr, b) != FlashStatusReady && Again ) {
                    Again--;
                }

                //
                // For some reasons in the FIB DVT, even the flash status is
                // ready but the actual data is not written to the chip.
                // We just have to poll the actual data and spin for a while
                // if it didn't get through.
                //

                Again = 0x100000;
                while ( FlashReadByte(FlashPtr) != b && Again ) {
                    Again--;
                }
            }

            FlashPtr++;
        }

        //
        // Verify the content that just has been programmed
        //

        Count = FlashSize( ID );
        pw = (PWORD)ImageBuffer;
        FlashPtr = FlashBaseAddress( ID );
        FlashResetDevice();

        while ( Count ) {
            if ( FlashReadWord(FlashPtr) != *pw++ ) {
                DbgPrint( "FLASH: verification failed (retries=%d)\n", Retries );
                break;
            }

            Count -= sizeof(WORD);
            FlashPtr += sizeof(WORD);
        }

        if ( Count == 0 ) {
            fSuccess = TRUE;
            break;
        }

        FlashResetDevice();
    }

    return fSuccess;
}

UINT64
FASTCALL
FlashReadMSR(
    IN ULONG Address
    )
/*++

Routine Description:

    This routine reads Pentium III Model-Specific Register (MSR) specified
    by Address

Arguments:

    Address - Register address to read

Return Value:

    64-bit value of specified MSR

--*/
{
    __asm {
        rdmsr
    }
}

VOID
FASTCALL
FlashWriteMSR(
    IN ULONG Address,
    IN UINT64 Value
    )
/*++

Routine Description:

    This routine writes Pentium III Model-Specific Register (MSR) specified
    by Address

Arguments:

    Address - Register address to read

    Value - 64-bit value to be written

Return Value:

    None

--*/
{
    __asm {
        mov     eax, DWORD PTR [Value]
        mov     edx, DWORD PTR [Value+4]
        wrmsr
    }
}

#ifdef FLASH_TIME

UINT64
FlashReadTSC(
    VOID
    )
/*++

Routine Description:

    This routine reads processor's time-stamp counter.  The time-stamp counter
    is contained in a 64-bit MSR.  The high-order of 32 bits MSR are loaded
    into the EDX register, and the low-order 32 bits are loaded into the EAX
    register.  The processor increments the time-stamp counter MSR every
    clock cycle and resets it to 0 whenever the processor reset.

Arguments:

    None

Return Value:

    64-bit MSR of time-stamp counter

--*/
{
    __asm {
        rdtsc
    }
}

#endif // FLASH_TIME

VOID
FlashChangeRomCaching(
    BOOL EnableCache
    )
/*++

Routine Description:

    This routine searches for ROM cache setting in MTRR and disable it.  It is
    necessary to disable and flash cache before changing MTRR.  The following
    steps are recommended by Intel in order to change MTRR settings. Save CR4,
    disable and flush processor cache, flush TLB, disable MTRR, change MTRR
    settings, flush cache and TLB, enable MTRR and restore CR4

Arguments:

    EnableCache - TRUE to enable caching, FALSE to disable

Return Value:

    None

--*/
{
    ULONG MTRR;
    UINT64 v, MTRRdeftype;
    ULONG Base, Type;


    __asm {
        push    ecx
        push    edx

        _emit   0fh                 ; mov  eax, cr4
        _emit   20h
        _emit   0e0h

        push    eax                 ; save content of cr4

        mov     eax, cr0            ; disable and flush cache
        push    eax                 ; save content of cr0
        or      eax, 060000000H
        mov     cr0, eax
        wbinvd

        mov     eax, cr3            ; flush TLB
        mov     cr3, eax
    }

    //
    // Save the content of MTRR deftype and disable MTRR
    //

    MTRRdeftype = FlashReadMSR( 0x2FF );
    FlashWriteMSR( 0x2FF, 0 );

    for ( MTRR=0x200; MTRR<0x20F; MTRR+=2 ) {
        v = FlashReadMSR( MTRR );
        Base = (ULONG)((v >> 12) & 0xFFFFFF);
        Type = (BYTE)v;

        //
        // Set or reset valid bit according to cache enable flag
        //

        if ( Base >= (FLASH_BASE_ADDRESS >> 12) && Type != 0 ) {
            v = FlashReadMSR( MTRR+1 );
            v = EnableCache ? (v | 0x800) : (v & (~0x800));
            FlashWriteMSR( MTRR+1, v );
        }
    }

    __asm {
        wbinvd                      ; flush cache
        mov     eax, cr3            ; flush TLB
        mov     cr3, eax
    }

    //
    // Restore content of MTRR deftype, MTRR should be re-enabled
    //

    FlashWriteMSR( 0x2FF, MTRRdeftype );

    __asm {
        pop     eax                 ; restore cr0
        mov     cr0, eax

        pop     eax                 ; restore cr4

        _emit   0fh                 ; mov  cr4, eax
        _emit   22h
        _emit   0e0h

        pop     edx
        pop     ecx
    }
}

HRESULT
FlashKernelImage(
    IN  PVOID  ImageBuffer,
    IN  SIZE_T ImageSize,
    OUT LPSTR  szResp,
    IN  DWORD  cchResp
    )
{
#ifdef FLASH_TIME
    UINT64 ClockTick;
#endif

    FlashDeviceID ID;
    HRESULT hr = S_OK;

#ifdef FLASH_TIME
    ClockTick = FlashReadTSC();
#endif

    if ( IsBadReadPtr(ImageBuffer, ImageSize) || \
         IsBadWritePtr(szResp, cchResp) ) {
        return HRESULT_FROM_WIN32( ERROR_NOACCESS );
    }

    //
    // Map top 1MB of physical memory of ROM region (FFF00000-FFFFFFFF)
    //

    KernelRomBase = MmMapIoSpace( FLASH_BASE_ADDRESS, FLASH_REGION_SIZE,
                                  PAGE_READWRITE | PAGE_NOCACHE );

    if ( !KernelRomBase ) {
        _snprintf( szResp, cchResp, "unable to map i/o space" );
        return E_FAIL;
    }

    __asm cli

    XDBGWRN("LABPUSHER", "FLASH: interrupts are now disabled" );

    //
    // Disable ROM caching
    //

    FlashChangeRomCaching( FALSE );

    ID = FlashDetectDevice();

    if ( ID == FlashUnknownDevice ) {
        _snprintf( szResp, cchResp, "Unknown flash device id" );
        hr = E_FAIL;
        goto cleanup;
    }

    if ( FlashSize(ID) != ImageSize ) {
        _snprintf( szResp, cchResp, "Invalid image size" );
        hr = E_FAIL;
        goto cleanup;
    }

    XDBGWRN("LABPUSHER", "FLASH: erasing and blank checking..." );

    if ( !FlashEraseChip(ID) ) {
        _snprintf( szResp, cchResp, "Failed to erase flash chip" );
        hr = E_FAIL;
        goto cleanup;
    }

    XDBGWRN("LABPUSHER", "FLASH: programming..." );

    if ( !FlashProgramImage(ID, ImageBuffer) ) {
        _snprintf( szResp, cchResp, "Failed to program kernel image (verify failed)" );
        hr = E_FAIL;
        goto cleanup;
    }

    XDBGWRN("LABPUSHER", "FLASH: done" );

    if ( SUCCEEDED(hr) ) {
        _snprintf( szResp, cchResp, "Done, new image flashed" );
    }

    hr = S_OK;

cleanup:

    __asm sti

    XDBGWRN("LABPUSHER", "FLASH: interrupts are now enabled" );

    MmUnmapIoSpace( KernelRomBase, FLASH_REGION_SIZE );

    //
    // Re-enable ROM caching as needed
    //

    FlashChangeRomCaching( TRUE );

#ifdef FLASH_TIME
    ClockTick = FlashReadTSC() - ClockTick;
    DbgPrint( "FLASH: elapsed time %I64u seconds\n", ClockTick / 733000000UI64 );
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labpusher\XbServer\xbserver.h ===
/*************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

	xbserver.h

  Abstract:

	Defines the Xbox server side for the LabPusher tool.

  Author:

	Mabel Santos (t-msanto) 03-Dec-2001

  Revision History:

*************************************************************************************************/

#ifndef _XBSERVER_H_
#define _XBSERVER_H_

#define NTLEANANDMEAN
#ifndef _X86_
#define _X86_
#endif
#define _WIN32_WINNT 0x0500

#define _HAL_
#define _MM_
#define _IO_
#define _FSCACHE_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <scsi.h>
#include <ntddscsi.h>
#include <ntos.h>
#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <xbdm.h>
#include <winsockx.h>
#include "..\..\..\..\ntos\recovery\recovpch.h"
#include "..\..\dvdread\bitfont.h"

#include <assert.h>
#include <D3DX8Math.h>
#ifdef _XBOX
#include <xgraphics.h>
#endif

#define PORT 2000
#define BUFFLEN 1024
#define ROM_SIZE (1024 * 1024)
#define ROM_FLASH_RETRIES 25

enum PacketTypes{ FLASHCMD = 1, KRNLNOTE, FILEDESC, FILEDATA, FINISHCMD };
enum ErrorCodes{ PKTERROR = 1, CHKSMERROR, DIRERROR, FILEERROR, KRNLERROR, FLASHERROR };

// network packet structures

struct FilePacketHeader
{
	unsigned char PacketType;
	unsigned long SequenceNo;
	unsigned long FileSize;
	unsigned short DataSize;
	unsigned long Crc;
};

struct FilePacket : public FilePacketHeader
{
	char Data[BUFFLEN];
};

class XbServer
{
private:
	// socket for network communication
	SOCKET ServerSock;

	// flag to indicate whether WinSock has been initialized
	BOOL WsaInitialized;

	// flag to indicate whether an error has occurred
	int ErrorFlag;

	// flag to indicate when a successful ROM flash has occurred
	BOOL ExitFlag;

	// total number of bytes to be received
	unsigned long TotalBytes;

	// number of bytes received so far
	unsigned long RecvdBytes;

	// sequence number of current file's description packet
	DWORD BasePkt;

	// number of packets needed for current file
	DWORD NumPkts;
	
	// number of packets received for current file
	DWORD RecvdPkts;

	// stream for writing files to hard drive
	FILE* OutFile;

	// buffer for holding kernel data
	char KernelBuf[ROM_SIZE];

	// index of current position in kernel buffer
	int KernelPos;

public:
	// buffer for holding Xbox name
	char NameBuf[BUFFLEN];

	XbServer(void);
	~XbServer(void);
	BOOL PrepareWinSock(void);
	BOOL FormatDrives(void);
	void MapDrives(void);
	BOOL SendReply(void);
	void RecvFiles(void);
	void ReadPacket(FilePacket* Packet);
	BOOL CheckPkts(void);
	void StartFile(DWORD FileSize, DWORD PktNum);
	BOOL CreateDirs(char* PathName);
	void FlashROM(void);
	void UnMapDrives(void);
	void FlashLED(void);
	DWORD GetCRC(unsigned char* Data, WORD Size);
};

extern XbServer* Server;
extern int DebugOn;

// debug output
void DebugPrint(char* ptszFormat, ...);

// setting LED colors
NTSTATUS WriteSMC(unsigned char addr, unsigned char value);

// mapping drives
DWORD MapDrive( char cDriveLetter, char* pszPartition );
DWORD UnMapDrive( char cDriveLetter );

// flashing ROM
HRESULT
FlashKernelImage(
    IN  PVOID  ImageBuffer,
    IN  SIZE_T ImageSize,
    OUT LPSTR  szResp,
    IN  DWORD  cchResp
    );

// graphics output
WCHAR* Ansi2UnicodeHack(char *str);
HRESULT InitGraphics(void);
void GraphicPrint(char* format, ...);

extern IDirect3D8*		    g_d3d;
extern IDirect3DDevice8*	g_pDevice;
extern BitFont				g_font;
extern IDirect3DTexture8*	g_pd3dtText;
extern TVertex				g_prText[4];
extern D3DLOCKED_RECT		g_d3dlr;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\csockserver.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    CSockServer.h

Abstract:

    This class will allow the creation of the Winsock Server object that
    can send and receive data within it's own thread.

Author:

    Jim Helm (jimhelm)
    Josh Poley (jpoley)

Environment:

    XBox


*/
#ifndef _CSOCKSERVER_H_
#define _CSOCKSERVER_H_

#include "stdafx.h"
#include <winsockx.h>
#include "CWorkerThread.h"

namespace Launcher {

class CSockServer : public CWorkerThread
    {
    private:
        SOCKET m_socket;                                        // Socket used to "listen" for connections
        SOCKET m_remotesocket;                                  // Socket returned by "accepted" connections
        sockaddr_in m_sockaddr;                                 // Our Sock Address structure
        USHORT m_port;                                          // Port of our current server
        unsigned m_uTimeoutSec;                                 // idle timeout length

        int GetSocket(int af=AF_INET,
                    int socktype=SOCK_STREAM,
                    int protocol=IPPROTO_TCP);                  // Get our socket

    public:
        int m_socktype;

    public:
        CSockServer();                                          // Constructor
        ~CSockServer();                                         // Destructor

    public:
        virtual DWORD ThreadFunct(void);                        // Thread function to handle accepting connections

    public:
        int BindSocket();                                       // Bind or Name our socket
        int OpenServerSocket(int socktype);                     // Create the socket for our server
        int CloseSocket(SOCKET s);                              // Close our socket
        BOOL IsDataAvailable(SOCKET s);

        USHORT GetPort(void) { Lock(); USHORT usTemp = m_port; Unlock(); return (usTemp); }
        void SetPort(USHORT usNewPort) { Lock(); m_port = usNewPort; Unlock(); }
        unsigned GetTimeout(void) { Lock(); unsigned usTemp = m_uTimeoutSec; Unlock(); return (usTemp); }
        void SetTimeout(unsigned timeout) { Lock(); m_uTimeoutSec = timeout; Unlock(); }
    };

} // namespace Launcher 

#endif // _CSOCKSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\csockserver.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    CSockServer.cpp

Abstract:

    This class will allow the creation of the Winsock Server object that
    can send and receive data within it's own thread.

Author:

    Jim Helm (jimhelm)
    Josh Poley (jpoley)

Environment:

    XBox

*/
#include "stdafx.h"
#include "CSockServer.h"
#include "launcher.h"
#include "launcherx.h"

namespace Launcher {

CSockServer::CSockServer()
    {
    m_port = 20;
    m_socket = NULL;
    m_remotesocket = NULL;
    m_socktype = SOCK_STREAM;
    m_uTimeoutSec = 60;

    XNetAddRef();

    WSADATA wsaData;
    unsigned short version = MAKEWORD(2, 2);
    WSAStartup(version, &wsaData);
    }

CSockServer::~CSockServer()
    {
    CloseSocket(m_socket);
    WSACleanup();
    XNetRelease();
    }

int CSockServer::BindSocket()
    {
    int nReturnVal=0;						// Return Value for BindSocket()

    m_sockaddr.sin_family = AF_INET;
    m_sockaddr.sin_port = htons(GetPort());
    m_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    nReturnVal = bind(m_socket, (LPSOCKADDR)&m_sockaddr, sizeof(SOCKADDR));
    if(SOCKET_ERROR == nReturnVal)
        {
        //nReturnVal = WSAGetLastError();
        DebugPrint("BindSocket: WS Last Error : %d\n", WSAGetLastError());
        }

    return (nReturnVal);
    }


// Close our Socket
int CSockServer::CloseSocket(SOCKET s)
    {
    Lock();
    if(NULL == s)
        {
        s = m_socket;
        }

    // Shutdown the socket (will fail if not connected)
    shutdown(s, SD_BOTH);

    // Close the socket
    closesocket(s);
    Unlock();

    return 0;
    }


// Get our Socket
int CSockServer::GetSocket(int af, int socktype, int protocol)
    {
    int nReturnVal=0;		// Return value for GetSocket()

    m_socket = socket(af, socktype, protocol);
    if(INVALID_SOCKET == m_socket)
        {
        //nReturnVal=WSAGetLastError();
        DebugPrint("GetSocket Last WS Error: %s\n", WSAGetLastError());
        }

    return nReturnVal;
    }


// Create our server socket
int CSockServer::OpenServerSocket(int socktype)
    {
    int nReturnVal;
    
    if(socktype == SOCK_DGRAM) nReturnVal = GetSocket(AF_INET, socktype, 0);
    else nReturnVal = GetSocket(AF_INET, socktype, IPPROTO_TCP);

    return nReturnVal;
    }

BOOL CSockServer::IsDataAvailable(SOCKET s)
    {
    TIMEVAL timeout = { m_uTimeoutSec, 0 };
    FD_SET bucket;
    bucket.fd_count = 1;
    bucket.fd_array[0] = s;

    int err = select(0, &bucket, NULL, NULL, &timeout);
    if(err == 0 || err == SOCKET_ERROR)
        {
        return FALSE;
        }

    return TRUE;
    }

// Thread code for our Winsock Server
DWORD CSockServer::ThreadFunct(void)
    {
	DWORD nReturnVal=0;				// Return Value of ThreadFunct()

	while(!GetExitFlag())
        {
        if(m_socktype == SOCK_STREAM)
            {
            if(SOCKET_ERROR == listen(m_socket, 1))
                {
                DebugPrint("LAUNCHER: listen failed: ec=%lu\n", WSAGetLastError());
                break;
                }
            else
                {
                DebugPrint("LAUNCHER: Waiting for a connection on port %u...\n", GetPort());
                m_remotesocket = accept(m_socket, NULL, NULL);
                if(INVALID_SOCKET == m_remotesocket)
                    {
                    DebugPrint("LAUNCHER: connection failed: ec=%lu\n", WSAGetLastError());
                    continue;
                    }
                else
                    {
                    Parser(m_remotesocket, this);
                    CloseSocket(m_remotesocket);
                    }
                }
            }
        else // socktype == SOCK_DGRAM (broadcast monitor)
            {
            /*
            // TODO this can become a broadcast to publish our IP address
            int err;
            char buffer[1024];
            SOCKADDR_IN dest;
            int addrsize=sizeof(SOCKADDR);
            TIMEVAL timeout;
            FD_SET bucket;
            bucket.fd_count = 1;
            bucket.fd_array[0] = m_socket;
            timeout.tv_sec = 5;
            timeout.tv_usec = 0;
    
            err = select(0, &bucket, NULL, NULL, &timeout);
            if(err == 0 || err == SOCKET_ERROR) continue;

            err = recvfrom(m_socket, buffer, 1024, 0, (SOCKADDR*)&dest, &addrsize);
            if(err>0) buffer[err] = '\0';
            else continue;

            char hello[32]; hello[0] = '0';
            char thekey[1024]; thekey[0] = '0';
            sscanf(buffer, "%s %[^\n\r]", hello, thekey);

            sendto(m_socket, buffer, strlen(buffer), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR));
            */
            }
        }

    return nReturnVal;
    }

} // namespace Launcher
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labpusher\XbServer\graphics.cpp ===
/*****************************************************************************

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    graphics.cpp

	Derived from \private\test\tools\dvdread\bitfont.cpp
	             \private\test\tools\dvdread\gui.cpp
			     \private\test\tools\dvdread\utils.cpp

	Author: Josh Poley (jpoley)

Abstract:

    Defines functions needed to display graphics output on the Xbox.

*****************************************************************************/

#include "xbserver.h"

IDirect3D8*		    g_d3d;
IDirect3DDevice8*	g_pDevice;
BitFont				g_font;
IDirect3DTexture8*	g_pd3dtText;
TVertex				g_prText[4];
D3DLOCKED_RECT		g_d3dlr;


DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef _XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef _XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef _XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

/*****************************************************************************

Routine Description:

    Ansi2UnicodeHack

    In-place Pseudo Ansi to Unicode (char to wide char) conversion.

Arguments:

    IN char* str - char string to convert to wide char string

Return Value:

    WCHAR* - pointer to Unicode string

Note:
    
    Because a bunch of Unicode functions expect a WCHAR string to be on an
    even boundry, the returned string may be moved 1 character over.

*****************************************************************************/

WCHAR* Ansi2UnicodeHack(char *str)
    {
    if(!str) return NULL;

    int align = 0;
    int len = strlen(str)+1;

    // put string on an even boundry because some freak put a bunch of ASSERTs
    // that check for even boundries in Unicode functions like 
    // RtlEqualUnicodeString()
    if(((DWORD)str & 1) != 0)
        {
        align = 1;
        }

    for(; len>=0; len--)
        {
        str[len*2+align] = str[len];
        str[len*2+align+1] = '\0';
        }

    str += align;

    return (WCHAR*)str;
    }

HRESULT InitGraphics(void)
    {
    HRESULT	hr;
    D3DPRESENT_PARAMETERS d3dpp;
    int i;
    
    // Create an instance of a Direct3D8 object 
    g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
    if(g_d3d == NULL)
        return E_FAIL;
    
    // Setup the present parameters: 640x480x24
    ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth					= 640;
    d3dpp.BackBufferHeight					= 480;
    d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount					= 1;
    d3dpp.Flags								= 0;
    d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
    d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow						= NULL;
    d3dpp.Windowed							= FALSE;
    d3dpp.EnableAutoDepthStencil			= TRUE;
    d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
    d3dpp.Flags								= 0;
    d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;
    
    // Create the device
    hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDevice);
    if(FAILED(hr))
        return hr;
    
    // Create a buffer for the text
    hr = g_pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &g_pd3dtText);
    if(FAILED(hr))
        return hr;
    
    // Text plane
    g_prText[0].x = 0.0f;
    g_prText[0].y = 480.0f;
    g_prText[0].u = 0.0f;
    g_prText[0].v = 240.0f;
    g_prText[1].x = 0.0f;
    g_prText[1].y = 0.0f;
    g_prText[1].u = 0.0f;
    g_prText[1].v = 0.0f;
    g_prText[2].x = 640.0f;
    g_prText[2].y = 0.0f;
    g_prText[2].u = 320.0f;
    g_prText[2].v = 0.0f;
    g_prText[3].x = 640.0f;
    g_prText[3].y = 480.0f;
    g_prText[3].u = 320.0f;
    g_prText[3].v = 240.0f;
    
    for(i=0; i<4; i++) 
        {
        g_prText[i].z	= 0.0f;
        g_prText[i].rhw	= 1.0f;
        }
    
    // Setup stuff
    g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
    g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
    g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
    g_pDevice->SetTexture(0, g_pd3dtText);
    g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);
    
    return S_OK;
    }

void GraphicPrint(char* format, ...)
    {
    IDirect3DSurface8*	pd3ds;

    // Clear the device
    g_pDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff000000, 1.0f, 0);

    // Clear the texture
    g_pd3dtText->LockRect(0, &g_d3dlr, NULL, 0);
    for(unsigned i=0; i<240; i++)
        memset((LPBYTE)g_d3dlr.pBits + i * g_d3dlr.Pitch, 0, 320 * 4);
    g_pd3dtText->UnlockRect(0);

    // Get the surface to draw the text to
    g_pd3dtText->GetSurfaceLevel(0, &pd3ds);

	char szBuffer[256];

    va_list args;
    va_start(args, format);

    vsprintf(szBuffer, format, args);

    WCHAR *ptr = Ansi2UnicodeHack(szBuffer);

    g_font.DrawText(pd3ds, ptr, 25, 20, 0, 0xFFFFFFFF, 0);

    // Release the surface
    pd3ds->Release();

    // Draw the textured primitive (with the text)
    g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));

    // End the scene and present it
    g_pDevice->EndScene();
    g_pDevice->Present(NULL, NULL, NULL, NULL);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\cworkerthread.cpp ===
/*

Copyright (C) 1999 Microsoft Corporation

Module Name:

    CWorkerThread.cpp

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

*/


#include "stdafx.h"
#include "CWorkerThread.h"

namespace Launcher {

/*****************************************************************************

Routine Description:

    LocalThreadFunct

Arguments:

    LPVOID lpParameter  - a valid CWorkerThread class

Return Value:

    0 on error, ~0 on execption, or the thread's exit value

Notes:


*****************************************************************************/
static DWORD WINAPI LocalThreadFunct(LPVOID lpParameter)
    {
    DWORD returnCode = 0;
    HWND window = NULL;
    UINT msg = 0;
    LPARAM lparam = 0;
    CWorkerThread *localPointer = (CWorkerThread*)lpParameter;

    if(!localPointer)
        {
        // a valid CWorkerThread class must be supplied via the lpParameter!
        //_ASSERT(localPointer);
        return 0;
        }

    // turn off the exit flag and set notification values
    localPointer->Lock();
    localPointer->bExit = FALSE;
    window = localPointer->notifyWindow;
    msg = localPointer->notifyMsg;
    lparam = localPointer->notifylParam;
    localPointer->Unlock();

    // set the thread id
    localPointer->SetThreadID(GetCurrentThreadId());

    // run the main thread function (this is the custom function)
#ifdef _DEBUG
    returnCode = localPointer->ThreadFunct();
#else
    //try
        {
        returnCode = localPointer->ThreadFunct();
        }
    //catch(...)
    //    {
    //    returnCode = ~0;
    //    }
#endif

    // invalidate the thread handle & id
    localPointer->SetThreadID(~0);
    localPointer->SetThreadHandle(~0);

    // store the return code from the main thread function
    localPointer->Lock();
    localPointer->dwThreadExitCode = returnCode;
    localPointer->Unlock();

    // send notification if necessary
    if(window)
        {
        //PostMessage(window, msg, (WPARAM)returnCode, lparam);
        }

    // exit thread
    return returnCode;
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::Run
    start up a worker thread

Arguments:

    none

Return Value:

    none

Notes:

*****************************************************************************/
void CWorkerThread::Run(void)
    {
    DWORD handle = _beginthread((void (__cdecl *)(void *))LocalThreadFunct, 0, this);
    SetThreadHandle(handle);
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::CWorkerThread
    worker thread data constructor

Arguments:

    none

Return Value:

    none

Notes:

*****************************************************************************/
CWorkerThread::CWorkerThread()
    {
    InitializeCriticalSection(&criter);
    SetThreadHandle(~0);
    SetThreadID(~0);

    Lock();

    notifyWindow = NULL;
    notifyMsg = 0;
    notifylParam = 0;

    dwLocalThreadID = 0;

    bExit = FALSE;
    dwThreadExitCode = 0;

    Unlock();
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::CWorkerThread
    worker thread data constructor

Arguments:

    DWORD localID

Return Value:

    none

Notes:

*****************************************************************************/
CWorkerThread::CWorkerThread(DWORD localID)
    {
    InitializeCriticalSection(&criter);
    SetThreadHandle(~0);
    SetThreadID(~0);

    Lock();

    notifyWindow = NULL;
    notifyMsg = 0;
    notifylParam = 0;
    
    dwLocalThreadID = localID;

    bExit = FALSE;
    dwThreadExitCode = 0;

    Unlock();
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::~CWorkerThread
    worker thread data destructor

Arguments:

    none

Return Value:

    none

Notes:

    If the thread does not exit, this function will be caught in an infinate 
        loop.

*****************************************************************************/
CWorkerThread::~CWorkerThread()
    {
    if(GetThreadHandle() != ~0)
        {
        DWORD timeout = 1000; // start with 1 sec

        // if your code infinite loops here, you have a blocking problem
        while(!SoftBreak(timeout))
            {
            timeout *= 2;
            if(timeout == 64000) OutputDebugStringA("CWorkerThread::~CWorkerThread(): Possible deadlock\n");
            }
        }

    DeleteCriticalSection(&criter);
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::SoftBreak

Arguments:

    DWORD dwTimeOut - timeout value in ms

Return Value:

    TRUE - the thread exited, FALSE - timedout before the thread exited

Notes:

*****************************************************************************/
BOOL CWorkerThread::SoftBreak(DWORD dwTimeOut)
    {
    Lock();
    bExit = TRUE;
    Unlock();

    return WaitForExit(dwTimeOut);
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::HardBreak

Arguments:

    none

Return Value:

    TRUE - operation succedded, FALSE - the operation failed.

Notes:

    This function does not perform any locking or unlocking.

    WARNING: Do not use this function execpt in DIRE situations. This WILL 
        cause leaks, and perhaps blocking or crashes if critical sections 
        are not released!

*****************************************************************************/
BOOL CWorkerThread::HardBreak(void)
    {
    DWORD dwHandle = dwThreadHandle;
    bExit = TRUE;
    dwThreadHandle = ~0;
    dwThreadExitCode = ~0;
    dwThreadID = ~0;

    if(dwHandle != ~0)
        {
        OutputDebugStringA("CWorkerThead::HardBreak() called!\n");
        //
        // schanbai 11/20/2000
        // comment out as there is no TerminateThread under Xbox
        //
#if 0
        return TerminateThread((void*)dwHandle, ~0);
#else
        return FALSE;
#endif
        }

    return FALSE;
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::WaitForExit

Arguments:

    DWORD dwTimeOut - timeout value in ms

Return Value:

    TRUE - the thread exited, FALSE - timeout was reached

Notes:

*****************************************************************************/
BOOL CWorkerThread::WaitForExit(DWORD dwTimeOut)
    {
    DWORD dwStartTime = GetTickCount();
    DWORD dwCurTime;

    while(GetThreadHandle() != ~0)
        {
        Sleep(20);
        dwCurTime = GetTickCount();
        if(dwCurTime - dwStartTime >= dwTimeOut)
            {
            return FALSE;
            }
        }

    return TRUE;
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::Lock

Arguments:

    DWORD dwTimeOut - timeout value in ms
   
Return Value:

    TRUE - critical section entered, FALSE - timeout

Notes:

*****************************************************************************/
#ifdef _WIN32_WINNT // TryEnterCriticalSection only available on NT
#include "winbase.h"
BOOL CWorkerThread::Lock(DWORD dwTimeOut)
    {
    DWORD dwStartTime = GetTickCount();
    DWORD dwCurTime;

    while(!TryEnterCriticalSection(&criter))
        {
        Sleep(20);
        dwCurTime = GetTickCount();
        if(dwCurTime - dwStartTime >= dwTimeOut)
            {
            return FALSE;
            }
        }

    return TRUE;
    }
#endif


/*****************************************************************************

Routine Description:

    CWorkerThread::SetExitNotify

Arguments:

    HWND   notifyDestination  - handle to the destination window
    UINT   message            - the message to send
    LPARAM lParam             - custom parameter to send

Return Value:

    none

Notes:

    WPARAM of the message is always the return code for the thread

*****************************************************************************/
void CWorkerThread::SetExitNotify(HWND notifyDestination, UINT message, LPARAM lParam)
    {
    Lock();
    notifyWindow = notifyDestination;
    notifyMsg = message;
    notifylParam = lParam;
    Unlock();
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::SuspendThread

Arguments:

    none

Return Value:

    DWORD - the thread's suspend count, 0xFFFFFFFF on error.

Notes:

    This function just calls the WIN API SuspendThread

*****************************************************************************/
DWORD CWorkerThread::SuspendThread(void)
    {
    DWORD dwHandle = GetThreadHandle();

    if(dwHandle != ~0)
        {
        return ::SuspendThread((void*)dwHandle);
        }

    return 0xFFFFFFFF;
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::ResumeThread

Arguments:

    none

Return Value:

    DWORD - the thread's suspend count, 0xFFFFFFFF on error.

Notes:

    This function just calls the WIN API ResumeThread

*****************************************************************************/
DWORD CWorkerThread::ResumeThread(void)
    {
    DWORD dwHandle = GetThreadHandle();

    if(dwHandle != ~0)
        {
        return ::ResumeThread((void*)dwHandle);
        }

    return 0xFFFFFFFF;
    }
} // namespace Launcher
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\cmd.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    cmd.cpp

Abstract:

    Extra commands. See dos.cpp for dos commands.

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-31-2000  Created

*/
#include "stdafx.h"
#include <xtestlib.h>
#include <heap.h>
#include <xbox.h>
#include <stdlib.h>
#include <math.h>

#include "launcherx.h"
#include "harnessapi.h"
#include "draw.h"

namespace Launcher {


DWORD BARTEST(SOCKET sock, char *nextToken)
    {
    SockPrint(sock, "Check the video output for the bars\r\n");

    drInit();
    drCls();

    drBox(  0,  20,  79, 480, 0xFFFFFFFF);
    drBox( 80,  20, 159, 480, 0xFF777777);
    drBox(160,  20, 239, 480, BUILDARGB(0xFF, 0xFF, 0, 0));
    drBox(240,  20, 319, 480, 0xFFFFFF00);
    drBox(320,  20, 399, 480, 0xFF00FFFF);
    drBox(400,  20, 479, 480, 0xFF00FF00);
    drBox(480,  20, 559, 480, 0xFF0000FF);
    drBox(560,  20, 639, 480, 0xFFFF00FF);
    drBox(  0, 320, 639, 400, 0x77000000);
    drBox(  0, 400, 639, 480, 0x77FF0000);

    drPrintf(5, 5, L"Graphic Bar Test");
    drPrintf(2, 340, L"Black");
    drPrintf(2, 360, L"Mix");
    drPrintf(2, 420, L"Red");
    drPrintf(2, 440, L"Mix");

    drShowScreen();

    drDeinit();

    return ERR_OK;
    }


DWORD DISKIO(SOCKET sock, char *nextToken)
    {
    // DISK "IN/OUT" Test for hardware guys
    bool exit = false;

    DWORD wSize, rSize, size;
    char *wbuffer = new char[MEGABYTE*3];
    if(!wbuffer)
        {
        SockPrint(sock, "Unable to allocate memory\r\n");
        return 0;
        }

    char filename[64];
    char drive;
    char op[10];

    if(!*nextToken)
        {
        drive = 'F';
        }
    else
        {
        sscanf(nextToken, "%s %c", op, &drive);
        }
    sprintf(filename, "%c:\\IOtest.txt", drive);

    HANDLE hFile = CreateFile(filename, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        {
        SockPrint(sock, "Unable to open file: %s (ec: %ld)\r\n", filename, GetLastError());
        return 0;
        }

    SockPrint(sock, "Writing initial file: %s...\r\n", filename);
    memset(wbuffer, 0, MEGABYTE*2);
    unsigned count = 1;
    for(size=0; size<MEGABYTE*2; size+=64)
        {
        //wbuffer[size] = (char)size;
        (*(unsigned*)&wbuffer[size]) = count++;
        }
    wbuffer[MEGABYTE*2-1] = 0x0F;
    wbuffer[MEGABYTE*2-2] = 0x0F;
    wbuffer[MEGABYTE*2-3] = 0x0F;
    wbuffer[MEGABYTE*2-4] = 0x00;
    wbuffer[MEGABYTE*2-5] = 0x01;
    wbuffer[MEGABYTE*2-6] = 0x01;
    wbuffer[MEGABYTE*2-7] = 0x01;
    wbuffer[MEGABYTE*2-8] = 0x00;
    wbuffer[MEGABYTE*2-9] = 0x0F;
    wbuffer[MEGABYTE*2-10] = 0x0F;
    wbuffer[MEGABYTE*2-11] = 0x0F;

    if(! (WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size))
        {
        SockPrint(sock, "Unable to write the file (bytes: %u) (ec: %ld)\r\n", wSize, GetLastError());
        CloseHandle(hFile);
        return 0;
        }

    SockPrint(sock, "Running DISKIO (%s) - press any key to stop.\r\n", op[0]=='O'||op[0]=='o'?"OUT":"IN");
    while(!exit)
        {
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

        if(op[0]=='O' || op[0]=='o') // OUT (write)
            {
            if(WriteFile(hFile, wbuffer, size, &wSize, NULL) != TRUE)
                SockPrint(sock, "Error: WriteFile[%d] (ec: %ld)\r\n", wSize, GetLastError());
            }
        else // IN (read)
            {
            if(ReadFile(hFile, wbuffer, size, &rSize, NULL) != TRUE)
                SockPrint(sock, "Error: ReadFile[%d] (ec: %ld)\r\n", rSize, GetLastError());
            }

        // check for user interaction
        if(NetHit(sock))
            {
            exit = true;
            }
        }

    CloseHandle(hFile);

    return ERR_OK;
    }


DWORD DUMP(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "DUMP");
        return ERR_SYNTAX;
        }

    DWORD len = 0;
    const unsigned chunkSize = 1024;
    unsigned char *buff = new unsigned char[chunkSize];
    if(!buff)
        {
        SockPrint(sock, "Error: Not enough memory.\r\n");
        return ERR_NOMEM;
        }

    HANDLE hFile = CreateFile(nextToken, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        {
        SockPrint(sock, "Could not open file (ec: %lu)\r\n", GetLastError());
        delete[] buff;
        return ERR_FILE;
        }
    for(DWORD i=0; i<GetFileSize(hFile, NULL); i+=chunkSize)
        {
        ReadFile(hFile, buff, chunkSize, &len, NULL);
        HexDump(sock, buff, len, i);
        }

    CloseHandle(hFile);
    delete[] buff;

    return ERR_OK;
    }


DWORD FLUSH(SOCKET sock, char *nextToken)
    {
    FlushDiskCache();
    return ERR_OK;
    }


DWORD HELP(SOCKET sock, char *nextToken)
    {
    // individual help texts
    if(*nextToken)
        {
        for(unsigned i=0; i<commandLength; i++)
            {
            if(strcmp(commands[i].name, nextToken) == 0)
                {
                SockPrint(sock, "%s\r\n\r\n%s\r\n", commands[i].helpShort, commands[i].helpLong);
                return ERR_OK;
                }
            }
        for(i=0; i<hiddenCommandLength; i++)
            {
            if(strcmp(hiddenCommands[i].name, nextToken) == 0)
                {
                SockPrint(sock, "%s\r\n\r\n%s\r\n", hiddenCommands[i].helpShort, hiddenCommands[i].helpLong);
                return ERR_OK;
                }
            }
        }

    // print general help
    SockPrint(sock, "XBox Harness Remote Commands:\r\n");
    SockPrint(sock, "For more information on a specific command, type HELP command-name.\r\n\r\n");
    for(unsigned i=0; i<commandLength; i++)
        {
        SockPrint(sock, "%-8s %s\r\n", commands[i].name, commands[i].helpShort);
        }

    return ERR_OK;
    }


DWORD HOTPLUG(SOCKET sock, char *nextToken)
    {
    if(*nextToken)
        {
        if(_stricmp(nextToken, "1") == 0 || _stricmp(nextToken, "ON") == 0)
            usbmanager->hotplugs = true;
        else if(_stricmp(nextToken, "0") == 0 || _stricmp(nextToken, "OFF") == 0)
            usbmanager->hotplugs = false;

        SockPrint(sock, "Hot plugs are now %s\r\n", usbmanager->hotplugs?"ON":"OFF");
        return ERR_OK;
        }

    SockPrint(sock, "Hot plugs are currently %s\r\n", usbmanager->hotplugs?"ON":"OFF");

    return ERR_OK;
    }


DWORD MF(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "MF");
        return ERR_SYNTAX;
        }

    char *filename = new char[1024];
    char *pattern = new char[40];
    unsigned size;
    unsigned items;
    DWORD len;

    items = sscanf(nextToken, "%s %u %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x", filename, &size, &pattern[0], &pattern[1], &pattern[2], &pattern[3], &pattern[4], &pattern[5], &pattern[6], &pattern[7], &pattern[8], &pattern[9], &pattern[10], &pattern[11], &pattern[12], &pattern[13], &pattern[14], &pattern[15], &pattern[16], &pattern[17], &pattern[18], &pattern[19]);
    items -= 2;

    HANDLE hFile = CreateFile(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);

    if(hFile == INVALID_HANDLE_VALUE)
        {
        SockPrint(sock, "Could not open file (ec: %lu)\r\n", GetLastError());
        delete[] filename;
        delete[] pattern;
        return ERR_FILE;
        }

    for(unsigned i=0; i<size; i+=items)
        {
        if(i+items > size) items = size-i;
        if(WriteFile(hFile, pattern, items, &len, NULL) == FALSE)
            {
            SockPrint(sock, "          Write failed (ec: %lu)\r\n", GetLastError());
            break;
            }

        // check for user interaction
        if(NetHit(sock))
            {
            SockPrint(sock, "          Write failed - user interrupted.\r\n");
            break;
            }
        }

    if(i >= size)
        {
        SockPrint(sock, "          Created file: %s[%u]\r\n", filename, i);
        }

    CloseHandle(hFile);

    delete[] filename;
    delete[] pattern;

    return ERR_OK;
    }


#pragma data_seg( ".EXP$A" )
EXP_TABLE_DIRECTORY __export_table_directory_start[] = { NULL };
#pragma data_seg( ".EXP$Z" )
EXP_TABLE_DIRECTORY __export_table_directory_end[] = { NULL };
#pragma data_seg()
#pragma comment(linker, "/merge:.EXP=.export")

DWORD MODS(SOCKET sock, char *nextToken)
    {
    /*
    char *lpszModuleName_A;
    PRIVATE_HEAP_RECORD *pHeapRecords;
    DWORD dwHeap;

    // Allocate the memory for the private heap records
    pHeapRecords = new PRIVATE_HEAP_RECORD[MAX_HEAP_HANDLE_TRACKING];
    if(!pHeapRecords)
        {
        SockPrint(sock, "Error: Not enough memory.\r\n");
        return ERR_NOMEM;
        }

    // Get the private heap records
    if (FALSE == GetHeapTrackingDatabase(pHeapRecords, MAX_HEAP_HANDLE_TRACKING * sizeof(PRIVATE_HEAP_RECORD)))
        {
        SockPrint(sock, "Error: No modules found (ec: %lu).\r\n", GetLastError());
        delete[] pHeapRecords;
        return ERR_OK;
        }

    SockPrint(sock, "Available modules callable with RUN:\r\n");
    for(dwHeap = 0; dwHeap<MAX_HEAP_HANDLE_TRACKING; dwHeap++)
        {
        // Get the module name
        if(pHeapRecords[dwHeap].HeapHandle == NULL) continue;
        lpszModuleName_A = XeModuleNameFromModuleIndex(pHeapRecords[dwHeap].OwnerModuleIndex);

        // print it out if necessary
        _strlwr(lpszModuleName_A);
        if(strcmp(lpszModuleName_A, "launcher") == 0) continue;
        if(strcmp(lpszModuleName_A, "xlog") == 0) continue;
        SockPrint(sock, "   %s\r\n", lpszModuleName_A);
        }

    delete[] pHeapRecords;
    */

    PEXP_TABLE_DIRECTORY _ptbegin = __export_table_directory_start;
    PEXP_TABLE_DIRECTORY _ptend = __export_table_directory_end;

    SockPrint(sock, "Available modules callable with RUN:\r\n");
    for(; _ptbegin < _ptend; _ptbegin++)
        {
        if(!_ptbegin->ModuleName) continue;
        if(_stricmp(_ptbegin->ModuleName, "launcher") == 0) continue;

        SockPrint(sock, "   %s\r\n", _ptbegin->ModuleName);
        }

    return ERR_OK;
    }



DWORD MU(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "MU");
        return ERR_SYNTAX;
        }

    char* operation = strchr(nextToken, ' ');
    if(!operation)
        {
        HELP(sock, "MU");
        return ERR_SYNTAX;
        }
    ++operation; // skip the space

    char drive = nextToken[0];
    unsigned port = XMUPortFromDriveLetter(drive);
    unsigned slot = XMUSlotFromDriveLetter(drive);
    char deviceName[128];

    if(_stricmp(operation, "MOUNT") == 0)
        {
        slot = slot==XDEVICE_TOP_SLOT? 1 : 2;

        if(usbmanager->devices[port][slot] != NULL && usbmanager->devices[port][slot]->type != XDEVICE_TYPE_MEMORY_UNIT)
            {
            SockPrint(sock, "The port (%02X, %02X) must be empty or hold an MU!\r\n", port, slot);
            return ERR_OK;
            }

        if(usbmanager->devices[port][slot] != NULL && usbmanager->devices[port][slot]->type == XDEVICE_TYPE_MEMORY_UNIT)
            {
            SockPrint(sock, "Unmounting %c... ", drive);
            delete (DeviceMU*)(usbmanager->devices[port][slot]);
            usbmanager->devices[port][slot] = NULL;
            }

        SockPrint(sock, "Attempting to mount %c... ", drive);
        usbmanager->devices[port][slot] = new DeviceMU(port, slot);

        if(((DeviceMU*)(usbmanager->devices[port][slot]))->drive != drive)
            {
            delete (DeviceMU*)(usbmanager->devices[port][slot]);
            usbmanager->devices[port][slot] = NULL;
            SockPrint(sock, "Mount failed.\r\n");
            }
        else
            {
            SockPrint(sock, responseOk);
            }
        }
    else if(_stricmp(operation, "BADBLOCK") == 0)
        {
        #ifdef MU_DIAGNOSTIC_IOCTLS
            USHORT table[16+1];
            DWORD size = MU_VSC_BAD_BLOCK_TABLE_SIZE;
            SockPrint(sock, "MU Bad Block Map:\r\n");
            if(MUDiagnosticIoctl(sock, port, slot, MU_IOCTL_GET_BAD_BLOCK_TABLE, table, size))
                {
                for(unsigned i=0; i<16; i++)
                    SockPrint(sock, "  [%X] %04X\r\n", i, table[i]);
                }
        #else
            SockPrint(sock, "MU Diagnostics not enabled in this build - C_DEFINES MU_DIAGNOSTIC_IOCTLS\r\n");
        #endif
        }
    else if(_stricmp(operation, "MEMTEST") == 0)
        {
        #ifdef MU_DIAGNOSTIC_IOCTLS
            USHORT count;
            DWORD size = sizeof(USHORT);
            SockPrint(sock, "MU Memory Test (this can take up to 30 seconds):\r\n");
            if(MUDiagnosticIoctl(sock, port, slot, MU_IOCTL_MEMORY_TEST, &count, size))
                {
                SockPrint(sock, "   Bad Blocks: %04x\r\n", count);
                }
        #else
            SockPrint(sock, "MU Diagnostics not enabled in this build - C_DEFINES MU_DIAGNOSTIC_IOCTLS\r\n");
        #endif
        }
    else
        {
        HELP(sock, "MU");
        return ERR_SYNTAX;
        }
    return ERR_OK;
    }


DWORD RAWREAD(SOCKET sock, char *nextToken)
    {
    char *device;
    char *file;
    char *temp;
    DWORD size;

    if(!*nextToken)
        {
        HELP(sock, "RAWREAD");
        return ERR_SYNTAX;
        }

    device = nextToken;

    file = strchr(device, ' ');
    if(!file)
        {
        HELP(sock, "RAWREAD");
        return ERR_SYNTAX;
        }
    *file = L'\0';
    ++file;

    temp = strchr(file, ' ');
    if(!temp)
        {
        HELP(sock, "RAWREAD");
        return ERR_SYNTAX;
        }
    *temp = L'\0';
    ++temp;
    size = atol(temp);

    DWORD error = RawRead(device, file, 0, size);

    if(error == ERROR_SUCCESS)
        SockPrint(sock, responseOk);
    else
        SockPrint(sock, "   Error: %lu\r\n", error);

    return ERR_OK;
    }


DWORD RAWWRITE(SOCKET sock, char *nextToken)
    {
    char *device;
    char *file;
    char *temp;
    DWORD size;

    if(!*nextToken)
        {
        HELP(sock, "RAWREAD");
        return ERR_SYNTAX;
        }

    device = nextToken;

    file = strchr(device, ' ');
    if(!file)
        {
        HELP(sock, "RAWREAD");
        return ERR_SYNTAX;
        }
    *file = '\0';
    ++file;

    temp = strchr(file, ' ');
    if(!temp)
        {
        HELP(sock, "RAWREAD");
        return ERR_SYNTAX;
        }
    *temp = '\0';
    ++temp;
    size = atol(temp);

    DWORD error = RawWrite(device, file, 0, size);

    if(error == ERROR_SUCCESS)
        SockPrint(sock, responseOk);
    else
        SockPrint(sock, "   Error: %lu\r\n", error);

    return ERR_OK;
    }


DWORD REBOOT(SOCKET sock, char *nextToken)
    {
    SockPrint(sock, "Rebooting...\r\n");

    shutdown(sock, SD_BOTH);
    closesocket(sock);

    FlushDiskCache();

    if(!nextToken || !*nextToken)
        {
        XLaunchNewImage("D:\\default.xbe", NULL);
        }
    else
        {
        XLaunchNewImage(nextToken, NULL);
        }

    //HalReturnToFirmware(HalRebootRoutine);

    return ERR_EXIT;
    }


DWORD RUN(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "RUN");
        return ERR_SYNTAX;
        }

    // close off all the devices, so a test can use them
    delete usbmanager;

    // execute the library
    if(RunTestA(sock, nextToken) == FALSE)
        {
        SockPrint(sock, "Error executing the module, use the MODS command to verify the name.\r\n");
        }

    // re-open the attached devices
    usbmanager = new USBManager;

    return ERR_OK;
    }


DWORD SAVER(SOCKET sock, char *nextToken)
    {
    bool exit = false;

    SockPrint(sock, "Running screen saver - press any key to stop.\r\n");
    drInit();

    DWORD angle = rand() % 360;
    DWORD speed = 4;
    DWORD border = 3*speed;

    const DWORD width = 160;
    const DWORD height = 160;

    // center the image on start
    DWORD offsetX = 640/2 - width/2;
    DWORD offsetY = 480/2 - height/2;

    Bitmap logo("t:\\media\\xboxlogo.bmp");

    while(!exit)
        {
        drCls();

        if(offsetX < border)
            {
            if(offsetY < border) angle = rand() % 50 + 290;
            else if(offsetY > 480-height-border) angle = rand() % 50 + 20;
            else angle = rand() % 140 + 290;
            }
        else if(offsetX > 640-width-border)
            {
            if(offsetY < border) angle = rand() % 50 + 190;
            else if(offsetY > 480-height-border) angle = rand() % 50 + 110;
            else angle = rand() % 140 + 110;
            }
        else if(offsetY < border)
            {
            angle = rand() % 140 + 200;
            }
        else if(offsetY > 480-height-border)
            {
            angle = rand() % 140 + 20;
            }
        if(offsetX < border) offsetX = border;
        if(offsetX > 640-width-border) offsetX = 640-width-border;
        if(offsetY < border) offsetY = border;
        if(offsetY > 480-height-border) offsetY = 480-height-border;

        angle %= 360;

        // move it
        offsetX += (DWORD)(speed * sin(angle));
        offsetY += (DWORD)(speed * cos(angle));

        // draw the image
        logo.Draw(offsetX, offsetY);
        drShowScreen();

        // check for user interruption - also used to sleep
        if(NetHit(sock, 2500))
            {
            exit = true;
            }
        }

    drDeinit();

    return ERR_OK;
    }


DWORD STRESS(SOCKET sock, char *nextToken)
    {
    Shutdown(sock, atol(nextToken));
    return ERR_OK;
    }


DWORD STATS(SOCKET sock, char *nextToken)
    {
    const unsigned STATS_VERSION    = 0x01;
    const unsigned STATS_MEMORY     = 0x02;
    const unsigned STATS_PROCESS    = 0x04;
    const unsigned STATS_DISK       = 0x08;
    const unsigned STATS_DEVICE     = 0x10;
    const unsigned STATS_NETWORK    = 0x20;

    const DWORD pageSize = 4096;
    DWORD display = (DWORD)(~0);

    // make sure memory usage is not skewed by the cache
    FlushDiskCache();

    // specific pages of info
    if(*nextToken)
        {
        display = 0;
        if(strstr(nextToken, "VER") != NULL)   display |= STATS_VERSION;
        if(strstr(nextToken, "MEM") != NULL)   display |= STATS_MEMORY;
        if(strstr(nextToken, "PS") != NULL)    display |= STATS_PROCESS;
        if(strstr(nextToken, "DISK") != NULL)  display |= STATS_DISK;
        if(strstr(nextToken, "USB") != NULL)   display |= STATS_DEVICE;
        if(strstr(nextToken, "DEV") != NULL)   display |= STATS_DEVICE;
        if(strstr(nextToken, "DEVICE") != NULL)   display |= STATS_DEVICE;
        if(strstr(nextToken, "NET") != NULL)   display |= STATS_NETWORK;
        if(strstr(nextToken, "NETWORK") != NULL)   display |= STATS_NETWORK;
        if(strstr(nextToken, "ALL") != NULL)   display = (DWORD)(~0);
        }

    //
    // version
    //
    if(display & STATS_VERSION)
        {
        SockPrint(sock, "System Version---------------------------------------------------------------\r\n");

        if (0 != (XboxKrnlVersion->Qfe | 0x8000))
            SockPrint(sock, "   Kernel:      %12lu DEBUG\r\n", XboxKrnlVersion->Build);
        else
            SockPrint(sock, "   Kernel:      %12lu FREE\r\n", XboxKrnlVersion->Build);

        //
        // XapiBuildNumber[4] is major, [5] is minor, [6] is build, [7] is qfe
        //
        // The high bit of XapiBuildNumber[7] is set if it is a debug build
        //

        if (XeImageHeader()->XapiLibraryVersion->DebugBuild)
            SockPrint(sock, "   Xapi:        %12lu DEBUG\r\n", XeImageHeader()->XapiLibraryVersion->BuildVersion);
        else
            SockPrint(sock, "   Xapi:        %12lu FREE\r\n", XeImageHeader()->XapiLibraryVersion->BuildVersion);
        }

    //
    // memory
    //
    if(display & STATS_MEMORY)
        {
        MM_STATISTICS mmStats;
        memset(&mmStats, 0, sizeof(MM_STATISTICS));
        mmStats.Length = sizeof(MM_STATISTICS);
        MmQueryStatistics(&mmStats);

        SockPrint(sock, "Memory Status----------------------------------------------------------------\r\n");
        SockPrint(sock, "   Total:       %12lu B\r\n", mmStats.TotalPhysicalPages*pageSize);
        SockPrint(sock, "   Available:   %12lu B\r\n", mmStats.AvailablePages*pageSize);
        SockPrint(sock, "   Cache:       %12lu B\r\n", mmStats.CachePagesCommitted*pageSize);
        SockPrint(sock, "   Pool:        %12lu B\r\n", mmStats.PoolPagesCommitted*pageSize);
        SockPrint(sock, "   Stack:       %12lu B\r\n", mmStats.StackPagesCommitted*pageSize);
        SockPrint(sock, "   Image:       %12lu B\r\n", mmStats.ImagePagesCommitted*pageSize);
        }

    //
    // process
    //
    if(display & STATS_PROCESS)
        {
        PS_STATISTICS psStats;
        memset(&psStats, 0, sizeof(PS_STATISTICS));
        psStats.Length = sizeof(PS_STATISTICS);
        PsQueryStatistics(&psStats);

        SockPrint(sock, "Process Status---------------------------------------------------------------\r\n");
        SockPrint(sock, "   Handles:     %12lu\r\n", psStats.HandleCount);
        SockPrint(sock, "   Threads:     %12lu\r\n", psStats.ThreadCount);
        }

    //
    // network
    //
    if(display & STATS_NETWORK)
        {
        XNADDR  XnAddr;
        XNetGetTitleXnAddr(&XnAddr);

        SockPrint(sock, "Network Status---------------------------------------------------------------\r\n");
        SockPrint(sock, "   IP:          %u.%u.%u.%u\r\n", XnAddr.ina.S_un.S_un_b.s_b1, XnAddr.ina.S_un.S_un_b.s_b2, XnAddr.ina.S_un.S_un_b.s_b3, XnAddr.ina.S_un.S_un_b.s_b4);
        }

    //
    // disk drives
    //
    if(display & STATS_DISK)
        {
        unsigned numDrives;
        DWORD serialNum;
        DWORD maxFilename;
        DWORD flags;
        DWORD vnameSize = 128;
        DWORD fsnameSize = 128;
        ULARGE_INTEGER available;
        ULARGE_INTEGER total;
        ULARGE_INTEGER free;
        char drives[] = "A:\\\0B:\\\0C:\\\0D:\\\0E:\\\0F:\\\0G:\\\0H:\\\0I:\\\0J:\\\0K:\\\0L:\\\0M:\\\0"
                        "N:\\\0O:\\\0P:\\\0Q:\\\0R:\\\0S:\\\0T:\\\0U:\\\0V:\\\0W:\\\0X:\\\0Y:\\\0Z:\\";
        char *vnameBuffer = new char[128];
        char *fsnameBuffer = new char[128];

        numDrives = ARRAYSIZE(drives)/4;

        SockPrint(sock, "Disk Status------------------------------------------------------------------\r\n");
        for(unsigned i=0; i<numDrives; i++)
            {
            vnameBuffer[0] = fsnameBuffer[0] = '\0';
            serialNum = 0;
            total.QuadPart = available.QuadPart = free.QuadPart = 0;
            if (GetVolumeInformation(&drives[i*4], vnameBuffer, vnameSize, &serialNum, &maxFilename, &flags, fsnameBuffer, fsnameSize))
                {
                available.QuadPart = 0;
                total.QuadPart = 0;
                GetDiskFreeSpaceEx(&drives[i*4], &available, &total, &free);

                SockPrint(sock, "   %s, %04X-%04X, %s\r\n", &drives[i*4], HIWORD(serialNum), LOWORD(serialNum), fsnameBuffer);
                SockPrint(sock, "      Total:   %12I64u MB\r\n", total.QuadPart/MEGABYTE);
                SockPrint(sock, "      Free:    %12I64u MB\r\n", available.QuadPart/MEGABYTE);
                }
            }

        delete[] vnameBuffer;
        delete[] fsnameBuffer;
        }

    //
    // usb devices
    //
    if(display & STATS_DEVICE)
        {
        XINPUT_CAPABILITIES info;

        const char *xidSubTypes[] = {
            "",
            "GAMEPAD",
            "JOYSTICK",
            "WHEEL",
            "DANCE PAD",
            "FISHING ROD",
            "LIGHT GUN"
            };

        SockPrint(sock, "Device Status----------------------------------------------------------------\r\n");
        for(unsigned i=0; i<XGetPortCount(); i++)
            {
            for(unsigned j=0; j<SLOT_MAX; j++)
                {
                if(usbmanager->devices[i][j] != NULL)
                    {
                    SockPrint(sock, "   Port %u Slot %u is Active\r\n", i, j);
                    if(XDEVICE_TYPE_GAMEPAD == usbmanager->devices[i][j]->type)
                        {
                        XInputGetCapabilities(((DeviceDuke*)(usbmanager->devices[i][j]))->duke, &info);
                        SockPrint(sock, "      Type:    %12s\r\n", "XID");
                        SockPrint(sock, "      SubType: %12s\r\n", xidSubTypes[info.SubType]);
                        }
                    else if(XDEVICE_TYPE_MEMORY_UNIT == usbmanager->devices[i][j]->type)
                        {
                        SockPrint(sock, "      Type:   %13s\r\n", "XMU");
                        SockPrint(sock, "      Drive:  %13c\r\n", (char)((DeviceMU*)(usbmanager->devices[i][j]))->drive);
                        }
                    else if(XDEVICE_TYPE_VOICE_MICROPHONE == usbmanager->devices[i][j]->type)
                        {
                        SockPrint(sock, "      Type:   %13s\r\n", "XHAWK");
                        }
#ifdef DEBUG_KEYBOARD
                    else if(XDEVICE_TYPE_DEBUG_KEYBOARD == usbmanager->devices[i][j]->type)
                        {
                        SockPrint(sock, "      Type:   %13s\r\n", "KEYBOARD");
                        }
#endif // DEBUG_KEYBOARD
                    }
                }
            }
        }

    return ERR_OK;
    }


extern void drBitmap(float x, float y, DWORD dwWidth, DWORD dwHeight, DWORD *bitmap);

DWORD TEST(SOCKET sock, char *nextToken)
    {
    SockPrint(sock, "Test Command:\r\n");

    unsigned state = 0;

    if(*nextToken) state = atol(nextToken);

    switch(state)
        {
        case 0:
            {
            break;
            }
        case 1:
            {
            const unsigned width = 8;
            const unsigned height = 4;

            DWORD bitmap[width*height] = { 0xFFFF0000, 0xFFFF0000, 0xFFFF0000, 0xFFFF0000, 0xFFFF0000, 0xFFFF0000, 0xFFFF0000, 0xFFFF0000,
                0xFFFF0000, 0xFFFF0000, 0xFFFF0000, 0xFFFF0000, 0xFFFF0000, 0xFFFF0000, 0xFFFF0000, 0xFFFF0000,
                0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFF00, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
                0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFF00, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};

            drInit();
            drCls();
            drBitmap(50, 50, width, height, bitmap);
            drShowScreen();
            drDeinit();
            break;
            }
        case 2:
            {
            SockPrint(sock, "RawRead... ");
            RawRead("\\Device\\MemoryUnit01_01", "z:\\mu.dmp", 0, 8*MEGABYTE);
            SockPrint(sock, "Format... ");
            FORMAT(sock, "\\Device\\MemoryUnit01_01");
            SockPrint(sock, "RawWrite... ");
            RawWrite("z:\\mu.dmp", "\\Device\\MemoryUnit01_01", 0, 8*MEGABYTE);
            SockPrint(sock, "Done\r\n");
            }
        case 3:
            {
            }
        default:
            break;
        }

    return ERR_OK;
    }




DWORD USB(SOCKET sock, char *nextToken)
    {
    const unsigned defSec = 30; // default number of seconds in state spew
    const unsigned sleep = 8; // pause in ms between state queries
    unsigned numseconds = 0;

    if(*nextToken) numseconds = atol(nextToken);
    if(numseconds == 0) numseconds = defSec;

    unsigned time = numseconds * (1000/sleep);

    SockPrint(sock, "Displaying USB XID output for %u seconds...\r\n\r\n", numseconds);

    for(unsigned i=0; i<time; i++)
        {
        SleepEx(8, false);
        usbmanager->ProcessInput(sock);
        }

    return ERR_OK;
    }


DWORD WRITEINI(SOCKET sock, char *nextToken)
    {
    WCHAR *section;
    WCHAR *key;
    WCHAR *value;
    WCHAR *part2;

    nextToken = (char*)Ansi2UnicodeHack(nextToken);

    part2 = wcschr((WCHAR*)nextToken, ' ');
    value = wcschr((WCHAR*)nextToken, '=');

    if(!part2 || !value)
        {
        HELP(sock, "WRITEINI");
        return ERR_SYNTAX;
        }

    *part2 = '\0';
    part2 += 1;
    *value = '\0';
    value += 1;

    if(value > part2)
        {
        section = (WCHAR*)nextToken;
        key = part2;
        }
    else
        {
        section = part2;
        key = (WCHAR*)nextToken;
        }

    if(WriteProfileString(section, key, value) == FALSE)
        SockPrint(sock, "Error writing [%ws] %ws=%ws (ec: %lu)\r\n", section, key, value, GetLastError());
    else
        SockPrint(sock, responseOk);

    return ERR_OK;
    }


DWORD XMOUNT(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "XMOUNT");
        return ERR_SYNTAX;
        }

    char drive = nextToken[0];
    unsigned port = XMUPortFromDriveLetter(drive);
    unsigned slot = XMUSlotFromDriveLetter(drive);

    slot = slot==XDEVICE_TOP_SLOT? 1 : 2;

    if(usbmanager->devices[port][slot] != NULL && usbmanager->devices[port][slot]->type != XDEVICE_TYPE_MEMORY_UNIT)
        {
        SockPrint(sock, "The port (%02X, %02X) must be empty or hold an MU!\r\n", port, slot);
        return ERR_OK;
        }

    if(usbmanager->devices[port][slot] != NULL && usbmanager->devices[port][slot]->type == XDEVICE_TYPE_MEMORY_UNIT)
        {
        SockPrint(sock, "Unmounting %wc... ", drive);
        delete (DeviceMU*)(usbmanager->devices[port][slot]);
        usbmanager->devices[port][slot] = NULL;
        }

    SockPrint(sock, "Attempting to mount %wc... ", drive);
    usbmanager->devices[port][slot] = new DeviceMU(port, slot);

    if(((DeviceMU*)(usbmanager->devices[port][slot]))->drive != drive)
        {
        delete (DeviceMU*)(usbmanager->devices[port][slot]);
        usbmanager->devices[port][slot] = NULL;
        SockPrint(sock, "Mount failed.\r\n");
        }
    else
        {
        SockPrint(sock, responseOk);
        }

    return ERR_OK;
    }

} // namespace Launcher
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\labpusher\XbServer\xbserver.cpp ===
/*************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

	xbserver.cpp

  Abstract:

	Defines the LabPusher Xbox "server" side functions which allow file data and information to be
	received from a broadcasting PC.

  Author:

	Mabel Santos (t-msanto) 03-Dec-2001

  Revision History:

*************************************************************************************************/

#include "xbserver.h"

XbServer* Server;
int DebugOn;

// CRC table
static const unsigned long CRCs[] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

extern "C"
{
	BOOL
	WINAPI
	XapiFormatFATVolume(
		POBJECT_STRING pcVolume
		);
}

/*************************************************************************************************

Routine Description:

	Default XbServer constructor.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

XbServer::XbServer(void)
{
	GraphicPrint("Creating XbServer object\n");

	// flash LED green to indicate that app has started
	WriteSMC(0x08, 0x0A);
	WriteSMC(0x07, 0x01);
	
	// set socket to invalid
	ServerSock = INVALID_SOCKET;
	DebugPrint("Set socket to invalid\n");

	// set WinSock flag to false
	WsaInitialized = false;
	DebugPrint("Set WinSock flag to false\n");

	// set error flag to 0
	ErrorFlag = 0;
	DebugPrint("Set error flag to 0\n");

	// set exit flag to false
	ExitFlag = false;
	DebugPrint("Set exit flag to false\n");

	// set byte counters to 0
	TotalBytes = 0;
	RecvdBytes = 0;
	DebugPrint("Set byte counters to 0\n");

	// set packet-tracking variables to 0
	BasePkt = 0;
	NumPkts = 0;
	RecvdPkts = 0;
	DebugPrint("Set packet-tracking variables to 0\n");

	// set filestream to null
	OutFile = NULL;
	DebugPrint("Set filestream to null\n");

	// set kernel buffer contents to null
	memset(KernelBuf, '\0', sizeof(KernelBuf));
	DebugPrint("Set kernel buffer contents to null\n");
	
	// set kernel buffer index to 0
	KernelPos = 0;
	DebugPrint("Set kernel buffer index to 0\n");

	// set name buffer contents to null
	memset(NameBuf, '\0', sizeof(NameBuf));
	DebugPrint("Set name buffer contents to null\n");
}

/*************************************************************************************************

Routine Description:

	Default XbServer destructor.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

XbServer::~XbServer(void)
{
	GraphicPrint("Deleting XbServer object\n");

	// close socket and clean up if needed
	if(ServerSock != INVALID_SOCKET)
	{
		closesocket(ServerSock);
	}

	if(WsaInitialized)
	{
		WSACleanup();
	}
}

/*************************************************************************************************

Routine Description:

	PrepareWinSock

	Initializes WinSock.  Creates a UDP socket for listening on port 2000 and binds the Xbox
	server to it.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
XbServer::PrepareWinSock(void)
{
	GraphicPrint("Preparing WinSock\n");

	// initialize WinSock
	WORD Version = MAKEWORD(2,2);
	WSADATA WsaData;
	WSAStartup(Version, &WsaData);
	WsaInitialized = true;
	DebugPrint("Initialized WinSock\n");

	// create a UDP datagram socket
	ServerSock = socket(AF_INET, SOCK_DGRAM, 0);
	DebugPrint("Created UDP datagram socket\n");
	
	if(ServerSock == INVALID_SOCKET && WSAGetLastError() == WSANOTINITIALISED) // 10093
	{
		WSAStartup(Version, &WsaData);
		WsaInitialized = true;
		DebugPrint("Initialized WinSock a second time\n");
		ServerSock = socket(AF_INET, SOCK_DGRAM, 0);
		DebugPrint("Created UDP datagram socket a second time\n");
	}

	// try to increase receive buffer size
	int Size, BufSize = 0;
	int Err, Res;
	
	// start with 64K, then cut buffer size in half if necessary until request is granted
	for(Size = 65536; Size > 16384; Size >>=1)
	{
		// if got a socket error, try again with a smaller size
		if(setsockopt(ServerSock, SOL_SOCKET, SO_RCVBUF, (char*)&Size, sizeof(int)) == SOCKET_ERROR)
		{
			Err = WSAGetLastError();
			// if option is not supported, break out of loop
			if(Err == WSAENOPROTOOPT || Err == WSAEINVAL) break;
		}
		else
		{
			// reaching here means buffer size was successfully changed
			break;
		}
	}
	Res = sizeof(int);
	getsockopt(ServerSock, SOL_SOCKET, SO_RCVBUF, (char*)&BufSize, &Res);
	DebugPrint("Receive buffer size = %d bytes\n", BufSize);

	// fill in address structure
	SOCKADDR_IN ServerAddr;
	ServerAddr.sin_family = AF_INET;
	ServerAddr.sin_port = htons(PORT);
	ServerAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	DebugPrint("Filled in address structure\n");

	// bind name to socket
	if(bind(ServerSock, (SOCKADDR*)&ServerAddr, sizeof(SOCKADDR)) == SOCKET_ERROR)
	{
		DebugPrint("SOCKET ERROR in PrepareWinSock(): bind()\n");
		OutputDebugStringA("SOCKET ERROR in PrepareWinSock(): bind()\n");
		return false;
	}
	else 
	{
		DebugPrint("Bound name to socket\n");
	}
	return true;
}

/*************************************************************************************************

Routine Description:

	FormatDrives

	Formats each partition on the Xbox hard disk.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
XbServer::FormatDrives(void)
{
	GraphicPrint("Formatting drives\n");

    OCHAR DriveBuf[BUFFLEN+1];
    OBJECT_STRING ObjStr;

	for(int i = 1; i <= 5; ++i)
	{
		sprintf(DriveBuf, "\\Device\\Harddisk0\\Partition%d", i);
		RtlInitObjectString(&ObjStr, DriveBuf);
		if(XapiFormatFATVolume(&ObjStr)) 
		{
			DebugPrint("Partition %d formatted\n", i);
		}
		else 
		{
			DebugPrint("ERROR: Partition %d not formatted\n", i);
			OutputDebugStringA("ERROR in FormatDrives(): XapiFormatFATVolume()\n");
			return false;
		}
	}
	return true;
}

/*************************************************************************************************

Routine Description:

	MapDrives

	Creates symbolic links to areas on the hard disk so they can be accessed using drive letters.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
XbServer::MapDrives(void)
{
	GraphicPrint("Mapping drives\n");

	DWORD Res;

	// map C drive
	Res = MapDrive('C', "\\Device\\Harddisk0\\Partition1");
	if(Res == 0)
	{
		DebugPrint("Mapped Drive C\n");
	}
	else
	{
		DebugPrint("Mapping drive C failed with error code %d\n", Res);
	}

	// map Y drive
	Res = MapDrive('Y', "\\Device\\Harddisk0\\Partition2");
	if(Res == 0)
	{
		DebugPrint("Mapped Drive Y\n");
	}
	else
	{
		DebugPrint("Mapping drive Y failed with error code %d\n", Res);
	}

	// create directories needed to map drives E and S
	CreateDirectory("C:\\devkit", NULL);
	CreateDirectory("C:\\TDATA", NULL);

	// map E drive
	Res = MapDrive('E', "\\Device\\Harddisk0\\Partition1\\devkit");
	if(Res == 0)
	{
		DebugPrint("Mapped Drive E\n");
	}
	else
	{
		DebugPrint("Mapping drive E failed with error code %d\n", Res);
	}

	// map S drive
	Res = MapDrive('S', "\\Device\\Harddisk0\\Partition1\\TDATA");
	if(Res == 0)
	{
		DebugPrint("Mapped Drive S\n");
	}
	else
	{
		DebugPrint("Mapping drive S failed with error code %d\n", Res);
	}
}

/*************************************************************************************************

Routine Description:

	SendReply

	Waits for a message and sends a response to let the PC know that this Xbox is in a listening
	state.

Arguments:

	none

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
XbServer::SendReply(void)
{
	char ReplyBuf[BUFFLEN];
	SOCKADDR_IN DestAddr;
	int Result;
	int AddrSize = sizeof(SOCKADDR_IN);
	DebugPrint("Waiting for message from LabPusher\n");
	GraphicPrint("Waiting for message from LabPusher\n");

	TIMEVAL Timeout;
	FD_SET Bucket;

	do
	{ 
		Bucket.fd_count = 1;
		Bucket.fd_array[0] = ServerSock;
		Timeout.tv_sec = 5;
		Timeout.tv_usec = 0;

		// wait for message from client
		Result = select(0, &Bucket, NULL, NULL, &Timeout);
		
		if(Result == SOCKET_ERROR)
		{
			DebugPrint("SOCKET ERROR in select()\n");
			OutputDebugStringA("SOCKET ERROR in SendReply(): select()\n");
			return false;
		}
		
	} while(Result == 0); // try again if hit timeout

	// grab message
	Result = recvfrom(ServerSock, ReplyBuf, sizeof(ReplyBuf), 0, (SOCKADDR*)&DestAddr, &AddrSize);	  
	
	if(Result == SOCKET_ERROR)
	{
		DebugPrint("SOCKET ERROR in recvfrom()\n");
		OutputDebugStringA("SOCKET ERROR in SendReply(): recvfrom()\n");
		return false;
	}

	DebugPrint("Received message from LabPusher\n");
	GraphicPrint("Received message from LabPusher\n");

	if(ReplyBuf)
	{
		// if message contains total number of bytes to be received, store the value
		TotalBytes = strtoul(ReplyBuf, NULL, 10);
		GraphicPrint("Total bytes to be received: %u\n", TotalBytes);
	}
	
	// reply with machine name so client knows which Xbox responded
	DWORD Len = BUFFLEN;

	// keep track of machine name so we can rename the box later
	DmGetXboxName(NameBuf, &Len);
	DebugPrint("Got Xbox name: %s\n", NameBuf);
	GraphicPrint("Got Xbox name: %s\n", NameBuf);
	
	Result = sendto(ServerSock, NameBuf, strlen(NameBuf), 0, (SOCKADDR*)&DestAddr, sizeof(SOCKADDR));	

	if(Result == SOCKET_ERROR)
	{
		DebugPrint("SOCKET ERROR in recvfrom()\n");
		OutputDebugStringA("SOCKET ERROR in SendReply(): recvfrom()\n");
		return false;
	}

	DebugPrint("Sent response back to LabPusher\n");
	GraphicPrint("Sent response back to LabPusher\n");
	return true;
}

/*************************************************************************************************

Routine Description:

	RecvFiles

	Receives file data and commands through the network.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
XbServer::RecvFiles(void)
{
	char RecvBuf[sizeof(FilePacketHeader) + BUFFLEN];
	FilePacket* RecvPkt = (FilePacket*)RecvBuf;
	SOCKADDR_IN SrcAddr;
	int Result;
	int AddrSize = sizeof(SOCKADDR_IN);
	DebugPrint("Waiting to receive files\n");
	GraphicPrint("Waiting to receive files\n");

	TIMEVAL Timeout;
	FD_SET Bucket;

	while(!ErrorFlag && !ExitFlag) // keep going as long as error condition hasn't occurred
								   // and there is still more data to be received
	{
		Bucket.fd_count = 1;
		Bucket.fd_array[0] = ServerSock;
		Timeout.tv_sec = 5;
		Timeout.tv_usec = 0;

		// clear buffer
		memset(RecvBuf, '\0', sizeof(RecvBuf));

		// wait for data packet from client
		Result = select(0, &Bucket, NULL, NULL, &Timeout);

		if(Result == 0) continue; // timed out so try again
		
		if(Result == SOCKET_ERROR)
		{
			DebugPrint("SOCKET ERROR in select()\n");
			OutputDebugStringA("SOCKET ERROR in RecvFiles(): select()\n");
			break;
		}

		// grab data packet
		Result = recvfrom(ServerSock, RecvBuf, sizeof(RecvBuf), 0, (SOCKADDR*)&SrcAddr, &AddrSize);	  
		
		if(Result == 0)
		{
			// no more data
			DebugPrint("No more data. Breaking out of loop...\n");
			break;
		}

		if(Result == SOCKET_ERROR)
		{
			DebugPrint("SOCKET ERROR in recvfrom()\n");
			OutputDebugStringA("SOCKET ERROR in RecvFiles(): recvfrom()\n");
			break;
		}

		// process data packet
		ReadPacket(RecvPkt);
	}

	// check if we broke out of loop prematurely because of an error condition
	if(ErrorFlag)
	{
		// if so, flash the LED
		FlashLED();
	}
}

/*************************************************************************************************

Routine Description:

	ReadPacket

	Reads a data packet and responds according to its packet type.
	FLASHCMD: flash ROM with new kernel image
	KRNLNOTE: prepare to receive kernel binary
	FILEDESC: create directories if needed and start new file
	FILEDATA: write regular file data to hard drive; copy kernel data to a buffer

Arguments:

	FilePacket* Packet	-	packet to be read
							
Return Value:

	none

*************************************************************************************************/

void
XbServer::ReadPacket(FilePacket* Packet)
{
	// display packet contents
	//DebugPrint("PacketType: %d\n", Packet->PacketType);
	//DebugPrint("SequenceNo: %d\n", Packet->SequenceNo);
	//DebugPrint("DataSize: %d\n", Packet->DataSize);
	//DebugPrint("Crc: %d\n", Packet->Crc);
	//if(Packet->Data) DebugPrint("Data: %s\n", Packet->Data);

	// if CRC does not match, set flag and return
	int Crc = GetCRC((unsigned char*)Packet->Data, Packet->DataSize);
	if(Crc != Packet->Crc)
	{
		DebugPrint("ERROR: GetCRC(Packet->Data, Packet->DataSize)(%d) != Packet->Crc(%d)\n", Crc, Packet->Crc);
		DebugPrint("Setting error flag to indicate checksum error...\n");
		ErrorFlag = CHKSMERROR;
		OutputDebugStringA("ERROR in ReadPacket(): CRCs do not match\n");
		return;
	}

	switch(Packet->PacketType)
	{
        case FINISHCMD:
            ExitFlag = true;
            break;

		case FLASHCMD: // packet contains flash command

			// check if all previous packets have been received
			if(!CheckPkts()) return;

			FlashROM();
			break;

		case KRNLNOTE: // packet contains kernel binary notification
			
			// check if all previous packets have been received
			if(!CheckPkts()) return;

			// reset packet-tracking variables
			StartFile(Packet->FileSize, Packet->SequenceNo);

			DebugPrint("Ready to receive kernel binary\n");
			//GraphicPrint("Receiving kernel data\n");
			break;

		case FILEDESC: // packet contains file description
			
			// check if all previous packets have been received
			if(!CheckPkts()) return;

			// create any directories in the file path that do not exist
			// if there is a problem with creating a directory, set flag and return
			if(!CreateDirs(Packet->Data)) return;

			// open new filestream
			OutFile = fopen(Packet->Data, "wb");

			// if there is a problem with opening the file, set flag and return
			if(!OutFile)
			{
				DebugPrint("ERROR: Could not start new file %s\n", Packet->Data);
				DebugPrint("Setting error flag to indicate file error...\n");
				ErrorFlag = FILEERROR;
				OutputDebugStringA("ERROR in ReadPacket(): Could not start new file\n");
				return;	
			}

			// reaching here means file was opened successfully
			DebugPrint("Started new file: %s\n", Packet->Data);
			//GraphicPrint("%s\n", Packet->Data);

			// reset packet-tracking variables
			StartFile(Packet->FileSize, Packet->SequenceNo);
			break;
			
		case FILEDATA: // packet contains file data

			// check if packet belongs to the same file
			DWORD Offset = Packet->SequenceNo - BasePkt - 1;
			//DebugPrint("Offset: %d\n", Offset);
			if(Offset >= NumPkts)
			{
				// if packet is from another file, set error flag and return
				DebugPrint("ERROR: Packet belongs to another file\n");
				DebugPrint("Setting error flag to indicate packet error...\n");
				ErrorFlag = PKTERROR;
				OutputDebugStringA("ERROR in ReadPacket(): Packet belongs to another file\n");
				return;
			}

			// if this is regular file data, write it to the hard drive
			if(OutFile)
			{
				// set file position according to packet's sequence number
				fseek(OutFile, Offset*BUFFLEN, SEEK_SET);
				size_t WriteRes = fwrite(Packet->Data, sizeof(char), Packet->DataSize, OutFile);

				// if there is a problem with writing to the file, set flag and return
				if(WriteRes < Packet->DataSize) 
				{
					DebugPrint("ERROR: Could not write data to file\n");
					DebugPrint("Setting error flag to indicate file error...\n");
					ErrorFlag = FILEERROR;
					OutputDebugStringA("ERROR in ReadPacket(): Could not write data to file\n");
					return;
				}
				// reaching here means data was properly written
				//DebugPrint("Wrote %dB of data to file\n", WriteRes);
				//DebugPrint("Wrote %dB of data to file: %s\n", WriteRes, Packet->Data);
			}

			else // if this is kernel data, copy it to the kernel buffer
			{
				// set array index according to packet's sequence number
				KernelPos = 0;
				KernelPos += (Offset*BUFFLEN);
				memmove(KernelBuf+KernelPos, Packet->Data, Packet->DataSize);

				// if there is a problem with copying to the buffer, set flag and return
				if(memcmp(KernelBuf+KernelPos, Packet->Data, Packet->DataSize) != 0)
				{
					DebugPrint("ERROR: Could not copy kernel data to buffer\n");
					DebugPrint("Setting error flag to indicate kernel error...\n");
					ErrorFlag = KRNLERROR;
					OutputDebugStringA("ERROR in ReadPacket(): Could not copy kernel data to buffer\n");
					return;
				}

				// reaching here means data was properly copied
				//DebugPrint("Copied %dB of data to buffer\n", Packet->DataSize);
				//DebugPrint("Copied %dB of data to buffer: %s\n", Packet->DataSize, Packet->Data);
			}

			// increment received byte counter
			RecvdBytes += Packet->DataSize;

			if(TotalBytes > 0)
				GraphicPrint("Receiving files: %.2f%% done\n", RecvdBytes/(TotalBytes*0.01));

			// increment received packet counter
			++RecvdPkts;
			//DebugPrint("Incremented received packet counter to %d\n", RecvdPkts);
			break;
	}
}

/*************************************************************************************************

Routine Description:

	CheckPkts

	Checks if all data packets for the most recent file have been received.

Arguments:

	none

Return Value:

	BOOL	-	true if all packets have been received; false otherwise

*************************************************************************************************/

BOOL
XbServer::CheckPkts(void)
{
	// if there is an open filestream, close it
	if(OutFile) 
	{
		fclose(OutFile);
		OutFile = NULL;
	}

    // check if all packets for the previous file have been received
    if(RecvdPkts != NumPkts)
    {
		DebugPrint("ERROR: Not all packets received for previous file\n");
		DebugPrint("Setting error flag to indicate packet error...\n");
		ErrorFlag = PKTERROR;
		OutputDebugStringA("ERROR in CheckPkts(): Not all packets received for previous file\n");
		return false;
    }

	// reaching here means all packets have been received
	DebugPrint("Done receiving file\n");
	//GraphicPrint("Done receiving file\n");
	return true;
}

/*************************************************************************************************

Routine Description:

	StartFile

	Prepares to receive a new file by resetting all packet-tracking variables.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
XbServer::StartFile(DWORD FileSize, DWORD PktNum)
{
	BasePkt = PktNum;
	DebugPrint("BasePkt: %d\n", BasePkt);
	DebugPrint("FileSize: %d bytes\n", FileSize);
	NumPkts = FileSize/BUFFLEN + (FileSize%BUFFLEN > 0 ? 1 : 0);
	DebugPrint("NumPkts: %d\n", NumPkts);
	RecvdPkts = 0;
	//DebugPrint("RecvdPkts: %d\n", RecvdPkts);
}

/*************************************************************************************************

Routine Description:

	CreateDirs

	Steps through a given path and creates any directories that do not already exist.

Arguments:

	char* PathName	-	path to be traversed

Return Value:

	BOOL	-	true if no errors are encountered; false otherwise

*************************************************************************************************/

BOOL
XbServer::CreateDirs(char* PathName)
{
	unsigned int Start, End;
	
	// step through each directory in the path
	for(Start = 0, End = strcspn(PathName, "\\") + 1;
		End < strlen(PathName);
		Start = End, End = strcspn(PathName+Start, "\\") + Start + 1)
	{
		char Temp = PathName[End];
		PathName[End] = '\0';
		DebugPrint("CurrDir: %s\n", PathName);
		
		// try to create directory
		if(!CreateDirectory(PathName, NULL))
		{	
			// if directory does not exist but can not be created, set error flag and return
			if(GetLastError() != ERROR_ALREADY_EXISTS)
			{
				DebugPrint("ERROR: Could not create directory %s\n", PathName);
				ErrorFlag = DIRERROR;
				OutputDebugStringA("ERROR in CreateDirs(): Could not create directory\n");
				return false;
			}
			else // directory already exists, so no harm done
			{
				//DebugPrint("Directory %s already exists\n", PathName);
			}
		}
		else
		{
			// reaching here means directory did not exist and was created successfully
			DebugPrint("Created new directory: %s\n", PathName);
			//GraphicPrint("Created new directory: %s\n", PathName);
		}
		PathName[End] = Temp;
	}
	return true;
}

/*************************************************************************************************

Routine Description:

	FlashROM

	Programs the Xbox flash ROM with a new kernel image.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
XbServer::FlashROM(void)
{
	DebugPrint("Flashing ROM\n");
	GraphicPrint("Flashing ROM\n");
	
	PUCHAR ROMImage = (PUCHAR)KernelBuf;
	HRESULT Result;

    for(int i = 0; i < ROM_FLASH_RETRIES; i++)
    {
        char FlashBuf[BUFFLEN];
        Result = FlashKernelImage(ROMImage, ROM_SIZE, FlashBuf, BUFFLEN);

        DebugPrint("Flash Status (%d): Result=0x%08x (%s)", i, Result, FlashBuf);

        if(SUCCEEDED(Result))
        {
			DebugPrint("Flashed ROM successfully\n");
            break;
        }
    }

    if (ROM_FLASH_RETRIES == i)
    {
		// if flashing did not succeed, set flag
		ErrorFlag = FLASHERROR;

        DebugPrint("ERROR: Could not flash ROM, hr=0x%08x", Result);
		OutputDebugStringA("ERROR in FlashROM(): FlashKernelImage()\n");

		// flash LED to indicate error condition
        FlashLED();
    }
	// reaching here means flash was successful
	ExitFlag = true;
}

/*************************************************************************************************

Routine Description:

	UnMapDrives

	Removes symbolic links to areas on the hard disk that allow them to be accessed using drive
	letters.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
XbServer::UnMapDrives(void)
{
	GraphicPrint("Unmapping drives\n");

	DWORD Res;

	// unmap C drive
	Res = UnMapDrive('C');
	if(Res == 0)
	{
		DebugPrint("Unmapped Drive C\n");
	}
	else
	{
		DebugPrint("Unmapping drive C failed with error code %d\n", Res);
	}
	
	// unmap Y drive
	Res = UnMapDrive('Y');
	if(Res == 0)
	{
		DebugPrint("Unmapped Drive Y\n");
	}
	else
	{
		DebugPrint("Unmapping drive Y failed with error code %d\n", Res);
	}

	// unmap E drive
	Res = UnMapDrive('E');
	if(Res == 0)
	{
		DebugPrint("Unmapped Drive E\n");
	}
	else
	{
		DebugPrint("Unmapping drive E failed with error code %d\n", Res);
	}

	// unmap S drive
	Res = UnMapDrive('S');
	if(Res == 0)
	{
		DebugPrint("Unmapped Drive S\n");
	}
	else
	{
		DebugPrint("Unmapping drive S failed with error code %d\n", Res);
	}
}

/*************************************************************************************************

Routine Description:

	FlashLED

	Makes the Xbox LED flash red to indicate that an error has occurred.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void
XbServer::FlashLED(void)
{
	DebugPrint("Error encountered:\n");
	OutputDebugStringA("Error encountered:\n");

	switch(ErrorFlag)
	{

	case PKTERROR:
		DebugPrint("Packet missing or out of order\n");
		OutputDebugStringA("Packet missing or out of order\n");
		GraphicPrint("Packet missing or out of order\n");
		// flash LED red
		//WriteSMC(0x08, 0xA0);
		//WriteSMC(0x07, 0x01);
		break;
	
	case CHKSMERROR:
		DebugPrint("Packet CRCs do not match\n");
		OutputDebugStringA("Packet CRCs do not match\n");
		GraphicPrint("Packet CRCs do not match\n");
		// flash LED orange
		//WriteSMC(0x08, 0xAA);
		//WriteSMC(0x07, 0x01);
		break;

	case DIRERROR:
		DebugPrint("Directory not created\n");
		OutputDebugStringA("Directory not created\n");
		GraphicPrint("Directory not created\n");
		// flash LED green
		//WriteSMC(0x08, 0x0A);
		//WriteSMC(0x07, 0x01);
		break;

	case FILEERROR:
		DebugPrint("File not written\n");
		OutputDebugStringA("File not written\n");
		GraphicPrint("File not written\n");
		// flash LED red and orange
		//WriteSMC(0x08, 0xF5);
		//WriteSMC(0x07, 0x01);
		break;

	case KRNLERROR:
		DebugPrint("Kernel not received\n");
		OutputDebugStringA("Kernel not received\n");
		GraphicPrint("Kernel not received\n");
		// flash LED orange and green
		//WriteSMC(0x08, 0xAF);
		//WriteSMC(0x07, 0x01);
		break;

	case FLASHERROR:
		DebugPrint("ROM not flashed\n");
		OutputDebugStringA("ROM not flashed\n");
		GraphicPrint("ROM not flashed\n");
		// flash LED red and green
		//WriteSMC(0x08, 0xA5);
		//WriteSMC(0x07, 0x01);
		break;

	default:
		DebugPrint("Socket error, format error or flash error\n");
		OutputDebugStringA("Socket error, format error or flash error\n");
		GraphicPrint("Socket error, format error or flash error\n");
		break;
	}
	// flash LED red to indicate that an error has been encountered
	WriteSMC(0x08, 0xA0);
	WriteSMC(0x07, 0x01);
	UnMapDrives();
	Sleep(INFINITE);
}

/*************************************************************************************************

Routine Description:

	GetCRC

	Determines the CRC for the specified data.

Arguments:

	unsigned char* Data	-	data whose CRC is to be determined
	WORD Size			-	size of data

Return Value:

	DWORD	-	CRC for data

*************************************************************************************************/

DWORD
XbServer::GetCRC(unsigned char* Data, WORD Size)
{
	DWORD Result = 0;
	DWORD Shift = 0;
	DWORD Index = 0;

	while(Size--)
	{	
		Result = (Result >> 8) ^ CRCs[(BYTE)(Result ^ *Data++)];
	}
	return Result;
}

/*************************************************************************************************

Routine Description:

	DebugPrint

	Prints a line to standard output if the DebugOn flag is set.

Arguments:

	char* ptszFormat, ...	-	format string	

Return Value:

	none

*************************************************************************************************/

void
DebugPrint(char *ptszFormat, ...)
{
	if(DebugOn)
	{
		char tszBuf[BUFFLEN];
		va_list arglist;

		va_start( arglist, ptszFormat );
		_vsnprintf( tszBuf, sizeof(tszBuf), ptszFormat, arglist );
		OutputDebugStringA( tszBuf );
		va_end(arglist);
	}
}

/*************************************************************************************************

Routine Description:

	main function

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void __cdecl main(void)
{	
	DebugOn = 0;

	InitGraphics();

	XNetStartupParams xnsp = { sizeof(XNetStartupParams), XNET_STARTUP_BYPASS_SECURITY, 255};
    int nXnetResult = XNetStartup( &xnsp );
    if(nXnetResult != NO_ERROR)
    {
		DebugPrint("XNetStartup() Error: %u\n", nXnetResult);
		GraphicPrint("XNetStartup() Error: %u\n", nXnetResult);
    }
	// sleep for 5 secs because sockets are not fully initialized immediately after call to
	// XNetStartup()
    Sleep(5000);

	// make an XbServer object
	Server = new XbServer;

	// set up network stuff
	if(!Server->PrepareWinSock())
	{
		Server->FlashLED();
		Sleep(INFINITE);
	}

	// format drives
	if(!Server->FormatDrives())
	{
		Server->FlashLED();
		Sleep(INFINITE);
	}

	// map drives
	Server->MapDrives();

	// notify client that this box is done formatting
	if(!Server->SendReply())
	{
		Server->FlashLED();
		Sleep(INFINITE);
	}

	// wait to receive files from network
	Server->RecvFiles();

	// notify client that this box is done receiving files and has successfully flashed ROM
	if(!Server->SendReply())
	{
		Server->FlashLED();
		Sleep(INFINITE);
	}

	// rename machine and unmap drives
	DmSetXboxName(Server->NameBuf);
	DebugPrint("Set Xbox name: %s\n", Server->NameBuf);
	GraphicPrint("Set Xbox name: %s\n", Server->NameBuf);
	Server->UnMapDrives();

	// delete XbServer object
	delete Server;

	GraphicPrint("Finished recovery. Waiting for reboot...\n");
	Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\cworkerthread.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    CWorkerThread.h

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

--*/

#ifndef _CWORKERTHRAD_H_
#define _CWORKERTHRAD_H_

#include "stdafx.h"
#include <process.h>    /* _beginthread, _endthread */

namespace Launcher {

static DWORD WINAPI LocalThreadFunct(LPVOID lpParameter);

/*++

Class Description:

    Worker thread class

Methods:



Data:



NOTE: 
    
    Remember to nest any member read/write with Lock and Unlock 

    In the implementation of the ThreadFunct function, the user must check 
        the bExit flag and exit gracefully if set.

--*/
class CWorkerThread
    {
    private:
        CRITICAL_SECTION criter;
        DWORD dwThreadHandle;
        DWORD dwThreadID;
        DWORD dwThreadExitCode;

    protected:
        BOOL bExit;

        DWORD dwLocalThreadID;

        // exit notification params
        HWND notifyWindow;
        UINT notifyMsg;
        LPARAM notifylParam;

    // constructors / destructors
    public:
        CWorkerThread();
        CWorkerThread(DWORD localID);
        ~CWorkerThread();

    // public access and information
    public:
        void Lock(void) { EnterCriticalSection(&criter); }
        void Unlock(void) { LeaveCriticalSection(&criter); }

        #ifdef _WIN32_WINNT
        BOOL Lock(DWORD dwTimeOut);
        #endif

        DWORD GetThreadHandle(void) { Lock(); DWORD h = dwThreadHandle; Unlock(); return h; }
        DWORD GetThreadID(void) { Lock(); DWORD id = dwThreadID; Unlock(); return id; }
        DWORD GetLocalThreadID(void) { Lock(); DWORD id = dwLocalThreadID; Unlock(); return id; }
        void  SetLocalThreadID(DWORD id) { Lock(); dwLocalThreadID = id; Unlock(); }
        DWORD GetThreadExitCode(void) { Lock(); DWORD e = dwThreadExitCode; Unlock(); return e; }
        BOOL  GetExitFlag(void) { Lock(); BOOL e = bExit; Unlock(); return e; }
        void  SetExitFlag(BOOL b) { Lock(); bExit = b; Unlock(); }

        void Run(void);
        BOOL SoftBreak(DWORD dwTimeOut);
        BOOL HardBreak(void);

        BOOL WaitForExit(DWORD dwTimeOut);

        // thread manipulation
        DWORD SuspendThread(void);
        DWORD ResumeThread(void);

        // notifications
        void SetExitNotify(HWND notifyDestination, UINT message, LPARAM lParam);

    // internal functions
    private:
        void SetThreadHandle(DWORD h) { Lock(); dwThreadHandle = h; Unlock(); }
        void SetThreadID(DWORD id) { Lock(); dwThreadID = id; Unlock(); }
        void SetThreadExitCode(DWORD c) { Lock(); dwThreadExitCode = c; Unlock(); }

        friend DWORD WINAPI LocalThreadFunct(LPVOID lpParameter);

    // overrideable functions
    public:
        /*
        NOTE: in the implementation of this function, the user must check 
               the bExit flag and exit gracefully if set:
        while(1)
            {
            if(GetExitFlag()) break;
            }
        */
        virtual DWORD ThreadFunct(void) { return 0; }
    };

} // namespace Launcher
#endif // _CWORKERTHRAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\launcher.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    launcher.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    jpoley

Environment:

    XBox

Revision History:

*/


#include "stdafx.h"
#include <xtestlib.h>
//#include <xbox.h>
//#include <xlog.h>

#include "CSockServer.h"
#include "launcherx.h"


//
// Thread ID in multiple-thread configuration (not a Win32 thread ID)
//
// You can specify how many threads you want to run your test by
// setting the key NumberOfThreads=n under your DLL section. The
// default is only one thread.
//

ULONG LauncherThreadID = 0;


//
// Heap handle from HeapCreate
//
HANDLE LauncherHeapHandle;

BOOL WINAPI LauncherDllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved)
    {
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpReserved);

    if(fdwReason == DLL_PROCESS_ATTACH)
        {
        LauncherHeapHandle = HeapCreate(0, 0, 0);

        if(!LauncherHeapHandle)
            {
            OutputDebugString(L"LAUNCHER: Unable to create heap\n");
            }
        else
            {
            DebugPrint("LAUNCHER: DLL_PROCESS_ATTACH %X\n", LauncherHeapHandle);
            }
        }
    else if(fdwReason == DLL_PROCESS_DETACH)
        {
        if(LauncherHeapHandle)
            {
            HeapDestroy(LauncherHeapHandle);
            }

        penterDumpStats();
        }

    return TRUE;
    }



/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI LauncherStartTest(HANDLE hLog)
    {
    ULONG ID;

    //
    // One way to run multiple threads without creating threads is to
    // set NumberOfThreads=n under the section [sample]. Everytime
    // the harness calls StartTest, LauncherThreadID will get increment by one
    // after InterlockedIncrement call below. If no NumberOfThreads
    // specified, only RunTest1 will be run
    //

    ID = InterlockedIncrement((LPLONG) &LauncherThreadID);

    // ini file settings
    //const int buffLen = 1024;
    unsigned short port;
    unsigned timeout;
    //WCHAR testname[buffLen];


    // Pull out internal INI file settings
    //GetProfileString(L"launcher", L"testname", L"(all)", testname, buffLen);
    port = (unsigned short)GetProfileInt(L"launcher", L"port", 99);
    timeout = GetProfileInt(L"launcher", L"timeout", 600);

    DebugPrint("LAUNCHER(%d): **************************************************************\n", ID);
    DebugPrint("LAUNCHER(%d): Internal INI Settings:\n", ID);
    DebugPrint("  port=%u\n", port);
    DebugPrint("  timeout=%u\n", timeout);
    //DebugPrint("  testname=%ws\n", testname);

    Launcher::CSockServer *server = new Launcher::CSockServer;

    if(!server)
        {
        DebugPrint("LAUNCHER: Out of memory!\n");
        return;
        }

    server->SetPort(port);
    server->SetTimeout(timeout);
    server->m_socktype = SOCK_STREAM;
    server->OpenServerSocket(server->m_socktype);
    server->BindSocket();
    server->ThreadFunct();

    delete server;

    DebugPrint("LAUNCHER(%d): **************************************************************\n", ID);
    }


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI LauncherEndTest(void)
    {
    LauncherThreadID = 0;
    }


/*

Routine Description:

    Formatted print function that sends the output through a connected SOCKET.

Arguments:

    SOCKET sock - connected socket
    char* format - printf style format specifier
    ... - arguments specified by the format specifier

Return Value:

    int - number of bytes sent out

Notes:

*/
int SockPrint(SOCKET sock, char* format, ...)
    {
    if(sock == INVALID_SOCKET) return 0;

    va_list args;
    va_start(args, format);

    char szBuffer[1024];

    int len = vsprintf(szBuffer, format, args);
    send(sock, szBuffer, len, 0);

    va_end(args);

    return len;
    }


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( launcher )
#pragma data_seg()

BEGIN_EXPORT_TABLE( launcher )
    EXPORT_TABLE_ENTRY( "StartTest", LauncherStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", LauncherEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", LauncherDllMain )
END_EXPORT_TABLE( launcher )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\dos.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dos.cpp

Abstract:

    MS-DOS style commands. Any non DOS commands are in cmd.cpp

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-31-2000  Created

*/
#include "stdafx.h"
#include "launcherx.h"

namespace Launcher {

DWORD ATTRIB(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "ATTRIB");
        return ERR_SYNTAX;
        }

    WIN32_FIND_DATA findData;
    HANDLE hFind;

    hFind = FindFirstFile(nextToken, &findData);

    if(hFind == INVALID_HANDLE_VALUE)
        {
        SockPrint(sock, "No files found (ec: %lu)\r\n", GetLastError());
        return 1;
        }

    do
        {
        if(strcmp(findData.cFileName, ".") == 0 || strcmp(findData.cFileName, "..") == 0) continue;

        SockPrint(sock, "%c%c%c%c%c %s\r\n", 
            findData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY?'D':' ',
            findData.dwFileAttributes&FILE_ATTRIBUTE_READONLY?'R':' ',
            findData.dwFileAttributes&FILE_ATTRIBUTE_HIDDEN?'H':' ',
            findData.dwFileAttributes&FILE_ATTRIBUTE_SYSTEM?'S':' ',
            findData.dwFileAttributes&FILE_ATTRIBUTE_ARCHIVE?'A':' ',
            findData.cFileName);
        } while(FindNextFile(hFind, &findData) == TRUE);

    FindClose(hFind);

    return ERR_OK;
    }


DWORD CALL(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "CALL");
        return ERR_SYNTAX;
        }

    size_t tokenLen;
    char *token;
    char *subToken;
    char *buffer = new char[1024];
    if(!buffer) return ERR_NOMEM;

    FILE *f = fopen(nextToken, "rb");
    if(!f)
        {
        delete[] buffer;
        if(strstr(nextToken, "autoexec.bat") == NULL) // NOTE the lowercase!
            {
            // dont display the error message if looking for the main autoexec
            // files (if user calls it they will still get the error message)
            SockPrint(sock, "Could not open file\r\n");
            }
        return 1;
        }
    while(fgets(buffer, 1024, f))
        {
        token = strstr(buffer, "\r\n");
        if(token) *token = '\0';
        _strupr(buffer);
        GetToken(buffer, &token, &tokenLen, &subToken);
        token[tokenLen] = '\0';
        ExecuteCommand(sock, token, subToken);
        }
    fclose(f);
    delete[] buffer;
    return ERR_OK;
    }


DWORD COPY(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "COPY");
        return ERR_SYNTAX;
        }

    WIN32_FIND_DATA findData;
    HANDLE hFind;
    unsigned numFiles=0;
    char *file1, *file2;

    char* newFile = strchr(nextToken, ' ');
    if(!newFile)
        {
        HELP(sock, "COPY");
        return ERR_SYNTAX;
        }
    *newFile = '\0';
    newFile += 1;

    char *path1 = new char[1024];
    char *path2 = new char[1024];

    if(!path1 || !path2)
        {
        delete[] path1;
        delete[] path2;
        return ERR_NOMEM;
        }

    strcpy(path1, nextToken);
    strcpy(path2, newFile);

    file1 = xPathFindFileName(path1);
    file2 = xPathFindFileName(path2);
    if(!file1 || !file2)
        {
        delete[] path1;
        delete[] path2;
        SockPrint(sock, "No files found.\r\n");
        return 1;
        }
    *file1 = '\0';
    *file2 = '\0';

    hFind = FindFirstFile(nextToken, &findData);
    if(hFind == INVALID_HANDLE_VALUE)
        {
        delete[] path1;
        delete[] path2;
        SockPrint(sock, "No files found (ec: %lu)\r\n", GetLastError());
        return 1;
        }

    do
        {
        if(strcmp(findData.cFileName, ".") == 0 || strcmp(findData.cFileName, "..") == 0) continue;

        strcpy(file1, findData.cFileName);
        strcpy(file2, findData.cFileName);

        if(CopyFile(path1, path2, false) != TRUE)
            {
            SockPrint(sock, "        Unable to copy the file: %s (ec: %lu)\r\n", path1, GetLastError());
            }
        else ++numFiles;
        } while(FindNextFile(hFind, &findData) == TRUE);

    FindClose(hFind);

    SockPrint(sock, "        %6u file(s) copied\r\n", numFiles);

    delete[] path1;
    delete[] path2;

    return ERR_OK;
    }


DWORD DEL(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "DEL");
        return ERR_SYNTAX;
        }

    WIN32_FIND_DATA findData;
    HANDLE hFind;
    unsigned numFiles=0;
    char *buffer = new char[1024];

    if(!buffer)
        {
        return ERR_NOMEM;
        }

    hFind = FindFirstFile(nextToken, &findData);
    char *name = xPathFindFileName(nextToken);
    if(!name)
        {
        delete[] buffer;
        SockPrint(sock, "No files found.\r\n");
        return 1;
        }
    *name = '\0';

    if(hFind == INVALID_HANDLE_VALUE)
        {
        delete[] buffer;
        SockPrint(sock, "No files found (ec: %lu)\r\n", GetLastError());
        return 1;
        }

    do
        {
        if(strcmp(findData.cFileName, ".") == 0 || strcmp(findData.cFileName, "..") == 0) continue;
        sprintf(buffer, "%s%s", nextToken, findData.cFileName);

        // clear any readonly settings (otherwise delete will fail)
        DWORD sattrib = GetFileAttributes(buffer);
        SETFLAG(sattrib, FILE_ATTRIBUTE_NORMAL);
        CLEARFLAG(sattrib, FILE_ATTRIBUTE_READONLY);
        SetFileAttributes(buffer, sattrib);

        if(DeleteFile(buffer) != TRUE)
            {
            SockPrint(sock, "        Unable to delete the file: %s (ec: %lu)\r\n", buffer, GetLastError());
            }
        else ++numFiles;
        } while(FindNextFile(hFind, &findData) == TRUE);
    FindClose(hFind);

    delete[] buffer;
    SockPrint(sock, "        %6u File(s) Deleted\r\n", numFiles);

    return ERR_OK;
    }


DWORD DIR(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "DIR");
        return ERR_SYNTAX;
        }

    WIN32_FIND_DATA findData;
    SYSTEMTIME sysTime;
    ULARGE_INTEGER available;
    ULARGE_INTEGER total;
    ULARGE_INTEGER free;
    HANDLE hFind;
    unsigned numFiles=0;
    unsigned numDirs=0;
    DWORD totalSize=0;

    hFind = FindFirstFile(nextToken, &findData);

    nextToken[3] = '\0'; // just leave the drive
    SockPrint(sock, "\r\n Directory of %s\r\n\r\n", nextToken);

    if(hFind == INVALID_HANDLE_VALUE)
        {
        SockPrint(sock, "No files found (ec: %lu)\r\n", GetLastError());
        }

    do
        {
        if(hFind == INVALID_HANDLE_VALUE) break;

        FileTimeToSystemTime(&findData.ftLastWriteTime, &sysTime);
        SockPrint(sock, "%02d/%02d/%04d  %02d:%02d%c %5s %9lu %s\r\n", sysTime.wMonth, sysTime.wDay, sysTime.wYear, (sysTime.wHour>12?sysTime.wHour-12:sysTime.wHour), sysTime.wMinute, (sysTime.wHour>12?'p':'a'), (findData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY?"<DIR>":""), findData.nFileSizeLow, findData.cFileName);

        if(findData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY) ++numDirs;
        else ++numFiles;
        totalSize += findData.nFileSizeLow;
        } while(FindNextFile(hFind, &findData) == TRUE);
    FindClose(hFind);

    available.QuadPart = 0;
    GetDiskFreeSpaceEx(nextToken, &available, &total, &free);

    SockPrint(sock, "        %6u File(s)  %12lu bytes\r\n", numFiles, totalSize);
    SockPrint(sock, "        %6u Dir(s)   %12I64u bytes free\r\n", numDirs, (unsigned __int64)available.QuadPart);

    return ERR_OK;
    }


DWORD ECHO(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        return ERR_SYNTAX;
        }

    SockPrint(sock, "%s\r\n", nextToken);
    DebugPrint("%s\n", nextToken);

    return ERR_OK;
    }


DWORD FORMAT(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "FORMAT");
        return ERR_SYNTAX;
        }
    bool mu = false;        // are we formatting an MU?
    DWORD port, slot;

    OBJECT_STRING deviceName;
    char muName[128];

    if(sscanf(nextToken, "\\Device\\MemoryUnit%02x_%02x", &port, &slot) == 2)
        {
        mu = true;
        if(usbmanager->devices[port][slot] != NULL && usbmanager->devices[port][slot]->type == XDEVICE_TYPE_MEMORY_UNIT)
            {
            delete (DeviceMU*)(usbmanager->devices[port][slot]);
            usbmanager->devices[port][slot] = NULL;
            }
        }

    RtlInitObjectString(&deviceName, nextToken);

    if(mu) OpenMU(port-1, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, muName);

    //DebugPrint("FORMAT: FormatFATVolume\n");
    if(XapiFormatFATVolume(&deviceName))
        {
        SockPrint(sock, "Format succeeded\r\n");
        }
    else
        {
        SockPrint(sock, "Format failed (ec: %lu)\r\n", GetLastError());
        }

    if(mu) CloseMU(port-1, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT);

    return ERR_OK;
    }


DWORD MKDIR(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "MKDIR");
        return ERR_SYNTAX;
        }

    if(CreateDirectory(nextToken, NULL) == FALSE)
        {
        SockPrint(sock, "        Unable to create directory (ec: %lu)\r\n", GetLastError());
        }

    return ERR_OK;
    }


DWORD MOVE(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "MOVE");
        return ERR_SYNTAX;
        }

    WIN32_FIND_DATA findData;
    HANDLE hFind;
    unsigned numFiles=0;
    char *file1, *file2;

    char* newFile = strchr(nextToken, ' ');
    if(!newFile)
        {
        HELP(sock, "MOVE");
        return ERR_SYNTAX;
        }
    *newFile = '\0';
    newFile += 1;

    char *path1 = new char[1024];
    char *path2 = new char[1024];

    if(!path1 || !path2)
        {
        delete[] path1;
        delete[] path2;
        return ERR_NOMEM;
        }

    strcpy(path1, nextToken);
    strcpy(path2, newFile);

    file1 = xPathFindFileName(path1);
    file2 = xPathFindFileName(path2);
    if(!file1 || !file2)
        {
        delete[] path1;
        delete[] path2;
        SockPrint(sock, "No files found.\r\n");
        return 1;
        }
    *file1 = '\0';
    *file2 = '\0';

    hFind = FindFirstFile(nextToken, &findData);
    if(hFind == INVALID_HANDLE_VALUE)
        {
        delete[] path1;
        delete[] path2;
        SockPrint(sock, "No files found (ec: %lu)\r\n", GetLastError());
        return 1;
        }

    do
        {
        if(strcmp(findData.cFileName, ".") == 0 || strcmp(findData.cFileName, "..") == 0) continue;

        strcpy(file1, findData.cFileName);
        strcpy(file2, findData.cFileName);

        if(MoveFile(path1, path2) != TRUE)
            {
            SockPrint(sock, "        Unable to move the file: %s (ec: %lu)\r\n", path1, GetLastError());
            }
        else ++numFiles;
        } while(FindNextFile(hFind, &findData) == TRUE);

    FindClose(hFind);

    SockPrint(sock, "        %6u file(s) moved\r\n", numFiles);

    delete[] path1;
    delete[] path2;

    return ERR_OK;
    }


DWORD REM(SOCKET sock, char *nextToken)
    {
    return ERR_OK;
    }


DWORD RMDIR(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "RMDIR");
        return ERR_SYNTAX;
        }

    if(RemoveDirectory(nextToken) == FALSE)
        {
        SockPrint(sock, "        Unable to remove directory (ec: %lu)\r\n", GetLastError());
        }

    return ERR_OK;
    }


void PrintVariable(char *name, void *p, void *param)
    {
    if(!p) return;
    SOCKET sock = (SOCKET)param;
    Variable *v = *(Variable**)p;
    SockPrint(sock, "%s=%s\r\n", name, v->value);
    }
DWORD SET(SOCKET sock, char *nextToken)
    {
    extern HashTable<Variable*, 13> variables;

    if(!*nextToken)
        {
        variables.ForAll(PrintVariable, (void*)sock);
        SockPrint(sock, "\r\n");
        return ERR_OK;
        }

    char *value = strchr(nextToken, '=');
    if(!value)
        {
        HELP(sock, "SET");
        return ERR_SYNTAX;
        }

    *value = '\0';
    ++value;

    variables.Add(nextToken, new Variable(value));

    return ERR_OK;
    }


DWORD TIMEDATE(SOCKET sock, char *nextToken)
    {
    SYSTEMTIME sysTime;

    /* TODO: SetSystemTime is currently not exported
    char ampm;
    if(*nextToken)
        {
        int items = sscanf(nextToken, "%02d/%02d/%04d %02d:%02d%c", &sysTime.wMonth, &sysTime.wDay, &sysTime.wYear, &sysTime.wHour, &sysTime.wMinute, &ampm);
        if(items == 6)
            {
            if(ampm == 'p' || ampm == 'P') sysTime.wHour += 12;
            SetSystemTime(&sysTime);
            }
        else
            {
            SockPrint(sock, "Set failed: use this syntax: MM/DD/YYYY HH:MM[a|p]\r\n");
            }
        }*/

    GetSystemTime(&sysTime);
    SockPrint(sock, "%02d/%02d/%04d %02d:%02d%c\r\n", sysTime.wMonth, sysTime.wDay, sysTime.wYear, (sysTime.wHour>12?sysTime.wHour-12:sysTime.wHour), sysTime.wMinute, (sysTime.wHour>12?'p':'a'));

    return ERR_OK;
    }


DWORD TYPE(SOCKET sock, char *nextToken)
    {
    if(!*nextToken)
        {
        HELP(sock, "TYPE");
        return ERR_SYNTAX;
        }

    DWORD len = 0;
    const unsigned chunkSize = 1024;
    unsigned char *buff = new unsigned char[chunkSize];
    if(!buff)
        {
        SockPrint(sock, "Error: Not enough memory.\r\n");
        return ERR_NOMEM;
        }

    HANDLE hFile = CreateFile(nextToken, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        {
        SockPrint(sock, "Could not open file (ec: %lu)\r\n", GetLastError());
        delete[] buff;
        return ERR_FILE;
        }
    for(DWORD i=0; i<GetFileSize(hFile, NULL); i+=chunkSize)
        {
        ReadFile(hFile, buff, chunkSize, &len, NULL);
        send(sock, (char*)buff, len, 0);
        }

    CloseHandle(hFile);
    delete[] buff;

    return ERR_OK;
    }


} // namespace Launcher
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\interpreter.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    interpreter.cpp

Abstract:

    Command interpreter and parser.

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-31-2000  Created

*/
#include "stdafx.h"
#include "launcherx.h"

namespace Launcher {


//
// general responses
//
char *responseHello = "\r\nXBox Harness Remote Window\r\n";
char *responsePrompt = "> ";
char *responseTimeout = "\r\n\r\nConnection timed out. Game Over.\r\n";
char *responseOk = "Done\r\n";
USBManager *usbmanager = NULL;

//
// Command Names, descriptions, help text, and function pointers
//
const CommandSet commands[] =
    {
    {"ATTRIB",
        "Displays the file attributes.",
        "ATTRIB [drive:\\path\\file]\r\n\r\n  [drive:\\path\\file]\r\n    Specifies drive, directory, and/or files to list.",
        ATTRIB},
    {"BARTEST",
        "Displays a series of colored bars on the video monitor.",
        "BARTEST",
        BARTEST},
    {"CALL",
        "Executes a batch program.",
        "CALL [drive:\\path\\file]\r\n\r\n  [drive:\\path\\file]\r\n    Specifies drive, directory, and file to execute.",
        CALL},
    {"COPY",
        "Copies one or more files to another location.",
        "COPY [drive:\\path\\file] [drive:\\path\\file]\r\n\r\n  [drive:\\path\\file]\r\n    Specifies drive, directory, and files to copy.",
        COPY},
    {"DEL",
        "Deletes one or more files.",
        "DEL [drive:\\path\\file]\r\n\r\n  [drive:\\path\\file]\r\n    Specifies drive, directory, and files to remove.",
        DEL},
    {"DIR",
        "Displays a list of files and subdirectories in a directory.",
        "DIR [drive:\\path\\file]\r\n\r\n  [drive:\\path\\file]\r\n    Specifies drive, directory, and/or files to list.",
        DIR},
    {"DISKIO",
        "Performs continuous reads or writes to a disk.",
        "DISKIO [IN|OUT] [drive]\r\n\r\n  IN       Specifies constant reads (default).\r\n  OUT      Specifies constant writes.\r\n  [drive]  is the letter for the mounted drive (F is default).",
        DISKIO},
    {"DUMP",
        "Displays the contents of a binary file.",
        "DUMP [drive:\\path\\file]\r\n\r\n  [drive:\\path\\file]\r\n    Specifies drive, directory, and file to display as a hex dump.",
        DUMP},
    {"FLUSH",
        "Flushes the cache.",
        "FLUSH",
        FLUSH},
    {"FORMAT",
        "Formats a FAT device.",
        "FORMAT [device name]\r\n\r\n  [device name]\r\n    \\Device\\MemoryUnit01_01 (mu port numbers are hex values, 1 based)\r\n    \\Device\\Harddisk0\\partition5",
        FORMAT},
    {"HELP",
        "Provides Help information for remote commands.",
        "HELP [command-name]",
        HELP},
    {"HOTPLUG",
        "Displays or sets whether or not devices will be initialized on insert.",
        "HOTPLUG [ON|OFF]",
        HOTPLUG},
    {"MD",
        "Creates a directory.",
        "MD [drive:][path]\r\n\r\n  [drive:][path]\r\n    Specifies drive, and directory to create.",
        MKDIR},
    {"MF",
        "Creates a file filled with a specific byte pattern.",
        "MF [drive:\\path\\file] [size] [pattern]\r\n\r\n  [drive:\\path\\file]  Specifies drive, path and file to create.\r\n  [size]         Maximum size of the file.\r\n  [pattern]      Hex pattern for the data allows up to 20 bytes.\r\n                 (eg: \"00 55 ff\")",
        MF},
    {"MODS",
        "Lists the modules callable with the RUN command.",
        "MODS",
        MODS},
    {"MOVE",
        "Moves one or more files from one directory to another directory.",
        "MOVE [drive:\\path\\file] [drive:\\path\\file]\r\n\r\n  [drive:\\path\\file]\r\n    Specifies drive, directory, and files to move.",
        MOVE},
    {"MU",
        "Handles MU specific operations",
        "MU [drive] [operation]\r\n\r\n  [drive]    The drive to perform the operation on.\r\n  [operation]\r\n    MOUNT - Mounts/remounts the specified MU drive\r\n\r\n  Diagnostic Operations (requires special build)\r\n    BADBLOCK - Displays the bad block table.\r\n    CLEARBADBLOCK - Flushes the bad block table.\r\n    MEMTEST - Performs the memory test.",
        MU},
    {"RD",
        "Removes a directory.",
        "RD [drive:][path]\r\n\r\n  [drive:][path]\r\n    Specifies drive, and directory to remove.",
        RMDIR},
    {"RAWREAD",
        "Performs a low level read from a device and writes the data to a file.",
        "RAWREAD [device] [drive:\\path\\file] [size]\r\n\r\n  [device]\r\n    Specifies the source device (eg \\Device\\MemoryUnit01_01)\r\n  [drive:\\path\\file]\r\n    Specifies the destination file.\r\n  [size]\r\n    Specifies the number of bytes to transfer.",
        RAWREAD},
    {"RAWWRITE",
        "Reads data from a file and low level writes it to a device.",
        "RAWWRITE [device] [drive:\\path\\file] [size]\r\n\r\n  [device]\r\n    Specifies the destination device (eg \\Device\\MemoryUnit01_01)\r\n  [drive:\\path\\file]\r\n    Specifies the data file.\r\n  [size]\r\n    Specifies the number of bytes to transfer.",
        RAWWRITE},
    {"REBOOT",
        "Reboots the system.",
        "REBOOT",
        REBOOT},
    {"REN",
        "Renames a file or files.",
        "REN [drive:\\path\\file] [drive:\\path\\file]\r\n\r\n  [drive:\\path\\file]\r\n    Specifies drive, directory, and files to rename.",
        MOVE},
    {"RUN",
        "Executes a Harness DLL.",
        "RUN [dll-name]\r\n\r\n  [dll-name]\r\n    Specifies the name of the harness dll to execute.\r\n\r\nUse the MODS command to see a list of callable modules.",
        RUN},
    {"SAVER",
        "Screen saver.",
        "SAVER\r\n    You must have xboxlogo.bmp in your tdata\\A7049955\\media directory",
        SAVER},
    {"SET",
        "Sets or views internal variables.",
        "SET [name=value]\r\n\r\nUse %name% to evaluate (eg format %MUF%)",
        SET},
    {"STATS",
        "Displays system resource information.",
        "STATS [/(VER|MEM|PS|NET|DISK|DEVICE|ALL)]\r\n\r\n  /ALL is default.",
        STATS},
    {"STRESS",
        "Shuts down stress.",
        "STRESS [mode]",
        STRESS},
    {"TIME",
        "Displays the system time and date.",
        "TIME",
        TIMEDATE},
    {"TYPE",
        "Displays the contents of a text file.",
        "TYPE [drive:\\path\\file]\r\n\r\n  [drive:\\path\\file]\r\n    Specifies drive, directory, and file to display.",
        TYPE},
    {"USB",
        "Dumps out the state of any connected XID devices.",
        "USB [num seconds]\r\n\r\n  [num seconds]    Specifies the duration of the dump (30 is default).",
        USB},
    {"WRITEINI",
        "Adds or edits an entry in the Harness INI file.",
        "WRITEINI section key=value\r\n\r\n  section       The INI file section, typically a dll name.\r\n  key=value     key is the name of the parameter and value is the data.\r\n\r\n  NOTE: you can use \"type t:\\testini.ini\" to view your changes.",
        WRITEINI},
    {"XMOUNT",
        "Mounts/remounts the specified MU drive.",
        "XMOUNT drive",
        XMOUNT},
    {"KILL",
        "Stops the current session and shuts down the remote server.",
        "KILL",
        NULL},
    {"QUIT|EXIT|BYE",
        "Exits this remote session and allows someone else to connect.",
        "QUIT",
        NULL}
    };

//
// these never get displayed in help
//
const CommandSet hiddenCommands[] =
    {
    {"?",
        "Provides Help information for remote commands.",
        "? [command-name]",
        HELP},
    {"ECHO",
        "Writes the input to the screen.",
        "ECHO [stuff]",
        ECHO},
    {"ERASE",
        "Deletes one or more files.",
        "ERASE [drive:\\path\\file]\r\n\r\n  [drive:\\path\\file]\r\n    Specifies drive, directory, and files to remove.",
        DEL},
    {"MKDIR",
        "Creates a directory.",
        "MKDIR [drive:][path]\r\n\r\n  [drive:][path]\r\n    Specifies drive, and directory to create.",
        MKDIR},
    {"REM",
        "Records comments (remarks) in batch files.",
        "",
        REM},
    {"RENAME",
        "Renames a file or files.",
        "RENAME [drive:\\path\\file] [drive:\\path\\file]\r\n\r\n  [drive:\\path\\file]\r\n    Specifies drive, directory, and files to rename.",
        MOVE},
    {"RMDIR",
        "Removes a directory.",
        "RMDIR [drive:][path]\r\n\r\n  [drive:][path]\r\n    Specifies drive, and directory to remove.",
        RMDIR},
    {"START",
        "Executes a Harness DLL.",
        "START [dll-name]\r\n\r\n  [dll-name]    Specifies the name of the harness dll to execute.\r\n\r\nUse the MODS command to see a list of callable modules.",
        RUN},
    {"TEST",
        "just a stub for internal tests",
        "",
        TEST}
    };

//
// command list sizes
//
const unsigned commandLength = ARRAYSIZE(commands);
const unsigned hiddenCommandLength = ARRAYSIZE(hiddenCommands);

HashTable<Variable*, 13> variables;

/*****************************************************************************

Routine Description:

    GetToken
    returns the location of the first and second tokens and the length of the first token

Arguments:

    char *str           - [in] string buffer
    char **tokenStart   - [out] start of the first token
    size_t *tokenLen    - [out] length of the first token
    char **nextToken    - [out] start of the next token

Return Value:

    char * - same as tokenStart

Notes:

    Example:
        GetToken("\t    abc  def ghij", &tokenStart, &tokenLen, &nextToken);

        printf(tokenStart) -> "abc  def ghij"
        printf(nextToken)  -> "def ghij"
        tokenLen == 3

*****************************************************************************/
char* GetToken(char *str, char **tokenStart, size_t *tokenLen, char **nextToken)
    {
    size_t leadingBlank = strspn(str, " \t\n");
    str += leadingBlank;
    size_t len = strcspn(str, " \t\n");
    size_t trailingBlank = strspn(str + len, " \t\n");

    *tokenStart = str;
    *tokenLen = len;
    *nextToken = str+len+trailingBlank;

    return str;
    }


/*****************************************************************************

Routine Description:

    ExecuteCommand
    Given a token it tries to resolve it into a command name and then call the
    appropriate function.

Arguments:

    SOCKET sock     - [in] socket all communication should be sent through
    char *token     - [in] the name of the command
    char *nextToken - [in] the string containing any parameters to the cmd

Return Value:

    DWORD

*****************************************************************************/
DWORD ExecuteCommand(SOCKET sock, char *token, char *nextToken)
    {
    usbmanager->CheckForHotplugs();

    // check for help switch
    if(strcmp(nextToken, "/?") == 0) return HELP(sock, token);

    // execute the command if its valid
    for(unsigned i=0; i<commandLength; i++)
        {
        if(strcmp(commands[i].name, token) == 0)
            {
            return commands[i].funct(sock, nextToken);
            }
        }
    for(i=0; i<hiddenCommandLength; i++)
        {
        if(strcmp(hiddenCommands[i].name, token) == 0)
            {
            return hiddenCommands[i].funct(sock, nextToken);
            }
        }

    return ERR_UNKNOWN;
    }



/*****************************************************************************

Routine Description:

    Parser

    1. Waits for input on the connected socket
    2. Pieces together a command
    3. Tries to execute that command (if its valid)
    4. Goto 1

Arguments:

    SOCKET sock         - [in] socket all communication goes through
    CSockServer *server - [in] pointer to the server that connected the socket

Return Value:

    DWORD

Notes:

    0x0D 0x0A           Enter
    0x0D                keypad Enter
    0x08                Backspace
    0x09                Tab
    0x7F                Del
    0x1B                Esc
    0x1B 0x5B 0x41      up arrow
    0x1B 0x5B 0x42      down arrow
    0x1B 0x5B 0x43      right arrow
    0x1B 0x5B 0x44      left arrow

*****************************************************************************/
DWORD Parser(SOCKET sock, CSockServer *server)
    {
    DebugPrint("LAUNCHER: connected to client\n");

    variables.SetCleanupFunct(DestroyVariable);
    variables.Add("MUF", new Variable("\\Device\\MemoryUnit01_01"));
    variables.Add("MUG", new Variable("\\Device\\MemoryUnit01_02"));
    variables.Add("MUH", new Variable("\\Device\\MemoryUnit02_01"));
    variables.Add("MUI", new Variable("\\Device\\MemoryUnit02_02"));
    variables.Add("MUJ", new Variable("\\Device\\MemoryUnit03_01"));
    variables.Add("MUK", new Variable("\\Device\\MemoryUnit03_02"));
    variables.Add("MUL", new Variable("\\Device\\MemoryUnit04_01"));
    variables.Add("MUM", new Variable("\\Device\\MemoryUnit04_02"));
    variables.Add("8MEG", new Variable("8388608"));

    const unsigned HISTORY_MAX_SIZE = 10;
    char *buffer = new char[1024];
    char *command = new char[1024];
    char *history[HISTORY_MAX_SIZE];
    char *parameters = new char[1024];
    unsigned historyLast, historySize, historyPtr;
    for(historyLast=0; historyLast<HISTORY_MAX_SIZE; historyLast++)
        {
        history[historyLast] = new char[1024];
        memset(history[historyLast], 0, 1024);
        }
    historyLast=historyPtr = HISTORY_MAX_SIZE-1;
    historySize = 0;
    usbmanager = new USBManager;
    if(!buffer || !command || !usbmanager || !parameters)
        {
        DebugPrint("LAUNCHER: Out of memory!\n");
        delete[] buffer;
        delete[] command;
        delete[] parameters;
        delete usbmanager;
        return ERR_NOMEM;
        }
    int len;
    DWORD err;
    char *t;
    char *token;
    char *nextToken;
    size_t tokenLen;
    buffer[0] = '\0';
    command[0] = '\0';

    SockPrint(sock, responseHello);

    CALL(sock, "t:\\autoexec.bat");
    CALL(sock, "z:\\autoexec.bat");

    SockPrint(sock, "\r\n\r\n%s", responsePrompt);

    do
        {
        // wait for data from client
        if(!server->IsDataAvailable(sock))
            {
            // we timed out
            SockPrint(sock, responseTimeout);
            break;
            }

        len = recv(sock, buffer, 1024, 0);
        if(len == 0 || len == SOCKET_ERROR) break;
        buffer[len] = '\0';

        //HexDump(INVALID_SOCKET, (unsigned char*)buffer, len);

        // handle escape key
        if(buffer[0] == 0x1B && len == 1)
            {
            // just a plain ol esc key - clear the current input
            command[0]='\0';
            SockPrint(sock, "\r%79s\r%s", "", responsePrompt);
            continue;
            }
        else if(buffer[0] == 0x1B)
            {
            // handle escape sequences such as arrow keys
            if(len == 3 && buffer[2] == 0x41) // up arrow
                {
                if(historySize == 0) continue;
                strcpy(command, history[historyPtr]);
                historyPtr = (historySize+historyPtr-1)%historySize;
                SockPrint(sock, "\r%79s\r%s%s", "", responsePrompt, command);
                continue;
                }
            else if(len == 3 && buffer[2] == 0x42) // down arrow
                {
                if(historySize == 0) continue;
                strcpy(command, history[historyPtr]);
                historyPtr = (historyPtr+1)%historySize;
                SockPrint(sock, "\r%79s\r%s%s", "", responsePrompt, command);
                continue;
                }
            }

        // ignore invalid inputs
        if(buffer[0] >= 127) continue;
        if(buffer[0] < 32 && buffer[0]!=8 && buffer[0]!='\r') continue;

        // add the input to the command
        strcat(command, buffer);

        // handle backspaces
        while((t = strchr(command, '\x08')) != NULL)
            {
            if(t == command) memmove(t, t+1, strlen(t));
            else memmove(t-1, t+1, strlen(t));
            }
        /*
        // handle erronous '\r' characters when pasting text in telnet client
        // but this will also prevent clients from sending commands and \r in
        // the same packet
        while((t = strchr(command, '\r')) != NULL && len>2)
            {
            memmove(t, t+1, strlen(t));
            }
            */

        // reprint the current command
        SockPrint(sock, "\r%79s\r%s%s", "", responsePrompt, command);

        // execute the command if they hit Enter
        if((t=strchr(command, '\r')) != 0)
            {
            t[0] = '\0';

            // use the last command if they just hit Enter
            if(command[0] == '\0')
                {
                strcpy(command, history[historyLast]);
                }
            else // save the command in the history
                {
                if(_stricmp(command, history[historyLast]) != 0)
                    {
                    if(historySize<HISTORY_MAX_SIZE) ++historySize;
                    historyPtr=historyLast = (historyLast+1)%HISTORY_MAX_SIZE;
                    strcpy(history[historyLast], command);
                    }
                else
                    {
                    historyPtr = historyLast;
                    }
                }

            // make it uppercase
            _strupr(command);

            // break the pieces out
            GetToken(command, &token, &tokenLen, &nextToken);
            token[tokenLen] = '\0';

            // look for exit commands
            if(strcmp(token, "EXIT")==0 || _stricmp(token, "BYE")==0 || _stricmp(token, "QUIT")==0)
                {
                SockPrint(sock, responseOk);
                break;
                }
            else if(strcmp(token, "KILL")==0)
                {
                server->SetExitFlag(TRUE);
                SockPrint(sock, responseOk);
                break;
                }

            // expand any variables
            LinePreProcessor(nextToken, parameters);

            // run the command
            err = ExecuteCommand(sock, token, parameters);

            if(err == ERR_UNKNOWN)
                {
                // others
                if(strcmp(token, "LS")==0)
                    {
                    SockPrint(sock, "This aint no freakin unix box!\r\n");
                    }

                // unknown command
                else
                    {
                    SockPrint(sock, "Unknown Command: %s\r\nType HELP for a list of supported commands\r\n", command);
                    }
                }

            command[0] = '\0';
            SockPrint(sock, responsePrompt);
            }

        } while(!server->GetExitFlag());

    delete usbmanager;
    delete[] buffer;
    delete[] command;
    delete[] parameters;
    for(historyLast=0; historyLast<HISTORY_MAX_SIZE; historyLast++)
        {
        delete[] history[historyLast];
        }

    return ERR_OK;
    }


Variable::Variable()
    {
    value = NULL;
    valueLen = 0;
    }

Variable::Variable(char *v)
    {
    valueLen = strlen(v) + 1;
    value = new char[valueLen];
    if(value) strcpy(value, v);
    }

Variable::~Variable()
    {
    if(value) delete[] value;
    value = NULL;
    }

// Called by the HashTable to clean up the variables
// As per "variables.SetCleanupFunct(DestroyVariable);"
void DestroyVariable(char *name, void *p, void *param)
    {
    if(!p) return;
    Variable *v = *(Variable**)p;
    delete v;
    }



size_t LinePreProcessor(char *input, char *output)
    {
    char *keyToken;
    char *nextToken;
    size_t offset;
    size_t tokenLen;
    size_t totalProcessed=0;
    Variable *var;
    char *params = NULL;
    char spacer; // the char we temporarily replace with the null

    if(!input || !output) return FALSE;

    output[0] = '\0';

    while((keyToken = strstr(input, "%")) != NULL)
        {
        offset = (size_t)(keyToken - input);

        // copy up to the keyword
        memcpy(output, input, offset);
        output[offset] = '\0';
        output += offset;

        // we were evaluating a function's params + and hit the end
        if(offset && *(keyToken-1)==')')
            {
            output[-1] = '\0';
            totalProcessed += offset-1;
            delete[] params;
            return totalProcessed;
            }

        // skip "%"
        keyToken += 1;
        offset += 1;

        // find end of the token
        tokenLen = strcspn(keyToken, "%(");

        // PRECEDENCE
        if(keyToken[0] == '(')
            {
            offset += LinePreProcessor(&keyToken[tokenLen+1], params) + 2; // +2 "()"
            if(variables.Get(params, var))
                {
                memcpy(output, var->value, var->valueLen);
                output += var->valueLen-1;
                }
            else if((nextToken = strstr(keyToken, "%")) != NULL)
                {
                // unknown variable, so just copy it (minus the % delimators)
                sprintf(output, "%s", params);
                }
            }

        // INLINE FUNCTIONS
        else if(keyToken[tokenLen] == '(')
            {/*
            if(!params) params = new char[4096];
            // evaluate the arguments
            offset += tokenLen;
            size_t len = LinePreProcessor(&keyToken[tokenLen+1], params) + 3; // +3 "()%"
            offset += len;

            INLINE_FUNC fn;

            spacer = keyToken[tokenLen];
            keyToken[tokenLen] = '\0';
            if(inlineFunctions.Get(keyToken, fn))
                {
                output += (this->cmdClass.*fn)(params, output);
                }
            else
                {
                // unknown function, so just copy it (with its params)
                output += sprintf(output, "%s(%s)", keyToken, params);
                }
            keyToken[tokenLen] = spacer;*/
            }

        // VARIABLES
        else
            {
            spacer = keyToken[tokenLen];
            keyToken[tokenLen] = '\0';
            if(variables.Get(keyToken, var))
                {
                offset += strlen(keyToken) + 1; // +1 for the "%"
                memcpy(output, var->value, var->valueLen);
                output += var->valueLen-1;
                }/*
            else if(strcmp(keyToken, "HTTPSTATUS") == 0)
                {
                offset += strlen(keyToken) + 1; // +1 for the "%"
                short status;
                engine->get_httpStatus(&status);
                output += sprintf(output, "%03d", status);
                }*/
            else if((nextToken = strstr(keyToken, "%")) != NULL)
                {
                // unknown variable, so just copy it (minus the % delimators)
                memcpy(output, keyToken, tokenLen+1);
                output += tokenLen;
                offset += tokenLen+1;
                }
            keyToken[tokenLen] = spacer;
            }

        input += offset;
        totalProcessed += offset;
        }

    // copy the last part of the string
    strcpy(output, input);
    delete[] params;
    return totalProcessed;
    }

} //namespace Launcher
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\draw.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    draw.h

Abstract:

    function declarations for draw.cpp

Author:

    Jason Gould (a-jasgou)   May 2000
    Josh Poley (jpoley)      Oct 2000

Revision History:

--*/
#ifndef __draw_h_
#define __draw_h_

namespace Launcher {

#define _UseD3d_ //d3d works now...
// #define _UseDxConio_ //define this to use dxconio

#define SCALEX(n) ((n)*(8/7))
#define SCALEY(n) ((n)*(3/2))
#define BUILDARGB(a, r, g, b) (((a) << 24) + ((r) << 16) + ((g) << 8) + (b))

void drInit(int width = 640, int height = 480);
void drDeinit();
void drBox(float x1, float y1, float x2, float y2, DWORD col);
void drLine(float x1, float y1, float x2, float y2, DWORD col);
void drSetSize(float width = 7, float height = 15, DWORD col = 0xffffffff, DWORD bkcol = 0);
int drPrintf(float x1, float y1, WCHAR* format, ...);
void drGetSize(float*pwidth, float*pheight, DWORD*pcolor, DWORD*pbkcolor);
void drShowScreen();
void drCls();
void drQuad(float x1, float y1, DWORD c1, float x2, float y2, DWORD c2, float x3, float y3, DWORD c3, float x4, float y4, DWORD c4);
DWORD drScaledFloatToRgba(float r, float g, float b, float a);	 //floats from 0=>1
DWORD drUnscaledFloatToRgba(float r, float g, float b, float a);//floats from 0=>255
DWORD drHslToRgb(float h, float s, float l, float al);

#pragma pack(push, 1)
typedef struct tagBITMAPFILEHEADER
    {
    unsigned __int16 bfType;
    unsigned __int32 bfSize;
    unsigned __int32 bfReserved1;
    unsigned __int32 bfOffBits;
    } BITMAPFILEHEADER, *PBITMAPFILEHEADER;
typedef struct tagBITMAPINFOHEADER
    {
    unsigned __int32 biSize;
    unsigned __int32 biWidth;
    unsigned __int32 biHeight;
    unsigned __int16 biPlanes;
    unsigned __int16 biBitCount;
    unsigned __int32 biCompression;
    unsigned __int32 biSizeImage;
    unsigned __int32 biXPelsPerMeter;
    unsigned __int32 biYPelsPerMeter;
    unsigned __int32 biClrUsed;
    unsigned __int32 biClrImportant;
    } BITMAPINFOHEADER, *PBITMAPINFOHEADER;
typedef struct tagColorTable
    {
    unsigned __int8 blue;
    unsigned __int8 green;
    unsigned __int8 red;
    unsigned __int8 reserved;
    } ColorTable;
#pragma pack(pop)

class Bitmap
    {
    public:
        BITMAPFILEHEADER bitmapHeader;
        BITMAPINFOHEADER bitmapInfo;
        ColorTable *palatte;
        unsigned char *image;

    public:
        Bitmap();
        Bitmap(char *filename);
        ~Bitmap();

    public:
        DWORD LoadFile(char *filename);
        DWORD Draw(DWORD offsetX, DWORD offsetY, DWORD trans = 0xFFFF);
    };

} // namespace Launcher

#endif // __draw_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\launcherx.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    launcherx.h

Abstract:

    Internal header file

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-31-2000  Created

*/

#ifndef _LAUNCHERX_H_
#define _LAUNCHERX_H_

#include <winsockx.h>
#include <xnetref.h>
#include "launcher.h"
#include "CSockServer.h"
#include "usbmanager.h"

extern void __stdcall penterDumpStats(void);

namespace Launcher {

typedef DWORD (*CMD_FUNC)(SOCKET sock, char *nextToken);

struct CommandSet
    {
    char *name;
    char *helpShort;
    char *helpLong;
    CMD_FUNC funct;
    };


#define CLEARFLAG(var, flag)                (var &= ~(flag))
#define SETFLAG(var, flag)                  (var |=  (flag))
#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define KILOBYTE 1024
#define MEGABYTE (KILOBYTE*KILOBYTE)

extern USBManager *usbmanager;

//
// error codes
//
#define ERR_OK      100
#define ERR_NOMEM   101 // out of memory
#define ERR_UNKNOWN 102 // unknown command
#define ERR_SYNTAX  103 // invalid syntax
#define ERR_EXIT    104 // quit the server
#define ERR_FILE    105

//
// common responses
//
extern char *responseHello;
extern char *responsePrompt;
extern char *responseTimeout;
extern char *responseOk;

//
// parser
//
const extern CommandSet commands[];
const extern CommandSet hiddenCommands[];
const extern unsigned commandLength;
const extern unsigned hiddenCommandLength;
extern DWORD ExecuteCommand(SOCKET sock, char *token, char *nextToken);
extern char* GetToken(char *str, char **tokenStart, size_t *tokenLen, char **nextToken);
extern DWORD Parser(SOCKET sock, CSockServer *server);
extern size_t LinePreProcessor(char *input, char *output);

//
// dos commands
//
extern DWORD ATTRIB(SOCKET sock, char *nextToken);
extern DWORD CALL(SOCKET sock, char *nextToken);
extern DWORD COPY(SOCKET sock, char *nextToken);
extern DWORD DIR(SOCKET sock, char *nextToken);
extern DWORD DEL(SOCKET sock, char *nextToken);
extern DWORD ECHO(SOCKET sock, char *nextToken);
extern DWORD FORMAT(SOCKET sock, char *nextToken);
extern DWORD MKDIR(SOCKET sock, char *nextToken);
extern DWORD MOVE(SOCKET sock, char *nextToken);
extern DWORD REM(SOCKET sock, char *nextToken);
extern DWORD RMDIR(SOCKET sock, char *nextToken);
extern DWORD SET(SOCKET sock, char *nextToken);
extern DWORD TIMEDATE(SOCKET sock, char *nextToken);
extern DWORD TYPE(SOCKET sock, char *nextToken);

//
// other commands
//
extern DWORD BARTEST(SOCKET sock, char *nextToken);
extern DWORD DISKIO(SOCKET sock, char *nextToken);
extern DWORD DUMP(SOCKET sock, char *nextToken);
extern DWORD FLUSH(SOCKET sock, char *nextToken);
extern DWORD HELP(SOCKET sock, char *nextToken);
extern DWORD HOTPLUG(SOCKET sock, char *nextToken);
extern DWORD MF(SOCKET sock, char *nextToken);
extern DWORD MODS(SOCKET sock, char *nextToken);
extern DWORD MU(SOCKET sock, char *nextToken);
extern DWORD RAWREAD(SOCKET sock, char *nextToken);
extern DWORD RAWWRITE(SOCKET sock, char *nextToken);
extern DWORD REBOOT(SOCKET sock, char *nextToken);
extern DWORD RUN(SOCKET sock, char *nextToken);
extern DWORD SAVER(SOCKET sock, char *nextToken);
extern DWORD STATS(SOCKET sock, char *nextToken);
extern DWORD STRESS(SOCKET sock, char *nextToken);
extern DWORD TEST(SOCKET sock, char *nextToken);
extern DWORD USB(SOCKET sock, char *nextToken);
extern DWORD WRITEINI(SOCKET sock, char *nextToken);
extern DWORD XMOUNT(SOCKET sock, char *nextToken);


//
// utils
//
extern WCHAR* Ansi2UnicodeHack(char *str);
extern char* Unicode2AnsiHack(unsigned short *str);
extern void HexDump(SOCKET sock, const unsigned char * buffer, DWORD length, DWORD offset=0);
void FlushDiskCache(void);
char* xPathFindFileName(char *name);
bool NetHit(SOCKET sock, unsigned usec=0);
bool OpenMU(unsigned port, unsigned slot, char *device);
bool CloseMU(unsigned port, unsigned slot);
bool MUDiagnosticIoctl(SOCKET sock, unsigned port, unsigned slot, DWORD ioctl, void *output, DWORD &size);
bool ReadMUCapacity(HANDLE handle);
DWORD RawRead(char *device, char *file, DWORD offset, DWORD size);
DWORD RawWrite(char *device, char *file, DWORD offset, DWORD size);






//
// Variable hash tables etc.
//

typedef void (*HASHOBJ_FUNC)(char *, void*, void*);

/*****************************************************************************

Class Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T> class HashEntry
    {
    public:
        char *key;
        T obj;
        HashEntry <T> *next;

    public:
        HashEntry();
        HashEntry(char *k, T o);
        ~HashEntry();
    };

/*****************************************************************************

Class Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T, size_t SIZE> class HashTable
    {
    public:
        HashTable();
        ~HashTable();

        HASHOBJ_FUNC clean;
        size_t m_size;

    public:
        HashEntry<T> *table[SIZE];

        BOOL Get(char *key, T& out);
        BOOL Add(char *key, T o);
        BOOL ForAll(HASHOBJ_FUNC fn, void *param);
        void SetCleanupFunct(HASHOBJ_FUNC c) { clean = c; }
    };

class Variable
    {
    public:
        char *value;
        size_t valueLen; // size of the buffer

    public:
        Variable();
        Variable(char *v);
        ~Variable();
    };

extern void DestroyVariable(char *name, void *p, void *param);

/*****************************************************************************

Routine Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T>
HashEntry<T>::HashEntry()
    {
    clean = NULL;
    key = NULL;
    next = NULL;
    }


/*****************************************************************************

Routine Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T>
HashEntry<T>::HashEntry(char *k, T o)
    {
    key = new char[strlen(k)+1];
    strcpy(key, k);
    obj = o;
    next = NULL;
    }

/*****************************************************************************

Routine Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T>
HashEntry<T>::~HashEntry()
    {
    if(key) delete[] key;
    if(next) delete next;
    }

/*****************************************************************************

Routine Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T, size_t SIZE>
HashTable<T, SIZE>::HashTable()
    {
    m_size = SIZE;
    clean = NULL;
    for(size_t i=0; i<SIZE; i++)
        {
        table[i] = NULL;
        }
    }


/*****************************************************************************

Routine Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T, size_t SIZE>
HashTable<T, SIZE>::~HashTable()
    {
    if(clean) ForAll(clean, NULL);
    for(size_t i=0; i<SIZE; i++)
        {
        if(table[i]) delete table[i];
        }
    }

/*****************************************************************************

Routine Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T, size_t SIZE>
BOOL HashTable<T, SIZE>::Get(char *key, T& out)
    {
    if(!key) return FALSE;

    size_t i = (key[0] + key[1]) % SIZE;

    if(!table[i]) return FALSE;

    for(HashEntry<T> *h = table[i]; h; h=h->next)
        {
        if(strcmp(h->key, key) == 0)
            {
            out = h->obj;
            return TRUE;
            }
        }

    return FALSE;
    }

/*****************************************************************************

Routine Description:

    Add the key and the associated object. Add the new HashEntry at the end
    of the list to give precedence to items added first.

Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T, size_t SIZE>
BOOL HashTable<T, SIZE>::Add(char *key, T o)
    {
    if(!key) return FALSE;
    size_t i = (key[0] + key[1]) % SIZE;

    if(!table[i])
        {
        table[i] = new HashEntry<T>(key, o);
        return TRUE;
        }
    else
        {
        HashEntry<T> *h = table[i];
        do
            {
            // replace entry with the same key
            if(_stricmp(h->key, key) == 0)
                {
                if(clean) clean(h->key, &(h->obj), NULL);
                h->obj = o;
                return TRUE;
                }

            // otherwise add it to the end
            if(!h->next)
                {
                h->next = new HashEntry<T>(key, o);
                return TRUE;
                }

            h=h->next;
            } while(h);
        }

    return FALSE;
    }

/*****************************************************************************

Routine Description:



Arguments:



Return Value:



Notes:



*****************************************************************************/
template <class T, size_t SIZE>
BOOL HashTable<T, SIZE>::ForAll(HASHOBJ_FUNC fn, void *param)
    {
    for(size_t i=0; i<SIZE; i++)
        {
        if(table[i])
            {
            for(HashEntry<T> *h = table[i]; h; h=h->next)
                {
                fn(h->key, &(h->obj), param);
                }
            }
        }
    return TRUE;
    }

} // namespace Launcher

#endif //_LAUNCHERX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\draw.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    draw.cpp

Abstract:

    simplified functions that call Matt's dxconio functions... Used by CPX

Author:

    Jason Gould (a-jasgou) May 2000

*/

#include "stdafx.h"

#include <Xfont.h>
#include <d3dx8math.h>
#include "draw.h"

namespace Launcher {

typedef struct MYVERTEX
    {
    D3DXVECTOR3 v;
    float       fRHW;
    D3DCOLOR    cDiffuse;
    } MYVERTEX, *PMYVERTEX;

static IDirect3DDevice8* gDevice = 0;
static IDirect3DSurface8* gBackBuffer = 0;
static IDirect3DVertexBuffer8* gVertexBuffer = 0;

static int gScreenWidth = 640; 
static int gScreenHeight = 480;
static float gWidth = 8;
static float gHeight = 15;
static DWORD gColor = 0xff00ff00;
static DWORD gBkColor = 0xff000000;
static XFONT* gFont = 0;


Bitmap::Bitmap()
    {
    memset(&bitmapHeader, 0, sizeof(BITMAPFILEHEADER));
    memset(&bitmapInfo, 0, sizeof(BITMAPINFOHEADER));
    palatte = NULL;
    image = NULL;
    }

Bitmap::Bitmap(char *filename)
    {
    memset(&bitmapHeader, 0, sizeof(BITMAPFILEHEADER));
    memset(&bitmapInfo, 0, sizeof(BITMAPINFOHEADER));
    palatte = NULL;
    image = NULL;

    LoadFile(filename);
    }

Bitmap::~Bitmap()
    {
    if(palatte) delete[] palatte;
    if(image) delete[] image;
    }


DWORD Bitmap::LoadFile(char *filename)
    {
    FILE *in = fopen(filename, "rb");

    if(!in)
        {
        DebugPrint("BMP: Error opening file!\r\n");
        return 0;
        }

    if(palatte) delete[] palatte;
    if(image) delete[] image;

    fread(&bitmapHeader, sizeof(BITMAPFILEHEADER), 1, in);
    fread(&bitmapInfo, sizeof(BITMAPINFOHEADER), 1, in);
    unsigned palletSize = 1 << bitmapInfo.biBitCount;

/*
    DebugPrint("BMP: Loading %s\r\n", filename);
    DebugPrint("BMP: biSize -           %lu\r\n", bitmapInfo.biSize);
    DebugPrint("BMP: biWidth -          %lu\r\n", bitmapInfo.biWidth);
    DebugPrint("BMP: biHeight -         %lu\r\n", bitmapInfo.biHeight);
    DebugPrint("BMP: biPlanes -         %lu\r\n", bitmapInfo.biPlanes);
    DebugPrint("BMP: biBitCount -       %lu\r\n", bitmapInfo.biBitCount);
    DebugPrint("BMP: biCompression -    %lu\r\n", bitmapInfo.biCompression);
    DebugPrint("BMP: biSizeImage -      %lu\r\n", bitmapInfo.biSizeImage);
    DebugPrint("BMP: biXPelsPerMeter -  %lu\r\n", bitmapInfo.biXPelsPerMeter);
    DebugPrint("BMP: biYPelsPerMeter -  %lu\r\n", bitmapInfo.biYPelsPerMeter);
    DebugPrint("BMP: biClrUsed -        %lu\r\n", bitmapInfo.biClrUsed);
    DebugPrint("BMP: biClrImportant -   %lu\r\n", bitmapInfo.biClrImportant);
    DebugPrint("BMP: palletSize -       %lu\r\n", palletSize);
*/

    palatte = new ColorTable[palletSize];
    if(!palatte)
        {
        fclose(in);
        return 0;
        }

    image = new unsigned char[bitmapInfo.biSizeImage];
    if(!image)
        {
        delete[] palatte;
        palatte = NULL;
        fclose(in);
        return 0;
        }

    fread(palatte, sizeof(ColorTable), palletSize, in);
    fread(image, sizeof(unsigned char), bitmapInfo.biSizeImage, in);

    fclose(in);

    return 1;
    }


DWORD Bitmap::Draw(DWORD offsetX, DWORD offsetY, DWORD trans /*=0xFFFF*/)
    {
    if(!palatte || !image) return 0;

    for(DWORD size=0; size<bitmapInfo.biSizeImage; size++)
        {
        if(image[size] == trans) drLine((float)(size%bitmapInfo.biWidth+offsetX), (float)(bitmapInfo.biHeight-size/bitmapInfo.biWidth+offsetY), (float)(size%bitmapInfo.biWidth+1+offsetX), (float)(bitmapInfo.biHeight-size/bitmapInfo.biWidth+1+offsetY), 0x00000000);
        else drLine((float)(size%bitmapInfo.biWidth+offsetX), (float)(bitmapInfo.biHeight-size/bitmapInfo.biWidth+offsetY), (float)(size%bitmapInfo.biWidth+1+offsetX), (float)(bitmapInfo.biHeight-size/bitmapInfo.biWidth+1+offsetY), BUILDARGB(0xFF, palatte[image[size]].red, palatte[image[size]].green, palatte[image[size]].blue));
        }

    /*
    MYVERTEX *pb;
    float maxx, minx;
    float maxy, miny;

    gDevice->BeginScene();
    gVertexBuffer->Lock(0, 128, (BYTE**)&pb, 0);

    if(IsBadWritePtr(pb, 128))
        {
        DebugPrint("Lock returned %p, which is BAD!\n", pb);
        return 1;
        }
    
    for(DWORD size = 0; size<bitmapInfo.biSizeImage; size++)
        {
        pb[size].v.x = (float)(size%bitmapInfo.biWidth+offsetX);
        pb[size].v.y = (float)(bitmapInfo.biHeight-size/bitmapInfo.biWidth+offsetY);
        pb[size].v.z = 0.1f;
        pb[size].fRHW = 0.9f;
        pb[size].cDiffuse = BUILDARGB(0xFF, palatte[image[size]].red, palatte[image[size]].green, palatte[image[size]].blue);
        }

    gVertexBuffer->Unlock();

    gDevice->DrawPrimitive(D3DPT_POINTLIST, 0, size);
    gDevice->EndScene();
        */

    return 1;
    }


void drBitmap(float x, float y, DWORD dwWidth, DWORD dwHeight, DWORD *bitmap)
    {
    /*
    for(DWORD points = 0; points<dwWidth*dwHeight; points++)
        {
        drLine(x+dwWidth, y+dwHeight, x+dwWidth+1, y+dwHeight+1, bitmap[points]);
        }
    */

    MYVERTEX *pb;
    float maxx, minx;
    float maxy, miny;

    gDevice->BeginScene();
    gVertexBuffer->Lock(0, 128, (BYTE**)&pb, 0);

    if(IsBadWritePtr(pb, 128))
        {
        DebugPrint("Lock returned %p, which is BAD!\n", pb);
        return;
        }
    
    for(DWORD points = 0; points<dwWidth*dwHeight; points++)
        {
        pb[points].v.x = x+points%dwWidth;
        pb[points].v.y = y+points/dwWidth;
        pb[points].v.z = .1f;
        pb[points].fRHW = .9f;
        pb[points].cDiffuse = bitmap[points];
        }

    gVertexBuffer->Unlock();

    gDevice->DrawPrimitive(D3DPT_POINTLIST, 0, points);
    gDevice->EndScene();
    }


/*************************************************************************************
Function:   drInit
Purpose:    initialize drawing stuff
Return:     none
*************************************************************************************/
void drInit(int width, int height)
    {
    gScreenWidth = width;
    gScreenHeight = height;
    gBackBuffer = NULL;

    if(gDevice == NULL)
        {
        // Create D3D 8.
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if(pD3D == NULL) return;

        // Set the screen mode.
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));

        // E:\XBOX\private\genx\directx\dxg\obj\i386\d3d8types.h
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;    //or 72?
        d3dpp.hDeviceWindow             = NULL;   // Ignored on Xbox

        // Create the gDevice.
        if(pD3D->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &gDevice) != S_OK)
            {
            pD3D->Release();
            return;
            }

        // Now we no longer need the D3D interface so let's free it.
        pD3D->Release();
        }

    gDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &gBackBuffer);

    gDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    gDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    gDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    gDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    gDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

    gDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
    gDevice->CreateVertexBuffer(sizeof(MYVERTEX)*4, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &gVertexBuffer);
    gDevice->SetStreamSource(0, gVertexBuffer, sizeof(MYVERTEX));

    XFONT_OpenBitmapFont(L"t:\\media\\cour.xft", 4096, &gFont);

    if(gFont == 0)
        {
        XFONT_OpenBitmapFont(L"t:\\media\\arialb16.xft", 4096, &gFont);
        //DebugPrint("Opening arial: %x\n", );
        }

    if(gFont)
        {
        XFONT_SetTextColor(gFont, 0xffFFFFFF);
        XFONT_SetBkColor(gFont, 0x00000000);
        }
    else
        {
        DebugPrint("gFont == 0! Font not loaded!\n");
        }
    }


/*************************************************************************************
Function:   drDeinit
Purpose:    deinitialize the drawing stuff
Return:     none
*************************************************************************************/
void drDeinit()
    {
    gBackBuffer->Release();
    gDevice->Release();
    }


void drClearRect(float x1, float y1, float x2, float y2, DWORD color) 
    {
    D3DRECT rect;

    if (gDevice != NULL)
        {
        if(x1 < x2)
            {
            rect.x1 = (long)x1; 
            rect.x2 = (long)x2 + 1;
            }
        else
            {
            rect.x1 = (long)x2; 
            rect.x2 = (long)x1 + 1;
            }

        if(y1 < y2)
            {
            rect.y1 = (long)y1;
            rect.y2 = (long)y2 + 1;
            }
        else
            {
            rect.y1 = (long)y2;
            rect.y2 = (long)y1 + 1;
            }

        gDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
        }

    }


/*************************************************************************************
Function:   drCls
Purpose:    clears the screen
Return:     none
*************************************************************************************/
void drCls()
    {
    drClearRect(0, 0, 639, 479, 0xFF000000);
    }



/*************************************************************************************
Function:   drBox
Purpose:    draw a rectangle
Params:     x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
            col --- the RGBA color to draw the box with
Return:     none
*************************************************************************************/
void drLine(float x1, float y1, float x2, float y2, DWORD color)
    {
    drClearRect(x1, y1, x2, y2, color);
    }


/*************************************************************************************
Function:   drQuad
Purpose:    draw a quadrilateral
Params:     x* --- x coordinate for point * 
            y* --- y coordinate for point *
            c* --- color at point *
Return:     none
*************************************************************************************/
void drQuad(float x1, float y1, DWORD c1,
            float x2, float y2, DWORD c2,
            float x3, float y3, DWORD c3,
            float x4, float y4, DWORD c4)
    {
    MYVERTEX * pb;
    float maxx, minx;
    float maxy, miny;

    gDevice->BeginScene();
    gVertexBuffer->Lock(0,128,(BYTE**)&pb,0);
    
    if(IsBadWritePtr(pb, 128))
        {
        DebugPrint("Lock returned %p, which is BAD!\n", pb);
        return;
        }


    pb[0].v.x = x1; pb[0].v.y = y1; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = c1;
    pb[1].v.x = x2; pb[1].v.y = y2; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = c2;
    pb[2].v.x = x3; pb[2].v.y = y3; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = c3;
    pb[3].v.x = x4; pb[3].v.y = y4; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = c4;

    gVertexBuffer->Unlock();

    gDevice->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
    gDevice->EndScene();
    }


/*************************************************************************************
Function:   drBox
Purpose:    draw a rectangle
Params:     x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
            col --- the RGBA color to draw the box with
Return:     none
*************************************************************************************/
void drBox(float x1, float y1, float x2, float y2, DWORD color)
    {
    MYVERTEX * pb;
    float maxx, minx;
    float maxy, miny;

    gDevice->BeginScene();
    gVertexBuffer->Lock(0,128,(BYTE**)&pb,0);
    
    if(IsBadWritePtr(pb, 128))
        {
        DebugPrint("Lock returned %p, which is BAD!\n", pb);
        return;
        }

    if(x1 < x2)
        {
        minx = x1;
        maxx = x2;
        }
    else
        {
        minx = x2;
        maxx = x1;
        }

    if(x1 < x2)
        {
        miny = y1;
        maxy = y2;
        }
    else
        {
        miny = y2;
        maxy = y1;
        }

//    maxx++;
//    maxy++; 

    if(x1 == x2)
        {
        maxx++;
        }

    pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
    pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
    pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
    pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

    gVertexBuffer->Unlock();

    gDevice->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
    gDevice->EndScene();
    }




/*************************************************************************************
Function:   drSetSize
Purpose:    set default font size and color for drPrintf
Params:     width, height --- the size of each letter of the font, in pixels
            col --- the RGBA color to draw text with
Return:     none
*************************************************************************************/
void drSetSize(float width, float height, DWORD col, DWORD bkcol)
    {
    gWidth = width; gHeight = height; 
    gColor = col; 
    gBkColor = bkcol;

    if(gFont) XFONT_SetTextColor(gFont, gColor);
    if(gFont) XFONT_SetBkColor(gFont, gBkColor);
    }


/*************************************************************************************
Function:   drGetSize
Purpose:    get the width, height, and color of the current default font
Params:     pwidth, pheight, pcolor --- pointers to memory to receive the data
            col --- the RGBA color to draw the box with
Return:     none
*************************************************************************************/
void drGetSize(OPTIONAL OUT float *pwidth, OPTIONAL OUT float *pheight, OPTIONAL OUT DWORD *pcolor, OPTIONAL OUT DWORD *pbkcolor)
    {
    if(pwidth)*pwidth=gWidth;
    if(pheight)*pheight=gHeight;
    if(pcolor)*pcolor=gColor;
    if(pcolor)*pbkcolor=gBkColor;
    }


/*************************************************************************************
Function:   drPrintf
Purpose:    prints formatted text, using the default font size and color
Params:     x1, y1 --- coordinates of the upper-left point to start the text
            format --- the WIDE_CHAR formatted string of text
            ... --- optional params for the formatted text
Return:     the number of chars printed
*************************************************************************************/
int drPrintf(float x1, float y1, TCHAR* format, ...)
    {
    int i;
    HRESULT h;
    va_list v;
    TCHAR wstr[256];

    va_start(v, format);
    i = wvsprintf(wstr, format, v);

    if(gFont) h = XFONT_TextOut(gFont, gBackBuffer, wstr, i, (long)x1, (long)y1);

    va_end(v);
    return i;
    }


/*************************************************************************************
Function:   drShowScreen
Purpose:    draw the screen buffer to the monitor
Params:     none
Return:     0, or error code
*************************************************************************************/
void drShowScreen()
    {
    #ifdef _UseDxConio_
        xDisplayConsole();
    #endif

    if (gDevice != NULL)
        {
        gDevice->Present(NULL, NULL, NULL, NULL);
        }
    }

} // namespace Launcher
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

//#ifndef UNICODE
//    #define _UNICODE
//    #define UNICODE
//#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>

extern "C"
    {
    #include <ntos.h>
    }

#include <stdio.h>
#include <xtl.h>
#include <ldr.h>
#include <xbeimage.h>


extern "C"
    {
    ULONG DebugPrint(PCHAR Format, ...);
    typedef VOID (CALLBACK *PFORMAT_PROGRESS_ROUTINE)(UINT uPercent);

    BOOL WINAPI XapiFormatFATVolume(POBJECT_STRING pcVolume);
    NTSTATUS MU_CreateDeviceObject(ULONG Port, ULONG Slot, POBJECT_STRING DeviceName);
    VOID MU_CloseDeviceObject(ULONG Port, ULONG Slot);
    }


//
// items from <wbasenoxbox.h>
//
extern "C"
    {
    WINBASEAPI
    BOOL
    WINAPI
    TerminateThread(
        IN OUT HANDLE hThread,
        IN DWORD dwExitCode
        );
    }


//
// Cut from mu.h
//
#define MU_VSC_GET_BAD_BLOCK_TABLE   0
#define MU_VSC_MEMORY_TEST           1
#define MU_VSC_BAD_BLOCK_TABLE_SIZE (sizeof(USHORT)*16)
#define MU_VSC_BAD_BLOCK_COUNT_SIZE sizeof(USHORT)
#define MU_IOCTL_GET_BAD_BLOCK_TABLE\
    CTL_CODE(FILE_DEVICE_DISK, MU_VSC_GET_BAD_BLOCK_TABLE, METHOD_NEITHER, FILE_ANY_ACCESS)
#define MU_IOCTL_MEMORY_TEST\
    CTL_CODE(FILE_DEVICE_DISK, MU_VSC_MEMORY_TEST, METHOD_NEITHER, FILE_ANY_ACCESS)


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\usbmanager.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#include "stdafx.h"
#include <xbox.h>
#include <xlog.h>

#include "usbmanager.h"
#include "launcherx.h"

namespace Launcher {

DWORD XIDMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };
DWORD XMUMasks[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
    };


USBManager::USBManager()
    {
    hotplugs = true;
    DWORD insertions, insertions2;
    unsigned i, j;
    unsigned port, slot;

    pollingParameters.fAutoPoll = 1;
    pollingParameters.fInterruptOut = 0;
    pollingParameters.ReservedMBZ1 = 0;
    pollingParameters.bInputInterval = 8;  
    pollingParameters.bOutputInterval = 8;
    pollingParameters.ReservedMBZ2 = 0;

    // make sure the usb schema has not changed on us
    ASSERT(ARRAYSIZE(XIDMasks) == XGetPortCount());

    // initialize
    for(i=0; i<XGetPortCount(); i++)
        {
        for(j=0; j<SLOT_MAX; j++)
            {
            devices[i][j] = NULL;
            packetNum[i][j] = 1234;
            }
        }

    // look for game pads
    insertions = XGetDevices(XDEVICE_TYPE_GAMEPAD);
    //DebugPrint("USBMGR: XID: - %X\n", insertions);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i%XGetPortCount();
        if(insertions & XIDMasks[i])
            {
            //DebugPrint("USBMGR: Inserted XID %d\n", i);
            devices[i][0] = new DeviceDuke(port, 0, &pollingParameters); 
            }
        }

    // check for mus
    insertions = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
    //DebugPrint("USBMGR: XMU: - %X\n", insertions);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
            {
            //DebugPrint("USBMGR: Inserted XMU %d (ec: %lu)\n", port, err);
            devices[i][slot] = new DeviceMU(port, slot);
            }
        }

    
    // check for hawks
    insertions = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
    insertions2 = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
    if(insertions == insertions2)
        {
        //DebugPrint("USBMGR: OK!\n");
        }
    else
        {
        //DebugPrint("USBMGR: CRAP!\n");
        }
    //DebugPrint("USBMGR: XHAWK: %X %X\n", removals, insertions);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
            {
            //DebugPrint("USBMGR: Inserted XHAWK [%d][%d]\n", port, slot);
            devices[port][slot] = new DeviceHawk(port, slot);
            }
        }
    }


USBManager::~USBManager()
    {
    unsigned i, j;

    for(i=0; i<XGetPortCount(); i++)
        {
        for(j=0; j<SLOT_MAX; j++)
            {
            if(devices[i][j] != NULL)
                {
                if(XDEVICE_TYPE_GAMEPAD == devices[i][j]->type) delete (DeviceDuke*)devices[i][j];
                else if(XDEVICE_TYPE_MEMORY_UNIT == devices[i][j]->type) delete (DeviceMU*)devices[i][j];
                else if(XDEVICE_TYPE_VOICE_MICROPHONE == devices[i][j]->type) delete (DeviceHawk*)devices[i][j];
                devices[i][j] = NULL;
                }
            }
        }
    }


void USBManager::CheckForHotplugs(void)
    {
    DWORD addDuke, removeDuke;
    DWORD addKey, removeKey;
    DWORD addMU, removeMU;
    DWORD addHawk, removeHawk, addHawk2, removeHawk2;
    unsigned slot, port;
    unsigned i, j;

    if(!hotplugs) return;

    // check for mu removals
    XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addMU, &removeMU);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(removeMU & XMUMasks[i])
            {
            delete (DeviceMU*)devices[i][slot];
            devices[i][slot] = NULL;
            }
        }

#ifdef DEBUG_KEYBOARD
    // check for keyboard removals
    XGetDeviceChanges(XDEVICE_TYPE_DEBUG_KEYBOARD, &addKey, &removeKey);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i%XGetPortCount();
        if(removeKey & XIDMasks[i])
            {
            delete (DeviceKeyboard*)devices[i][0];
            devices[i][0] = NULL;
            }
        }
#endif // DEBUG_KEYBOARD

    // check for xhawk removals
    XGetDeviceChanges(XDEVICE_TYPE_VOICE_MICROPHONE, &addHawk, &removeHawk);
    XGetDeviceChanges(XDEVICE_TYPE_VOICE_HEADPHONE, &addHawk2, &removeHawk2);
    if(removeHawk == removeHawk && addHawk == addHawk2)
        {
        //DebugPrint("USBMGR: OK!\n");
        }
    else
        {
        //DebugPrint("USBMGR: CRAP!\n");
        }
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(removeHawk & XMUMasks[i])
            {
            delete (DeviceHawk*)devices[port][slot];
            devices[port][slot] = NULL;
            }
        }


    // check for game controllers (insert & removal)
    XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDuke, &removeDuke);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i%XGetPortCount();
        if(removeDuke & XIDMasks[i])
            {
            delete (DeviceDuke*)devices[i][0];
            devices[i][0] = NULL;
            }
        if(addDuke & XIDMasks[i])
            {
            devices[i][0] = new DeviceDuke(port, 0, &pollingParameters); 
            }
        }

#ifdef DEBUG_KEYBOARD
    // check for keyboard insertions
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i%XGetPortCount();
        if(addKey & XIDMasks[i])
            {
            devices[i][0] = new DeviceKeyboard(port, 0, &pollingParameters); 
            }
        }
#endif // DEBUG_KEYBOARD

    // check for mu insertions
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(addMU & XMUMasks[i])
            {
            devices[i][slot] = new DeviceMU(port, slot); 
            }
        }

    // check for xhawk insertions
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(addHawk & XMUMasks[i])
            {
            //DebugPrint("USBMGR: Inserted XHAWK [%d][%d]\n", port, slot);
            devices[i][slot] = new DeviceHawk(port, slot); 
            }
        }
    }


void USBManager::ProcessInput(void)
    {
    CheckForHotplugs();
    for(unsigned i=0; i<XGetPortCount(); i++)
        {
        DumpControllerState(INVALID_SOCKET, i, 0);
        }
    }


void USBManager::ProcessInput(SOCKET sock)
    {
    CheckForHotplugs();
    for(unsigned i=0; i<XGetPortCount(); i++)
        {
        DumpControllerState(sock, i, 0);
        }
    }


void USBManager::DumpControllerState(SOCKET sock, unsigned port, unsigned slot)
    {
    if(devices[port][slot] == NULL) return;

    XINPUT_STATE state;
    memset(&state, 0, sizeof(XINPUT_STATE));

    XInputGetState(((DeviceDuke*)devices[port][slot])->duke, &state);

    //DebugPrint("Duke: 0x%X, packet id: %u\r\n", ((DeviceDuke*)devices[port][slot])->duke, state.dwPacketNumber);

    if(packetNum[port][slot] != state.dwPacketNumber)
        {
        packetNum[port][slot] = state.dwPacketNumber;

        if(sock != INVALID_SOCKET)
            {
            SockPrint(sock, "Input [%u][%u] #%lu:\r\n"
                "   dButtons = %d%d%d%d %d%d%d%d %d%d%d%d%d%d%d%d\r\n"
                "   aButtons = (%02X %02X %02X %02X %02X %02X %02X %02X)\r\n"
                "   Thumb1   = (%d, %d)\r\n"
                "   Thumb2   = (%d, %d)\r\n"
                , port, slot,
                state.dwPacketNumber,
                !!(state.Gamepad.wButtons&(1<<0)),
                !!(state.Gamepad.wButtons&(1<<1)),
                !!(state.Gamepad.wButtons&(1<<2)),
                !!(state.Gamepad.wButtons&(1<<3)),
                !!(state.Gamepad.wButtons&(1<<4)),
                !!(state.Gamepad.wButtons&(1<<5)),
                !!(state.Gamepad.wButtons&(1<<6)),
                !!(state.Gamepad.wButtons&(1<<7)),
                !!(state.Gamepad.wButtons&(1<<8)),
                !!(state.Gamepad.wButtons&(1<<9)),
                !!(state.Gamepad.wButtons&(1<<10)),
                !!(state.Gamepad.wButtons&(1<<11)),
                !!(state.Gamepad.wButtons&(1<<12)),
                !!(state.Gamepad.wButtons&(1<<13)),
                !!(state.Gamepad.wButtons&(1<<14)),
                !!(state.Gamepad.wButtons&(1<<15)),
                state.Gamepad.bAnalogButtons[0],
                state.Gamepad.bAnalogButtons[1],
                state.Gamepad.bAnalogButtons[2],
                state.Gamepad.bAnalogButtons[3],
                state.Gamepad.bAnalogButtons[4],
                state.Gamepad.bAnalogButtons[5],
                state.Gamepad.bAnalogButtons[6],
                state.Gamepad.bAnalogButtons[7],
                state.Gamepad.sThumbLX,
                state.Gamepad.sThumbLY,
                state.Gamepad.sThumbRX,
                state.Gamepad.sThumbRY
                );
            }
        }
    }

} // namespace Launcher
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\utils.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    utils.cpp

Abstract:


Author:

    jpoley

Environment:

    XBox

Revision History:

*/


#include "stdafx.h"
#include <xbox.h>
#include <ntdddisk.h>

#include "launcherx.h"


namespace Launcher {

/*****************************************************************************

Routine Description:

    Ansi2UnicodeHack

    In-place Pseudo Ansi to Unicode (char to wide char) conversion.

Arguments:

    IN char* str - char string to convert to wide char string

Return Value:

    WCHAR* - pointer to Unicode string

Note:
    
    Because a bunch of Unicode functions expect a WCHAR string to be on an
    even boundry, the returned string may be moved 1 character over.

*****************************************************************************/
WCHAR* Ansi2UnicodeHack(char *str)
    {
    if(!str) return NULL;

    int align = 0;
    int len = strlen(str)+1;

    // put string on an even boundry because some freak put a bunch of ASSERTs
    // that check for even boundries in Unicode functions like 
    // RtlEqualUnicodeString()
    if(((ULONG_PTR)str & 1) != 0)
        {
        align = 1;
        }

    for(; len>=0; len--)
        {
        str[len*2+align] = str[len];
        str[len*2+align+1] = '\0';
        }

    str += align;

    return (WCHAR*)str;
    }


/*****************************************************************************

Routine Description:

    Unicode2AnsiHack

    In-place Pseudo Unicode to Ansi (wide char to char) conversion.

Arguments:

    IN unsigned short* str - wide char string to convert to char string

Return Value:

    char* - pointer to ANSI string

*****************************************************************************/
char* Unicode2AnsiHack(unsigned short *str)
    {
    if(!str) return NULL;
    char *str2 = (char*)str;

    size_t len = wcslen(str)+1;
    for(size_t i=0; i<len; i++)
        {
        str2[i] = str2[i*2];
        }

    return (char*)str;
    }


/*****************************************************************************

Routine Description:

    HexDump

    Writes the contents of a chunk of memory to the socket as a hex dump.

Arguments:

    SOCKET sock     - [in] socket to send the data through
    uchar* buffer   - [in] the memory address
    DWORD length    - [in] the number of bytes to write
    DWORD offset    - [in optional] starting offset for the displayed address

Return Value:

    void

*****************************************************************************/
void HexDump(SOCKET sock, const unsigned char * buffer, DWORD length, DWORD offset/*=0*/)
    {
    DWORD i, count, index;
    CHAR digits[]="0123456789ABCDEF";
    CHAR line[100];
    char cbLine;

    for(index = 0; length; length -= count, buffer += count, index += count)
        {
        count = (length > 16) ? 16:length;

        sprintf(line, "%04X  ", index+offset);
        cbLine = 6;

        for(i=0; i<count; i++)
            {
            line[cbLine++] = digits[buffer[i] >> 4];
            line[cbLine++] = digits[buffer[i] & 0x0f];
            if(i == 7)
                {
                line[cbLine++] = ' ';
                }
            else
                {
                line[cbLine++] = ' ';
                }
            }
        for(; i<16; i++)
            {
            line[cbLine++] = ' ';
            line[cbLine++] = ' ';
            line[cbLine++] = ' ';
            }

        line[cbLine++] = ' ';

        for(i=0; i<count; i++)
            {
            if(buffer[i] < 32 || buffer[i] > 126)
                {
                line[cbLine++] = '.';
                }
            else
                {
                line[cbLine++] = buffer[i];
                }
            }

        line[cbLine++] = '\r';
        line[cbLine++] = '\n';
        line[cbLine++] = 0;
        if(sock == INVALID_SOCKET) DebugPrint(line);
        else send(sock, line, strlen(line), 0);        
        }
    }


/*****************************************************************************

Routine Description:

    This routine will flush the disk cache

Arguments:

    None

Return Value:

    No return value

*****************************************************************************/
void FlushDiskCache(void)
    {
    ULONG Volume, Disk;
    HANDLE Handle;
    NTSTATUS Status;
    char VolumeBuffer[MAX_PATH];
    OBJECT_STRING VolumeString;
    OBJECT_ATTRIBUTES ObjA;
    IO_STATUS_BLOCK IoStatusBlock;

    for(Disk=0; Disk<2; Disk++)
        {
        for(Volume=1; Volume<4; Volume++)
            {
            sprintf(VolumeBuffer, "\\Device\\Harddisk%d\\Partition%d", Disk, Volume);

            RtlInitObjectString(&VolumeString, VolumeBuffer);

            InitializeObjectAttributes(&ObjA,&VolumeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

            Status = NtCreateFile(&Handle, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT);

            if(!NT_SUCCESS(Status)) continue;

            Status = NtFlushBuffersFile(Handle, &IoStatusBlock);
            NtClose(Handle);
            }
        }
    }


/*****************************************************************************

Routine Description:

    xPathFindFileName
    Returns a pointer to the start of the filename in a path string.

Arguments:

    WCHAR *name - [in] string to search for the filename

Return Value:

    WCHAR*

*****************************************************************************/
char* xPathFindFileName(char *name)
    {
    DWORD attribs;
    char *sep;

    size_t len = strlen(name);

    attribs = GetFileAttributes(name);
    if(attribs != -1 && attribs&FILE_ATTRIBUTE_DIRECTORY)
        {
        return name + len;
        }

    sep = strrchr(name, '\\');

    if(!sep)
        {
        return NULL;
        }

    return sep + 1;
    }


/*****************************************************************************

Routine Description:

    NetHit
    Looks for incoming data on the socket.

Arguments:

    SOCKET sock     [in] connected socket
    unsigned usec   [in] microsec time to wait for input (0 is default)

Return Value:

    true - socket closed or input
    false - no input

*****************************************************************************/
bool NetHit(SOCKET sock, unsigned usec/*=0*/)
    {
    // check for user interaction
    TIMEVAL timeout = { 0, usec };
    FD_SET bucket;
    bucket.fd_count = 1;
    bucket.fd_array[0] = sock;
    int err = select(0, &bucket, NULL, NULL, &timeout);
    if(err == SOCKET_ERROR || err != 0)
        {
        char eat[10];
        recv(sock, eat, 10, 0);
        return true;
        }

    return false;
    }



/*****************************************************************************

Routine Description:

    OpenMU
    Creates a device object name usable in calls to NtCreateFile etc.

Arguments:

    unsigned port   [in] 0 based index of the usb port number
    unsigned slot   [in] XDEVICE_TOP_SLOT or XDEVICE_BOTTOM_SLOT

Return Value:

    true - happy
    false - failure

*****************************************************************************/
bool OpenMU(unsigned port, unsigned slot, char *device)
    {
    OBJECT_STRING deviceName;
    deviceName.Buffer = device;
    deviceName.Length = 0;
    deviceName.MaximumLength = 63;
    if(! NT_SUCCESS(MU_CreateDeviceObject(port, slot, &deviceName)))
        return false;
    return true;
    }


/*****************************************************************************

Routine Description:

    CloseMU
    Destroys a device object

Arguments:

    unsigned port   [in] 0 based index of the usb port number
    unsigned slot   [in] XDEVICE_TOP_SLOT or XDEVICE_BOTTOM_SLOT

Return Value:

    true

*****************************************************************************/
bool CloseMU(unsigned port, unsigned slot)
    {
    MU_CloseDeviceObject(port, slot);
    return true;
    }

bool ReadMUCapacity(HANDLE handle)
    {
    NTSTATUS status;
    IO_STATUS_BLOCK statusBlock;
    DISK_GEOMETRY diskGeometry;
    PARTITION_INFORMATION pi;

    status = NtDeviceIoControlFile(handle,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                   NULL,
                                   0,
                                   &diskGeometry,
                                   sizeof(diskGeometry));
    DebugPrint("IOCTL_DISK_GET_DRIVE_GEOMETRY: %x\n", status);
/*
    status = NtDeviceIoControlFile(handle,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   IOCTL_DISK_GET_PARTITION_INFO,
                                   NULL,
                                   0,
                                   &pi,
                                   sizeof(pi));
    DebugPrint("IOCTL_DISK_GET_PARTITION_INFO: %x\n", status);
*/
    /*
    ULONG ulSectorSize = diskGeometry.BytesPerSector;
    ULONG ulSectorsPerTrack = diskGeometry.SectorsPerTrack;
    ULONG ulHeads = diskGeometry.TracksPerCylinder;
    ULONG ulTotalSectorCount = (RtlExtendedIntegerMultiply(
                                diskGeometry.Cylinders,
                                diskGeometry.SectorsPerTrack *
                                    diskGeometry.TracksPerCylinder)).LowPart;
                                    */

    return true;
    }

/*****************************************************************************

Routine Description:

    MUDiagnosticIoctl
    Calls in the the MU's Diagnostic Ioctl.

Arguments:

    SOCKET sock     [in] socket for output
    unsigned port   [in] 0 based index of the usb port number
    unsigned slot   [in] XDEVICE_TOP_SLOT or XDEVICE_BOTTOM_SLOT
    DWORD ioctl     [in] MU_DIAGNOSTIC_IOCTLS identifier
    void *output    [in out] buffer to be filled with the return data from the IOCTL
    DWORD &size     [in out] size of the buffer

Return Value:

    true - happy
    false - failure

Notes:
    
    This library AND the MU driver must be compiled with 
    C_DEFINES=-DMU_DIAGNOSTIC_IOCTLS

    The MU must NOT be mounted prior to calling this method

*****************************************************************************/
bool MUDiagnosticIoctl(SOCKET sock, unsigned port, unsigned slot, DWORD ioctl, void *output, DWORD &size)
    {
    HANDLE handle;
    NTSTATUS status;
    char deviceName[128];
    OBJECT_STRING deviceString;
    OBJECT_ATTRIBUTES objAttrib;
    IO_STATUS_BLOCK ioStatusBlock;

    if(!OpenMU(port, slot, deviceName))
        {
        SockPrint(sock, "   MU_CreateDeviceObject failed\r\n");
        return false;
        }
    RtlInitObjectString(&deviceString, deviceName);
    InitializeObjectAttributes(&objAttrib, &deviceString, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&handle, SYNCHRONIZE|GENERIC_READ, &objAttrib, &ioStatusBlock, FILE_SHARE_READ, FILE_NO_INTERMEDIATE_BUFFERING|FILE_SYNCHRONOUS_IO_NONALERT);
    if(!NT_SUCCESS(status)) 
        {
        SockPrint(sock, "   CreateFile Error %s (ec: %ld)\r\n", deviceName, RtlNtStatusToDosError(status));
        CloseMU(port, slot);
        return false;
        }

    if(DeviceIoControl(handle, ioctl, NULL, 0, output, size, &size, NULL) == FALSE)
        {
        SockPrint(sock, "   DeviceIoControl Error (ec: %ld)\r\n", GetLastError());
        CloseMU(port, slot);
        NtClose(handle);
        return false;
        }

    CloseMU(port, slot);
    NtClose(handle);
    return true;
    }


//#define MU_MEDIA_OFFSET     4096*8
//#define MU_MEDIA_OFFSET     0


/*****************************************************************************

Routine Description:

    RawRead
    Reads from a device and writes the data to a file.

Arguments:

    WCHAR *device   [in] device name (eg "\\Device\\MemoryUnit01_01")
    WCHAR *file     [in] destination filename (eg "z:\\mu.dmp")
    DWORD offset    [in] starting offset to read from on the device
    DWORD size      [in] number of bytes to read

Return Value:

    DWORD - win32 error code

*****************************************************************************/
DWORD RawRead(char *device, char *file, DWORD offset, DWORD size)
    {
    const DWORD EXTRA_SIZE = 4096;
    const unsigned __int64 SECTOR_MASK = 0xFFFFFF000;
    DWORD error = ERROR_SUCCESS;
    OBJECT_STRING uniName;
    NTSTATUS status;
    char muName[128];
    PUCHAR mem = (PUCHAR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, size + 2*EXTRA_SIZE);
    if(!mem) return ERROR_NOT_ENOUGH_MEMORY;
    
    bool mu = false;
    DWORD port, slot;

    if(sscanf(device, "\\Device\\MemoryUnit%02x_%02x", &port, &slot) == 2)
        {
        if(usbmanager->devices[port][slot] != NULL && usbmanager->devices[port][slot]->type == XDEVICE_TYPE_MEMORY_UNIT)
            {
            delete (DeviceMU*)(usbmanager->devices[port][slot]);
            usbmanager->devices[port][slot] = NULL;
            }
        mu = true;
        }

    // sector align buffers
    PUCHAR buffer = (PUCHAR)((ULONG) mem & SECTOR_MASK);
    buffer += EXTRA_SIZE;

    // initialize src name
    RtlInitObjectString(&uniName, device);
    if(mu) OpenMU(port-1, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, muName);

    do {

    // open the source
    HANDLE hSrc;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK statusBlock;
    InitializeObjectAttributes(&oa, &uniName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtOpenFile(&hSrc, SYNCHRONIZE | GENERIC_ALL, &oa, &statusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_NO_INTERMEDIATE_BUFFERING | FILE_SYNCHRONOUS_IO_ALERT);
    if(NT_SUCCESS(status))
        {
        if(mu) ReadMUCapacity(hSrc);
        // read data
        LARGE_INTEGER startLoc;
        startLoc.QuadPart = offset;
        //__asm int 3;
        status = NtReadFile(hSrc, 0, NULL, NULL, &statusBlock, buffer, size, &startLoc);
        NtClose(hSrc);

        if(!NT_SUCCESS(status))
            {
            //SockPrint(sock, "RawRead: Read from Source failed (ec: 0x%X)\r\n", status);
            error = RtlNtStatusToDosError(status);
            break;
            }
        }
    else
        {
        //SockPrint(sock, "RawRead: Open Source failed (ec: 0x%X)\r\n", status);
        error = RtlNtStatusToDosError(status);
        break;
        }

    // open the destination
    HANDLE hDest = CreateFile(file, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hDest != INVALID_HANDLE_VALUE)
        {
        // write the data
        DWORD wSize=0;
        if(!(WriteFile(hDest, buffer, size, &wSize, NULL) == TRUE && wSize == size))
            {
            CloseHandle(hDest);
            //SockPrint(sock, "RawRead: Write failed[%lu]\r\n", wSize);
            error = GetLastError();
            break;
            }
        CloseHandle(hDest);
        }
    else
        {
        //SockPrint(sock, "RawRead: Open Destination failed (ec: %lu)\r\n", GetLastError());
        error = GetLastError();
        break;
        }

    } while(0);

    if(mu) CloseMU(port-1, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT);
    LocalFree(mem);
    return error;
    }


/*****************************************************************************

Routine Description:

    RawWrite
    Writes to a device from the data in a file.

Arguments:

    WCHAR *device   [in] source filename (eg "z:\\mu.dmp")
    WCHAR *file     [in] device name (eg "\\Device\\MemoryUnit01_01")
    DWORD offset    [in] starting offset to write on the device
    DWORD size      [in] number of bytes to write

Return Value:

    DWORD - win32 error code

*****************************************************************************/
DWORD RawWrite(char *device, char *file, DWORD offset, DWORD size)
    {
    const DWORD EXTRA_SIZE = 4096;
    const unsigned __int64 SECTOR_MASK = 0xFFFFFF000;
    DWORD error = ERROR_SUCCESS;
    OBJECT_STRING uniName;
    char muName[128];
    NTSTATUS status;
    PUCHAR mem = (PUCHAR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, size + 2*EXTRA_SIZE);
    if(!mem) return ERROR_NOT_ENOUGH_MEMORY;
    
    bool mu = false;
    DWORD port, slot;

    if(sscanf(device, "\\Device\\MemoryUnit%02x_%02x", &port, &slot) == 2)
        {
        mu = true;
        if(usbmanager->devices[port][slot] != NULL && usbmanager->devices[port][slot]->type == XDEVICE_TYPE_MEMORY_UNIT)
            {
            delete (DeviceMU*)(usbmanager->devices[port][slot]);
            usbmanager->devices[port][slot] = NULL;
            }
        }

    // sector align buffers
    PUCHAR buffer = (PUCHAR)((ULONG) mem & SECTOR_MASK);
    buffer += EXTRA_SIZE;

    // initialize src name
    RtlInitObjectString(&uniName, device);
    if(mu) OpenMU(port-1, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, muName);

    do {

    // open the source
    HANDLE hSrc = CreateFile(file, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hSrc != INVALID_HANDLE_VALUE)
        {
        // read the data
        DWORD rSize=0;
        if(!(ReadFile(hSrc, buffer, size, &rSize, NULL) == TRUE && rSize == size))
            {
            CloseHandle(hSrc);
            //SockPrint(sock, "RawWrite: Read failed[%lu]\r\n", rSize);
            error = GetLastError();
            break;
            }
        CloseHandle(hSrc);
        }
    else
        {
        //SockPrint(sock, "RawRead: Open Source failed (ec: %lu)\r\n", GetLastError());
        error = GetLastError();
        break;
        }

    // open the destination
    HANDLE hDest;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK statusBlock;
    InitializeObjectAttributes(&oa, &uniName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtOpenFile(&hDest, SYNCHRONIZE | GENERIC_ALL, &oa, &statusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_NO_INTERMEDIATE_BUFFERING | FILE_SYNCHRONOUS_IO_ALERT);
    if(NT_SUCCESS(status))
        {
        if(mu) ReadMUCapacity(hDest);
        // write data
        LARGE_INTEGER startLoc;
        startLoc.QuadPart = offset;
        status = NtWriteFile(hDest, 0, NULL, NULL, &statusBlock, buffer, size, &startLoc);
        NtClose(hDest);

        if(!NT_SUCCESS(status))
            {
            //SockPrint(sock, "RawWrite: Write to Destination failed (ec: 0x%X)\r\n", status);
            error = RtlNtStatusToDosError(status);
            break;
            }
        }
    else
        {
        //SockPrint(sock, "RawWrite: Open Destination failed (ec: 0x%X)\r\n", status);
        error = RtlNtStatusToDosError(status);
        break;
        }

    } while(0);

    if(mu) CloseMU(port-1, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT);
    LocalFree(mem);
    return error;
    }

} // namespace Launcher
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\medialoader\FileList.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	FileList.cpp

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 01-Aug-2001

Revision History:

	01-Aug-2001 jeffsul
		Initial Version

--*/

#include "FileList.h"

#include "MLInternal.h"
#include "regexpr.h"
using namespace regex;

CFileList::CFileList()
{
	m_pFirstFile	=	NULL;
	m_nNumFiles		=	0;
}


CFileList::~CFileList()
{
	PFILELISTNODE	pNode;

	pNode = m_pFirstFile;

	while ( NULL != pNode )
	{
		PFILELISTNODE	pNextNode;
		pNextNode	=	pNode->pNext;
		SAFEDELETE( pNode );
		pNode = pNextNode;
		m_nNumFiles--;
	}
}


HRESULT CFileList::AddFile( IN CONST LPWIN32_FIND_DATA lpFindFileData )
{
	HRESULT	hr		=	S_OK;

	// set up new node
	PFILELISTNODE	pNewNode = new FILELISTNODE;
	
	CHECKALLOC( pNewNode );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	pNewNode->bUsed		=	FALSE;
	memcpy( &pNewNode->FindData, lpFindFileData, sizeof(WIN32_FIND_DATA) );

	// insert node into chain
	pNewNode->pNext = m_pFirstFile;
	m_pFirstFile = pNewNode;

	m_nNumFiles++;
	return hr;
}


HRESULT CFileList::RemoveFile( IN LPCSTR lpszFileName )
{
	HRESULT	hr		=	S_OK;

	PFILELISTNODE	pNode = m_pFirstFile;
	PFILELISTNODE	pPrevNode = NULL;


	while ( NULL != pNode )
	{
		INT	nCompare;
		nCompare = strcmp( pNode->FindData.cFileName, lpszFileName );
		if ( 0 == nCompare )
		{
			if ( NULL == pPrevNode )
			{
				m_pFirstFile = pNode->pNext;
			}
			else
			{
				pPrevNode->pNext = pNode->pNext;
			}

			SAFEDELETE( pNode );
			m_nNumFiles--;
			return hr;
		}
	}

	return S_FALSE;
}

HRESULT CFileList::GetRandomUnusedFile( OUT LPWIN32_FIND_DATA lpFindFileData )
{
	HRESULT	hr			=	S_OK;

	PFILELISTNODE pNode	=	m_pFirstFile;

	if ( 0 == m_nNumFiles )
	{
		return E_FAIL;
	}

	srand( timeGetTime() );
	UINT	nFileIndex	=	rand() % m_nNumFiles;

	for ( UINT i=0; i < nFileIndex; i++ )
	{
		pNode = pNode->pNext;
		ASSERT( NULL != pNode );
	}

	while ( NULL != pNode && TRUE == pNode->bUsed )
	{
		pNode = pNode->pNext;
	}

	if ( NULL == pNode )
	{
		// no unused nodes after the randomly selected one, start from beginning
		return GetFirstUnusedFile( lpFindFileData );
	}

	memcpy( lpFindFileData, &pNode->FindData, sizeof(WIN32_FIND_DATA) );
	pNode->bUsed = TRUE;
	return hr;
}


HRESULT CFileList::GetFirstUnusedFile( OUT LPWIN32_FIND_DATA lpFindFileData )
{
	HRESULT	hr			=	S_OK;

	PFILELISTNODE pNode	=	m_pFirstFile;

	while ( NULL != pNode && TRUE == pNode->bUsed )
	{
		pNode = pNode->pNext;
	}

	if ( NULL == pNode )
	{
		// no unused nodes
		return E_FAIL;
	}

	memcpy( lpFindFileData, &pNode->FindData, sizeof(WIN32_FIND_DATA) );
	pNode->bUsed = TRUE;
	return hr;
}

INT	CFileList::GetNumFiles()
{
	return m_nNumFiles;
}


#define CHECKTOKEN( p )											\
if ( NULL == (p) )												\
{																\
	DbgPrint( "[MediaLoader] Error: Bad token\n" );				\
	SAFEDELETEARRAY( lpszBody );								\
	RtlAssert( 0, __FILE__, __LINE__, NULL );					\
	return E_FAIL;												\
}
HRESULT CFileList::ParseHTML( IN LPCSTR lpszBuf, IN DWORD dwSize, IN LPCSTR lpszSearchString )
{
	HRESULT	hr			=	S_OK;
	LPSTR	lpszFiles	=	NULL;

	LPSTR	lpszBody = new CHAR[dwSize];
	CHECKALLOC( lpszBody );
	if ( FAILED( hr ) )
	{
		return E_FAIL;
	}
	memcpy( lpszBody, lpszBuf, dwSize );

	// move down to first file
	lpszFiles = strstr( lpszBody, "<br><br>" );
	CHECKTOKEN( lpszFiles );
	lpszFiles += 8;

    if ( '/' == lpszFiles[1] )
    {
        // this is an empty directory
		SAFEDELETEARRAY( lpszBody );
        return hr;
    }

	INT i= -1;

	// create each find data structure and add it to the list
	while ( NULL != lpszFiles )
	{
		i++;
		LPCSTR	lpszDay;
		LPCSTR	lpszMonth;
		LPCSTR	lpszDate;
		LPCSTR	lpszYear;
		LPCSTR	lpszHour;
		LPCSTR	lpszMin;
		//LPCSTR	lpszTime;
		LPCSTR	lpszAmPm;
		LPCSTR	lpszSize;
		LPCSTR	lpszName;

		// get the file's date
		lpszDay = strtok( lpszFiles, " \t," );
		CHECKTOKEN( lpszDay );
		lpszMonth = strtok( NULL, " \t," );
		CHECKTOKEN( lpszMonth );
		lpszDate = strtok( NULL, " \t," );
		CHECKTOKEN( lpszDate );
		lpszYear = strtok( NULL, " \t," );
		CHECKTOKEN( lpszYear );
		//lpszTime = strtok( NULL, " \t," );
		//CHECKTOKEN( lpszTime );
		lpszHour = strtok( NULL, " :\t," );
		CHECKTOKEN( lpszHour );
		lpszMin = strtok( NULL, " \t," );
		CHECKTOKEN( lpszMin );
		lpszAmPm = strtok( NULL, " \t," );
		CHECKTOKEN( lpszAmPm );

		INT		nYear, nMonth, nDate, nHour, nMin;
		nYear = atoi( lpszYear );
		if ( 0 == strcmp( lpszMonth, "January" ) )
		{
			nMonth = 1;
		}
		else if ( 0 == strcmp( lpszMonth, "February" ) )
		{
			nMonth = 2;
		}
		else if ( 0 == strcmp( lpszMonth, "March" ) )
		{
			nMonth = 3;
		}
		else if ( 0 == strcmp( lpszMonth, "April" ) )
		{
			nMonth = 4;
		}
		else if ( 0 == strcmp( lpszMonth, "May" ) )
		{
			nMonth = 5;
		}
		else if ( 0 == strcmp( lpszMonth, "June" ) )
		{
			nMonth = 6;
		}
		else if ( 0 == strcmp( lpszMonth, "July" ) )
		{
			nMonth = 7;
		}
		else if ( 0 == strcmp( lpszMonth, "August" ) )
		{
			nMonth = 8;
		}
		else if ( 0 == strcmp( lpszMonth, "September" ) )
		{
			nMonth = 9;
		}
		else if ( 0 == strcmp( lpszMonth, "October" ) )
		{
			nMonth = 10;
		}
		else if ( 0 == strcmp( lpszMonth, "November" ) )
		{
			nMonth = 11;
		}
		else
		{
			nMonth = 12;
		}

		nDate = atoi( lpszDate );
		nHour = atoi( lpszHour );
		nMin = atoi( lpszMin );

		SYSTEMTIME time;
		//tm	time;
		time.wHour = (WORD)nHour;
		if ( 0 == strcmp( lpszAmPm, "PM" ) )
		{
			time.wHour += 12;
		}
		time.wMinute = (WORD)nMin;
		time.wMonth = (WORD)nMonth;
		time.wSecond = 0;
		time.wMilliseconds = 0;
		time.wDay = (WORD)nDate;
		time.wYear = (WORD)nYear;


		// get the file's size
		lpszSize = strtok( NULL, " \t," );
		CHECKTOKEN( lpszSize );

		// get the file's name
		lpszFiles = strstr( lpszSize+strlen(lpszSize)+1, "\"" );
		CHECKTOKEN( lpszFiles );
		lpszFiles += 1;
		lpszName = strtok( lpszFiles, " \"" );
		CHECKTOKEN( lpszName );

        UINT	k, j;
	    UINT	nLength = strlen( lpszSearchString );
        CHAR    szStringNoSpaces[ MAX_PATH ] = {0};
	    j = 0;
	    for ( k=0; k <= nLength; k++ )
	    {
		    if ( ' ' == lpszSearchString[k] )
		    {
			    szStringNoSpaces[j] = '%';
		    	szStringNoSpaces[j+1] = '2';
			    szStringNoSpaces[j+2] = '0';
			    j += 3;
		    }
		    else
		    {
		    	szStringNoSpaces[j] = lpszSearchString[k];
		    	j++;
		    }

		    if ( j >= MAX_PATH )
		    {
		    	DbgPrint("[MediaLoader] Error: Too many characters in filename %s.\n", lpszSearchString );
		    }
	    }

		BOOL	bMatches = FileNameMatches( szStringNoSpaces, lpszName );

		if ( bMatches )
		{
			// if the file name matches the search string
			// add the file to the list
			WIN32_FIND_DATA FindData;
			ZeroMemory( &FindData, sizeof(WIN32_FIND_DATA) );

			strcpy( FindData.cFileName, lpszName );
			FindData.nFileSizeLow = atoi( lpszSize );
			SystemTimeToFileTime( &time, &FindData.ftCreationTime );
			if ( 0 != FindData.nFileSizeLow )
			{
				// not a directory, or a zero length file,
				// which we wouldn't want anyway, right?
				EXECUTE( AddFile( &FindData ) );
				if ( FAILED( hr ) )
				{
					SAFEDELETEARRAY( lpszBody );
					return hr;
				}
			}
		}

		// move the pointer to the next file
		lpszFiles = strstr( lpszName+strlen(lpszName)+1, "</A><br>" );
		if ( NULL == lpszFiles )
		{
			break;
		}
		lpszFiles += 8;
		if ( lpszFiles == strstr( lpszFiles, "</pre><hr></body>" ) )
		{
			break;
		}

	}

	// do any cleaning up
	SAFEDELETEARRAY( lpszBody );

	return hr;
}


BOOL CFileList::FileNameMatches( IN LPCSTR lpszSearchString, IN LPCSTR lpszFileName )
{
	BOOL	bResult		=	FALSE;

	LPCSTR lpszFileNameOnly = strrchr( lpszFileName, '/' );
	if ( NULL == lpszFileNameOnly )
	{
		return bResult;
	}
	lpszFileNameOnly += 1;

	WCHAR	szWideFileNameOnly[MAX_PATH];
	WCHAR	szWideSearchString[MAX_PATH];

	for ( UINT i=0; i < strlen(lpszFileNameOnly) + 1; i++ )
	{
		szWideFileNameOnly[i] = (WCHAR)tolower( lpszFileNameOnly[i] );
	}
	regexpr	str( szWideFileNameOnly );

	UINT	j	= 0;
	for ( i=0; i < strlen(lpszSearchString) + 1; i++ )
	{
		if ( ' ' == lpszSearchString[i] )
		{
			lstrcat( szWideSearchString, L"%20" );
			j += 2;
			//lstrcpy( szWideSearchString + j = (TCHAR)'%'
		}
		else
		{
			szWideSearchString[j] = (WCHAR)tolower( lpszSearchString[i] );
		}
		j++;
	}
	rpattern pat( szWideSearchString );
	
	regexpr::backref_type br = str.match( pat );
	
	LPCTSTR lpszFirstMatch = &br.first[0];
	
	if ( br && szWideFileNameOnly == _tcsstr( szWideFileNameOnly, lpszFirstMatch ) )
	{
		bResult = TRUE;
	}

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\launcher\usbmanager.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == _XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#ifndef _USBMANAGER_H_
#define _USBMANAGER_H_

#include "stdafx.h"
#include "launcher.h"
#include <xbox.h>

namespace Launcher {


enum {
    SLOT_CONTROLLER,
    SLOT_TOP,
    SLOT_BOTTOM,
    SLOT_MAX
    };


class USBDevice
    {
    public:
        PXPP_DEVICE_TYPE type; // XDEVICE type

    public:
        USBDevice() { type = NULL; }
        ~USBDevice() { type = NULL; }

    public:
        virtual void Insert(unsigned port, unsigned slot) = 0;
        virtual void Remove(void) = 0;
    };

class DeviceDuke : public USBDevice
    {
    public:
        HANDLE duke;
        XINPUT_POLLING_PARAMETERS *pollingParameters;

    public:
        DeviceDuke() { type = XDEVICE_TYPE_GAMEPAD; pollingParameters = NULL; duke = NULL; }
        DeviceDuke(unsigned port, unsigned slot, XINPUT_POLLING_PARAMETERS *p) { type = XDEVICE_TYPE_GAMEPAD; pollingParameters = p; duke = NULL; Insert(port, slot); }
        ~DeviceDuke() { if(duke) Remove(); }

    public:
        void Insert(unsigned port, unsigned slot) { /*DebugPrint("USBDevice: Insert duke\n");*/ duke = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, pollingParameters); }
        void Remove(void) { /*DebugPrint("USBDevice: Remove duke\n");*/ XInputClose(duke); duke = NULL; }
    };

#ifdef DEBUG_KEYBOARD
class DeviceKeyboard : public USBDevice
    {
    public:
        HANDLE keyboard;
        XINPUT_POLLING_PARAMETERS *pollingParameters;

    public:
        DeviceKeyboard() { type = XDEVICE_TYPE_DEBUG_KEYBOARD; pollingParameters = NULL; keyboard = NULL; }
        DeviceKeyboard(unsigned port, unsigned slot, XINPUT_POLLING_PARAMETERS *p) { type = XDEVICE_TYPE_DEBUG_KEYBOARD; pollingParameters = p; keyboard = NULL; Insert(port, slot); }
        ~DeviceKeyboard() { if(keyboard) Remove(); }

    public:
        void Insert(unsigned port, unsigned slot) { keyboard = XInputOpen(XDEVICE_TYPE_DEBUG_KEYBOARD, port, XDEVICE_NO_SLOT, pollingParameters); }
        void Remove(void) { XInputClose(keyboard); keyboard = NULL; }
    };
#endif // DEBUG_KEYBOARD

class DeviceMU : public USBDevice
    {
    public:
        OCHAR drive;

    public:
        DeviceMU() { type = XDEVICE_TYPE_MEMORY_UNIT; drive = 0; }
        DeviceMU(unsigned port, unsigned slot) { type = XDEVICE_TYPE_MEMORY_UNIT; drive = 0; Insert(port, slot); }
        ~DeviceMU() { if(drive) Remove(); }

    public:
        void Insert(unsigned port, unsigned slot) { /*DebugPrint("USBDevice: Insert MU\n");*/ XMountMU(port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, &drive); }
        void Remove(void) { /*DebugPrint("USBDevice: Remove MU\n");*/ XUnmountMU(XMUPortFromDriveLetter(drive), XMUSlotFromDriveLetter(drive)); drive = 0; }
    };

class DeviceHawk : public USBDevice
    {
    public:
        XMediaObject *microphone;
        XMediaObject *headphone;

    public:
        DeviceHawk() { type = XDEVICE_TYPE_VOICE_MICROPHONE; microphone = headphone = NULL; }
        DeviceHawk(unsigned port, unsigned slot) { type = XDEVICE_TYPE_VOICE_MICROPHONE; microphone = headphone = NULL; Insert(port, slot); }
        ~DeviceHawk() { if(microphone || headphone) Remove(); }

    public:
        void Insert(unsigned port, unsigned slot) { /*DebugPrint("USBDevice: Insert HAWK\n"); XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, NULL, &microphone); XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, NULL, &headphone); */}
        void Remove(void) { 
            /*DebugPrint("USBDevice: Remove HAWK\n");*/
            if(microphone) { DebugPrint("microphone->Release()..."); microphone->Release(); DebugPrint("...microphone->Release()\n"); } 
            if(headphone)  { DebugPrint("headphone->Release()...");  headphone->Release();  DebugPrint("...headphone->Release()\n"); } 
            microphone = headphone = NULL; 
            /*DebugPrint("USBDevice: Remove HAWK\n");*/ }
    };

class USBManager
    {
    public:
        bool hotplugs;
        USBDevice *devices[XGetPortCount()][SLOT_MAX];
        DWORD packetNum[XGetPortCount()][SLOT_MAX];
        XINPUT_POLLING_PARAMETERS pollingParameters;

    public:
        USBManager();
        ~USBManager();

    public:
        void DumpControllerState(SOCKET sock, unsigned port, unsigned slot);
        void ProcessInput(void);
        void ProcessInput(SOCKET sock);
        void CheckForHotplugs(void);

    };

} // namespace Launcher

#endif // _USBMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\medialoader\HTTPHeader.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	HTTPHeader.cpp

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 02-Aug-2001

Revision History:

	02-Aug-2001 jeffsul
		Initial Version

--*/

#include "HTTPHeader.h"

#include "MLInternal.h"
#include <stdio.h>

#define CHECKTOKEN( p )										\
if ( NULL == (p) )											\
{															\
	DbgPrint( "[HTTP] Error: Bad token\n" );					\
	RtlAssert( 0, __FILE__, __LINE__, NULL );				\
	return E_FAIL;											\
}

#define CHECKBYTESIZE( n )									\
if ( (n) > (UINT)nLength )										\
{															\
	DbgPrint( "[HTTP] Warning: Reply exceeds maximum buffer size\n" );	\
	RtlAssert( 0, __FILE__, __LINE__, NULL );				\
}	

INT
HTTPSendRequest(
	SOCKET	socket,              
	LPCSTR	lpBuf,  
	INT		nLength            
)
{
	INT		nReturnLength	= 0;

	nReturnLength = send( socket, lpBuf, nLength, 0 );

	return nReturnLength;
}


INT
HTTPGetReply(
	SOCKET	socket,              
	LPVOID	lpBuf,  
	INT		nLength
)
{
	INT		nNumBytes		=	0;
	DWORD	dwNumBytesCopied	=	0;

	LPBYTE	lpBody			=	NULL;

	CHAR* lpReply = new CHAR [HTTP_MAX_BUFFER_SIZE];
	if ( NULL == lpReply )
	{
		return SOCKET_ERROR;
	}
	ZeroMemory( lpReply, HTTP_MAX_BUFFER_SIZE );
	lpBody = new BYTE [HTTP_MAX_BUFFER_SIZE];
	if ( NULL == lpBody )
	{
		SAFEDELETEARRAY( lpReply );
		return SOCKET_ERROR;
	}
	ZeroMemory( lpBody, HTTP_MAX_BUFFER_SIZE );

	// receive from the socket
	HTTPHEADER	HTTPHeader;
	nNumBytes = recv( socket, lpReply, HTTP_MAX_BUFFER_SIZE, 0 );
	if ( SOCKET_ERROR == nNumBytes )
	{
		DbgPrint("[HTTP] Error: Unable to receive HTTP response (error %d)\n", WSAGetLastError());
		SAFEDELETEARRAY( lpReply );
		SAFEDELETEARRAY( lpBody );
		return SOCKET_ERROR;
	}

	// parse out the header and the main body
	HRESULT hr		=	S_OK;
	hr =  HTTPParseReply( lpReply, nNumBytes, &HTTPHeader, lpBody, &dwNumBytesCopied );
	SAFEDELETEARRAY( lpReply );
	if ( FAILED( hr ) )
	{
		DbgPrint("[HTTP] Error: Unable to parse HTTP response (error %d)\n", WSAGetLastError());
		SAFEDELETEARRAY( lpBody );
		return SOCKET_ERROR;
	}
	else if ( S_FALSE == hr )
	{
		SAFEDELETEARRAY( lpBody );
		return 0;
	}

	// see if we have a chunked html file
	if ( HTTP_TE_CHUNKED == HTTPHeader.dwTransferEncoding && HTTP_CT_TEXT_HTML == HTTPHeader.dwContentType )
	{
		DWORD	dwChunkSize	=	0;
		LPBYTE	lpszToken	=	NULL;
		INT		nTempNumBytes	=	0;
		LPBYTE	lpszCurrent	=	NULL;
		BOOL	bIsTerminal	=	FALSE;

		if ( 0 == dwNumBytesCopied )
		{
			// started with no chunk, get the first chunk
			ZeroMemory( lpBody, /*sizeof(lpBody)*/HTTP_MAX_BUFFER_SIZE );
			nTempNumBytes = recv( socket, (CHAR *)lpBody, HTTP_MAX_BUFFER_SIZE, 0 );
			if ( SOCKET_ERROR == nTempNumBytes )
			{
				DbgPrint("[HTTP] Error: Unable to receive HTTP response (error %d)\n", WSAGetLastError());
				SAFEDELETEARRAY( lpBody );
				return SOCKET_ERROR;
			}
			dwNumBytesCopied = nTempNumBytes;
		}

		// parse out the first chunk
		hr = HTTPParseChunk( lpBody, dwNumBytesCopied, lpBuf, &dwChunkSize, &bIsTerminal );
		if ( FAILED( hr ) )
		{
			DbgPrint("[HTTP] Error: Unable to parse HTTP chunk\n" );
			SAFEDELETEARRAY( lpBody );
			return SOCKET_ERROR;
		}
		dwNumBytesCopied = dwChunkSize;
		lpszCurrent = (LPBYTE)lpBuf + dwChunkSize;

		// get the remaining chunks
		while ( FALSE == bIsTerminal )
		{
			// receive another chunk
			ZeroMemory( lpBody, /*sizeof(lpBody)*/HTTP_MAX_BUFFER_SIZE );
			nTempNumBytes = recv( socket, (CHAR *)lpBody, HTTP_MAX_BUFFER_SIZE, 0 );
			if ( 0 == nTempNumBytes )
			{
				DbgPrint("[HTTP] Error: Expected more bytes from server (HTML file may be too large)\n" );
				SAFEDELETEARRAY( lpBody );
				return SOCKET_ERROR;
			}
			if ( SOCKET_ERROR == nTempNumBytes )
			{
				DbgPrint("[HTTP] Error: Unable to receive HTTP response (error %d)\n", WSAGetLastError());
				SAFEDELETEARRAY( lpBody );
				return SOCKET_ERROR;
			}
			
			// parse out the chunk data
			hr = HTTPParseChunk( lpBody, nTempNumBytes, lpszCurrent, &dwChunkSize, &bIsTerminal );
			if ( FAILED( hr ) )
			{
				DbgPrint("[HTTP] Error: Unable to parse HTTP chunk\n" );
				SAFEDELETEARRAY( lpBody );
				return SOCKET_ERROR;
			}
			dwNumBytesCopied += dwChunkSize;
			lpszCurrent = (LPBYTE)lpBuf + dwNumBytesCopied;
		}

		// copy all the data to the destination buffer
		CHECKBYTESIZE( dwNumBytesCopied );
		memcpy( lpBuf, lpszCurrent - dwNumBytesCopied, dwNumBytesCopied );
	}

	else //if ( HTTP_TE_CHUNKED == HTTPHeader.dwTransferEncoding ) // this is a chunked data file
	{
		memcpy( lpBuf, lpBody, dwNumBytesCopied );

		while ( HTTPHeader.dwBytesLeft > 0 )
		{
			INT		nTempNumBytes	=	0;
			
			// get another chunk
			nTempNumBytes = recv( socket, (CHAR *)lpBuf+dwNumBytesCopied, HTTPHeader.dwBytesLeft, 0 );
			if ( SOCKET_ERROR == nNumBytes )
			{
				DbgPrint("[HTTP] Error: Unable to receive HTTP response (error %d)\n", WSAGetLastError());
				SAFEDELETEARRAY( lpBody );
				return SOCKET_ERROR;
			}
			
			dwNumBytesCopied += nTempNumBytes;
			CHECKBYTESIZE( dwNumBytesCopied );
			HTTPHeader.dwBytesLeft -= nTempNumBytes;
		}
	}

	SAFEDELETEARRAY( lpBody );
	return dwNumBytesCopied;
}

INT
HTTPGetReplyToFile(
	SOCKET	socket,
	HANDLE	hFile,
	INT		nLength
)
{
	INT		nNumBytes		=	0;

	CHAR* lpReply = new CHAR [HTTP_MAX_BUFFER_SIZE];
	if ( NULL == lpReply )
	{
		return SOCKET_ERROR;
	}
	ZeroMemory( lpReply, HTTP_MAX_BUFFER_SIZE );

	LPBYTE	lpBody = new BYTE [HTTP_MAX_BUFFER_SIZE];
	if ( NULL == lpBody )
	{
		SAFEDELETEARRAY( lpReply );
		return SOCKET_ERROR;
	}
	ZeroMemory( lpBody, HTTP_MAX_BUFFER_SIZE );

	DWORD	dwNumBytesCopied	=	0;
	BOOL	bSuccess			=	FALSE;
	DWORD	dwNumBytesWritten	=	0;

	LPBYTE	lpChunk = new BYTE [ HTTP_MAX_BUFFER_SIZE ];
	if ( NULL == lpChunk )
	{
		SAFEDELETEARRAY( lpReply );
		SAFEDELETEARRAY( lpBody );
		return 0;
	}

	// receive from the socket
	HTTPHEADER	HTTPHeader;
	nNumBytes = recv( socket, lpReply, HTTP_MAX_BUFFER_SIZE, 0 );
	if ( SOCKET_ERROR == nNumBytes )
	{
		DbgPrint("[HTTP] Error: Unable to receive HTTP response (error %d)\n", WSAGetLastError());
		SAFEDELETEARRAY( lpReply );
		SAFEDELETEARRAY( lpBody );
		delete [] lpChunk;
		return SOCKET_ERROR;
	}

	// parse out the header and the main body
	HRESULT hr		=	S_OK;
	hr =  HTTPParseReply( lpReply, nNumBytes, &HTTPHeader, lpBody, &dwNumBytesCopied );
	SAFEDELETEARRAY( lpReply );
	if ( FAILED( hr ) )
	{
		DbgPrint("[HTTP] Error: Unable to parse HTTP response (error %d)\n", WSAGetLastError());
		SAFEDELETEARRAY( lpBody );
		delete [] lpChunk;
		return SOCKET_ERROR;
	}
	else if ( S_FALSE == hr )
	{
		SAFEDELETEARRAY( lpBody );
		delete [] lpChunk;
		return 0;
	}

	// see if we have a chunked html file
	if ( HTTP_TE_CHUNKED == HTTPHeader.dwTransferEncoding && HTTP_CT_TEXT_HTML == HTTPHeader.dwContentType )
	{
		DWORD	dwChunkSize	=	0;
		LPBYTE	lpszToken	=	NULL;
		INT		nTempNumBytes	=	0;
		LPBYTE	lpszCurrent	=	NULL;
		BOOL	bIsTerminal	=	FALSE;

		if ( 0 == dwNumBytesCopied )
		{
			// started with no chunk, get the first chunk
			ZeroMemory( lpBody, /*sizeof(lpBody)*/HTTP_MAX_BUFFER_SIZE );
			nTempNumBytes = recv( socket, (CHAR *)lpBody, HTTP_MAX_BUFFER_SIZE, 0 );
			if ( SOCKET_ERROR == nTempNumBytes )
			{
				DbgPrint("[HTTP] Error: Unable to receive HTTP response (error %d)\n", WSAGetLastError());
				SAFEDELETEARRAY( lpBody );
				delete [] lpChunk;
				return SOCKET_ERROR;
			}
			dwNumBytesCopied = nTempNumBytes;
		}

		// parse out the first chunk
		hr = HTTPParseChunk( lpBody, dwNumBytesCopied, lpChunk, &dwChunkSize, &bIsTerminal );
		if ( FAILED( hr ) )
		{
			DbgPrint("[HTTP] Error: Unable to parse HTTP chunk\n" );
			SAFEDELETEARRAY( lpBody );
			delete [] lpChunk;
			return SOCKET_ERROR;
		}
		dwNumBytesCopied = dwChunkSize;

		//------------------------------------------------------------------------------
		//	write buffer to file
		//------------------------------------------------------------------------------
		bSuccess = WriteFile( hFile, lpChunk, dwChunkSize, &dwNumBytesWritten, NULL );
		if ( FALSE == bSuccess || dwChunkSize != dwNumBytesWritten )
		{
			/*ML_OUTPUT( 1,*/ DbgPrint( "[MediaLoader] Error: WriteFile failed (error %d)\n", GetLastError() /*)*/ );
			SAFEDELETEARRAY( lpBody );
			delete [] lpChunk;
			return 0;
		}

		// get the remaining chunks
		while ( FALSE == bIsTerminal )
		{
			// receive another chunk
			ZeroMemory( lpBody, /*sizeof(lpBody)*/HTTP_MAX_BUFFER_SIZE );
			nTempNumBytes = recv( socket, (CHAR *)lpBody, HTTP_MAX_BUFFER_SIZE, 0 );
			if ( 0 == nTempNumBytes )
			{
				DbgPrint("[HTTP] Error: Expected more bytes from server (HTML file may be too large)\n" );
				SAFEDELETEARRAY( lpBody );
				delete [] lpChunk;
				return SOCKET_ERROR;
			}
			if ( SOCKET_ERROR == nTempNumBytes )
			{
				DbgPrint("[HTTP] Error: Unable to receive HTTP response (error %d)\n", WSAGetLastError());
				SAFEDELETEARRAY( lpBody );
				delete [] lpChunk;
				return SOCKET_ERROR;
			}
			
			// parse out the chunk data
			hr = HTTPParseChunk( lpBody, nTempNumBytes, lpChunk, &dwChunkSize, &bIsTerminal );
			if ( FAILED( hr ) )
			{
				DbgPrint("[HTTP] Error: Unable to parse HTTP chunk\n" );
				SAFEDELETEARRAY( lpBody );
				delete [] lpChunk;
				return SOCKET_ERROR;
			}
			dwNumBytesCopied += dwChunkSize;

			//------------------------------------------------------------------------------
			//	write buffer to file
			//------------------------------------------------------------------------------
			bSuccess = WriteFile( hFile, lpChunk, dwChunkSize, &dwNumBytesWritten, NULL );
			if ( FALSE == bSuccess || dwChunkSize != dwNumBytesWritten )
			{
				/*ML_OUTPUT( 1,*/ DbgPrint( "[MediaLoader] Error: WriteFile failed (error %d)\n", GetLastError() /*)*/ );
				SAFEDELETEARRAY( lpBody );
				delete [] lpChunk;
				return 0;
			}
		}

		// copy all the data to the destination buffer
		CHECKBYTESIZE( dwNumBytesCopied );
		//memcpy( lpBuf, lpszCurrent - dwNumBytesCopied, dwNumBytesCopied );
	}

	else // this is not a chunked data file
	{
		//memcpy( lpBuf, lpBody, dwNumBytesCopied );
		bSuccess = WriteFile( hFile, lpBody, dwNumBytesCopied, &dwNumBytesWritten, NULL );
		if ( FALSE == bSuccess || dwNumBytesCopied != dwNumBytesWritten )
		{
			/*ML_OUTPUT( 1,*/ DbgPrint( "[MediaLoader] Error: WriteFile failed (error %d)\n", GetLastError() ) /*)*/;
			SAFEDELETEARRAY( lpBody );
			delete [] lpChunk;
			return 0;
		}

		while ( HTTPHeader.dwBytesLeft > 0 )
		{
			INT		nTempNumBytes	=	0;
			
			// get another chunk
			nTempNumBytes = recv( socket, (CHAR *)lpBody, HTTP_MAX_BUFFER_SIZE, 0 );
			if ( SOCKET_ERROR == nTempNumBytes || 0 == nTempNumBytes )
			{
				DbgPrint("[HTTP] Error: Unable to receive HTTP response (error %d)\n", WSAGetLastError());
				SAFEDELETEARRAY( lpBody );
				delete [] lpChunk;
				return SOCKET_ERROR;
			}

			bSuccess = WriteFile( hFile, lpBody, nTempNumBytes, &dwNumBytesWritten, NULL );
			if ( FALSE == bSuccess || nTempNumBytes != dwNumBytesWritten )
			{
				/*ML_OUTPUT( 1,*/ DbgPrint( "[MediaLoader] Error: WriteFile failed (error %d)\n", GetLastError() ) /*)*/;
				SAFEDELETEARRAY( lpBody );
				delete [] lpChunk;
				return 0;
			}
			
			dwNumBytesCopied += nTempNumBytes;
			CHECKBYTESIZE( dwNumBytesCopied );
			HTTPHeader.dwBytesLeft -= nTempNumBytes;
		}
	}

	SAFEDELETEARRAY( lpBody );
	delete [] lpChunk;
	return dwNumBytesCopied;
}

HRESULT 
HTTPParseReply( 
	IN LPSTR		lpBuf, 
	IN DWORD		dwSize, 
	OUT PHTTPHEADER pHTTPHeader, 
	OUT LPVOID		lpBody,
	OUT	LPDWORD		lpdwSizeCopied
)
{
	HRESULT hr		=	S_OK;

	LPSTR	lpszToken	=	NULL;
	CHAR	szHeader[HTTP_MAX_HEADER_SIZE];

	ZeroMemory( pHTTPHeader, sizeof(HTTPHEADER) );

	// find the end of the header
	lpszToken = strstr( (CHAR *)lpBuf, "\r\n\r\n" );
	if ( NULL == lpszToken )
	{
		return E_FAIL;
	}
	lpszToken += 4;

	// calculate length of header and main body
	INT		nHeaderLength = lpszToken-lpBuf;
	*lpdwSizeCopied	 =	dwSize-nHeaderLength;

	// copy the header to a usable buffer
	memcpy( szHeader, lpBuf, nHeaderLength );
	szHeader[nHeaderLength+1] = '\0';


	if ( 0 < *lpdwSizeCopied )
	{
		// copy the main body into the destination buffer
		memcpy( lpBody, lpszToken, *lpdwSizeCopied );
	}

	// get the HTTP version, status code, and status message from the first line
	INT nSuccess = 0;
	lpszToken = strtok( szHeader, " /" );
	CHECKTOKEN( lpszToken );
	lpszToken = strtok( NULL, " \t" );
	CHECKTOKEN( lpszToken );
	pHTTPHeader->fVersion = (FLOAT)atof( lpszToken );
	lpszToken = strtok( NULL, " \t" );
	CHECKTOKEN( lpszToken );
	pHTTPHeader->nStatusCode = atoi( lpszToken );
	lpszToken = strtok( NULL, "\t\r\n" );
	CHECKTOKEN( lpszToken );
	strcpy( pHTTPHeader->szStatusMessage, lpszToken );

	// check the status code to make sure we got a 200 level status (OK)
	if ( pHTTPHeader->nStatusCode < 200 || pHTTPHeader->nStatusCode > 299 )
	{
		// if we have any error other than 404 (not found) print out an error
		if ( 404 != pHTTPHeader->nStatusCode )
		{
			DbgPrint( "[HTTP] Warning: Transfer error (error %d: %s)\n", pHTTPHeader->nStatusCode, pHTTPHeader->szStatusMessage );
		}
		return S_FALSE;
	}

	// parse out each of the data fields from the header
	lpszToken = strtok( NULL, " :\t\r\n" );
	while ( NULL != lpszToken )
	{
		if ( 0 == strcmp( lpszToken, "Server" ) )
		{
			lpszToken = strtok( NULL, "\r\n" );
			if ( NULL != lpszToken )
			{
				strcpy( pHTTPHeader->szServer, lpszToken );
			}
		}
		else if ( 0 == strcmp( lpszToken, "Date" ) )
		{
			lpszToken = strtok( NULL, "\r\n" );
			if ( NULL != lpszToken )
			{
				strcpy( pHTTPHeader->szDate, lpszToken );
			}
		}
		else if ( 0 == strcmp( lpszToken, "Transfer-Encoding" ) )
		{
			lpszToken = strtok( NULL, "\r\n" );
			if ( NULL != lpszToken )
			{
				if ( 0 == strcmp( lpszToken, " chunked" ) )
				{
					pHTTPHeader->dwTransferEncoding = HTTP_TE_CHUNKED;
				}
				else
				{
					pHTTPHeader->dwTransferEncoding = HTTP_TE_NORMAL;
				}
			}
		}
		else if ( 0 == strcmp( lpszToken, "Content-Type" ) )
		{
			lpszToken = strtok( NULL, "\r\n" );
			if ( NULL != lpszToken )
			{
				if ( 0 == strcmp( lpszToken, " text/html" ) )
				{
					pHTTPHeader->dwContentType = HTTP_CT_TEXT_HTML;
				}
				else if ( 0 == strcmp( lpszToken, " audio/wav" ) )
				{
					pHTTPHeader->dwContentType = HTTP_CT_AUDIO_WAV;
				}
				else
				{
					pHTTPHeader->dwContentType = FTTP_CT_UNDEFINED;
				}
			}
		}
		else if ( 0 == strcmp( lpszToken, "Content-Length" ) )
		{
			lpszToken = strtok( NULL, "\r\n" );
			if ( NULL != lpszToken )
			{
				pHTTPHeader->dwContentLength = atoi( lpszToken );
				pHTTPHeader->dwBytesLeft = pHTTPHeader->dwContentLength - *lpdwSizeCopied;
			}
		}

		else
		{
			// we don't care about this partivular data field,
			// skip over its data and move on
			lpszToken = strtok( NULL, "\r\n" );
		}

		// go to the next data field
		lpszToken = strtok( NULL, " :\t\r\n" );
	}

	return hr;
}



HRESULT
HTTPParseChunk(
	IN LPBYTE		lpChunk,
	IN DWORD		dwSize,
	OUT	LPVOID		lpBody,
	OUT	LPDWORD		lpdwSizeCopied,
	OUT	PBOOL		pbIsLastChunk
)
{
	HRESULT hr	=	S_OK;

	LPBYTE	lpszChunkSize, lpszNextChunkSize, lpBeginBody;
	INT		nContentLength, nNextChunkSize;

	lpszNextChunkSize = (LPBYTE)strstr( (CHAR *)lpChunk+dwSize-10, "\r\n" );
	if ( NULL == lpszNextChunkSize )
	{
		// no \r\n was found at the end of the chunk,
		// so we must have at least one more chunk and
		// the end of the actual data is the end of the chunk
		pbIsLastChunk = FALSE;
		lpszNextChunkSize = lpChunk + dwSize;
	}
	else
	{
		// calculate the size of the actual data
		INT		nNumFields;
		nNumFields = sscanf( (CHAR *)lpszNextChunkSize, "\r\n%x\r\n", &nNextChunkSize );

		// see if this is the last chunk
		if ( 0 == nNextChunkSize )
		{
			*pbIsLastChunk = TRUE;
		}
		else
		{
			*pbIsLastChunk = FALSE;
		}
	}

	lpszChunkSize = (LPBYTE)strstr( (CHAR *)lpChunk, "\r\n" );
	if ( NULL == lpszChunkSize || '0' == lpszChunkSize[2] || lpszChunkSize-lpChunk > 10 )
	{
		// if there was no \r\n or the only \r\n was at the end of the chunk,
		// then the actual data starts at the beginning of the chunk
		lpBeginBody = lpChunk;
		//*lpdwSizeCopied = lpszNextChunkSize - lpChunk;

	}
	else
	{
		// skip over the hex number to the actual data
		INT		nNumFields;
		nNumFields = sscanf( (CHAR *)lpszChunkSize + 2, "%x", &nContentLength );
		//lpBeginBody = lpszChunkSize + strstr( lpszChunkSize + 2;
		lpBeginBody = (LPBYTE)strstr( (CHAR *)lpszChunkSize, "\r\n" ) + 2;
	}

	if ( NULL == lpBeginBody )
	{
		DbgPrint( "[HTTP] Error: Unable to parse chunk correctly\n" );
		return E_FAIL;
	}

	*lpdwSizeCopied = lpszNextChunkSize - lpBeginBody;
	
	if ( 0 < *lpdwSizeCopied )
	{
		// copy the actual data to the destination buffer
		memcpy( lpBody, lpBeginBody, *lpdwSizeCopied );
	}
	

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\medialoader\FileList.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	FileList.h

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 01-Aug-2001

Revision History:

	01-Aug-2001 jeffsul
		Initial Version

--*/

#ifndef __FILELIST_H__
#define __FILELIST_H__

#include "HTTPHeader.h"

#include <xtl.h>

typedef struct _FILELISTNODE			//	a stucture to hold info for each file in a list
{
	WIN32_FIND_DATA	FindData;			//	contains file info (see msdn)
	BOOL	bUsed;						//	whether or not the file has been "accessed" already
	_FILELISTNODE* pNext;				//	pointer to the next file node structure in the list
} FILELISTNODE, *PFILELISTNODE;

class CFileList
{
public:
	CFileList();
	~CFileList();

	HRESULT												//	adds a file to the list
	AddFile( 
		IN CONST LPWIN32_FIND_DATA lpFindFileData		//	file info for node to be added
	);

	HRESULT												//	remove a file from the list
	RemoveFile(					
		IN LPCSTR lpszFileName							//	the name of the file to remove
	);

	HRESULT												//	gets the file info from a random unused file in the list,
	GetRandomUnusedFile(								//	then marks it as used
		OUT LPWIN32_FIND_DATA lpFindFileData			//	a pointer to the structure to fill with the found data
	);

	HRESULT												//	gets the first unused file from the list,
	GetFirstUnusedFile(									//	then marks it as used
		OUT LPWIN32_FIND_DATA lpFindFileData			//	a pointer to the structure to fill with the found data
	);

	INT													//	returns the number of files in the list
	GetNumFiles();										

	HRESULT												//	creates a file list from an html directory listing,
	ParseHTML(											//	files that match the search string are added
		IN LPCSTR lpszBuf,								//	a character buffer containing a full html file 
		IN DWORD dwSize,								//	the size of the html buffer
		IN LPCSTR lpszSearchString						//	the regular expression string that file names must match
	);

protected:

private:
	PFILELISTNODE	m_pFirstFile;						//	a pointer to the first file node in the list
	UINT			m_nNumFiles;						//	the number of nodes in the list

	BOOL												//	a utility function to see if a filename matches
	FileNameMatches(									//	a particular regular expression
		IN LPCSTR lpszSearchString,					//	the regular expression string that file names must match
		IN LPCSTR lpszFileName							//	the (full path and) file name of the file in question
	);

	//VOID
	//CopyFileName(
	//	IN LPSTR  lpszDest,
	//	IN LPCSTR lpszSrc
	//);
};
	
#endif // #ifndef __FILELIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\medialoader\MLInternal.h ===
#ifndef _MLINTERNAL_H_
#define _MLINTERN