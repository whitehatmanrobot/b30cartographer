OM_DEFAULT), SORT_DEFAULT))

#define LOCALE_CUSTOM_UNSPECIFIED                                             \
          (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_CUSTOM_UNSPECIFIED), SORT_DEFAULT))

#define LOCALE_CUSTOM_UI_DEFAULT                                              \
          (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_UI_CUSTOM_DEFAULT), SORT_DEFAULT))

#define LOCALE_NEUTRAL                                                        \
          (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT))

#define LOCALE_INVARIANT                                                      \
          (MAKELCID(MAKELANGID(LANG_INVARIANT, SUBLANG_NEUTRAL), SORT_DEFAULT))

// begin_ntminiport begin_ntndis begin_ntminitape

//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! defined(lint)
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this varible.  Error 527 has to do with unreachable code.
// -restore restores checking to the -save state

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -save -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint -restore */

#endif // lint

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//

#if (_MSC_VER > 1200)
#define DEFAULT_UNREACHABLE default: __assume(0)
#else

//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

#define DEFAULT_UNREACHABLE

#endif

#ifdef __cplusplus

// Define operator overloads to enable bit operations on enum values that are 
// used to define flags. Use DEFINE_ENUM_FLAG_OPERATORS(YOUR_TYPE) to enable these 
// operators on YOUR_TYPE.

// Moved here from objbase.w.

#define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE) \
extern "C++" { \
inline ENUMTYPE operator | (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((int)a) | ((int)b)); } \
inline ENUMTYPE &operator |= (ENUMTYPE &a, ENUMTYPE b) { return (ENUMTYPE &)(((int &)a) |= ((int)b)); } \
inline ENUMTYPE operator & (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((int)a) & ((int)b)); } \
inline ENUMTYPE &operator &= (ENUMTYPE &a, ENUMTYPE b) { return (ENUMTYPE &)(((int &)a) &= ((int)b)); } \
inline ENUMTYPE operator ~ (ENUMTYPE a) { return ENUMTYPE(~((int)a)); } \
inline ENUMTYPE operator ^ (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((int)a) ^ ((int)b)); } \
inline ENUMTYPE &operator ^= (ENUMTYPE &a, ENUMTYPE b) { return (ENUMTYPE &)(((int &)a) ^= ((int)b)); } \
}
#else
#define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE) // NOP, C allows these operators.
#endif

// Compile-time macros for initializing flag values in const data.
// 
// When using DEFINE_ENUM_FLAG_OPERATORS for enum values you should use the macros below
// when you need to initialize global const data.  Without these macros the inline operators 
// from DEFINE_ENUM_FLAG_OPERATORS force a runtime initialization rather than a
// compile time initialization.  This applies even if you have declared the data as const.
#define COMPILETIME_OR_2FLAGS(a,b)          ((UINT)(a)|(UINT)(b))
#define COMPILETIME_OR_3FLAGS(a,b,c)        ((UINT)(a)|(UINT)(b)|(UINT)(c))
#define COMPILETIME_OR_4FLAGS(a,b,c,d)      ((UINT)(a)|(UINT)(b)|(UINT)(c)|(UINT)(d))
#define COMPILETIME_OR_5FLAGS(a,b,c,d,e)    ((UINT)(a)|(UINT)(b)|(UINT)(c)|(UINT)(d)|(UINT)(e))

#ifndef WIN32_NO_STATUS 
/*lint -save -e767 */  
#define STATUS_WAIT_0                    ((DWORD   )0x00000000L)    
#define STATUS_ABANDONED_WAIT_0          ((DWORD   )0x00000080L)    
#define STATUS_USER_APC                  ((DWORD   )0x000000C0L)    
#define STATUS_TIMEOUT                   ((DWORD   )0x00000102L)    
#define STATUS_PENDING                   ((DWORD   )0x00000103L)    
#define DBG_EXCEPTION_HANDLED            ((DWORD   )0x00010001L)    
#define DBG_CONTINUE                     ((DWORD   )0x00010002L)    
#define STATUS_SEGMENT_NOTIFICATION      ((DWORD   )0x40000005L)    
#define DBG_TERMINATE_THREAD             ((DWORD   )0x40010003L)    
#define DBG_TERMINATE_PROCESS            ((DWORD   )0x40010004L)    
#define DBG_CONTROL_C                    ((DWORD   )0x40010005L)    
#define DBG_PRINTEXCEPTION_C             ((DWORD   )0x40010006L)    
#define DBG_RIPEXCEPTION                 ((DWORD   )0x40010007L)    
#define DBG_CONTROL_BREAK                ((DWORD   )0x40010008L)    
#define DBG_COMMAND_EXCEPTION            ((DWORD   )0x40010009L)    
#define STATUS_GUARD_PAGE_VIOLATION      ((DWORD   )0x80000001L)    
#define STATUS_DATATYPE_MISALIGNMENT     ((DWORD   )0x80000002L)    
#define STATUS_BREAKPOINT                ((DWORD   )0x80000003L)    
#define STATUS_SINGLE_STEP               ((DWORD   )0x80000004L)    
#define STATUS_LONGJUMP                  ((DWORD   )0x80000026L)    
#define STATUS_UNWIND_CONSOLIDATE        ((DWORD   )0x80000029L)    
#define DBG_EXCEPTION_NOT_HANDLED        ((DWORD   )0x80010001L)    
#define STATUS_ACCESS_VIOLATION          ((DWORD   )0xC0000005L)    
#define STATUS_IN_PAGE_ERROR             ((DWORD   )0xC0000006L)    
#define STATUS_INVALID_HANDLE            ((DWORD   )0xC0000008L)    
#define STATUS_INVALID_PARAMETER         ((DWORD   )0xC000000DL)    
#define STATUS_NO_MEMORY                 ((DWORD   )0xC0000017L)    
#define STATUS_ILLEGAL_INSTRUCTION       ((DWORD   )0xC000001DL)    
#define STATUS_NONCONTINUABLE_EXCEPTION  ((DWORD   )0xC0000025L)    
#define STATUS_INVALID_DISPOSITION       ((DWORD   )0xC0000026L)    
#define STATUS_ARRAY_BOUNDS_EXCEEDED     ((DWORD   )0xC000008CL)    
#define STATUS_FLOAT_DENORMAL_OPERAND    ((DWORD   )0xC000008DL)    
#define STATUS_FLOAT_DIVIDE_BY_ZERO      ((DWORD   )0xC000008EL)    
#define STATUS_FLOAT_INEXACT_RESULT      ((DWORD   )0xC000008FL)    
#define STATUS_FLOAT_INVALID_OPERATION   ((DWORD   )0xC0000090L)    
#define STATUS_FLOAT_OVERFLOW            ((DWORD   )0xC0000091L)    
#define STATUS_FLOAT_STACK_CHECK         ((DWORD   )0xC0000092L)    
#define STATUS_FLOAT_UNDERFLOW           ((DWORD   )0xC0000093L)    
#define STATUS_INTEGER_DIVIDE_BY_ZERO    ((DWORD   )0xC0000094L)    
#define STATUS_INTEGER_OVERFLOW          ((DWORD   )0xC0000095L)    
#define STATUS_PRIVILEGED_INSTRUCTION    ((DWORD   )0xC0000096L)    
#define STATUS_STACK_OVERFLOW            ((DWORD   )0xC00000FDL)    
#define STATUS_DLL_NOT_FOUND             ((DWORD   )0xC0000135L)    
#define STATUS_ORDINAL_NOT_FOUND         ((DWORD   )0xC0000138L)    
#define STATUS_ENTRYPOINT_NOT_FOUND      ((DWORD   )0xC0000139L)    
#define STATUS_CONTROL_C_EXIT            ((DWORD   )0xC000013AL)    
#define STATUS_DLL_INIT_FAILED           ((DWORD   )0xC0000142L)    
#define STATUS_FLOAT_MULTIPLE_FAULTS     ((DWORD   )0xC00002B4L)    
#define STATUS_FLOAT_MULTIPLE_TRAPS      ((DWORD   )0xC00002B5L)    
#define STATUS_REG_NAT_CONSUMPTION       ((DWORD   )0xC00002C9L)    
#define STATUS_STACK_BUFFER_OVERRUN      ((DWORD   )0xC0000409L)    
#define STATUS_INVALID_CRUNTIME_PARAMETER ((DWORD   )0xC0000417L)    
#define STATUS_ASSERTION_FAILURE         ((DWORD   )0xC0000420L)    
#if defined(STATUS_SUCCESS) || (_WIN32_WINNT > 0x0500) || (_WIN32_FUSION >= 0x0100) 
#define STATUS_SXS_EARLY_DEACTIVATION    ((DWORD   )0xC015000FL)    
#define STATUS_SXS_INVALID_DEACTIVATION  ((DWORD   )0xC0150010L)    
#endif 
/*lint -restore */  
#endif 
#define MAXIMUM_WAIT_OBJECTS 64     // Maximum number of wait objects

#define MAXIMUM_SUSPEND_COUNT MAXCHAR // Maximum times thread can be suspended

typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;


//
// Define 128-bit 16-byte aligned xmm register type.
//

typedef struct DECLSPEC_ALIGN(16) _M128A {
    ULONGLONG Low;
    LONGLONG High;
} M128A, *PM128A;

//
// Format of data for (F)XSAVE/(F)XRSTOR instruction
//

typedef struct DECLSPEC_ALIGN(16) _XSAVE_FORMAT {
    WORD   ControlWord;
    WORD   StatusWord;
    BYTE  TagWord;
    BYTE  Reserved1;
    WORD   ErrorOpcode;
    DWORD ErrorOffset;
    WORD   ErrorSelector;
    WORD   Reserved2;
    DWORD DataOffset;
    WORD   DataSelector;
    WORD   Reserved3;
    DWORD MxCsr;
    DWORD MxCsr_Mask;
    M128A FloatRegisters[8];

#if defined(_WIN64)

    M128A XmmRegisters[16];
    BYTE  Reserved4[96];

#else

    M128A XmmRegisters[8];
    BYTE  Reserved4[192];

    //
    // The fields below are not part of XSAVE/XRSTOR format.
    // They are written by the OS which is relying on a fact that
    // neither (FX)SAVE nor (F)XSTOR used this area.
    //

    DWORD   StackControl[7];    // KERNEL_STACK_CONTROL structure actualy
    DWORD   Cr0NpxState;

#endif

} XSAVE_FORMAT, *PXSAVE_FORMAT;

typedef struct DECLSPEC_ALIGN(8) _XSAVE_AREA_HEADER {
    DWORD64 Mask;
    DWORD64 Reserved[7];
} XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;

typedef struct DECLSPEC_ALIGN(16) _XSAVE_AREA {
    XSAVE_FORMAT LegacyState;
    XSAVE_AREA_HEADER Header;
} XSAVE_AREA, *PXSAVE_AREA;

typedef struct _XSTATE_CONTEXT {
    DWORD64 Mask;
    DWORD Length;
    DWORD Reserved1;
    __field_bcount_opt(Length) PXSAVE_AREA Area;

#if defined(_X86_)
    DWORD Reserved2;
#endif

    PVOID Buffer;

#if defined(_X86_)
    DWORD Reserved3;
#endif

} XSTATE_CONTEXT, *PXSTATE_CONTEXT;


#define XSAVE_ALIGN                 64
#define MINIMAL_XSTATE_AREA_LENGTH  sizeof(XSAVE_AREA)


//
// This structure specifies an offset (from the beginning of CONTEXT_EX
// structure) and size of a single chunk of an extended context structure.
//
// N.B. Offset may be negative.
//

typedef struct _CONTEXT_CHUNK {
    LONG Offset;
    DWORD Length;
} CONTEXT_CHUNK, *PCONTEXT_CHUNK;

//
// CONTEXT_EX structure is an extension to CONTEXT structure. It defines
// a context record as a set of disjoint variable-sized buffers (chunks)
// each containing a portion of processor state. Currently there are only
// two buffers (chunks) are defined:
//
//   - Legacy, that stores traditional CONTEXT structure;
//   - XState, that stores XSAVE save area buffer starting from
//     XSAVE_AREA_HEADER, i.e. without the first 512 bytes.
//
// There a few assumptions exists that simplify conversion of PCONTEXT
// pointer to PCONTEXT_EX pointer.
//
// 1. APIs that work with PCONTEXT pointers assume that CONTEXT_EX is
//    stored right after the CONTEXT structure. It is also assumed that
//    CONTEXT_EX is present if and only if corresponding CONTEXT_XXX
//    flags are set in CONTEXT.ContextFlags.
//
// 2. CONTEXT_EX.Legacy is always present if CONTEXT_EX structure is
//    present. All other chunks are optional.
//
// 3. CONTEXT.ContextFlags unambigiously define which chunks are
//    present. I.e. if CONTEXT_XSTATE is set CONTEXT_EX.XState is valid.
//

typedef struct _CONTEXT_EX {

    //
    // The total length of the structure starting from the chunk with
    // the smallest offset. N.B. that the offset may be negative.
    //

    CONTEXT_CHUNK All;

    //
    // Wrapper for the traditional CONTEXT structure. N.B. the size of
    // the chunk may be less than sizeof(CONTEXT) is some cases (when
    // CONTEXT_EXTENDED_REGISTERS is not set on x86 for instance).
    //

    CONTEXT_CHUNK Legacy;

    //
    // CONTEXT_XSTATE: Extended processor state chunk. The state is
    // stored in the same format XSAVE operation strores it with
    // exception of the first 512 bytes, i.e. staring from
    // XSAVE_AREA_HEADER. The lower two bits corresponding FP and
    // SSE state must be zero.
    //

    CONTEXT_CHUNK XState;

} CONTEXT_EX, *PCONTEXT_EX;

#define CONTEXT_EX_LENGTH   ALIGN_UP_BY(sizeof(CONTEXT_EX), STACK_ALIGN)

//
// These macros make context chunks manupulations easier.
//

#define RTL_CONTEXT_EX_OFFSET(ContextEx, Chunk)         \
    ((ContextEx)->Chunk.Offset)

#define RTL_CONTEXT_EX_LENGTH(ContextEx, Chunk)         \
    ((ContextEx)->Chunk.Length)

#define RTL_CONTEXT_EX_CHUNK(Base, Layout, Chunk)       \
    ((PVOID)((PCHAR)(Base) + RTL_CONTEXT_EX_OFFSET(Layout, Chunk)))

#define RTL_CONTEXT_OFFSET(Context, Chunk)              \
    RTL_CONTEXT_EX_OFFSET((PCONTEXT_EX)(Context + 1), Chunk)

#define RTL_CONTEXT_LENGTH(Context, Chunk)              \
    RTL_CONTEXT_EX_LENGTH((PCONTEXT_EX)(Context + 1), Chunk)

#define RTL_CONTEXT_CHUNK(Context, Chunk)               \
    RTL_CONTEXT_EX_CHUNK((PCONTEXT_EX)(Context + 1),    \
                         (PCONTEXT_EX)(Context + 1),    \
                         Chunk)


#if !defined(__midl) && !defined(MIDL_PASS)

//
// XSAVE/XRSTOR save area should be aligned on 64 byte boundary
//

C_ASSERT((sizeof(XSAVE_FORMAT) & (XSAVE_ALIGN - 1)) == 0);
C_ASSERT((FIELD_OFFSET(XSAVE_AREA, Header) & (XSAVE_ALIGN - 1)) == 0);

// XSAVE_AREA structure must be sized uniformly on all architectures
C_ASSERT(MINIMAL_XSTATE_AREA_LENGTH == 512 + 64);

#endif


#ifdef _AMD64_


#if defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

//
// Define bit test intrinsics.
//

#ifdef __cplusplus
extern "C" {
#endif

#define BitTest _bittest
#define BitTestAndComplement _bittestandcomplement
#define BitTestAndSet _bittestandset
#define BitTestAndReset _bittestandreset
#define InterlockedBitTestAndSet _interlockedbittestandset
#define InterlockedBitTestAndReset _interlockedbittestandreset

#define BitTest64 _bittest64
#define BitTestAndComplement64 _bittestandcomplement64
#define BitTestAndSet64 _bittestandset64
#define BitTestAndReset64 _bittestandreset64
#define InterlockedBitTestAndSet64 _interlockedbittestandset64
#define InterlockedBitTestAndReset64 _interlockedbittestandreset64

__checkReturn
BOOLEAN
_bittest (
    __in_bcount((Offset+7)/8) LONG const *Base,
    __in LONG Offset
    );

BOOLEAN
_bittestandcomplement (
    __inout_bcount((Offset+7)/8) LONG *Base,
    __in LONG Offset
    );

BOOLEAN
_bittestandset (
    __inout_bcount((Offset+7)/8) LONG *Base,
    __in LONG Offset
    );

BOOLEAN
_bittestandreset (
    __inout_bcount((Offset+7)/8) LONG *Base,
    __in LONG Offset
    );

BOOLEAN
_interlockedbittestandset (
    __inout_bcount((Offset+7)/8) __drv_interlocked LONG volatile *Base,
    __in LONG Offset
    );

BOOLEAN
_interlockedbittestandreset (
    __inout_bcount((Offset+7)/8) __drv_interlocked LONG volatile *Base,
    __in LONG Offset
    );

BOOLEAN
_bittest64 (
    __in_bcount((Offset+7)/8) LONG64 const *Base,
    __in LONG64 Offset
    );

BOOLEAN
_bittestandcomplement64 (
    __inout_bcount((Offset+7)/8) LONG64 *Base,
    __in LONG64 Offset
    );

BOOLEAN
_bittestandset64 (
    __inout_bcount((Offset+7)/8) LONG64 *Base,
    __in LONG64 Offset
    );

BOOLEAN
_bittestandreset64 (
    __inout_bcount((Offset+7)/8) LONG64 *Base,
    __in LONG64 Offset
    );

BOOLEAN
_interlockedbittestandset64 (
    __inout_bcount((Offset+7)/8) __drv_interlocked LONG64 volatile *Base,
    __in LONG64 Offset
    );

BOOLEAN
_interlockedbittestandreset64 (
    __inout_bcount((Offset+7)/8) __drv_interlocked LONG64 volatile *Base,
    __in LONG64 Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)
#pragma intrinsic(_interlockedbittestandset)
#pragma intrinsic(_interlockedbittestandreset)

#pragma intrinsic(_bittest64)
#pragma intrinsic(_bittestandcomplement64)
#pragma intrinsic(_bittestandset64)
#pragma intrinsic(_bittestandreset64)
#pragma intrinsic(_interlockedbittestandset64)
#pragma intrinsic(_interlockedbittestandreset64)

//
// Define bit scan intrinsics.
//

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse
#define BitScanForward64 _BitScanForward64
#define BitScanReverse64 _BitScanReverse64

__success(return!=0)
BOOLEAN
_BitScanForward (
    __out DWORD *Index,
    __in DWORD Mask
    );

__success(return!=0)
BOOLEAN
_BitScanReverse (
    __out DWORD *Index,
    __in DWORD Mask
    );

__success(return!=0)
BOOLEAN
_BitScanForward64 (
    __out DWORD *Index,
    __in DWORD64 Mask
    );

__success(return!=0)
BOOLEAN
_BitScanReverse64 (
    __out DWORD *Index,
    __in DWORD64 Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#pragma intrinsic(_BitScanForward64)
#pragma intrinsic(_BitScanReverse64)

//
// Interlocked intrinsic functions.
//

#define InterlockedIncrement16 _InterlockedIncrement16
#define InterlockedDecrement16 _InterlockedDecrement16
#define InterlockedCompareExchange16 _InterlockedCompareExchange16

#define InterlockedAnd _InterlockedAnd
#define InterlockedAndAcquire _InterlockedAnd
#define InterlockedAndRelease _InterlockedAnd
#define InterlockedOr _InterlockedOr
#define InterlockedOrAcquire _InterlockedOr
#define InterlockedOrRelease _InterlockedOr
#define InterlockedXor _InterlockedXor
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedIncrementAcquire InterlockedIncrement
#define InterlockedIncrementRelease InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedDecrementAcquire InterlockedDecrement
#define InterlockedDecrementRelease InterlockedDecrement
#define InterlockedAdd _InterlockedAdd
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire InterlockedCompareExchange
#define InterlockedCompareExchangeRelease InterlockedCompareExchange

#define InterlockedAnd64 _InterlockedAnd64
#define InterlockedAnd64Acquire _InterlockedAnd64
#define InterlockedAnd64Release _InterlockedAnd64
#define InterlockedAndAffinity InterlockedAnd64
#define InterlockedOr64 _InterlockedOr64
#define InterlockedOr64Acquire _InterlockedOr64
#define InterlockedOr64Release _InterlockedOr64
#define InterlockedOrAffinity InterlockedOr64
#define InterlockedXor64 _InterlockedXor64
#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedAdd64 _InterlockedAdd64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAcquire64 InterlockedExchange64
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64
#define InterlockedCompareExchangeAcquire64 InterlockedCompareExchange64
#define InterlockedCompareExchangeRelease64 InterlockedCompareExchange64

#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerAcquire _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerRelease _InterlockedCompareExchangePointer

#define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd64((LONG64 *)a, b)
#define InterlockedIncrementSizeT(a) InterlockedIncrement64((LONG64 *)a)
#define InterlockedDecrementSizeT(a) InterlockedDecrement64((LONG64 *)a)

SHORT
InterlockedIncrement16 (
    __inout __drv_interlocked SHORT volatile *Addend
    );

SHORT
InterlockedDecrement16 (
    __inout __drv_interlocked SHORT volatile *Addend
    );

SHORT
InterlockedCompareExchange16 (
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT ExChange,
    __in SHORT Comperand
    );

LONG
InterlockedAnd (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG Value
    );

LONG
InterlockedOr (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG Value
    );

LONG
InterlockedXor (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG Value
    );

LONG64
InterlockedAnd64 (
    __inout __drv_interlocked LONG64 volatile *Destination,
    __in LONG64 Value
    );

LONG64
InterlockedOr64 (
    __inout __drv_interlocked LONG64 volatile *Destination,
    __in LONG64 Value
    );

LONG64
InterlockedXor64 (
    __inout __drv_interlocked LONG64 volatile *Destination,
    __in LONG64 Value
    );

LONG
InterlockedIncrement(
    __inout __drv_interlocked LONG volatile *Addend
    );

LONG
InterlockedDecrement(
    __inout __drv_interlocked LONG volatile *Addend
    );

LONG
InterlockedExchange(
    __inout __drv_interlocked LONG volatile *Target,
    __in LONG Value
    );

LONG
InterlockedExchangeAdd(
    __inout __drv_interlocked LONG volatile *Addend,
    __in LONG Value
    );

#if !defined(_X86AMD64_)

__forceinline
LONG
InterlockedAdd(
    __inout __drv_interlocked LONG volatile *Addend,
    __in LONG Value
    )

{
    return InterlockedExchangeAdd(Addend, Value) + Value;
}

#endif

LONG
InterlockedCompareExchange (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG ExChange,
    __in LONG Comperand
    );

LONG64
InterlockedIncrement64(
    __inout __drv_interlocked LONG64 volatile *Addend
    );

LONG64
InterlockedDecrement64(
    __inout __drv_interlocked LONG64 volatile *Addend
    );

LONG64
InterlockedExchange64(
    __inout __drv_interlocked LONG64 volatile *Target,
    __in LONG64 Value
    );

LONG64
InterlockedExchangeAdd64(
    __inout __drv_interlocked LONG64 volatile *Addend,
    __in LONG64 Value
    );

#if !defined(_X86AMD64_)

__forceinline
LONG64
InterlockedAdd64(
    __inout __drv_interlocked LONG64 volatile *Addend,
    __in LONG64 Value
    )

{
    return InterlockedExchangeAdd64(Addend, Value) + Value;
}

#endif

LONG64
InterlockedCompareExchange64 (
    __inout __drv_interlocked LONG64 volatile *Destination,
    __in LONG64 ExChange,
    __in LONG64 Comperand
    );

PVOID
InterlockedCompareExchangePointer (
    __inout __drv_interlocked PVOID volatile *Destination,
    __in_opt PVOID Exchange,
    __in_opt PVOID Comperand
    );

PVOID
InterlockedExchangePointer(
    __inout __drv_interlocked PVOID volatile *Target,
    __in_opt PVOID Value
    );

#pragma intrinsic(_InterlockedIncrement16)
#pragma intrinsic(_InterlockedDecrement16)
#pragma intrinsic(_InterlockedCompareExchange16)
#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedAnd64)
#pragma intrinsic(_InterlockedOr64)
#pragma intrinsic(_InterlockedXor64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)

#if _MSC_FULL_VER >= 140041204

#define InterlockedAnd8 _InterlockedAnd8
#define InterlockedOr8 _InterlockedOr8
#define InterlockedXor8 _InterlockedXor8
#define InterlockedAnd16 _InterlockedAnd16
#define InterlockedOr16 _InterlockedOr16
#define InterlockedXor16 _InterlockedXor16

char
InterlockedAnd8 (
    __inout __drv_interlocked char volatile *Destination,
    __in char Value
    );

char
InterlockedOr8 (
    __inout __drv_interlocked char volatile *Destination,
    __in char Value
    );

char
InterlockedXor8 (
    __inout __drv_interlocked char volatile *Destination,
    __in char Value
    );

SHORT
InterlockedAnd16(
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT Value
    );

SHORT
InterlockedOr16(
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT Value
    );

SHORT
InterlockedXor16(
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT Value
    );

#pragma intrinsic (_InterlockedAnd8)
#pragma intrinsic (_InterlockedOr8)
#pragma intrinsic (_InterlockedXor8)
#pragma intrinsic (_InterlockedAnd16)
#pragma intrinsic (_InterlockedOr16)
#pragma intrinsic (_InterlockedXor16)

#endif

//
// Define function to flush a cache line.
//

#define CacheLineFlush(Address) _mm_clflush(Address)

VOID
_mm_clflush (
    __in VOID const *Address
    );

#pragma intrinsic(_mm_clflush)

VOID
_ReadWriteBarrier (
    VOID
    );

#pragma intrinsic(_ReadWriteBarrier)

//
// Define memory fence intrinsics
//

#define FastFence __faststorefence
#define LoadFence _mm_lfence
#define MemoryFence _mm_mfence
#define StoreFence _mm_sfence

VOID
__faststorefence (
    VOID
    );

VOID
_mm_lfence (
    VOID
    );

VOID
_mm_mfence (
    VOID
    );

VOID
_mm_sfence (
    VOID
    );

VOID
_mm_pause (
    VOID
    );

VOID
_mm_prefetch (
    __in CHAR CONST *a,
    __in int sel
    );

VOID
_m_prefetchw (
    __in volatile CONST VOID *Source
    );

//
// Define constants for use with _mm_prefetch.
//

#define _MM_HINT_T0     1
#define _MM_HINT_T1     2
#define _MM_HINT_T2     3
#define _MM_HINT_NTA    0

#pragma intrinsic(__faststorefence)
#pragma intrinsic(_mm_pause)
#pragma intrinsic(_mm_prefetch)
#pragma intrinsic(_mm_lfence)
#pragma intrinsic(_mm_mfence)
#pragma intrinsic(_mm_sfence)
#pragma intrinsic(_m_prefetchw)

#define YieldProcessor _mm_pause
#define MemoryBarrier __faststorefence
#define PreFetchCacheLine(l, a)  _mm_prefetch((CHAR CONST *) a, l)
#define PrefetchForWrite(p) _m_prefetchw(p)
#define ReadForWriteAccess(p) (_m_prefetchw(p), *(p))

//
// PreFetchCacheLine level defines.
//

#define PF_TEMPORAL_LEVEL_1 _MM_HINT_T0
#define PF_TEMPORAL_LEVEL_2 _MM_HINT_T1
#define PF_TEMPORAL_LEVEL_3 _MM_HINT_T2
#define PF_NON_TEMPORAL_LEVEL_ALL _MM_HINT_NTA

//
// Define get/set MXCSR intrinsics.
//

#define ReadMxCsr _mm_getcsr
#define WriteMxCsr _mm_setcsr

unsigned int
_mm_getcsr (
    VOID
    );

VOID
_mm_setcsr (
    __in unsigned int MxCsr
    );

#pragma intrinsic(_mm_getcsr)
#pragma intrinsic(_mm_setcsr)

//
// Assert exception.
//

VOID
__int2c (
    VOID
    );

#pragma intrinsic(__int2c)

__analysis_noreturn
FORCEINLINE
VOID
DbgRaiseAssertionFailure (
    VOID
    )

{
    __int2c();
}

//
// Define function to get the caller's EFLAGs value.
//

#define GetCallersEflags() __getcallerseflags()

unsigned __int32
__getcallerseflags (
    VOID
    );

#pragma intrinsic(__getcallerseflags)

//
// Define function to get segment limit.
//

#define GetSegmentLimit __segmentlimit

DWORD
__segmentlimit (
    __in DWORD Selector
    );

#pragma intrinsic(__segmentlimit)

//
// Define function to read the value of a performance counter.
//

#define ReadPMC __readpmc

DWORD64
__readpmc (
    __in DWORD Counter
    );

#pragma intrinsic(__readpmc)

//
// Define function to read the value of the time stamp counter
//

#define ReadTimeStampCounter() __rdtsc()

DWORD64
__rdtsc (
    VOID
    );

#pragma intrinsic(__rdtsc)

//
// Define functions to move strings as bytes, words, dwords, and qwords.
//

VOID
__movsb (
    __out_ecount_full(Count) PBYTE  Destination,
    __in_ecount(Count) BYTE  const *Source,
    __in SIZE_T Count
    );

VOID
__movsw (
    __out_ecount_full(Count) PWORD   Destination,
    __in_ecount(Count) WORD   const *Source,
    __in SIZE_T Count
    );

VOID
__movsd (
    __out_ecount_full(Count) PDWORD Destination,
    __in_ecount(Count) DWORD const *Source,
    __in SIZE_T Count
    );

VOID
__movsq (
    __out_ecount_full(Count) PDWORD64 Destination,
    __in_ecount(Count) DWORD64 const *Source,
    __in SIZE_T Count
    );

#pragma intrinsic(__movsb)
#pragma intrinsic(__movsw)
#pragma intrinsic(__movsd)
#pragma intrinsic(__movsq)

//
// Define functions to store strings as bytes, words, dwords, and qwords.
//

VOID
__stosb (
    __out_ecount_full(Count) PBYTE  Destination,
    __in BYTE  Value,
    __in SIZE_T Count
    );

VOID
__stosw (
    __out_ecount_full(Count) PWORD   Destination,
    __in WORD   Value,
    __in SIZE_T Count
    );

VOID
__stosd (
    __out_ecount_full(Count) PDWORD Destination,
    __in DWORD Value,
    __in SIZE_T Count
    );

VOID
__stosq (
    __out_ecount_full(Count) PDWORD64 Destination,
    __in DWORD64 Value,
    __in SIZE_T Count
    );

#pragma intrinsic(__stosb)
#pragma intrinsic(__stosw)
#pragma intrinsic(__stosd)
#pragma intrinsic(__stosq)

//
// Define functions to capture the high 64-bits of a 128-bit multiply.
//

#define MultiplyHigh __mulh
#define UnsignedMultiplyHigh __umulh

LONGLONG
MultiplyHigh (
    __in LONG64 Multiplier,
    __in LONG64 Multiplicand
    );

ULONGLONG
UnsignedMultiplyHigh (
    __in DWORD64 Multiplier,
    __in DWORD64 Multiplicand
    );

#pragma intrinsic(__mulh)
#pragma intrinsic(__umulh)

//
// Define functions to perform 128-bit shifts
//

#define ShiftLeft128 __shiftleft128
#define ShiftRight128 __shiftright128

DWORD64
ShiftLeft128 (
    __in DWORD64 LowPart,
    __in DWORD64 HighPart,
    __in BYTE  Shift
    );

DWORD64
ShiftRight128 (
    __in DWORD64 LowPart,
    __in DWORD64 HighPart,
    __in BYTE  Shift
    );

#pragma intrinsic(__shiftleft128)
#pragma intrinsic(__shiftright128)

//
// Define functions to perform 128-bit multiplies.
//

#define Multiply128 _mul128

LONG64
Multiply128 (
    __in LONG64 Multiplier,
    __in LONG64 Multiplicand,
    __out LONG64 *HighProduct
    );

#pragma intrinsic(_mul128)

#ifndef UnsignedMultiply128

#define UnsignedMultiply128 _umul128

DWORD64
UnsignedMultiply128 (
    __in DWORD64 Multiplier,
    __in DWORD64 Multiplicand,
    __out DWORD64 *HighProduct
    );

#pragma intrinsic(_umul128)

#endif

__forceinline
LONG64
MultiplyExtract128 (
    __in LONG64 Multiplier,
    __in LONG64 Multiplicand,
    __in BYTE  Shift
    )

{

    LONG64 extractedProduct;
    LONG64 highProduct;
    LONG64 lowProduct;
    BOOLEAN negate;
    DWORD64 uhighProduct;
    DWORD64 ulowProduct;

    lowProduct = Multiply128(Multiplier, Multiplicand, &highProduct);
    negate = FALSE;
    uhighProduct = (DWORD64)highProduct;
    ulowProduct = (DWORD64)lowProduct;
    if (highProduct < 0) {
        negate = TRUE;
        uhighProduct = (DWORD64)(-highProduct);
        ulowProduct = (DWORD64)(-lowProduct);
        if (ulowProduct != 0) {
            uhighProduct -= 1;
        }
    }

    extractedProduct = (LONG64)ShiftRight128(ulowProduct, uhighProduct, Shift);
    if (negate != FALSE) {
        extractedProduct = -extractedProduct;
    }

    return extractedProduct;
}

__forceinline
DWORD64
UnsignedMultiplyExtract128 (
    __in DWORD64 Multiplier,
    __in DWORD64 Multiplicand,
    __in BYTE  Shift
    )

{

    DWORD64 extractedProduct;
    DWORD64 highProduct;
    DWORD64 lowProduct;

    lowProduct = UnsignedMultiply128(Multiplier, Multiplicand, &highProduct);
    extractedProduct = ShiftRight128(lowProduct, highProduct, Shift);
    return extractedProduct;
}

//
// Define functions to read and write the uer TEB and the system PCR/PRCB.
//

BYTE 
__readgsbyte (
    __in DWORD Offset
    );

WORD  
__readgsword (
    __in DWORD Offset
    );

DWORD
__readgsdword (
    __in DWORD Offset
    );

DWORD64
__readgsqword (
    __in DWORD Offset
    );

VOID
__writegsbyte (
    __in DWORD Offset,
    __in BYTE  Data
    );

VOID
__writegsword (
    __in DWORD Offset,
    __in WORD   Data
    );

VOID
__writegsdword (
    __in DWORD Offset,
    __in DWORD Data
    );

VOID
__writegsqword (
    __in DWORD Offset,
    __in DWORD64 Data
    );

#pragma intrinsic(__readgsbyte)
#pragma intrinsic(__readgsword)
#pragma intrinsic(__readgsdword)
#pragma intrinsic(__readgsqword)
#pragma intrinsic(__writegsbyte)
#pragma intrinsic(__writegsword)
#pragma intrinsic(__writegsdword)
#pragma intrinsic(__writegsqword)

#if !defined(_MANAGED)

VOID
__incgsbyte (
    __in DWORD Offset
    );

VOID
__addgsbyte (
    __in DWORD Offset,
    __in BYTE  Value
    );

VOID
__incgsword (
    __in DWORD Offset
    );

VOID
__addgsword (
    __in DWORD Offset,
    __in WORD   Value
    );

VOID
__incgsdword (
    __in DWORD Offset
    );

VOID
__addgsdword (
    __in DWORD Offset,
    __in DWORD Value
    );

VOID
__incgsqword (
    __in DWORD Offset
    );

VOID
__addgsqword (
    __in DWORD Offset,
    __in DWORD64 Value
    );

#if 0
#pragma intrinsic(__incgsbyte)
#pragma intrinsic(__addgsbyte)
#pragma intrinsic(__incgsword)
#pragma intrinsic(__addgsword)
#pragma intrinsic(__incgsdword)
#pragma intrinsic(__addgsdword)
#pragma intrinsic(__incgsqword)
#pragma intrinsic(__addgsqword)
#endif

#endif

#ifdef __cplusplus
}
#endif

#endif // defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

//
// The following values specify the type of access in the first parameter
// of the exception record whan the exception code specifies an access
// violation.
//

#define EXCEPTION_READ_FAULT 0          // exception caused by a read
#define EXCEPTION_WRITE_FAULT 1         // exception caused by a write
#define EXCEPTION_EXECUTE_FAULT 8       // exception caused by an instruction fetch

// begin_wx86
//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_AMD64   0x100000

// end_wx86

#define CONTEXT_CONTROL (CONTEXT_AMD64 | 0x1L)
#define CONTEXT_INTEGER (CONTEXT_AMD64 | 0x2L)
#define CONTEXT_SEGMENTS (CONTEXT_AMD64 | 0x4L)
#define CONTEXT_FLOATING_POINT  (CONTEXT_AMD64 | 0x8L)
#define CONTEXT_DEBUG_REGISTERS (CONTEXT_AMD64 | 0x10L)

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_FLOATING_POINT)

#define CONTEXT_ALL (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS)

#define CONTEXT_XSTATE (CONTEXT_AMD64 | 0x20L)

#define CONTEXT_EXCEPTION_ACTIVE 0x8000000
#define CONTEXT_SERVICE_ACTIVE 0x10000000
#define CONTEXT_EXCEPTION_REQUEST 0x40000000
#define CONTEXT_EXCEPTION_REPORTING 0x80000000

// begin_wx86

#endif // !defined(RC_INVOKED)

//
// Define initial MxCsr and FpCsr control.
//

#define INITIAL_MXCSR 0x1f80            // initial MXCSR value
#define INITIAL_FPCSR 0x027f            // initial FPCSR value

// end_ntddk
// begin_wdm begin_ntosp

typedef XSAVE_FORMAT XMM_SAVE_AREA32, *PXMM_SAVE_AREA32;

// end_wdm end_ntosp
// begin_ntddk

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) it is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//
// The flags field within this record controls the contents of a CONTEXT
// record.
//
// If the context record is used as an input parameter, then for each
// portion of the context record controlled by a flag whose value is
// set, it is assumed that that portion of the context record contains
// valid context. If the context record is being used to modify a threads
// context, then only that portion of the threads context is modified.
//
// If the context record is used as an output parameter to capture the
// context of a thread, then only those portions of the thread's context
// corresponding to set flags will be returned.
//
// CONTEXT_CONTROL specifies SegSs, Rsp, SegCs, Rip, and EFlags.
//
// CONTEXT_INTEGER specifies Rax, Rcx, Rdx, Rbx, Rbp, Rsi, Rdi, and R8-R15.
//
// CONTEXT_SEGMENTS specifies SegDs, SegEs, SegFs, and SegGs.
//
// CONTEXT_FLOATING_POINT specifies Xmm0-Xmm15.
//
// CONTEXT_DEBUG_REGISTERS specifies Dr0-Dr3 and Dr6-Dr7.
//

typedef struct DECLSPEC_ALIGN(16) _CONTEXT {

    //
    // Register parameter home addresses.
    //
    // N.B. These fields are for convience - they could be used to extend the
    //      context record in the future.
    //

    DWORD64 P1Home;
    DWORD64 P2Home;
    DWORD64 P3Home;
    DWORD64 P4Home;
    DWORD64 P5Home;
    DWORD64 P6Home;

    //
    // Control flags.
    //

    DWORD ContextFlags;
    DWORD MxCsr;

    //
    // Segment Registers and processor flags.
    //

    WORD   SegCs;
    WORD   SegDs;
    WORD   SegEs;
    WORD   SegFs;
    WORD   SegGs;
    WORD   SegSs;
    DWORD EFlags;

    //
    // Debug registers
    //

    DWORD64 Dr0;
    DWORD64 Dr1;
    DWORD64 Dr2;
    DWORD64 Dr3;
    DWORD64 Dr6;
    DWORD64 Dr7;

    //
    // Integer registers.
    //

    DWORD64 Rax;
    DWORD64 Rcx;
    DWORD64 Rdx;
    DWORD64 Rbx;
    DWORD64 Rsp;
    DWORD64 Rbp;
    DWORD64 Rsi;
    DWORD64 Rdi;
    DWORD64 R8;
    DWORD64 R9;
    DWORD64 R10;
    DWORD64 R11;
    DWORD64 R12;
    DWORD64 R13;
    DWORD64 R14;
    DWORD64 R15;

    //
    // Program counter.
    //

    DWORD64 Rip;

    //
    // Floating point state.
    //

    union {
        XMM_SAVE_AREA32 FltSave;
        struct {
            M128A Header[2];
            M128A Legacy[8];
            M128A Xmm0;
            M128A Xmm1;
            M128A Xmm2;
            M128A Xmm3;
            M128A Xmm4;
            M128A Xmm5;
            M128A Xmm6;
            M128A Xmm7;
            M128A Xmm8;
            M128A Xmm9;
            M128A Xmm10;
            M128A Xmm11;
            M128A Xmm12;
            M128A Xmm13;
            M128A Xmm14;
            M128A Xmm15;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

    //
    // Vector registers.
    //

    M128A VectorRegister[26];
    DWORD64 VectorControl;

    //
    // Special debug control registers.
    //

    DWORD64 DebugControl;
    DWORD64 LastBranchToRip;
    DWORD64 LastBranchFromRip;
    DWORD64 LastExceptionToRip;
    DWORD64 LastExceptionFromRip;
} CONTEXT, *PCONTEXT;

//
// Define function table entry - a function table entry is generated for
// each frame function.
//

#define RUNTIME_FUNCTION_INDIRECT 0x1

typedef struct _RUNTIME_FUNCTION {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD UnwindData;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

//
// Define unwind history table structure.
//

#define UNWIND_HISTORY_TABLE_SIZE 12

typedef struct _UNWIND_HISTORY_TABLE_ENTRY {
    DWORD64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
} UNWIND_HISTORY_TABLE_ENTRY, *PUNWIND_HISTORY_TABLE_ENTRY;

typedef struct _UNWIND_HISTORY_TABLE {
    DWORD Count;
    BYTE  LocalHint;
    BYTE  GlobalHint;
    BYTE  Search;
    BYTE  Once;
    DWORD64 LowAddress;
    DWORD64 HighAddress;
    UNWIND_HISTORY_TABLE_ENTRY Entry[UNWIND_HISTORY_TABLE_SIZE];
} UNWIND_HISTORY_TABLE, *PUNWIND_HISTORY_TABLE;

//
// Define dynamic function table entry.
//

typedef
__drv_functionClass(GET_RUNTIME_FUNCTION_CALLBACK)
PRUNTIME_FUNCTION
GET_RUNTIME_FUNCTION_CALLBACK (
    __in DWORD64 ControlPc,
    __in_opt PVOID Context
    );
typedef GET_RUNTIME_FUNCTION_CALLBACK *PGET_RUNTIME_FUNCTION_CALLBACK;

typedef
__drv_functionClass(OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK)
DWORD   
OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK (
    __in HANDLE Process,
    __in PVOID TableAddress,
    __out PDWORD Entries,
    __out PRUNTIME_FUNCTION* Functions
    );
typedef OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK *POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK;

#define OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME \
    "OutOfProcessFunctionTableCallback"

//
// Define runtime exception handling prototypes.
//

NTSYSAPI
VOID
__cdecl
RtlRestoreContext (
    __in PCONTEXT ContextRecord,
    __in_opt struct _EXCEPTION_RECORD *ExceptionRecord
    );


NTSYSAPI
BOOLEAN
__cdecl
RtlAddFunctionTable (
    __in_ecount(EntryCount) PRUNTIME_FUNCTION FunctionTable,
    __in DWORD EntryCount,
    __in DWORD64 BaseAddress
    );

NTSYSAPI
PRUNTIME_FUNCTION
NTAPI
RtlLookupFunctionEntry (
    __in DWORD64 ControlPc,
    __out PDWORD64 ImageBase,
    __inout_opt PUNWIND_HISTORY_TABLE HistoryTable
    );

//
// Nonvolatile context pointer record.
//

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
    union {
        PM128A FloatingContext[16];
        struct {
            PM128A Xmm0;
            PM128A Xmm1;
            PM128A Xmm2;
            PM128A Xmm3;
            PM128A Xmm4;
            PM128A Xmm5;
            PM128A Xmm6;
            PM128A Xmm7;
            PM128A Xmm8;
            PM128A Xmm9;
            PM128A Xmm10;
            PM128A Xmm11;
            PM128A Xmm12;
            PM128A Xmm13;
            PM128A Xmm14;
            PM128A Xmm15;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

    union {
        PDWORD64 IntegerContext[16];
        struct {
            PDWORD64 Rax;
            PDWORD64 Rcx;
            PDWORD64 Rdx;
            PDWORD64 Rbx;
            PDWORD64 Rsp;
            PDWORD64 Rbp;
            PDWORD64 Rsi;
            PDWORD64 Rdi;
            PDWORD64 R8;
            PDWORD64 R9;
            PDWORD64 R10;
            PDWORD64 R11;
            PDWORD64 R12;
            PDWORD64 R13;
            PDWORD64 R14;
            PDWORD64 R15;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME2;

} KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;

NTSYSAPI
PEXCEPTION_ROUTINE
NTAPI
RtlVirtualUnwind (
    __in DWORD HandlerType,
    __in DWORD64 ImageBase,
    __in DWORD64 ControlPc,
    __in PRUNTIME_FUNCTION FunctionEntry,
    __inout PCONTEXT ContextRecord,
    __out PVOID *HandlerData,
    __out PDWORD64 EstablisherFrame,
    __inout_opt PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
    );

NTSYSAPI
BOOLEAN
__cdecl
RtlInstallFunctionTableCallback (
    __in DWORD64 TableIdentifier,
    __in DWORD64 BaseAddress,
    __in DWORD Length,
    __in PGET_RUNTIME_FUNCTION_CALLBACK Callback,
    __in_opt PVOID Context,
    __in_opt PCWSTR OutOfProcessCallbackDll
    );

NTSYSAPI
BOOLEAN
__cdecl
RtlDeleteFunctionTable (
    __in PRUNTIME_FUNCTION FunctionTable
    );

#endif // _AMD64_


#ifdef _X86_

//
// Disable these two pragmas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif

// end_ntddk end_nthal
#if defined(_M_IX86) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#ifdef __cplusplus
extern "C" {
#endif



#if (_MSC_FULL_VER >= 14000101)


//
// Define bit test intrinsics.
//

#define BitTest _bittest
#define BitTestAndComplement _bittestandcomplement
#define BitTestAndSet _bittestandset
#define BitTestAndReset _bittestandreset
#define InterlockedBitTestAndSet _interlockedbittestandset
#define InterlockedBitTestAndReset _interlockedbittestandreset

__checkReturn
BOOLEAN
_bittest (
    __in_bcount((Offset+7)/8) LONG const *Base,
    __in LONG Offset
    );

BOOLEAN
_bittestandcomplement (
    __inout_bcount((Offset+7)/8) LONG *Base,
    __in LONG Offset
    );

BOOLEAN
_bittestandset (
    __inout_bcount((Offset+7)/8) LONG *Base,
    __in LONG Offset
    );

BOOLEAN
_bittestandreset (
    __inout_bcount((Offset+7)/8) LONG *Base,
    __in LONG Offset
    );

BOOLEAN
_interlockedbittestandset (
    __inout_bcount((Offset+7)/8) __drv_interlocked LONG volatile *Base,
    __in LONG Offset
    );

BOOLEAN
_interlockedbittestandreset (
    __inout_bcount((Offset+7)/8) __drv_interlocked LONG volatile *Base,
    __in LONG Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)
#pragma intrinsic(_interlockedbittestandset)
#pragma intrinsic(_interlockedbittestandreset)

//
// Define bit scan intrinsics.
//

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse

__success(return != 0)
BOOLEAN
_BitScanForward (
    __out DWORD *Index,
    __in DWORD Mask
    );

__success(return != 0)
BOOLEAN
_BitScanReverse (
    __out DWORD *Index,
    __in DWORD Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)

#else

#pragma warning(push)
#pragma warning(disable:4035 4793)

FORCEINLINE
BOOLEAN
InterlockedBitTestAndSet (
    __inout_bcount((Bit+7)/8) __drv_interlocked LONG volatile *Base,
    __in LONG Bit
    )
{
    __asm {
           mov eax, Bit
           mov ecx, Base
           lock bts [ecx], eax
           setc al
    };
}

FORCEINLINE
BOOLEAN
InterlockedBitTestAndReset (
    __inout_bcount((Bit+7)/8) __drv_interlocked LONG volatile *Base,
    __in LONG Bit
    )
{
    __asm {
           mov eax, Bit
           mov ecx, Base
           lock btr [ecx], eax
           setc al
    };
}
#pragma warning(pop)

#endif	/* _MSC_FULL_VER >= 14000101 */

//
// [pfx_parse] - guard against PREfix intrinsic error
//
#if (_MSC_FULL_VER >= 140040816) || (defined(_PREFAST_) && (_MSC_VER >= 1400))

#define InterlockedAnd16 _InterlockedAnd16
#define InterlockedCompareExchange16 _InterlockedCompareExchange16
#define InterlockedOr16 _InterlockedOr16

SHORT
_InterlockedAnd16 (
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT Value
    );

SHORT
_InterlockedCompareExchange16 (
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT ExChange,
    __in SHORT Comperand
    );

SHORT
_InterlockedOr16 (
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT Value
    );

#pragma intrinsic(_InterlockedAnd16)
#pragma intrinsic(_InterlockedCompareExchange16)
#pragma intrinsic(_InterlockedOr16)

#endif  /* _MSC_FULL_VER >= 140040816 */

#if !defined(_M_CEE_PURE)
#pragma warning(push)
#pragma warning(disable:4035 4793)

FORCEINLINE
BOOLEAN
InterlockedBitTestAndComplement (
    __inout_bcount((Bit+7)/8) __drv_interlocked LONG volatile *Base,
    __in LONG Bit
    )
{
    __asm {
           mov eax, Bit
           mov ecx, Base
           lock btc [ecx], eax
           setc al
    };
}
#pragma warning(pop)
#endif	/* _M_CEE_PURE */

//
// [pfx_parse]
// guard against __readfsbyte parsing error
//
#if (_MSC_FULL_VER >= 13012035) || defined(_PREFIX_) || defined(_PREFAST_)

//
// Define FS referencing intrinsics
//

BYTE 
__readfsbyte (
    __in DWORD Offset
    );

WORD  
__readfsword (
    __in DWORD Offset
    );

DWORD
__readfsdword (
    __in DWORD Offset
    );

VOID
__writefsbyte (
    __in DWORD Offset,
    __in BYTE  Data
    );

VOID
__writefsword (
    __in DWORD Offset,
    __in WORD   Data
    );

VOID
__writefsdword (
    __in DWORD Offset,
    __in DWORD Data
    );

#pragma intrinsic(__readfsbyte)
#pragma intrinsic(__readfsword)
#pragma intrinsic(__readfsdword)
#pragma intrinsic(__writefsbyte)
#pragma intrinsic(__writefsword)
#pragma intrinsic(__writefsdword)

#endif	/* _MSC_FULL_VER >= 13012035 */

#if (_MSC_FULL_VER >= 140050727) || defined(_PREFIX_) || defined(_PREFAST_)

#if !defined(_MANAGED)

VOID
__incfsbyte (
    __in DWORD Offset
    );

VOID
__addfsbyte (
    __in DWORD Offset,
    __in BYTE  Value
    );

VOID
__incfsword (
    __in DWORD Offset
    );

VOID
__addfsword (
    __in DWORD Offset,
    __in WORD   Value
    );

VOID
__incfsdword (
    __in DWORD Offset
    );

VOID
__addfsdword (
    __in DWORD Offset,
    __in DWORD Value
    );

#pragma intrinsic(__incfsbyte)
#pragma intrinsic(__addfsbyte)
#pragma intrinsic(__incfsword)
#pragma intrinsic(__addfsword)
#pragma intrinsic(__incfsdword)
#pragma intrinsic(__addfsdword)

#endif

#endif	/* _MSC_FULL_VER >= 140050727 */

#if (_MSC_FULL_VER >= 140041204) || defined(_PREFIX_) || defined(_PREFAST_)

VOID
_mm_pause (
    VOID
    );

#pragma intrinsic(_mm_pause)

#define YieldProcessor _mm_pause

#else

#if !defined(_M_CEE_PURE)
#define YieldProcessor() __asm { rep nop }
#endif  // !defined(_M_CEE_PURE)

#endif  // (_MSC_FULL_VER >= 140041204)

#ifdef __cplusplus
}
#endif

#endif  /* !defined(MIDL_PASS) || defined(_M_IX86) */

#if !defined(MIDL_PASS) && defined(_M_IX86)

#if !defined(_M_CEE_PURE)

#pragma warning( push )
#pragma warning( disable : 4793 )
FORCEINLINE
VOID
MemoryBarrier (
    VOID
    )
{
    LONG Barrier;
    __asm {
        xchg Barrier, eax
    }
}
#pragma warning( pop )

#endif /* _M_CEE_PURE */
//
// Prefetch is not supported on all x86 procssors.
//

#define PreFetchCacheLine(l, a)
#define PrefetchForWrite(p)
#define ReadForWriteAccess(p) (*(p))

//
// PreFetchCacheLine level defines.
//

#define PF_TEMPORAL_LEVEL_1
#define PF_NON_TEMPORAL_LEVEL_ALL

//
// Define function to read the value of a performance counter.
//

#if _MSC_FULL_VER >= 140050727

#define ReadPMC __readpmc

DWORD64
__readpmc (
    __in DWORD Counter
    );

#pragma intrinsic(__readpmc)

#else

FORCEINLINE
DWORD64
ReadPMC (
    __in DWORD Counter
    )

{
    __asm {
        mov ecx, Counter
        rdpmc
    };
}

#endif

//
// Define function to read the value of the time stamp counter
//

#if _MSC_FULL_VER >= 140040310

#define ReadTimeStampCounter() __rdtsc()

DWORD64
__rdtsc (
    VOID
    );

#pragma intrinsic(__rdtsc)

#else

FORCEINLINE
DWORD64
ReadTimeStampCounter (
    VOID
    )

{
    __asm rdtsc
}

#endif

// end_ntddk
// begin_wdm

#if defined(_X86_) && defined(_M_IX86) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#if _MSC_FULL_VER >= 140030222

VOID
__int2c (
    VOID
    );

#pragma intrinsic(__int2c)

__analysis_noreturn
FORCEINLINE
VOID
DbgRaiseAssertionFailure (
    VOID
    )

{
    __int2c();
}

#else
#pragma warning( push )
#pragma warning( disable : 4793 )

__analysis_noreturn
FORCEINLINE
VOID
DbgRaiseAssertionFailure (
    VOID
    )

{
    __asm int 0x2c
}

#pragma warning( pop )

#endif

#endif

// end_wdm

#if (_MSC_FULL_VER >= 13012035)

__inline PVOID GetFiberData( void )    { return *(PVOID *) (ULONG_PTR) __readfsdword (0x10);}
__inline PVOID GetCurrentFiber( void ) { return (PVOID) (ULONG_PTR) __readfsdword (0x10);}

#else
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning (disable:4035 4793)        // disable 4035 (function must return something)
__inline PVOID GetFiberData( void ) { __asm {
                                        mov eax, fs:[0x10]
                                        mov eax,[eax]
                                        }
                                     }
__inline PVOID GetCurrentFiber( void ) { __asm mov eax, fs:[0x10] }

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning (default:4035 4793)        // Reenable it
#endif
#endif // (_MSC_FULL_VER >= 13012035)

// begin_ntddk
#endif // !defined(MIDL_PASS) && defined(_M_IX86)
// end_ntddk

//
// The following values specify the type of failing access when the status is
// STATUS_ACCESS_VIOLATION and the first parameter in the execpetion record.
//

#define EXCEPTION_READ_FAULT          0 // Access violation was caused by a read
#define EXCEPTION_WRITE_FAULT         1 // Access violation was caused by a write
#define EXCEPTION_EXECUTE_FAULT       8 // Access violation was caused by an instruction fetch

// begin_wx86
// begin_ntddk

//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_i386    0x00010000    // this assumes that i386 and
#define CONTEXT_i486    0x00010000    // i486 have identical context records

// end_wx86

#define CONTEXT_CONTROL         (CONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define CONTEXT_INTEGER         (CONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define CONTEXT_SEGMENTS        (CONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define CONTEXT_FLOATING_POINT  (CONTEXT_i386 | 0x00000008L) // 387 state
#define CONTEXT_DEBUG_REGISTERS (CONTEXT_i386 | 0x00000010L) // DB 0-3,6,7
#define CONTEXT_EXTENDED_REGISTERS  (CONTEXT_i386 | 0x00000020L) // cpu specific extensions

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_INTEGER |\
                      CONTEXT_SEGMENTS)

#define CONTEXT_ALL             (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | \
                                 CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS | \
                                 CONTEXT_EXTENDED_REGISTERS)

#define CONTEXT_XSTATE          (CONTEXT_i386 | 0x00000040L)

// begin_wx86

#endif // !defined(RC_INVOKED)

typedef struct _FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[SIZE_OF_80387_REGISTERS];
    DWORD   Cr0NpxState;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;


// end_ntddk
// begin_wdm begin_ntosp

#define MAXIMUM_SUPPORTED_EXTENSION     512

#if !defined(__midl) && !defined(MIDL_PASS)

C_ASSERT(sizeof(XSAVE_FORMAT) == MAXIMUM_SUPPORTED_EXTENSION);

#endif

// end_wdm end_ntosp
// begin_ntddk

#include "pshpack4.h"

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED
    DWORD   EFlags;             // MUST BE SANITIZED
    DWORD   Esp;
    DWORD   SegSs;

    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //

    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];

} CONTEXT;

typedef CONTEXT *PCONTEXT;

#include "poppack.h"

// begin_ntminiport
#endif //_X86_


#ifndef _LDT_ENTRY_DEFINED
#define _LDT_ENTRY_DEFINED

typedef struct _LDT_ENTRY {
    WORD    LimitLow;
    WORD    BaseLow;
    union {
        struct {
            BYTE    BaseMid;
            BYTE    Flags1;     // Declare as bytes to avoid alignment
            BYTE    Flags2;     // Problems.
            BYTE    BaseHi;
        } Bytes;
        struct {
            DWORD   BaseMid : 8;
            DWORD   Type : 5;
            DWORD   Dpl : 2;
            DWORD   Pres : 1;
            DWORD   LimitHi : 4;
            DWORD   Sys : 1;
            DWORD   Reserved_0 : 1;
            DWORD   Default_Big : 1;
            DWORD   Granularity : 1;
            DWORD   BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;

#endif


#if defined(_M_IA64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#ifdef __cplusplus
extern "C" {
#endif

//
// Define bit test intrinsics.
//

#define BitTest _bittest
#define BitTestAndComplement _bittestandcomplement
#define BitTestAndSet _bittestandset
#define BitTestAndReset _bittestandreset

#define BitTest64 _bittest64
#define BitTestAndComplement64 _bittestandcomplement64
#define BitTestAndSet64 _bittestandset64
#define BitTestAndReset64 _bittestandreset64

__checkReturn
BOOLEAN
_bittest (
    __in_bcount((Offset+7)/8) LONG const *Base,
    __in LONG Offset
    );

BOOLEAN
_bittestandcomplement (
    __inout_bcount((Offset+7)/8) LONG *Base,
    __in LONG Offset
    );

BOOLEAN
_bittestandset (
    __inout_bcount((Offset+7)/8) LONG *Base,
    __in LONG Offset
    );

BOOLEAN
_bittestandreset (
    __inout_bcount((Offset+7)/8) LONG *Base,
    __in LONG Offset
    );

__checkReturn
BOOLEAN
_bittest64 (
    __in_bcount((Offset+7)/8) LONG64 const *Base,
    __in LONG64 Offset
    );

BOOLEAN
_bittestandcomplement64 (
    __inout_bcount((Offset+7)/8) LONG64 *Base,
    __in LONG64 Offset
    );

BOOLEAN
_bittestandset64 (
    __inout_bcount((Offset+7)/8) LONG64 *Base,
    __in LONG64 Offset
    );

BOOLEAN
_bittestandreset64 (
    __inout_bcount((Offset+7)/8) LONG64 *Base,
    __in LONG64 Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)

#pragma intrinsic(_bittest64)
#pragma intrinsic(_bittestandcomplement64)
#pragma intrinsic(_bittestandset64)
#pragma intrinsic(_bittestandreset64)

//
// Define bit scan intrinsics.
//

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse
#define BitScanForward64 _BitScanForward64
#define BitScanReverse64 _BitScanReverse64

__success(return!=0)
BOOLEAN
_BitScanForward (
    __out DWORD *Index,
    __in DWORD Mask
    );

__success(return!=0)
BOOLEAN
_BitScanReverse (
    __out DWORD *Index,
    __in DWORD Mask
    );

__success(return!=0)
BOOLEAN
_BitScanForward64 (
    __out DWORD *Index,
    __in DWORD64 Mask
    );

__success(return!=0)
BOOLEAN
_BitScanReverse64 (
    __out DWORD *Index,
    __in DWORD64 Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#pragma intrinsic(_BitScanForward64)
#pragma intrinsic(_BitScanReverse64)

#define InterlockedCompareExchange16 _InterlockedCompareExchange16

SHORT
_InterlockedCompareExchange16 (
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT ExChange,
    __in SHORT Comperand
    );

#pragma intrinsic(_InterlockedCompareExchange16)

#ifdef __cplusplus
}
#endif

#define InterlockedAdd                  _InterlockedAdd
#define InterlockedAddAcquire           _InterlockedAdd_acq
#define InterlockedAddRelease           _InterlockedAdd_rel

#define InterlockedIncrement            _InterlockedIncrement
#define InterlockedIncrementAcquire     _InterlockedIncrement_acq
#define InterlockedIncrementRelease     _InterlockedIncrement_rel

#define InterlockedDecrement            _InterlockedDecrement
#define InterlockedDecrementAcquire     _InterlockedDecrement_acq
#define InterlockedDecrementRelease     _InterlockedDecrement_rel

#define InterlockedExchange             _InterlockedExchange
#define InterlockedExchangeAcquire      _InterlockedExchange_acq

#define InterlockedExchangeAdd          _InterlockedExchangeAdd
#define InterlockedExchangeAddAcquire   _InterlockedExchangeAdd_acq
#define InterlockedExchangeAddRelease   _InterlockedExchangeAdd_rel

#define InterlockedAdd64                _InterlockedAdd64
#define InterlockedAddAcquire64         _InterlockedAdd64_acq
#define InterlockedAddRelease64         _InterlockedAdd64_rel

#define InterlockedIncrement64          _InterlockedIncrement64
#define InterlockedIncrementAcquire64   _InterlockedIncrement64_acq
#define InterlockedIncrementRelease64   _InterlockedIncrement64_rel

#define InterlockedDecrement64          _InterlockedDecrement64
#define InterlockedDecrementAcquire64   _InterlockedDecrement64_acq
#define InterlockedDecrementRelease64   _InterlockedDecrement64_rel

#define InterlockedExchange64           _InterlockedExchange64
#define InterlockedExchangeAcquire64    _InterlockedExchange64_acq

#define InterlockedExchangeAdd64        _InterlockedExchangeAdd64
#define InterlockedExchangeAddAcquire64 _InterlockedExchangeAdd64_acq
#define InterlockedExchangeAddRelease64 _InterlockedExchangeAdd64_rel

#define InterlockedCompareExchange64        _InterlockedCompareExchange64
#define InterlockedCompareExchangeAcquire64 _InterlockedCompareExchange64_acq
#define InterlockedCompareExchangeRelease64 _InterlockedCompareExchange64_rel

#define InterlockedCompare64Exchange128         _InterlockedCompare64Exchange128
#define InterlockedCompare64ExchangeAcquire128  _InterlockedCompare64Exchange128_acq
#define InterlockedCompare64ExchangeRelease128  _InterlockedCompare64Exchange128_rel

#define InterlockedCompareExchange          _InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire   _InterlockedCompareExchange_acq
#define InterlockedCompareExchangeRelease   _InterlockedCompareExchange_rel

#define InterlockedExchangePointer          _InterlockedExchangePointer
#define InterlockedExchangePointerAcquire   _InterlockedExchangePointer_acq

#define InterlockedCompareExchangePointer           _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerRelease    _InterlockedCompareExchangePointer_rel
#define InterlockedCompareExchangePointerAcquire    _InterlockedCompareExchangePointer_acq


#define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd64((LONG64 *)a, b)
#define InterlockedIncrementSizeT(a) InterlockedIncrement64((LONG64 *)a)
#define InterlockedDecrementSizeT(a) InterlockedDecrement64((LONG64 *)a)

#define InterlockedOr       _InterlockedOr
#define InterlockedOrAcquire   _InterlockedOr_acq
#define InterlockedOrRelease   _InterlockedOr_rel
#define InterlockedOr8      _InterlockedOr8
#define InterlockedOr8Acquire  _InterlockedOr8_acq
#define InterlockedOr8Release  _InterlockedOr8_rel
#define InterlockedOr16     _InterlockedOr16
#define InterlockedOr16Acquire _InterlockedOr16_acq
#define InterlockedOr16Release _InterlockedOr16_rel
#define InterlockedOr64     _InterlockedOr64
#define InterlockedOr64Acquire _InterlockedOr64_acq
#define InterlockedOr64Release _InterlockedOr64_rel
#define InterlockedXor      _InterlockedXor
#define InterlockedXorAcquire  _InterlockedXor_acq
#define InterlockedXorRelease  _InterlockedXor_rel
#define InterlockedXor8     _InterlockedXor8
#define InterlockedXor8Acquire _InterlockedXor8_acq
#define InterlockedXor8Release _InterlockedXor8_rel
#define InterlockedXor16    _InterlockedXor16
#define InterlockedXor16Acquire _InterlockedXor16_acq
#define InterlockedXor16Release _InterlockedXor16_rel
#define InterlockedXor64     _InterlockedXor64
#define InterlockedXor64Acquire _InterlockedXor64_acq
#define InterlockedXor64Release _InterlockedXor64_rel
#define InterlockedAnd       _InterlockedAnd
#define InterlockedAndAcquire   _InterlockedAnd_acq
#define InterlockedAndRelease   _InterlockedAnd_rel
#define InterlockedAnd8      _InterlockedAnd8
#define InterlockedAnd8Acquire  _InterlockedAnd8_acq
#define InterlockedAnd8Release  _InterlockedAnd8_rel
#define InterlockedAnd16     _InterlockedAnd16
#define InterlockedAnd16Acquire _InterlockedAnd16_acq
#define InterlockedAnd16Release _InterlockedAnd16_rel
#define InterlockedAnd64     _InterlockedAnd64
#define InterlockedAnd64Acquire _InterlockedAnd64_acq
#define InterlockedAnd64Release _InterlockedAnd64_rel

#ifdef __cplusplus
extern "C" {
#endif

LONG
__cdecl
InterlockedAdd (
    __inout __drv_interlocked LONG volatile *Addend,
    __in LONG Value
    );

LONG
__cdecl
InterlockedAddAcquire (
    __inout __drv_interlocked LONG volatile *Addend,
    __in LONG Value
    );

LONG
__cdecl
InterlockedAddRelease (
    __inout __drv_interlocked LONG volatile *Addend,
    __in LONG Value
    );

LONGLONG
__cdecl
InterlockedAdd64 (
    __inout __drv_interlocked LONGLONG volatile *Addend,
    __in LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedAddAcquire64 (
    __inout __drv_interlocked LONGLONG volatile *Addend,
    __in LONGLONG Value
    );


LONGLONG
__cdecl
InterlockedAddRelease64 (
    __inout __drv_interlocked LONGLONG volatile *Addend,
    __in LONGLONG Value
    );

LONG
__cdecl
InterlockedIncrement(
    __inout __drv_interlocked LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrement(
    __inout __drv_interlocked LONG volatile *Addend
    );

LONG
__cdecl
InterlockedIncrementAcquire(
    __inout __drv_interlocked LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrementAcquire(
    __inout __drv_interlocked LONG volatile *Addend
    );

LONG
__cdecl
InterlockedIncrementRelease(
    __inout __drv_interlocked LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrementRelease(
    __inout __drv_interlocked LONG volatile *Addend
    );

LONG
__cdecl
InterlockedExchange(
    __inout __drv_interlocked LONG volatile *Target,
    __in LONG Value
    );

LONG
__cdecl
InterlockedExchangeAcquire(
    __inout __drv_interlocked LONG volatile *Target,
    __in LONG Value
    );

LONG
__cdecl
InterlockedExchangeAdd(
    __inout __drv_interlocked LONG volatile *Addend,
    __in LONG Value
    );

LONG
__cdecl
InterlockedExchangeAddAcquire(
    __inout __drv_interlocked LONG volatile *Addend,
    __in LONG Value
    );

LONG
__cdecl
InterlockedExchangeAddRelease(
    __inout __drv_interlocked LONG volatile *Addend,
    __in LONG Value
    );

LONG
__cdecl
InterlockedCompareExchange (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG ExChange,
    __in LONG Comperand
    );


LONG
__cdecl
InterlockedCompareExchangeRelease (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG ExChange,
    __in LONG Comperand
    );


LONG
__cdecl
InterlockedCompareExchangeAcquire (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG ExChange,
    __in LONG Comperand
    );


LONGLONG
__cdecl
InterlockedIncrement64(
    __inout __drv_interlocked LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedIncrementAcquire64(
    __inout __drv_interlocked LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedIncrementRelease64(
    __inout __drv_interlocked LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrement64(
    __inout __drv_interlocked LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrementAcquire64(
    __inout __drv_interlocked LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrementRelease64(
    __inout __drv_interlocked LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedExchange64(
    __inout __drv_interlocked LONGLONG volatile *Target,
    __in LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAcquire64(
    __inout __drv_interlocked LONGLONG volatile *Target,
    __in LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAdd64(
    __inout __drv_interlocked LONGLONG volatile *Addend,
    __in LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAddAcquire64(
    __inout __drv_interlocked LONGLONG volatile *Addend,
    __in LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAddRelease64(
    __inout __drv_interlocked LONGLONG volatile *Addend,
    __in LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedCompareExchange64 (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG ExChange,
    __in LONGLONG Comperand
    );

LONGLONG
__cdecl
InterlockedCompareExchangeAcquire64 (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG ExChange,
    __in LONGLONG Comperand
    );

LONGLONG
__cdecl
InterlockedCompareExchangeRelease64 (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG ExChange,
    __in LONGLONG Comperand
    );

LONG64
__cdecl
InterlockedCompare64Exchange128(
    __inout_bcount(16) __drv_interlocked LONG64 volatile *Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

LONG64
__cdecl
InterlockedCompare64ExchangeAcquire128(
    __inout_bcount(16) __drv_interlocked LONG64 volatile *Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

LONG64
__cdecl
InterlockedCompare64ExchangeRelease128(
    __inout_bcount(16) __drv_interlocked LONG64 volatile *Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointer (
    __inout __drv_interlocked PVOID volatile *Destination,
    __in PVOID Exchange,
    __in PVOID Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointerAcquire (
    __inout __drv_interlocked PVOID volatile *Destination,
    __in PVOID Exchange,
    __in PVOID Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointerRelease (
    __inout __drv_interlocked PVOID volatile *Destination,
    __in PVOID Exchange,
    __in PVOID Comperand
    );

PVOID
__cdecl
InterlockedExchangePointer(
    __inout __drv_interlocked PVOID volatile *Target,
    __in PVOID Value
    );

PVOID
__cdecl
InterlockedExchangePointerAcquire(
    __inout __drv_interlocked PVOID volatile *Target,
    __in PVOID Value
    );

LONG
__cdecl
InterlockedOr (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG Value
    );

LONG
__cdecl
InterlockedOrAcquire (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG Value
    );

LONG
__cdecl
InterlockedOrRelease (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG Value
    );

CHAR
__cdecl
InterlockedOr8 (
    __inout __drv_interlocked CHAR volatile *Destination,
    __in CHAR Value
    );

CHAR
__cdecl
InterlockedOr8Acquire (
    __inout __drv_interlocked CHAR volatile *Destination,
    __in CHAR Value
    );

CHAR
__cdecl
InterlockedOr8Release (
    __inout __drv_interlocked CHAR volatile *Destination,
    __in CHAR Value
    );

SHORT
__cdecl
InterlockedOr16(
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT Value
    );

SHORT
__cdecl
InterlockedOr16Acquire (
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT Value
    );

SHORT
__cdecl
InterlockedOr16Release (
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT Value
    );

LONGLONG
__cdecl
InterlockedOr64 (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedOr64Acquire (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedOr64Release (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG Value
    );

LONG
__cdecl
InterlockedXor (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG Value
    );

LONG
__cdecl
InterlockedXorAcquire (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG Value
    );

LONG
__cdecl
InterlockedXorRelease (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG Value
    );

CHAR
__cdecl
InterlockedXor8 (
    __inout __drv_interlocked CHAR volatile *Destination,
    __in CHAR Value
    );

CHAR
__cdecl
InterlockedXor8Acquire (
    __inout __drv_interlocked CHAR volatile *Destination,
    __in CHAR Value
    );

CHAR
__cdecl
InterlockedXor8Release (
    __inout __drv_interlocked CHAR volatile *Destination,
    __in CHAR Value
    );

SHORT
__cdecl
InterlockedXor16(
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT Value
    );

SHORT
__cdecl
InterlockedXor16Acquire (
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT Value
    );

SHORT
__cdecl
InterlockedXor16Release (
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT Value
    );

LONGLONG
__cdecl
InterlockedXor64 (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedXor64Acquire (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedXor64Release (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG Value
    );

LONG
__cdecl
InterlockedAnd (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG Value
    );

LONG
__cdecl
InterlockedAndAcquire (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG Value
    );

LONG
__cdecl
InterlockedAndRelease (
    __inout __drv_interlocked LONG volatile *Destination,
    __in LONG Value
    );

CHAR
__cdecl
InterlockedAnd8 (
    __inout __drv_interlocked CHAR volatile *Destination,
    __in CHAR Value
    );

CHAR
__cdecl
InterlockedAnd8Acquire (
    __inout __drv_interlocked CHAR volatile *Destination,
    __in CHAR Value
    );

CHAR
__cdecl
InterlockedAnd8Release (
    __inout __drv_interlocked CHAR volatile *Destination,
    __in CHAR Value
    );

SHORT
__cdecl
InterlockedAnd16(
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT Value
    );

SHORT
__cdecl
InterlockedAnd16Acquire (
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT Value
    );

SHORT
__cdecl
InterlockedAnd16Release (
    __inout __drv_interlocked SHORT volatile *Destination,
    __in SHORT Value
    );

LONGLONG
__cdecl
InterlockedAnd64 (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedAnd64Acquire (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedAnd64Release (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG Value
    );

#pragma intrinsic(_InterlockedAdd)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedIncrement_acq)
#pragma intrinsic(_InterlockedIncrement_rel)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedDecrement_acq)
#pragma intrinsic(_InterlockedDecrement_rel)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedCompareExchange_acq)
#pragma intrinsic(_InterlockedCompareExchange_rel)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedAdd64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchange64_acq)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedCompareExchange64_acq)
#pragma intrinsic(_InterlockedCompareExchange64_rel)
#pragma intrinsic(_InterlockedCompare64Exchange128)
#pragma intrinsic(_InterlockedCompare64Exchange128_acq)
#pragma intrinsic(_InterlockedCompare64Exchange128_rel)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer_acq)
#pragma intrinsic(_InterlockedCompareExchangePointer_rel)
#pragma intrinsic(_InterlockedAdd_acq)
#pragma intrinsic(_InterlockedAdd_rel)
#pragma intrinsic(_InterlockedExchange_acq)
#pragma intrinsic(_InterlockedExchangeAdd_acq)
#pragma intrinsic(_InterlockedExchangeAdd_rel)
#pragma intrinsic(_InterlockedAdd64_acq)
#pragma intrinsic(_InterlockedAdd64_rel)
#pragma intrinsic(_InterlockedIncrement64_acq)
#pragma intrinsic(_InterlockedIncrement64_rel)
#pragma intrinsic(_InterlockedDecrement64_acq)
#pragma intrinsic(_InterlockedDecrement64_rel)
#pragma intrinsic(_InterlockedExchangeAdd64_acq)
#pragma intrinsic(_InterlockedExchangeAdd64_rel)
#pragma intrinsic(_InterlockedExchangePointer_acq)
#pragma intrinsic (_InterlockedOr)
#pragma intrinsic (_InterlockedOr_acq)
#pragma intrinsic (_InterlockedOr_rel)
#pragma intrinsic (_InterlockedOr8)
#pragma intrinsic (_InterlockedOr8_acq)
#pragma intrinsic (_InterlockedOr8_rel)
#pragma intrinsic (_InterlockedOr16)
#pragma intrinsic (_InterlockedOr16_acq)
#pragma intrinsic (_InterlockedOr16_rel)
#pragma intrinsic (_InterlockedOr64)
#pragma intrinsic (_InterlockedOr64_acq)
#pragma intrinsic (_InterlockedOr64_rel)
#pragma intrinsic (_InterlockedXor)
#pragma intrinsic (_InterlockedXor_acq)
#pragma intrinsic (_InterlockedXor_rel)
#pragma intrinsic (_InterlockedXor8)
#pragma intrinsic (_InterlockedXor8_acq)
#pragma intrinsic (_InterlockedXor8_rel)
#pragma intrinsic (_InterlockedXor16)
#pragma intrinsic (_InterlockedXor16_acq)
#pragma intrinsic (_InterlockedXor16_rel)
#pragma intrinsic (_InterlockedXor64)
#pragma intrinsic (_InterlockedXor64_acq)
#pragma intrinsic (_InterlockedXor64_rel)
#pragma intrinsic (_InterlockedAnd)
#pragma intrinsic (_InterlockedAnd_acq)
#pragma intrinsic (_InterlockedAnd_rel)
#pragma intrinsic (_InterlockedAnd8)
#pragma intrinsic (_InterlockedAnd8_acq)
#pragma intrinsic (_InterlockedAnd8_rel)
#pragma intrinsic (_InterlockedAnd16)
#pragma intrinsic (_InterlockedAnd16_acq)
#pragma intrinsic (_InterlockedAnd16_rel)
#pragma intrinsic (_InterlockedAnd64)
#pragma intrinsic (_InterlockedAnd64_acq)
#pragma intrinsic (_InterlockedAnd64_rel)

#if !defined (InterlockedAnd64)

#define InterlockedAnd64 InterlockedAnd64_Inline

LONGLONG
FORCEINLINE
InterlockedAnd64_Inline (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old & Value,
                                          Old) != Old);

    return Old;
}

#endif

#define InterlockedAndAffinity InterlockedAnd64

#if !defined (InterlockedOr64)

#define InterlockedOr64 InterlockedOr64_Inline

LONGLONG
FORCEINLINE
InterlockedOr64_Inline (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old | Value,
                                          Old) != Old);

    return Old;
}

#endif

#define InterlockedOrAffinity InterlockedOr64

#if !defined (InterlockedXor64)

#define InterlockedXor64 InterlockedXor64_Inline

LONGLONG
FORCEINLINE
InterlockedXor64_Inline (
    __inout __drv_interlocked LONGLONG volatile *Destination,
    __in LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old ^ Value,
                                          Old) != Old);

    return Old;
}

#endif

#if !defined (InterlockedBitTestAndSet)

#define InterlockedBitTestAndSet InterlockedBitTestAndSet_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndSet_Inline (
    __inout __drv_interlocked LONG volatile *Base,
    __in LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedOr (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndReset)

#define InterlockedBitTestAndReset InterlockedBitTestAndReset_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndReset_Inline (
    __inout __drv_interlocked LONG volatile *Base,
    __in LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedAnd (&Base[Bit/(sizeof (*Base)*8)], ~tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndSet64)

#define InterlockedBitTestAndSet64 InterlockedBitTestAndSet64_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndSet64_Inline (
    __inout __drv_interlocked LONG64 volatile *Base,
    __in LONG64 Bit
    )
{
    LONG64 tBit;

    tBit = 1i64<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedOr64 (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndReset64)

#define InterlockedBitTestAndReset64 InterlockedBitTestAndReset64_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndReset64_Inline (
    __inout __drv_interlocked LONG64 volatile *Base,
    __in LONG64 Bit
    )
{
    LONG64 tBit;

    tBit = 1i64<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedAnd64 (&Base[Bit/(sizeof (*Base)*8)], ~tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndComplement)

#define InterlockedBitTestAndComplement InterlockedBitTestAndComplement_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndComplement_Inline (
    __inout __drv_interlocked LONG volatile *Base,
    __in LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedXor (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndComplement64)

#define InterlockedBitTestAndComplement64 InterlockedBitTestAndComplement64_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndComplement64_Inline (
    __inout __drv_interlocked LONG64 volatile *Base,
    __in LONG64 Bit
    )
{
    LONG64 tBit;

    tBit = 1i64<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedXor64 (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#ifdef __cplusplus
}
#endif

#endif /* defined(_M_IA64) && !defined(RC_INVOKED) && !defined(MIDL_PASS) */


#if !defined(__midl) && !defined(GENUTIL) && !defined(_GENIA64_) && defined(_IA64_)

void * __cdecl _rdteb(void);
void * __cdecl _rdtebex(void);
#ifdef _M_IA64

#pragma intrinsic(_rdteb)
// _rdtebex() is a kernel safe version of _rdteb()
#pragma intrinsic(_rdtebex)
#define NtCurrentTeb() ((struct _TEB *)_rdtebex())

//
// Define functions to get the address of the current fiber and the
// current fiber data.
//

#define GetCurrentFiber() (((PNT_TIB)NtCurrentTeb())->FiberData)
#define GetFiberData() (*(PVOID *)(GetCurrentFiber()))


// begin_ntddk

#ifdef __cplusplus
extern "C" {
#endif

// end_ntddk
// begin_wdm

#if defined(_IA64_) && defined(_M_IA64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

void
__break(
    __in int StIIM
    );

#pragma intrinsic (__break)

#define BREAK_DEBUG_BASE    0x080000
#define ASSERT_BREAKPOINT         (BREAK_DEBUG_BASE+3)  // Cause a STATUS_ASSERTION_FAILURE exception to be raised.

__analysis_noreturn
FORCEINLINE
VOID
DbgRaiseAssertionFailure (
    VOID
    )

{
    __break(ASSERT_BREAKPOINT);
}

#endif

// end_wdm
// begin_ntddk

void
__yield(
   void
   );

void
__mf(
    void
    );

void
__lfetch(
    int Level,
    __in volatile VOID CONST *Address
    );

void
__lfetchfault(
    __in int Level,
    __in volatile VOID CONST *Address
    );

void
__lfetch_excl(
    __in int Level,
    __in volatile VOID CONST *Address
    );

void
__lfetchfault_excl(
    __in int Level,
    __in volatile VOID CONST *Address
    );

//
// __lfetch control defines.
//

#define MD_LFHINT_NONE    0x00
#define MD_LFHINT_NT1     0x01
#define MD_LFHINT_NT2     0x02
#define MD_LFHINT_NTA     0x03

#pragma intrinsic (__yield)
#pragma intrinsic (__lfetch)
#pragma intrinsic (__lfetchfault)
#pragma intrinsic (__lfetchfault_excl)
#pragma intrinsic (__lfetch_excl)
#pragma intrinsic (__mf)

//
// Define function to read the value of the time stamp counter
//
// N.B. The register number for the time stamp counter is CV_IA64_ApITC which
//      is 3116.
//

#define ReadTimeStampCounter() __getReg(3116)

unsigned __int64
__getReg (
    __in int Number
    );

#pragma intrinsic(__getReg)

#define YieldProcessor          __yield
#define MemoryBarrier           __mf
#define PreFetchCacheLine       __lfetch
#define PrefetchForWrite(p)
#define ReadForWriteAccess(p)   (__lfetch_excl(MD_LFHINT_NONE, (p)), (*(p)))


//
// PreFetchCacheLine level defines.
//

#define PF_TEMPORAL_LEVEL_1         MD_LFHINT_NONE
#define PF_TEMPORAL_LEVEL_2         MD_LFHINT_NT1
#define PF_TEMPORAL_LEVEL_3         MD_LFHINT_NT2
#define PF_NON_TEMPORAL_LEVEL_ALL   MD_LFHINT_NTA

//
// Define functions to capture the high 64-bits of a 128-bit multiply.
//

#define UnsignedMultiplyHigh __UMULH

ULONGLONG
UnsignedMultiplyHigh (
    __in ULONGLONG Multiplier,
    __in ULONGLONG Multiplicand
    );

#pragma intrinsic(__UMULH)

#if (_MSC_VER >= 1400)

#define UnsignedMultiply128 _umul128

DWORD64
UnsignedMultiply128 (
    __in unsigned __int64 Multiplier,
    __in unsigned __int64 Multiplicand,
    __out __deref_out_range(==,Multiplier * Multiplicand) unsigned __int64 *HighProduct
    );

#pragma intrinsic(_umul128)

#endif

#ifdef __cplusplus
}
#endif

// end_ntddk

#else
struct _TEB *
NtCurrentTeb(void);
#endif

#endif  // !defined(__midl) && !defined(GENUTIL) && !defined(_GENIA64_) && defined(_M_IA64)

#ifdef _IA64_

// begin_ntddk

//
// The following values specify the type of failing access when the status is
// STATUS_ACCESS_VIOLATION and the first parameter in the exception record.
//

#define EXCEPTION_READ_FAULT          0 // Access violation was caused by a read
#define EXCEPTION_WRITE_FAULT         1 // Access violation was caused by a write
#define EXCEPTION_EXECUTE_FAULT       2 // Access violation was caused by an instruction fetch

//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_IA64                    0x00080000

#define CONTEXT_CONTROL                 (CONTEXT_IA64 | 0x00000001L)
#define CONTEXT_LOWER_FLOATING_POINT    (CONTEXT_IA64 | 0x00000002L)
#define CONTEXT_HIGHER_FLOATING_POINT   (CONTEXT_IA64 | 0x00000004L)
#define CONTEXT_INTEGER                 (CONTEXT_IA64 | 0x00000008L)
#define CONTEXT_DEBUG                   (CONTEXT_IA64 | 0x00000010L)
#define CONTEXT_IA32_CONTROL            (CONTEXT_IA64 | 0x00000020L)  // Includes StIPSR


#define CONTEXT_FLOATING_POINT          (CONTEXT_LOWER_FLOATING_POINT | CONTEXT_HIGHER_FLOATING_POINT)
#define CONTEXT_FULL                    (CONTEXT_CONTROL | CONTEXT_FLOATING_POINT | CONTEXT_INTEGER | CONTEXT_IA32_CONTROL)
#define CONTEXT_ALL                     (CONTEXT_CONTROL | CONTEXT_FLOATING_POINT | CONTEXT_INTEGER | CONTEXT_DEBUG | CONTEXT_IA32_CONTROL)

#define CONTEXT_EXCEPTION_ACTIVE        0x8000000
#define CONTEXT_SERVICE_ACTIVE          0x10000000
#define CONTEXT_EXCEPTION_REQUEST       0x40000000
#define CONTEXT_EXCEPTION_REPORTING     0x80000000

#endif // !defined(RC_INVOKED)

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) it is used to construct a call frame for APC delivery,
//  3) it is used to construct a call frame for exception dispatching
//  in user mode, 4) it is used in the user level thread creation
//  routines, and 5) it is used to to pass thread state to debuggers.
//
//  N.B. Because this record is used as a call frame, it must be EXACTLY
//  a multiple of 16 bytes in length and aligned on a 16-byte boundary.
//

typedef struct _CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an __inout parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an __out only parameter.
    //

    DWORD ContextFlags;
    DWORD Fill1[3];         // for alignment of following on 16-byte boundary

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_DEBUG.
    //
    // N.B. CONTEXT_DEBUG is *not* part of CONTEXT_FULL.
    //

    ULONGLONG DbI0;
    ULONGLONG DbI1;
    ULONGLONG DbI2;
    ULONGLONG DbI3;
    ULONGLONG DbI4;
    ULONGLONG DbI5;
    ULONGLONG DbI6;
    ULONGLONG DbI7;

    ULONGLONG DbD0;
    ULONGLONG DbD1;
    ULONGLONG DbD2;
    ULONGLONG DbD3;
    ULONGLONG DbD4;
    ULONGLONG DbD5;
    ULONGLONG DbD6;
    ULONGLONG DbD7;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_LOWER_FLOATING_POINT.
    //

    FLOAT128 FltS0;
    FLOAT128 FltS1;
    FLOAT128 FltS2;
    FLOAT128 FltS3;
    FLOAT128 FltT0;
    FLOAT128 FltT1;
    FLOAT128 FltT2;
    FLOAT128 FltT3;
    FLOAT128 FltT4;
    FLOAT128 FltT5;
    FLOAT128 FltT6;
    FLOAT128 FltT7;
    FLOAT128 FltT8;
    FLOAT128 FltT9;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_HIGHER_FLOATING_POINT.
    //

    FLOAT128 FltS4;
    FLOAT128 FltS5;
    FLOAT128 FltS6;
    FLOAT128 FltS7;
    FLOAT128 FltS8;
    FLOAT128 FltS9;
    FLOAT128 FltS10;
    FLOAT128 FltS11;
    FLOAT128 FltS12;
    FLOAT128 FltS13;
    FLOAT128 FltS14;
    FLOAT128 FltS15;
    FLOAT128 FltS16;
    FLOAT128 FltS17;
    FLOAT128 FltS18;
    FLOAT128 FltS19;

    FLOAT128 FltF32;
    FLOAT128 FltF33;
    FLOAT128 FltF34;
    FLOAT128 FltF35;
    FLOAT128 FltF36;
    FLOAT128 FltF37;
    FLOAT128 FltF38;
    FLOAT128 FltF39;

    FLOAT128 FltF40;
    FLOAT128 FltF41;
    FLOAT128 FltF42;
    FLOAT128 FltF43;
    FLOAT128 FltF44;
    FLOAT128 FltF45;
    FLOAT128 FltF46;
    FLOAT128 FltF47;
    FLOAT128 FltF48;
    FLOAT128 FltF49;

    FLOAT128 FltF50;
    FLOAT128 FltF51;
    FLOAT128 FltF52;
    FLOAT128 FltF53;
    FLOAT128 FltF54;
    FLOAT128 FltF55;
    FLOAT128 FltF56;
    FLOAT128 FltF57;
    FLOAT128 FltF58;
    FLOAT128 FltF59;

    FLOAT128 FltF60;
    FLOAT128 FltF61;
    FLOAT128 FltF62;
    FLOAT128 FltF63;
    FLOAT128 FltF64;
    FLOAT128 FltF65;
    FLOAT128 FltF66;
    FLOAT128 FltF67;
    FLOAT128 FltF68;
    FLOAT128 FltF69;

    FLOAT128 FltF70;
    FLOAT128 FltF71;
    FLOAT128 FltF72;
    FLOAT128 FltF73;
    FLOAT128 FltF74;
    FLOAT128 FltF75;
    FLOAT128 FltF76;
    FLOAT128 FltF77;
    FLOAT128 FltF78;
    FLOAT128 FltF79;

    FLOAT128 FltF80;
    FLOAT128 FltF81;
    FLOAT128 FltF82;
    FLOAT128 FltF83;
    FLOAT128 FltF84;
    FLOAT128 FltF85;
    FLOAT128 FltF86;
    FLOAT128 FltF87;
    FLOAT128 FltF88;
    FLOAT128 FltF89;

    FLOAT128 FltF90;
    FLOAT128 FltF91;
    FLOAT128 FltF92;
    FLOAT128 FltF93;
    FLOAT128 FltF94;
    FLOAT128 FltF95;
    FLOAT128 FltF96;
    FLOAT128 FltF97;
    FLOAT128 FltF98;
    FLOAT128 FltF99;

    FLOAT128 FltF100;
    FLOAT128 FltF101;
    FLOAT128 FltF102;
    FLOAT128 FltF103;
    FLOAT128 FltF104;
    FLOAT128 FltF105;
    FLOAT128 FltF106;
    FLOAT128 FltF107;
    FLOAT128 FltF108;
    FLOAT128 FltF109;

    FLOAT128 FltF110;
    FLOAT128 FltF111;
    FLOAT128 FltF112;
    FLOAT128 FltF113;
    FLOAT128 FltF114;
    FLOAT128 FltF115;
    FLOAT128 FltF116;
    FLOAT128 FltF117;
    FLOAT128 FltF118;
    FLOAT128 FltF119;

    FLOAT128 FltF120;
    FLOAT128 FltF121;
    FLOAT128 FltF122;
    FLOAT128 FltF123;
    FLOAT128 FltF124;
    FLOAT128 FltF125;
    FLOAT128 FltF126;
    FLOAT128 FltF127;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_LOWER_FLOATING_POINT | CONTEXT_HIGHER_FLOATING_POINT | CONTEXT_CONTROL.
    //

    ULONGLONG StFPSR;       //  FP status

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //
    // N.B. The registers gp, sp, rp are part of the control context
    //

    ULONGLONG IntGp;        //  r1, volatile
    ULONGLONG IntT0;        //  r2-r3, volatile
    ULONGLONG IntT1;        //
    ULONGLONG IntS0;        //  r4-r7, preserved
    ULONGLONG IntS1;
    ULONGLONG IntS2;
    ULONGLONG IntS3;
    ULONGLONG IntV0;        //  r8, volatile
    ULONGLONG IntT2;        //  r9-r11, volatile
    ULONGLONG IntT3;
    ULONGLONG IntT4;
    ULONGLONG IntSp;        //  stack pointer (r12), special
    ULONGLONG IntTeb;       //  teb (r13), special
    ULONGLONG IntT5;        //  r14-r31, volatile
    ULONGLONG IntT6;
    ULONGLONG IntT7;
    ULONGLONG IntT8;
    ULONGLONG IntT9;
    ULONGLONG IntT10;
    ULONGLONG IntT11;
    ULONGLONG IntT12;
    ULONGLONG IntT13;
    ULONGLONG IntT14;
    ULONGLONG IntT15;
    ULONGLONG IntT16;
    ULONGLONG IntT17;
    ULONGLONG IntT18;
    ULONGLONG IntT19;
    ULONGLONG IntT20;
    ULONGLONG IntT21;
    ULONGLONG IntT22;

    ULONGLONG IntNats;      //  Nat bits for r1-r31
                            //  r1-r31 in bits 1 thru 31.
    ULONGLONG Preds;        //  predicates, preserved

    ULONGLONG BrRp;         //  return pointer, b0, preserved
    ULONGLONG BrS0;         //  b1-b5, preserved
    ULONGLONG BrS1;
    ULONGLONG BrS2;
    ULONGLONG BrS3;
    ULONGLONG BrS4;
    ULONGLONG BrT0;         //  b6-b7, volatile
    ULONGLONG BrT1;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //

    // Other application registers
    ULONGLONG ApUNAT;       //  User Nat collection register, preserved
    ULONGLONG ApLC;         //  Loop counter register, preserved
    ULONGLONG ApEC;         //  Epilog counter register, preserved
    ULONGLONG ApCCV;        //  CMPXCHG value register, volatile
    ULONGLONG ApDCR;        //  Default control register (TBD)

    // Register stack info
    ULONGLONG RsPFS;        //  Previous function state, preserved
    ULONGLONG RsBSP;        //  Backing store pointer, preserved
    ULONGLONG RsBSPSTORE;
    ULONGLONG RsRSC;        //  RSE configuration, volatile
    ULONGLONG RsRNAT;       //  RSE Nat collection register, preserved

    // Trap Status Information
    ULONGLONG StIPSR;       //  Interruption Processor Status
    ULONGLONG StIIP;        //  Interruption IP
    ULONGLONG StIFS;        //  Interruption Function State

    // iA32 related control registers
    ULONGLONG StFCR;        //  copy of Ar21
    ULONGLONG Eflag;        //  Eflag copy of Ar24
    ULONGLONG SegCSD;       //  iA32 CSDescriptor (Ar25)
    ULONGLONG SegSSD;       //  iA32 SSDescriptor (Ar26)
    ULONGLONG Cflag;        //  Cr0+Cr4 copy of Ar27
    ULONGLONG StFSR;        //  x86 FP status (copy of AR28)
    ULONGLONG StFIR;        //  x86 FP status (copy of AR29)
    ULONGLONG StFDR;        //  x86 FP status (copy of AR30)

      ULONGLONG UNUSEDPACK;   //  added to pack StFDR to 16-bytes

} CONTEXT, *PCONTEXT;

//
// Plabel descriptor structure definition
//

typedef struct _PLABEL_DESCRIPTOR {
   ULONGLONG EntryPoint;
   ULONGLONG GlobalPointer;
} PLABEL_DESCRIPTOR, *PPLABEL_DESCRIPTOR;

//
// Function table entry structure definition.
//

typedef struct _RUNTIME_FUNCTION {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD UnwindInfoAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

//
// Define unwind history table structure.
//

#define UNWIND_HISTORY_TABLE_SIZE 12

typedef struct _UNWIND_HISTORY_TABLE_ENTRY {
    DWORD64 ImageBase;
    DWORD64 Gp;
    PRUNTIME_FUNCTION FunctionEntry;
} UNWIND_HISTORY_TABLE_ENTRY, *PUNWIND_HISTORY_TABLE_ENTRY;

typedef struct _UNWIND_HISTORY_TABLE {
        DWORD Count;
        BYTE  LocalHint;
        BYTE  GlobalHint;
        BYTE  Search;
        BYTE  Once;
        DWORD64 LowAddress;
        DWORD64 HighAddress;
        UNWIND_HISTORY_TABLE_ENTRY Entry[UNWIND_HISTORY_TABLE_SIZE];
} UNWIND_HISTORY_TABLE, *PUNWIND_HISTORY_TABLE;

//
// Define dynamic function table entry.
//

typedef
__drv_functionClass(GET_RUNTIME_FUNCTION_CALLBACK)
PRUNTIME_FUNCTION
GET_RUNTIME_FUNCTION_CALLBACK (
    __in DWORD64 ControlPc,
    __in_opt PVOID Context
    );
typedef GET_RUNTIME_FUNCTION_CALLBACK *PGET_RUNTIME_FUNCTION_CALLBACK;

typedef
__drv_functionClass(OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK)
__checkReturn
DWORD   
OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK (
    __in HANDLE Process,
    __in PVOID TableAddress,
    __out PDWORD Entries,
    __deref_out PRUNTIME_FUNCTION* Functions
    );
typedef OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK *POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK;

#define OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME \
    "OutOfProcessFunctionTableCallback"

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return!=0)
NTSYSAPI
BOOLEAN
NTAPI
RtlAddFunctionTable(
    __in_ecount(EntryCount) PRUNTIME_FUNCTION FunctionTable,
    __in DWORD EntryCount,
    __in ULONGLONG BaseAddress,
    __in ULONGLONG TargetGp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return!=0)
NTSYSAPI
BOOLEAN
NTAPI
RtlInstallFunctionTableCallback (
    __in DWORD64 TableIdentifier,
    __in DWORD64 BaseAddress,
    __in DWORD Length,
    __in DWORD64 TargetGp,
    __in PGET_RUNTIME_FUNCTION_CALLBACK Callback,
    __in_opt PVOID Context,
    __in_opt PCWSTR OutOfProcessCallbackDll
    );

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return!=0)
NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteFunctionTable (
    __in PRUNTIME_FUNCTION FunctionTable
    );

__drv_maxIRQL(SYNCH_LEVEL)
__drv_minIRQL(PASSIVE_LEVEL)
NTSYSAPI
PRUNTIME_FUNCTION
NTAPI
RtlLookupFunctionEntry (
    __in ULONGLONG ControlPc,
    __out PULONGLONG ImageBase,
    __out PULONGLONG TargetGp
    );

//
// Nonvolatile context pointer record.
//
// The IA64 architecture currently doesn't have any nonvolatile kernel context
// as we capture everything in either the trap or exception frames on
// transition from user to kernel mode. We allocate a single bogus
// pointer field as usually this structure is made up of pointers to
// places in the kernel stack where the various nonvolatile items were
// pushed on to the kernel stack.
//
// TBD *** Need to fill in this structure with the relevant fields
//         when we start storing the nonvolatile information only when
//         necessary.
//

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
    PFLOAT128  FltS0;
    PFLOAT128  FltS1;
    PFLOAT128  FltS2;
    PFLOAT128  FltS3;
    PFLOAT128  HighFloatingContext[10];
    PFLOAT128  FltS4;
    PFLOAT128  FltS5;
    PFLOAT128  FltS6;
    PFLOAT128  FltS7;
    PFLOAT128  FltS8;
    PFLOAT128  FltS9;
    PFLOAT128  FltS10;
    PFLOAT128  FltS11;
    PFLOAT128  FltS12;
    PFLOAT128  FltS13;
    PFLOAT128  FltS14;
    PFLOAT128  FltS15;
    PFLOAT128  FltS16;
    PFLOAT128  FltS17;
    PFLOAT128  FltS18;
    PFLOAT128  FltS19;

    PULONGLONG IntS0;
    PULONGLONG IntS1;
    PULONGLONG IntS2;
    PULONGLONG IntS3;
    PULONGLONG IntSp;
    PULONGLONG IntS0Nat;
    PULONGLONG IntS1Nat;
    PULONGLONG IntS2Nat;
    PULONGLONG IntS3Nat;
    PULONGLONG IntSpNat;

    PULONGLONG Preds;

    PULONGLONG BrRp;
    PULONGLONG BrS0;
    PULONGLONG BrS1;
    PULONGLONG BrS2;
    PULONGLONG BrS3;
    PULONGLONG BrS4;

    PULONGLONG ApUNAT;
    PULONGLONG ApLC;
    PULONGLONG ApEC;
    PULONGLONG RsPFS;

    PULONGLONG StFSR;
    PULONGLONG StFIR;
    PULONGLONG StFDR;
    PULONGLONG Cflag;

    PULONGLONG StFPSR;

} KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;

typedef struct _FRAME_POINTERS {
    ULONGLONG MemoryStackFp;
    ULONGLONG BackingStoreFp;
} FRAME_POINTERS, *PFRAME_POINTERS;

NTSYSAPI
ULONGLONG
NTAPI
RtlVirtualUnwind (
    __in ULONGLONG ImageBase,
    __in ULONGLONG ControlPc,
    __in PRUNTIME_FUNCTION FunctionEntry,
    __inout PCONTEXT ContextRecord,
    __out PBOOLEAN InFunction,
    __out PFRAME_POINTERS EstablisherFrame,
    __inout_opt PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
    );

NTSYSAPI
VOID
NTAPI
RtlRestoreContext (
    __in PCONTEXT ContextRecord,
    __in_opt struct _EXCEPTION_RECORD *ExceptionRecord
    );

NTSYSAPI
VOID
NTAPI
__jump_unwind (
    ULONGLONG TargetMsFrame,
    ULONGLONG TargetBsFrame,
    ULONGLONG TargetPc
    );

#endif // _IA64_


#if !defined(RC_INVOKED)

#define WOW64_CONTEXT_i386      0x00010000    // this assumes that i386 and
#define WOW64_CONTEXT_i486      0x00010000    // i486 have identical context records

#define WOW64_CONTEXT_CONTROL               (WOW64_CONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define WOW64_CONTEXT_INTEGER               (WOW64_CONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define WOW64_CONTEXT_SEGMENTS              (WOW64_CONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define WOW64_CONTEXT_FLOATING_POINT        (WOW64_CONTEXT_i386 | 0x00000008L) // 387 state
#define WOW64_CONTEXT_DEBUG_REGISTERS       (WOW64_CONTEXT_i386 | 0x00000010L) // DB 0-3,6,7
#define WOW64_CONTEXT_EXTENDED_REGISTERS    (WOW64_CONTEXT_i386 | 0x00000020L) // cpu specific extensions

#define WOW64_CONTEXT_FULL      (WOW64_CONTEXT_CONTROL | WOW64_CONTEXT_INTEGER | WOW64_CONTEXT_SEGMENTS)

#define WOW64_CONTEXT_ALL       (WOW64_CONTEXT_CONTROL | WOW64_CONTEXT_INTEGER | WOW64_CONTEXT_SEGMENTS | \
                                 WOW64_CONTEXT_FLOATING_POINT | WOW64_CONTEXT_DEBUG_REGISTERS | \
                                 WOW64_CONTEXT_EXTENDED_REGISTERS)

#define WOW64_CONTEXT_XSTATE                (WOW64_CONTEXT_i386 | 0x00000040L)

#endif // !defined(RC_INVOKED)

//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define WOW64_SIZE_OF_80387_REGISTERS      80

#define WOW64_MAXIMUM_SUPPORTED_EXTENSION     512

typedef struct _WOW64_FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[WOW64_SIZE_OF_80387_REGISTERS];
    DWORD   Cr0NpxState;
} WOW64_FLOATING_SAVE_AREA;

typedef WOW64_FLOATING_SAVE_AREA *PWOW64_FLOATING_SAVE_AREA;

#include "pshpack4.h"

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _WOW64_CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    WOW64_FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED
    DWORD   EFlags;             // MUST BE SANITIZED
    DWORD   Esp;
    DWORD   SegSs;

    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //

    BYTE    ExtendedRegisters[WOW64_MAXIMUM_SUPPORTED_EXTENSION];

} WOW64_CONTEXT;

typedef WOW64_CONTEXT *PWOW64_CONTEXT;

#include "poppack.h"


typedef struct _WOW64_LDT_ENTRY {
    WORD    LimitLow;
    WORD    BaseLow;
    union {
        struct {
            BYTE    BaseMid;
            BYTE    Flags1;     // Declare as bytes to avoid alignment
            BYTE    Flags2;     // Problems.
            BYTE    BaseHi;
        } Bytes;
        struct {
            DWORD   BaseMid : 8;
            DWORD   Type : 5;
            DWORD   Dpl : 2;
            DWORD   Pres : 1;
            DWORD   LimitHi : 4;
            DWORD   Sys : 1;
            DWORD   Reserved_0 : 1;
            DWORD   Default_Big : 1;
            DWORD   Granularity : 1;
            DWORD   BaseHi : 8;
        } Bits;
    } HighWord;
} WOW64_LDT_ENTRY, *PWOW64_LDT_ENTRY;

typedef struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
    DWORD Selector;
    WOW64_LDT_ENTRY Descriptor;
} WOW64_DESCRIPTOR_TABLE_ENTRY, *PWOW64_DESCRIPTOR_TABLE_ENTRY;

#define EXCEPTION_NONCONTINUABLE 0x1    // Noncontinuable exception
#define EXCEPTION_MAXIMUM_PARAMETERS 15 // maximum number of exception parameters

//
// Exception record definition.
//

typedef struct _EXCEPTION_RECORD {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD32 {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    DWORD ExceptionRecord;
    DWORD ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    DWORD64 ExceptionRecord;
    DWORD64 ExceptionAddress;
    DWORD NumberParameters;
    DWORD __unusedAlignment;
    DWORD64 ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;

//
// Typedef for pointer returned by exception_info()
//

typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;

// end_wdm

NTSYSAPI
VOID
NTAPI
RtlUnwind (
    __in_opt PVOID TargetFrame,
    __in_opt PVOID TargetIp,
    __in_opt PEXCEPTION_RECORD ExceptionRecord,
    __in PVOID ReturnValue
    );

#if defined(_IA64_)

NTSYSAPI
VOID
NTAPI
RtlUnwind2 (
    __in_opt FRAME_POINTERS TargetFrame,
    __in_opt PVOID TargetIp,
    __in_opt PEXCEPTION_RECORD ExceptionRecord,
    __in PVOID ReturnValue,
    __in PCONTEXT ContextRecord
    );

#endif

#if defined(_AMD64_)

NTSYSAPI
VOID
NTAPI
RtlUnwindEx (
    __in_opt PVOID TargetFrame,
    __in_opt PVOID TargetIp,
    __in_opt PEXCEPTION_RECORD ExceptionRecord,
    __in PVOID ReturnValue,
    __in PCONTEXT ContextRecord,
    __in_opt PUNWIND_HISTORY_TABLE HistoryTable
    );

#elif defined(_IA64_)

NTSYSAPI
VOID
NTAPI
RtlUnwindEx (
    __in_opt FRAME_POINTERS TargetFrame,
    __in_opt PVOID TargetIp,
    __in_opt PEXCEPTION_RECORD ExceptionRecord,
    __in PVOID ReturnValue,
    __in PCONTEXT ContextRecord,
    __in_opt PUNWIND_HISTORY_TABLE HistoryTable
    );

#endif

typedef PVOID PACCESS_TOKEN;            
typedef PVOID PSECURITY_DESCRIPTOR;     
typedef PVOID PSID;     
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS MASK                            //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define the access mask as a longword sized structure divided up as
//  follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+---------------+-------------------------------+
//      |G|G|G|G|Res'd|A| StandardRights|         SpecificRights        |
//      |R|W|E|A|     |S|               |                               |
//      +-+-------------+---------------+-------------------------------+
//
//      typedef struct _ACCESS_MASK {
//          WORD   SpecificRights;
//          BYTE  StandardRights;
//          BYTE  AccessSystemAcl : 1;
//          BYTE  Reserved : 3;
//          BYTE  GenericAll : 1;
//          BYTE  GenericExecute : 1;
//          BYTE  GenericWrite : 1;
//          BYTE  GenericRead : 1;
//      } ACCESS_MASK;
//      typedef ACCESS_MASK *PACCESS_MASK;
//
//  but to make life simple for programmer's we'll allow them to specify
//  a desired access mask by simply OR'ing together mulitple single rights
//  and treat an access mask as a DWORD.  For example
//
//      DesiredAccess = DELETE | READ_CONTROL
//
//  So we'll declare ACCESS_MASK as DWORD
//

// begin_wdm
typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS TYPES                           //
//                                                                    //
////////////////////////////////////////////////////////////////////////


// begin_wdm
//
//  The following are masks for the predefined standard access types
//

#define DELETE                           (0x00010000L)
#define READ_CONTROL                     (0x00020000L)
#define WRITE_DAC                        (0x00040000L)
#define WRITE_OWNER                      (0x00080000L)
#define SYNCHRONIZE                      (0x00100000L)

#define STANDARD_RIGHTS_REQUIRED         (0x000F0000L)

#define STANDARD_RIGHTS_READ             (READ_CONTROL)
#define STANDARD_RIGHTS_WRITE            (READ_CONTROL)
#define STANDARD_RIGHTS_EXECUTE          (READ_CONTROL)

#define STANDARD_RIGHTS_ALL              (0x001F0000L)

#define SPECIFIC_RIGHTS_ALL              (0x0000FFFFL)

//
// AccessSystemAcl access type
//

#define ACCESS_SYSTEM_SECURITY           (0x01000000L)

//
// MaximumAllowed access type
//

#define MAXIMUM_ALLOWED                  (0x02000000L)

//
//  These are the generic rights.
//

#define GENERIC_READ                     (0x80000000L)
#define GENERIC_WRITE                    (0x40000000L)
#define GENERIC_EXECUTE                  (0x20000000L)
#define GENERIC_ALL                      (0x10000000L)


//
//  Define the generic mapping array.  This is used to denote the
//  mapping of each generic access right to a specific access mask.
//

typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        LUID_AND_ATTRIBUTES                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//


#include <pshpack4.h>

typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;

#include <poppack.h>


////////////////////////////////////////////////////////////////////////
//                                                                    //
//              Security Id     (SID)                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//
// Pictorially the structure of an SID is as follows:
//
//         1   1   1   1   1   1
//         5   4   3   2   1   0   9   8   7   6   5   4   3   2   1   0
//      +---------------------------------------------------------------+
//      |      SubAuthorityCount        |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[0]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[1]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[2]                      |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +- -  -  -  -  -  -  -  SubAuthority[]  -  -  -  -  -  -  -  - -+
//      |                                                               |
//      +---------------------------------------------------------------+
//
//


// begin_ntifs

#ifndef SID_IDENTIFIER_AUTHORITY_DEFINED
#define SID_IDENTIFIER_AUTHORITY_DEFINED
typedef struct _SID_IDENTIFIER_AUTHORITY {
    BYTE  Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;
#endif


#ifndef SID_DEFINED
#define SID_DEFINED
typedef struct _SID {
   BYTE  Revision;
   BYTE  SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
#ifdef MIDL_PASS
   [size_is(SubAuthorityCount)] DWORD SubAuthority[*];
#else // MIDL_PASS
   DWORD SubAuthority[ANYSIZE_ARRAY];
#endif // MIDL_PASS
} SID, *PISID;
#endif

#define SID_REVISION                     (1)    // Current revision level
#define SID_MAX_SUB_AUTHORITIES          (15)
#define SID_RECOMMENDED_SUB_AUTHORITIES  (1)    // Will change to around 6

                                                // in a future release.
#ifndef MIDL_PASS
#define SECURITY_MAX_SID_SIZE  \
      (sizeof(SID) - sizeof(DWORD) + (SID_MAX_SUB_AUTHORITIES * sizeof(DWORD)))
#endif // MIDL_PASS


typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer,
    SidTypeLabel
} SID_NAME_USE, *PSID_NAME_USE;

typedef struct _SID_AND_ATTRIBUTES {
#ifdef MIDL_PASS
    PISID Sid;
#else // MIDL_PASS
    PSID Sid;
#endif // MIDL_PASS
    DWORD Attributes;
    } SID_AND_ATTRIBUTES, * PSID_AND_ATTRIBUTES;

typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;

#define SID_HASH_SIZE 32
typedef ULONG_PTR SID_HASH_ENTRY, *PSID_HASH_ENTRY;

typedef struct _SID_AND_ATTRIBUTES_HASH {
    DWORD SidCount;
    PSID_AND_ATTRIBUTES SidAttr;
    SID_HASH_ENTRY Hash[SID_HASH_SIZE];
} SID_AND_ATTRIBUTES_HASH, *PSID_AND_ATTRIBUTES_HASH;


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Universal well-known SIDs                                               //
//                                                                         //
//     Null SID                     S-1-0-0                                //
//     World                        S-1-1-0                                //
//     Local                        S-1-2-0                                //
//     Creator Owner ID             S-1-3-0                                //
//     Creator Group ID             S-1-3-1                                //
//     Creator Owner Server ID      S-1-3-2                                //
//     Creator Group Server ID      S-1-3-3                                //
//                                                                         //
//     (Non-unique IDs)             S-1-4                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#define SECURITY_NULL_SID_AUTHORITY         {0,0,0,0,0,0}
#define SECURITY_WORLD_SID_AUTHORITY        {0,0,0,0,0,1}
#define SECURITY_LOCAL_SID_AUTHORITY        {0,0,0,0,0,2}
#define SECURITY_CREATOR_SID_AUTHORITY      {0,0,0,0,0,3}
#define SECURITY_NON_UNIQUE_AUTHORITY       {0,0,0,0,0,4}
#define SECURITY_RESOURCE_MANAGER_AUTHORITY {0,0,0,0,0,9}


#define SECURITY_NULL_RID                 (0x00000000L)
#define SECURITY_WORLD_RID                (0x00000000L)
#define SECURITY_LOCAL_RID                (0x00000000L)
#define SECURITY_LOCAL_LOGON_RID          (0x00000001L)

#define SECURITY_CREATOR_OWNER_RID        (0x00000000L)
#define SECURITY_CREATOR_GROUP_RID        (0x00000001L)

#define SECURITY_CREATOR_OWNER_SERVER_RID (0x00000002L)
#define SECURITY_CREATOR_GROUP_SERVER_RID (0x00000003L)

#define SECURITY_CREATOR_OWNER_RIGHTS_RID (0x00000004L)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// NT well-known SIDs                                                        //
//                                                                           //
//     NT Authority            S-1-5                                         //
//     Dialup                  S-1-5-1                                       //
//                                                                           //
//     Network                 S-1-5-2                                       //
//     Batch                   S-1-5-3                                       //
//     Interactive             S-1-5-4                                       //
//     (Logon IDs)             S-1-5-5-X-Y                                   //
//     Service                 S-1-5-6                                       //
//     AnonymousLogon          S-1-5-7       (aka null logon session)        //
//     Proxy                   S-1-5-8                                       //
//     Enterprise DC (EDC)     S-1-5-9       (aka domain controller account) //
//     Self                    S-1-5-10      (self RID)                      //
//     Authenticated User      S-1-5-11      (Authenticated user somewhere)  //
//     Restricted Code         S-1-5-12      (Running restricted code)       //
//     Terminal Server         S-1-5-13      (Running on Terminal Server)    //
//     Remote Logon            S-1-5-14      (Remote Interactive Logon)      //
//     This Organization       S-1-5-15                                      //
//                                                                           //
//     IUser                   S-1-5-17
//     Local System            S-1-5-18                                      //
//     Local Service           S-1-5-19                                      //
//     Network Service         S-1-5-20                                      //
//                                                                           //
//     (NT non-unique IDs)     S-1-5-0x15-... (NT Domain Sids)               //
//                                                                           //
//     (Built-in domain)       S-1-5-0x20                                    //
//                                                                           //
//     (Security Package IDs)  S-1-5-0x40                                    //
//     NTLM Authentication     S-1-5-0x40-10                                 //
//     SChannel Authentication S-1-5-0x40-14                                 //
//     Digest Authentication   S-1-5-0x40-21                                 //
//                                                                           //
//     Other Organization      S-1-5-1000    (>=1000 can not be filtered)    //
//                                                                           //
//                                                                           //
// NOTE: the relative identifier values (RIDs) determine which security      //
//       boundaries the SID is allowed to cross.  Before adding new RIDs,    //
//       a determination needs to be made regarding which range they should  //
//       be added to in order to ensure proper "SID filtering"               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#define SECURITY_NT_AUTHORITY           {0,0,0,0,0,5}   // ntifs

#define SECURITY_DIALUP_RID             (0x00000001L)
#define SECURITY_NETWORK_RID            (0x00000002L)
#define SECURITY_BATCH_RID              (0x00000003L)
#define SECURITY_INTERACTIVE_RID        (0x00000004L)
#define SECURITY_LOGON_IDS_RID          (0x00000005L)
#define SECURITY_LOGON_IDS_RID_COUNT    (3L)
#define SECURITY_SERVICE_RID            (0x00000006L)
#define SECURITY_ANONYMOUS_LOGON_RID    (0x00000007L)
#define SECURITY_PROXY_RID              (0x00000008L)
#define SECURITY_ENTERPRISE_CONTROLLERS_RID (0x00000009L)
#define SECURITY_SERVER_LOGON_RID       SECURITY_ENTERPRISE_CONTROLLERS_RID
#define SECURITY_PRINCIPAL_SELF_RID     (0x0000000AL)
#define SECURITY_AUTHENTICATED_USER_RID (0x0000000BL)
#define SECURITY_RESTRICTED_CODE_RID    (0x0000000CL)
#define SECURITY_TERMINAL_SERVER_RID    (0x0000000DL)
#define SECURITY_REMOTE_LOGON_RID       (0x0000000EL)
#define SECURITY_THIS_ORGANIZATION_RID  (0x0000000FL)
#define SECURITY_IUSER_RID              (0x00000011L)
#define SECURITY_LOCAL_SYSTEM_RID       (0x00000012L)
#define SECURITY_LOCAL_SERVICE_RID      (0x00000013L)
#define SECURITY_NETWORK_SERVICE_RID    (0x00000014L)

#define SECURITY_NT_NON_UNIQUE          (0x00000015L)
#define SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT  (3L)

#define SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID (0x00000016L)

#define SECURITY_BUILTIN_DOMAIN_RID     (0x00000020L)
#define SECURITY_WRITE_RESTRICTED_CODE_RID (0x00000021L)


#define SECURITY_PACKAGE_BASE_RID       (0x00000040L)
#define SECURITY_PACKAGE_RID_COUNT      (2L)
#define SECURITY_PACKAGE_NTLM_RID       (0x0000000AL)
#define SECURITY_PACKAGE_SCHANNEL_RID   (0x0000000EL)
#define SECURITY_PACKAGE_DIGEST_RID     (0x00000015L)

#define SECURITY_CRED_TYPE_BASE_RID             (0x00000041L)
#define SECURITY_CRED_TYPE_RID_COUNT            (2L)
#define SECURITY_CRED_TYPE_THIS_ORG_CERT_RID    (0x00000001L)

#define SECURITY_MIN_BASE_RID           (0x00000050L)

#define SECURITY_SERVICE_ID_BASE_RID    (0x00000050L)
#define SECURITY_SERVICE_ID_RID_COUNT   (6L)

#define SECURITY_RESERVED_ID_BASE_RID   (0x00000051L)

#define SECURITY_APPPOOL_ID_BASE_RID    (0x00000052L)
#define SECURITY_APPPOOL_ID_RID_COUNT   (6L)

#define SECURITY_VIRTUALSERVER_ID_BASE_RID    (0x00000053L)
#define SECURITY_VIRTUALSERVER_ID_RID_COUNT   (6L)

#define SECURITY_USERMODEDRIVERHOST_ID_BASE_RID  (0x00000054L)
#define SECURITY_USERMODEDRIVERHOST_ID_RID_COUNT (6L)

#define SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_BASE_RID  (0x00000055L)
#define SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_RID_COUNT (6L)

#define SECURITY_WMIHOST_ID_BASE_RID  (0x00000056L)
#define SECURITY_WMIHOST_ID_RID_COUNT (6L)

#define SECURITY_TASK_ID_BASE_RID                 (0x00000057L)

#define SECURITY_NFS_ID_BASE_RID        (0x00000058L)

#define SECURITY_COM_ID_BASE_RID        (0x00000059L)

#define SECURITY_VIRTUALACCOUNT_ID_RID_COUNT   (6L)

#define SECURITY_MAX_BASE_RID		(0x0000006FL)
#define SECURITY_MAX_ALWAYS_FILTERED    (0x000003E7L)
#define SECURITY_MIN_NEVER_FILTERED     (0x000003E8L)

#define SECURITY_OTHER_ORGANIZATION_RID (0x000003E8L)

//
//Service SID type RIDs are in the range 0x50- 0x6F.  Therefore, we are giving  the next available RID to Windows Mobile team.
//
#define SECURITY_WINDOWSMOBILE_ID_BASE_RID (0x00000070L)


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// well-known domain relative sub-authority values (RIDs)...               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////



#define DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS (0x000001F2L)

#define FOREST_USER_RID_MAX            (0x000001F3L)

// Well-known users ...

#define DOMAIN_USER_RID_ADMIN          (0x000001F4L)
#define DOMAIN_USER_RID_GUEST          (0x000001F5L)
#define DOMAIN_USER_RID_KRBTGT         (0x000001F6L)

#define DOMAIN_USER_RID_MAX            (0x000003E7L)


// well-known groups ...

#define DOMAIN_GROUP_RID_ADMINS        (0x00000200L)
#define DOMAIN_GROUP_RID_USERS         (0x00000201L)
#define DOMAIN_GROUP_RID_GUESTS        (0x00000202L)
#define DOMAIN_GROUP_RID_COMPUTERS     (0x00000203L)
#define DOMAIN_GROUP_RID_CONTROLLERS   (0x00000204L)
#define DOMAIN_GROUP_RID_CERT_ADMINS   (0x00000205L)
#define DOMAIN_GROUP_RID_SCHEMA_ADMINS (0x00000206L)
#define DOMAIN_GROUP_RID_ENTERPRISE_ADMINS (0x00000207L)
#define DOMAIN_GROUP_RID_POLICY_ADMINS (0x00000208L)
#define DOMAIN_GROUP_RID_READONLY_CONTROLLERS (0x00000209L)

// well-known aliases ...

#define DOMAIN_ALIAS_RID_ADMINS                         (0x00000220L)
#define DOMAIN_ALIAS_RID_USERS                          (0x00000221L)
#define DOMAIN_ALIAS_RID_GUESTS                         (0x00000222L)
#define DOMAIN_ALIAS_RID_POWER_USERS                    (0x00000223L)

#define DOMAIN_ALIAS_RID_ACCOUNT_OPS                    (0x00000224L)
#define DOMAIN_ALIAS_RID_SYSTEM_OPS                     (0x00000225L)
#define DOMAIN_ALIAS_RID_PRINT_OPS                      (0x00000226L)
#define DOMAIN_ALIAS_RID_BACKUP_OPS                     (0x00000227L)

#define DOMAIN_ALIAS_RID_REPLICATOR                     (0x00000228L)
#define DOMAIN_ALIAS_RID_RAS_SERVERS                    (0x00000229L)
#define DOMAIN_ALIAS_RID_PREW2KCOMPACCESS               (0x0000022AL)
#define DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS           (0x0000022BL)
#define DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS      (0x0000022CL)
#define DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS (0x0000022DL)

#define DOMAIN_ALIAS_RID_MONITORING_USERS               (0x0000022EL)
#define DOMAIN_ALIAS_RID_LOGGING_USERS                  (0x0000022FL)
#define DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS            (0x00000230L)
#define DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS             (0x00000231L)
#define DOMAIN_ALIAS_RID_DCOM_USERS                     (0x00000232L)
#define DOMAIN_ALIAS_RID_IUSERS                         (0x00000238L)
#define DOMAIN_ALIAS_RID_CRYPTO_OPERATORS               (0x00000239L)
#define DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP     (0x0000023BL)
#define DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP (0x0000023CL)
#define DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP        (0x0000023DL)
#define DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP      (0x0000023EL)


#define SECURITY_MANDATORY_LABEL_AUTHORITY          {0,0,0,0,0,16}
#define SECURITY_MANDATORY_UNTRUSTED_RID            (0x00000000L)
#define SECURITY_MANDATORY_LOW_RID                  (0x00001000L)
#define SECURITY_MANDATORY_MEDIUM_RID               (0x00002000L)
#define SECURITY_MANDATORY_MEDIUM_PLUS_RID          (SECURITY_MANDATORY_MEDIUM_RID + 0x100)
#define SECURITY_MANDATORY_HIGH_RID                 (0x00003000L)
#define SECURITY_MANDATORY_SYSTEM_RID               (0x00004000L)
#define SECURITY_MANDATORY_PROTECTED_PROCESS_RID    (0x00005000L)

//
// SECURITY_MANDATORY_MAXIMUM_USER_RID is the highest RID that
// can be set by a usermode caller.
//

#define SECURITY_MANDATORY_MAXIMUM_USER_RID   SECURITY_MANDATORY_SYSTEM_RID

#define MANDATORY_LEVEL_TO_MANDATORY_RID(IL) (IL * 0x1000)



//
// Well known SID definitions for lookup.
//

typedef enum {

    WinNullSid                                  = 0,
    WinWorldSid                                 = 1,
    WinLocalSid                                 = 2,
    WinCreatorOwnerSid                          = 3,
    WinCreatorGroupSid                          = 4,
    WinCreatorOwnerServerSid                    = 5,
    WinCreatorGroupServerSid                    = 6,
    WinNtAuthoritySid                           = 7,
    WinDialupSid                                = 8,
    WinNetworkSid                               = 9,
    WinBatchSid                                 = 10,
    WinInteractiveSid                           = 11,
    WinServiceSid                               = 12,
    WinAnonymousSid                             = 13,
    WinProxySid                                 = 14,
    WinEnterpriseControllersSid                 = 15,
    WinSelfSid                                  = 16,
    WinAuthenticatedUserSid                     = 17,
    WinRestrictedCodeSid                        = 18,
    WinTerminalServerSid                        = 19,
    WinRemoteLogonIdSid                         = 20,
    WinLogonIdsSid                              = 21,
    WinLocalSystemSid                           = 22,
    WinLocalServiceSid                          = 23,
    WinNetworkServiceSid                        = 24,
    WinBuiltinDomainSid                         = 25,
    WinBuiltinAdministratorsSid                 = 26,
    WinBuiltinUsersSid                          = 27,
    WinBuiltinGuestsSid                         = 28,
    WinBuiltinPowerUsersSid                     = 29,
    WinBuiltinAccountOperatorsSid               = 30,
    WinBuiltinSystemOperatorsSid                = 31,
    WinBuiltinPrintOperatorsSid                 = 32,
    WinBuiltinBackupOperatorsSid                = 33,
    WinBuiltinReplicatorSid                     = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid             = 36,
    WinBuiltinNetworkConfigurationOperatorsSid  = 37,
    WinAccountAdministratorSid                  = 38,
    WinAccountGuestSid                          = 39,
    WinAccountKrbtgtSid                         = 40,
    WinAccountDomainAdminsSid                   = 41,
    WinAccountDomainUsersSid                    = 42,
    WinAccountDomainGuestsSid                   = 43,
    WinAccountComputersSid                      = 44,
    WinAccountControllersSid                    = 45,
    WinAccountCertAdminsSid                     = 46,
    WinAccountSchemaAdminsSid                   = 47,
    WinAccountEnterpriseAdminsSid               = 48,
    WinAccountPolicyAdminsSid                   = 49,
    WinAccountRasAndIasServersSid               = 50,
    WinNTLMAuthenticationSid                    = 51,
    WinDigestAuthenticationSid                  = 52,
    WinSChannelAuthenticationSid                = 53,
    WinThisOrganizationSid                      = 54,
    WinOtherOrganizationSid                     = 55,
    WinBuiltinIncomingForestTrustBuildersSid    = 56,
    WinBuiltinPerfMonitoringUsersSid            = 57,
    WinBuiltinPerfLoggingUsersSid               = 58,
    WinBuiltinAuthorizationAccessSid            = 59,
    WinBuiltinTerminalServerLicenseServersSid   = 60,
    WinBuiltinDCOMUsersSid                      = 61,
    WinBuiltinIUsersSid                         = 62,
    WinIUserSid                                 = 63,
    WinBuiltinCryptoOperatorsSid                = 64,
    WinUntrustedLabelSid                        = 65,
    WinLowLabelSid                              = 66,
    WinMediumLabelSid                           = 67,
    WinHighLabelSid                             = 68,
    WinSystemLabelSid                           = 69,
    WinWriteRestrictedCodeSid                   = 70,
    WinCreatorOwnerRightsSid                    = 71,
    WinCacheablePrincipalsGroupSid              = 72,
    WinNonCacheablePrincipalsGroupSid           = 73,
    WinEnterpriseReadonlyControllersSid         = 74,
    WinAccountReadonlyControllersSid            = 75,
    WinBuiltinEventLogReadersGroup              = 76,
    WinNewEnterpriseReadonlyControllersSid      = 77,
    WinBuiltinCertSvcDComAccessGroup            = 78,
    WinMediumPlusLabelSid                       = 79,
    WinLocalLogonSid                            = 80,
    WinConsoleLogonSid							= 81,
    WinThisOrganizationCertificateSid			= 82,
} WELL_KNOWN_SID_TYPE;

//
// Allocate the System Luid.  The first 1000 LUIDs are reserved.
// Use #999 here (0x3e7 = 999)
//

#define SYSTEM_LUID                     { 0x3e7, 0x0 }
#define ANONYMOUS_LOGON_LUID            { 0x3e6, 0x0 }
#define LOCALSERVICE_LUID               { 0x3e5, 0x0 }
#define NETWORKSERVICE_LUID             { 0x3e4, 0x0 }
#define IUSER_LUID                      { 0x3e3, 0x0 }

// end_ntifs

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                          User and Group related SID attributes     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// Group attributes
//

#define SE_GROUP_MANDATORY                 (0x00000001L)
#define SE_GROUP_ENABLED_BY_DEFAULT        (0x00000002L)
#define SE_GROUP_ENABLED                   (0x00000004L)
#define SE_GROUP_OWNER                     (0x00000008L)
#define SE_GROUP_USE_FOR_DENY_ONLY         (0x00000010L)
#define SE_GROUP_INTEGRITY                 (0x00000020L)
#define SE_GROUP_INTEGRITY_ENABLED         (0x00000040L)
#define SE_GROUP_LOGON_ID                  (0xC0000000L)
#define SE_GROUP_RESOURCE                  (0x20000000L)

#define SE_GROUP_VALID_ATTRIBUTES          (SE_GROUP_MANDATORY          | \
                                            SE_GROUP_ENABLED_BY_DEFAULT | \
                                            SE_GROUP_ENABLED            | \
                                            SE_GROUP_OWNER              | \
                                            SE_GROUP_USE_FOR_DENY_ONLY  | \
                                            SE_GROUP_LOGON_ID           | \
                                            SE_GROUP_RESOURCE           | \
                                            SE_GROUP_INTEGRITY          | \
                                            SE_GROUP_INTEGRITY_ENABLED)

//
// User attributes
//

// (None yet defined.)




////////////////////////////////////////////////////////////////////////
//                                                                    //
//                         ACL  and  ACE                              //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define an ACL and the ACE format.  The structure of an ACL header
//  followed by one or more ACEs.  Pictorally the structure of an ACL header
//  is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +-------------------------------+---------------+---------------+
//      |            AclSize            |      Sbz1     |  AclRevision  |
//      +-------------------------------+---------------+---------------+
//      |              Sbz2             |           AceCount            |
//      +-------------------------------+-------------------------------+
//
//  The current AclRevision is defined to be ACL_REVISION.
//
//  AclSize is the size, in bytes, allocated for the ACL.  This includes
//  the ACL header, ACES, and remaining free space in the buffer.
//
//  AceCount is the number of ACES in the ACL.
//

// begin_wdm
// This is the *current* ACL revision

#define ACL_REVISION     (2)
#define ACL_REVISION_DS  (4)

// This is the history of ACL revisions.  Add a new one whenever
// ACL_REVISION is updated

#define ACL_REVISION1   (1)
#define MIN_ACL_REVISION ACL_REVISION2
#define ACL_REVISION2   (2)
#define ACL_REVISION3   (3)
#define ACL_REVISION4   (4)
#define MAX_ACL_REVISION ACL_REVISION4

typedef struct _ACL {
    BYTE  AclRevision;
    BYTE  Sbz1;
    WORD   AclSize;
    WORD   AceCount;
    WORD   Sbz2;
} ACL;
typedef ACL *PACL;

// end_wdm
// begin_ntifs

//
//  The structure of an ACE is a common ace header followed by ace type
//  specific data.  Pictorally the structure of the common ace header is
//  as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |            AceSize            |    AceFlags   |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//
//  AceType denotes the type of the ace, there are some predefined ace
//  types
//
//  AceSize is the size, in bytes, of ace.
//
//  AceFlags are the Ace flags for audit and inheritance, defined shortly.

typedef struct _ACE_HEADER {
    BYTE  AceType;
    BYTE  AceFlags;
    WORD   AceSize;
} ACE_HEADER;
typedef ACE_HEADER *PACE_HEADER;

//
//  The following are the predefined ace types that go into the AceType
//  field of an Ace header.
//

#define ACCESS_MIN_MS_ACE_TYPE                  (0x0)
#define ACCESS_ALLOWED_ACE_TYPE                 (0x0)
#define ACCESS_DENIED_ACE_TYPE                  (0x1)
#define SYSTEM_AUDIT_ACE_TYPE                   (0x2)
#define SYSTEM_ALARM_ACE_TYPE                   (0x3)
#define ACCESS_MAX_MS_V2_ACE_TYPE               (0x3)

#define ACCESS_ALLOWED_COMPOUND_ACE_TYPE        (0x4)
#define ACCESS_MAX_MS_V3_ACE_TYPE               (0x4)

#define ACCESS_MIN_MS_OBJECT_ACE_TYPE           (0x5)
#define ACCESS_ALLOWED_OBJECT_ACE_TYPE          (0x5)
#define ACCESS_DENIED_OBJECT_ACE_TYPE           (0x6)
#define SYSTEM_AUDIT_OBJECT_ACE_TYPE            (0x7)
#define SYSTEM_ALARM_OBJECT_ACE_TYPE            (0x8)
#define ACCESS_MAX_MS_OBJECT_ACE_TYPE           (0x8)

#define ACCESS_MAX_MS_V4_ACE_TYPE               (0x8)
#define ACCESS_MAX_MS_ACE_TYPE                  (0x8)

#define ACCESS_ALLOWED_CALLBACK_ACE_TYPE        (0x9)
#define ACCESS_DENIED_CALLBACK_ACE_TYPE         (0xA)
#define ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE (0xB)
#define ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE  (0xC)
#define SYSTEM_AUDIT_CALLBACK_ACE_TYPE          (0xD)
#define SYSTEM_ALARM_CALLBACK_ACE_TYPE          (0xE)
#define SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE   (0xF)
#define SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE   (0x10)

#define SYSTEM_MANDATORY_LABEL_ACE_TYPE         (0x11)
#define ACCESS_MAX_MS_V5_ACE_TYPE               (0x11)


//
//  The following are the inherit flags that go into the AceFlags field
//  of an Ace header.
//

#define OBJECT_INHERIT_ACE                (0x1)
#define CONTAINER_INHERIT_ACE             (0x2)
#define NO_PROPAGATE_INHERIT_ACE          (0x4)
#define INHERIT_ONLY_ACE                  (0x8)
#define INHERITED_ACE                     (0x10)
#define VALID_INHERIT_FLAGS               (0x1F)


//  The following are the currently defined ACE flags that go into the
//  AceFlags field of an ACE header.  Each ACE type has its own set of
//  AceFlags.
//
//  SUCCESSFUL_ACCESS_ACE_FLAG - used only with system audit and alarm ACE
//  types to indicate that a message is generated for successful accesses.
//
//  FAILED_ACCESS_ACE_FLAG - used only with system audit and alarm ACE types
//  to indicate that a message is generated for failed accesses.
//

//
//  SYSTEM_AUDIT and SYSTEM_ALARM AceFlags
//
//  These control the signaling of audit and alarms for success or failure.
//

#define SUCCESSFUL_ACCESS_ACE_FLAG       (0x40)
#define FAILED_ACCESS_ACE_FLAG           (0x80)


//
//  We'll define the structure of the predefined ACE types.  Pictorally
//  the structure of the predefined ACE's is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |    AceFlags   | Resd  |Inherit|    AceSize    |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//      |                              Mask                             |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +                              Sid                              +
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +---------------------------------------------------------------+
//
//  Mask is the access mask associated with the ACE.  This is either the
//  access allowed, access denied, audit, or alarm mask.
//
//  Sid is the Sid associated with the ACE.
//

//  The following are the four predefined ACE types.

//  Examine the AceType field in the Header to determine
//  which structure is appropriate to use for casting.


typedef struct _ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_ALLOWED_ACE;

typedef ACCESS_ALLOWED_ACE *PACCESS_ALLOWED_ACE;

typedef struct _ACCESS_DENIED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_DENIED_ACE;
typedef ACCESS_DENIED_ACE *PACCESS_DENIED_ACE;

typedef struct _SYSTEM_AUDIT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;

typedef struct _SYSTEM_ALARM_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_ALARM_ACE;
typedef SYSTEM_ALARM_ACE *PSYSTEM_ALARM_ACE;

typedef struct _SYSTEM_MANDATORY_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_MANDATORY_LABEL_ACE, *PSYSTEM_MANDATORY_LABEL_ACE;

#define SYSTEM_MANDATORY_LABEL_NO_WRITE_UP         0x1
#define SYSTEM_MANDATORY_LABEL_NO_READ_UP          0x2
#define SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP       0x4

#define SYSTEM_MANDATORY_LABEL_VALID_MASK (SYSTEM_MANDATORY_LABEL_NO_WRITE_UP   | \
                                           SYSTEM_MANDATORY_LABEL_NO_READ_UP    | \
                                           SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP)
// end_ntifs


typedef struct _ACCESS_ALLOWED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE, *PACCESS_ALLOWED_OBJECT_ACE;

typedef struct _ACCESS_DENIED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_DENIED_OBJECT_ACE, *PACCESS_DENIED_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_AUDIT_OBJECT_ACE, *PSYSTEM_AUDIT_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_ALARM_OBJECT_ACE, *PSYSTEM_ALARM_OBJECT_ACE;

//
// Callback ace support in post Win2000.
// Resource managers can put their own data after Sidstart + Length of the sid
//

typedef struct _ACCESS_ALLOWED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resouce manager specific data
} ACCESS_ALLOWED_CALLBACK_ACE, *PACCESS_ALLOWED_CALLBACK_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resouce manager specific data
} ACCESS_DENIED_CALLBACK_ACE, *PACCESS_DENIED_CALLBACK_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resouce manager specific data
} SYSTEM_AUDIT_CALLBACK_ACE, *PSYSTEM_AUDIT_CALLBACK_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resouce manager specific data
} SYSTEM_ALARM_CALLBACK_ACE, *PSYSTEM_ALARM_CALLBACK_ACE;

typedef struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resouce manager specific data
} ACCESS_ALLOWED_CALLBACK_OBJECT_ACE, *PACCESS_ALLOWED_CALLBACK_OBJECT_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resouce manager specific data
} ACCESS_DENIED_CALLBACK_OBJECT_ACE, *PACCESS_DENIED_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resouce manager specific data
} SYSTEM_AUDIT_CALLBACK_OBJECT_ACE, *PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resouce manager specific data
} SYSTEM_ALARM_CALLBACK_OBJECT_ACE, *PSYSTEM_ALARM_CALLBACK_OBJECT_ACE;

//
// Currently define Flags for "OBJECT" ACE types.
//

#define ACE_OBJECT_TYPE_PRESENT           0x1
#define ACE_INHERITED_OBJECT_TYPE_PRESENT 0x2


//
//  The following declarations are used for setting and querying information
//  about and ACL.  First are the various information classes available to
//  the user.
//

typedef enum _ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
} ACL_INFORMATION_CLASS;

//
//  This record is returned/sent if the user is requesting/setting the
//  AclRevisionInformation
//

typedef struct _ACL_REVISION_INFORMATION {
    DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef ACL_REVISION_INFORMATION *PACL_REVISION_INFORMATION;

//
//  This record is returned if the user is requesting AclSizeInformation
//

typedef struct _ACL_SIZE_INFORMATION {
    DWORD AceCount;
    DWORD AclBytesInUse;
    DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
typedef ACL_SIZE_INFORMATION *PACL_SIZE_INFORMATION;


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             SECURITY_DESCRIPTOR                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//  Define the Security Descriptor and related data types.
//  This is an opaque data structure.
//

// begin_wdm
//
// Current security descriptor revision value
//

#define SECURITY_DESCRIPTOR_REVISION     (1)
#define SECURITY_DESCRIPTOR_REVISION1    (1)

// end_wdm
// begin_ntifs

#define SECURITY_DESCRIPTOR_MIN_LENGTH   (sizeof(SECURITY_DESCRIPTOR))


typedef WORD   SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;

#define SE_OWNER_DEFAULTED               (0x0001)
#define SE_GROUP_DEFAULTED               (0x0002)
#define SE_DACL_PRESENT                  (0x0004)
#define SE_DACL_DEFAULTED                (0x0008)
#define SE_SACL_PRESENT                  (0x0010)
#define SE_SACL_DEFAULTED                (0x0020)
#define SE_DACL_AUTO_INHERIT_REQ         (0x0100)
#define SE_SACL_AUTO_INHERIT_REQ         (0x0200)
#define SE_DACL_AUTO_INHERITED           (0x0400)
#define SE_SACL_AUTO_INHERITED           (0x0800)
#define SE_DACL_PROTECTED                (0x1000)
#define SE_SACL_PROTECTED                (0x2000)
#define SE_RM_CONTROL_VALID              (0x4000)
#define SE_SELF_RELATIVE                 (0x8000)

//
//  Where:
//
//      SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the
//          SID pointed to by the Owner field was provided by a
//          defaulting mechanism rather than explicitly provided by the
//          original provider of the security descriptor.  This may
//          affect the treatment of the SID with respect to inheritence
//          of an owner.
//
//      SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the
//          SID in the Group field was provided by a defaulting mechanism
//          rather than explicitly provided by the original provider of
//          the security descriptor.  This may affect the treatment of
//          the SID with respect to inheritence of a primary group.
//
//      SE_DACL_PRESENT - This boolean flag, when set, indicates that the
//          security descriptor contains a discretionary ACL.  If this
//          flag is set and the Dacl field of the SECURITY_DESCRIPTOR is
//          null, then a null ACL is explicitly being specified.
//
//      SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Dacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the DaclPresent flag is not set.
//
//      SE_SACL_PRESENT - This boolean flag, when set,  indicates that the
//          security descriptor contains a system ACL pointed to by the
//          Sacl field.  If this flag is set and the Sacl field of the
//          SECURITY_DESCRIPTOR is null, then an empty (but present)
//          ACL is being specified.
//
//      SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Sacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the SaclPresent flag is not set.
//
//      SE_SELF_RELATIVE - This boolean flag, when set, indicates that the
//          security descriptor is in self-relative form.  In this form,
//          all fields of the security descriptor are contiguous in memory
//          and all pointer fields are expressed as offsets from the
//          beginning of the security descriptor.  This form is useful
//          for treating security descriptors as opaque data structures
//          for transmission in communication protocol or for storage on
//          secondary media.
//
//
//
// Pictorially the structure of a security descriptor is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------------------------------------------------------+
//      |            Control            |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                            Owner                              |
//      +---------------------------------------------------------------+
//      |                            Group                              |
//      +---------------------------------------------------------------+
//      |                            Sacl                               |
//      +---------------------------------------------------------------+
//      |                            Dacl                               |
//      +---------------------------------------------------------------+
//
// In general, this data structure should be treated opaquely to ensure future
// compatibility.
//
//

typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
    BYTE  Revision;
    BYTE  Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD Owner;
    DWORD Group;
    DWORD Sacl;
    DWORD Dacl;
    } SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;

typedef struct _SECURITY_DESCRIPTOR {
   BYTE  Revision;
   BYTE  Sbz1;
   SECURITY_DESCRIPTOR_CONTROL Control;
   PSID Owner;
   PSID Group;
   PACL Sacl;
   PACL Dacl;

   } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;

// end_ntifs

// Where:
//
//     Revision - Contains the revision level of the security
//         descriptor.  This allows this structure to be passed between
//         systems or stored on disk even though it is expected to
//         change in the future.
//
//     Control - A set of flags which qualify the meaning of the
//         security descriptor or individual fields of the security
//         descriptor.
//
//     Owner - is a pointer to an SID representing an object's owner.
//         If this field is null, then no owner SID is present in the
//         security descriptor.  If the security descriptor is in
//         self-relative form, then this field contains an offset to
//         the SID, rather than a pointer.
//
//     Group - is a pointer to an SID representing an object's primary
//         group.  If this field is null, then no primary group SID is
//         present in the security descriptor.  If the security descriptor
//         is in self-relative form, then this field contains an offset to
//         the SID, rather than a pointer.
//
//     Sacl - is a pointer to a system ACL.  This field value is only
//         valid if the DaclPresent control flag is set.  If the
//         SaclPresent flag is set and this field is null, then a null
//         ACL  is specified.  If the security descriptor is in
//         self-relative form, then this field contains an offset to
//         the ACL, rather than a pointer.
//
//     Dacl - is a pointer to a discretionary ACL.  This field value is
//         only valid if the DaclPresent control flag is set.  If the
//         DaclPresent flag is set and this field is null, then a null
//         ACL (unconditionally granting access) is specified.  If the
//         security descriptor is in self-relative form, then this field
//         contains an offset to the ACL, rather than a pointer.
//




////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Object Type list for AccessCheckByType               //
//                                                                    //
////////////////////////////////////////////////////////////////////////

typedef struct _OBJECT_TYPE_LIST {
    WORD   Level;
    WORD   Sbz;
    GUID *ObjectType;
} OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;

//
// DS values for Level
//

#define ACCESS_OBJECT_GUID       0
#define ACCESS_PROPERTY_SET_GUID 1
#define ACCESS_PROPERTY_GUID     2

#define ACCESS_MAX_LEVEL         4

//
// Parameters to NtAccessCheckByTypeAndAditAlarm
//

typedef enum _AUDIT_EVENT_TYPE {
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess
} AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;

#define AUDIT_ALLOW_NO_PRIVILEGE 0x1

//
// DS values for Source and ObjectTypeName
//

#define ACCESS_DS_SOURCE_A "DS"
#define ACCESS_DS_SOURCE_W L"DS"
#define ACCESS_DS_OBJECT_TYPE_NAME_A "Directory Service Object"
#define ACCESS_DS_OBJECT_TYPE_NAME_W L"Directory Service Object"

////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Privilege Related Data Structures                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////

// end_ntifs
// begin_wdm
//
// Privilege attributes
//

#define SE_PRIVILEGE_ENABLED_BY_DEFAULT (0x00000001L)
#define SE_PRIVILEGE_ENABLED            (0x00000002L)
#define SE_PRIVILEGE_REMOVED            (0X00000004L)
#define SE_PRIVILEGE_USED_FOR_ACCESS    (0x80000000L)

#define SE_PRIVILEGE_VALID_ATTRIBUTES   (SE_PRIVILEGE_ENABLED_BY_DEFAULT | \
                                         SE_PRIVILEGE_ENABLED            | \
                                         SE_PRIVILEGE_REMOVED            | \
                                         SE_PRIVILEGE_USED_FOR_ACCESS)


//
// Privilege Set Control flags
//

#define PRIVILEGE_SET_ALL_NECESSARY    (1)

//
//  Privilege Set - This is defined for a privilege set of one.
//                  If more than one privilege is needed, then this structure
//                  will need to be allocated with more space.
//
//  Note: don't change this structure without fixing the INITIAL_PRIVILEGE_SET
//  structure (defined in se.h)
//

typedef struct _PRIVILEGE_SET {
    DWORD PrivilegeCount;
    DWORD Control;
    LUID_AND_ATTRIBUTES Privilege[ANYSIZE_ARRAY];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;




//
// Values for different access granted\denied reasons:
// AccessReasonAceN = AccessReasonAce + N.
// AccessReasonPrivilegeN = AccessReasonPrivilege + N.
//

#define ACCESS_REASON_TYPE_MASK 0xffff0000
#define ACCESS_REASON_DATA_MASK 0x0000ffff

typedef enum _ACCESS_REASON_TYPE{

    AccessReasonNone = 0x00000000,  // Indicate no reason for the bit. The bit may not be checked, or just no known reason.

    //
    // The lowest 2 bytes store the index of the ACE that grant/deny this bit.
    // If the corresponding access maskt is zero, then it is deny ACE; otherwise,
    // it is allow ACE.
    //
    AccessReasonAllowedAce = 0x00010000,    // Granted a permission.
    AccessReasonDeniedAce = 0x00020000,     // Denied a permission.

    AccessReasonAllowedParentAce = 0x00030000,    // Granted a permission from parent ACE
    AccessReasonDeniedParentAce = 0x00040000,     // Denied a permission from parent ACE

    AccessReasonMissingPrivilege = 0x00100000,
    AccessReasonFromPrivilege = 0x00200000,


    AccessReasonIntegrityLevel = 0x00300000,

    AccessReasonOwnership = 0x00400000,

    AccessReasonNullDacl = 0x00500000,
    AccessReasonEmptyDacl = 0x00600000,

    AccessReasonNoSD = 0x00700000,
    AccessReasonNoGrant = 0x00800000    // this access bit is not granted by any ACE.
} ACCESS_REASON_TYPE;

 //
// Structure to hold access denied\granted reason for every bit of ACCESS_MASK.
// There are 32-bits in ACCESS_MASK and only 27-bits are actually valid on
// return from AccessCheck because MAXIMUM_ALLOWED, GENERIC_READ,
// GENERIC_WRITE, GENERIC_EXECUTE, and GENERIC_ALL are never returned.
//
// The content in Data fields depends on the Access Reason, for example,
// if the reason is AccessReasonAce, the Data will be the ACE ID.
// If there are more than one reason (more than one bit is set), the array size
// of the Data is equal to the number of bits set (or number of reasons).
// The Data could be null for a particular reason.
//

typedef DWORD ACCESS_REASON;

typedef struct _ACCESS_REASONS{
        ACCESS_REASON Data[32];
} ACCESS_REASONS, *PACCESS_REASONS;


/*
The following data structures are defined to consolidate various falvors of
access check functions. In particular for Windows 7, the new access check
function will enable security attribute check, plus returning the reason
for a access check result.

The new access check function based on these data structures will
form the foundation to reimplement other flavors of access check
functions.

*/

//
// Structure to hold pointer to security descriptor and its unique id, which
// can be used for caching access check results.
// (NOTE NOTE) The cache key can be constructed by SecurityDescriptorId, Token and
// PrincipalSelfSid. Watch how GenericMapping affects the cache results.
//
#define SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE    0x00000001
#define SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE    0x00000002
#define SE_SECURITY_DESCRIPTOR_VALID_FLAGS          0x00000003

typedef struct _SE_SECURITY_DESCRIPTOR
{
    DWORD Size;
    DWORD Flags;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
} SE_SECURITY_DESCRIPTOR, *PSE_SECURITY_DESCRIPTOR;

typedef struct _SE_ACCESS_REQUEST
{
    DWORD Size;
    PSE_SECURITY_DESCRIPTOR SeSecurityDescriptor;
    ACCESS_MASK DesiredAccess;
    ACCESS_MASK PreviouslyGrantedAccess;
    PSID PrincipalSelfSid;      // Need to watch how this field affects the cache.
    PGENERIC_MAPPING GenericMapping;
    DWORD ObjectTypeListCount;
    POBJECT_TYPE_LIST ObjectTypeList;
} SE_ACCESS_REQUEST, *PSE_ACCESS_REQUEST;


typedef struct _SE_ACCESS_REPLY
{
    DWORD Size;
    DWORD ResultListCount;  // Indicate the array size of GrantedAccess and AccessStatus, it only can be either 1 or ObjectTypeListCount.
    PACCESS_MASK GrantedAccess;
    PDWORD    AccessStatus;
    PACCESS_REASONS AccessReason;
    PPRIVILEGE_SET* Privileges;
} SE_ACCESS_REPLY, *PSE_ACCESS_REPLY;


////////////////////////////////////////////////////////////////////////
//                                                                    //
//               NT Defined Privileges                                //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#define SE_CREATE_TOKEN_NAME              TEXT("SeCreateTokenPrivilege")
#define SE_ASSIGNPRIMARYTOKEN_NAME        TEXT("SeAssignPrimaryTokenPrivilege")
#define SE_LOCK_MEMORY_NAME               TEXT("SeLockMemoryPrivilege")
#define SE_INCREASE_QUOTA_NAME            TEXT("SeIncreaseQuotaPrivilege")
#define SE_UNSOLICITED_INPUT_NAME         TEXT("SeUnsolicitedInputPrivilege")
#define SE_MACHINE_ACCOUNT_NAME           TEXT("SeMachineAccountPrivilege")
#define SE_TCB_NAME                       TEXT("SeTcbPrivilege")
#define SE_SECURITY_NAME                  TEXT("SeSecurityPrivilege")
#define SE_TAKE_OWNERSHIP_NAME            TEXT("SeTakeOwnershipPrivilege")
#define SE_LOAD_DRIVER_NAME               TEXT("SeLoadDriverPrivilege")
#define SE_SYSTEM_PROFILE_NAME            TEXT("SeSystemProfilePrivilege")
#define SE_SYSTEMTIME_NAME                TEXT("SeSystemtimePrivilege")
#define SE_PROF_SINGLE_PROCESS_NAME       TEXT("SeProfileSingleProcessPrivilege")
#define SE_INC_BASE_PRIORITY_NAME         TEXT("SeIncreaseBasePriorityPrivilege")
#define SE_CREATE_PAGEFILE_NAME           TEXT("SeCreatePagefilePrivilege")
#define SE_CREATE_PERMANENT_NAME          TEXT("SeCreatePermanentPrivilege")
#define SE_BACKUP_NAME                    TEXT("SeBackupPrivilege")
#define SE_RESTORE_NAME                   TEXT("SeRestorePrivilege")
#define SE_SHUTDOWN_NAME                  TEXT("SeShutdownPrivilege")
#define SE_DEBUG_NAME                     TEXT("SeDebugPrivilege")
#define SE_AUDIT_NAME                     TEXT("SeAuditPrivilege")
#define SE_SYSTEM_ENVIRONMENT_NAME        TEXT("SeSystemEnvironmentPrivilege")
#define SE_CHANGE_NOTIFY_NAME             TEXT("SeChangeNotifyPrivilege")
#define SE_REMOTE_SHUTDOWN_NAME           TEXT("SeRemoteShutdownPrivilege")
#define SE_UNDOCK_NAME                    TEXT("SeUndockPrivilege")
#define SE_SYNC_AGENT_NAME                TEXT("SeSyncAgentPrivilege")
#define SE_ENABLE_DELEGATION_NAME         TEXT("SeEnableDelegationPrivilege")
#define SE_MANAGE_VOLUME_NAME             TEXT("SeManageVolumePrivilege")
#define SE_IMPERSONATE_NAME               TEXT("SeImpersonatePrivilege")
#define SE_CREATE_GLOBAL_NAME             TEXT("SeCreateGlobalPrivilege")
#define SE_TRUSTED_CREDMAN_ACCESS_NAME    TEXT("SeTrustedCredManAccessPrivilege")
#define SE_RELABEL_NAME                   TEXT("SeRelabelPrivilege")
#define SE_INC_WORKING_SET_NAME           TEXT("SeIncreaseWorkingSetPrivilege")
#define SE_TIME_ZONE_NAME                 TEXT("SeTimeZonePrivilege")
#define SE_CREATE_SYMBOLIC_LINK_NAME      TEXT("SeCreateSymbolicLinkPrivilege")



////////////////////////////////////////////////////////////////////
//                                                                //
//           Security Quality Of Service                          //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////

// begin_wdm
//
// Impersonation Level
//
// Impersonation level is represented by a pair of bits in Windows.
// If a new impersonation level is added or lowest value is changed from
// 0 to something else, fix the Windows CreateFile call.
//

typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
    } SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;

#define SECURITY_MAX_IMPERSONATION_LEVEL SecurityDelegation
#define SECURITY_MIN_IMPERSONATION_LEVEL SecurityAnonymous
#define DEFAULT_IMPERSONATION_LEVEL SecurityImpersonation
#define VALID_IMPERSONATION_LEVEL(L) (((L) >= SECURITY_MIN_IMPERSONATION_LEVEL) && ((L) <= SECURITY_MAX_IMPERSONATION_LEVEL))


////////////////////////////////////////////////////////////////////
//                                                                //
//           Token Object Definitions                             //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////


//
// Token Specific Access Rights.
//

#define TOKEN_ASSIGN_PRIMARY    (0x0001)
#define TOKEN_DUPLICATE         (0x0002)
#define TOKEN_IMPERSONATE       (0x0004)
#define TOKEN_QUERY             (0x0008)
#define TOKEN_QUERY_SOURCE      (0x0010)
#define TOKEN_ADJUST_PRIVILEGES (0x0020)
#define TOKEN_ADJUST_GROUPS     (0x0040)
#define TOKEN_ADJUST_DEFAULT    (0x0080)
#define TOKEN_ADJUST_SESSIONID  (0x0100)

#define TOKEN_ALL_ACCESS_P (STANDARD_RIGHTS_REQUIRED  |\
                          TOKEN_ASSIGN_PRIMARY      |\
                          TOKEN_DUPLICATE           |\
                          TOKEN_IMPERSONATE         |\
                          TOKEN_QUERY               |\
                          TOKEN_QUERY_SOURCE        |\
                          TOKEN_ADJUST_PRIVILEGES   |\
                          TOKEN_ADJUST_GROUPS       |\
                          TOKEN_ADJUST_DEFAULT )

#if ((defined(_WIN32_WINNT) && (_WIN32_WINNT > 0x0400)) || (!defined(_WIN32_WINNT)))
#define TOKEN_ALL_ACCESS  (TOKEN_ALL_ACCESS_P |\
                          TOKEN_ADJUST_SESSIONID )
#else
#define TOKEN_ALL_ACCESS  (TOKEN_ALL_ACCESS_P)
#endif

#define TOKEN_READ       (STANDARD_RIGHTS_READ      |\
                          TOKEN_QUERY)


#define TOKEN_WRITE      (STANDARD_RIGHTS_WRITE     |\
                          TOKEN_ADJUST_PRIVILEGES   |\
                          TOKEN_ADJUST_GROUPS       |\
                          TOKEN_ADJUST_DEFAULT)

#define TOKEN_EXECUTE    (STANDARD_RIGHTS_EXECUTE)

//
//
// Token Types
//

typedef enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
    } TOKEN_TYPE;
typedef TOKEN_TYPE *PTOKEN_TYPE;

//
// Token elevation values describe the relative strength of a given token.
// A full token is a token with all groups and privileges to which the principal
// is authorized.  A limited token is one with some groups or privileges removed.
//

typedef enum _TOKEN_ELEVATION_TYPE {
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull,
    TokenElevationTypeLimited,
} TOKEN_ELEVATION_TYPE, *PTOKEN_ELEVATION_TYPE;

//
// Token Information Classes.
//


typedef enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin,
    TokenElevationType,
    TokenLinkedToken,
    TokenElevation,
    TokenHasRestrictions,
    TokenAccessInformation,
    TokenVirtualizationAllowed,
    TokenVirtualizationEnabled,
    TokenIntegrityLevel,
    TokenUIAccess,
    TokenMandatoryPolicy,
    TokenLogonSid,
    MaxTokenInfoClass  // MaxTokenInfoClass should always be the last enum
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;

//
// Token information class structures
//


typedef struct _TOKEN_USER {
    SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;

typedef struct _TOKEN_GROUPS {
    DWORD GroupCount;
#ifdef MIDL_PASS
    [size_is(GroupCount)] SID_AND_ATTRIBUTES Groups[*];
#else // MIDL_PASS
    SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];
#endif // MIDL_PASS
} TOKEN_GROUPS, *PTOKEN_GROUPS;


typedef struct _TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;


typedef struct _TOKEN_OWNER {
    PSID Owner;
} TOKEN_OWNER, *PTOKEN_OWNER;


typedef struct _TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;


typedef struct _TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;

typedef struct _TOKEN_GROUPS_AND_PRIVILEGES {
    DWORD SidCount;
    DWORD SidLength;
    PSID_AND_ATTRIBUTES Sids;
    DWORD RestrictedSidCount;
    DWORD RestrictedSidLength;
    PSID_AND_ATTRIBUTES RestrictedSids;
    DWORD PrivilegeCount;
    DWORD PrivilegeLength;
    PLUID_AND_ATTRIBUTES Privileges;
    LUID AuthenticationId;
} TOKEN_GROUPS_AND_PRIVILEGES, *PTOKEN_GROUPS_AND_PRIVILEGES;

typedef struct _TOKEN_LINKED_TOKEN {
    HANDLE LinkedToken;
} TOKEN_LINKED_TOKEN, *PTOKEN_LINKED_TOKEN;

typedef struct _TOKEN_ELEVATION {
    DWORD TokenIsElevated;
} TOKEN_ELEVATION, *PTOKEN_ELEVATION;

typedef struct _TOKEN_MANDATORY_LABEL {
    SID_AND_ATTRIBUTES Label;
} TOKEN_MANDATORY_LABEL, *PTOKEN_MANDATORY_LABEL;

#define TOKEN_MANDATORY_POLICY_OFF             0x0
#define TOKEN_MANDATORY_POLICY_NO_WRITE_UP     0x1
#define TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN 0x2

#define TOKEN_MANDATORY_POLICY_VALID_MASK      (TOKEN_MANDATORY_POLICY_NO_WRITE_UP | \
                                                TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN)

typedef struct _TOKEN_MANDATORY_POLICY {
    DWORD Policy;
} TOKEN_MANDATORY_POLICY, *PTOKEN_MANDATORY_POLICY;

typedef struct _TOKEN_ACCESS_INFORMATION {
    PSID_AND_ATTRIBUTES_HASH SidHash;
    PSID_AND_ATTRIBUTES_HASH RestrictedSidHash;
    PTOKEN_PRIVILEGES Privileges;
    LUID AuthenticationId;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    TOKEN_MANDATORY_POLICY MandatoryPolicy;
    DWORD Flags;
} TOKEN_ACCESS_INFORMATION, *PTOKEN_ACCESS_INFORMATION;

//
// Valid bits for each TOKEN_AUDIT_POLICY policy mask field.
//

#define POLICY_AUDIT_SUBCATEGORY_COUNT (53)

typedef struct _TOKEN_AUDIT_POLICY {
    BYTE  PerUserPolicy[((POLICY_AUDIT_SUBCATEGORY_COUNT) >> 1) + 1];
} TOKEN_AUDIT_POLICY, *PTOKEN_AUDIT_POLICY;

#define TOKEN_SOURCE_LENGTH 8

typedef struct _TOKEN_SOURCE {
    CHAR SourceName[TOKEN_SOURCE_LENGTH];
    LUID SourceIdentifier;
} TOKEN_SOURCE, *PTOKEN_SOURCE;


typedef struct _TOKEN_STATISTICS {
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD DynamicCharged;
    DWORD DynamicAvailable;
    DWORD GroupCount;
    DWORD PrivilegeCount;
    LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;



typedef struct _TOKEN_CONTROL {
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL, *PTOKEN_CONTROL;

typedef struct _TOKEN_ORIGIN {
    LUID OriginatingLogonSession ;
} TOKEN_ORIGIN, * PTOKEN_ORIGIN ;


typedef enum _MANDATORY_LEVEL {
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow,
    MandatoryLevelMedium,
    MandatoryLevelHigh,
    MandatoryLevelSystem,
    MandatoryLevelSecureProcess,
    MandatoryLevelCount
} MANDATORY_LEVEL, *PMANDATORY_LEVEL;




//
// Security Tracking Mode
//

#define SECURITY_DYNAMIC_TRACKING      (TRUE)
#define SECURITY_STATIC_TRACKING       (FALSE)

typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
                    * PSECURITY_CONTEXT_TRACKING_MODE;



//
// Quality Of Service
//

typedef struct _SECURITY_QUALITY_OF_SERVICE {
    DWORD Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
    } SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;


//
// Used to represent information related to a thread impersonation
//

typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;

#define DISABLE_MAX_PRIVILEGE   0x1 
#define SANDBOX_INERT           0x2 
#define LUA_TOKEN               0x4 
#define WRITE_RESTRICTED        0x8 

typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;

#define OWNER_SECURITY_INFORMATION       (0x00000001L)
#define GROUP_SECURITY_INFORMATION       (0x00000002L)
#define DACL_SECURITY_INFORMATION        (0x00000004L)
#define SACL_SECURITY_INFORMATION        (0x00000008L)
#define LABEL_SECURITY_INFORMATION       (0x00000010L)

#define PROTECTED_DACL_SECURITY_INFORMATION     (0x80000000L)
#define PROTECTED_SACL_SECURITY_INFORMATION     (0x40000000L)
#define UNPROTECTED_DACL_SECURITY_INFORMATION   (0x20000000L)
#define UNPROTECTED_SACL_SECURITY_INFORMATION   (0x10000000L)

#define PROCESS_TERMINATE                  (0x0001)  
#define PROCESS_CREATE_THREAD              (0x0002)  
#define PROCESS_SET_SESSIONID              (0x0004)  
#define PROCESS_VM_OPERATION               (0x0008)  
#define PROCESS_VM_READ                    (0x0010)  
#define PROCESS_VM_WRITE                   (0x0020)  
#define PROCESS_DUP_HANDLE                 (0x0040)  
#define PROCESS_CREATE_PROCESS             (0x0080)  
#define PROCESS_SET_QUOTA                  (0x0100)  
#define PROCESS_SET_INFORMATION            (0x0200)  
#define PROCESS_QUERY_INFORMATION          (0x0400)  
#define PROCESS_SUSPEND_RESUME             (0x0800)  
#define PROCESS_QUERY_LIMITED_INFORMATION  (0x1000)  
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFFF)
#else
#define PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFF)
#endif

#if defined(_WIN64)

#define MAXIMUM_PROC_PER_GROUP 64

#else

#define MAXIMUM_PROC_PER_GROUP 32

#endif

#define MAXIMUM_PROCESSORS          MAXIMUM_PROC_PER_GROUP

#define THREAD_TERMINATE                 (0x0001)  
#define THREAD_SUSPEND_RESUME            (0x0002)  
#define THREAD_GET_CONTEXT               (0x0008)  
#define THREAD_SET_CONTEXT               (0x0010)  
#define THREAD_QUERY_INFORMATION         (0x0040)  
#define THREAD_SET_INFORMATION           (0x0020)  
#define THREAD_SET_THREAD_TOKEN          (0x0080)
#define THREAD_IMPERSONATE               (0x0100)
#define THREAD_DIRECT_IMPERSONATION      (0x0200)
// begin_wdm
#define THREAD_SET_LIMITED_INFORMATION   (0x0400)  // winnt
#define THREAD_QUERY_LIMITED_INFORMATION (0x0800)  // winnt
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define THREAD_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFFF)
#else
#define THREAD_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0x3FF)
#endif
#define JOB_OBJECT_ASSIGN_PROCESS           (0x0001)
#define JOB_OBJECT_SET_ATTRIBUTES           (0x0002)
#define JOB_OBJECT_QUERY                    (0x0004)
#define JOB_OBJECT_TERMINATE                (0x0008)
#define JOB_OBJECT_SET_SECURITY_ATTRIBUTES  (0x0010)
#define JOB_OBJECT_ALL_ACCESS       (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                        0x1F )

typedef struct _JOB_SET_ARRAY {
    HANDLE JobHandle;   // Handle to job object to insert
    DWORD MemberLevel;  // Level of this job in the set. Must be > 0. Can be sparse.
    DWORD Flags;        // Unused. Must be zero
} JOB_SET_ARRAY, *PJOB_SET_ARRAY;

#define FLS_MAXIMUM_AVAILABLE 128   
#define TLS_MINIMUM_AVAILABLE 64    

typedef struct _NT_TIB {
    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;
#if defined(_MSC_EXTENSIONS)
    union {
        PVOID FiberData;
        DWORD Version;
    };
#else
    PVOID FiberData;
#endif
    PVOID ArbitraryUserPointer;
    struct _NT_TIB *Self;
} NT_TIB;
typedef NT_TIB *PNT_TIB;

//
// 32 and 64 bit specific version for wow64 and the debugger
//
typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;

#if defined(_MSC_EXTENSIONS)
    union {
        DWORD FiberData;
        DWORD Version;
    };
#else
    DWORD FiberData;
#endif

    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;

#if defined(_MSC_EXTENSIONS)
    union {
        DWORD64 FiberData;
        DWORD Version;
    };

#else
    DWORD64 FiberData;
#endif

    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;



#define THREAD_BASE_PRIORITY_LOWRT  15  // value that gets a thread to LowRealtime-1
#define THREAD_BASE_PRIORITY_MAX    2   // maximum thread base priority boost
#define THREAD_BASE_PRIORITY_MIN    (-2)  // minimum thread base priority boost
#define THREAD_BASE_PRIORITY_IDLE   (-15) // value that gets a thread to idle

typedef struct _UMS_CREATE_THREAD_ATTRIBUTES {  
    DWORD UmsVersion;   
        PVOID UmsContext;   
        PVOID UmsCompletionList;   
} UMS_CREATE_THREAD_ATTRIBUTES, *PUMS_CREATE_THREAD_ATTRIBUTES; 

typedef struct _QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;

#define QUOTA_LIMITS_HARDWS_MIN_ENABLE  0x00000001
#define QUOTA_LIMITS_HARDWS_MIN_DISABLE 0x00000002
#define QUOTA_LIMITS_HARDWS_MAX_ENABLE  0x00000004
#define QUOTA_LIMITS_HARDWS_MAX_DISABLE 0x00000008
#define QUOTA_LIMITS_USE_DEFAULT_LIMITS 0x00000010

typedef union _RATE_QUOTA_LIMIT {
    DWORD RateData;
    struct {
        DWORD RatePercent : 7;
        DWORD Reserved0   : 25;
    } DUMMYSTRUCTNAME;
} RATE_QUOTA_LIMIT, *PRATE_QUOTA_LIMIT;

typedef struct _QUOTA_LIMITS_EX {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;               // Limit expressed in pages
    LARGE_INTEGER TimeLimit;
    SIZE_T WorkingSetLimit;             // Limit expressed in pages
    SIZE_T Reserved2;
    SIZE_T Reserved3;
    SIZE_T Reserved4;
    DWORD  Flags;
    RATE_QUOTA_LIMIT CpuRateLimit;
} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;

typedef struct _IO_COUNTERS {
    ULONGLONG  ReadOperationCount;
    ULONGLONG  WriteOperationCount;
    ULONGLONG  OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;

#define MAX_HW_COUNTERS 16
#define THREAD_PROFILING_FLAG_DISPATCH  0x00000001

typedef enum _HARDWARE_COUNTER_TYPE {
    PMCCounter,
    MaxHardwareCounterType
} HARDWARE_COUNTER_TYPE, *PHARDWARE_COUNTER_TYPE;

typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    LARGE_INTEGER TotalUserTime;
    LARGE_INTEGER TotalKernelTime;
    LARGE_INTEGER ThisPeriodTotalUserTime;
    LARGE_INTEGER ThisPeriodTotalKernelTime;
    DWORD TotalPageFaultCount;
    DWORD TotalProcesses;
    DWORD ActiveProcesses;
    DWORD TotalTerminatedProcesses;
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
    LARGE_INTEGER PerProcessUserTimeLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD LimitFlags;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    DWORD ActiveProcessLimit;
    ULONG_PTR Affinity;
    DWORD PriorityClass;
    DWORD SchedulingClass;
} JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    IO_COUNTERS IoInfo;
    SIZE_T ProcessMemoryLimit;
    SIZE_T JobMemoryLimit;
    SIZE_T PeakProcessMemoryUsed;
    SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
    DWORD NumberOfAssignedProcesses;
    DWORD NumberOfProcessIdsInList;
    ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;

typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
    DWORD UIRestrictionsClass;
} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;

//
// N.B. The JOBOBJECT_SECURITY_LIMIT_INFORMATION information class is no longer supported.
//

typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    DWORD SecurityLimitFlags ;
    HANDLE JobToken ;
    PTOKEN_GROUPS SidsToDisable ;
    PTOKEN_PRIVILEGES PrivilegesToDelete ;
    PTOKEN_GROUPS RestrictedSids ;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION ;

typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    DWORD EndOfJobTimeAction;
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;

typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    PVOID CompletionKey;
    HANDLE CompletionPort;
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;

typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_JOBSET_INFORMATION {
    DWORD MemberLevel;
} JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION;

#define JOB_OBJECT_TERMINATE_AT_END_OF_JOB  0
#define JOB_OBJECT_POST_AT_END_OF_JOB       1

//
// Completion Port Messages for job objects
//
// These values are returned via the lpNumberOfBytesTransferred parameter
//

#define JOB_OBJECT_MSG_END_OF_JOB_TIME          1
#define JOB_OBJECT_MSG_END_OF_PROCESS_TIME      2
#define JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT     3
#define JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO      4
#define JOB_OBJECT_MSG_NEW_PROCESS              6
#define JOB_OBJECT_MSG_EXIT_PROCESS             7
#define JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS    8
#define JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT     9
#define JOB_OBJECT_MSG_JOB_MEMORY_LIMIT         10

//
// Basic Limits
//
#define JOB_OBJECT_LIMIT_WORKINGSET                 0x00000001
#define JOB_OBJECT_LIMIT_PROCESS_TIME               0x00000002
#define JOB_OBJECT_LIMIT_JOB_TIME                   0x00000004
#define JOB_OBJECT_LIMIT_ACTIVE_PROCESS             0x00000008
#define JOB_OBJECT_LIMIT_AFFINITY                   0x00000010
#define JOB_OBJECT_LIMIT_PRIORITY_CLASS             0x00000020
#define JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME          0x00000040
#define JOB_OBJECT_LIMIT_SCHEDULING_CLASS           0x00000080

//
// Extended Limits
//
#define JOB_OBJECT_LIMIT_PROCESS_MEMORY             0x00000100
#define JOB_OBJECT_LIMIT_JOB_MEMORY                 0x00000200
#define JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION 0x00000400
#define JOB_OBJECT_LIMIT_BREAKAWAY_OK               0x00000800
#define JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK        0x00001000
#define JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE          0x00002000

#define JOB_OBJECT_LIMIT_SUBSET_AFFINITY            0x00004000
#define JOB_OBJECT_LIMIT_RESERVED3                  0x00008000
#define JOB_OBJECT_LIMIT_RESERVED4                  0x00010000
#define JOB_OBJECT_LIMIT_RESERVED5                  0x00020000
#define JOB_OBJECT_LIMIT_RESERVED6                  0x00040000


#define JOB_OBJECT_LIMIT_VALID_FLAGS            0x0007ffff

#define JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS      0x000000ff
#define JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS   0x00007fff
#define JOB_OBJECT_RESERVED_LIMIT_VALID_FLAGS   0x0007ffff

//
// UI restrictions for jobs
//

#define JOB_OBJECT_UILIMIT_NONE             0x00000000

#define JOB_OBJECT_UILIMIT_HANDLES          0x00000001
#define JOB_OBJECT_UILIMIT_READCLIPBOARD    0x00000002
#define JOB_OBJECT_UILIMIT_WRITECLIPBOARD   0x00000004
#define JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS 0x00000008
#define JOB_OBJECT_UILIMIT_DISPLAYSETTINGS  0x00000010
#define JOB_OBJECT_UILIMIT_GLOBALATOMS      0x00000020
#define JOB_OBJECT_UILIMIT_DESKTOP          0x00000040
#define JOB_OBJECT_UILIMIT_EXITWINDOWS      0x00000080

#define JOB_OBJECT_UILIMIT_ALL              0x000000FF

#define JOB_OBJECT_UI_VALID_FLAGS           0x000000FF

#define JOB_OBJECT_SECURITY_NO_ADMIN            0x00000001
#define JOB_OBJECT_SECURITY_RESTRICTED_TOKEN    0x00000002
#define JOB_OBJECT_SECURITY_ONLY_TOKEN          0x00000004
#define JOB_OBJECT_SECURITY_FILTER_TOKENS       0x00000008

#define JOB_OBJECT_SECURITY_VALID_FLAGS         0x0000000f

typedef enum _JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,  // deprecated
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    JobObjectBasicAndIoAccountingInformation,
    JobObjectExtendedLimitInformation,
    JobObjectJobSetInformation,
    JobObjectGroupInformation,
    MaxJobObjectInfoClass
    } JOBOBJECTINFOCLASS;

//
#define EVENT_MODIFY_STATE      0x0002  
#define EVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

#define MUTANT_QUERY_STATE      0x0001

#define MUTANT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|\
                          MUTANT_QUERY_STATE)

#define SEMAPHORE_MODIFY_STATE      0x0002  
#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

//
// Timer Specific Access Rights.
//

#define TIMER_QUERY_STATE       0x0001
#define TIMER_MODIFY_STATE      0x0002

#define TIMER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|\
                          TIMER_QUERY_STATE|TIMER_MODIFY_STATE)


#define TIME_ZONE_ID_UNKNOWN  0
#define TIME_ZONE_ID_STANDARD 1
#define TIME_ZONE_ID_DAYLIGHT 2


typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationProcessorCore,
    RelationNumaNode,
    RelationCache,
    RelationProcessorPackage,
    RelationGroup,
    RelationAll = 0xffff
} LOGICAL_PROCESSOR_RELATIONSHIP;

#define LTP_PC_SMT 0x1

typedef enum _PROCESSOR_CACHE_TYPE {
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace
} PROCESSOR_CACHE_TYPE;

#define CACHE_FULLY_ASSOCIATIVE 0xFF

typedef struct _CACHE_DESCRIPTOR {
    BYTE   Level;
    BYTE   Associativity;
    WORD   LineSize;
    DWORD  Size;
    PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    ULONG_PTR   ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    union {
        struct {
            BYTE  Flags;
        } ProcessorCore;
        struct {
            DWORD NodeNumber;
        } NumaNode;
        CACHE_DESCRIPTOR Cache;
        ULONGLONG  Reserved[2];
    } DUMMYUNIONNAME;
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;

typedef struct _PROCESSOR_RELATIONSHIP {
    BYTE  Flags;
    BYTE  Reserved[21];
    WORD   GroupCount;
    __field_ecount(GroupCount) GROUP_AFFINITY GroupMask[ANYSIZE_ARRAY];
} PROCESSOR_RELATIONSHIP, *PPROCESSOR_RELATIONSHIP;

typedef struct _NUMA_NODE_RELATIONSHIP {
    DWORD NodeNumber;
    BYTE  Reserved[20];
    GROUP_AFFINITY GroupMask;
} NUMA_NODE_RELATIONSHIP, *PNUMA_NODE_RELATIONSHIP;

typedef struct _CACHE_RELATIONSHIP {
    BYTE  Level;
    BYTE  Associativity;
    WORD   LineSize;
    DWORD CacheSize;
    PROCESSOR_CACHE_TYPE Type;
    BYTE  Reserved[20];
    GROUP_AFFINITY GroupMask;
} CACHE_RELATIONSHIP, *PCACHE_RELATIONSHIP;

typedef struct _PROCESSOR_GROUP_INFO {
    BYTE  MaximumProcessorCount;
    BYTE  ActiveProcessorCount;
    BYTE  Reserved[38];
    KAFFINITY ActiveProcessorMask;
} PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;

typedef struct _GROUP_RELATIONSHIP {
    WORD   MaximumGroupCount;
    WORD   ActiveGroupCount;
    BYTE  Reserved[20];
    PROCESSOR_GROUP_INFO GroupInfo[ANYSIZE_ARRAY];
} GROUP_RELATIONSHIP, *PGROUP_RELATIONSHIP;

__struct_bcount(Size) struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    DWORD Size;
    union {
        PROCESSOR_RELATIONSHIP Processor;
        NUMA_NODE_RELATIONSHIP NumaNode;
        CACHE_RELATIONSHIP Cache;
        GROUP_RELATIONSHIP Group;
    } DUMMYUNIONNAME;
};

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;

// end_wdm end_ntminiport

typedef struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
    DWORD64 CycleTime;
} SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION, *PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;


#define PROCESSOR_INTEL_386     386
#define PROCESSOR_INTEL_486     486
#define PROCESSOR_INTEL_PENTIUM 586
#define PROCESSOR_INTEL_IA64    2200
#define PROCESSOR_AMD_X8664     8664
#define PROCESSOR_MIPS_R4000    4000    // incl R4101 & R3910 for Windows CE
#define PROCESSOR_ALPHA_21064   21064
#define PROCESSOR_PPC_601       601
#define PROCESSOR_PPC_603       603
#define PROCESSOR_PPC_604       604
#define PROCESSOR_PPC_620       620
#define PROCESSOR_HITACHI_SH3   10003   // Windows CE
#define PROCESSOR_HITACHI_SH3E  10004   // Windows CE
#define PROCESSOR_HITACHI_SH4   10005   // Windows CE
#define PROCESSOR_MOTOROLA_821  821     // Windows CE
#define PROCESSOR_SHx_SH3       103     // Windows CE
#define PROCESSOR_SHx_SH4       104     // Windows CE
#define PROCESSOR_STRONGARM     2577    // Windows CE - 0xA11
#define PROCESSOR_ARM720        1824    // Windows CE - 0x720
#define PROCESSOR_ARM820        2080    // Windows CE - 0x820
#define PROCESSOR_ARM920        2336    // Windows CE - 0x920
#define PROCESSOR_ARM_7TDMI     70001   // Windows CE
#define PROCESSOR_OPTIL         0x494f  // MSIL

#define PROCESSOR_ARCHITECTURE_INTEL            0
#define PROCESSOR_ARCHITECTURE_MIPS             1
#define PROCESSOR_ARCHITECTURE_ALPHA            2
#define PROCESSOR_ARCHITECTURE_PPC              3
#define PROCESSOR_ARCHITECTURE_SHX              4
#define PROCESSOR_ARCHITECTURE_ARM              5
#define PROCESSOR_ARCHITECTURE_IA64             6
#define PROCESSOR_ARCHITECTURE_ALPHA64          7
#define PROCESSOR_ARCHITECTURE_MSIL             8
#define PROCESSOR_ARCHITECTURE_AMD64            9
#define PROCESSOR_ARCHITECTURE_IA32_ON_WIN64    10

#define PROCESSOR_ARCHITECTURE_UNKNOWN 0xFFFF

#define PF_FLOATING_POINT_PRECISION_ERRATA  0   
#define PF_FLOATING_POINT_EMULATED          1   
#define PF_COMPARE_EXCHANGE_DOUBLE          2   
#define PF_MMX_INSTRUCTIONS_AVAILABLE       3   
#define PF_PPC_MOVEMEM_64BIT_OK             4   
#define PF_ALPHA_BYTE_INSTRUCTIONS          5   
#define PF_XMMI_INSTRUCTIONS_AVAILABLE      6   
#define PF_3DNOW_INSTRUCTIONS_AVAILABLE     7   
#define PF_RDTSC_INSTRUCTION_AVAILABLE      8   
#define PF_PAE_ENABLED                      9   
#define PF_XMMI64_INSTRUCTIONS_AVAILABLE   10   
#define PF_SSE_DAZ_MODE_AVAILABLE          11   
#define PF_NX_ENABLED                      12   
#define PF_SSE3_INSTRUCTIONS_AVAILABLE     13   
#define PF_COMPARE_EXCHANGE128             14   
#define PF_COMPARE64_EXCHANGE128           15   
#define PF_CHANNELS_ENABLED                16   
#define PF_XSAVE_ENABLED                   17   

//
// Known extended CPU state feature IDs
//

#define XSTATE_LEGACY_FLOATING_POINT        0
#define XSTATE_LEGACY_SSE                   1
#define XSTATE_GSSE                         2

#define XSTATE_MASK_LEGACY_FLOATING_POINT   (1i64 << (XSTATE_LEGACY_FLOATING_POINT))
#define XSTATE_MASK_LEGACY_SSE              (1i64 << (XSTATE_LEGACY_SSE))
#define XSTATE_MASK_LEGACY                  (XSTATE_MASK_LEGACY_FLOATING_POINT | XSTATE_MASK_LEGACY_SSE)
#define XSTATE_MASK_GSSE                    (1i64 << (XSTATE_GSSE))

#define MAXIMUM_XSTATE_FEATURES             64

//
// Extended processor state configuration
//

typedef struct _XSTATE_FEATURE {
    DWORD Offset;
    DWORD Size;
} XSTATE_FEATURE, *PXSTATE_FEATURE;

typedef struct _XSTATE_CONFIGURATION {
    // Mask of enabled features
    DWORD64 EnabledFeatures;

    // Total size of the save area
    DWORD Size;

    DWORD OptimizedSave : 1;

    // List of features (
    XSTATE_FEATURE Features[MAXIMUM_XSTATE_FEATURES];

} XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;


typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    SIZE_T RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

typedef struct _MEMORY_BASIC_INFORMATION32 {
    DWORD BaseAddress;
    DWORD AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION32, *PMEMORY_BASIC_INFORMATION32;

typedef struct DECLSPEC_ALIGN(16) _MEMORY_BASIC_INFORMATION64 {
    ULONGLONG BaseAddress;
    ULONGLONG AllocationBase;
    DWORD     AllocationProtect;
    DWORD     __alignment1;
    ULONGLONG RegionSize;
    DWORD     State;
    DWORD     Protect;
    DWORD     Type;
    DWORD     __alignment2;
} MEMORY_BASIC_INFORMATION64, *PMEMORY_BASIC_INFORMATION64;

#define SECTION_QUERY                0x0001
#define SECTION_MAP_WRITE            0x0002
#define SECTION_MAP_READ             0x0004
#define SECTION_MAP_EXECUTE          0x0008
#define SECTION_EXTEND_SIZE          0x0010
#define SECTION_MAP_EXECUTE_EXPLICIT 0x0020 // not included in SECTION_ALL_ACCESS

#define SECTION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SECTION_QUERY|\
                            SECTION_MAP_WRITE |      \
                            SECTION_MAP_READ |       \
                            SECTION_MAP_EXECUTE |    \
                            SECTION_EXTEND_SIZE)

#define SESSION_QUERY_ACCESS  0x0001
#define SESSION_MODIFY_ACCESS 0x0002

#define SESSION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED |  \
                            SESSION_QUERY_ACCESS |             \
                            SESSION_MODIFY_ACCESS)

#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define PAGE_WRITECOPY         0x08     
#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     
#define PAGE_GUARD            0x100     
#define PAGE_NOCACHE          0x200     
#define PAGE_WRITECOMBINE     0x400     
#define MEM_COMMIT           0x1000     
#define MEM_RESERVE          0x2000     
#define MEM_DECOMMIT         0x4000     
#define MEM_RELEASE          0x8000     
#define MEM_FREE            0x10000     
#define MEM_PRIVATE         0x20000     
#define MEM_MAPPED          0x40000     
#define MEM_RESET           0x80000     
#define MEM_TOP_DOWN       0x100000     
#define MEM_WRITE_WATCH    0x200000     
#define MEM_PHYSICAL       0x400000     
#define MEM_ROTATE         0x800000     
#define MEM_LARGE_PAGES  0x20000000     
#define MEM_4MB_PAGES    0x80000000     
#define SEC_FILE           0x800000     
#define SEC_IMAGE         0x1000000     
#define SEC_PROTECTED_IMAGE  0x2000000  
#define SEC_RESERVE       0x4000000     
#define SEC_COMMIT        0x8000000     
#define SEC_NOCACHE      0x10000000     
#define SEC_WRITECOMBINE 0x40000000     
#define SEC_LARGE_PAGES  0x80000000     
#define MEM_IMAGE         SEC_IMAGE     
#define WRITE_WATCH_FLAG_RESET 0x01     

//
// Define access rights to files and directories
//

//
// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
// constants *MUST* always be in sync.
// The values are redefined in devioctl.h because they must be available to
// both DOS and NT.
//

#define FILE_READ_DATA            ( 0x0001 )    // file & pipe
#define FILE_LIST_DIRECTORY       ( 0x0001 )    // directory

#define FILE_WRITE_DATA           ( 0x0002 )    // file & pipe
#define FILE_ADD_FILE             ( 0x0002 )    // directory

#define FILE_APPEND_DATA          ( 0x0004 )    // file
#define FILE_ADD_SUBDIRECTORY     ( 0x0004 )    // directory
#define FILE_CREATE_PIPE_INSTANCE ( 0x0004 )    // named pipe


#define FILE_READ_EA              ( 0x0008 )    // file & directory

#define FILE_WRITE_EA             ( 0x0010 )    // file & directory

#define FILE_EXECUTE              ( 0x0020 )    // file
#define FILE_TRAVERSE             ( 0x0020 )    // directory

#define FILE_DELETE_CHILD         ( 0x0040 )    // directory

#define FILE_READ_ATTRIBUTES      ( 0x0080 )    // all

#define FILE_WRITE_ATTRIBUTES     ( 0x0100 )    // all

#define FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF)

#define FILE_GENERIC_READ         (STANDARD_RIGHTS_READ     |\
                                   FILE_READ_DATA           |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_READ_EA             |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_WRITE        (STANDARD_RIGHTS_WRITE    |\
                                   FILE_WRITE_DATA          |\
                                   FILE_WRITE_ATTRIBUTES    |\
                                   FILE_WRITE_EA            |\
                                   FILE_APPEND_DATA         |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_EXECUTE      (STANDARD_RIGHTS_EXECUTE  |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_EXECUTE             |\
                                   SYNCHRONIZE)

#define FILE_SHARE_READ                 0x00000001  
#define FILE_SHARE_WRITE                0x00000002  
#define FILE_SHARE_DELETE               0x00000004  
#define FILE_ATTRIBUTE_READONLY             0x00000001  
#define FILE_ATTRIBUTE_HIDDEN               0x00000002  
#define FILE_ATTRIBUTE_SYSTEM               0x00000004  
#define FILE_ATTRIBUTE_DIRECTORY            0x00000010  
#define FILE_ATTRIBUTE_ARCHIVE              0x00000020  
#define FILE_ATTRIBUTE_DEVICE               0x00000040  
#define FILE_ATTRIBUTE_NORMAL               0x00000080  
#define FILE_ATTRIBUTE_TEMPORARY            0x00000100  
#define FILE_ATTRIBUTE_SPARSE_FILE          0x00000200  
#define FILE_ATTRIBUTE_REPARSE_POINT        0x00000400  
#define FILE_ATTRIBUTE_COMPRESSED           0x00000800  
#define FILE_ATTRIBUTE_OFFLINE              0x00001000  
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  0x00002000  
#define FILE_ATTRIBUTE_ENCRYPTED            0x00004000  
#define FILE_ATTRIBUTE_VIRTUAL              0x00010000  
#define FILE_NOTIFY_CHANGE_FILE_NAME    0x00000001   
#define FILE_NOTIFY_CHANGE_DIR_NAME     0x00000002   
#define FILE_NOTIFY_CHANGE_ATTRIBUTES   0x00000004   
#define FILE_NOTIFY_CHANGE_SIZE         0x00000008   
#define FILE_NOTIFY_CHANGE_LAST_WRITE   0x00000010   
#define FILE_NOTIFY_CHANGE_LAST_ACCESS  0x00000020   
#define FILE_NOTIFY_CHANGE_CREATION     0x00000040   
#define FILE_NOTIFY_CHANGE_SECURITY     0x00000100   
#define FILE_ACTION_ADDED                   0x00000001   
#define FILE_ACTION_REMOVED                 0x00000002   
#define FILE_ACTION_MODIFIED                0x00000003   
#define FILE_ACTION_RENAMED_OLD_NAME        0x00000004   
#define FILE_ACTION_RENAMED_NEW_NAME        0x00000005   
#define MAILSLOT_NO_MESSAGE             ((DWORD)-1) 
#define MAILSLOT_WAIT_FOREVER           ((DWORD)-1) 
#define FILE_CASE_SENSITIVE_SEARCH          0x00000001  
#define FILE_CASE_PRESERVED_NAMES           0x00000002  
#define FILE_UNICODE_ON_DISK                0x00000004  
#define FILE_PERSISTENT_ACLS                0x00000008  
#define FILE_FILE_COMPRESSION               0x00000010  
#define FILE_VOLUME_QUOTAS                  0x00000020  
#define FILE_SUPPORTS_SPARSE_FILES          0x00000040  
#define FILE_SUPPORTS_REPARSE_POINTS        0x00000080  
#define FILE_SUPPORTS_REMOTE_STORAGE        0x00000100  
#define FILE_VOLUME_IS_COMPRESSED           0x00008000  
#define FILE_SUPPORTS_OBJECT_IDS            0x00010000  
#define FILE_SUPPORTS_ENCRYPTION            0x00020000  
#define FILE_NAMED_STREAMS                  0x00040000  
#define FILE_READ_ONLY_VOLUME               0x00080000  
#define FILE_SEQUENTIAL_WRITE_ONCE          0x00100000  
#define FILE_SUPPORTS_TRANSACTIONS          0x00200000  
#define FILE_SUPPORTS_HARD_LINKS            0x00400000  
#define FILE_SUPPORTS_EXTENDED_ATTRIBUTES   0x00800000  
#define FILE_SUPPORTS_OPEN_BY_FILE_ID       0x01000000  
#define FILE_SUPPORTS_USN_JOURNAL           0x02000000  

//
// Define the file notification information structure
//

typedef struct _FILE_NOTIFY_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;


//
// Define segement buffer structure for scatter/gather read/write.
//

typedef union _FILE_SEGMENT_ELEMENT {
    PVOID64 Buffer;
    ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;

//
// The reparse GUID structure is used by all 3rd party layered drivers to
// store data in a reparse point. For non-Microsoft tags, The GUID field
// cannot be GUID_NULL.
// The constraints on reparse tags are defined below.
// Microsoft tags can also be used with this format of the reparse point buffer.
//

typedef struct _REPARSE_GUID_DATA_BUFFER {
    DWORD  ReparseTag;
    WORD   ReparseDataLength;
    WORD   Reserved;
    GUID   ReparseGuid;
    struct {
        BYTE   DataBuffer[1];
    } GenericReparseBuffer;
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;

#define REPARSE_GUID_DATA_BUFFER_HEADER_SIZE   FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, GenericReparseBuffer)



//
// Maximum allowed size of the reparse data.
//

#define MAXIMUM_REPARSE_DATA_BUFFER_SIZE      ( 16 * 1024 )

//
// Predefined reparse tags.
// These tags need to avoid conflicting with IO_REMOUNT defined in ntos\inc\io.h
//

#define IO_REPARSE_TAG_RESERVED_ZERO             (0)
#define IO_REPARSE_TAG_RESERVED_ONE              (1)

//
// The value of the following constant needs to satisfy the following conditions:
//  (1) Be at least as large as the largest of the reserved tags.
//  (2) Be strictly smaller than all the tags in use.
//

#define IO_REPARSE_TAG_RESERVED_RANGE            IO_REPARSE_TAG_RESERVED_ONE

//
// The reparse tags are a DWORD. The 32 bits are laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-----------------------+-------------------------------+
//  |M|R|N|R|     Reserved bits     |       Reparse Tag Value       |
//  +-+-+-+-+-----------------------+-------------------------------+
//
// M is the Microsoft bit. When set to 1, it denotes a tag owned by Microsoft.
//   All ISVs must use a tag with a 0 in this position.
//   Note: If a Microsoft tag is used by non-Microsoft software, the
//   behavior is not defined.
//
// R is reserved.  Must be zero for non-Microsoft tags.
//
// N is name surrogate. When set to 1, the file represents another named
//   entity in the system.
//
// The M and N bits are OR-able.
// The following macros check for the M and N bit values:
//

//
// Macro to determine whether a reparse point tag corresponds to a tag
// owned by Microsoft.
//

#define IsReparseTagMicrosoft(_tag) (              \
                           ((_tag) & 0x80000000)   \
                           )

//
// Macro to determine whether a reparse point tag is a name surrogate
//

#define IsReparseTagNameSurrogate(_tag) (          \
                           ((_tag) & 0x20000000)   \
                           )

#define IO_REPARSE_TAG_MOUNT_POINT              (0xA0000003L)       
#define IO_REPARSE_TAG_HSM                      (0xC0000004L)       
#define IO_REPARSE_TAG_HSM2                     (0x80000006L)       
#define IO_REPARSE_TAG_SIS                      (0x80000007L)       
#define IO_REPARSE_TAG_WIM                      (0x80000008L)       
#define IO_REPARSE_TAG_CSV                      (0x80000009L)       
#define IO_REPARSE_TAG_DFS                      (0x8000000AL)       
#define IO_REPARSE_TAG_SYMLINK                  (0xA000000CL)       
#define IO_REPARSE_TAG_DFSR                     (0x80000012L)       

//
// I/O Completion Specific Access Rights.
//

#define IO_COMPLETION_MODIFY_STATE  0x0002  
#define IO_COMPLETION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

//
// Object Manager Symbolic Link Specific Access Rights.
//

#define DUPLICATE_CLOSE_SOURCE      0x00000001  
#define DUPLICATE_SAME_ACCESS       0x00000002  

//
// =========================================
// Define GUIDs which represent well-known power schemes
// =========================================
//

//
// Maximum Power Savings - indicates that very aggressive power savings measures will be used to help
//                         stretch battery life.
//
// {a1841308-3541-4fab-bc81-f71556f20b4a}
//
DEFINE_GUID( GUID_MAX_POWER_SAVINGS, 0xA1841308, 0x3541, 0x4FAB, 0xBC, 0x81, 0xF7, 0x15, 0x56, 0xF2, 0x0B, 0x4A );

//
// No Power Savings - indicates that almost no power savings measures will be used.
//
// {8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c}
//
DEFINE_GUID( GUID_MIN_POWER_SAVINGS, 0x8C5E7FDA, 0xE8BF, 0x4A96, 0x9A, 0x85, 0xA6, 0xE2, 0x3A, 0x8C, 0x63, 0x5C );

//
// Typical Power Savings - indicates that fairly aggressive power savings measures will be used.
//
// {381b4222-f694-41f0-9685-ff5bb260df2e}
//
DEFINE_GUID( GUID_TYPICAL_POWER_SAVINGS, 0x381B4222, 0xF694, 0x41F0, 0x96, 0x85, 0xFF, 0x5B, 0xB2, 0x60, 0xDF, 0x2E );

//
// This is a special GUID that represents "no subgroup" of settings.  That is, it indicates
// that settings that are in the root of the power policy hierarchy as opposed to settings
// that are buried under a subgroup of settings.  This should be used when querying for
// power settings that may not fall into a subgroup.
//
DEFINE_GUID( NO_SUBGROUP_GUID, 0xFEA3413E, 0x7E05, 0x4911, 0x9A, 0x71, 0x70, 0x03, 0x31, 0xF1, 0xC2, 0x94 );

//
// This is a special GUID that represents "every power scheme".  That is, it indicates
// that any write to this power scheme should be reflected to every scheme present.
// This allows users to write a single setting once and have it apply to all schemes.  They
// can then apply custom settings to specific power schemes that they care about.
//
DEFINE_GUID( ALL_POWERSCHEMES_GUID, 0x68A1E95E, 0x13EA, 0x41E1, 0x80, 0x11, 0x0C, 0x49, 0x6C, 0xA4, 0x90, 0xB0 );

//
// This is a special GUID that represents a 'personality' that each power scheme will have.
// In other words, each power scheme will have this key indicating "I'm most like *this* base
// power scheme."  This individual setting will have one of three settings:
// GUID_MAX_POWER_SAVINGS
// GUID_MIN_POWER_SAVINGS
// GUID_TYPICAL_POWER_SAVINGS
//
// This allows several features:
// 1. Drivers and applications can register for notification of this GUID.  So when this power
//    scheme is activiated, this GUID's setting will be sent across the system and drivers/applications
//    can see "GUID_MAX_POWER_SAVINGS" which will tell them in a generic fashion "get real aggressive
//    about conserving power".
// 2. UserB may install a driver or application which creates power settings, and UserB may modify
//    those power settings.  Now UserA logs in.  How does he see those settings?  They simply don't
//    exist in his private power key.  Well they do exist over in the system power key.  When we
//    enumerate all the power settings in this system power key and don't find a corresponding entry
//    in the user's private power key, then we can go look at this "personality" key in the users
//    power scheme.  We can then go get a default value for the power setting, depending on which
//    "personality" power scheme is being operated on.  Here's an example:
//    A. UserB installs an application that creates a power setting Seetting1
//    B. UserB changes Setting1 to have a value of 50 because that's one of the possible settings
//       available for setting1.
//    C. UserB logs out
//    D. UserA logs in and his active power scheme is some custom scheme that was derived from
//       the GUID_TYPICAL_POWER_SAVINGS.  But remember that UserA has no setting1 in his
//       private power key.
//    E. When activating UserA's selected power scheme, all power settings in the system power key will
//       be enumerated (including Setting1).
//    F. The power manager will see that UserA has no Setting1 power setting in his private power scheme.
//    G. The power manager will query UserA's power scheme for its personality and retrieve
//       GUID_TYPICAL_POWER_SAVINGS.
//    H. The power manager then looks in Setting1 in the system power key and looks in its set of default
//       values for the corresponding value for GUID_TYPICAL_POWER_SAVINGS power schemes.
//    I. This derived power setting is applied.
DEFINE_GUID( GUID_POWERSCHEME_PERSONALITY, 0x245D8541, 0x3943, 0x4422, 0xB0, 0x25, 0x13, 0xA7, 0x84, 0xF6, 0x79, 0xB7 );

//
// Define a special GUID which will be used to define the active power scheme.
// User will register for this power setting GUID, and when the active power
// scheme changes, they'll get a callback where the payload is the GUID
// representing the active powerscheme.
// ( 31F9F286-5084-42FE-B720-2B0264993763 }
//
DEFINE_GUID( GUID_ACTIVE_POWERSCHEME, 0x31F9F286, 0x5084, 0x42FE, 0xB7, 0x20, 0x2B, 0x02, 0x64, 0x99, 0x37, 0x63 );

//
// =========================================
// Define GUIDs which represent well-known power settings
// =========================================
//

// Video settings
// --------------
//
// Specifies the subgroup which will contain all of the video
// settings for a single policy.
//
DEFINE_GUID( GUID_VIDEO_SUBGROUP, 0x7516B95F, 0xF776, 0x4464, 0x8C, 0x53, 0x06, 0x16, 0x7F, 0x40, 0xCC, 0x99 );

//
// Specifies (in seconds) how long we wait after the last user input has been
// recieved before we power off the video.
//
DEFINE_GUID( GUID_VIDEO_POWERDOWN_TIMEOUT, 0x3C0BC021, 0xC8A8, 0x4E07, 0xA9, 0x73, 0x6B, 0x14, 0xCB, 0xCB, 0x2B, 0x7E );

//
// Specifies whether adaptive display dimming is turned on or off.
// 82DBCF2D-CD67-40C5-BFDC-9F1A5CCD4663
//
DEFINE_GUID( GUID_VIDEO_ANNOYANCE_TIMEOUT, 0x82DBCF2D, 0xCD67, 0x40C5, 0xBF, 0xDC, 0x9F, 0x1A, 0x5C, 0xCD, 0x46, 0x63 );

//
// Specifies how much adaptive dim time out will be increased by.
// EED904DF-B142-4183-B10B-5A1197A37864
//
DEFINE_GUID( GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE, 0xEED904DF, 0xB142, 0x4183, 0xB1, 0x0B, 0x5A, 0x11, 0x97, 0xA3, 0x78, 0x64 );

//
// Specifies (in seconds) how long we wait after the last user input has been
// recieved before we dim the video.
//
DEFINE_GUID( GUID_VIDEO_DIM_TIMEOUT, 0x17aaa29b, 0x8b43, 0x4b94, 0xaa, 0xfe, 0x35, 0xf6, 0x4d, 0xaa, 0xf1, 0xee);

//
// Specifies if the operating system should use adaptive timers (based on
// previous behavior) to power down the video,
//
DEFINE_GUID( GUID_VIDEO_ADAPTIVE_POWERDOWN, 0x90959D22, 0xD6A1, 0x49B9, 0xAF, 0x93, 0xBC, 0xE8, 0x85, 0xAD, 0x33, 0x5B );

//
// Specifies if the monitor is currently being powered or not.
// 02731015-4510-4526-99E6-E5A17EBD1AEA
//
DEFINE_GUID( GUID_MONITOR_POWER_ON, 0x02731015, 0x4510, 0x4526, 0x99, 0xE6, 0xE5, 0xA1, 0x7E, 0xBD, 0x1A, 0xEA );

//
// Monitor brightness policy when in normal state
// {aded5e82-b909-4619-9949-f5d71dac0bcb}
DEFINE_GUID(GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS, 0xaded5e82L, 0xb909, 0x4619, 0x99, 0x49, 0xf5, 0xd7, 0x1d, 0xac, 0x0b, 0xcb);

//
//
// Monitor brightness policy when in dim state
// {f1fbfde2-a960-4165-9f88-50667911ce96}
DEFINE_GUID(GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS, 0xf1fbfde2, 0xa960, 0x4165, 0x9f, 0x88, 0x50, 0x66, 0x79, 0x11, 0xce, 0x96);

//
// Current Monitor brightness
// {8ffee2c6-2d01-46be-adb9-398addc5b4ff}
DEFINE_GUID(GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS, 0x8ffee2c6, 0x2d01, 0x46be, 0xad, 0xb9, 0x39, 0x8a, 0xdd, 0xc5, 0xb4, 0xff);


//
// Specifies if the operating system should use ambient light sensor to change
// disply brightness adatively.
// {FBD9AA66-9553-4097-BA44-ED6E9D65EAB8}
DEFINE_GUID(GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS, 0xFBD9AA66, 0x9553, 0x4097, 0xBA, 0x44, 0xED, 0x6E, 0x9D, 0x65, 0xEA, 0xB8);

//
// Specifies a change in the session's display state.
// 73A5E93A-5BB1-4F93-895B-DBD0DA855967
//
// N.B. This is a session-specific notification, sent only to interactive
//      session registrants. Session 0 and kernel mode consumers do not receive
//      this notification.
DEFINE_GUID( GUID_SESSION_DISPLAY_STATE, 0x73A5E93A, 0x5BB1, 0x4F93, 0x89, 0x5B, 0xDB, 0xD0, 0xDA, 0x85, 0x59, 0x67 );

//
// Specifies a change in the current monitor's display state.
// 6fe69556-704a-47a0-8f24-c28d936fda47
//
DEFINE_GUID(GUID_CONSOLE_DISPLAY_STATE, 0x6fe69556, 0x704a, 0x47a0, 0x8f, 0x24, 0xc2, 0x8d, 0x93, 0x6f, 0xda, 0x47);

//
// Defines a guid for enabling/disabling the ability to create display required 
// power requests.
//
// {A9CEB8DA-CD46-44FB-A98B-02AF69DE4623}
//
DEFINE_GUID( GUID_ALLOW_DISPLAY_REQUIRED, 0xA9CEB8DA, 0xCD46, 0x44FB, 0xA9, 0x8B, 0x02, 0xAF, 0x69, 0xDE, 0x46, 0x23 );

// Harddisk settings
// -----------------
//
// Specifies the subgroup which will contain all of the harddisk
// settings for a single policy.
//
DEFINE_GUID( GUID_DISK_SUBGROUP, 0x0012EE47, 0x9041, 0x4B5D, 0x9B, 0x77, 0x53, 0x5F, 0xBA, 0x8B, 0x14, 0x42 );

//
// Specifies (in seconds) how long we wait after the last disk access
// before we power off the disk.
//
DEFINE_GUID( GUID_DISK_POWERDOWN_TIMEOUT, 0x6738E2C4, 0xE8A5, 0x4A42, 0xB1, 0x6A, 0xE0, 0x40, 0xE7, 0x69, 0x75, 0x6E );

//
// Specifies the amount of contiguous disk activity time to ignore when
// calculating disk idleness.
//
// 80e3c60e-bb94-4ad8-bbe0-0d3195efc663
//

DEFINE_GUID( GUID_DISK_BURST_IGNORE_THRESHOLD, 0x80e3c60e, 0xbb94, 0x4ad8, 0xbb, 0xe0, 0x0d, 0x31, 0x95, 0xef, 0xc6, 0x63 );

//
// Specifies if the operating system should use adaptive timers (based on
// previous behavior) to power down the disk,
//
DEFINE_GUID( GUID_DISK_ADAPTIVE_POWERDOWN, 0x396A32E1, 0x499A, 0x40B2, 0x91, 0x24, 0xA9, 0x6A, 0xFE, 0x70, 0x76, 0x67 );

// System sleep settings
// ---------------------
//
// Specifies the subgroup which will contain all of the sleep
// settings for a single policy.
// { 238C9FA8-0AAD-41ED-83F4-97BE242C8F20 }
//
DEFINE_GUID( GUID_SLEEP_SUBGROUP, 0x238C9FA8, 0x0AAD, 0x41ED, 0x83, 0xF4, 0x97, 0xBE, 0x24, 0x2C, 0x8F, 0x20 );

//
// Specifies an idle treshold percentage (0-100). The system must be this idle
// over a period of time in order to idle to sleep.
//
// N.B. DEPRECATED IN WINDOWS 6.1
//
DEFINE_GUID( GUID_SLEEP_IDLE_THRESHOLD, 0x81cd32e0, 0x7833, 0x44f3, 0x87, 0x37, 0x70, 0x81, 0xf3, 0x8d, 0x1f, 0x70 );

//
// Specifies (in seconds) how long we wait after the system is deemed
// "idle" before moving to standby (S1, S2 or S3).
//
DEFINE_GUID( GUID_STANDBY_TIMEOUT, 0x29F6C1DB, 0x86DA, 0x48C5, 0x9F, 0xDB, 0xF2, 0xB6, 0x7B, 0x1F, 0x44, 0xDA );

//
// Specifies (in seconds) how long the system should go back to sleep after
// waking unattended. 0 indicates that the standard standby/hibernate idle
// policy should be used instead.
//
// {7bc4a2f9-d8fc-4469-b07b-33eb785aaca0}
//
DEFINE_GUID( GUID_UNATTEND_SLEEP_TIMEOUT, 0x7bc4a2f9, 0xd8fc, 0x4469, 0xb0, 0x7b, 0x33, 0xeb, 0x78, 0x5a, 0xac, 0xa0 );

//
// Specifies (in seconds) how long we wait after the system is deemed
// "idle" before moving to hibernate (S4).
//
DEFINE_GUID( GUID_HIBERNATE_TIMEOUT, 0x9D7815A6, 0x7EE4, 0x497E, 0x88, 0x88, 0x51, 0x5A, 0x05, 0xF0, 0x23, 0x64 );

//
// Specifies whether or not Fast S4 should be enabled if the system supports it
// 94AC6D29-73CE-41A6-809F-6363BA21B47E
//
DEFINE_GUID( GUID_HIBERNATE_FASTS4_POLICY, 0x94AC6D29, 0x73CE, 0x41A6, 0x80, 0x9F, 0x63, 0x63, 0xBA, 0x21, 0xB4, 0x7E );

//
// Define a GUID for controlling the criticality of sleep state transitions.
// Critical sleep transitions do not query applications, services or drivers
// before transitioning the platform to a sleep state.
//
// {B7A27025-E569-46c2-A504-2B96CAD225A1}
//
DEFINE_GUID( GUID_CRITICAL_POWER_TRANSITION,  0xB7A27025, 0xE569, 0x46c2, 0xA5, 0x04, 0x2B, 0x96, 0xCA, 0xD2, 0x25, 0xA1);

//
// Specifies if the system is entering or exiting 'away mode'.
// 98A7F580-01F7-48AA-9C0F-44352C29E5C0
//
DEFINE_GUID( GUID_SYSTEM_AWAYMODE, 0x98A7F580, 0x01F7, 0x48AA, 0x9C, 0x0F, 0x44, 0x35, 0x2C, 0x29, 0xE5, 0xC0 );

// Specify whether away mode is allowed
//
// {25DFA149-5DD1-4736-B5AB-E8A37B5B8187}
//
DEFINE_GUID( GUID_ALLOW_AWAYMODE, 0x25dfa149, 0x5dd1, 0x4736, 0xb5, 0xab, 0xe8, 0xa3, 0x7b, 0x5b, 0x81, 0x87 );

//
// Defines a guid for enabling/disabling standby (S1-S3) states. This does not
// affect hibernation (S4).
//
// {abfc2519-3608-4c2a-94ea-171b0ed546ab}
//
DEFINE_GUID( GUID_ALLOW_STANDBY_STATES, 0xabfc2519, 0x3608, 0x4c2a, 0x94, 0xea, 0x17, 0x1b, 0x0e, 0xd5, 0x46, 0xab );

//
// Defines a guid for enabling/disabling the ability to wake via RTC.
//
// {BD3B718A-0680-4D9D-8AB2-E1D2B4AC806D}
//
DEFINE_GUID( GUID_ALLOW_RTC_WAKE, 0xBD3B718A, 0x0680, 0x4D9D, 0x8A, 0xB2, 0xE1, 0xD2, 0xB4, 0xAC, 0x80, 0x6D );

//
// Defines a guid for enabling/disabling the ability to create system required 
// power requests.
//
// {A4B195F5-8225-47D8-8012-9D41369786E2}
//
DEFINE_GUID( GUID_ALLOW_SYSTEM_REQUIRED, 0xA4B195F5, 0x8225, 0x47D8, 0x80, 0x12, 0x9D, 0x41, 0x36, 0x97, 0x86, 0xE2 );
  
// System button actions
// ---------------------
//
//
// Specifies the subgroup which will contain all of the system button
// settings for a single policy.
//
DEFINE_GUID( GUID_SYSTEM_BUTTON_SUBGROUP, 0x4F971E89, 0xEEBD, 0x4455, 0xA8, 0xDE, 0x9E, 0x59, 0x04, 0x0E, 0x73, 0x47 );

// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system power button is pressed.
//
DEFINE_GUID( GUID_POWERBUTTON_ACTION, 0x7648EFA3, 0xDD9C, 0x4E3E, 0xB5, 0x66, 0x50, 0xF9, 0x29, 0x38, 0x62, 0x80 );
DEFINE_GUID( GUID_POWERBUTTON_ACTION_FLAGS, 0x857E7FAC, 0x034B, 0x4704, 0xAB, 0xB1, 0xBC, 0xA5, 0x4A, 0xA3, 0x14, 0x78 );

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system sleep button is pressed.
//
DEFINE_GUID( GUID_SLEEPBUTTON_ACTION, 0x96996BC0, 0xAD50, 0x47EC, 0x92, 0x3B, 0x6F, 0x41, 0x87, 0x4D, 0xD9, 0xEB );
DEFINE_GUID( GUID_SLEEPBUTTON_ACTION_FLAGS, 0x2A160AB1, 0xB69D, 0x4743, 0xB7, 0x18, 0xBF, 0x14, 0x41, 0xD5, 0xE4, 0x93 );

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system sleep button is pressed.
// { A7066653-8D6C-40A8-910E-A1F54B84C7E5 }
//
DEFINE_GUID( GUID_USERINTERFACEBUTTON_ACTION, 0xA7066653, 0x8D6C, 0x40A8, 0x91, 0x0E, 0xA1, 0xF5, 0x4B, 0x84, 0xC7, 0xE5 );

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system lid is closed.
//
DEFINE_GUID( GUID_LIDCLOSE_ACTION, 0x5CA83367, 0x6E45, 0x459F, 0xA2, 0x7B, 0x47, 0x6B, 0x1D, 0x01, 0xC9, 0x36 );
DEFINE_GUID( GUID_LIDCLOSE_ACTION_FLAGS, 0x97E969AC, 0x0D6C, 0x4D08, 0x92, 0x7C, 0xD7, 0xBD, 0x7A, 0xD7, 0x85, 0x7B );
DEFINE_GUID( GUID_LIDOPEN_POWERSTATE, 0x99FF10E7, 0x23B1, 0x4C07, 0xA9, 0xD1, 0x5C, 0x32, 0x06, 0xD7, 0x41, 0xB4 );


// Battery Discharge Settings
// --------------------------
//
// Specifies the subgroup which will contain all of the battery discharge
// settings for a single policy.
//
DEFINE_GUID( GUID_BATTERY_SUBGROUP, 0xE73A048D, 0xBF27, 0x4F12, 0x97, 0x31, 0x8B, 0x20, 0x76, 0xE8, 0x89, 0x1F );

//
// 4 battery discharge alarm settings.
//
// GUID_BATTERY_DISCHARGE_ACTION_x - This is the action to take.  It is a value
//                                   of type POWER_ACTION
// GUID_BATTERY_DISCHARGE_LEVEL_x  - This is the battery level (%)
// GUID_BATTERY_DISCHARGE_FLAGS_x  - Flags defined below:
//                                   POWER_ACTION_POLICY->EventCode flags
//                                   BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK
//                                   BATTERY_DISCHARGE_FLAGS_ENABLE
DEFINE_GUID( GUID_BATTERY_DISCHARGE_ACTION_0, 0x637EA02F, 0xBBCB, 0x4015, 0x8E, 0x2C, 0xA1, 0xC7, 0xB9, 0xC0, 0xB5, 0x46 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_LEVEL_0, 0x9A66D8D7, 0x4FF7, 0x4EF9, 0xB5, 0xA2, 0x5A, 0x32, 0x6C, 0xA2, 0xA4, 0x69 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_FLAGS_0, 0x5dbb7c9f, 0x38e9, 0x40d2, 0x97, 0x49, 0x4f, 0x8a, 0x0e, 0x9f, 0x64, 0x0f );

DEFINE_GUID( GUID_BATTERY_DISCHARGE_ACTION_1, 0xD8742DCB, 0x3E6A, 0x4B3C, 0xB3, 0xFE, 0x37, 0x46, 0x23, 0xCD, 0xCF, 0x06 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_LEVEL_1, 0x8183BA9A, 0xE910, 0x48DA, 0x87, 0x69, 0x14, 0xAE, 0x6D, 0xC1, 0x17, 0x0A );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_FLAGS_1, 0xbcded951, 0x187b, 0x4d05, 0xbc, 0xcc, 0xf7, 0xe5, 0x19, 0x60, 0xc2, 0x58 );

DEFINE_GUID( GUID_BATTERY_DISCHARGE_ACTION_2, 0x421CBA38, 0x1A8E, 0x4881, 0xAC, 0x89, 0xE3, 0x3A, 0x8B, 0x04, 0xEC, 0xE4 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_LEVEL_2, 0x07A07CA2, 0xADAF, 0x40D7, 0xB0, 0x77, 0x53, 0x3A, 0xAD, 0xED, 0x1B, 0xFA );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_FLAGS_2, 0x7fd2f0c4, 0xfeb7, 0x4da3, 0x81, 0x17, 0xe3, 0xfb, 0xed, 0xc4, 0x65, 0x82 );

DEFINE_GUID( GUID_BATTERY_DISCHARGE_ACTION_3, 0x80472613, 0x9780, 0x455E, 0xB3, 0x08, 0x72, 0xD3, 0x00, 0x3C, 0xF2, 0xF8 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_LEVEL_3, 0x58AFD5A6, 0xC2DD, 0x47D2, 0x9F, 0xBF, 0xEF, 0x70, 0xCC, 0x5C, 0x59, 0x65 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_FLAGS_3, 0x73613ccf, 0xdbfa, 0x4279, 0x83, 0x56, 0x49, 0x35, 0xf6, 0xbf, 0x62, 0xf3 );

// Processor power settings
// ------------------------
//

// Specifies the subgroup which will contain all of the processor
// settings for a single policy.
//
DEFINE_GUID( GUID_PROCESSOR_SETTINGS_SUBGROUP, 0x54533251, 0x82BE, 0x4824, 0x96, 0xC1, 0x47, 0xB6, 0x0B, 0x74, 0x0D, 0x00 );

//
// Specifies various attributes that control processor performance/throttle
// states.
// 
DEFINE_GUID( GUID_PROCESSOR_THROTTLE_POLICY, 0x57027304, 0x4AF6, 0x4104, 0x92, 0x60, 0xE3, 0xD9, 0x52, 0x48, 0xFC, 0x36 );

#define PERFSTATE_POLICY_CHANGE_IDEAL  0
#define PERFSTATE_POLICY_CHANGE_SINGLE 1
#define PERFSTATE_POLICY_CHANGE_ROCKET 2
#define PERFSTATE_POLICY_CHANGE_MAX PERFSTATE_POLICY_CHANGE_ROCKET

//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should never go above.  For example, if this value is set to 80, then
// the processor frequency will never be throttled above 80 percent of its
// maximum frequency by the system.
//
DEFINE_GUID( GUID_PROCESSOR_THROTTLE_MAXIMUM, 0xBC5038F7, 0x23E0, 0x4960, 0x96, 0xDA, 0x33, 0xAB, 0xAF, 0x59, 0x35, 0xEC );

//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should not drop below.  For example, if this value is set to 50, then the
// processor frequency will never be throttled below 50 percent of its
// maximum frequency by the system.
//
DEFINE_GUID( GUID_PROCESSOR_THROTTLE_MINIMUM, 0x893DEE8E, 0x2BEF, 0x41E0, 0x89, 0xC6, 0xB5, 0x5D, 0x09, 0x29, 0x96, 0x4C );

//
// Specifies whether throttle states are allowed to be used even when
// performance states are available.
//
// {3b04d4fd-1cc7-4f23-ab1c-d1337819c4bb}
//
DEFINE_GUID( GUID_PROCESSOR_ALLOW_THROTTLING, 0x3b04d4fd, 0x1cc7, 0x4f23, 0xab, 0x1c, 0xd1, 0x33, 0x78, 0x19, 0xc4, 0xbb );

//
// Specifies processor power settings for CState policy data
// {68F262A7-F621-4069-B9A5-4874169BE23C}
//
DEFINE_GUID( GUID_PROCESSOR_IDLESTATE_POLICY, 0x68f262a7, 0xf621, 0x4069, 0xb9, 0xa5, 0x48, 0x74, 0x16, 0x9b, 0xe2, 0x3c);

//
// Specifies processor power settings for PerfState policy data
// {BBDC3814-18E9-4463-8A55-D197327C45C0}
//
DEFINE_GUID( GUID_PROCESSOR_PERFSTATE_POLICY, 0xBBDC3814, 0x18E9, 0x4463, 0x8A, 0x55, 0xD1, 0x97, 0x32, 0x7C, 0x45, 0xC0);

//
// Specifies the increase busy percentage threshold that must be met before
// increasing the processor performance state.
//
// {06cadf0e-64ed-448a-8927-ce7bf90eb35d}
//
DEFINE_GUID( GUID_PROCESSOR_PERF_INCREASE_THRESHOLD, 0x06cadf0e, 0x64ed, 0x448a, 0x89, 0x27, 0xce, 0x7b, 0xf9, 0x0e, 0xb3, 0x5d );

//
// Specifies the decrease busy percentage threshold that must be met before
// decreasing the processor performance state.
//
// {12a0ab44-fe28-4fa9-b3bd-4b64f44960a6}
//
DEFINE_GUID( GUID_PROCESSOR_PERF_DECREASE_THRESHOLD, 0x12a0ab44, 0xfe28, 0x4fa9, 0xb3, 0xbd, 0x4b, 0x64, 0xf4, 0x49, 0x60, 0xa6 );

//
// Specifies, either as ideal, single or rocket, how aggressive performance
// states should be selected when increasing the processor performance state.
//
// {465E1F50-B610-473a-AB58-00D1077DC418}
//
DEFINE_GUID( GUID_PROCESSOR_PERF_INCREASE_POLICY, 0x465e1f50, 0xb610, 0x473a, 0xab, 0x58, 0x0, 0xd1, 0x7, 0x7d, 0xc4, 0x18);

//
// Specifies, either as ideal, single or rocket, how aggressive performance
// states should be selected when decreasing the processor performance state.
//
// {40FBEFC7-2E9D-4d25-A185-0CFD8574BAC6}
//
DEFINE_GUID( GUID_PROCESSOR_PERF_DECREASE_POLICY, 0x40fbefc7, 0x2e9d, 0x4d25, 0xa1, 0x85, 0xc, 0xfd, 0x85, 0x74, 0xba, 0xc6);

//
// Specifies, in milliseconds, the minimum amount of time that must elapse after
// the last processor performance state change before increasing the processor
// performance state.
//
// {984CF492-3BED-4488-A8F9-4286C97BF5AA}
//
DEFINE_GUID( GUID_PROCESSOR_PERF_INCREASE_TIME, 0x984cf492, 0x3bed, 0x4488, 0xa8, 0xf9, 0x42, 0x86, 0xc9, 0x7b, 0xf5, 0xaa);

//
// Specifies, in milliseconds, the minimum amount of time that must elapse after
// the last processor performance state change before increasing the processor
// performance state.
//
// {D8EDEB9B-95CF-4f95-A73C-B061973693C8}
//
DEFINE_GUID( GUID_PROCESSOR_PERF_DECREASE_TIME, 0xd8edeb9b, 0x95cf, 0x4f95, 0xa7, 0x3c, 0xb0, 0x61, 0x97, 0x36, 0x93, 0xc8);

//
// Specifies the time, in milliseconds, that must expire before considering
// a change in the processor performance states or parked core set.
//
// {4D2B0152-7D5C-498b-88E2-34345392A2C5}
//
DEFINE_GUID( GUID_PROCESSOR_PERF_TIME_CHECK, 0x4d2b0152, 0x7d5c, 0x498b, 0x88, 0xe2, 0x34, 0x34, 0x53, 0x92, 0xa2, 0xc5);

//
// Specifies whether a processor may opportunistically increase frequency above
// the maximum when operating contitions allow it to do so safely.
//
// {45BCC044-D885-43e2-8605-EE0EC6E96B59}
//
DEFINE_GUID(GUID_PROCESSOR_PERF_BOOST_POLICY, 
0x45bcc044, 0xd885, 0x43e2, 0x86, 0x5, 0xee, 0xe, 0xc6, 0xe9, 0x6b, 0x59);

#define PROCESSOR_PERF_BOOST_POLICY_DISABLED 0
#define PROCESSOR_PERF_BOOST_POLICY_MAX 100

//
// Specifies if idle state promotion and demotion values should be scaled based
// on the current peformance state.
//
// {6C2993B0-8F48-481f-BCC6-00DD2742AA06}
//
DEFINE_GUID( GUID_PROCESSOR_IDLE_ALLOW_SCALING, 0x6c2993b0, 0x8f48, 0x481f, 0xbc, 0xc6, 0x0, 0xdd, 0x27, 0x42, 0xaa, 0x6);

//
// Specifies if idle states should be disabled.
//
// {5D76A2CA-E8C0-402f-A133-2158492D58AD}
//
DEFINE_GUID( GUID_PROCESSOR_IDLE_DISABLE, 0x5d76a2ca, 0xe8c0, 0x402f, 0xa1, 0x33, 0x21, 0x58, 0x49, 0x2d, 0x58, 0xad);

//
// Specifies the time that elapsed since the last idle state promotion or
// demotion before idle states may be promoted or demoted again (in 
// microseconds).
//
// {C4581C31-89AB-4597-8E2B-9C9CAB440E6B}
//
DEFINE_GUID( GUID_PROCESSOR_IDLE_TIME_CHECK, 0xc4581c31, 0x89ab, 0x4597, 0x8e, 0x2b, 0x9c, 0x9c, 0xab, 0x44, 0xe, 0x6b);


//
// Specifies the upper busy threshold that must be met before demoting the
// processor to a lighter idle state (in percentage).
//
// {4B92D758-5A24-4851-A470-815D78AEE119}
//
DEFINE_GUID( GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD, 0x4b92d758, 0x5a24, 0x4851, 0xa4, 0x70, 0x81, 0x5d, 0x78, 0xae, 0xe1, 0x19);

//
// Specifies the lower busy threshold that must be met before promoting the 
// processor to a deeper idle state (in percentage).
//
// {7B224883-B3CC-4d79-819F-8374152CBE7C}
//
DEFINE_GUID( GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD, 0x7b224883, 0xb3cc, 0x4d79, 0x81, 0x9f, 0x83, 0x74, 0x15, 0x2c, 0xbe, 0x7c);

//
// Specifies the utilization threshold in percent that must be crossed in order to un-park cores.
// 
// {df142941-20f3-4edf-9a4a-9c83d3d717d1}
// 
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD, 0xdf142941, 0x20f3, 0x4edf, 0x9a, 0x4a, 0x9c, 0x83, 0xd3, 0xd7, 0x17, 0xd1 );

//
// Specifies the utilization threshold in percent that must be crossed in order to park cores.
// 
// {68dd2f27-a4ce-4e11-8487-3794e4135dfa}
// 
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD, 0x68dd2f27, 0xa4ce, 0x4e11, 0x84, 0x87, 0x37, 0x94, 0xe4, 0x13, 0x5d, 0xfa);

//
// Specifies, either as ideal, single or rocket, how aggressive core parking is when cores must be unparked.
// 
// {c7be0679-2817-4d69-9d02-519a537ed0c6}
// 
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY, 0xc7be0679, 0x2817, 0x4d69, 0x9d, 0x02, 0x51, 0x9a, 0x53, 0x7e, 0xd0, 0xc6);

#define CORE_PARKING_POLICY_CHANGE_IDEAL  0
#define CORE_PARKING_POLICY_CHANGE_SINGLE 1
#define CORE_PARKING_POLICY_CHANGE_ROCKET 2
#define CORE_PARKING_POLICY_CHANGE_MAX CORE_PARKING_POLICY_CHANGE_ROCKET

// 
// Specifies, either as ideal, single or rocket, how aggressive core parking is when cores must be parked.
// 
// {71021b41-c749-4d21-be74-a00f335d582b}
// 
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY, 0x71021b41, 0xc749, 0x4d21, 0xbe, 0x74, 0xa0, 0x0f, 0x33, 0x5d, 0x58, 0x2b);

//
// Specifies, on a per processor group basis, the maximum number of cores that can be kept unparked. 
// 
// {ea062031-0e34-4ff1-9b6d-eb1059334028}
// 
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_MAX_CORES, 0xea062031, 0x0e34, 0x4ff1, 0x9b, 0x6d, 0xeb, 0x10, 0x59, 0x33, 0x40, 0x28);

//
// Specifies, on a per processor group basis, the minimum number of cores that must be kept unparked.
// 
// {0cc5b647-c1df-4637-891a-dec35c318583}
// 
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_MIN_CORES, 0x0cc5b647, 0xc1df, 0x4637, 0x89, 0x1a, 0xde, 0xc3, 0x5c, 0x31, 0x85, 0x83);

//
// Specifies, in milliseconds, the minimum amount of time a core must be parked before it can be unparked.
// 
// {2ddd5a84-5a71-437e-912a-db0b8c788732}
//
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME, 0x2ddd5a84, 0x5a71, 0x437e, 0x91, 0x2a, 0xdb, 0x0b, 0x8c, 0x78, 0x87, 0x32);

//
// Specifies, in milliseconds, the minimum amount of time a core must be unparked before it can be parked.
// 
// {dfd10d17-d5eb-45dd-877a-9a34ddd15c82}
// 
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME, 0xdfd10d17, 0xd5eb, 0x45dd, 0x87, 0x7a, 0x9a, 0x34, 0xdd, 0xd1, 0x5c, 0x82);

//
// Specifies the factor by which to decrease affinity history on each core after each check.
// 
// {8f7b45e3-c393-480a-878c-f67ac3d07082}
// 
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR, 0x8f7b45e3, 0xc393, 0x480a, 0x87, 0x8c, 0xf6, 0x7a, 0xc3, 0xd0, 0x70, 0x82);

//
// Specifies the threshold above which a core is considered to have had significant affinitized work scheduled to it while parked.
// 
// {5b33697b-e89d-4d38-aa46-9e7dfb7cd2f9}
// 
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD, 0x5b33697b, 0xe89d, 0x4d38, 0xaa, 0x46, 0x9e, 0x7d, 0xfb, 0x7c, 0xd2, 0xf9);

//
// Specifies the weighting given to each occurence where affinitized work was scheduled to a parked core.
// 
// {e70867f1-fa2f-4f4e-aea1-4d8a0ba23b20}
// 
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING, 0xe70867f1, 0xfa2f, 0x4f4e, 0xae, 0xa1, 0x4d, 0x8a, 0x0b, 0xa2, 0x3b, 0x20);

//
// Specifies the factor by which to decrease the over utilization history on each core after the current performance check.
// 
// {1299023c-bc28-4f0a-81ec-d3295a8d815d}
// 
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR, 0x1299023c, 0xbc28, 0x4f0a, 0x81, 0xec, 0xd3, 0x29, 0x5a, 0x8d, 0x81, 0x5d);

//
// Specifies the threshold above which a core is considered to have been recently over utilized while parked.
// 
// {9ac18e92-aa3c-4e27-b307-01ae37307129}
// 
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD, 0x9ac18e92, 0xaa3c, 0x4e27, 0xb3, 0x07, 0x01, 0xae, 0x37, 0x30, 0x71, 0x29);

//
// Specifies the weighting given to each occurence where a parked core is found to be over utilized.
// 
// {8809c2d8-b155-42d4-bcda-0d345651b1db}
// 
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING, 0x8809c2d8, 0xb155, 0x42d4, 0xbc, 0xda, 0x0d, 0x34, 0x56, 0x51, 0xb1, 0xdb);

//
// Specifies, in percentage, the busy threshold that must be met before a parked core is considered over utilized.
// 
// {943c8cb6-6f93-4227-ad87-e9a3feec08d1}
// 
DEFINE_GUID( GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD, 0x943c8cb6, 0x6f93, 0x4227, 0xad, 0x87, 0xe9, 0xa3, 0xfe, 0xec, 0x08, 0xd1);

//
// Specifies if at least one processor per core should always remain unparked.
// 
// {a55612aa-f624-42c6-a443-7397d064c04f}
// 

DEFINE_GUID( GUID_PROCESSOR_PARKING_CORE_OVERRIDE, 0xa55612aa, 0xf624, 0x42c6, 0xa4, 0x43, 0x73, 0x97, 0xd0, 0x64, 0xc0, 0x4f);

//
// Specifies what performance state a processor should enter when first parked.
// 
// {447235c7-6a8d-4cc0-8e24-9eaf70b96e2b}
// 

DEFINE_GUID( GUID_PROCESSOR_PARKING_PERF_STATE, 0x447235c7, 0x6a8d, 0x4cc0, 0x8e, 0x24, 0x9e, 0xaf, 0x70, 0xb9, 0x6e, 0x2b);

//
// Specifies the number of perf time check intervals to average utility over.
//
// {7d24baa7-0b84-480f-840c-1b0743c00f5f}
//
DEFINE_GUID( GUID_PROCESSOR_PERF_HISTORY, 0x7d24baa7, 0x0b84, 0x480f, 0x84, 0x0c, 0x1b, 0x07, 0x43, 0xc0, 0x0f, 0x5f);

//
// Specifies active vs passive cooling.  Although not directly related to
// processor settings, it is the processor that gets throttled if we're doing
// passive cooling, so it is fairly strongly related.
// {94D3A615-A899-4AC5-AE2B-E4D8F634367F}
//
DEFINE_GUID( GUID_SYSTEM_COOLING_POLICY, 0x94D3A615, 0xA899, 0x4AC5, 0xAE, 0x2B, 0xE4, 0xD8, 0xF6, 0x34, 0x36, 0x7F);

// Lock Console on Wake
// --------------------
//

// Specifies the behavior of the system when we wake from standby or
// hibernate.  If this is set, then we will cause the console to lock
// after we resume.
//
DEFINE_GUID( GUID_LOCK_CONSOLE_ON_WAKE, 0x0E796BDB, 0x100D, 0x47D6, 0xA2, 0xD5, 0xF7, 0xD2, 0xDA, 0xA5, 0x1F, 0x51 );

// Device idle characteristics
// ---------------------------
//
// Specifies whether to use the "performance" or "conservative" timeouts for
// device idle management.
//
// 4faab71a-92e5-4726-b531-224559672d19
//
DEFINE_GUID( GUID_DEVICE_IDLE_POLICY, 0x4faab71a, 0x92e5, 0x4726, 0xb5, 0x31, 0x22, 0x45, 0x59, 0x67, 0x2d, 0x19 );

#define POWER_DEVICE_IDLE_POLICY_PERFORMANCE  0
#define POWER_DEVICE_IDLE_POLICY_CONSERVATIVE 1

// AC/DC power source
// ------------------
//

// Specifies the power source for the system.  consumers may register for
// notification when the power source changes and will be notified with
// one of 3 values:
// 0 - Indicates the system is being powered by an AC power source.
// 1 - Indicates the system is being powered by a DC power source.
// 2 - Indicates the system is being powered by a short-term DC power
//     source.  For example, this would be the case if the system is
//     being powed by a short-term battery supply in a backing UPS
//     system.  When this value is recieved, the consumer should make
//     preparations for either a system hibernate or system shutdown.
//
// { 5D3E9A59-E9D5-4B00-A6BD-FF34FF516548 }
DEFINE_GUID( GUID_ACDC_POWER_SOURCE, 0x5D3E9A59, 0xE9D5, 0x4B00, 0xA6, 0xBD, 0xFF, 0x34, 0xFF, 0x51, 0x65, 0x48 );

// Lid state changes
// -----------------
//
// Specifies the current state of the lid (open or closed). The callback won't
// be called at all until a lid device is found and its current state is known.
//
// Values:
//
// 0 - closed
// 1 - opened
//
// { BA3E0F4D-B817-4094-A2D1-D56379E6A0F3 }
//

DEFINE_GUID( GUID_LIDSWITCH_STATE_CHANGE,  0xBA3E0F4D, 0xB817, 0x4094, 0xA2, 0xD1, 0xD5, 0x63, 0x79, 0xE6, 0xA0, 0xF3 );

// Battery life remaining
// ----------------------
//

// Specifies the percentage of battery life remaining.  The consumer
// may register for notification in order to track battery life in
// a fine-grained manner.
//
// Once registered, the consumer can expect to be notified as the battery
// life percentage changes.
//
// The consumer will recieve a value between 0 and 100 (inclusive) which
// indicates percent battery life remaining.
//
// { A7AD8041-B45A-4CAE-87A3-EECBB468A9E1 }
DEFINE_GUID( GUID_BATTERY_PERCENTAGE_REMAINING, 0xA7AD8041, 0xB45A, 0x4CAE, 0x87, 0xA3, 0xEE, 0xCB, 0xB4, 0x68, 0xA9, 0xE1 );


// Notification to listeners that the system is fairly busy and won't be moving
// into an idle state any time soon.  This can be used as a hint to listeners
// that now might be a good time to do background tasks.
//
DEFINE_GUID( GUID_IDLE_BACKGROUND_TASK, 0x515C31D8, 0xF734, 0x163D, 0xA0, 0xFD, 0x11, 0xA0, 0x8C, 0x91, 0xE8, 0xF1 );

// Notification to listeners that the system is fairly busy and won't be moving
// into an idle state any time soon.  This can be used as a hint to listeners
// that now might be a good time to do background tasks.
//
// { CF23F240-2A54-48D8-B114-DE1518FF052E }
DEFINE_GUID( GUID_BACKGROUND_TASK_NOTIFICATION, 0xCF23F240, 0x2A54, 0x48D8, 0xB1, 0x14, 0xDE, 0x15, 0x18, 0xFF, 0x05, 0x2E );

// Define a GUID that will represent the action of a direct experience button
// on the platform.  Users will register for this DPPE setting and recieve
// notification when the h/w button is pressed.
//
// { 1A689231-7399-4E9A-8F99-B71F999DB3FA }
//
DEFINE_GUID( GUID_APPLAUNCH_BUTTON, 0x1A689231, 0x7399, 0x4E9A, 0x8F, 0x99, 0xB7, 0x1F, 0x99, 0x9D, 0xB3, 0xFA );

// PCI Express power settings
// ------------------------
//

// Specifies the subgroup which will contain all of the PCI Express
// settings for a single policy.
//
// {501a4d13-42af-4429-9fd1-a8218c268e20}
//
DEFINE_GUID( GUID_PCIEXPRESS_SETTINGS_SUBGROUP, 0x501a4d13, 0x42af,0x4429, 0x9f, 0xd1, 0xa8, 0x21, 0x8c, 0x26, 0x8e, 0x20 );

// Specifies the PCI Express ASPM power policy.
//
// {ee12f906-d277-404b-b6da-e5fa1a576df5}
//
DEFINE_GUID( GUID_PCIEXPRESS_ASPM_POLICY, 0xee12f906, 0xd277, 0x404b, 0xb6, 0xda, 0xe5, 0xfa, 0x1a, 0x57, 0x6d, 0xf5 );

// POWER Shutdown settings
// ------------------------
//

// Specifies if forced shutdown should be used for all button and lid initiated
// shutdown actions.
//
// {833a6b62-dfa4-46d1-82f8-e09e34d029d6}
//

DEFINE_GUID( GUID_ENABLE_SWITCH_FORCED_SHUTDOWN, 0x833a6b62, 0xdfa4, 0x46d1, 0x82, 0xf8, 0xe0, 0x9e, 0x34, 0xd0, 0x29, 0xd6 );


typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking     = 1,
    PowerSystemSleeping1   = 2,
    PowerSystemSleeping2   = 3,
    PowerSystemSleeping3   = 4,
    PowerSystemHibernate   = 5,
    PowerSystemShutdown    = 6,
    PowerSystemMaximum     = 7
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;

#define POWER_SYSTEM_MAXIMUM 7

typedef enum {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION;

typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;

typedef enum _MONITOR_DISPLAY_STATE {
    PowerMonitorOff = 0,
    PowerMonitorOn,
    PowerMonitorDim
} MONITOR_DISPLAY_STATE, *PMONITOR_DISPLAY_STATE;


#define ES_SYSTEM_REQUIRED   ((DWORD)0x00000001)
#define ES_DISPLAY_REQUIRED  ((DWORD)0x00000002)
#define ES_USER_PRESENT      ((DWORD)0x00000004)
#define ES_AWAYMODE_REQUIRED ((DWORD)0x00000040)
#define ES_CONTINUOUS        ((DWORD)0x80000000)

typedef DWORD EXECUTION_STATE, *PEXECUTION_STATE;

typedef enum {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
} LATENCY_TIME;

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

#define DIAGNOSTIC_REASON_VERSION              0

#define DIAGNOSTIC_REASON_SIMPLE_STRING        0x00000001
#define DIAGNOSTIC_REASON_DETAILED_STRING      0x00000002
#define DIAGNOSTIC_REASON_NOT_SPECIFIED        0x80000000
#define DIAGNOSTIC_REASON_INVALID_FLAGS        (~0x80000003)

#endif // (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

//
// Defines for power request APIs
//

#define POWER_REQUEST_CONTEXT_VERSION          0

#define POWER_REQUEST_CONTEXT_SIMPLE_STRING    0x00000001
#define POWER_REQUEST_CONTEXT_DETAILED_STRING  0x00000002

//
// N.B. The maximum is a macro (rather than part of enum) for cgen to be able
// to parse power.h correctly. When a new power request type is added, the
// PowerRequestMaximum should be manually incremented.
//

typedef enum _POWER_REQUEST_TYPE {
    PowerRequestDisplayRequired,
    PowerRequestSystemRequired,
    PowerRequestAwayModeRequired
} POWER_REQUEST_TYPE, *PPOWER_REQUEST_TYPE;

#define PowerRequestMaximum 3

// end_ntminiport

#if (NTDDI_VERSION >= NTDDI_WINXP)

//-----------------------------------------------------------------------------
// Device Power Information
// Accessable via CM_Get_DevInst_Registry_Property_Ex(CM_DRP_DEVICE_POWER_DATA)
//-----------------------------------------------------------------------------

#define PDCAP_D0_SUPPORTED              0x00000001
#define PDCAP_D1_SUPPORTED              0x00000002
#define PDCAP_D2_SUPPORTED              0x00000004
#define PDCAP_D3_SUPPORTED              0x00000008
#define PDCAP_WAKE_FROM_D0_SUPPORTED    0x00000010
#define PDCAP_WAKE_FROM_D1_SUPPORTED    0x00000020
#define PDCAP_WAKE_FROM_D2_SUPPORTED    0x00000040
#define PDCAP_WAKE_FROM_D3_SUPPORTED    0x00000080
#define PDCAP_WARM_EJECT_SUPPORTED      0x00000100

typedef struct CM_Power_Data_s {
    DWORD               PD_Size;
    DEVICE_POWER_STATE  PD_MostRecentPowerState;
    DWORD               PD_Capabilities;
    DWORD               PD_D1Latency;
    DWORD               PD_D2Latency;
    DWORD               PD_D3Latency;
    DEVICE_POWER_STATE  PD_PowerStateMapping[POWER_SYSTEM_MAXIMUM];
    SYSTEM_POWER_STATE  PD_DeepestSystemWake;
} CM_POWER_DATA, *PCM_POWER_DATA;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

// begin_wdm

typedef enum {
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime,                                   // Compare with KeQueryInterruptTime()
    LastSleepTime,                                  // Compare with KeQueryInterruptTime()
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent,
    SystemPowerStateLogging,
    SystemPowerLoggingEntry,
    SetPowerSettingValue,
    NotifyUserPowerSetting,
    PowerInformationLevelUnused0,
    PowerInformationLevelUnused1,
    SystemVideoState,
    TraceApplicationPowerMessage,
    TraceApplicationPowerMessageEnd,
    ProcessorPerfStates,
    ProcessorIdleStates,
    ProcessorCap,
    SystemWakeSource,
    SystemHiberFileInformation,
    TraceServicePowerMessage,
    ProcessorLoad,
    PowerShutdownNotification,
    MonitorCapabilities,
    SessionPowerInit,
    SessionDisplayState,
    PowerRequestCreate,
    PowerRequestAction,
    GetPowerRequestList,
    ProcessorInformationEx,
    NotifyUserModeLegacyPowerEvent,
    GroupPark,
    ProcessorIdleDomains,
    WakeTimerList,
    SystemHiberFileSize,
    PowerInformationLevelMaximum
} POWER_INFORMATION_LEVEL;

//
// Power Setting definitions
//

typedef enum {
    PoAc,
    PoDc,
    PoHot,
    PoConditionMaximum
} SYSTEM_POWER_CONDITION;

typedef struct {

    //
    // Version of this structure.  Currently should be set to
    // POWER_SETTING_VALUE_VERSION.
    //
    DWORD       Version;


    //
    // GUID representing the power setting being applied.
    //
    GUID        Guid;


    //
    // What power state should this setting be applied to?  E.g.
    // AC, DC, thermal, ...
    //
    SYSTEM_POWER_CONDITION PowerCondition;

    //
    // Length (in bytes) of the 'Data' member.
    //
    DWORD       DataLength;

    //
    // Data which contains the actual setting value.
    //
    BYTE    Data[ANYSIZE_ARRAY];
} SET_POWER_SETTING_VALUE, *PSET_POWER_SETTING_VALUE;

#define POWER_SETTING_VALUE_VERSION (0x1)

typedef struct {
    GUID Guid;
} NOTIFY_USER_POWER_SETTING, *PNOTIFY_USER_POWER_SETTING;

//
// Package definition for an experience button device notification.  When
// someone registers for GUID_EXPERIENCE_BUTTON, this is the definition of
// the setting data they'll get.
//
typedef struct _APPLICATIONLAUNCH_SETTING_VALUE {

    //
    // System time when the most recent button press ocurred.  Note that this is
    // specified in 100ns internvals since January 1, 1601.
    //
    LARGE_INTEGER       ActivationTime;

    //
    // Reserved for internal use.
    //
    DWORD               Flags;

    //
    // which instance of this device was pressed?
    //
    DWORD               ButtonInstanceID;


} APPLICATIONLAUNCH_SETTING_VALUE, *PAPPLICATIONLAUNCH_SETTING_VALUE;

//
// define platform roles
//

typedef enum {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop,
    PlatformRoleMobile,
    PlatformRoleWorkstation,
    PlatformRoleEnterpriseServer,
    PlatformRoleSOHOServer,
    PlatformRoleAppliancePC,
    PlatformRolePerformanceServer,
    PlatformRoleMaximum
} POWER_PLATFORM_ROLE;

//
// System power manager capabilities
//

#if (NTDDI_VERSION >= NTDDI_WINXP) || !defined(_BATCLASS_)
typedef struct {
    DWORD       Granularity;
    DWORD       Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;
#endif // (NTDDI_VERSION >= NTDDI_WINXP) || !defined(_BATCLASS_)

//

typedef struct {
    DWORD   Frequency;
    DWORD   Flags;
    DWORD   PercentFrequency;
} PPM_WMI_LEGACY_PERFSTATE, *PPPM_WMI_LEGACY_PERFSTATE;

typedef struct {
    DWORD Latency;
    DWORD Power;
    DWORD TimeCheck;
    BYTE  PromotePercent;
    BYTE  DemotePercent;
    BYTE  StateType;
    BYTE  Reserved;
    DWORD StateFlags;
    DWORD Context;
    DWORD IdleHandler;
    DWORD Reserved1;            // reserved for future use
} PPM_WMI_IDLE_STATE, *PPPM_WMI_IDLE_STATE;

typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState;          // current idle state
    DWORD OldState;             // previous idle state
    DWORD64 TargetProcessors;
    PPM_WMI_IDLE_STATE State[ANYSIZE_ARRAY];
} PPM_WMI_IDLE_STATES, *PPPM_WMI_IDLE_STATES;

typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState;          // current idle state
    DWORD OldState;             // previous idle state
    PVOID TargetProcessors;
    PPM_WMI_IDLE_STATE State[ANYSIZE_ARRAY];
} PPM_WMI_IDLE_STATES_EX, *PPPM_WMI_IDLE_STATES_EX;

typedef struct {
    DWORD Frequency;            // in Mhz
    DWORD Power;                // in milliwatts
    BYTE  PercentFrequency;
    BYTE  IncreaseLevel;        // goto higher state
    BYTE  DecreaseLevel;        // goto lower state
    BYTE  Type;                 // performance or throttle
    DWORD IncreaseTime;         // in tick counts
    DWORD DecreaseTime;         // in tick counts
    DWORD64 Control;            // control value
    DWORD64 Status;             // control value
    DWORD HitCount;
    DWORD Reserved1;            // reserved for future use
    DWORD64 Reserved2;
    DWORD64 Reserved3;
} PPM_WMI_PERF_STATE, *PPPM_WMI_PERF_STATE;

typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState;         // current state
    DWORD MaxPerfState;         // fastest state considering policy restrictions
    DWORD MinPerfState;         // slowest state considering policy restrictions
    DWORD LowestPerfState;      // slowest perf state, fixed, aka the "knee"
    DWORD ThermalConstraint;
    BYTE  BusyAdjThreshold;
    BYTE  PolicyType;           // domain coordination
    BYTE  Type;
    BYTE  Reserved;
    DWORD TimerInterval;
    DWORD64 TargetProcessors;   // domain affinity
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[ANYSIZE_ARRAY];
} PPM_WMI_PERF_STATES, *PPPM_WMI_PERF_STATES;

typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState;         // current state
    DWORD MaxPerfState;         // fastest state considering policy restrictions
    DWORD MinPerfState;         // slowest state considering policy restrictions
    DWORD LowestPerfState;      // slowest perf state, fixed, aka the "knee"
    DWORD ThermalConstraint;
    BYTE  BusyAdjThreshold;
    BYTE  PolicyType;           // domain coordination
    BYTE  Type;
    BYTE  Reserved;
    DWORD TimerInterval;
    PVOID TargetProcessors;     // domain affinity
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[ANYSIZE_ARRAY];
} PPM_WMI_PERF_STATES_EX, *PPPM_WMI_PERF_STATES_EX;

//
// Legacy processor idle accounting.
//

#define PROC_IDLE_BUCKET_COUNT 6

typedef struct {
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD64 TotalTime;
    DWORD IdleTimeBuckets[PROC_IDLE_BUCKET_COUNT];
} PPM_IDLE_STATE_ACCOUNTING, *PPPM_IDLE_STATE_ACCOUNTING;

typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD64 StartTime;
    PPM_IDLE_STATE_ACCOUNTING State[ANYSIZE_ARRAY];
} PPM_IDLE_ACCOUNTING, *PPPM_IDLE_ACCOUNTING;

//
// Processor idle accounting.
//

#define PROC_IDLE_BUCKET_COUNT_EX 16

typedef struct {
    DWORD64 TotalTimeUs;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD Count;
} PPM_IDLE_STATE_BUCKET_EX, *PPPM_IDLE_STATE_BUCKET_EX;

typedef struct {
    DWORD64 TotalTime;
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    PPM_IDLE_STATE_BUCKET_EX IdleTimeBuckets[PROC_IDLE_BUCKET_COUNT_EX];
} PPM_IDLE_STATE_ACCOUNTING_EX, *PPPM_IDLE_STATE_ACCOUNTING_EX;

typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD64 StartTime;
    __field_ecount(StateCount) PPM_IDLE_STATE_ACCOUNTING_EX State[ANYSIZE_ARRAY];
} PPM_IDLE_ACCOUNTING_EX, *PPPM_IDLE_ACCOUNTING_EX;

//
// Definitions of coordination types for _PSD, _TSD, and _CSD BIOS objects from
// the Acpi 3.0 specification
//

#define ACPI_PPM_SOFTWARE_ALL     0xFC
#define ACPI_PPM_SOFTWARE_ANY     0xFD
#define ACPI_PPM_HARDWARE_ALL     0xFE

//
// Definition of Microsoft PPM coordination types.
//

#define MS_PPM_SOFTWARE_ALL       0x1

//
// Processor firmware rundown feature bit definitions.
//

#define PPM_FIRMWARE_ACPI1C2      0x00000001
#define PPM_FIRMWARE_ACPI1C3      0x00000002
#define PPM_FIRMWARE_ACPI1TSTATES 0x00000004
#define PPM_FIRMWARE_CST          0x00000008
#define PPM_FIRMWARE_CSD          0x00000010
#define PPM_FIRMWARE_PCT          0x00000020
#define PPM_FIRMWARE_PSS          0x00000040
#define PPM_FIRMWARE_XPSS         0x00000080
#define PPM_FIRMWARE_PPC          0x00000100
#define PPM_FIRMWARE_PSD          0x00000200
#define PPM_FIRMWARE_PTC          0x00000400
#define PPM_FIRMWARE_TSS          0x00000800
#define PPM_FIRMWARE_TPC          0x00001000
#define PPM_FIRMWARE_TSD          0x00002000
#define PPM_FIRMWARE_PCCH         0x00004000
#define PPM_FIRMWARE_PCCP         0x00008000

//
// Processor Power Management WMI interface.
//

// {A5B32DDD-7F39-4abc-B892-900E43B59EBB}
DEFINE_GUID(PPM_PERFSTATE_CHANGE_GUID,
0xa5b32ddd, 0x7f39, 0x4abc, 0xb8, 0x92, 0x90, 0xe, 0x43, 0xb5, 0x9e, 0xbb);

// {995e6b7f-d653-497a-b978-36a30c29bf01}
DEFINE_GUID(PPM_PERFSTATE_DOMAIN_CHANGE_GUID,
0x995e6b7f, 0xd653, 0x497a, 0xb9, 0x78, 0x36, 0xa3, 0xc, 0x29, 0xbf, 0x1);

// {4838fe4f-f71c-4e51-9ecc-8430a7ac4c6c}
DEFINE_GUID(PPM_IDLESTATE_CHANGE_GUID,
0x4838fe4f, 0xf71c, 0x4e51, 0x9e, 0xcc, 0x84, 0x30, 0xa7, 0xac, 0x4c, 0x6c);

// {5708cc20-7d40-4bf4-b4aa-2b01338d0126}
DEFINE_GUID(PPM_PERFSTATES_DATA_GUID,
0x5708cc20, 0x7d40, 0x4bf4, 0xb4, 0xaa, 0x2b, 0x01, 0x33, 0x8d, 0x01, 0x26);

// {ba138e10-e250-4ad7-8616-cf1a7ad410e7}
DEFINE_GUID(PPM_IDLESTATES_DATA_GUID,
0xba138e10, 0xe250, 0x4ad7, 0x86, 0x16, 0xcf, 0x1a, 0x7a, 0xd4, 0x10, 0xe7);

// {e2a26f78-ae07-4ee0-a30f-ce354f5a94cd}
DEFINE_GUID(PPM_IDLE_ACCOUNTING_GUID,
0xe2a26f78, 0xae07, 0x4ee0, 0xa3, 0x0f, 0xce, 0x54, 0xf5, 0x5a, 0x94, 0xcd);

// {d67abd39-81f8-4a5e-8152-72e31ec912ee}
DEFINE_GUID(PPM_IDLE_ACCOUNTING_EX_GUID,
0xd67abd39, 0x81f8, 0x4a5e, 0x81, 0x52, 0x72, 0xe3, 0x1e, 0xc9, 0x12, 0xee);

// {a852c2c8-1a4c-423b-8c2c-f30d82931a88}
DEFINE_GUID(PPM_THERMALCONSTRAINT_GUID,
0xa852c2c8, 0x1a4c, 0x423b, 0x8c, 0x2c, 0xf3, 0x0d, 0x82, 0x93, 0x1a, 0x88);

// {7fd18652-0cfe-40d2-b0a1-0b066a87759e}
DEFINE_GUID(PPM_PERFMON_PERFSTATE_GUID,
0x7fd18652, 0xcfe, 0x40d2, 0xb0, 0xa1, 0xb, 0x6, 0x6a, 0x87, 0x75, 0x9e);

// {48f377b8-6880-4c7b-8bdc-380176c6654d}
DEFINE_GUID(PPM_THERMAL_POLICY_CHANGE_GUID,
0x48f377b8, 0x6880, 0x4c7b, 0x8b, 0xdc, 0x38, 0x1, 0x76, 0xc6, 0x65, 0x4d);


typedef struct {
    DWORD State;
    DWORD Status;
    DWORD Latency;
    DWORD Speed;
    DWORD Processor;
} PPM_PERFSTATE_EVENT, *PPPM_PERFSTATE_EVENT;

typedef struct {
    DWORD State;
    DWORD Latency;
    DWORD Speed;
    DWORD64 Processors;
} PPM_PERFSTATE_DOMAIN_EVENT, *PPPM_PERFSTATE_DOMAIN_EVENT;

typedef struct {
    DWORD NewState;
    DWORD OldState;
    DWORD64 Processors;
} PPM_IDLESTATE_EVENT, *PPPM_IDLESTATE_EVENT;

typedef struct {
    DWORD ThermalConstraint;
    DWORD64 Processors;
} PPM_THERMALCHANGE_EVENT, *PPPM_THERMALCHANGE_EVENT;

#pragma warning(push)
#pragma warning(disable:4121)

typedef struct {
    BYTE  Mode;
    DWORD64 Processors;
} PPM_THERMAL_POLICY_EVENT, *PPPM_THERMAL_POLICY_EVENT;

#pragma warning(pop)

// Power Policy Management interfaces
//

typedef struct {
    POWER_ACTION    Action;
    DWORD           Flags;
    DWORD           EventCode;
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;

// POWER_ACTION_POLICY->Flags:
#define POWER_ACTION_QUERY_ALLOWED      0x00000001
#define POWER_ACTION_UI_ALLOWED         0x00000002
#define POWER_ACTION_OVERRIDE_APPS      0x00000004
#define POWER_ACTION_PSEUDO_TRANSITION  0x08000000
#define POWER_ACTION_LIGHTEST_FIRST     0x10000000
#define POWER_ACTION_LOCK_CONSOLE       0x20000000
#define POWER_ACTION_DISABLE_WAKES      0x40000000
#define POWER_ACTION_CRITICAL           0x80000000

// POWER_ACTION_POLICY->EventCode flags
#define POWER_LEVEL_USER_NOTIFY_TEXT      0x00000001
#define POWER_LEVEL_USER_NOTIFY_SOUND     0x00000002
#define POWER_LEVEL_USER_NOTIFY_EXEC      0x00000004
#define POWER_USER_NOTIFY_BUTTON          0x00000008
#define POWER_USER_NOTIFY_SHUTDOWN        0x00000010
#define POWER_USER_NOTIFY_FORCED_SHUTDOWN 0x00000020
#define POWER_FORCE_TRIGGER_RESET         0x80000000

// Note: for battery alarm EventCodes, the ID of the battery alarm << 16 is ORed
// into the flags.  For example: DISCHARGE_POLICY_LOW << 16

//
// The GUID_BATTERY_DISCHARGE_FLAGS_x power settings use a subset of EventCode
// flags.  The POWER_FORCE_TRIGGER_RESET flag doesn't make sense for a battery
// alarm so it is overloaded for other purposes (gerneral enable/disable).
#define BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK  0x00000007
#define BATTERY_DISCHARGE_FLAGS_ENABLE  0x80000000

// system battery drain policies
typedef struct {
    BOOLEAN                 Enable;
    BYTE                    Spare[3];
    DWORD                   BatteryLevel;
    POWER_ACTION_POLICY     PowerPolicy;
    SYSTEM_POWER_STATE      MinSystemState;
} SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL;

// Discharge policy constants
#define NUM_DISCHARGE_POLICIES      4
#define DISCHARGE_POLICY_CRITICAL   0
#define DISCHARGE_POLICY_LOW        1


// system power policies
typedef struct _SYSTEM_POWER_POLICY {
    DWORD                   Revision;       // 1

    // events
    POWER_ACTION_POLICY     PowerButton;
    POWER_ACTION_POLICY     SleepButton;
    POWER_ACTION_POLICY     LidClose;
    SYSTEM_POWER_STATE      LidOpenWake;
    DWORD                   Reserved;

    // "system idle" detection
    POWER_ACTION_POLICY     Idle;
    DWORD                   IdleTimeout;
    BYTE                    IdleSensitivity;

    BYTE                    DynamicThrottle;
    BYTE                    Spare2[2];

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MinSleep;
    SYSTEM_POWER_STATE      MaxSleep;
    SYSTEM_POWER_STATE      ReducedLatencySleep;
    DWORD                   WinLogonFlags;

    DWORD                   Spare3;

    // parameters for dozing
    //
    DWORD                   DozeS4Timeout;

    // battery policies
    DWORD                   BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL      DischargePolicy[NUM_DISCHARGE_POLICIES];

    // video policies
    DWORD                   VideoTimeout;
    BOOLEAN                 VideoDimDisplay;
    DWORD                   VideoReserved[3];

    // hard disk policies
    DWORD                   SpindownTimeout;

    // processor policies
    BOOLEAN                 OptimizeForPower;
    BYTE                    FanThrottleTolerance;
    BYTE                    ForcedThrottle;
    BYTE                    MinThrottle;
    POWER_ACTION_POLICY     OverThrottled;

} SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY;


// processor power policy state

//
// Processor Idle State Policy.
//

#define PROCESSOR_IDLESTATE_POLICY_COUNT 0x3

typedef struct {
    DWORD TimeCheck;
    BYTE  DemotePercent;
    BYTE  PromotePercent;
    BYTE  Spare[2];
} PROCESSOR_IDLESTATE_INFO, *PPROCESSOR_IDLESTATE_INFO;

typedef struct {
    WORD   Revision;
    union {
        WORD   AsWORD  ;
        struct {
            WORD   AllowScaling : 1;
            WORD   Disabled : 1;
            WORD   Reserved : 14;
        } DUMMYSTRUCTNAME;
    } Flags;

    DWORD PolicyCount;
    PROCESSOR_IDLESTATE_INFO Policy[PROCESSOR_IDLESTATE_POLICY_COUNT];
} PROCESSOR_IDLESTATE_POLICY, *PPROCESSOR_IDLESTATE_POLICY;

//
// Legacy Processor Policy.  This is only provided to allow legacy
// applications to compile.  New applications must use
// PROCESSOR_IDLESTATE_POLICY.
//

#define PO_THROTTLE_NONE            0
#define PO_THROTTLE_CONSTANT        1
#define PO_THROTTLE_DEGRADE         2
#define PO_THROTTLE_ADAPTIVE        3
#define PO_THROTTLE_MAXIMUM         4   // not a policy, just a limit


typedef struct _PROCESSOR_POWER_POLICY_INFO {

    // Time based information (will be converted to kernel units)
    DWORD                   TimeCheck;                      // in US
    DWORD                   DemoteLimit;                    // in US
    DWORD                   PromoteLimit;                   // in US

    // Percentage based information
    BYTE                    DemotePercent;
    BYTE                    PromotePercent;
    BYTE                    Spare[2];

    // Flags
    DWORD                   AllowDemotion:1;
    DWORD                   AllowPromotion:1;
    DWORD                   Reserved:30;

} PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO;

// processor power policy
typedef struct _PROCESSOR_POWER_POLICY {
    DWORD                       Revision;       // 1

    // Dynamic Throttling Policy
    BYTE                        DynamicThrottle;
    BYTE                        Spare[3];

    // Flags
    DWORD                       DisableCStates:1;
    DWORD                       Reserved:31;

    // System policy information
    // The Array is last, in case it needs to be grown and the structure
    // revision incremented.
    DWORD                       PolicyCount;
    PROCESSOR_POWER_POLICY_INFO Policy[3];

} PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY;

//
// Processor Perf State Policy.
//

typedef struct {
    DWORD Revision;
    BYTE  MaxThrottle;
    BYTE  MinThrottle;
    BYTE  BusyAdjThreshold;
    union {
        BYTE  Spare;
        union {
            BYTE  AsBYTE ;
            struct {
                BYTE  NoDomainAccounting : 1;
                BYTE  IncreasePolicy: 2;
                BYTE  DecreasePolicy: 2;
                BYTE  Reserved : 3;
            } DUMMYSTRUCTNAME;
        } Flags;
    } DUMMYUNIONNAME;
    
    DWORD TimeCheck;
    DWORD IncreaseTime;
    DWORD DecreaseTime;
    DWORD IncreasePercent;
    DWORD DecreasePercent;
} PROCESSOR_PERFSTATE_POLICY, *PPROCESSOR_PERFSTATE_POLICY;

// administrator power policy overrides
typedef struct _ADMINISTRATOR_POWER_POLICY {

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MinSleep;
    SYSTEM_POWER_STATE      MaxSleep;

    // video policies
    DWORD                   MinVideoTimeout;
    DWORD                   MaxVideoTimeout;

    // disk policies
    DWORD                   MinSpindownTimeout;
    DWORD                   MaxSpindownTimeout;
} ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY;


typedef struct {
    // Misc supported system features
    BOOLEAN             PowerButtonPresent;
    BOOLEAN             SleepButtonPresent;
    BOOLEAN             LidPresent;
    BOOLEAN             SystemS1;
    BOOLEAN             SystemS2;
    BOOLEAN             SystemS3;
    BOOLEAN             SystemS4;           // hibernate
    BOOLEAN             SystemS5;           // off
    BOOLEAN             HiberFilePresent;
    BOOLEAN             FullWake;
    BOOLEAN             VideoDimPresent;
    BOOLEAN             ApmPresent;
    BOOLEAN             UpsPresent;

    // Processors
    BOOLEAN             ThermalControl;
    BOOLEAN             ProcessorThrottle;
    BYTE                ProcessorMinThrottle;

#if (NTDDI_VERSION < NTDDI_WINXP)
    BYTE                ProcessorThrottleScale;
    BYTE                spare2[4];
#else
    BYTE                ProcessorMaxThrottle;
    BOOLEAN             FastSystemS4;
    BYTE                spare2[3];
#endif // (NTDDI_VERSION < NTDDI_WINXP)

    // Disk
    BOOLEAN             DiskSpinDown;
    BYTE                spare3[8];

    // System Battery
    BOOLEAN             SystemBatteriesPresent;
    BOOLEAN             BatteriesAreShortTerm;
    BATTERY_REPORTING_SCALE BatteryScale[3];

    // Wake
    SYSTEM_POWER_STATE  AcOnLineWake;
    SYSTEM_POWER_STATE  SoftLidWake;
    SYSTEM_POWER_STATE  RtcWake;
    SYSTEM_POWER_STATE  MinDeviceWakeState; // note this may change on driver load
    SYSTEM_POWER_STATE  DefaultLowLatencyWake;
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;

typedef struct {
    BOOLEAN             AcOnLine;
    BOOLEAN             BatteryPresent;
    BOOLEAN             Charging;
    BOOLEAN             Discharging;
    BOOLEAN             Spare1[4];

    DWORD               MaxCapacity;
    DWORD               RemainingCapacity;
    DWORD               Rate;
    DWORD               EstimatedTime;

    DWORD               DefaultAlert1;
    DWORD               DefaultAlert2;
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;



//
// Image Format
//


#ifndef _MAC

#include "pshpack4.h"                   // 4 byte packing is the default

#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
#define IMAGE_VXD_SIGNATURE                 0x454C      // LE
#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00

#include "pshpack2.h"                   // 16 bit headers are 2 byte packed

#else

#include "pshpack1.h"

#define IMAGE_DOS_SIGNATURE                 0x4D5A      // MZ
#define IMAGE_OS2_SIGNATURE                 0x4E45      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x4C45      // LE
#define IMAGE_NT_SIGNATURE                  0x50450000  // PE00
#endif

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
    WORD   ne_magic;                    // Magic number
    CHAR   ne_ver;                      // Version number
    CHAR   ne_rev;                      // Revision number
    WORD   ne_enttab;                   // Offset of Entry Table
    WORD   ne_cbenttab;                 // Number of bytes in Entry Table
    LONG   ne_crc;                      // Checksum of whole file
    WORD   ne_flags;                    // Flag word
    WORD   ne_autodata;                 // Automatic data segment number
    WORD   ne_heap;                     // Initial heap allocation
    WORD   ne_stack;                    // Initial stack allocation
    LONG   ne_csip;                     // Initial CS:IP setting
    LONG   ne_sssp;                     // Initial SS:SP setting
    WORD   ne_cseg;                     // Count of file segments
    WORD   ne_cmod;                     // Entries in Module Reference Table
    WORD   ne_cbnrestab;                // Size of non-resident name table
    WORD   ne_segtab;                   // Offset of Segment Table
    WORD   ne_rsrctab;                  // Offset of Resource Table
    WORD   ne_restab;                   // Offset of resident name table
    WORD   ne_modtab;                   // Offset of Module Reference Table
    WORD   ne_imptab;                   // Offset of Imported Names Table
    LONG   ne_nrestab;                  // Offset of Non-resident Names Table
    WORD   ne_cmovent;                  // Count of movable entries
    WORD   ne_align;                    // Segment alignment shift count
    WORD   ne_cres;                     // Count of resource segments
    BYTE   ne_exetyp;                   // Target Operating system
    BYTE   ne_flagsothers;              // Other .EXE flags
    WORD   ne_pretthunks;               // offset to return thunks
    WORD   ne_psegrefbytes;             // offset to segment ref. bytes
    WORD   ne_swaparea;                 // Minimum code swap area size
    WORD   ne_expver;                   // Expected Windows version number
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

typedef struct _IMAGE_VXD_HEADER {      // Windows VXD header
    WORD   e32_magic;                   // Magic number
    BYTE   e32_border;                  // The byte ordering for the VXD
    BYTE   e32_worder;                  // The word ordering for the VXD
    DWORD  e32_level;                   // The EXE format level for now = 0
    WORD   e32_cpu;                     // The CPU type
    WORD   e32_os;                      // The OS type
    DWORD  e32_ver;                     // Module version
    DWORD  e32_mflags;                  // Module flags
    DWORD  e32_mpages;                  // Module # pages
    DWORD  e32_startobj;                // Object # for instruction pointer
    DWORD  e32_eip;                     // Extended instruction pointer
    DWORD  e32_stackobj;                // Object # for stack pointer
    DWORD  e32_esp;                     // Extended stack pointer
    DWORD  e32_pagesize;                // VXD page size
    DWORD  e32_lastpagesize;            // Last page size in VXD
    DWORD  e32_fixupsize;               // Fixup section size
    DWORD  e32_fixupsum;                // Fixup section checksum
    DWORD  e32_ldrsize;                 // Loader section size
    DWORD  e32_ldrsum;                  // Loader section checksum
    DWORD  e32_objtab;                  // Object table offset
    DWORD  e32_objcnt;                  // Number of objects in module
    DWORD  e32_objmap;                  // Object page map offset
    DWORD  e32_itermap;                 // Object iterated data map offset
    DWORD  e32_rsrctab;                 // Offset of Resource Table
    DWORD  e32_rsrccnt;                 // Number of resource entries
    DWORD  e32_restab;                  // Offset of resident name table
    DWORD  e32_enttab;                  // Offset of Entry Table
    DWORD  e32_dirtab;                  // Offset of Module Directive Table
    DWORD  e32_dircnt;                  // Number of module directives
    DWORD  e32_fpagetab;                // Offset of Fixup Page Table
    DWORD  e32_frectab;                 // Offset of Fixup Record Table
    DWORD  e32_impmod;                  // Offset of Import Module Name Table
    DWORD  e32_impmodcnt;               // Number of entries in Import Module Name Table
    DWORD  e32_impproc;                 // Offset of Import Procedure Name Table
    DWORD  e32_pagesum;                 // Offset of Per-Page Checksum Table
    DWORD  e32_datapage;                // Offset of Enumerated Data Pages
    DWORD  e32_preload;                 // Number of preload pages
    DWORD  e32_nrestab;                 // Offset of Non-resident Names Table
    DWORD  e32_cbnrestab;               // Size of Non-resident Name Table
    DWORD  e32_nressum;                 // Non-resident Name Table Checksum
    DWORD  e32_autodata;                // Object # for automatic data object
    DWORD  e32_debuginfo;               // Offset of the debugging information
    DWORD  e32_debuglen;                // The length of the debugging info. in bytes
    DWORD  e32_instpreload;             // Number of instance pages in preload section of VXD file
    DWORD  e32_instdemand;              // Number of instance pages in demand load section of VXD file
    DWORD  e32_heapsize;                // Size of heap - for 16-bit apps
    BYTE   e32_res3[12];                // Reserved words
    DWORD  e32_winresoff;
    DWORD  e32_winreslen;
    WORD   e32_devid;                   // Device ID for VxD
    WORD   e32_ddkver;                  // DDK version for VxD
  } IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;

#ifndef _MAC
#include "poppack.h"                    // Back to 4 byte packing
#endif

//
// File header format.
//

typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

#define IMAGE_SIZEOF_FILE_HEADER             20

#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
#define IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  // Agressively trim working set
#define IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  // App can handle >2gb addresses
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  // If Image is on removable media, copy and run from the swap file.
#define IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  // If Image is on Net, copy and run from the swap file.
#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
#define IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  // File should only be run on a UP machine
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.

#define IMAGE_FILE_MACHINE_UNKNOWN           0
#define IMAGE_FILE_MACHINE_I386              0x014c  // Intel 386.
#define IMAGE_FILE_MACHINE_R3000             0x0162  // MIPS little-endian, 0x160 big-endian
#define IMAGE_FILE_MACHINE_R4000             0x0166  // MIPS little-endian
#define IMAGE_FILE_MACHINE_R10000            0x0168  // MIPS little-endian
#define IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  // MIPS little-endian WCE v2
#define IMAGE_FILE_MACHINE_ALPHA             0x0184  // Alpha_AXP
#define IMAGE_FILE_MACHINE_SH3               0x01a2  // SH3 little-endian
#define IMAGE_FILE_MACHINE_SH3DSP            0x01a3
#define IMAGE_FILE_MACHINE_SH3E              0x01a4  // SH3E little-endian
#define IMAGE_FILE_MACHINE_SH4               0x01a6  // SH4 little-endian
#define IMAGE_FILE_MACHINE_SH5               0x01a8  // SH5
#define IMAGE_FILE_MACHINE_ARM               0x01c0  // ARM Little-Endian
#define IMAGE_FILE_MACHINE_THUMB             0x01c2
#define IMAGE_FILE_MACHINE_AM33              0x01d3
#define IMAGE_FILE_MACHINE_POWERPC           0x01F0  // IBM PowerPC Little-Endian
#define IMAGE_FILE_MACHINE_POWERPCFP         0x01f1
#define IMAGE_FILE_MACHINE_IA64              0x0200  // Intel 64
#define IMAGE_FILE_MACHINE_MIPS16            0x0266  // MIPS
#define IMAGE_FILE_MACHINE_ALPHA64           0x0284  // ALPHA64
#define IMAGE_FILE_MACHINE_MIPSFPU           0x0366  // MIPS
#define IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  // MIPS
#define IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64
#define IMAGE_FILE_MACHINE_TRICORE           0x0520  // Infineon
#define IMAGE_FILE_MACHINE_CEF               0x0CEF
#define IMAGE_FILE_MACHINE_EBC               0x0EBC  // EFI Byte Code
#define IMAGE_FILE_MACHINE_AMD64             0x8664  // AMD64 (K8)
#define IMAGE_FILE_MACHINE_M32R              0x9041  // M32R little-endian
#define IMAGE_FILE_MACHINE_CEE               0xC0EE

//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16

//
// Optional header format.
//

typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    WORD   Magic;
    BYTE   MajorLinkerVersion;
    BYTE   MinorLinkerVersion;
    DWORD  SizeOfCode;
    DWORD  SizeOfInitializedData;
    DWORD  SizeOfUninitializedData;
    DWORD  AddressOfEntryPoint;
    DWORD  BaseOfCode;
    DWORD  BaseOfData;
    DWORD  BaseOfBss;
    DWORD  GprMask;
    DWORD  CprMask[4];
    DWORD  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

#define IMAGE_NT_OPTIONAL_HDR32_MAGIC      0x10b
#define IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107

#ifdef _WIN64
typedef IMAGE_OPTIONAL_HEADER64             IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER64            PIMAGE_OPTIONAL_HEADER;
#define IMAGE_NT_OPTIONAL_HDR_MAGIC         IMAGE_NT_OPTIONAL_HDR64_MAGIC
#else
typedef IMAGE_OPTIONAL_HEADER32             IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER32            PIMAGE_OPTIONAL_HEADER;
#define IMAGE_NT_OPTIONAL_HDR_MAGIC         IMAGE_NT_OPTIONAL_HDR32_MAGIC
#endif

typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;

#ifdef _WIN64
typedef IMAGE_NT_HEADERS64                  IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS64                 PIMAGE_NT_HEADERS;
#else
typedef IMAGE_NT_HEADERS32                  IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS32                 PIMAGE_NT_HEADERS;
#endif

// IMAGE_FIRST_SECTION doesn't need 32/64 versions since the file header is the same either way.

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((ULONG_PTR)(ntheader) +                                            \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))

// Subsystem Values

#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.
#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.
#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image runs in the Posix character subsystem.
#define IMAGE_SUBSYSTEM_NATIVE_WINDOWS       8   // image is a native Win9x driver.
#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI       9   // Image runs in the Windows CE subsystem.
#define IMAGE_SUBSYSTEM_EFI_APPLICATION      10  //
#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER  11   //
#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER   12  //
#define IMAGE_SUBSYSTEM_EFI_ROM              13
#define IMAGE_SUBSYSTEM_XBOX                 14
#define IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION 16

// DllCharacteristics Entries

//      IMAGE_LIBRARY_PROCESS_INIT            0x0001     // Reserved.
//      IMAGE_LIBRARY_PROCESS_TERM            0x0002     // Reserved.
//      IMAGE_LIBRARY_THREAD_INIT             0x0004     // Reserved.
//      IMAGE_LIBRARY_THREAD_TERM             0x0008     // Reserved.
#define IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040     // DLL can move.
#define IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY    0x0080     // Code Integrity Image
#define IMAGE_DLLCHARACTERISTICS_NX_COMPAT    0x0100     // Image is NX compatible
#define IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 0x0200     // Image understands isolation and doesn't want it
#define IMAGE_DLLCHARACTERISTICS_NO_SEH       0x0400     // Image does not use SEH.  No SE handler may reside in this image
#define IMAGE_DLLCHARACTERISTICS_NO_BIND      0x0800     // Do not bind this image.
//                                            0x1000     // Reserved.
#define IMAGE_DLLCHARACTERISTICS_WDM_DRIVER   0x2000     // Driver uses WDM model
//                                            0x4000     // Reserved.
#define IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE     0x8000

// Directory Entries

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor

//
// Non-COFF Object file header
//

typedef struct ANON_OBJECT_HEADER {
    WORD    Sig1;            // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD    Sig2;            // Must be 0xffff
    WORD    Version;         // >= 1 (implies the CLSID field is present)
    WORD    Machine;
    DWORD   TimeDateStamp;
    CLSID   ClassID;         // Used to invoke CoCreateInstance
    DWORD   SizeOfData;      // Size of data that follows the header
} ANON_OBJECT_HEADER;

typedef struct ANON_OBJECT_HEADER_V2 {
    WORD    Sig1;            // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD    Sig2;            // Must be 0xffff
    WORD    Version;         // >= 2 (implies the Flags field is present - otherwise V1)
    WORD    Machine;
    DWORD   TimeDateStamp;
    CLSID   ClassID;         // Used to invoke CoCreateInstance
    DWORD   SizeOfData;      // Size of data that follows the header
    DWORD   Flags;           // 0x1 -> contains metadata
    DWORD   MetaDataSize;    // Size of CLR metadata
    DWORD   MetaDataOffset;  // Offset of CLR metadata
} ANON_OBJECT_HEADER_V2;

typedef struct ANON_OBJECT_HEADER_BIGOBJ {
   /* same as ANON_OBJECT_HEADER_V2 */
    WORD    Sig1;            // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD    Sig2;            // Must be 0xffff
    WORD    Version;         // >= 2 (implies the Flags field is present)
    WORD    Machine;         // Actual machine - IMAGE_FILE_MACHINE_xxx
    DWORD   TimeDateStamp;
    CLSID   ClassID;         // {D1BAA1C7-BAEE-4ba9-AF20-FAF66AA4DCB8}
    DWORD   SizeOfData;      // Size of data that follows the header
    DWORD   Flags;           // 0x1 -> contains metadata
    DWORD   MetaDataSize;    // Size of CLR metadata
    DWORD   MetaDataOffset;  // Offset of CLR metadata

    /* bigobj specifics */
    DWORD   NumberOfSections; // extended from WORD
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
} ANON_OBJECT_HEADER_BIGOBJ;

//
// Section header format.
//

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER          40

//
// Section characteristics.
//
//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.
//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.
//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.
//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.
#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.

#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.

#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.
//                                           0x00002000  // Reserved.
//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000
#define IMAGE_SCN_NO_DEFER_SPEC_EXC          0x00004000  // Reset speculative exceptions handling bits in the TLB entries for this section.
#define IMAGE_SCN_GPREL                      0x00008000  // Section content can be accessed relative to GP
#define IMAGE_SCN_MEM_FARDATA                0x00008000
//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000
#define IMAGE_SCN_MEM_PURGEABLE              0x00020000
#define IMAGE_SCN_MEM_16BIT                  0x00020000
#define IMAGE_SCN_MEM_LOCKED                 0x00040000
#define IMAGE_SCN_MEM_PRELOAD                0x00080000

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //
#define IMAGE_SCN_ALIGN_128BYTES             0x00800000  //
#define IMAGE_SCN_ALIGN_256BYTES             0x00900000  //
#define IMAGE_SCN_ALIGN_512BYTES             0x00A00000  //
#define IMAGE_SCN_ALIGN_1024BYTES            0x00B00000  //
#define IMAGE_SCN_ALIGN_2048BYTES            0x00C00000  //
#define IMAGE_SCN_ALIGN_4096BYTES            0x00D00000  //
#define IMAGE_SCN_ALIGN_8192BYTES            0x00E00000  //
// Unused                                    0x00F00000
#define IMAGE_SCN_ALIGN_MASK                 0x00F00000

#define IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000  // Section contains extended relocations.
#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

//
// TLS Chaacteristic Flags
//
#define IMAGE_SCN_SCALE_INDEX                0x00000001  // Tls index is scaled

#ifndef _MAC
#include "pshpack2.h"                       // Symbols, relocs, and linenumbers are 2 byte packed
#endif

//
// Symbol format.
//

typedef struct _IMAGE_SYMBOL {
    union {
        BYTE    ShortName[8];
        struct {
            DWORD   Short;     // if 0, use LongName
            DWORD   Long;      // offset into string table
        } Name;
        DWORD   LongName[2];    // PBYTE [2]
    } N;
    DWORD   Value;
    SHORT   SectionNumber;
    WORD    Type;
    BYTE    StorageClass;
    BYTE    NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL UNALIGNED *PIMAGE_SYMBOL;

#define IMAGE_SIZEOF_SYMBOL                  18

typedef struct _IMAGE_SYMBOL_EX {
    union {
        BYTE     ShortName[8];
        struct {
            DWORD   Short;     // if 0, use LongName
            DWORD   Long;      // offset into string table
        } Name;
        DWORD   LongName[2];    // PBYTE  [2]
    } N;
    DWORD   Value;
    LONG    SectionNumber;
    WORD    Type;
    BYTE    StorageClass;
    BYTE    NumberOfAuxSymbols;
} IMAGE_SYMBOL_EX;
typedef IMAGE_SYMBOL_EX UNALIGNED *PIMAGE_SYMBOL_EX;

//
// Section values.
//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//

#define IMAGE_SYM_UNDEFINED           (SHORT)0          // Symbol is undefined or is common.
#define IMAGE_SYM_ABSOLUTE            (SHORT)-1         // Symbol is an absolute value.
#define IMAGE_SYM_DEBUG               (SHORT)-2         // Symbol is a special debug item.
#define IMAGE_SYM_SECTION_MAX         0xFEFF            // Values 0xFF00-0xFFFF are special
#define IMAGE_SYM_SECTION_MAX_EX      MAXLONG

//
// Type (fundamental) values.
//

#define IMAGE_SYM_TYPE_NULL                 0x0000  // no type.
#define IMAGE_SYM_TYPE_VOID                 0x0001  //
#define IMAGE_SYM_TYPE_CHAR                 0x0002  // type character.
#define IMAGE_SYM_TYPE_SHORT                0x0003  // type short integer.
#define IMAGE_SYM_TYPE_INT                  0x0004  //
#define IMAGE_SYM_TYPE_LONG                 0x0005  //
#define IMAGE_SYM_TYPE_FLOAT                0x0006  //
#define IMAGE_SYM_TYPE_DOUBLE               0x0007  //
#define IMAGE_SYM_TYPE_STRUCT               0x0008  //
#define IMAGE_SYM_TYPE_UNION                0x0009  //
#define IMAGE_SYM_TYPE_ENUM                 0x000A  // enumeration.
#define IMAGE_SYM_TYPE_MOE                  0x000B  // member of enumeration.
#define IMAGE_SYM_TYPE_BYTE                 0x000C  //
#define IMAGE_SYM_TYPE_WORD                 0x000D  //
#define IMAGE_SYM_TYPE_UINT                 0x000E  //
#define IMAGE_SYM_TYPE_DWORD                0x000F  //
#define IMAGE_SYM_TYPE_PCODE                0x8000  //
//
// Type (derived) values.
//

#define IMAGE_SYM_DTYPE_NULL                0       // no derived type.
#define IMAGE_SYM_DTYPE_POINTER             1       // pointer.
#define IMAGE_SYM_DTYPE_FUNCTION            2       // function.
#define IMAGE_SYM_DTYPE_ARRAY               3       // array.

//
// Storage classes.
//
#define IMAGE_SYM_CLASS_END_OF_FUNCTION     (BYTE )-1
#define IMAGE_SYM_CLASS_NULL                0x0000
#define IMAGE_SYM_CLASS_AUTOMATIC           0x0001
#define IMAGE_SYM_CLASS_EXTERNAL            0x0002
#define IMAGE_SYM_CLASS_STATIC              0x0003
#define IMAGE_SYM_CLASS_REGISTER            0x0004
#define IMAGE_SYM_CLASS_EXTERNAL_DEF        0x0005
#define IMAGE_SYM_CLASS_LABEL               0x0006
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL     0x0007
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT    0x0008
#define IMAGE_SYM_CLASS_ARGUMENT            0x0009
#define IMAGE_SYM_CLASS_STRUCT_TAG          0x000A
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION     0x000B
#define IMAGE_SYM_CLASS_UNION_TAG           0x000C
#define IMAGE_SYM_CLASS_TYPE_DEFINITION     0x000D
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC    0x000E
#define IMAGE_SYM_CLASS_ENUM_TAG            0x000F
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM      0x0010
#define IMAGE_SYM_CLASS_REGISTER_PARAM      0x0011
#define IMAGE_SYM_CLASS_BIT_FIELD           0x0012

#define IMAGE_SYM_CLASS_FAR_EXTERNAL        0x0044  //

#define IMAGE_SYM_CLASS_BLOCK               0x0064
#define IMAGE_SYM_CLASS_FUNCTION            0x0065
#define IMAGE_SYM_CLASS_END_OF_STRUCT       0x0066
#define IMAGE_SYM_CLASS_FILE                0x0067
// new
#define IMAGE_SYM_CLASS_SECTION             0x0068
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL       0x0069

#define IMAGE_SYM_CLASS_CLR_TOKEN           0x006B

// type packing constants

#define N_BTMASK                            0x000F
#define N_TMASK                             0x0030
#define N_TMASK1                            0x00C0
#define N_TMASK2                            0x00F0
#define N_BTSHFT                            4
#define N_TSHIFT                            2
// MACROS

// Basic Type of  x
#define BTYPE(x) ((x) & N_BTMASK)

// Is x a pointer?
#ifndef ISPTR
#define ISPTR(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_POINTER << N_BTSHFT))
#endif

// Is x a function?
#ifndef ISFCN
#define ISFCN(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_FUNCTION << N_BTSHFT))
#endif

// Is x an array?

#ifndef ISARY
#define ISARY(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY << N_BTSHFT))
#endif

// Is x a structure, union, or enumeration TAG?
#ifndef ISTAG
#define ISTAG(x) ((x)==IMAGE_SYM_CLASS_STRUCT_TAG || (x)==IMAGE_SYM_CLASS_UNION_TAG || (x)==IMAGE_SYM_CLASS_ENUM_TAG)
#endif

#ifndef INCREF
#define INCREF(x) ((((x)&~N_BTMASK)<<N_TSHIFT)|(IMAGE_SYM_DTYPE_POINTER<<N_BTSHFT)|((x)&N_BTMASK))
#endif
#ifndef DECREF
#define DECREF(x) ((((x)>>N_TSHIFT)&~N_BTMASK)|((x)&N_BTMASK))
#endif

#include <pshpack2.h>

typedef struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    BYTE  bAuxType;                  // IMAGE_AUX_SYMBOL_TYPE
    BYTE  bReserved;                 // Must be 0
    DWORD SymbolTableIndex;
    BYTE  rgbReserved[12];           // Must be 0
} IMAGE_AUX_SYMBOL_TOKEN_DEF;

typedef IMAGE_AUX_SYMBOL_TOKEN_DEF UNALIGNED *PIMAGE_AUX_SYMBOL_TOKEN_DEF;

#include <poppack.h>

//
// Auxiliary entry format.
//

typedef union _IMAGE_AUX_SYMBOL {
    struct {
        DWORD    TagIndex;                      // struct, union, or enum tag index
        union {
            struct {
                WORD    Linenumber;             // declaration line number
                WORD    Size;                   // size of struct, union, or enum
            } LnSz;
           DWORD    TotalSize;
        } Misc;
        union {
            struct {                            // if ISFCN, tag, or .bb
                DWORD    PointerToLinenumber;
                DWORD    PointerToNextFunction;
            } Function;
            struct {                            // if ISARY, up to 4 dimen.
                WORD     Dimension[4];
            } Array;
        } FcnAry;
        WORD    TvIndex;                        // tv index
    } Sym;
    struct {
        BYTE    Name[IMAGE_SIZEOF_SYMBOL];
    } File;
    struct {
        DWORD   Length;                         // section length
        WORD    NumberOfRelocations;            // number of relocation entries
        WORD    NumberOfLinenumbers;            // number of line numbers
        DWORD   CheckSum;                       // checksum for communal
        SHORT   Number;                         // section number to associate with
        BYTE    Selection;                      // communal selection type
	BYTE    bReserved;
	SHORT   HighNumber;                     // high bits of the section number
    } Section;
    IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;   
    struct {
        DWORD crc;
        BYTE  rgbReserved[14];
    } CRC;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL UNALIGNED *PIMAGE_AUX_SYMBOL;

typedef union _IMAGE_AUX_SYMBOL_EX {
    struct {
        DWORD   WeakDefaultSymIndex;                       // the weak extern default symbol index
        DWORD   WeakSearchType;
        BYTE    rgbReserved[12];
    } Sym;
    struct {
        BYTE    Name[sizeof(IMAGE_SYMBOL_EX)];
    } File;
    struct {
        DWORD   Length;                         // section length
        WORD    NumberOfRelocations;            // number of relocation entries
        WORD    NumberOfLinenumbers;            // number of line numbers
        DWORD   CheckSum;                       // checksum for communal
        SHORT   Number;                         // section number to associate with
        BYTE    Selection;                      // communal selection type
        BYTE    bReserved;
        SHORT   HighNumber;                     // high bits of the section number
        BYTE    rgbReserved[2];
    } Section;
    struct{ 
        IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;   
        BYTE  rgbReserved[2];
    };
    struct {
        DWORD crc;
        BYTE  rgbReserved[16];
    } CRC;
} IMAGE_AUX_SYMBOL_EX;
typedef IMAGE_AUX_SYMBOL_EX UNALIGNED *PIMAGE_AUX_SYMBOL_EX;

typedef enum IMAGE_AUX_SYMBOL_TYPE {
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1,
} IMAGE_AUX_SYMBOL_TYPE;


//
// Communal selection types.
//

#define IMAGE_COMDAT_SELECT_NODUPLICATES    1
#define IMAGE_COMDAT_SELECT_ANY             2
#define IMAGE_COMDAT_SELECT_SAME_SIZE       3
#define IMAGE_COMDAT_SELECT_EXACT_MATCH     4
#define IMAGE_COMDAT_SELECT_ASSOCIATIVE     5
#define IMAGE_COMDAT_SELECT_LARGEST         6
#define IMAGE_COMDAT_SELECT_NEWEST          7

#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY  1
#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY    2
#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS      3

//
// Relocation format.
//

typedef struct _IMAGE_RELOCATION {
    union {
        DWORD   VirtualAddress;
        DWORD   RelocCount;             // Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set
    } DUMMYUNIONNAME;
    DWORD   SymbolTableIndex;
    WORD    Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION UNALIGNED *PIMAGE_RELOCATION;

//
// I386 relocation types.
//
#define IMAGE_REL_I386_ABSOLUTE         0x0000  // Reference is absolute, no relocation is necessary
#define IMAGE_REL_I386_DIR16            0x0001  // Direct 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_REL16            0x0002  // PC-relative 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32            0x0006  // Direct 32-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32NB          0x0007  // Direct 32-bit reference to the symbols virtual address, base not included
#define IMAGE_REL_I386_SEG12            0x0009  // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
#define IMAGE_REL_I386_SECTION          0x000A
#define IMAGE_REL_I386_SECREL           0x000B
#define IMAGE_REL_I386_TOKEN            0x000C  // clr token
#define IMAGE_REL_I386_SECREL7          0x000D  // 7 bit offset from base of section containing target
#define IMAGE_REL_I386_REL32            0x0014  // PC-relative 32-bit reference to the symbols virtual address

//
// MIPS relocation types.
//
#define IMAGE_REL_MIPS_ABSOLUTE         0x0000  // Reference is absolute, no relocation is necessary
#define IMAGE_REL_MIPS_REFHALF          0x0001
#define IMAGE_REL_MIPS_REFWORD          0x0002
#define IMAGE_REL_MIPS_JMPADDR          0x0003
#define IMAGE_REL_MIPS_REFHI            0x0004
#define IMAGE_REL_MIPS_REFLO            0x0005
#define IMAGE_REL_MIPS_GPREL            0x0006
#define IMAGE_REL_MIPS_LITERAL          0x0007
#define IMAGE_REL_MIPS_SECTION          0x000A
#define IMAGE_REL_MIPS_SECREL           0x000B
#define IMAGE_REL_MIPS_SECRELLO         0x000C  // Low 16-bit section relative referemce (used for >32k TLS)
#define IMAGE_REL_MIPS_SECRELHI         0x000D  // High 16-bit section relative reference (used for >32k TLS)
#define IMAGE_REL_MIPS_TOKEN            0x000E  // clr token
#define IMAGE_REL_MIPS_JMPADDR16        0x0010
#define IMAGE_REL_MIPS_REFWORDNB        0x0022
#define IMAGE_REL_MIPS_PAIR             0x0025

//
// Alpha Relocation types.
//
#define IMAGE_REL_ALPHA_ABSOLUTE        0x0000
#define IMAGE_REL_ALPHA_REFLONG         0x0001
#define IMAGE_REL_ALPHA_REFQUAD         0x0002
#define IMAGE_REL_ALPHA_GPREL32         0x0003
#define IMAGE_REL_ALPHA_LITERAL         0x0004
#define IMAGE_REL_ALPHA_LITUSE          0x0005
#define IMAGE_REL_ALPHA_GPDISP          0x0006
#define IMAGE_REL_ALPHA_BRADDR          0x0007
#define IMAGE_REL_ALPHA_HINT            0x0008
#define IMAGE_REL_ALPHA_INLINE_REFLONG  0x0009
#define IMAGE_REL_ALPHA_REFHI           0x000A
#define IMAGE_REL_ALPHA_REFLO           0x000B
#define IMAGE_REL_ALPHA_PAIR            0x000C
#define IMAGE_REL_ALPHA_MATCH           0x000D
#define IMAGE_REL_ALPHA_SECTION         0x000E
#define IMAGE_REL_ALPHA_SECREL          0x000F
#define IMAGE_REL_ALPHA_REFLONGNB       0x0010
#define IMAGE_REL_ALPHA_SECRELLO        0x0011  // Low 16-bit section relative reference
#define IMAGE_REL_ALPHA_SECRELHI        0x0012  // High 16-bit section relative reference
#define IMAGE_REL_ALPHA_REFQ3           0x0013  // High 16 bits of 48 bit reference
#define IMAGE_REL_ALPHA_REFQ2           0x0014  // Middle 16 bits of 48 bit reference
#define IMAGE_REL_ALPHA_REFQ1           0x0015  // Low 16 bits of 48 bit reference
#define IMAGE_REL_ALPHA_GPRELLO         0x0016  // Low 16-bit GP relative reference
#define IMAGE_REL_ALPHA_GPRELHI         0x0017  // High 16-bit GP relative reference

//
// IBM PowerPC relocation types.
//
#define IMAGE_REL_PPC_ABSOLUTE          0x0000  // NOP
#define IMAGE_REL_PPC_ADDR64            0x0001  // 64-bit address
#define IMAGE_REL_PPC_ADDR32            0x0002  // 32-bit address
#define IMAGE_REL_PPC_ADDR24            0x0003  // 26-bit address, shifted left 2 (branch absolute)
#define IMAGE_REL_PPC_ADDR16            0x0004  // 16-bit address
#define IMAGE_REL_PPC_ADDR14            0x0005  // 16-bit address, shifted left 2 (load doubleword)
#define IMAGE_REL_PPC_REL24             0x0006  // 26-bit PC-relative offset, shifted left 2 (branch relative)
#define IMAGE_REL_PPC_REL14             0x0007  // 16-bit PC-relative offset, shifted left 2 (br cond relative)
#define IMAGE_REL_PPC_TOCREL16          0x0008  // 16-bit offset from TOC base
#define IMAGE_REL_PPC_TOCREL14          0x0009  // 16-bit offset from TOC base, shifted left 2 (load doubleword)

#define IMAGE_REL_PPC_ADDR32NB          0x000A  // 32-bit addr w/o image base
#define IMAGE_REL_PPC_SECREL            0x000B  // va of containing section (as in an image sectionhdr)
#define IMAGE_REL_PPC_SECTION           0x000C  // sectionheader number
#define IMAGE_REL_PPC_IFGLUE            0x000D  // substitute TOC restore instruction iff symbol is glue code
#define IMAGE_REL_PPC_IMGLUE            0x000E  // symbol is glue code; virtual address is TOC restore instruction
#define IMAGE_REL_PPC_SECREL16          0x000F  // va of containing section (limited to 16 bits)
#define IMAGE_REL_PPC_REFHI             0x0010
#define IMAGE_REL_PPC_REFLO             0x0011
#define IMAGE_REL_PPC_PAIR              0x0012
#define IMAGE_REL_PPC_SECRELLO          0x0013  // Low 16-bit section relative reference (used for >32k TLS)
#define IMAGE_REL_PPC_SECRELHI          0x0014  // High 16-bit section relative reference (used for >32k TLS)
#define IMAGE_REL_PPC_GPREL             0x0015
#define IMAGE_REL_PPC_TOKEN             0x0016  // clr token

#define IMAGE_REL_PPC_TYPEMASK          0x00FF  // mask to isolate above values in IMAGE_RELOCATION.Type

// Flag bits in IMAGE_RELOCATION.TYPE

#define IMAGE_REL_PPC_NEG               0x0100  // subtract reloc value rather than adding it
#define IMAGE_REL_PPC_BRTAKEN           0x0200  // fix branch prediction bit to predict branch taken
#define IMAGE_REL_PPC_BRNTAKEN          0x0400  // fix branch prediction bit to predict branch not taken
#define IMAGE_REL_PPC_TOCDEFN           0x0800  // toc slot defined in file (or, data in toc)

//
// Hitachi SH3 relocation types.
//
#define IMAGE_REL_SH3_ABSOLUTE          0x0000  // No relocation
#define IMAGE_REL_SH3_DIRECT16          0x0001  // 16 bit direct
#define IMAGE_REL_SH3_DIRECT32          0x0002  // 32 bit direct
#define IMAGE_REL_SH3_DIRECT8           0x0003  // 8 bit direct, -128..255
#define IMAGE_REL_SH3_DIRECT8_WORD      0x0004  // 8 bit direct .W (0 ext.)
#define IMAGE_REL_SH3_DIRECT8_LONG      0x0005  // 8 bit direct .L (0 ext.)
#define IMAGE_REL_SH3_DIRECT4           0x0006  // 4 bit direct (0 ext.)
#define IMAGE_REL_SH3_DIRECT4_WORD      0x0007  // 4 bit direct .W (0 ext.)
#define IMAGE_REL_SH3_DIRECT4_LONG      0x0008  // 4 bit direct .L (0 ext.)
#define IMAGE_REL_SH3_PCREL8_WORD       0x0009  // 8 bit PC relative .W
#define IMAGE_REL_SH3_PCREL8_LONG       0x000A  // 8 bit PC relative .L
#define IMAGE_REL_SH3_PCREL12_WORD      0x000B  // 12 LSB PC relative .W
#define IMAGE_REL_SH3_STARTOF_SECTION   0x000C  // Start of EXE section
#define IMAGE_REL_SH3_SIZEOF_SECTION    0x000D  // Size of EXE section
#define IMAGE_REL_SH3_SECTION           0x000E  // Section table index
#define IMAGE_REL_SH3_SECREL            0x000F  // Offset within section
#define IMAGE_REL_SH3_DIRECT32_NB       0x0010  // 32 bit direct not based
#define IMAGE_REL_SH3_GPREL4_LONG       0x0011  // GP-relative addressing
#define IMAGE_REL_SH3_TOKEN             0x0012  // clr token
#define IMAGE_REL_SHM_PCRELPT           0x0013  // Offset from current
                                                //  instruction in longwords
                                                //  if not NOMODE, insert the
                                                //  inverse of the low bit at
                                                //  bit 32 to select PTA/PTB
#define IMAGE_REL_SHM_REFLO             0x0014  // Low bits of 32-bit address
#define IMAGE_REL_SHM_REFHALF           0x0015  // High bits of 32-bit address
#define IMAGE_REL_SHM_RELLO             0x0016  // Low bits of relative reference
#define IMAGE_REL_SHM_RELHALF           0x0017  // High bits of relative reference
#define IMAGE_REL_SHM_PAIR              0x0018  // offset operand for relocation

#define IMAGE_REL_SH_NOMODE             0x8000  // relocation ignores section mode


#define IMAGE_REL_ARM_ABSOLUTE          0x0000  // No relocation required
#define IMAGE_REL_ARM_ADDR32            0x0001  // 32 bit address
#define IMAGE_REL_ARM_ADDR32NB          0x0002  // 32 bit address w/o image base
#define IMAGE_REL_ARM_BRANCH24          0x0003  // 24 bit offset << 2 & sign ext.
#define IMAGE_REL_ARM_BRANCH11          0x0004  // Thumb: 2 11 bit offsets
#define IMAGE_REL_ARM_TOKEN             0x0005  // clr token
#define IMAGE_REL_ARM_GPREL12           0x0006  // GP-relative addressing (ARM)
#define IMAGE_REL_ARM_GPREL7            0x0007  // GP-relative addressing (Thumb)
#define IMAGE_REL_ARM_BLX24             0x0008
#define IMAGE_REL_ARM_BLX11             0x0009
#define IMAGE_REL_ARM_SECTION           0x000E  // Section table index
#define IMAGE_REL_ARM_SECREL            0x000F  // Offset within section

#define IMAGE_REL_AM_ABSOLUTE           0x0000
#define IMAGE_REL_AM_ADDR32             0x0001
#define IMAGE_REL_AM_ADDR32NB           0x0002
#define IMAGE_REL_AM_CALL32             0x0003
#define IMAGE_REL_AM_FUNCINFO           0x0004
#define IMAGE_REL_AM_REL32_1            0x0005
#define IMAGE_REL_AM_REL32_2            0x0006
#define IMAGE_REL_AM_SECREL             0x0007
#define IMAGE_REL_AM_SECTION            0x0008
#define IMAGE_REL_AM_TOKEN              0x0009

//
// x64 relocations
//
#define IMAGE_REL_AMD64_ABSOLUTE        0x0000  // Reference is absolute, no relocation is necessary
#define IMAGE_REL_AMD64_ADDR64          0x0001  // 64-bit address (VA).
#define IMAGE_REL_AMD64_ADDR32          0x0002  // 32-bit address (VA).
#define IMAGE_REL_AMD64_ADDR32NB        0x0003  // 32-bit address w/o image base (RVA).
#define IMAGE_REL_AMD64_REL32           0x0004  // 32-bit relative address from byte following reloc
#define IMAGE_REL_AMD64_REL32_1         0x0005  // 32-bit relative address from byte distance 1 from reloc
#define IMAGE_REL_AMD64_REL32_2         0x0006  // 32-bit relative address from byte distance 2 from reloc
#define IMAGE_REL_AMD64_REL32_3         0x0007  // 32-bit relative address from byte distance 3 from reloc
#define IMAGE_REL_AMD64_REL32_4         0x0008  // 32-bit relative address from byte distance 4 from reloc
#define IMAGE_REL_AMD64_REL32_5         0x0009  // 32-bit relative address from byte distance 5 from reloc
#define IMAGE_REL_AMD64_SECTION         0x000A  // Section index
#define IMAGE_REL_AMD64_SECREL          0x000B  // 32 bit offset from base of section containing target
#define IMAGE_REL_AMD64_SECREL7         0x000C  // 7 bit unsigned offset from base of section containing target
#define IMAGE_REL_AMD64_TOKEN           0x000D  // 32 bit metadata token
#define IMAGE_REL_AMD64_SREL32          0x000E  // 32 bit signed span-dependent value emitted into object
#define IMAGE_REL_AMD64_PAIR            0x000F
#define IMAGE_REL_AMD64_SSPAN32         0x0010  // 32 bit signed span-dependent value applied at link time

//
// IA64 relocation types.
//
#define IMAGE_REL_IA64_ABSOLUTE         0x0000
#define IMAGE_REL_IA64_IMM14            0x0001
#define IMAGE_REL_IA64_IMM22            0x0002
#define IMAGE_REL_IA64_IMM64            0x0003
#define IMAGE_REL_IA64_DIR32            0x0004
#define IMAGE_REL_IA64_DIR64            0x0005
#define IMAGE_REL_IA64_PCREL21B         0x0006
#define IMAGE_REL_IA64_PCREL21M         0x0007
#define IMAGE_REL_IA64_PCREL21F         0x0008
#define IMAGE_REL_IA64_GPREL22          0x0009
#define IMAGE_REL_IA64_LTOFF22          0x000A
#define IMAGE_REL_IA64_SECTION          0x000B
#define IMAGE_REL_IA64_SECREL22         0x000C
#define IMAGE_REL_IA64_SECREL64I        0x000D
#define IMAGE_REL_IA64_SECREL32         0x000E
//
#define IMAGE_REL_IA64_DIR32NB          0x0010
#define IMAGE_REL_IA64_SREL14           0x0011
#define IMAGE_REL_IA64_SREL22           0x0012
#define IMAGE_REL_IA64_SREL32           0x0013
#define IMAGE_REL_IA64_UREL32           0x0014
#define IMAGE_REL_IA64_PCREL60X         0x0015  // This is always a BRL and never converted
#define IMAGE_REL_IA64_PCREL60B         0x0016  // If possible, convert to MBB bundle with NOP.B in slot 1
#define IMAGE_REL_IA64_PCREL60F         0x0017  // If possible, convert to MFB bundle with NOP.F in slot 1
#define IMAGE_REL_IA64_PCREL60I         0x0018  // If possible, convert to MIB bundle with NOP.I in slot 1
#define IMAGE_REL_IA64_PCREL60M         0x0019  // If possible, convert to MMB bundle with NOP.M in slot 1
#define IMAGE_REL_IA64_IMMGPREL64       0x001A
#define IMAGE_REL_IA64_TOKEN            0x001B  // clr token
#define IMAGE_REL_IA64_GPREL32          0x001C
#define IMAGE_REL_IA64_ADDEND           0x001F

//
// CEF relocation types.
//
#define IMAGE_REL_CEF_ABSOLUTE          0x0000  // Reference is absolute, no relocation is necessary
#define IMAGE_REL_CEF_ADDR32            0x0001  // 32-bit address (VA).
#define IMAGE_REL_CEF_ADDR64            0x0002  // 64-bit address (VA).
#define IMAGE_REL_CEF_ADDR32NB          0x0003  // 32-bit address w/o image base (RVA).
#define IMAGE_REL_CEF_SECTION           0x0004  // Section index
#define IMAGE_REL_CEF_SECREL            0x0005  // 32 bit offset from base of section containing target
#define IMAGE_REL_CEF_TOKEN             0x0006  // 32 bit metadata token

//
// clr relocation types.
//
#define IMAGE_REL_CEE_ABSOLUTE          0x0000  // Reference is absolute, no relocation is necessary
#define IMAGE_REL_CEE_ADDR32            0x0001  // 32-bit address (VA).
#define IMAGE_REL_CEE_ADDR64            0x0002  // 64-bit address (VA).
#define IMAGE_REL_CEE_ADDR32NB          0x0003  // 32-bit address w/o image base (RVA).
#define IMAGE_REL_CEE_SECTION           0x0004  // Section index
#define IMAGE_REL_CEE_SECREL            0x0005  // 32 bit offset from base of section containing target
#define IMAGE_REL_CEE_TOKEN             0x0006  // 32 bit metadata token


#define IMAGE_REL_M32R_ABSOLUTE         0x0000  // No relocation required
#define IMAGE_REL_M32R_ADDR32           0x0001  // 32 bit address
#define IMAGE_REL_M32R_ADDR32NB         0x0002  // 32 bit address w/o image base
#define IMAGE_REL_M32R_ADDR24           0x0003  // 24 bit address
#define IMAGE_REL_M32R_GPREL16          0x0004  // GP relative addressing
#define IMAGE_REL_M32R_PCREL24          0x0005  // 24 bit offset << 2 & sign ext.
#define IMAGE_REL_M32R_PCREL16          0x0006  // 16 bit offset << 2 & sign ext.
#define IMAGE_REL_M32R_PCREL8           0x0007  // 8 bit offset << 2 & sign ext.
#define IMAGE_REL_M32R_REFHALF          0x0008  // 16 MSBs
#define IMAGE_REL_M32R_REFHI            0x0009  // 16 MSBs; adj for LSB sign ext.
#define IMAGE_REL_M32R_REFLO            0x000A  // 16 LSBs
#define IMAGE_REL_M32R_PAIR             0x000B  // Link HI and LO
#define IMAGE_REL_M32R_SECTION          0x000C  // Section table index
#define IMAGE_REL_M32R_SECREL32         0x000D  // 32 bit section relative reference
#define IMAGE_REL_M32R_TOKEN            0x000E  // clr token

#define IMAGE_REL_EBC_ABSOLUTE          0x0000  // No relocation required
#define IMAGE_REL_EBC_ADDR32NB          0x0001  // 32 bit address w/o image base
#define IMAGE_REL_EBC_REL32             0x0002  // 32-bit relative address from byte following reloc
#define IMAGE_REL_EBC_SECTION           0x0003  // Section table index
#define IMAGE_REL_EBC_SECREL            0x0004  // Offset within section

#define EXT_IMM64(Value, Address, Size, InstPos, ValPos)  /* Intel-IA64-Filler */           \
    Value |= (((ULONGLONG)((*(Address) >> InstPos) & (((ULONGLONG)1 << Size) - 1))) << ValPos)  // Intel-IA64-Filler

#define INS_IMM64(Value, Address, Size, InstPos, ValPos)  /* Intel-IA64-Filler */\
    *(PDWORD)Address = (*(PDWORD)Address & ~(((1 << Size) - 1) << InstPos)) | /* Intel-IA64-Filler */\
          ((DWORD)((((ULONGLONG)Value >> ValPos) & (((ULONGLONG)1 << Size) - 1))) << InstPos)  // Intel-IA64-Filler

#define EMARCH_ENC_I17_IMM7B_INST_WORD_X         3  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM7B_SIZE_X              7  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X     4  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM7B_VAL_POS_X           0  // Intel-IA64-Filler

#define EMARCH_ENC_I17_IMM9D_INST_WORD_X         3  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM9D_SIZE_X              9  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X     18 // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM9D_VAL_POS_X           7  // Intel-IA64-Filler

#define EMARCH_ENC_I17_IMM5C_INST_WORD_X         3  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM5C_SIZE_X              5  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X     13 // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM5C_VAL_POS_X           16 // Intel-IA64-Filler

#define EMARCH_ENC_I17_IC_INST_WORD_X            3  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IC_SIZE_X                 1  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IC_INST_WORD_POS_X        12 // Intel-IA64-Filler
#define EMARCH_ENC_I17_IC_VAL_POS_X              21 // Intel-IA64-Filler

#define EMARCH_ENC_I17_IMM41a_INST_WORD_X        1  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41a_SIZE_X             10 // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X    14 // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41a_VAL_POS_X          22 // Intel-IA64-Filler

#define EMARCH_ENC_I17_IMM41b_INST_WORD_X        1  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41b_SIZE_X             8  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X    24 // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41b_VAL_POS_X          32 // Intel-IA64-Filler

#define EMARCH_ENC_I17_IMM41c_INST_WORD_X        2  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41c_SIZE_X             23 // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X    0  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41c_VAL_POS_X          40 // Intel-IA64-Filler

#define EMARCH_ENC_I17_SIGN_INST_WORD_X          3  // Intel-IA64-Filler
#define EMARCH_ENC_I17_SIGN_SIZE_X               1  // Intel-IA64-Filler
#define EMARCH_ENC_I17_SIGN_INST_WORD_POS_X      27 // Intel-IA64-Filler
#define EMARCH_ENC_I17_SIGN_VAL_POS_X            63 // Intel-IA64-Filler

#define X3_OPCODE_INST_WORD_X                    3  // Intel-IA64-Filler
#define X3_OPCODE_SIZE_X                         4  // Intel-IA64-Filler
#define X3_OPCODE_INST_WORD_POS_X                28 // Intel-IA64-Filler
#define X3_OPCODE_SIGN_VAL_POS_X                 0  // Intel-IA64-Filler

#define X3_I_INST_WORD_X                         3  // Intel-IA64-Filler
#define X3_I_SIZE_X                              1  // Intel-IA64-Filler
#define X3_I_INST_WORD_POS_X                     27 // Intel-IA64-Filler
#define X3_I_SIGN_VAL_POS_X                      59 // Intel-IA64-Filler

#define X3_D_WH_INST_WORD_X                      3  // Intel-IA64-Filler
#define X3_D_WH_SIZE_X                           3  // Intel-IA64-Filler
#define X3_D_WH_INST_WORD_POS_X                  24 // Intel-IA64-Filler
#define X3_D_WH_SIGN_VAL_POS_X                   0  // Intel-IA64-Filler

#define X3_IMM20_INST_WORD_X                     3  // Intel-IA64-Filler
#define X3_IMM20_SIZE_X                          20 // Intel-IA64-Filler
#define X3_IMM20_INST_WORD_POS_X                 4  // Intel-IA64-Filler
#define X3_IMM20_SIGN_VAL_POS_X                  0  // Intel-IA64-Filler

#define X3_IMM39_1_INST_WORD_X                   2  // Intel-IA64-Filler
#define X3_IMM39_1_SIZE_X                        23 // Intel-IA64-Filler
#define X3_IMM39_1_INST_WORD_POS_X               0  // Intel-IA64-Filler
#define X3_IMM39_1_SIGN_VAL_POS_X                36 // Intel-IA64-Filler

#define X3_IMM39_2_INST_WORD_X                   1  // Intel-IA64-Filler
#define X3_IMM39_2_SIZE_X                        16 // Intel-IA64-Filler
#define X3_IMM39_2_INST_WORD_POS_X               16 // Intel-IA64-Filler
#define X3_IMM39_2_SIGN_VAL_POS_X                20 // Intel-IA64-Filler

#define X3_P_INST_WORD_X                         3  // Intel-IA64-Filler
#define X3_P_SIZE_X                              4  // Intel-IA64-Filler
#define X3_P_INST_WORD_POS_X                     0  // Intel-IA64-Filler
#define X3_P_SIGN_VAL_POS_X                      0  // Intel-IA64-Filler

#define X3_TMPLT_INST_WORD_X                     0  // Intel-IA64-Filler
#define X3_TMPLT_SIZE_X                          4  // Intel-IA64-Filler
#define X3_TMPLT_INST_WORD_POS_X                 0  // Intel-IA64-Filler
#define X3_TMPLT_SIGN_VAL_POS_X                  0  // Intel-IA64-Filler

#define X3_BTYPE_QP_INST_WORD_X                  2  // Intel-IA64-Filler
#define X3_BTYPE_QP_SIZE_X                       9  // Intel-IA64-Filler
#define X3_BTYPE_QP_INST_WORD_POS_X              23 // Intel-IA64-Filler
#define X3_BTYPE_QP_INST_VAL_POS_X               0  // Intel-IA64-Filler

#define X3_EMPTY_INST_WORD_X                     1  // Intel-IA64-Filler
#define X3_EMPTY_SIZE_X                          2  // Intel-IA64-Filler
#define X3_EMPTY_INST_WORD_POS_X                 14 // Intel-IA64-Filler
#define X3_EMPTY_INST_VAL_POS_X                  0  // Intel-IA64-Filler

//
// Line number format.
//

typedef struct _IMAGE_LINENUMBER {
    union {
        DWORD   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0.
        DWORD   VirtualAddress;                 // Virtual address of line number.
    } Type;
    WORD    Linenumber;                         // Line number.
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER UNALIGNED *PIMAGE_LINENUMBER;

#ifndef _MAC
#include "poppack.h"                        // Back to 4 byte packing
#endif

//
// Based relocation format.
//

typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;

//
// Based relocation types.
//

#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MIPS_JMPADDR          5
#define IMAGE_REL_BASED_MIPS_JMPADDR16        9
#define IMAGE_REL_BASED_IA64_IMM64            9
#define IMAGE_REL_BASED_DIR64                 10


//
// Archive format.
//

#define IMAGE_ARCHIVE_START_SIZE             8
#define IMAGE_ARCHIVE_START                  "!<arch>\n"
#define IMAGE_ARCHIVE_END                    "`\n"
#define IMAGE_ARCHIVE_PAD                    "\n"
#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "

typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE     Name[16];                          // File member name - `/' terminated.
    BYTE     Date[12];                          // File member date - decimal.
    BYTE     UserID[6];                         // File member user id - decimal.
    BYTE     GroupID[6];                        // File member group id - decimal.
    BYTE     Mode[8];                           // File member mode - octal.
    BYTE     Size[10];                          // File member size - decimal.
    BYTE     EndHeader[2];                      // String to end header.
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;

#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60

//
// DLL support.
//

//
// Export Format
//

typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     // RVA from base of image
    DWORD   AddressOfNames;         // RVA from base of image
    DWORD   AddressOfNameOrdinals;  // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

//
// Import Format
//

typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    BYTE    Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

#include "pshpack8.h"                       // Use align 8 for the 64-bit IAT.

typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString;  // PBYTE 
        ULONGLONG Function;         // PDWORD
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;    // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;

#include "poppack.h"                        // Back to 4 byte packing

typedef struct _IMAGE_THUNK_DATA32 {
    union {
        DWORD ForwarderString;      // PBYTE 
        DWORD Function;             // PDWORD
        DWORD Ordinal;
        DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;

#define IMAGE_ORDINAL_FLAG64 0x8000000000000000
#define IMAGE_ORDINAL_FLAG32 0x80000000
#define IMAGE_ORDINAL64(Ordinal) (Ordinal & 0xffff)
#define IMAGE_ORDINAL32(Ordinal) (Ordinal & 0xffff)
#define IMAGE_SNAP_BY_ORDINAL64(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG64) != 0)
#define IMAGE_SNAP_BY_ORDINAL32(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG32) != 0)

//
// Thread Local Storage
//

typedef VOID
(NTAPI *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
    );

typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG   StartAddressOfRawData;
    ULONGLONG   EndAddressOfRawData;
    ULONGLONG   AddressOfIndex;         // PDWORD
    ULONGLONG   AddressOfCallBacks;     // PIMAGE_TLS_CALLBACK *;
    DWORD   SizeOfZeroFill;
    DWORD   Characteristics;
} IMAGE_TLS_DIRECTORY64;
typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;

typedef struct _IMAGE_TLS_DIRECTORY32 {
    DWORD   StartAddressOfRawData;
    DWORD   EndAddressOfRawData;
    DWORD   AddressOfIndex;             // PDWORD
    DWORD   AddressOfCallBacks;         // PIMAGE_TLS_CALLBACK *
    DWORD   SizeOfZeroFill;
    DWORD   Characteristics;
} IMAGE_TLS_DIRECTORY32;
typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;

#ifdef _WIN64
#define IMAGE_ORDINAL_FLAG              IMAGE_ORDINAL_FLAG64
#define IMAGE_ORDINAL(Ordinal)          IMAGE_ORDINAL64(Ordinal)
typedef IMAGE_THUNK_DATA64              IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA64             PIMAGE_THUNK_DATA;
#define IMAGE_SNAP_BY_ORDINAL(Ordinal)  IMAGE_SNAP_BY_ORDINAL64(Ordinal)
typedef IMAGE_TLS_DIRECTORY64           IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY64          PIMAGE_TLS_DIRECTORY;
#else
#define IMAGE_ORDINAL_FLAG              IMAGE_ORDINAL_FLAG32
#define IMAGE_ORDINAL(Ordinal)          IMAGE_ORDINAL32(Ordinal)
typedef IMAGE_THUNK_DATA32              IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA32             PIMAGE_THUNK_DATA;
#define IMAGE_SNAP_BY_ORDINAL(Ordinal)  IMAGE_SNAP_BY_ORDINAL32(Ordinal)
typedef IMAGE_TLS_DIRECTORY32           IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY32          PIMAGE_TLS_DIRECTORY;
#endif

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            // 0 for terminating null import descriptor
        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    } DUMMYUNIONNAME;
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;

//
// New format import descriptors pointed to by DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ]
//

typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    NumberOfModuleForwarderRefs;
// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows
} IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_BOUND_FORWARDER_REF {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    Reserved;
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;

//
// Resource Format.
//

//
// Resource directory consists of two counts, following by a variable length
// array of directory entries.  The first count is the number of entries at
// beginning of the array that have actual names associated with each entry.
// The entries are in ascending order, case insensitive strings.  The second
// count is the number of entries that immediately follow the named entries.
// This second count identifies the number of entries that have 16-bit integer
// Ids as their name.  These entries are also sorted in ascending order.
//
// This structure allows fast lookup by either name or number, but for any
// given resource entry only one form of lookup is supported, not both.
// This is consistant with the syntax of the .RC file and the .RES file.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;
    WORD    NumberOfIdEntries;
//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

#define IMAGE_RESOURCE_NAME_IS_STRING        0x80000000
#define IMAGE_RESOURCE_DATA_IS_DIRECTORY     0x80000000
//
// Each directory contains the 32-bit Name of the entry and an offset,
// relative to the beginning of the resource directory of the data associated
// with this directory entry.  If the name of the entry is an actual text
// string instead of an integer Id, then the high order bit of the name field
// is set to one and the low order 31-bits are an offset, relative to the
// beginning of the resource directory of the string, which is of type
// IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
// low-order 16-bits are the integer Id that identify this resource directory
// entry. If the directory entry is yet another resource directory (i.e. a
// subdirectory), then the high order bit of the offset field will be
// set to indicate this.  Otherwise the high bit is clear and the offset
// field points to a resource data entry.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        } DUMMYSTRUCTNAME;
        DWORD   Name;
        WORD    Id;
    } DUMMYUNIONNAME;
    union {
        DWORD   OffsetToData;
        struct {
            DWORD   OffsetToDirectory:31;
            DWORD   DataIsDirectory:1;
        } DUMMYSTRUCTNAME2;
    } DUMMYUNIONNAME2;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

//
// For resource directory entries that have actual string names, the Name
// field of the directory entry points to an object of the following type.
// All of these string objects are stored together after the last resource
// directory entry and before the first resource data object.  This minimizes
// the impact of these variable length objects on the alignment of the fixed
// size directory entry objects.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD    Length;
    CHAR    NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;


typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    WORD    Length;
    WCHAR   NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;


//
// Each resource data entry describes a leaf node in the resource directory
// tree.  It contains an offset, relative to the beginning of the resource
// directory of the data for the resource, a size field that gives the number
// of bytes of data at that offset, a CodePage that should be used when
// decoding code point values within the resource data.  Typically for new
// applications the code page would be the unicode code page.
//

typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD   OffsetToData;
    DWORD   Size;
    DWORD   CodePage;
    DWORD   Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

//
// Load Configuration Directory Entry
//

typedef struct {
    DWORD   Size;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   GlobalFlagsClear;
    DWORD   GlobalFlagsSet;
    DWORD   CriticalSectionDefaultTimeout;
    DWORD   DeCommitFreeBlockThreshold;
    DWORD   DeCommitTotalFreeThreshold;
    DWORD   LockPrefixTable;            // VA
    DWORD   MaximumAllocationSize;
    DWORD   VirtualMemoryThreshold;
    DWORD   ProcessHeapFlags;
    DWORD   ProcessAffinityMask;
    WORD    CSDVersion;
    WORD    Reserved1;
    DWORD   EditList;                   // VA
    DWORD   SecurityCookie;             // VA
    DWORD   SEHandlerTable;             // VA
    DWORD   SEHandlerCount;
} IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

typedef struct {
    DWORD      Size;
    DWORD      TimeDateStamp;
    WORD       MajorVersion;
    WORD       MinorVersion;
    DWORD      GlobalFlagsClear;
    DWORD      GlobalFlagsSet;
    DWORD      CriticalSectionDefaultTimeout;
    ULONGLONG  DeCommitFreeBlockThreshold;
    ULONGLONG  DeCommitTotalFreeThreshold;
    ULONGLONG  LockPrefixTable;         // VA
    ULONGLONG  MaximumAllocationSize;
    ULONGLONG  VirtualMemoryThreshold;
    ULONGLONG  ProcessAffinityMask;
    DWORD      ProcessHeapFlags;
    WORD       CSDVersion;
    WORD       Reserved1;
    ULONGLONG  EditList;                // VA
    ULONGLONG  SecurityCookie;          // VA
    ULONGLONG  SEHandlerTable;          // VA
    ULONGLONG  SEHandlerCount;
} IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;

#ifdef _WIN64
typedef IMAGE_LOAD_CONFIG_DIRECTORY64     IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY64    PIMAGE_LOAD_CONFIG_DIRECTORY;
#else
typedef IMAGE_LOAD_CONFIG_DIRECTORY32     IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY32    PIMAGE_LOAD_CONFIG_DIRECTORY;
#endif

//
// WIN CE Exception table format
//

//
// Function table entry format.  Function table is pointed to by the
// IMAGE_DIRECTORY_ENTRY_EXCEPTION directory entry.
//

typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    DWORD FuncStart;
    DWORD PrologLen : 8;
    DWORD FuncLen : 22;
    DWORD ThirtyTwoBit : 1;
    DWORD ExceptionFlag : 1;
} IMAGE_CE_RUNTIME_FUNCTION_ENTRY, * PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    ULONGLONG BeginAddress;
    ULONGLONG EndAddress;
    ULONGLONG ExceptionHandler;
    ULONGLONG HandlerData;
    ULONGLONG PrologEndAddress;
} IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD ExceptionHandler;
    DWORD HandlerData;
    DWORD PrologEndAddress;
} IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD UnwindInfoAddress;
} _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;

typedef  _IMAGE_RUNTIME_FUNCTION_ENTRY  IMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY;

#if defined(_AXP64_)

typedef  IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY  IMAGE_AXP64_RUNTIME_FUNCTION_ENTRY;
typedef PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY PIMAGE_AXP64_RUNTIME_FUNCTION_ENTRY;
typedef  IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY  IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;

#elif defined(_ALPHA_)

typedef  IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY  IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;

#else

typedef  _IMAGE_RUNTIME_FUNCTION_ENTRY  IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;

#endif

//
// Debug Format
//

typedef struct _IMAGE_DEBUG_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Type;
    DWORD   SizeOfData;
    DWORD   AddressOfRawData;
    DWORD   PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;

#define IMAGE_DEBUG_TYPE_UNKNOWN          0
#define IMAGE_DEBUG_TYPE_COFF             1
#define IMAGE_DEBUG_TYPE_CODEVIEW         2
#define IMAGE_DEBUG_TYPE_FPO              3
#define IMAGE_DEBUG_TYPE_MISC             4
#define IMAGE_DEBUG_TYPE_EXCEPTION        5
#define IMAGE_DEBUG_TYPE_FIXUP            6
#define IMAGE_DEBUG_TYPE_OMAP_TO_SRC      7
#define IMAGE_DEBUG_TYPE_OMAP_FROM_SRC    8
#define IMAGE_DEBUG_TYPE_BORLAND          9
#define IMAGE_DEBUG_TYPE_RESERVED10       10
#define IMAGE_DEBUG_TYPE_CLSID            11


typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    DWORD   NumberOfSymbols;
    DWORD   LvaToFirstSymbol;
    DWORD   NumberOfLinenumbers;
    DWORD   LvaToFirstLinenumber;
    DWORD   RvaToFirstByteOfCode;
    DWORD   RvaToLastByteOfCode;
    DWORD   RvaToFirstByteOfData;
    DWORD   RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;

#define FRAME_FPO       0
#define FRAME_TRAP      1
#define FRAME_TSS       2
#define FRAME_NONFPO    3

typedef struct _FPO_DATA {
    DWORD       ulOffStart;             // offset 1st byte of function code
    DWORD       cbProcSize;             // # bytes in function
    DWORD       cdwLocals;              // # bytes in locals/4
    WORD        cdwParams;              // # bytes in params/4
    WORD        cbProlog : 8;           // # bytes in prolog
    WORD        cbRegs   : 3;           // # regs saved
    WORD        fHasSEH  : 1;           // TRUE if SEH in func
    WORD        fUseBP   : 1;           // TRUE if EBP has been allocated
    WORD        reserved : 1;           // reserved for future use
    WORD        cbFrame  : 2;           // frame type
} FPO_DATA, *PFPO_DATA;
#define SIZEOF_RFPO_DATA 16


#define IMAGE_DEBUG_MISC_EXENAME    1

typedef struct _IMAGE_DEBUG_MISC {
    DWORD       DataType;               // type of misc data, see defines
    DWORD       Length;                 // total length of record, rounded to four
                                        // byte multiple.
    BOOLEAN     Unicode;                // TRUE if data is unicode string
    BYTE        Reserved[ 3 ];
    BYTE        Data[ 1 ];              // Actual data
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;


//
// Function table extracted from MIPS/ALPHA/IA64 images.  Does not contain
// information needed only for runtime support.  Just those fields for
// each entry needed by a debugger.
//

typedef struct _IMAGE_FUNCTION_ENTRY {
    DWORD   StartingAddress;
    DWORD   EndingAddress;
    DWORD   EndOfPrologue;
} IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY;

typedef struct _IMAGE_FUNCTION_ENTRY64 {
    ULONGLONG   StartingAddress;
    ULONGLONG   EndingAddress;
    union {
        ULONGLONG   EndOfPrologue;
        ULONGLONG   UnwindInfoAddress;
    } DUMMYUNIONNAME;
} IMAGE_FUNCTION_ENTRY64, *PIMAGE_FUNCTION_ENTRY64;

//
// Debugging information can be stripped from an image file and placed
// in a separate .DBG file, whose file name part is the same as the
// image file name part (e.g. symbols for CMD.EXE could be stripped
// and placed in CMD.DBG).  This is indicated by the IMAGE_FILE_DEBUG_STRIPPED
// flag in the Characteristics field of the file header.  The beginning of
// the .DBG file contains the following structure which captures certain
// information from the image file.  This allows a debug to proceed even if
// the original image file is not accessable.  This header is followed by
// zero of more IMAGE_SECTION_HEADER structures, followed by zero or more
// IMAGE_DEBUG_DIRECTORY structures.  The latter structures and those in
// the image file contain file offsets relative to the beginning of the
// .DBG file.
//
// If symbols have been stripped from an image, the IMAGE_DEBUG_MISC structure
// is left in the image file, but not mapped.  This allows a debugger to
// compute the name of the .DBG file, from the name of the image in the
// IMAGE_DEBUG_MISC structure.
//

typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    WORD        Signature;
    WORD        Flags;
    WORD        Machine;
    WORD        Characteristics;
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       ImageBase;
    DWORD       SizeOfImage;
    DWORD       NumberOfSections;
    DWORD       ExportedNamesSize;
    DWORD       DebugDirectorySize;
    DWORD       SectionAlignment;
    DWORD       Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;

typedef struct _NON_PAGED_DEBUG_INFO {
    WORD        Signature;
    WORD        Flags;
    DWORD       Size;
    WORD        Machine;
    WORD        Characteristics;
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       SizeOfImage;
    ULONGLONG   ImageBase;
    //DebugDirectorySize
    //IMAGE_DEBUG_DIRECTORY
} NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;

#ifndef _MAC
#define IMAGE_SEPARATE_DEBUG_SIGNATURE 0x4944
#define NON_PAGED_DEBUG_SIGNATURE      0x494E
#else
#define IMAGE_SEPARATE_DEBUG_SIGNATURE 0x4449  // DI
#define NON_PAGED_DEBUG_SIGNATURE      0x4E49  // NI
#endif

#define IMAGE_SEPARATE_DEBUG_FLAGS_MASK 0x8000
#define IMAGE_SEPARATE_DEBUG_MISMATCH   0x8000  // when DBG was updated, the
                                                // old checksum didn't match.

//
//  The .arch section is made up of headers, each describing an amask position/value
//  pointing to an array of IMAGE_ARCHITECTURE_ENTRY's.  Each "array" (both the header
//  and entry arrays) are terminiated by a quadword of 0xffffffffL.
//
//  NOTE: There may be quadwords of 0 sprinkled around and must be skipped.
//

typedef struct _ImageArchitectureHeader {
    unsigned int AmaskValue: 1;                 // 1 -> code section depends on mask bit
                                                // 0 -> new instruction depends on mask bit
    int :7;                                     // MBZ
    unsigned int AmaskShift: 8;                 // Amask bit in question for this fixup
    int :16;                                    // MBZ
    DWORD FirstEntryRVA;                        // RVA into .arch section to array of ARCHITECTURE_ENTRY's
} IMAGE_ARCHITECTURE_HEADER, *PIMAGE_ARCHITECTURE_HEADER;

typedef struct _ImageArchitectureEntry {
    DWORD FixupInstRVA;                         // RVA of instruction to fixup
    DWORD NewInst;                              // fixup instruction (see alphaops.h)
} IMAGE_ARCHITECTURE_ENTRY, *PIMAGE_ARCHITECTURE_ENTRY;

#include "poppack.h"                // Back to the initial value

// The following structure defines the new import object.  Note the values of the first two fields,
// which must be set as stated in order to differentiate old and new import members.
// Following this structure, the linker emits two null-terminated strings used to recreate the
// import at the time of use.  The first string is the import's name, the second is the dll's name.

#define IMPORT_OBJECT_HDR_SIG2  0xffff

typedef struct IMPORT_OBJECT_HEADER {
    WORD    Sig1;                       // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD    Sig2;                       // Must be IMPORT_OBJECT_HDR_SIG2.
    WORD    Version;
    WORD    Machine;
    DWORD   TimeDateStamp;              // Time/date stamp
    DWORD   SizeOfData;                 // particularly useful for incremental links

    union {
        WORD    Ordinal;                // if grf & IMPORT_OBJECT_ORDINAL
        WORD    Hint;
    } DUMMYUNIONNAME;

    WORD    Type : 2;                   // IMPORT_TYPE
    WORD    NameType : 3;               // IMPORT_NAME_TYPE
    WORD    Reserved : 11;              // Reserved. Must be zero.
} IMPORT_OBJECT_HEADER;

typedef enum IMPORT_OBJECT_TYPE
{
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
} IMPORT_OBJECT_TYPE;

typedef enum IMPORT_OBJECT_NAME_TYPE
{
    IMPORT_OBJECT_ORDINAL = 0,          // Import by ordinal
    IMPORT_OBJECT_NAME = 1,             // Import name == public symbol name.
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,   // Import name == public symbol name skipping leading ?, @, or optionally _.
    IMPORT_OBJECT_NAME_UNDECORATE = 3,  // Import name == public symbol name skipping leading ?, @, or optionally _
                                        // and truncating at first @
} IMPORT_OBJECT_NAME_TYPE;


#ifndef __IMAGE_COR20_HEADER_DEFINED__
#define __IMAGE_COR20_HEADER_DEFINED__

typedef enum ReplacesCorHdrNumericDefines
{
// COM+ Header entry point flags.
    COMIMAGE_FLAGS_ILONLY               =0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED        =0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY           =0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED     =0x00000008,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT    =0x00000010,
    COMIMAGE_FLAGS_TRACKDEBUGDATA       =0x00010000,

// Version flags for image.
    COR_VERSION_MAJOR_V2                =2,
    COR_VERSION_MAJOR                   =COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR                   =0,
    COR_DELETED_NAME_LENGTH             =8,
    COR_VTABLEGAP_NAME_LENGTH           =8,

// Maximum size of a NativeType descriptor.
    NATIVE_TYPE_MAX_CB                  =1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=0xFF,

// #defines for the MIH FLAGS
    IMAGE_COR_MIH_METHODRVA             =0x01,
    IMAGE_COR_MIH_EHRVA                 =0x02,
    IMAGE_COR_MIH_BASICBLOCK            =0x08,

// V-table constants
    COR_VTABLE_32BIT                    =0x01,          // V-table slots are 32-bits in size.
    COR_VTABLE_64BIT                    =0x02,          // V-table slots are 64-bits in size.
    COR_VTABLE_FROM_UNMANAGED           =0x04,          // If set, transition from unmanaged.
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN  =0x08,  // If set, transition from unmanaged with keeping the current appdomain.
    COR_VTABLE_CALL_MOST_DERIVED        =0x10,          // Call most derived method described by

// EATJ constants
    IMAGE_COR_EATJ_THUNK_SIZE           =32,            // Size of a jump thunk reserved range.

// Max name lengths
    //@todo: Change to unlimited name lengths.
    MAX_CLASS_NAME                      =1024,
    MAX_PACKAGE_NAME                    =1024,
} ReplacesCorHdrNumericDefines;

// CLR 2.0 header structure.
typedef struct IMAGE_COR20_HEADER
{
    // Header versioning
    DWORD                   cb;
    WORD                    MajorRuntimeVersion;
    WORD                    MinorRuntimeVersion;

    // Symbol table and startup information
    IMAGE_DATA_DIRECTORY    MetaData;
    DWORD                   Flags;

    // If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is not set, EntryPointToken represents a managed entrypoint.
    // If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is set, EntryPointRVA represents an RVA to a native entrypoint.
    union {
        DWORD               EntryPointToken;
        DWORD               EntryPointRVA;
    } DUMMYUNIONNAME;

    // Binding information
    IMAGE_DATA_DIRECTORY    Resources;
    IMAGE_DATA_DIRECTORY    StrongNameSignature;

    // Regular fixup and binding information
    IMAGE_DATA_DIRECTORY    CodeManagerTable;
    IMAGE_DATA_DIRECTORY    VTableFixups;
    IMAGE_DATA_DIRECTORY    ExportAddressTableJumps;

    // Precompiled image info (internal use only - set to zero)
    IMAGE_DATA_DIRECTORY    ManagedNativeHeader;

} IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;

#endif // __IMAGE_COR20_HEADER_DEFINED__

//
// End Image Format
//

//
// for move macros
//
#ifdef _MAC
#ifndef _INC_STRING
#include <string.h>
#endif /* _INC_STRING */
#else
#include <string.h>
#endif // _MAC


#ifndef _SLIST_HEADER_
#define _SLIST_HEADER_

#if defined(_WIN64)

//
// The type SINGLE_LIST_ENTRY is not suitable for use with SLISTs.  For
// WIN64, an entry on an SLIST is required to be 16-byte aligned, while a
// SINGLE_LIST_ENTRY structure has only 8 byte alignment.
//
// Therefore, all SLIST code should use the SLIST_ENTRY type instead of the
// SINGLE_LIST_ENTRY type.
//

#pragma warning(push)
#pragma warning(disable:4324)   // structure padded due to align()
typedef struct DECLSPEC_ALIGN(16) _SLIST_ENTRY *PSLIST_ENTRY;
typedef struct DECLSPEC_ALIGN(16) _SLIST_ENTRY {
    PSLIST_ENTRY Next;
} SLIST_ENTRY;
#pragma warning(pop)

typedef struct _SLIST_ENTRY32 {
    DWORD Next;
} SLIST_ENTRY32, *PSLIST_ENTRY32;

#else

#define SLIST_ENTRY SINGLE_LIST_ENTRY
#define _SLIST_ENTRY _SINGLE_LIST_ENTRY
#define PSLIST_ENTRY PSINGLE_LIST_ENTRY

typedef SLIST_ENTRY SLIST_ENTRY32, *PSLIST_ENTRY32;

#endif // _WIN64

#if defined(_WIN64)

typedef union DECLSPEC_ALIGN(16) _SLIST_HEADER {
    struct {  // original struct
        ULONGLONG Alignment;
        ULONGLONG Region;
    } DUMMYSTRUCTNAME;
    struct {  // 8-byte header
        ULONGLONG Depth:16;
        ULONGLONG Sequence:9;
        ULONGLONG NextEntry:39;
        ULONGLONG HeaderType:1; // 0: 8-byte; 1: 16-byte
        ULONGLONG Init:1;       // 0: uninitialized; 1: initialized
        ULONGLONG Reserved:59;
        ULONGLONG Region:3;
    } Header8;
    struct {  // ia64 16-byte header
        ULONGLONG Depth:16;
        ULONGLONG Sequence:48;
        ULONGLONG HeaderType:1; // 0: 8-byte; 1: 16-byte
        ULONGLONG Init:1;       // 0: uninitialized; 1: initialized
        ULONGLONG Reserved:2;
        ULONGLONG NextEntry:60; // last 4 bits are always 0's
    } Header16;
    struct {  // x64 16-byte header
        ULONGLONG Depth:16;
        ULONGLONG Sequence:48;
        ULONGLONG HeaderType:1; // 0: 8-byte; 1: 16-byte
        ULONGLONG Reserved:3;
        ULONGLONG NextEntry:60; // last 4 bits are always 0's
    } HeaderX64;
} SLIST_HEADER, *PSLIST_HEADER;

typedef union _SLIST_HEADER32{
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY32 Next;
        WORD   Depth;
        WORD   Sequence;
    } DUMMYSTRUCTNAME;
} SLIST_HEADER32, *PSLIST_HEADER32;

#else

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY Next;
        WORD   Depth;
        WORD   Sequence;
    } DUMMYSTRUCTNAME;
} SLIST_HEADER, *PSLIST_HEADER;

typedef SLIST_HEADER SLIST_HEADER32, *PSLIST_HEADER32;

#endif // _WIN64

#endif // _SLIST_HEADER_


NTSYSAPI
VOID
NTAPI
RtlInitializeSListHead (
    __out PSLIST_HEADER ListHead
    );

__checkReturn
NTSYSAPI
PSLIST_ENTRY
NTAPI
RtlFirstEntrySList (
    __in const SLIST_HEADER *ListHead
    );

NTSYSAPI
PSLIST_ENTRY
NTAPI
RtlInterlockedPopEntrySList (
    __inout PSLIST_HEADER ListHead
    );

NTSYSAPI
PSLIST_ENTRY
NTAPI
RtlInterlockedPushEntrySList (
    __inout PSLIST_HEADER ListHead,
    __inout __drv_aliasesMem PSLIST_ENTRY ListEntry
    );

NTSYSAPI
PSLIST_ENTRY
NTAPI
RtlInterlockedFlushSList (
    __inout PSLIST_HEADER ListHead
    );

NTSYSAPI
WORD  
NTAPI
RtlQueryDepthSList (
    __in PSLIST_HEADER ListHead
    );

#if defined(_IA64_)

NTSYSAPI
PSLIST_ENTRY32
NTAPI
RtlInterlockedPopEntrySList32 (
    __inout PSLIST_HEADER32 ListHead
    );

#endif

// begin_ntddk

#ifndef _RTL_RUN_ONCE_DEF
#define _RTL_RUN_ONCE_DEF

//
// Run once
//

#define RTL_RUN_ONCE_INIT {0}   // Static initializer

//
// Run once flags
//

#define RTL_RUN_ONCE_CHECK_ONLY     0x00000001UL
#define RTL_RUN_ONCE_ASYNC          0x00000002UL
#define RTL_RUN_ONCE_INIT_FAILED    0x00000004UL

//
// The context stored in the run once structure must leave the following number
// of low order bits unused.
//

#define RTL_RUN_ONCE_CTX_RESERVED_BITS 2

typedef union _RTL_RUN_ONCE {       
    PVOID Ptr;                      
} RTL_RUN_ONCE, *PRTL_RUN_ONCE;     

typedef
__drv_functionClass(RTL_RUN_ONCE_INIT_FN)
__drv_sameIRQL
DWORD /* LOGICAL */
NTAPI
RTL_RUN_ONCE_INIT_FN (
    __inout PRTL_RUN_ONCE RunOnce,
    __inout_opt PVOID Parameter,
    __deref_opt_inout_opt PVOID *Context
    );
typedef RTL_RUN_ONCE_INIT_FN *PRTL_RUN_ONCE_INIT_FN;

#endif // _RTL_RUN_ONCE_DEF

#if (NTDDI_VERSION >= NTDDI_LONGHORN)

__drv_maxIRQL(APC_LEVEL)
NTSYSAPI
VOID
NTAPI
RtlRunOnceInitialize (
    __out PRTL_RUN_ONCE RunOnce
    );

__drv_maxIRQL(APC_LEVEL)
__drv_inTry
NTSYSAPI
DWORD   
NTAPI
RtlRunOnceExecuteOnce (
    __inout PRTL_RUN_ONCE RunOnce,
    __in __callback PRTL_RUN_ONCE_INIT_FN InitFn,
    __inout_opt PVOID Parameter,
    __deref_opt_out_opt PVOID *Context
    );

__drv_maxIRQL(APC_LEVEL)
__checkReturn
NTSYSAPI
DWORD   
NTAPI
RtlRunOnceBeginInitialize (
    __inout PRTL_RUN_ONCE RunOnce,
    __in DWORD Flags,
    __deref_opt_out_opt PVOID *Context
    );

__drv_maxIRQL(APC_LEVEL)
NTSYSAPI
DWORD   
NTAPI
RtlRunOnceComplete (
    __inout PRTL_RUN_ONCE RunOnce,
    __in DWORD Flags,
    __in_opt PVOID Context
    );

#endif // NTDDI_VERSION >= NTDDI_LONGHORN

#define HEAP_NO_SERIALIZE               0x00000001      
#define HEAP_GROWABLE                   0x00000002      
#define HEAP_GENERATE_EXCEPTIONS        0x00000004      
#define HEAP_ZERO_MEMORY                0x00000008      
#define HEAP_REALLOC_IN_PLACE_ONLY      0x00000010      
#define HEAP_TAIL_CHECKING_ENABLED      0x00000020      
#define HEAP_FREE_CHECKING_ENABLED      0x00000040      
#define HEAP_DISABLE_COALESCE_ON_FREE   0x00000080      
#define HEAP_CREATE_ALIGN_16            0x00010000      
#define HEAP_CREATE_ENABLE_TRACING      0x00020000      
#define HEAP_CREATE_ENABLE_EXECUTE      0x00040000      
#define HEAP_MAXIMUM_TAG                0x0FFF              
#define HEAP_PSEUDO_TAG_FLAG            0x8000              
#define HEAP_TAG_SHIFT                  18                  
#if !defined(MIDL_PASS)
FORCEINLINE
DWORD
HEAP_MAKE_TAG_FLAGS (
    __in DWORD TagBase,
    __in DWORD Tag
    )

{
    __assume_bound(TagBase);
    return ((DWORD)((TagBase) + ((Tag) << HEAP_TAG_SHIFT)));
}
#endif

#if (NTDDI_VERSION > NTDDI_WINXP)
NTSYSAPI
WORD  
NTAPI
RtlCaptureStackBackTrace(
    __in DWORD FramesToSkip,
    __in DWORD FramesToCapture,
    __out_ecount(FramesToCapture) PVOID *BackTrace,
    __out_opt PDWORD BackTraceHash
   );
#endif

#if (NTDDI_VERSION > NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlCaptureContext (
    __out PCONTEXT ContextRecord
    );
#endif


#define IS_TEXT_UNICODE_ASCII16               0x0001
#define IS_TEXT_UNICODE_REVERSE_ASCII16       0x0010

#define IS_TEXT_UNICODE_STATISTICS            0x0002
#define IS_TEXT_UNICODE_REVERSE_STATISTICS    0x0020

#define IS_TEXT_UNICODE_CONTROLS              0x0004
#define IS_TEXT_UNICODE_REVERSE_CONTROLS      0x0040

#define IS_TEXT_UNICODE_SIGNATURE             0x0008
#define IS_TEXT_UNICODE_REVERSE_SIGNATURE     0x0080

#define IS_TEXT_UNICODE_ILLEGAL_CHARS         0x0100
#define IS_TEXT_UNICODE_ODD_LENGTH            0x0200
#define IS_TEXT_UNICODE_DBCS_LEADBYTE         0x0400
#define IS_TEXT_UNICODE_NULL_BYTES            0x1000

#define IS_TEXT_UNICODE_UNICODE_MASK          0x000F
#define IS_TEXT_UNICODE_REVERSE_MASK          0x00F0
#define IS_TEXT_UNICODE_NOT_UNICODE_MASK      0x0F00
#define IS_TEXT_UNICODE_NOT_ASCII_MASK        0xF000

#define COMPRESSION_FORMAT_NONE          (0x0000)   
#define COMPRESSION_FORMAT_DEFAULT       (0x0001)   
#define COMPRESSION_FORMAT_LZNT1         (0x0002)   
#define COMPRESSION_ENGINE_STANDARD      (0x0000)   
#define COMPRESSION_ENGINE_MAXIMUM       (0x0100)   
#define COMPRESSION_ENGINE_HIBER         (0x0200)   

#if _DBG_MEMCPY_INLINE_ && !defined(MIDL_PASS) && !defined(_MEMCPY_INLINE_) && !defined(_CRTBLD)
#define _MEMCPY_INLINE_
FORCEINLINE
PVOID
__cdecl
memcpy_inline (
    __out_bcount_full(size) void *dst,
    __in_bcount(size) const void *src,
    __in size_t size
    )
{
    //
    // Make sure the source and destination do not overlap such that the
    // move destroys the destination.
    //
    if (((char *)dst > (char *)src) &&
        ((char *)dst < ((char *)src + size))) {
        __debugbreak();
    }
    return memcpy(dst, src, size);
}
#define memcpy memcpy_inline
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__checkReturn
NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemory (
    __in const VOID *Source1,
    __in const VOID *Source2,
    __in SIZE_T Length
    );

#endif

#define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))


#if !defined(MIDL_PASS)

FORCEINLINE
PVOID
RtlSecureZeroMemory(
    __out_bcount_full(cnt) PVOID ptr,
    __in SIZE_T cnt
    )
{
    volatile char *vptr = (volatile char *)ptr;

#if defined(_M_AMD64)

        __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

#else

    while (cnt) {
        *vptr = 0;
        vptr++;
        cnt--;
    }

#endif

    return ptr;
}

#endif


#define SEF_DACL_AUTO_INHERIT             0x01
#define SEF_SACL_AUTO_INHERIT             0x02
#define SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT 0x04
#define SEF_AVOID_PRIVILEGE_CHECK         0x08
#define SEF_AVOID_OWNER_CHECK             0x10
#define SEF_DEFAULT_OWNER_FROM_PARENT     0x20
#define SEF_DEFAULT_GROUP_FROM_PARENT     0x40
#define SEF_MACL_NO_WRITE_UP              0x100
#define SEF_MACL_NO_READ_UP               0x200
#define SEF_MACL_NO_EXECUTE_UP            0x400
#define SEF_AVOID_OWNER_RESTRICTION       0x1000

#define SEF_MACL_VALID_FLAGS              (SEF_MACL_NO_WRITE_UP   | \
                                           SEF_MACL_NO_READ_UP    | \
                                           SEF_MACL_NO_EXECUTE_UP)


typedef struct _MESSAGE_RESOURCE_ENTRY {
    WORD   Length;
    WORD   Flags;
    BYTE  Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;

#define MESSAGE_RESOURCE_UNICODE 0x0001

typedef struct _MESSAGE_RESOURCE_BLOCK {
    DWORD LowId;
    DWORD HighId;
    DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

typedef struct _MESSAGE_RESOURCE_DATA {
    DWORD NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[ 1 ];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;


NTSYSAPI
PVOID
NTAPI
RtlPcToFileHeader(
    __in PVOID PcValue,
    __out PVOID *BaseOfImage
    );

typedef struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     // Maintenance string for PSS usage
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     // Maintenance string for PSS usage
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;
#ifdef UNICODE
typedef OSVERSIONINFOW OSVERSIONINFO;
typedef POSVERSIONINFOW POSVERSIONINFO;
typedef LPOSVERSIONINFOW LPOSVERSIONINFO;
#else
typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
#endif // UNICODE

typedef struct _OSVERSIONINFOEXA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     // Maintenance string for PSS usage
    WORD   wServicePackMajor;
    WORD   wServicePackMinor;
    WORD   wSuiteMask;
    BYTE  wProductType;
    BYTE  wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     // Maintenance string for PSS usage
    WORD   wServicePackMajor;
    WORD   wServicePackMinor;
    WORD   wSuiteMask;
    BYTE  wProductType;
    BYTE  wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;
#ifdef UNICODE
typedef OSVERSIONINFOEXW OSVERSIONINFOEX;
typedef POSVERSIONINFOEXW POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXW LPOSVERSIONINFOEX;
#else
typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
#endif // UNICODE

//
// RtlVerifyVersionInfo() conditions
//

#define VER_EQUAL                       1
#define VER_GREATER                     2
#define VER_GREATER_EQUAL               3
#define VER_LESS                        4
#define VER_LESS_EQUAL                  5
#define VER_AND                         6
#define VER_OR                          7

#define VER_CONDITION_MASK              7
#define VER_NUM_BITS_PER_CONDITION_MASK 3

//
// RtlVerifyVersionInfo() type mask bits
//

#define VER_MINORVERSION                0x0000001
#define VER_MAJORVERSION                0x0000002
#define VER_BUILDNUMBER                 0x0000004
#define VER_PLATFORMID                  0x0000008
#define VER_SERVICEPACKMINOR            0x0000010
#define VER_SERVICEPACKMAJOR            0x0000020
#define VER_SUITENAME                   0x0000040
#define VER_PRODUCT_TYPE                0x0000080

//
// RtlVerifyVersionInfo() os product type values
//

#define VER_NT_WORKSTATION              0x0000001
#define VER_NT_DOMAIN_CONTROLLER        0x0000002
#define VER_NT_SERVER                   0x0000003

//
// dwPlatformId defines:
//

#define VER_PLATFORM_WIN32s             0
#define VER_PLATFORM_WIN32_WINDOWS      1
#define VER_PLATFORM_WIN32_NT           2


//
//
// VerifyVersionInfo() macro to set the condition mask
//
// For documentation sakes here's the old version of the macro that got
// changed to call an API
// #define VER_SET_CONDITION(_m_,_t_,_c_)  _m_=(_m_|(_c_<<(1<<_t_)))
//

#define VER_SET_CONDITION(_m_,_t_,_c_)  \
        ((_m_)=VerSetConditionMask((_m_),(_t_),(_c_)))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONGLONG
NTAPI
VerSetConditionMask(
    __in ULONGLONG ConditionMask,
    __in DWORD TypeMask,
    __in BYTE  Condition
    );
#endif

//

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTSYSAPI
BOOLEAN
NTAPI
RtlGetProductInfo(
    __in  DWORD  OSMajorVersion,
    __in  DWORD  OSMinorVersion,
    __in  DWORD  SpMajorVersion,
    __in  DWORD  SpMinorVersion,
    __out PDWORD ReturnedProductType
    );

#endif

#define RTL_UMS_VERSION  (0x0100)  

typedef enum _RTL_UMS_THREAD_INFO_CLASS {
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext,
    UmsThreadPriority,
    UmsThreadAffinity,
    UmsThreadTeb,
    UmsThreadIsSuspended,
    UmsThreadIsTerminated,
    UmsThreadMaxInfoClass
} RTL_UMS_THREAD_INFO_CLASS, *PRTL_UMS_THREAD_INFO_CLASS;

typedef enum _RTL_UMS_SCHEDULER_REASON {
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked,
    UmsSchedulerThreadYield,
} RTL_UMS_SCHEDULER_REASON, *PRTL_UMS_SCHEDULER_REASON;

typedef
__drv_functionClass(RTL_UMS_SCHEDULER_ENTRY_POINT)
VOID
NTAPI
RTL_UMS_SCHEDULER_ENTRY_POINT(
    __in RTL_UMS_SCHEDULER_REASON Reason,
    __in ULONG_PTR ActivationPayload,
    __in PVOID SchedulerParam
    );

typedef RTL_UMS_SCHEDULER_ENTRY_POINT *PRTL_UMS_SCHEDULER_ENTRY_POINT;


#if (NTDDI_VERSION >= NTDDI_WIN7)


NTSYSAPI
DWORD   
NTAPI
RtlCopyExtendedContext (
    __out PCONTEXT_EX Destination,
    __in DWORD ContextFlags,
    __in PCONTEXT_EX Source
    );

NTSYSAPI
DWORD   
NTAPI
RtlInitializeExtendedContext (
    __out PVOID Context,
    __in DWORD ContextFlags,
    __out PCONTEXT_EX* ContextEx
    );

NTSYSAPI
DWORD64
NTAPI
RtlGetEnabledExtendedFeatures (
    __in DWORD64 FeatureMask
    );


NTSYSAPI
DWORD   
NTAPI
RtlGetExtendedContextLength (
    __in DWORD ContextFlags,
    __out PDWORD ContextLength
    );

NTSYSAPI
DWORD64
NTAPI
RtlGetExtendedFeaturesMask (
    __in PCONTEXT_EX ContextEx
    );

NTSYSAPI
PVOID
NTAPI
RtlLocateExtendedFeature (
    __in PCONTEXT_EX ContextEx,
    __in DWORD FeatureId,
    __out_opt PDWORD Length
    );

NTSYSAPI
PCONTEXT
NTAPI
RtlLocateLegacyContext (
    __in PCONTEXT_EX ContextEx,
    __out_opt PDWORD Length
    );

NTSYSAPI
VOID
NTAPI
RtlSetExtendedFeaturesMask (
    __out PCONTEXT_EX ContextEx,
    __in DWORD64 FeatureMask
    );

#endif


typedef struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD   Type;
    WORD   CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Flags;
    WORD   CreatorBackTraceIndexHigh;
    WORD   SpareWORD  ;
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG, RTL_RESOURCE_DEBUG, *PRTL_RESOURCE_DEBUG;

#define RTL_CRITSECT_TYPE 0
#define RTL_RESOURCE_TYPE 1

//
// These flags define the upper byte of the critical section SpinCount field
//
#define RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO         0x01000000
#define RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN          0x02000000
#define RTL_CRITICAL_SECTION_FLAG_STATIC_INIT           0x04000000
#define RTL_CRITICAL_SECTION_ALL_FLAG_BITS              0xFF000000
#define RTL_CRITICAL_SECTION_FLAG_RESERVED              (RTL_CRITICAL_SECTION_ALL_FLAG_BITS & (~(RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO | RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN | RTL_CRITICAL_SECTION_FLAG_STATIC_INIT)))

//
// These flags define possible values stored in the Flags field of a critsec debuginfo.
//
#define RTL_CRITICAL_SECTION_DEBUG_FLAG_STATIC_INIT     0x00000001

#pragma pack(push, 8)

typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;        // from the thread's ClientId->UniqueThread
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;        // force size on 64-bit systems when packed
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

#pragma pack(pop)

typedef struct _RTL_SRWLOCK {                            
        PVOID Ptr;                                       
} RTL_SRWLOCK, *PRTL_SRWLOCK;                            
#define RTL_SRWLOCK_INIT {0}                            
typedef struct _RTL_CONDITION_VARIABLE {                    
        PVOID Ptr;                                       
} RTL_CONDITION_VARIABLE, *PRTL_CONDITION_VARIABLE;      
#define RTL_CONDITION_VARIABLE_INIT {0}                 
#define RTL_CONDITION_VARIABLE_LOCKMODE_SHARED  0x1     
typedef
VOID
(NTAPI *PAPCFUNC)(
    __in ULONG_PTR Parameter
    );
typedef LONG (NTAPI *PVECTORED_EXCEPTION_HANDLER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef enum _HEAP_INFORMATION_CLASS {

    HeapCompatibilityInformation,
    HeapEnableTerminationOnCorruption


} HEAP_INFORMATION_CLASS;


#define WT_EXECUTEDEFAULT       0x00000000                           
#define WT_EXECUTEINIOTHREAD    0x00000001                           
#define WT_EXECUTEINUITHREAD    0x00000002                           
#define WT_EXECUTEINWAITTHREAD  0x00000004                           
#define WT_EXECUTEONLYONCE      0x00000008                           
#define WT_EXECUTEINTIMERTHREAD 0x00000020                           
#define WT_EXECUTELONGFUNCTION  0x00000010                           
#define WT_EXECUTEINPERSISTENTIOTHREAD  0x00000040                   
#define WT_EXECUTEINPERSISTENTTHREAD 0x00000080                      
#define WT_TRANSFER_IMPERSONATION 0x00000100                         
#define WT_SET_MAX_THREADPOOL_THREADS(Flags, Limit)  ((Flags) |= (Limit)<<16) 
typedef VOID (NTAPI * WAITORTIMERCALLBACKFUNC) (PVOID, BOOLEAN );   
typedef VOID (NTAPI * WORKERCALLBACKFUNC) (PVOID );                 
typedef VOID (NTAPI * APC_CALLBACK_FUNCTION) (DWORD   , PVOID, PVOID); 
typedef
VOID
(NTAPI *PFLS_CALLBACK_FUNCTION) (
    IN PVOID lpFlsData
    );

typedef
BOOLEAN
(NTAPI *PSECURE_MEMORY_CACHE_CALLBACK) (
    __in_bcount(Range) PVOID Addr,
    __in SIZE_T Range
    );

#define WT_EXECUTEINLONGTHREAD  0x00000010                           
#define WT_EXECUTEDELETEWAIT    0x00000008                           

typedef enum _ACTIVATION_CONTEXT_INFO_CLASS {
    ActivationContextBasicInformation                       = 1,
    ActivationContextDetailedInformation                    = 2,
    AssemblyDetailedInformationInActivationContext          = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext  = 4,
    RunlevelInformationInActivationContext                  = 5,
    CompatibilityInformationInActivationContext             = 6,
    ActivationContextManifestResourceName                   = 7,
    MaxActivationContextInfoClass,

    //
    // compatibility with old names
    //
    AssemblyDetailedInformationInActivationContxt           = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt   = 4
} ACTIVATION_CONTEXT_INFO_CLASS;

#define ACTIVATIONCONTEXTINFOCLASS ACTIVATION_CONTEXT_INFO_CLASS


typedef struct _ACTIVATION_CONTEXT_QUERY_INDEX {
    DWORD ulAssemblyIndex;
    DWORD ulFileIndexInAssembly;
} ACTIVATION_CONTEXT_QUERY_INDEX, * PACTIVATION_CONTEXT_QUERY_INDEX;

typedef const struct _ACTIVATION_CONTEXT_QUERY_INDEX * PCACTIVATION_CONTEXT_QUERY_INDEX;


#define ACTIVATION_CONTEXT_PATH_TYPE_NONE (1)
#define ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE (2)
#define ACTIVATION_CONTEXT_PATH_TYPE_URL (3)
#define ACTIVATION_CONTEXT_PATH_TYPE_ASSEMBLYREF (4)

typedef struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulFilenameLength;
    DWORD ulPathLength;

    PCWSTR lpFileName;
    PCWSTR lpFilePath;
} ASSEMBLY_FILE_DETAILED_INFORMATION, *PASSEMBLY_FILE_DETAILED_INFORMATION;
typedef const ASSEMBLY_FILE_DETAILED_INFORMATION *PCASSEMBLY_FILE_DETAILED_INFORMATION;

//
// compatibility with old names
// The new names use "file" consistently.
//
#define  _ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION  _ASSEMBLY_FILE_DETAILED_INFORMATION
#define   ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION   ASSEMBLY_FILE_DETAILED_INFORMATION
#define  PASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION  PASSEMBLY_FILE_DETAILED_INFORMATION
#define PCASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION PCASSEMBLY_FILE_DETAILED_INFORMATION

typedef struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulEncodedAssemblyIdentityLength;      // in bytes
    DWORD ulManifestPathType;                   // ACTIVATION_CONTEXT_PATH_TYPE_*
    DWORD ulManifestPathLength;                 // in bytes
    LARGE_INTEGER liManifestLastWriteTime;      // FILETIME
    DWORD ulPolicyPathType;                     // ACTIVATION_CONTEXT_PATH_TYPE_*
    DWORD ulPolicyPathLength;                   // in bytes
    LARGE_INTEGER liPolicyLastWriteTime;        // FILETIME
    DWORD ulMetadataSatelliteRosterIndex;

    DWORD ulManifestVersionMajor;               // 1
    DWORD ulManifestVersionMinor;               // 0
    DWORD ulPolicyVersionMajor;                 // 0
    DWORD ulPolicyVersionMinor;                 // 0
    DWORD ulAssemblyDirectoryNameLength;        // in bytes

    PCWSTR lpAssemblyEncodedAssemblyIdentity;
    PCWSTR lpAssemblyManifestPath;
    PCWSTR lpAssemblyPolicyPath;
    PCWSTR lpAssemblyDirectoryName;

    DWORD  ulFileCount;
} ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION, * PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION * PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION ;

typedef enum
{
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN,
    ACTCTX_RUN_LEVEL_NUMBERS
} ACTCTX_REQUESTED_RUN_LEVEL;

typedef struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
    DWORD ulFlags;
    ACTCTX_REQUESTED_RUN_LEVEL  RunLevel;
    DWORD UiAccess;
} ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION, * PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION * PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION ;

typedef enum
{
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION
} ACTCTX_COMPATIBILITY_ELEMENT_TYPE;

typedef struct _COMPATIBILITY_CONTEXT_ELEMENT {
    GUID Id;
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
} COMPATIBILITY_CONTEXT_ELEMENT, *PCOMPATIBILITY_CONTEXT_ELEMENT;

typedef const struct _COMPATIBILITY_CONTEXT_ELEMENT *PCCOMPATIBILITY_CONTEXT_ELEMENT;

#pragma warning(push)
#pragma warning(disable:4200)

typedef struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
    DWORD ElementCount;
    COMPATIBILITY_CONTEXT_ELEMENT Elements[];
} ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION, * PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;

#pragma warning(pop)

typedef const struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION * PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;

#define MAX_SUPPORTED_OS_NUM    (4)
#define INVALID_OS_COUNT        (0xffff)

typedef struct _SUPPORTED_OS_INFO {
    WORD   OsCount;
    WORD   MitigationExist;
    WORD   OsList[MAX_SUPPORTED_OS_NUM];
} SUPPORTED_OS_INFO, *PSUPPORTED_OS_INFO;

typedef struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
    DWORD dwFlags;
    DWORD ulFormatVersion;
    DWORD ulAssemblyCount;
    DWORD ulRootManifestPathType;
    DWORD ulRootManifestPathChars;
    DWORD ulRootConfigurationPathType;
    DWORD ulRootConfigurationPathChars;
    DWORD ulAppDirPathType;
    DWORD ulAppDirPathChars;
    PCWSTR lpRootManifestPath;
    PCWSTR lpRootConfigurationPath;
    PCWSTR lpAppDirPath;
} ACTIVATION_CONTEXT_DETAILED_INFORMATION, *PACTIVATION_CONTEXT_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION *PCACTIVATION_CONTEXT_DETAILED_INFORMATION;

typedef struct _HARDWARE_COUNTER_DATA {
    HARDWARE_COUNTER_TYPE Type;
    DWORD Reserved;
    DWORD64 Value;
} HARDWARE_COUNTER_DATA, *PHARDWARE_COUNTER_DATA;

#define PERFORMANCE_DATA_VERSION 1

typedef struct _PERFORMANCE_DATA {
    WORD   Size;
    BYTE  Version;
    BYTE  HwCountersCount;
    DWORD ContextSwitchCount;
    DWORD64 WaitReasonBitMap;
    DWORD64 CycleTime;
    DWORD RetryCount;
    DWORD Reserved;
    HARDWARE_COUNTER_DATA HwCounters[MAX_HW_COUNTERS];
} PERFORMANCE_DATA, *PPERFORMANCE_DATA;

#define READ_THREAD_PROFILING_FLAG_DISPATCHING        0x00000001
#define READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS  0x00000002
#define DLL_PROCESS_ATTACH   1    
#define DLL_THREAD_ATTACH    2    
#define DLL_THREAD_DETACH    3    
#define DLL_PROCESS_DETACH   0    

//
// Defines for the READ flags for Eventlogging
//
#define EVENTLOG_SEQUENTIAL_READ        0x0001
#define EVENTLOG_SEEK_READ              0x0002
#define EVENTLOG_FORWARDS_READ          0x0004
#define EVENTLOG_BACKWARDS_READ         0x0008

//
// The types of events that can be logged.
//
#define EVENTLOG_SUCCESS                0x0000
#define EVENTLOG_ERROR_TYPE             0x0001
#define EVENTLOG_WARNING_TYPE           0x0002
#define EVENTLOG_INFORMATION_TYPE       0x0004
#define EVENTLOG_AUDIT_SUCCESS          0x0008
#define EVENTLOG_AUDIT_FAILURE          0x0010

//
// Defines for the WRITE flags used by Auditing for paired events
// These are not implemented in Product 1
//

#define EVENTLOG_START_PAIRED_EVENT    0x0001
#define EVENTLOG_END_PAIRED_EVENT      0x0002
#define EVENTLOG_END_ALL_PAIRED_EVENTS 0x0004
#define EVENTLOG_PAIRED_EVENT_ACTIVE   0x0008
#define EVENTLOG_PAIRED_EVENT_INACTIVE 0x0010

//
// Structure that defines the header of the Eventlog record. This is the
// fixed-sized portion before all the variable-length strings, binary
// data and pad bytes.
//
// TimeGenerated is the time it was generated at the client.
// TimeWritten is the time it was put into the log at the server end.
//

typedef struct _EVENTLOGRECORD {
    DWORD  Length;        // Length of full record
    DWORD  Reserved;      // Used by the service
    DWORD  RecordNumber;  // Absolute record number
    DWORD  TimeGenerated; // Seconds since 1-1-1970
    DWORD  TimeWritten;   // Seconds since 1-1-1970
    DWORD  EventID;
    WORD   EventType;
    WORD   NumStrings;
    WORD   EventCategory;
    WORD   ReservedFlags; // For use with paired events (auditing)
    DWORD  ClosingRecordNumber; // For use with paired events (auditing)
    DWORD  StringOffset;  // Offset from beginning of record
    DWORD  UserSidLength;
    DWORD  UserSidOffset;
    DWORD  DataLength;
    DWORD  DataOffset;    // Offset from beginning of record
    //
    // Then follow:
    //
    // WCHAR SourceName[]
    // WCHAR Computername[]
    // SID   UserSid
    // WCHAR Strings[]
    // BYTE  Data[]
    // CHAR  Pad[]
    // DWORD Length;
    //
} EVENTLOGRECORD, *PEVENTLOGRECORD;

//SS: start of changes to support clustering
//SS: ideally the
#define MAXLOGICALLOGNAMESIZE   256

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable : 4200) /* nonstandard extension used : zero-sized array in struct/union */

struct _EVENTSFORLOGFILE;
typedef struct _EVENTSFORLOGFILE EVENTSFORLOGFILE, *PEVENTSFORLOGFILE;

struct _PACKEDEVENTINFO;
typedef struct _PACKEDEVENTINFO PACKEDEVENTINFO, *PPACKEDEVENTINFO;

#if defined(_MSC_EXTENSIONS)

struct _EVENTSFORLOGFILE
{
    DWORD           ulSize;
    WCHAR           szLogicalLogFile[MAXLOGICALLOGNAMESIZE];        //name of the logical file-security/application/system
    DWORD           ulNumRecords;
    EVENTLOGRECORD  pEventLogRecords[];
};

struct _PACKEDEVENTINFO
{
    DWORD               ulSize;  //total size of the structure
    DWORD               ulNumEventsForLogFile; //number of EventsForLogFile structure that follow
    DWORD               ulOffsets[];           //the offsets from the start of this structure to the EVENTSFORLOGFILE structure
};

#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default : 4200) /* nonstandard extension used : zero-sized array in struct/union */
#endif
//SS: end of changes to support clustering
//

// begin_wdm 
//
// Registry Specific Access Rights.
//

#define KEY_QUERY_VALUE         (0x0001)
#define KEY_SET_VALUE           (0x0002)
#define KEY_CREATE_SUB_KEY      (0x0004)
#define KEY_ENUMERATE_SUB_KEYS  (0x0008)
#define KEY_NOTIFY              (0x0010)
#define KEY_CREATE_LINK         (0x0020)
#define KEY_WOW64_32KEY         (0x0200)
#define KEY_WOW64_64KEY         (0x0100)
#define KEY_WOW64_RES           (0x0300)

#define KEY_READ                ((STANDARD_RIGHTS_READ       |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY)                 \
                                  &                           \
                                 (~SYNCHRONIZE))


#define KEY_WRITE               ((STANDARD_RIGHTS_WRITE      |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY)         \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_EXECUTE             ((KEY_READ)                   \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_ALL_ACCESS          ((STANDARD_RIGHTS_ALL        |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY         |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY                 |\
                                  KEY_CREATE_LINK)            \
                                  &                           \
                                 (~SYNCHRONIZE))

//
// Open/Create Options
//

#define REG_OPTION_RESERVED         (0x00000000L)   // Parameter is reserved

#define REG_OPTION_NON_VOLATILE     (0x00000000L)   // Key is preserved
                                                    // when system is rebooted

#define REG_OPTION_VOLATILE         (0x00000001L)   // Key is not preserved
                                                    // when system is rebooted

#define REG_OPTION_CREATE_LINK      (0x00000002L)   // Created key is a
                                                    // symbolic link

#define REG_OPTION_BACKUP_RESTORE   (0x00000004L)   // open for backup or restore
                                                    // special access rules
                                                    // privilege required

#define REG_OPTION_OPEN_LINK        (0x00000008L)   // Open symbolic link

#define REG_LEGAL_OPTION            \
                (REG_OPTION_RESERVED            |\
                 REG_OPTION_NON_VOLATILE        |\
                 REG_OPTION_VOLATILE            |\
                 REG_OPTION_CREATE_LINK         |\
                 REG_OPTION_BACKUP_RESTORE      |\
                 REG_OPTION_OPEN_LINK)

#define REG_OPEN_LEGAL_OPTION       \
                (REG_OPTION_RESERVED            |\
                 REG_OPTION_BACKUP_RESTORE      |\
                 REG_OPTION_OPEN_LINK)

//
// Key creation/open disposition
//

#define REG_CREATED_NEW_KEY         (0x00000001L)   // New Registry Key created
#define REG_OPENED_EXISTING_KEY     (0x00000002L)   // Existing Key opened

//
// hive format to be used by Reg(Nt)SaveKeyEx
//
#define REG_STANDARD_FORMAT     1
#define REG_LATEST_FORMAT       2
#define REG_NO_COMPRESSION      4

//
// Key restore & hive load flags
//

#define REG_WHOLE_HIVE_VOLATILE         (0x00000001L)   // Restore whole hive volatile
#define REG_REFRESH_HIVE                (0x00000002L)   // Unwind changes to last flush
#define REG_NO_LAZY_FLUSH               (0x00000004L)   // Never lazy flush this hive
#define REG_FORCE_RESTORE               (0x00000008L)   // Force the restore process even when we have open handles on subkeys
#define REG_APP_HIVE                    (0x00000010L)   // Loads the hive visible to the calling process
#define REG_PROCESS_PRIVATE             (0x00000020L)   // Hive cannot be mounted by any other process while in use
#define REG_START_JOURNAL               (0x00000040L)   // Starts Hive Journal
#define REG_HIVE_EXACT_FILE_GROWTH      (0x00000080L)   // Grow hive file in exact 4k increments
#define REG_HIVE_NO_RM                  (0x00000100L)   // No RM is started for this hive (no transactions)
#define REG_HIVE_SINGLE_LOG             (0x00000200L)   // Legacy single logging is used for this hive
#define REG_BOOT_HIVE                   (0x00000400L)   // This hive might be used by the OS loader

//
// Unload Flags
//
#define REG_FORCE_UNLOAD            1

//
// Notify filter values
//

#define REG_NOTIFY_CHANGE_NAME          (0x00000001L) // Create or delete (child)
#define REG_NOTIFY_CHANGE_ATTRIBUTES    (0x00000002L)
#define REG_NOTIFY_CHANGE_LAST_SET      (0x00000004L) // time stamp
#define REG_NOTIFY_CHANGE_SECURITY      (0x00000008L)

#define REG_LEGAL_CHANGE_FILTER                 \
                (REG_NOTIFY_CHANGE_NAME          |\
                 REG_NOTIFY_CHANGE_ATTRIBUTES    |\
                 REG_NOTIFY_CHANGE_LAST_SET      |\
                 REG_NOTIFY_CHANGE_SECURITY)
 
// end_wdm 

//
//
// Predefined Value Types.
//

#define REG_NONE                    ( 0 )   // No value type
#define REG_SZ                      ( 1 )   // Unicode nul terminated string
#define REG_EXPAND_SZ               ( 2 )   // Unicode nul terminated string
                                            // (with environment variable references)
#define REG_BINARY                  ( 3 )   // Free form binary
#define REG_DWORD                   ( 4 )   // 32-bit number
#define REG_DWORD_LITTLE_ENDIAN     ( 4 )   // 32-bit number (same as REG_DWORD)
#define REG_DWORD_BIG_ENDIAN        ( 5 )   // 32-bit number
#define REG_LINK                    ( 6 )   // Symbolic Link (unicode)
#define REG_MULTI_SZ                ( 7 )   // Multiple Unicode strings
#define REG_RESOURCE_LIST           ( 8 )   // Resource list in the resource map
#define REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description
#define REG_RESOURCE_REQUIREMENTS_LIST ( 10 )
#define REG_QWORD                   ( 11 )  // 64-bit number
#define REG_QWORD_LITTLE_ENDIAN     ( 11 )  // 64-bit number (same as REG_QWORD)

// end_wdm

// begin_wdm
//
// Service Types (Bit Mask)
//
#define SERVICE_KERNEL_DRIVER          0x00000001
#define SERVICE_FILE_SYSTEM_DRIVER     0x00000002
#define SERVICE_ADAPTER                0x00000004
#define SERVICE_RECOGNIZER_DRIVER      0x00000008

#define SERVICE_DRIVER                 (SERVICE_KERNEL_DRIVER | \
                                        SERVICE_FILE_SYSTEM_DRIVER | \
                                        SERVICE_RECOGNIZER_DRIVER)

#define SERVICE_WIN32_OWN_PROCESS      0x00000010
#define SERVICE_WIN32_SHARE_PROCESS    0x00000020
#define SERVICE_WIN32                  (SERVICE_WIN32_OWN_PROCESS | \
                                        SERVICE_WIN32_SHARE_PROCESS)

#define SERVICE_INTERACTIVE_PROCESS    0x00000100

#define SERVICE_TYPE_ALL               (SERVICE_WIN32  | \
                                        SERVICE_ADAPTER | \
                                        SERVICE_DRIVER  | \
                                        SERVICE_INTERACTIVE_PROCESS)

//
// Start Type
//

#define SERVICE_BOOT_START             0x00000000
#define SERVICE_SYSTEM_START           0x00000001
#define SERVICE_AUTO_START             0x00000002
#define SERVICE_DEMAND_START           0x00000003
#define SERVICE_DISABLED               0x00000004

//
// Error control type
//
#define SERVICE_ERROR_IGNORE           0x00000000
#define SERVICE_ERROR_NORMAL           0x00000001
#define SERVICE_ERROR_SEVERE           0x00000002
#define SERVICE_ERROR_CRITICAL         0x00000003

//
//
// Define the registry driver node enumerations
//

typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType               = SERVICE_KERNEL_DRIVER,
    FileSystemType           = SERVICE_FILE_SYSTEM_DRIVER,
    Win32ServiceOwnProcess   = SERVICE_WIN32_OWN_PROCESS,
    Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS,
    AdapterType              = SERVICE_ADAPTER,
    RecognizerType           = SERVICE_RECOGNIZER_DRIVER
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad    = SERVICE_BOOT_START,
    SystemLoad  = SERVICE_SYSTEM_START,
    AutoLoad    = SERVICE_AUTO_START,
    DemandLoad  = SERVICE_DEMAND_START,
    DisableLoad = SERVICE_DISABLED
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError   = SERVICE_ERROR_IGNORE,
    NormalError   = SERVICE_ERROR_NORMAL,
    SevereError   = SERVICE_ERROR_SEVERE,
    CriticalError = SERVICE_ERROR_CRITICAL
} SERVICE_ERROR_TYPE;

//
// Service node Flags. These flags are used by the OS loader to promote
// a driver's start type to boot start if the system is booting using
// the specified mechanism. The flags should be set in the driver's
// registry configuration.
//
// CM_SERVICE_NETWORK_BOOT_LOAD - Specified if a driver should be
// promoted on network boot.
//
// CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD - Specified if a driver should be
// promoted on booting from a VHD.
//
// CM_SERVICE_USB_DISK_BOOT_LOAD - Specified if a driver should be promoted
// while booting from a USB disk.
//

#define CM_SERVICE_NETWORK_BOOT_LOAD      0x00000001
#define CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD 0x00000002
#define CM_SERVICE_USB_DISK_BOOT_LOAD     0x00000004

//
// Mask defining the legal promotion flag values.
//

#define CM_SERVICE_VALID_PROMOTION_MASK (CM_SERVICE_NETWORK_BOOT_LOAD |       \
                                         CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD |  \
                                         CM_SERVICE_USB_DISK_BOOT_LOAD)



//
// IOCTL_TAPE_ERASE definitions
//

#define TAPE_ERASE_SHORT            0L
#define TAPE_ERASE_LONG             1L

typedef struct _TAPE_ERASE {
    DWORD Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;

//
// IOCTL_TAPE_PREPARE definitions
//

#define TAPE_LOAD                   0L
#define TAPE_UNLOAD                 1L
#define TAPE_TENSION                2L
#define TAPE_LOCK                   3L
#define TAPE_UNLOCK                 4L
#define TAPE_FORMAT                 5L

typedef struct _TAPE_PREPARE {
    DWORD Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;

//
// IOCTL_TAPE_WRITE_MARKS definitions
//

#define TAPE_SETMARKS               0L
#define TAPE_FILEMARKS              1L
#define TAPE_SHORT_FILEMARKS        2L
#define TAPE_LONG_FILEMARKS         3L

typedef struct _TAPE_WRITE_MARKS {
    DWORD Type;
    DWORD Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;

//
// IOCTL_TAPE_GET_POSITION definitions
//

#define TAPE_ABSOLUTE_POSITION       0L
#define TAPE_LOGICAL_POSITION        1L
#define TAPE_PSEUDO_LOGICAL_POSITION 2L

typedef struct _TAPE_GET_POSITION {
    DWORD Type;
    DWORD Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;

//
// IOCTL_TAPE_SET_POSITION definitions
//

#define TAPE_REWIND                 0L
#define TAPE_ABSOLUTE_BLOCK         1L
#define TAPE_LOGICAL_BLOCK          2L
#define TAPE_PSEUDO_LOGICAL_BLOCK   3L
#define TAPE_SPACE_END_OF_DATA      4L
#define TAPE_SPACE_RELATIVE_BLOCKS  5L
#define TAPE_SPACE_FILEMARKS        6L
#define TAPE_SPACE_SEQUENTIAL_FMKS  7L
#define TAPE_SPACE_SETMARKS         8L
#define TAPE_SPACE_SEQUENTIAL_SMKS  9L

typedef struct _TAPE_SET_POSITION {
    DWORD Method;
    DWORD Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;

//
// IOCTL_TAPE_GET_DRIVE_PARAMS definitions
//

//
// Definitions for FeaturesLow parameter
//

#define TAPE_DRIVE_FIXED            0x00000001
#define TAPE_DRIVE_SELECT           0x00000002
#define TAPE_DRIVE_INITIATOR        0x00000004

#define TAPE_DRIVE_ERASE_SHORT      0x00000010
#define TAPE_DRIVE_ERASE_LONG       0x00000020
#define TAPE_DRIVE_ERASE_BOP_ONLY   0x00000040
#define TAPE_DRIVE_ERASE_IMMEDIATE  0x00000080

#define TAPE_DRIVE_TAPE_CAPACITY    0x00000100
#define TAPE_DRIVE_TAPE_REMAINING   0x00000200
#define TAPE_DRIVE_FIXED_BLOCK      0x00000400
#define TAPE_DRIVE_VARIABLE_BLOCK   0x00000800

#define TAPE_DRIVE_WRITE_PROTECT    0x00001000
#define TAPE_DRIVE_EOT_WZ_SIZE      0x00002000

#define TAPE_DRIVE_ECC              0x00010000
#define TAPE_DRIVE_COMPRESSION      0x00020000
#define TAPE_DRIVE_PADDING          0x00040000
#define TAPE_DRIVE_REPORT_SMKS      0x00080000

#define TAPE_DRIVE_GET_ABSOLUTE_BLK 0x00100000
#define TAPE_DRIVE_GET_LOGICAL_BLK  0x00200000
#define TAPE_DRIVE_SET_EOT_WZ_SIZE  0x00400000

#define TAPE_DRIVE_EJECT_MEDIA      0x01000000
#define TAPE_DRIVE_CLEAN_REQUESTS   0x02000000
#define TAPE_DRIVE_SET_CMP_BOP_ONLY 0x04000000

#define TAPE_DRIVE_RESERVED_BIT     0x80000000  //don't use this bit!
//                                              //can't be a low features bit!
//                                              //reserved; high features only

//
// Definitions for FeaturesHigh parameter
//

#define TAPE_DRIVE_LOAD_UNLOAD      0x80000001
#define TAPE_DRIVE_TENSION          0x80000002
#define TAPE_DRIVE_LOCK_UNLOCK      0x80000004
#define TAPE_DRIVE_REWIND_IMMEDIATE 0x80000008

#define TAPE_DRIVE_SET_BLOCK_SIZE   0x80000010
#define TAPE_DRIVE_LOAD_UNLD_IMMED  0x80000020
#define TAPE_DRIVE_TENSION_IMMED    0x80000040
#define TAPE_DRIVE_LOCK_UNLK_IMMED  0x80000080

#define TAPE_DRIVE_SET_ECC          0x80000100
#define TAPE_DRIVE_SET_COMPRESSION  0x80000200
#define TAPE_DRIVE_SET_PADDING      0x80000400
#define TAPE_DRIVE_SET_REPORT_SMKS  0x80000800

#define TAPE_DRIVE_ABSOLUTE_BLK     0x80001000
#define TAPE_DRIVE_ABS_BLK_IMMED    0x80002000
#define TAPE_DRIVE_LOGICAL_BLK      0x80004000
#define TAPE_DRIVE_LOG_BLK_IMMED    0x80008000

#define TAPE_DRIVE_END_OF_DATA      0x80010000
#define TAPE_DRIVE_RELATIVE_BLKS    0x80020000
#define TAPE_DRIVE_FILEMARKS        0x80040000
#define TAPE_DRIVE_SEQUENTIAL_FMKS  0x80080000

#define TAPE_DRIVE_SETMARKS         0x80100000
#define TAPE_DRIVE_SEQUENTIAL_SMKS  0x80200000
#define TAPE_DRIVE_REVERSE_POSITION 0x80400000
#define TAPE_DRIVE_SPACE_IMMEDIATE  0x80800000

#define TAPE_DRIVE_WRITE_SETMARKS   0x81000000
#define TAPE_DRIVE_WRITE_FILEMARKS  0x82000000
#define TAPE_DRIVE_WRITE_SHORT_FMKS 0x84000000
#define TAPE_DRIVE_WRITE_LONG_FMKS  0x88000000

#define TAPE_DRIVE_WRITE_MARK_IMMED 0x90000000
#define TAPE_DRIVE_FORMAT           0xA0000000
#define TAPE_DRIVE_FORMAT_IMMEDIATE 0xC0000000
#define TAPE_DRIVE_HIGH_FEATURES    0x80000000  //mask for high features flag

typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD DefaultBlockSize;
    DWORD MaximumBlockSize;
    DWORD MinimumBlockSize;
    DWORD MaximumPartitionCount;
    DWORD FeaturesLow;
    DWORD FeaturesHigh;
    DWORD EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_SET_DRIVE_PARAMETERS definitions
//

typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_GET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    DWORD BlockSize;
    DWORD PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_SET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    DWORD BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_CREATE_PARTITION definitions
//

#define TAPE_FIXED_PARTITIONS       0L
#define TAPE_SELECT_PARTITIONS      1L
#define TAPE_INITIATOR_PARTITIONS   2L

typedef struct _TAPE_CREATE_PARTITION {
    DWORD Method;
    DWORD Count;
    DWORD Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;


//
// WMI Methods
//
#define TAPE_QUERY_DRIVE_PARAMETERS       0L
#define TAPE_QUERY_MEDIA_CAPACITY         1L
#define TAPE_CHECK_FOR_DRIVE_PROBLEM      2L
#define TAPE_QUERY_IO_ERROR_DATA          3L
#define TAPE_QUERY_DEVICE_ERROR_DATA      4L

typedef struct _TAPE_WMI_OPERATIONS {
   DWORD Method;
   DWORD DataBufferSize;
   PVOID DataBuffer;
} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;

//
// Type of drive errors
//
typedef enum _TAPE_DRIVE_PROBLEM_TYPE {
   TapeDriveProblemNone, TapeDriveReadWriteWarning,
   TapeDriveReadWriteError, TapeDriveReadWarning,
   TapeDriveWriteWarning, TapeDriveReadError,
   TapeDriveWriteError, TapeDriveHardwareError,
   TapeDriveUnsupportedMedia, TapeDriveScsiConnectionError,
   TapeDriveTimetoClean, TapeDriveCleanDriveNow,
   TapeDriveMediaLifeExpired, TapeDriveSnappedTape
} TAPE_DRIVE_PROBLEM_TYPE;

#ifndef _NTTMAPI_
#define _NTTMAPI_


#ifdef __cplusplus
extern "C" {
#endif


#include <ktmtypes.h>

//
// Types for Nt level TM calls
//

//
// KTM Tm object rights
//
#define TRANSACTIONMANAGER_QUERY_INFORMATION     ( 0x0001 )
#define TRANSACTIONMANAGER_SET_INFORMATION       ( 0x0002 )
#define TRANSACTIONMANAGER_RECOVER               ( 0x0004 )
#define TRANSACTIONMANAGER_RENAME                ( 0x0008 )
#define TRANSACTIONMANAGER_CREATE_RM             ( 0x0010 )

// The following right is intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
#define TRANSACTIONMANAGER_BIND_TRANSACTION      ( 0x0020 )

//
// Generic mappings for transaction manager rights.
//

#define TRANSACTIONMANAGER_GENERIC_READ            (STANDARD_RIGHTS_READ            |\
                                                    TRANSACTIONMANAGER_QUERY_INFORMATION)

#define TRANSACTIONMANAGER_GENERIC_WRITE           (STANDARD_RIGHTS_WRITE           |\
                                                    TRANSACTIONMANAGER_SET_INFORMATION     |\
                                                    TRANSACTIONMANAGER_RECOVER             |\
                                                    TRANSACTIONMANAGER_RENAME              |\
                                                    TRANSACTIONMANAGER_CREATE_RM)

#define TRANSACTIONMANAGER_GENERIC_EXECUTE         (STANDARD_RIGHTS_EXECUTE)

#define TRANSACTIONMANAGER_ALL_ACCESS              (STANDARD_RIGHTS_REQUIRED        |\
                                                    TRANSACTIONMANAGER_GENERIC_READ        |\
                                                    TRANSACTIONMANAGER_GENERIC_WRITE       |\
                                                    TRANSACTIONMANAGER_GENERIC_EXECUTE     |\
                                                    TRANSACTIONMANAGER_BIND_TRANSACTION)


//
// KTM transaction object rights.
//
#define TRANSACTION_QUERY_INFORMATION     ( 0x0001 )
#define TRANSACTION_SET_INFORMATION       ( 0x0002 )
#define TRANSACTION_ENLIST                ( 0x0004 )
#define TRANSACTION_COMMIT                ( 0x0008 )
#define TRANSACTION_ROLLBACK              ( 0x0010 )
#define TRANSACTION_PROPAGATE             ( 0x0020 )
#define TRANSACTION_RIGHT_RESERVED1       ( 0x0040 )

//
// Generic mappings for transaction rights.
// Resource managers, when enlisting, should generally use the macro
// TRANSACTION_RESOURCE_MANAGER_RIGHTS when opening a transaction.
// It's the same as generic read and write except that it does not allow
// a commit decision to be made.
//

#define TRANSACTION_GENERIC_READ            (STANDARD_RIGHTS_READ            |\
                                             TRANSACTION_QUERY_INFORMATION   |\
                                             SYNCHRONIZE)

#define TRANSACTION_GENERIC_WRITE           (STANDARD_RIGHTS_WRITE           |\
                                             TRANSACTION_SET_INFORMATION     |\
                                             TRANSACTION_COMMIT              |\
                                             TRANSACTION_ENLIST              |\
                                             TRANSACTION_ROLLBACK            |\
                                             TRANSACTION_PROPAGATE           |\
                                             SYNCHRONIZE)

#define TRANSACTION_GENERIC_EXECUTE         (STANDARD_RIGHTS_EXECUTE         |\
                                             TRANSACTION_COMMIT              |\
                                             TRANSACTION_ROLLBACK            |\
                                             SYNCHRONIZE)

#define TRANSACTION_ALL_ACCESS              (STANDARD_RIGHTS_REQUIRED        |\
                                             TRANSACTION_GENERIC_READ        |\
                                             TRANSACTION_GENERIC_WRITE       |\
                                             TRANSACTION_GENERIC_EXECUTE)

#define TRANSACTION_RESOURCE_MANAGER_RIGHTS (TRANSACTION_GENERIC_READ        |\
                                             STANDARD_RIGHTS_WRITE           |\
                                             TRANSACTION_SET_INFORMATION     |\
                                             TRANSACTION_ENLIST              |\
                                             TRANSACTION_ROLLBACK            |\
                                             TRANSACTION_PROPAGATE           |\
                                             SYNCHRONIZE)

//
// KTM resource manager object rights.
//
#define RESOURCEMANAGER_QUERY_INFORMATION     ( 0x0001 )
#define RESOURCEMANAGER_SET_INFORMATION       ( 0x0002 )
#define RESOURCEMANAGER_RECOVER               ( 0x0004 )
#define RESOURCEMANAGER_ENLIST                ( 0x0008 )
#define RESOURCEMANAGER_GET_NOTIFICATION      ( 0x0010 )
#define RESOURCEMANAGER_REGISTER_PROTOCOL     ( 0x0020 )
#define RESOURCEMANAGER_COMPLETE_PROPAGATION  ( 0x0040 )

//
// Generic mappings for resource manager rights.
//
#define RESOURCEMANAGER_GENERIC_READ        (STANDARD_RIGHTS_READ                 |\
                                             RESOURCEMANAGER_QUERY_INFORMATION    |\
                                             SYNCHRONIZE)

#define RESOURCEMANAGER_GENERIC_WRITE       (STANDARD_RIGHTS_WRITE                |\
                                             RESOURCEMANAGER_SET_INFORMATION      |\
                                             RESOURCEMANAGER_RECOVER              |\
                                             RESOURCEMANAGER_ENLIST               |\
                                             RESOURCEMANAGER_GET_NOTIFICATION     |\
                                             RESOURCEMANAGER_REGISTER_PROTOCOL    |\
                                             RESOURCEMANAGER_COMPLETE_PROPAGATION |\
                                             SYNCHRONIZE)

#define RESOURCEMANAGER_GENERIC_EXECUTE     (STANDARD_RIGHTS_EXECUTE              |\
                                             RESOURCEMANAGER_RECOVER              |\
                                             RESOURCEMANAGER_ENLIST               |\
                                             RESOURCEMANAGER_GET_NOTIFICATION     |\
                                             RESOURCEMANAGER_COMPLETE_PROPAGATION |\
                                             SYNCHRONIZE)

#define RESOURCEMANAGER_ALL_ACCESS          (STANDARD_RIGHTS_REQUIRED             |\
                                             RESOURCEMANAGER_GENERIC_READ         |\
                                             RESOURCEMANAGER_GENERIC_WRITE        |\
                                             RESOURCEMANAGER_GENERIC_EXECUTE)


//
// KTM enlistment object rights.
//
#define ENLISTMENT_QUERY_INFORMATION     ( 0x0001 )
#define ENLISTMENT_SET_INFORMATION       ( 0x0002 )
#define ENLISTMENT_RECOVER               ( 0x0004 )
#define ENLISTMENT_SUBORDINATE_RIGHTS    ( 0x0008 )
#define ENLISTMENT_SUPERIOR_RIGHTS       ( 0x0010 )

//
// Generic mappings for enlistment rights.
//
#define ENLISTMENT_GENERIC_READ        (STANDARD_RIGHTS_READ           |\
                                        ENLISTMENT_QUERY_INFORMATION)

#define ENLISTMENT_GENERIC_WRITE       (STANDARD_RIGHTS_WRITE          |\
                                        ENLISTMENT_SET_INFORMATION     |\
                                        ENLISTMENT_RECOVER             |\
                                        ENLISTMENT_SUBORDINATE_RIGHTS  |\
                                        ENLISTMENT_SUPERIOR_RIGHTS)

#define ENLISTMENT_GENERIC_EXECUTE     (STANDARD_RIGHTS_EXECUTE        |\
                                        ENLISTMENT_RECOVER             |\
                                        ENLISTMENT_SUBORDINATE_RIGHTS  |\
                                        ENLISTMENT_SUPERIOR_RIGHTS)

#define ENLISTMENT_ALL_ACCESS          (STANDARD_RIGHTS_REQUIRED       |\
                                        ENLISTMENT_GENERIC_READ        |\
                                        ENLISTMENT_GENERIC_WRITE       |\
                                        ENLISTMENT_GENERIC_EXECUTE)


//
// Transaction outcomes.
//
// TODO: warning, must match values in KTRANSACTION_OUTCOME duplicated def 
// in tm.h.
//

typedef enum _TRANSACTION_OUTCOME {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted,
    TransactionOutcomeAborted,
} TRANSACTION_OUTCOME;


typedef enum _TRANSACTION_STATE {
    TransactionStateNormal = 1,
    TransactionStateIndoubt,
    TransactionStateCommittedNotify,
} TRANSACTION_STATE;


typedef struct _TRANSACTION_BASIC_INFORMATION {
    GUID    TransactionId;
    DWORD   State;
    DWORD   Outcome;
} TRANSACTION_BASIC_INFORMATION, *PTRANSACTION_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    GUID    TmIdentity;
    LARGE_INTEGER VirtualClock;
} TRANSACTIONMANAGER_BASIC_INFORMATION, *PTRANSACTIONMANAGER_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    GUID  LogIdentity;
} TRANSACTIONMANAGER_LOG_INFORMATION, *PTRANSACTIONMANAGER_LOG_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    DWORD LogPathLength;
    __field_ecount(LogPathLength) WCHAR LogPath[1]; // Variable size
//  Data[1];                                        // Variable size data not declared
} TRANSACTIONMANAGER_LOGPATH_INFORMATION, *PTRANSACTIONMANAGER_LOGPATH_INFORMATION;

typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    ULONGLONG  LastRecoveredLsn;
} TRANSACTIONMANAGER_RECOVERY_INFORMATION, *PTRANSACTIONMANAGER_RECOVERY_INFORMATION;


// end_wdm
typedef struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
    GUID OldestTransactionGuid;
} TRANSACTIONMANAGER_OLDEST_INFORMATION, *PTRANSACTIONMANAGER_OLDEST_INFORMATION;
// begin_wdm


typedef struct _TRANSACTION_PROPERTIES_INFORMATION {
    DWORD              IsolationLevel;
    DWORD              IsolationFlags;
    LARGE_INTEGER      Timeout;
    DWORD              Outcome;
    DWORD              DescriptionLength;
    WCHAR              Description[1];            // Variable size
//          Data[1];            // Variable size data not declared
} TRANSACTION_PROPERTIES_INFORMATION, *PTRANSACTION_PROPERTIES_INFORMATION;

// The following info-class is intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
typedef struct _TRANSACTION_BIND_INFORMATION {
    HANDLE TmHandle;
} TRANSACTION_BIND_INFORMATION, *PTRANSACTION_BIND_INFORMATION;

typedef struct _TRANSACTION_ENLISTMENT_PAIR {
    GUID   EnlistmentId;
    GUID   ResourceManagerId;
} TRANSACTION_ENLISTMENT_PAIR, *PTRANSACTION_ENLISTMENT_PAIR;

typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    DWORD                       NumberOfEnlistments;
    TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1]; // Variable size
} TRANSACTION_ENLISTMENTS_INFORMATION, *PTRANSACTION_ENLISTMENTS_INFORMATION;

typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
} TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION, *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;


typedef struct _RESOURCEMANAGER_BASIC_INFORMATION {
    GUID    ResourceManagerId;
    DWORD   DescriptionLength;
    WCHAR   Description[1];            // Variable size
} RESOURCEMANAGER_BASIC_INFORMATION, *PRESOURCEMANAGER_BASIC_INFORMATION;

typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    HANDLE    IoCompletionPortHandle;
    ULONG_PTR CompletionKey;
} RESOURCEMANAGER_COMPLETION_INFORMATION, *PRESOURCEMANAGER_COMPLETION_INFORMATION;

// end_wdm

// begin_wdm
typedef enum _TRANSACTION_INFORMATION_CLASS {
    TransactionBasicInformation,
    TransactionPropertiesInformation,
    TransactionEnlistmentInformation,
    TransactionSuperiorEnlistmentInformation
// end_wdm
    ,
// The following info-classes are intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
    TransactionBindInformation, // private and deprecated
    TransactionDTCPrivateInformation // private and deprecated
    ,
// begin_wdm
} TRANSACTION_INFORMATION_CLASS;

// begin_wdm
typedef enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
    TransactionManagerBasicInformation,
    TransactionManagerLogInformation,
    TransactionManagerLogPathInformation,
    TransactionManagerRecoveryInformation = 4
// end_wdm
    ,
// The following info-classes are intended for internal use only; they
// are considered deprecated, and no one else should take a dependency
// on them.
    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5
// end_wdm

// begin_wdm
} TRANSACTIONMANAGER_INFORMATION_CLASS;


// begin_wdm
typedef enum _RESOURCEMANAGER_INFORMATION_CLASS {
    ResourceManagerBasicInformation,
    ResourceManagerCompletionInformation,
} RESOURCEMANAGER_INFORMATION_CLASS;


typedef struct _ENLISTMENT_BASIC_INFORMATION {
    GUID    EnlistmentId;
    GUID    TransactionId;
    GUID    ResourceManagerId;
} ENLISTMENT_BASIC_INFORMATION, *PENLISTMENT_BASIC_INFORMATION;

typedef struct _ENLISTMENT_CRM_INFORMATION {
    GUID   CrmTransactionManagerId;
    GUID   CrmResourceManagerId;
    GUID   CrmEnlistmentId;
} ENLISTMENT_CRM_INFORMATION, *PENLISTMENT_CRM_INFORMATION;


// begin_wdm
typedef enum _ENLISTMENT_INFORMATION_CLASS {
    EnlistmentBasicInformation,
    EnlistmentRecoveryInformation,
    EnlistmentCrmInformation
} ENLISTMENT_INFORMATION_CLASS;

typedef struct _TRANSACTION_LIST_ENTRY {
    UOW    UOW;
} TRANSACTION_LIST_ENTRY, *PTRANSACTION_LIST_ENTRY;

typedef struct _TRANSACTION_LIST_INFORMATION {
    DWORD   NumberOfTransactions;
    TRANSACTION_LIST_ENTRY TransactionInformation[1]; // Var size
} TRANSACTION_LIST_INFORMATION, *PTRANSACTION_LIST_INFORMATION;


//
// Types of objects known to the kernel transaction manager.
//

typedef enum _KTMOBJECT_TYPE {

    KTMOBJECT_TRANSACTION,
    KTMOBJECT_TRANSACTION_MANAGER,
    KTMOBJECT_RESOURCE_MANAGER,
    KTMOBJECT_ENLISTMENT,
    KTMOBJECT_INVALID

} KTMOBJECT_TYPE, *PKTMOBJECT_TYPE;


//
// KTMOBJECT_CURSOR
//
// Used by NtEnumerateTransactionObject to enumerate a transaction
// object namespace (e.g. enlistments in a resource manager).
//

typedef struct _KTMOBJECT_CURSOR {

    //
    // The last GUID enumerated; zero if beginning enumeration.
    // 

    GUID    LastQuery;

    //
    // A count of GUIDs filled in by this last enumeration.
    // 

    DWORD   ObjectIdCount;

    //
    // ObjectIdCount GUIDs from the namespace specified.
    // 

    GUID    ObjectIds[1];

} KTMOBJECT_CURSOR, *PKTMOBJECT_CURSOR;

// begin_wdm

#ifdef __cplusplus
}
#endif

#endif // _NTTMAPI_
typedef DWORD TP_VERSION, *PTP_VERSION; 

typedef struct _TP_CALLBACK_INSTANCE TP_CALLBACK_INSTANCE, *PTP_CALLBACK_INSTANCE;

typedef VOID (NTAPI *PTP_SIMPLE_CALLBACK)(
    __inout     PTP_CALLBACK_INSTANCE Instance,
    __inout_opt PVOID                 Context
    );

typedef struct _TP_POOL TP_POOL, *PTP_POOL; 

typedef enum _TP_CALLBACK_PRIORITY {
    TP_CALLBACK_PRIORITY_HIGH,
    TP_CALLBACK_PRIORITY_NORMAL,
    TP_CALLBACK_PRIORITY_LOW,
    TP_CALLBACK_PRIORITY_INVALID
} TP_CALLBACK_PRIORITY;

typedef struct _TP_POOL_STACK_INFORMATION {
    SIZE_T StackReserve;
    SIZE_T StackCommit;
}TP_POOL_STACK_INFORMATION, *PTP_POOL_STACK_INFORMATION;

typedef struct _TP_CLEANUP_GROUP TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP; 

typedef VOID (NTAPI *PTP_CLEANUP_GROUP_CANCEL_CALLBACK)(
    __inout_opt PVOID ObjectContext,
    __inout_opt PVOID CleanupContext
    );

//
// Do not manipulate this structure directly!  Allocate space for it
// and use the inline interfaces below.
//

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

typedef struct _TP_CALLBACK_ENVIRON_V3 {
    TP_VERSION                         Version;
    PTP_POOL                           Pool;
    PTP_CLEANUP_GROUP                  CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK  CleanupGroupCancelCallback;
    PVOID                              RaceDll;
    struct _ACTIVATION_CONTEXT        *ActivationContext;
    PTP_SIMPLE_CALLBACK                FinalizationCallback;
    union {
        DWORD                          Flags;
        struct {
            DWORD                      LongFunction :  1;
            DWORD                      Persistent   :  1;
            DWORD                      Private      : 30;
        } s;
    } u;    
    TP_CALLBACK_PRIORITY               CallbackPriority;
    DWORD                              Size;
} TP_CALLBACK_ENVIRON_V3;

typedef TP_CALLBACK_ENVIRON_V3 TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;

#else

typedef struct _TP_CALLBACK_ENVIRON_V1 {
    TP_VERSION                         Version;
    PTP_POOL                           Pool;
    PTP_CLEANUP_GROUP                  CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK  CleanupGroupCancelCallback;
    PVOID                              RaceDll;
    struct _ACTIVATION_CONTEXT        *ActivationContext;
    PTP_SIMPLE_CALLBACK                FinalizationCallback;
    union {
        DWORD                          Flags;
        struct {
            DWORD                      LongFunction :  1;
            DWORD                      Persistent   :  1;
            DWORD                      Private      : 30;
        } s;
    } u;    
} TP_CALLBACK_ENVIRON_V1;

typedef TP_CALLBACK_ENVIRON_V1 TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;

#endif

#if !defined(MIDL_PASS)

FORCEINLINE
VOID
TpInitializeCallbackEnviron(
    __out PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

    CallbackEnviron->Version = 3;

#else

    CallbackEnviron->Version = 1;

#endif

    CallbackEnviron->Pool = NULL;
    CallbackEnviron->CleanupGroup = NULL;
    CallbackEnviron->CleanupGroupCancelCallback = NULL;
    CallbackEnviron->RaceDll = NULL;
    CallbackEnviron->ActivationContext = NULL;
    CallbackEnviron->FinalizationCallback = NULL;
    CallbackEnviron->u.Flags = 0;

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

    CallbackEnviron->CallbackPriority = TP_CALLBACK_PRIORITY_NORMAL;
    CallbackEnviron->Size = sizeof(TP_CALLBACK_ENVIRON);

#endif

}

FORCEINLINE
VOID
TpSetCallbackThreadpool(
    __inout PTP_CALLBACK_ENVIRON CallbackEnviron,
    __in    PTP_POOL             Pool
    )
{
    CallbackEnviron->Pool = Pool;
}

FORCEINLINE
VOID
TpSetCallbackCleanupGroup(
    __inout  PTP_CALLBACK_ENVIRON              CallbackEnviron,
    __in     PTP_CLEANUP_GROUP                 CleanupGroup,
    __in_opt PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback
    )
{
    CallbackEnviron->CleanupGroup = CleanupGroup;
    CallbackEnviron->CleanupGroupCancelCallback = CleanupGroupCancelCallback;
}

FORCEINLINE
VOID
TpSetCallbackActivationContext(
    __inout  PTP_CALLBACK_ENVIRON CallbackEnviron,
    __in_opt struct _ACTIVATION_CONTEXT *ActivationContext
    )
{
    CallbackEnviron->ActivationContext = ActivationContext;
}

FORCEINLINE
VOID
TpSetCallbackNoActivationContext(
    __inout PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->ActivationContext = (struct _ACTIVATION_CONTEXT *)(LONG_PTR) -1; // INVALID_ACTIVATION_CONTEXT
}

FORCEINLINE
VOID
TpSetCallbackLongFunction(
    __inout PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.LongFunction = 1;
}

FORCEINLINE
VOID
TpSetCallbackRaceWithDll(
    __inout PTP_CALLBACK_ENVIRON CallbackEnviron,
    __in    PVOID                DllHandle
    )
{
    CallbackEnviron->RaceDll = DllHandle;
}

FORCEINLINE
VOID
TpSetCallbackFinalizationCallback(
    __inout PTP_CALLBACK_ENVIRON CallbackEnviron,
    __in    PTP_SIMPLE_CALLBACK  FinalizationCallback
    )
{
    CallbackEnviron->FinalizationCallback = FinalizationCallback;
}

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

FORCEINLINE
VOID
TpSetCallbackPriority(
    __inout PTP_CALLBACK_ENVIRON CallbackEnviron,
    __in    TP_CALLBACK_PRIORITY Priority
    )
{
    CallbackEnviron->CallbackPriority = Priority;
}

#endif

FORCEINLINE
VOID
TpSetCallbackPersistent(
    __inout PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.Persistent = 1;
}


FORCEINLINE
VOID
TpDestroyCallbackEnviron(
    __in PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    //
    // For the current version of the callback environment, no actions
    // need to be taken to tear down an initialized structure.  This
    // may change in a future release.
    //

    UNREFERENCED_PARAMETER(CallbackEnviron);
}

#endif // !defined(MIDL_PASS)


typedef struct _TP_WORK TP_WORK, *PTP_WORK;

typedef VOID (NTAPI *PTP_WORK_CALLBACK)(
    __inout     PTP_CALLBACK_INSTANCE Instance,
    __inout_opt PVOID                 Context,
    __inout     PTP_WORK              Work
    );

typedef struct _TP_TIMER TP_TIMER, *PTP_TIMER;

typedef VOID (NTAPI *PTP_TIMER_CALLBACK)(
    __inout     PTP_CALLBACK_INSTANCE Instance,
    __inout_opt PVOID                 Context,
    __inout     PTP_TIMER             Timer
    );

typedef DWORD    TP_WAIT_RESULT;

typedef struct _TP_WAIT TP_WAIT, *PTP_WAIT;

typedef VOID (NTAPI *PTP_WAIT_CALLBACK)(
    __inout     PTP_CALLBACK_INSTANCE Instance,
    __inout_opt PVOID                 Context,
    __inout     PTP_WAIT              Wait,
    __in        TP_WAIT_RESULT        WaitResult
    );

typedef struct _TP_IO TP_IO, *PTP_IO;

#if defined(_M_AMD64) && !defined(__midl)

__forceinline
struct _TEB *
NtCurrentTeb (
    VOID
    )

{
    return (struct _TEB *)__readgsqword(FIELD_OFFSET(NT_TIB, Self));
}

__forceinline
PVOID
GetCurrentFiber (
    VOID
    )

{

    return (PVOID)__readgsqword(FIELD_OFFSET(NT_TIB, FiberData));
}

__forceinline
PVOID
GetFiberData (
    VOID
    )

{

    return *(PVOID *)GetCurrentFiber();
}

#endif // _M_AMD64 && !defined(__midl)


#if defined(_M_IX86) && !defined(MIDL_PASS)

#define PcTeb 0x18

#if (_MSC_FULL_VER >= 13012035)

__inline struct _TEB * NtCurrentTeb( void ) { return (struct _TEB *) (ULONG_PTR) __readfsdword (PcTeb); }

#else

#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning (disable:4035)        // disable 4035 (function must return something)

__inline struct _TEB * NtCurrentTeb( void ) { __asm mov eax, fs:[PcTeb] }

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning (default:4035)        // reenable it
#endif

#endif

#endif // defined(_M_IX86) && !defined(MIDL_PASS)

#if (_WIN32_WINNT > 0x0500) || (_WIN32_FUSION >= 0x0100) || ISOLATION_AWARE_ENABLED // winnt_only
#define ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION         (1)
#define ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION              (2)
#define ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION     (3)
#define ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION       (4)
#define ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION    (5)
#define ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION (6)
#define ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION       (7)
#define ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE   (8)
#define ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES               (9)
#define ACTIVATION_CONTEXT_SECTION_APPLICATION_SETTINGS         (10)
#define ACTIVATION_CONTEXT_SECTION_COMPATIBILITY_INFO           (11)
#endif // winnt_only

#ifdef __cplusplus
}
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#pragma warning(default:4214)
#endif

#endif /* _WINNT_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WinReg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    Winreg.h

Abstract:

    This module contains the function prototypes and constant, type and
    structure definitions for the Windows 32-Bit Registry API.

--*/

#ifndef _WINREG_
#define _WINREG_


#ifdef _MAC
#include <macwin32.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WINVER
#define WINVER 0x0500   // version 5.0
#endif /* !WINVER */

//
// RRF - Registry Routine Flags (for RegGetValue)
//

#define RRF_RT_REG_NONE        0x00000001  // restrict type to REG_NONE      (other data types will not return ERROR_SUCCESS)
#define RRF_RT_REG_SZ          0x00000002  // restrict type to REG_SZ        (other data types will not return ERROR_SUCCESS) (automatically converts REG_EXPAND_SZ to REG_SZ unless RRF_NOEXPAND is specified)
#define RRF_RT_REG_EXPAND_SZ   0x00000004  // restrict type to REG_EXPAND_SZ (other data types will not return ERROR_SUCCESS) (must specify RRF_NOEXPAND or RegGetValue will fail with ERROR_INVALID_PARAMETER)
#define RRF_RT_REG_BINARY      0x00000008  // restrict type to REG_BINARY    (other data types will not return ERROR_SUCCESS)
#define RRF_RT_REG_DWORD       0x00000010  // restrict type to REG_DWORD     (other data types will not return ERROR_SUCCESS)
#define RRF_RT_REG_MULTI_SZ    0x00000020  // restrict type to REG_MULTI_SZ  (other data types will not return ERROR_SUCCESS)
#define RRF_RT_REG_QWORD       0x00000040  // restrict type to REG_QWORD     (other data types will not return ERROR_SUCCESS)

#define RRF_RT_DWORD           (RRF_RT_REG_BINARY | RRF_RT_REG_DWORD) // restrict type to *32-bit* RRF_RT_REG_BINARY or RRF_RT_REG_DWORD (other data types will not return ERROR_SUCCESS)
#define RRF_RT_QWORD           (RRF_RT_REG_BINARY | RRF_RT_REG_QWORD) // restrict type to *64-bit* RRF_RT_REG_BINARY or RRF_RT_REG_DWORD (other data types will not return ERROR_SUCCESS)
#define RRF_RT_ANY             0x0000ffff                             // no type restriction

#define RRF_NOEXPAND           0x10000000  // do not automatically expand environment strings if value is of type REG_EXPAND_SZ
#define RRF_ZEROONFAILURE      0x20000000  // if pvData is not NULL, set content to all zeros on failure

//
// Flags for RegLoadAppKey
//
#define REG_PROCESS_APPKEY          0x00000001

//
// Flags for RegLoadMUIString
//
#define REG_MUI_STRING_TRUNCATE     0x00000001

//
// Requested Key access mask type.
//

typedef ACCESS_MASK REGSAM;

//
// Reserved Key Handles.
//

#define HKEY_CLASSES_ROOT                   (( HKEY ) (ULONG_PTR)((LONG)0x80000000) )
#define HKEY_CURRENT_USER                   (( HKEY ) (ULONG_PTR)((LONG)0x80000001) )
#define HKEY_LOCAL_MACHINE                  (( HKEY ) (ULONG_PTR)((LONG)0x80000002) )
#define HKEY_USERS                          (( HKEY ) (ULONG_PTR)((LONG)0x80000003) )
#define HKEY_PERFORMANCE_DATA               (( HKEY ) (ULONG_PTR)((LONG)0x80000004) )
#define HKEY_PERFORMANCE_TEXT               (( HKEY ) (ULONG_PTR)((LONG)0x80000050) )
#define HKEY_PERFORMANCE_NLSTEXT            (( HKEY ) (ULONG_PTR)((LONG)0x80000060) )
#if(WINVER >= 0x0400)
#define HKEY_CURRENT_CONFIG                 (( HKEY ) (ULONG_PTR)((LONG)0x80000005) )
#define HKEY_DYN_DATA                       (( HKEY ) (ULONG_PTR)((LONG)0x80000006) )
#define HKEY_CURRENT_USER_LOCAL_SETTINGS    (( HKEY ) (ULONG_PTR)((LONG)0x80000007) )


//
// RegConnectRegistryEx supported flags
//
#define REG_SECURE_CONNECTION   1

/*NOINC*/
#ifndef _PROVIDER_STRUCTS_DEFINED
#define _PROVIDER_STRUCTS_DEFINED

#define PROVIDER_KEEPS_VALUE_LENGTH 0x1
struct val_context {
    int valuelen;       // the total length of this value
    LPVOID value_context;   // provider's context
    LPVOID val_buff_ptr;    // where in the ouput buffer the value is.
};

typedef struct val_context FAR *PVALCONTEXT;

typedef struct pvalueA {           // Provider supplied value/context.
    LPSTR   pv_valuename;          // The value name pointer
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEA, FAR *PPVALUEA;
typedef struct pvalueW {           // Provider supplied value/context.
    LPWSTR  pv_valuename;          // The value name pointer
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEW, FAR *PPVALUEW;
#ifdef UNICODE
typedef PVALUEW PVALUE;
typedef PPVALUEW PPVALUE;
#else
typedef PVALUEA PVALUE;
typedef PPVALUEA PPVALUE;
#endif // UNICODE

typedef
DWORD __cdecl
QUERYHANDLER (LPVOID keycontext, PVALCONTEXT val_list, DWORD num_vals,
          LPVOID outputbuffer, DWORD FAR *total_outlen, DWORD input_blen);

typedef QUERYHANDLER FAR *PQUERYHANDLER;

typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;    // capability flags (none defined yet).
    LPVOID pi_key_context;
}REG_PROVIDER;

typedef struct provider_info FAR *PPROVIDER;

typedef struct value_entA {
    LPSTR   ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTA, FAR *PVALENTA;
typedef struct value_entW {
    LPWSTR  ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTW, FAR *PVALENTW;
#ifdef UNICODE
typedef VALENTW VALENT;
typedef PVALENTW PVALENT;
#else
typedef VALENTA VALENT;
typedef PVALENTA PVALENT;
#endif // UNICODE

#endif // not(_PROVIDER_STRUCTS_DEFINED)
/*INC*/

#endif /* WINVER >= 0x0400 */

//
// Default values for parameters that do not exist in the Win 3.1
// compatible APIs.
//

#define WIN31_CLASS                 NULL

//
// API Prototypes.
//

typedef __success(return==ERROR_SUCCESS) LONG LSTATUS;

WINADVAPI
LSTATUS
APIENTRY
RegCloseKey (
    __in HKEY hKey
    );

WINADVAPI
LSTATUS
APIENTRY
RegOverridePredefKey (
    __in HKEY hKey,
    __in_opt HKEY hNewHKey
    );

WINADVAPI
LSTATUS
APIENTRY
RegOpenUserClassesRoot(
    __in HANDLE hToken,
    __reserved DWORD dwOptions,
    __in REGSAM samDesired,
    __out PHKEY  phkResult
    );

WINADVAPI
LSTATUS
APIENTRY
RegOpenCurrentUser(
    __in REGSAM samDesired,
    __out PHKEY phkResult
    );

WINADVAPI
LSTATUS
APIENTRY
RegDisablePredefinedCache(
    VOID
    );

WINADVAPI
LSTATUS
APIENTRY
RegDisablePredefinedCacheEx(
    VOID
    );

WINADVAPI
LSTATUS
APIENTRY
RegConnectRegistryA (
    __in_opt LPCSTR lpMachineName,
    __in HKEY hKey,
    __out PHKEY phkResult
    );
WINADVAPI
LSTATUS
APIENTRY
RegConnectRegistryW (
    __in_opt LPCWSTR lpMachineName,
    __in HKEY hKey,
    __out PHKEY phkResult
    );
#ifdef UNICODE
#define RegConnectRegistry  RegConnectRegistryW
#else
#define RegConnectRegistry  RegConnectRegistryA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegConnectRegistryExA (
    __in_opt LPCSTR lpMachineName,
    __in HKEY hKey,
    __in ULONG Flags,
    __out PHKEY phkResult
    );
WINADVAPI
LSTATUS
APIENTRY
RegConnectRegistryExW (
    __in_opt LPCWSTR lpMachineName,
    __in HKEY hKey,
    __in ULONG Flags,
    __out PHKEY phkResult
    );
#ifdef UNICODE
#define RegConnectRegistryEx  RegConnectRegistryExW
#else
#define RegConnectRegistryEx  RegConnectRegistryExA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegCreateKeyA (
    __in HKEY hKey,
    __in_opt LPCSTR lpSubKey,
    __out PHKEY phkResult
    );
WINADVAPI
LSTATUS
APIENTRY
RegCreateKeyW (
    __in HKEY hKey,
    __in_opt LPCWSTR lpSubKey,
    __out PHKEY phkResult
    );
#ifdef UNICODE
#define RegCreateKey  RegCreateKeyW
#else
#define RegCreateKey  RegCreateKeyA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegCreateKeyExA (
    __in HKEY hKey,
    __in LPCSTR lpSubKey,
    __reserved DWORD Reserved,
    __in_opt LPSTR lpClass,
    __in DWORD dwOptions,
    __in REGSAM samDesired,
    __in_opt CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __out PHKEY phkResult,
    __out_opt LPDWORD lpdwDisposition
    );
WINADVAPI
LSTATUS
APIENTRY
RegCreateKeyExW (
    __in HKEY hKey,
    __in LPCWSTR lpSubKey,
    __reserved DWORD Reserved,
    __in_opt LPWSTR lpClass,
    __in DWORD dwOptions,
    __in REGSAM samDesired,
    __in_opt CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __out PHKEY phkResult,
    __out_opt LPDWORD lpdwDisposition
    );
#ifdef UNICODE
#define RegCreateKeyEx  RegCreateKeyExW
#else
#define RegCreateKeyEx  RegCreateKeyExA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegCreateKeyTransactedA (
    __in HKEY hKey,
    __in LPCSTR lpSubKey,
    __reserved DWORD Reserved,
    __in_opt LPSTR lpClass,
    __in DWORD dwOptions,
    __in REGSAM samDesired,
    __in_opt CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __out PHKEY phkResult,
    __out_opt LPDWORD lpdwDisposition,
    __in        HANDLE hTransaction,
    __reserved PVOID  pExtendedParemeter
    );
WINADVAPI
LSTATUS
APIENTRY
RegCreateKeyTransactedW (
    __in HKEY hKey,
    __in LPCWSTR lpSubKey,
    __reserved DWORD Reserved,
    __in_opt LPWSTR lpClass,
    __in DWORD dwOptions,
    __in REGSAM samDesired,
    __in_opt CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __out PHKEY phkResult,
    __out_opt LPDWORD lpdwDisposition,
    __in        HANDLE hTransaction,
    __reserved PVOID  pExtendedParemeter
    );
#ifdef UNICODE
#define RegCreateKeyTransacted  RegCreateKeyTransactedW
#else
#define RegCreateKeyTransacted  RegCreateKeyTransactedA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegDeleteKeyA (
    __in HKEY hKey,
    __in LPCSTR lpSubKey
    );
WINADVAPI
LSTATUS
APIENTRY
RegDeleteKeyW (
    __in HKEY hKey,
    __in LPCWSTR lpSubKey
    );
#ifdef UNICODE
#define RegDeleteKey  RegDeleteKeyW
#else
#define RegDeleteKey  RegDeleteKeyA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegDeleteKeyExA (
    __in HKEY hKey,
    __in LPCSTR lpSubKey,
    __in REGSAM samDesired,
    __reserved DWORD Reserved
    );
WINADVAPI
LSTATUS
APIENTRY
RegDeleteKeyExW (
    __in HKEY hKey,
    __in LPCWSTR lpSubKey,
    __in REGSAM samDesired,
    __reserved DWORD Reserved
    );
#ifdef UNICODE
#define RegDeleteKeyEx  RegDeleteKeyExW
#else
#define RegDeleteKeyEx  RegDeleteKeyExA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegDeleteKeyTransactedA (
    __in HKEY hKey,
    __in LPCSTR lpSubKey,
    __in REGSAM samDesired,
    __reserved DWORD Reserved,
    __in        HANDLE hTransaction,
    __reserved PVOID  pExtendedParameter
    );
WINADVAPI
LSTATUS
APIENTRY
RegDeleteKeyTransactedW (
    __in HKEY hKey,
    __in LPCWSTR lpSubKey,
    __in REGSAM samDesired,
    __reserved DWORD Reserved,
    __in        HANDLE hTransaction,
    __reserved PVOID  pExtendedParameter
    );
#ifdef UNICODE
#define RegDeleteKeyTransacted  RegDeleteKeyTransactedW
#else
#define RegDeleteKeyTransacted  RegDeleteKeyTransactedA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegDisableReflectionKey (
    __in HKEY hBase
    );    

WINADVAPI
LONG
APIENTRY
RegEnableReflectionKey (
    __in HKEY hBase
    );    

WINADVAPI
LONG
APIENTRY
RegQueryReflectionKey (
    __in HKEY hBase,
    __out BOOL *bIsReflectionDisabled
    );    
    
WINADVAPI
LSTATUS
APIENTRY
RegDeleteValueA (
    __in HKEY hKey,
    __in_opt LPCSTR lpValueName
    );
WINADVAPI
LSTATUS
APIENTRY
RegDeleteValueW (
    __in HKEY hKey,
    __in_opt LPCWSTR lpValueName
    );
#ifdef UNICODE
#define RegDeleteValue  RegDeleteValueW
#else
#define RegDeleteValue  RegDeleteValueA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegEnumKeyA (
    __in HKEY hKey,
    __in DWORD dwIndex,
    __out_ecount_part_opt(cchName,cchName + 1) LPSTR lpName,
    __in DWORD cchName
    );
WINADVAPI
LSTATUS
APIENTRY
RegEnumKeyW (
    __in HKEY hKey,
    __in DWORD dwIndex,
    __out_ecount_part_opt(cchName,cchName + 1) LPWSTR lpName,
    __in DWORD cchName
    );
#ifdef UNICODE
#define RegEnumKey  RegEnumKeyW
#else
#define RegEnumKey  RegEnumKeyA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegEnumKeyExA (
    __in HKEY hKey,
    __in DWORD dwIndex,
    __out_ecount_part_opt(*lpcchName, *lpcchName + 1) LPSTR lpName,
    __inout LPDWORD lpcchName,
    __reserved LPDWORD lpReserved,
    __out_ecount_part_opt(*lpcchClass,*lpcchClass + 1) LPSTR lpClass,
    __inout_opt LPDWORD lpcchClass,
    __out_opt PFILETIME lpftLastWriteTime
    );
WINADVAPI
LSTATUS
APIENTRY
RegEnumKeyExW (
    __in HKEY hKey,
    __in DWORD dwIndex,
    __out_ecount_part_opt(*lpcchName, *lpcchName + 1) LPWSTR lpName,
    __inout LPDWORD lpcchName,
    __reserved LPDWORD lpReserved,
    __out_ecount_part_opt(*lpcchClass,*lpcchClass + 1) LPWSTR lpClass,
    __inout_opt LPDWORD lpcchClass,
    __out_opt PFILETIME lpftLastWriteTime
    );
#ifdef UNICODE
#define RegEnumKeyEx  RegEnumKeyExW
#else
#define RegEnumKeyEx  RegEnumKeyExA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegEnumValueA (
    __in HKEY hKey,
    __in DWORD dwIndex,
    __out_ecount_part_opt(*lpcchValueName, *lpcchValueName + 1) LPSTR lpValueName,
    __inout LPDWORD lpcchValueName,
    __reserved LPDWORD lpReserved,
    __out_opt LPDWORD lpType,
    __out_bcount_part_opt(*lpcbData, *lpcbData) __out_data_source(REGISTRY) LPBYTE lpData,
    __inout_opt LPDWORD lpcbData
    );
WINADVAPI
LSTATUS
APIENTRY
RegEnumValueW (
    __in HKEY hKey,
    __in DWORD dwIndex,
    __out_ecount_part_opt(*lpcchValueName, *lpcchValueName + 1) LPWSTR lpValueName,
    __inout LPDWORD lpcchValueName,
    __reserved LPDWORD lpReserved,
    __out_opt LPDWORD lpType,
    __out_bcount_part_opt(*lpcbData, *lpcbData) __out_data_source(REGISTRY) LPBYTE lpData,
    __inout_opt LPDWORD lpcbData
    );
#ifdef UNICODE
#define RegEnumValue  RegEnumValueW
#else
#define RegEnumValue  RegEnumValueA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegFlushKey (
    __in HKEY hKey
    );

WINADVAPI
LSTATUS
APIENTRY
RegGetKeySecurity (
    __in HKEY hKey,
    __in SECURITY_INFORMATION SecurityInformation,
    __out_bcount_opt(*lpcbSecurityDescriptor) PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __inout LPDWORD lpcbSecurityDescriptor
    );

WINADVAPI
LSTATUS
APIENTRY
RegLoadKeyA (
    __in HKEY    hKey,
    __in_opt LPCSTR  lpSubKey,
    __in LPCSTR  lpFile
    );
WINADVAPI
LSTATUS
APIENTRY
RegLoadKeyW (
    __in HKEY    hKey,
    __in_opt LPCWSTR  lpSubKey,
    __in LPCWSTR  lpFile
    );
#ifdef UNICODE
#define RegLoadKey  RegLoadKeyW
#else
#define RegLoadKey  RegLoadKeyA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegNotifyChangeKeyValue (
    __in HKEY hKey,
    __in BOOL bWatchSubtree,
    __in DWORD dwNotifyFilter,
    __in_opt HANDLE hEvent,
    __in BOOL fAsynchronous
    );

WINADVAPI
LSTATUS
APIENTRY
RegOpenKeyA (
    __in HKEY hKey,
    __in_opt LPCSTR lpSubKey,
    __out PHKEY phkResult
    );
WINADVAPI
LSTATUS
APIENTRY
RegOpenKeyW (
    __in HKEY hKey,
    __in_opt LPCWSTR lpSubKey,
    __out PHKEY phkResult
    );
#ifdef UNICODE
#define RegOpenKey  RegOpenKeyW
#else
#define RegOpenKey  RegOpenKeyA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegOpenKeyExA (
    __in HKEY hKey,
    __in_opt LPCSTR lpSubKey,
    __in_opt DWORD ulOptions,
    __in REGSAM samDesired,
    __out PHKEY phkResult
    );
WINADVAPI
LSTATUS
APIENTRY
RegOpenKeyExW (
    __in HKEY hKey,
    __in_opt LPCWSTR lpSubKey,
    __in_opt DWORD ulOptions,
    __in REGSAM samDesired,
    __out PHKEY phkResult
    );
#ifdef UNICODE
#define RegOpenKeyEx  RegOpenKeyExW
#else
#define RegOpenKeyEx  RegOpenKeyExA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegOpenKeyTransactedA (
    __in HKEY hKey,
    __in_opt LPCSTR lpSubKey,
    __in_opt DWORD ulOptions,
    __in REGSAM samDesired,
    __out PHKEY phkResult,
    __in        HANDLE hTransaction,
    __reserved PVOID  pExtendedParemeter
    );
WINADVAPI
LSTATUS
APIENTRY
RegOpenKeyTransactedW (
    __in HKEY hKey,
    __in_opt LPCWSTR lpSubKey,
    __in_opt DWORD ulOptions,
    __in REGSAM samDesired,
    __out PHKEY phkResult,
    __in        HANDLE hTransaction,
    __reserved PVOID  pExtendedParemeter
    );
#ifdef UNICODE
#define RegOpenKeyTransacted  RegOpenKeyTransactedW
#else
#define RegOpenKeyTransacted  RegOpenKeyTransactedA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegQueryInfoKeyA (
    __in HKEY hKey,
    __out_ecount_part_opt(*lpcchClass, *lpcchClass + 1) LPSTR lpClass,
    __inout_opt LPDWORD lpcchClass,
    __reserved LPDWORD lpReserved,
    __out_opt LPDWORD lpcSubKeys,
    __out_opt LPDWORD lpcbMaxSubKeyLen,
    __out_opt LPDWORD lpcbMaxClassLen,
    __out_opt LPDWORD lpcValues,
    __out_opt LPDWORD lpcbMaxValueNameLen,
    __out_opt LPDWORD lpcbMaxValueLen,
    __out_opt LPDWORD lpcbSecurityDescriptor,
    __out_opt PFILETIME lpftLastWriteTime
    );
WINADVAPI
LSTATUS
APIENTRY
RegQueryInfoKeyW (
    __in HKEY hKey,
    __out_ecount_part_opt(*lpcchClass, *lpcchClass + 1) LPWSTR lpClass,
    __inout_opt LPDWORD lpcchClass,
    __reserved LPDWORD lpReserved,
    __out_opt LPDWORD lpcSubKeys,
    __out_opt LPDWORD lpcbMaxSubKeyLen,
    __out_opt LPDWORD lpcbMaxClassLen,
    __out_opt LPDWORD lpcValues,
    __out_opt LPDWORD lpcbMaxValueNameLen,
    __out_opt LPDWORD lpcbMaxValueLen,
    __out_opt LPDWORD lpcbSecurityDescriptor,
    __out_opt PFILETIME lpftLastWriteTime
    );
#ifdef UNICODE
#define RegQueryInfoKey  RegQueryInfoKeyW
#else
#define RegQueryInfoKey  RegQueryInfoKeyA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegQueryValueA (
    __in HKEY hKey,
    __in_opt LPCSTR lpSubKey,
    __out_bcount_part_opt(*lpcbData, *lpcbData) __out_data_source(REGISTRY) LPSTR lpData,
    __inout_opt PLONG lpcbData
    );
WINADVAPI
LSTATUS
APIENTRY
RegQueryValueW (
    __in HKEY hKey,
    __in_opt LPCWSTR lpSubKey,
    __out_bcount_part_opt(*lpcbData, *lpcbData) __out_data_source(REGISTRY) LPWSTR lpData,
    __inout_opt PLONG lpcbData
    );
#ifdef UNICODE
#define RegQueryValue  RegQueryValueW
#else
#define RegQueryValue  RegQueryValueA
#endif // !UNICODE

#if(WINVER >= 0x0400)

WINADVAPI
LSTATUS
APIENTRY
RegQueryMultipleValuesA (
    __in HKEY hKey,
    __out_ecount(num_vals) PVALENTA val_list,
    __in DWORD num_vals,
    __out_bcount_part_opt(*ldwTotsize, *ldwTotsize) __out_data_source(REGISTRY) LPSTR lpValueBuf,
    __inout_opt LPDWORD ldwTotsize
    );
WINADVAPI
LSTATUS
APIENTRY
RegQueryMultipleValuesW (
    __in HKEY hKey,
    __out_ecount(num_vals) PVALENTW val_list,
    __in DWORD num_vals,
    __out_bcount_part_opt(*ldwTotsize, *ldwTotsize) __out_data_source(REGISTRY) LPWSTR lpValueBuf,
    __inout_opt LPDWORD ldwTotsize
    );
#ifdef UNICODE
#define RegQueryMultipleValues  RegQueryMultipleValuesW
#else
#define RegQueryMultipleValues  RegQueryMultipleValuesA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

WINADVAPI
LSTATUS
APIENTRY
RegQueryValueExA (
    __in HKEY hKey,
    __in_opt LPCSTR lpValueName,
    __reserved LPDWORD lpReserved,
    __out_opt LPDWORD lpType,
    __out_bcount_part_opt(*lpcbData, *lpcbData) __out_data_source(REGISTRY) LPBYTE lpData,
    __inout_opt LPDWORD lpcbData
    );
WINADVAPI
LSTATUS
APIENTRY
RegQueryValueExW (
    __in HKEY hKey,
    __in_opt LPCWSTR lpValueName,
    __reserved LPDWORD lpReserved,
    __out_opt LPDWORD lpType,
    __out_bcount_part_opt(*lpcbData, *lpcbData) __out_data_source(REGISTRY) LPBYTE lpData,
    __inout_opt LPDWORD lpcbData
    );
#ifdef UNICODE
#define RegQueryValueEx  RegQueryValueExW
#else
#define RegQueryValueEx  RegQueryValueExA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegReplaceKeyA (
    __in HKEY hKey,
    __in_opt LPCSTR lpSubKey,
    __in LPCSTR lpNewFile,
    __in LPCSTR lpOldFile
    );
WINADVAPI
LSTATUS
APIENTRY
RegReplaceKeyW (
    __in HKEY hKey,
    __in_opt LPCWSTR lpSubKey,
    __in LPCWSTR lpNewFile,
    __in LPCWSTR lpOldFile
    );
#ifdef UNICODE
#define RegReplaceKey  RegReplaceKeyW
#else
#define RegReplaceKey  RegReplaceKeyA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegRestoreKeyA (
    __in HKEY hKey,
    __in LPCSTR lpFile,
    __in DWORD dwFlags
    );
WINADVAPI
LSTATUS
APIENTRY
RegRestoreKeyW (
    __in HKEY hKey,
    __in LPCWSTR lpFile,
    __in DWORD dwFlags
    );
#ifdef UNICODE
#define RegRestoreKey  RegRestoreKeyW
#else
#define RegRestoreKey  RegRestoreKeyA
#endif // !UNICODE

#if(WINVER >= 0x0600)

WINADVAPI
LSTATUS
APIENTRY
RegRenameKey(
    __in HKEY hKey,
    __in_opt LPCWSTR lpSubKeyName,
    __in LPCWSTR lpNewKeyName
    );

#endif /* WINVER >= 0x0600 */

WINADVAPI
LSTATUS
APIENTRY
RegSaveKeyA (
    __in HKEY hKey,
    __in LPCSTR lpFile,
    __in_opt CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
WINADVAPI
LSTATUS
APIENTRY
RegSaveKeyW (
    __in HKEY hKey,
    __in LPCWSTR lpFile,
    __in_opt CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#ifdef UNICODE
#define RegSaveKey  RegSaveKeyW
#else
#define RegSaveKey  RegSaveKeyA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegSetKeySecurity (
    __in HKEY hKey,
    __in SECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

WINADVAPI
LSTATUS
APIENTRY
RegSetValueA (
    __in HKEY hKey,
    __in_opt LPCSTR lpSubKey,
    __in DWORD dwType,
    __in_bcount_opt(cbData) LPCSTR lpData,
    __in DWORD cbData
    );
WINADVAPI
LSTATUS
APIENTRY
RegSetValueW (
    __in HKEY hKey,
    __in_opt LPCWSTR lpSubKey,
    __in DWORD dwType,
    __in_bcount_opt(cbData) LPCWSTR lpData,
    __in DWORD cbData
    );
#ifdef UNICODE
#define RegSetValue  RegSetValueW
#else
#define RegSetValue  RegSetValueA
#endif // !UNICODE


WINADVAPI
LSTATUS
APIENTRY
RegSetValueExA (
    __in HKEY hKey,
    __in_opt LPCSTR lpValueName,
    __reserved DWORD Reserved,
    __in DWORD dwType,
    __in_bcount_opt(cbData) CONST BYTE* lpData,
    __in DWORD cbData
    );
WINADVAPI
LSTATUS
APIENTRY
RegSetValueExW (
    __in HKEY hKey,
    __in_opt LPCWSTR lpValueName,
    __reserved DWORD Reserved,
    __in DWORD dwType,
    __in_bcount_opt(cbData) CONST BYTE* lpData,
    __in DWORD cbData
    );
#ifdef UNICODE
#define RegSetValueEx  RegSetValueExW
#else
#define RegSetValueEx  RegSetValueExA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegUnLoadKeyA (
    __in HKEY    hKey,
    __in_opt LPCSTR lpSubKey
    );
WINADVAPI
LSTATUS
APIENTRY
RegUnLoadKeyW (
    __in HKEY    hKey,
    __in_opt LPCWSTR lpSubKey
    );
#ifdef UNICODE
#define RegUnLoadKey  RegUnLoadKeyW
#else
#define RegUnLoadKey  RegUnLoadKeyA
#endif // !UNICODE

//
// Utils wrappers
//
#if _WIN32_WINNT >= 0x0600

WINADVAPI
LSTATUS
APIENTRY
RegDeleteKeyValueA (
    __in      HKEY     hKey,
    __in_opt  LPCSTR lpSubKey,
    __in_opt  LPCSTR lpValueName
    );
WINADVAPI
LSTATUS
APIENTRY
RegDeleteKeyValueW (
    __in      HKEY     hKey,
    __in_opt  LPCWSTR lpSubKey,
    __in_opt  LPCWSTR lpValueName
    );
#ifdef UNICODE
#define RegDeleteKeyValue  RegDeleteKeyValueW
#else
#define RegDeleteKeyValue  RegDeleteKeyValueA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegSetKeyValueA (
    __in        HKEY     hKey,
    __in_opt    LPCSTR  lpSubKey,
    __in_opt    LPCSTR  lpValueName,
    __in        DWORD    dwType,
    __in_bcount_opt(cbData) LPCVOID  lpData,
    __in        DWORD    cbData
    );
WINADVAPI
LSTATUS
APIENTRY
RegSetKeyValueW (
    __in        HKEY     hKey,
    __in_opt    LPCWSTR  lpSubKey,
    __in_opt    LPCWSTR  lpValueName,
    __in        DWORD    dwType,
    __in_bcount_opt(cbData) LPCVOID  lpData,
    __in        DWORD    cbData
    );
#ifdef UNICODE
#define RegSetKeyValue  RegSetKeyValueW
#else
#define RegSetKeyValue  RegSetKeyValueA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegDeleteTreeA (
    __in        HKEY     hKey,
    __in_opt    LPCSTR  lpSubKey
    );
WINADVAPI
LSTATUS
APIENTRY
RegDeleteTreeW (
    __in        HKEY     hKey,
    __in_opt    LPCWSTR  lpSubKey
    );
#ifdef UNICODE
#define RegDeleteTree  RegDeleteTreeW
#else
#define RegDeleteTree  RegDeleteTreeA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegCopyTreeA (
    __in        HKEY     hKeySrc,
    __in_opt    LPCSTR  lpSubKey,
    __in        HKEY     hKeyDest
    );
WINADVAPI
LSTATUS
APIENTRY
RegCopyTreeW (
    __in        HKEY     hKeySrc,
    __in_opt    LPCWSTR  lpSubKey,
    __in        HKEY     hKeyDest
    );
#ifdef UNICODE
#define RegCopyTree  RegCopyTreeW
#else
#define RegCopyTree  RegCopyTreeA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegGetValueA (
    __in HKEY    hkey,
    __in_opt LPCSTR  lpSubKey,
    __in_opt LPCSTR  lpValue,
    __in_opt DWORD    dwFlags,
    __out_opt LPDWORD pdwType,
    __out_bcount_part_opt(*pcbData,*pcbData) PVOID   pvData,
    __inout_opt LPDWORD pcbData
    );
WINADVAPI
LSTATUS
APIENTRY
RegGetValueW (
    __in HKEY    hkey,
    __in_opt LPCWSTR  lpSubKey,
    __in_opt LPCWSTR  lpValue,
    __in_opt DWORD    dwFlags,
    __out_opt LPDWORD pdwType,
    __out_bcount_part_opt(*pcbData,*pcbData) PVOID   pvData,
    __inout_opt LPDWORD pcbData
    );
#ifdef UNICODE
#define RegGetValue  RegGetValueW
#else
#define RegGetValue  RegGetValueA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegLoadMUIStringA (
                    __in                    HKEY        hKey,
                    __in_opt                LPCSTR    pszValue,
                    __out_bcount_opt(cbOutBuf)  LPSTR     pszOutBuf,
                    __in                    DWORD       cbOutBuf,
                    __out_opt               LPDWORD     pcbData,
                    __in                    DWORD       Flags,   
                    __in_opt                LPCSTR    pszDirectory
                    );
WINADVAPI
LSTATUS
APIENTRY
RegLoadMUIStringW (
                    __in                    HKEY        hKey,
                    __in_opt                LPCWSTR    pszValue,
                    __out_bcount_opt(cbOutBuf)  LPWSTR     pszOutBuf,
                    __in                    DWORD       cbOutBuf,
                    __out_opt               LPDWORD     pcbData,
                    __in                    DWORD       Flags,   
                    __in_opt                LPCWSTR    pszDirectory
                    );
#ifdef UNICODE
#define RegLoadMUIString  RegLoadMUIStringW
#else
#define RegLoadMUIString  RegLoadMUIStringA
#endif // !UNICODE


WINADVAPI
LSTATUS
APIENTRY
RegLoadAppKeyA (
        __in        LPCSTR    lpFile,
        __out       PHKEY       phkResult,
        __in        REGSAM      samDesired, 
        __in        DWORD       dwOptions,
        __reserved  DWORD       Reserved
    );
WINADVAPI
LSTATUS
APIENTRY
RegLoadAppKeyW (
        __in        LPCWSTR    lpFile,
        __out       PHKEY       phkResult,
        __in        REGSAM      samDesired, 
        __in        DWORD       dwOptions,
        __reserved  DWORD       Reserved
    );
#ifdef UNICODE
#define RegLoadAppKey  RegLoadAppKeyW
#else
#define RegLoadAppKey  RegLoadAppKeyA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600

//
// Remoteable System Shutdown APIs
//

__drv_preferredFunction("InitiateSystemShutdownEx", "Legacy API. Rearchitect to avoid Reboot")
WINADVAPI
BOOL
APIENTRY
InitiateSystemShutdownA(
    __in_opt LPSTR lpMachineName,
    __in_opt LPSTR lpMessage,
    __in DWORD dwTimeout,
    __in BOOL bForceAppsClosed,
    __in BOOL bRebootAfterShutdown
    );
__drv_preferredFunction("InitiateSystemShutdownEx", "Legacy API. Rearchitect to avoid Reboot")
WINADVAPI
BOOL
APIENTRY
InitiateSystemShutdownW(
    __in_opt LPWSTR lpMachineName,
    __in_opt LPWSTR lpMessage,
    __in DWORD dwTimeout,
    __in BOOL bForceAppsClosed,
    __in BOOL bRebootAfterShutdown
    );
#ifdef UNICODE
#define InitiateSystemShutdown  InitiateSystemShutdownW
#else
#define InitiateSystemShutdown  InitiateSystemShutdownA
#endif // !UNICODE


WINADVAPI
BOOL
APIENTRY
AbortSystemShutdownA(
    __in_opt LPSTR lpMachineName
    );
WINADVAPI
BOOL
APIENTRY
AbortSystemShutdownW(
    __in_opt LPWSTR lpMachineName
    );
#ifdef UNICODE
#define AbortSystemShutdown  AbortSystemShutdownW
#else
#define AbortSystemShutdown  AbortSystemShutdownA
#endif // !UNICODE

//
// defines for InitiateSystemShutdownEx reason codes
//

#include <reason.h>             // get the public reasons
//
// Then for Historical reasons support some old symbols, internal only

#define REASON_SWINSTALL    (SHTDN_REASON_MAJOR_SOFTWARE|SHTDN_REASON_MINOR_INSTALLATION)
#define REASON_HWINSTALL    (SHTDN_REASON_MAJOR_HARDWARE|SHTDN_REASON_MINOR_INSTALLATION)
#define REASON_SERVICEHANG  (SHTDN_REASON_MAJOR_SOFTWARE|SHTDN_REASON_MINOR_HUNG)
#define REASON_UNSTABLE     (SHTDN_REASON_MAJOR_SYSTEM|SHTDN_REASON_MINOR_UNSTABLE)
#define REASON_SWHWRECONF   (SHTDN_REASON_MAJOR_SOFTWARE|SHTDN_REASON_MINOR_RECONFIG)
#define REASON_OTHER        (SHTDN_REASON_MAJOR_OTHER|SHTDN_REASON_MINOR_OTHER)
#define REASON_UNKNOWN      SHTDN_REASON_UNKNOWN
#define REASON_LEGACY_API   SHTDN_REASON_LEGACY_API
#define REASON_PLANNED_FLAG SHTDN_REASON_FLAG_PLANNED

//
// MAX Shutdown TimeOut == 10 Years in seconds
//
#define MAX_SHUTDOWN_TIMEOUT (10*365*24*60*60)

__drv_preferredFunction("a design alternative", "Rearchitect to avoid Reboot") 
__drv_when(((dwReason==0 && lpMessage==0)) || dwReason>=0xd0000000, 
    __drv_reportError("Requires a valid dwReason or lpMessage"))
WINADVAPI
BOOL
APIENTRY
InitiateSystemShutdownExA(
    __in_opt LPSTR lpMachineName,
    __in_opt LPSTR lpMessage,
    __in DWORD dwTimeout,
    __in BOOL bForceAppsClosed,
    __in BOOL bRebootAfterShutdown,
    __in DWORD dwReason
    );
__drv_preferredFunction("a design alternative", "Rearchitect to avoid Reboot") 
__drv_when(((dwReason==0 && lpMessage==0)) || dwReason>=0xd0000000, 
    __drv_reportError("Requires a valid dwReason or lpMessage"))
WINADVAPI
BOOL
APIENTRY
InitiateSystemShutdownExW(
    __in_opt LPWSTR lpMachineName,
    __in_opt LPWSTR lpMessage,
    __in DWORD dwTimeout,
    __in BOOL bForceAppsClosed,
    __in BOOL bRebootAfterShutdown,
    __in DWORD dwReason
    );
#ifdef UNICODE
#define InitiateSystemShutdownEx  InitiateSystemShutdownExW
#else
#define InitiateSystemShutdownEx  InitiateSystemShutdownExA
#endif // !UNICODE

//
// Shutdown flags
//

#define SHUTDOWN_FORCE_OTHERS           0x00000001
#define SHUTDOWN_FORCE_SELF             0x00000002
#define SHUTDOWN_RESTART                0x00000004
#define SHUTDOWN_POWEROFF               0x00000008
#define SHUTDOWN_NOREBOOT               0x00000010
#define SHUTDOWN_GRACE_OVERRIDE         0x00000020
#define SHUTDOWN_INSTALL_UPDATES        0x00000040
#define SHUTDOWN_RESTARTAPPS            0x00000080
#define SHUTDOWN_SKIP_SVC_PRESHUTDOWN   0x00000100


WINADVAPI
DWORD
APIENTRY
InitiateShutdownA(
    __in_opt LPSTR lpMachineName,
    __in_opt LPSTR lpMessage,
    __in     DWORD dwGracePeriod,
    __in     DWORD dwShutdownFlags,
    __in     DWORD dwReason
    );
WINADVAPI
DWORD
APIENTRY
InitiateShutdownW(
    __in_opt LPWSTR lpMachineName,
    __in_opt LPWSTR lpMessage,
    __in     DWORD dwGracePeriod,
    __in     DWORD dwShutdownFlags,
    __in     DWORD dwReason
    );
#ifdef UNICODE
#define InitiateShutdown  InitiateShutdownW
#else
#define InitiateShutdown  InitiateShutdownA
#endif // !UNICODE

WINADVAPI
LSTATUS
APIENTRY
RegSaveKeyExA (
    __in HKEY hKey,
    __in LPCSTR lpFile,
    __in_opt CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __in DWORD Flags
    );
WINADVAPI
LSTATUS
APIENTRY
RegSaveKeyExW (
    __in HKEY hKey,
    __in LPCWSTR lpFile,
    __in_opt CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __in DWORD Flags
    );
#ifdef UNICODE
#define RegSaveKeyEx  RegSaveKeyExW
#else
#define RegSaveKeyEx  RegSaveKeyExA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif


#endif // _WINREG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\winsafer.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    winsafer.h

Abstract:

    This file implements the publicly exported functions, data types,
    data structures, and definitions usable by programs that directly
    interact with the Windows SAFER APIs.

--*/

#ifndef _WINSAFER_H
#define _WINSAFER_H

#include <guiddef.h>
#include <wincrypt.h>


#ifdef __cplusplus
extern "C" {
#endif

//
// Opaque datatype for representing handles to Safer objects.
//

DECLARE_HANDLE(SAFER_LEVEL_HANDLE);


//
// Constants to represent scope with SaferCreateLevel and others.
//

#define SAFER_SCOPEID_MACHINE  1
#define SAFER_SCOPEID_USER     2


//
// Pre-defined levels that can be used with SaferCreateLevel
//

#define SAFER_LEVELID_FULLYTRUSTED 0x40000
#define SAFER_LEVELID_NORMALUSER   0x20000
#define SAFER_LEVELID_CONSTRAINED  0x10000
#define SAFER_LEVELID_UNTRUSTED    0x01000
#define SAFER_LEVELID_DISALLOWED   0x00000

//
// Flags to use when creating/opening a Level with SaferCreateLevel
//

#define SAFER_LEVEL_OPEN   1


//
// Maximum string size.
//

#define SAFER_MAX_FRIENDLYNAME_SIZE 256
#define SAFER_MAX_DESCRIPTION_SIZE  256
#define SAFER_MAX_HASH_SIZE         64

//
// Flags to use with SaferComputeTokenFromLevel.
//

#define SAFER_TOKEN_NULL_IF_EQUAL   0x00000001
#define SAFER_TOKEN_COMPARE_ONLY    0x00000002
#define SAFER_TOKEN_MAKE_INERT      0x00000004
#define SAFER_TOKEN_WANT_FLAGS      0x00000008

//
// Flags for specifying what criteria within SAFER_CODE_PROPERTIES to evaluate
// when finding code identity with SaferIdentifyLevel.
//

#define SAFER_CRITERIA_IMAGEPATH    0x00001
#define SAFER_CRITERIA_NOSIGNEDHASH 0x00002
#define SAFER_CRITERIA_IMAGEHASH    0x00004
#define SAFER_CRITERIA_AUTHENTICODE 0x00008
#define SAFER_CRITERIA_URLZONE      0x00010
#define SAFER_CRITERIA_IMAGEPATH_NT 0x01000

//
// Code image information structure passed to SaferIdentifyLevel.
//

#include <pshpack8.h>

typedef struct _SAFER_CODE_PROPERTIES
{

    //
    // Must be initialized to be the size of this structure,
    // for the purposes of future/backwards compatibility.
    //

    DWORD cbSize;

    //
    // Must be initialized to the types of criteria that should
    // be considered when evaluating this structure.  This can be
    // a combination of the SAFER_CRITERIA_xxxx flags.  If not enough
    // of the structure elements needed to evaluate the criteria
    // types indicated were supplied, then some of those criteria
    // flags may be silently ignored.  Specifying 0 for this value
    // will cause the entire structure's contents to be ignored.
    //

    DWORD dwCheckFlags;

    //
    // Optionally specifies the fully-qualified path and filename
    // to be used for discrimination checks based on the path.
    // The ImagePath will additionally be used to open and read the
    // file to identify any other discrimination criteria that was
    // unsupplied in this structure.
    //

    LPCWSTR ImagePath;

    //
    // Optionally specifies a file handle that has been opened to
    // code image with at least GENERIC_READ access.  The handle will
    // be used instead of explicitly opening the file again to compute
    // other discrimination criteria that was unsupplied in this structure.
    //

    HANDLE hImageFileHandle;

    //
    // Optionally specifies the pre-determined Internet Explorer
    // security zone.  These enums are defined within urlmon.h
    // For example: URLZONE_LOCAL_MACHINE, URLZONE_INTRANET,
    //   URLZONE_TRUSTED, URLZONE_INTERNET, or URLZONE_UNTRUSTED.
    //

    DWORD UrlZoneId;

    //
    // Optionally specifies the pre-computed hash of the image.
    // The supplied hash is interpreted as being valid if ImageSize
    // is non-zero and dwImageHashSize is non-zero and HashAlgorithm
    // represents a valid hashing algorithm from wincrypt.h
    //
    // If the supplied hash fails to meet the conditions above, then
    // the hash will be automatically computed against:
    //      1) by using ImageSize and pByteBlock if both are non-zero.
    //      2) by using hImageFileHandle if it is non-null.
    //      3) by attempting to open ImagePath if it is non-null.
    //

    BYTE ImageHash[SAFER_MAX_HASH_SIZE];
    DWORD dwImageHashSize;
    LARGE_INTEGER ImageSize;
    ALG_ID HashAlgorithm;

    //
    // Optionally specifies a memory block of memory representing
    // the image for which the trust is being requested for.  When
    // this member is specified, ImageSize must also be supplied.
    //

    LPBYTE pByteBlock;

    //
    // Optionally gives the arguments used for Authenticode signer
    // certificate verification.  These arguments are supplied to the
    // WinVerifyTrust() API and control the user-interface prompting
    // to accept untrusted certificates.
    //

    HWND hWndParent;
    DWORD dwWVTUIChoice;

} SAFER_CODE_PROPERTIES, *PSAFER_CODE_PROPERTIES;

#include <poppack.h>


//
// Masks for the per-identity WinSafer flags
//

#define SAFER_POLICY_JOBID_MASK                  0xFF000000
#define SAFER_POLICY_JOBID_CONSTRAINED           0x04000000
#define SAFER_POLICY_JOBID_UNTRUSTED             0x03000000
#define SAFER_POLICY_ONLY_EXES                   0x00010000
#define SAFER_POLICY_SANDBOX_INERT               0x00020000
#define SAFER_POLICY_HASH_DUPLICATE              0x00040000
#define SAFER_POLICY_ONLY_AUDIT                  0x00001000
#define SAFER_POLICY_BLOCK_CLIENT_UI             0x00002000
#define SAFER_POLICY_UIFLAGS_MASK                0x000000FF
#define SAFER_POLICY_UIFLAGS_INFORMATION_PROMPT  0x00000001
#define SAFER_POLICY_UIFLAGS_OPTION_PROMPT       0x00000002
#define SAFER_POLICY_UIFLAGS_HIDDEN              0x00000004

//
// Information classes on the overall policy that can be queried
// with SaferSet/GetPolicyInformation and set at different
// policy scopes based on access of the caller.
//

typedef enum _SAFER_POLICY_INFO_CLASS
{

    //
    // Accesses the list of all Levels defined in a policy.
    // The corresponding data element is a buffer that is filled
    // with multiple DWORDs, each representing the LevelIds that
    // are defined within this scope.
    //

    SaferPolicyLevelList = 1,

    //
    // for transparent enforcement of policy in the execution
    // framework -- will be used by native code execution but can
    // be used by any policy enforcement environment.
    // Corresponding data element is a DWORD holding a Boolean value.
    //

    SaferPolicyEnableTransparentEnforcement,

    //
    // Returns the name of the Level that has been designed
    // as the default level within the specified scope.
    // The corresponding data element is a single DWORD buffer
    // representing the LevelId of the default Level.  If no
    // level has been configured to be the default, then the
    // GetInfo API will return FALSE and GetLastError will
    // return ERROR_NOT_FOUND.
    //

    SaferPolicyDefaultLevel,

    //
    // Returns whether Code Identities or Default Level within the
    // user scope can be considered during identification.
    //

    SaferPolicyEvaluateUserScope,

    //
    // Control Flags for safer policy scope.
    //

    SaferPolicyScopeFlags,

    //
    // Flags which indicate "audit" or "block client UI" rules
    //

    SaferPolicyDefaultLevelFlags,

    //
    // Flag which indicates if certificate rules are applied in CreateProcess
    //

    SaferPolicyAuthenticodeEnabled

} SAFER_POLICY_INFO_CLASS;


//
// Enumerations used for retrieving specific information about a
// single authorization Level via SaferGet/SetInformationFromLevel.
//

typedef enum _SAFER_OBJECT_INFO_CLASS
{

    SaferObjectLevelId = 1,               // get: DWORD
    SaferObjectScopeId,                   // get: DWORD
    SaferObjectFriendlyName,              // get/set: LPCWSTR
    SaferObjectDescription,               // get/set: LPCWSTR
    SaferObjectBuiltin,                   // get: DWORD boolean

    SaferObjectDisallowed,                // get: DWORD boolean
    SaferObjectDisableMaxPrivilege,       // get: DWORD boolean
    SaferObjectInvertDeletedPrivileges,   // get: DWORD boolean
    SaferObjectDeletedPrivileges,         // get: TOKEN_PRIVILEGES
    SaferObjectDefaultOwner,              // get: TOKEN_OWNER
    SaferObjectSidsToDisable,             // get: TOKEN_GROUPS
    SaferObjectRestrictedSidsInverted,    // get: TOKEN_GROUPS
    SaferObjectRestrictedSidsAdded,       // get: TOKEN_GROUPS

    //
    // To enumerate all identities, call GetInfo with
    //      SaferObjectAllIdentificationGuids.
    //

    SaferObjectAllIdentificationGuids,    // get: SAFER_IDENTIFICATION_GUIDS

    //
    // To create a new identity, call SetInfo with
    //      SaferObjectSingleIdentification with a new
    //      unique GUID that you have generated.
    // To get details on a single identity, call GetInfo with
    //      SaferObjectSingleIdentification with desired GUID.
    // To modify details of a single identity, call SetInfo with
    //      SaferObjectSingleIdentification with desired info and GUID.
    // To delete an identity, call SetInfo with
    //      SaferObjectSingleIdentification with the
    //      header.dwIdentificationType set to 0.
    //

    SaferObjectSingleIdentification,      // get/set: SAFER_IDENTIFICATION_*

    SaferObjectExtendedError              // get: DWORD dwError

} SAFER_OBJECT_INFO_CLASS;


//
// Structures and enums used by the SaferGet/SetLevelInformation APIs.
//

#include <pshpack8.h>

typedef enum _SAFER_IDENTIFICATION_TYPES
{

    SaferIdentityDefault,
    SaferIdentityTypeImageName = 1,
    SaferIdentityTypeImageHash,
    SaferIdentityTypeUrlZone,
    SaferIdentityTypeCertificate

} SAFER_IDENTIFICATION_TYPES;

typedef struct _SAFER_IDENTIFICATION_HEADER
{
    //
    // indicates the type of the structure, one of SaferIdentityType*
    //

    SAFER_IDENTIFICATION_TYPES dwIdentificationType;

    //
    // size of the whole structure, not just the common header.
    //

    DWORD cbStructSize;

    //
    // the unique GUID of the Identity in question.
    //

    GUID IdentificationGuid;

    //
    // last change of this identification.
    //

    FILETIME lastModified;

} SAFER_IDENTIFICATION_HEADER, *PSAFER_IDENTIFICATION_HEADER;

typedef struct _SAFER_PATHNAME_IDENTIFICATION
{
    //
    // header.dwIdentificationType must be SaferIdentityTypeImageName
    // header.cbStructSize must be sizeof(SAFER_PATHNAME_IDENTIFICATION)
    //

    SAFER_IDENTIFICATION_HEADER header;

    //
    // user-entered description
    //

    WCHAR Description[SAFER_MAX_DESCRIPTION_SIZE];

    //
    // filepath or name, possibly with vars
    //

    PWCHAR ImageName;

    //
    // any combo of SAFER_POLICY_* flags
    //

    DWORD dwSaferFlags;

} SAFER_PATHNAME_IDENTIFICATION, *PSAFER_PATHNAME_IDENTIFICATION;

typedef struct _SAFER_HASH_IDENTIFICATION
{
    //
    // header.dwIdentificationType must be SaferIdentityTypeImageHash
    // header.cbStructSize must be sizeof(SAFER_HASH_IDENTIFICATION)
    //

    SAFER_IDENTIFICATION_HEADER header;

    //
    // user-entered friendly name, initially from file's resources.
    //
    WCHAR Description[SAFER_MAX_DESCRIPTION_SIZE];

    //
    // user-entered description.
    //

    WCHAR FriendlyName[SAFER_MAX_FRIENDLYNAME_SIZE];

    //
    // amount of ImageHash actually used, in bytes (MD5 is 16 bytes).
    //

    DWORD HashSize;

    //
    // computed hash data itself.
    //

    BYTE ImageHash[SAFER_MAX_HASH_SIZE];

    //
    // algorithm in which the hash was computed (CALG_MD5, etc).
    //

    ALG_ID HashAlgorithm;

    //
    // size of the original file in bytes.
    //

    LARGE_INTEGER ImageSize;

    //
    // any combo of SAFER_POLICY_* flags
    //

    DWORD dwSaferFlags;

} SAFER_HASH_IDENTIFICATION, *PSAFER_HASH_IDENTIFICATION;

typedef struct _SAFER_HASH_IDENTIFICATION2
{
    //
    // Start by including the original structure. It contains number of bytes
    // in this particular structure.
    //

    SAFER_HASH_IDENTIFICATION hashIdentification;

    //
    // amount of ImageHash actually used, in bytes (SHA256 is 32 bytes).
    //

    DWORD HashSize;

    //
    // computed hash data itself.
    //

    BYTE ImageHash[SAFER_MAX_HASH_SIZE];

    //
    // algorithm in which the hash was computed (CALG_SHA256).
    //

    ALG_ID HashAlgorithm;

} SAFER_HASH_IDENTIFICATION2, *PSAFER_HASH_IDENTIFICATION2;

typedef struct _SAFER_URLZONE_IDENTIFICATION
{
    //
    // header.dwIdentificationType must be SaferIdentityTypeUrlZone
    // header.cbStructSize must be sizeof(SAFER_URLZONE_IDENTIFICATION)
    //

    SAFER_IDENTIFICATION_HEADER header;

    //
    // any single URLZONE_* from urlmon.h
    //

    DWORD UrlZoneId;

    //
    // any combo of SAFER_POLICY_* flags
    //

    DWORD dwSaferFlags;

} SAFER_URLZONE_IDENTIFICATION, *PSAFER_URLZONE_IDENTIFICATION;


#include <poppack.h>

//
// Functions related to querying and setting the global policy
// controls to disable transparent enforcement, and perform level
// enumeration operations.
//

WINADVAPI
BOOL WINAPI
SaferGetPolicyInformation(
    __in DWORD                   dwScopeId,
    __in SAFER_POLICY_INFO_CLASS SaferPolicyInfoClass,
    __in DWORD                   InfoBufferSize,
    __out_bcount(InfoBufferSize) PVOID InfoBuffer,
    __out PDWORD                 InfoBufferRetSize,
    __reserved LPVOID            lpReserved
    );

WINADVAPI
BOOL WINAPI
SaferSetPolicyInformation(
    __in DWORD                          dwScopeId,
    __in SAFER_POLICY_INFO_CLASS        SaferPolicyInfoClass,
    __in DWORD                          InfoBufferSize,
    __in_bcount(InfoBufferSize) PVOID   InfoBuffer,
    __reserved LPVOID                   lpReserved
    );

//
// Functions to open or close a handle to a Safer Level.
//

WINADVAPI
BOOL WINAPI
SaferCreateLevel(
    __in DWORD                dwScopeId,
    __in DWORD                dwLevelId,
    __in DWORD                OpenFlags,
    __deref_out SAFER_LEVEL_HANDLE * pLevelHandle,
    __reserved LPVOID               lpReserved
    );

WINADVAPI
BOOL WINAPI
SaferCloseLevel(
    __in SAFER_LEVEL_HANDLE hLevelHandle
    );

WINADVAPI
BOOL WINAPI
SaferIdentifyLevel(
    __in DWORD              dwNumProperties,
    __in_ecount_opt(dwNumProperties) PSAFER_CODE_PROPERTIES pCodeProperties,
    __deref_out SAFER_LEVEL_HANDLE  * pLevelHandle,
    __in_opt LPVOID         lpReserved
    );

WINADVAPI
BOOL WINAPI
SaferComputeTokenFromLevel(
    __in SAFER_LEVEL_HANDLE LevelHandle,
    __in_opt HANDLE         InAccessToken,
    __out PHANDLE           OutAccessToken,
    __in DWORD              dwFlags,
    __inout_opt LPVOID      lpReserved
    );

WINADVAPI
BOOL WINAPI
SaferGetLevelInformation(
        __in SAFER_LEVEL_HANDLE                 LevelHandle,
        __in SAFER_OBJECT_INFO_CLASS            dwInfoType,
        __out_bcount_opt(dwInBufferSize) LPVOID lpQueryBuffer,
        __in DWORD                              dwInBufferSize,
        __out LPDWORD                           lpdwOutBufferSize
        );

WINADVAPI
BOOL WINAPI
SaferSetLevelInformation(
    __in SAFER_LEVEL_HANDLE             LevelHandle,
    __in SAFER_OBJECT_INFO_CLASS        dwInfoType,
    __in_bcount(dwInBufferSize) LPVOID  lpQueryBuffer,
    __in DWORD                          dwInBufferSize
    );

//
// This function performs logging of messages to the Application
// event log.  This is called by the hooks within CreateProcess,
// ShellExecute and cmd when a lower trust evaluation result occurs.
//

WINADVAPI
BOOL WINAPI
SaferRecordEventLogEntry(
    __in SAFER_LEVEL_HANDLE hLevel,
    __in LPCWSTR            szTargetPath,
    __reserved LPVOID       lpReserved
    );


WINADVAPI
BOOL WINAPI
SaferiIsExecutableFileType(
    __in LPCWSTR szFullPathname,
    __in BOOLEAN bFromShellExecute
    );

#define SRP_POLICY_EXE      L"EXE"
#define SRP_POLICY_DLL      L"DLL"
#define SRP_POLICY_MSI      L"MSI"
#define SRP_POLICY_SCRIPT   L"SCRIPT"
#define SRP_POLICY_SHELL    L"SHELL"
#define SRP_POLICY_NOV2     L"IGNORESRPV2"

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\winsatcominterfacei.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0542 */
/* Compiler settings for winsatcominterfacei.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __winsatcominterfacei_h__
#define __winsatcominterfacei_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWinSATTaskMangerTask_FWD_DEFINED__
#define __IWinSATTaskMangerTask_FWD_DEFINED__
typedef interface IWinSATTaskMangerTask IWinSATTaskMangerTask;
#endif 	/* __IWinSATTaskMangerTask_FWD_DEFINED__ */


#ifndef __IProvideWinSATAssessmentInfo_FWD_DEFINED__
#define __IProvideWinSATAssessmentInfo_FWD_DEFINED__
typedef interface IProvideWinSATAssessmentInfo IProvideWinSATAssessmentInfo;
#endif 	/* __IProvideWinSATAssessmentInfo_FWD_DEFINED__ */


#ifndef __IProvideWinSATResultsInfo_FWD_DEFINED__
#define __IProvideWinSATResultsInfo_FWD_DEFINED__
typedef interface IProvideWinSATResultsInfo IProvideWinSATResultsInfo;
#endif 	/* __IProvideWinSATResultsInfo_FWD_DEFINED__ */


#ifndef __IQueryRecentWinSATAssessment_FWD_DEFINED__
#define __IQueryRecentWinSATAssessment_FWD_DEFINED__
typedef interface IQueryRecentWinSATAssessment IQueryRecentWinSATAssessment;
#endif 	/* __IQueryRecentWinSATAssessment_FWD_DEFINED__ */


#ifndef __IProvideWinSATVisuals_FWD_DEFINED__
#define __IProvideWinSATVisuals_FWD_DEFINED__
typedef interface IProvideWinSATVisuals IProvideWinSATVisuals;
#endif 	/* __IProvideWinSATVisuals_FWD_DEFINED__ */


#ifndef __IQueryAllWinSATAssessments_FWD_DEFINED__
#define __IQueryAllWinSATAssessments_FWD_DEFINED__
typedef interface IQueryAllWinSATAssessments IQueryAllWinSATAssessments;
#endif 	/* __IQueryAllWinSATAssessments_FWD_DEFINED__ */


#ifndef __IWinSATInitiateEvents_FWD_DEFINED__
#define __IWinSATInitiateEvents_FWD_DEFINED__
typedef interface IWinSATInitiateEvents IWinSATInitiateEvents;
#endif 	/* __IWinSATInitiateEvents_FWD_DEFINED__ */


#ifndef __IInitiateWinSATAssessment_FWD_DEFINED__
#define __IInitiateWinSATAssessment_FWD_DEFINED__
typedef interface IInitiateWinSATAssessment IInitiateWinSATAssessment;
#endif 	/* __IInitiateWinSATAssessment_FWD_DEFINED__ */


#ifndef __IAccessibleWinSAT_FWD_DEFINED__
#define __IAccessibleWinSAT_FWD_DEFINED__
typedef interface IAccessibleWinSAT IAccessibleWinSAT;
#endif 	/* __IAccessibleWinSAT_FWD_DEFINED__ */


#ifndef __IQueryOEMWinSATCustomization_FWD_DEFINED__
#define __IQueryOEMWinSATCustomization_FWD_DEFINED__
typedef interface IQueryOEMWinSATCustomization IQueryOEMWinSATCustomization;
#endif 	/* __IQueryOEMWinSATCustomization_FWD_DEFINED__ */


#ifndef __CWinSATTaskMangerTask_FWD_DEFINED__
#define __CWinSATTaskMangerTask_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWinSATTaskMangerTask CWinSATTaskMangerTask;
#else
typedef struct CWinSATTaskMangerTask CWinSATTaskMangerTask;
#endif /* __cplusplus */

#endif 	/* __CWinSATTaskMangerTask_FWD_DEFINED__ */


#ifndef __CInitiateWinSAT_FWD_DEFINED__
#define __CInitiateWinSAT_FWD_DEFINED__

#ifdef __cplusplus
typedef class CInitiateWinSAT CInitiateWinSAT;
#else
typedef struct CInitiateWinSAT CInitiateWinSAT;
#endif /* __cplusplus */

#endif 	/* __CInitiateWinSAT_FWD_DEFINED__ */


#ifndef __CQueryWinSAT_FWD_DEFINED__
#define __CQueryWinSAT_FWD_DEFINED__

#ifdef __cplusplus
typedef class CQueryWinSAT CQueryWinSAT;
#else
typedef struct CQueryWinSAT CQueryWinSAT;
#endif /* __cplusplus */

#endif 	/* __CQueryWinSAT_FWD_DEFINED__ */


#ifndef __CQueryAllWinSAT_FWD_DEFINED__
#define __CQueryAllWinSAT_FWD_DEFINED__

#ifdef __cplusplus
typedef class CQueryAllWinSAT CQueryAllWinSAT;
#else
typedef struct CQueryAllWinSAT CQueryAllWinSAT;
#endif /* __cplusplus */

#endif 	/* __CQueryAllWinSAT_FWD_DEFINED__ */


#ifndef __CProvideWinSATVisuals_FWD_DEFINED__
#define __CProvideWinSATVisuals_FWD_DEFINED__

#ifdef __cplusplus
typedef class CProvideWinSATVisuals CProvideWinSATVisuals;
#else
typedef struct CProvideWinSATVisuals CProvideWinSATVisuals;
#endif /* __cplusplus */

#endif 	/* __CProvideWinSATVisuals_FWD_DEFINED__ */


#ifndef __CAccessiblityWinSAT_FWD_DEFINED__
#define __CAccessiblityWinSAT_FWD_DEFINED__

#ifdef __cplusplus
typedef class CAccessiblityWinSAT CAccessiblityWinSAT;
#else
typedef struct CAccessiblityWinSAT CAccessiblityWinSAT;
#endif /* __cplusplus */

#endif 	/* __CAccessiblityWinSAT_FWD_DEFINED__ */


#ifndef __CQueryOEMWinSATCustomization_FWD_DEFINED__
#define __CQueryOEMWinSATCustomization_FWD_DEFINED__

#ifdef __cplusplus
typedef class CQueryOEMWinSATCustomization CQueryOEMWinSATCustomization;
#else
typedef struct CQueryOEMWinSATCustomization CQueryOEMWinSATCustomization;
#endif /* __cplusplus */

#endif 	/* __CQueryOEMWinSATCustomization_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "msxml.h"
#include "oleacc.h"
#include "taskschd.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_winsatcominterfacei_0000_0000 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_winsatcominterfacei_0000_0000_0001
    {	WINSAT_OEM_DATA_VALID	= 0,
	WINSAT_OEM_DATA_NON_SYS_CONFIG_MATCH	= 1,
	WINSAT_OEM_DATA_INVALID	= 2,
	WINSAT_OEM_NO_DATA_SUPPLIED	= 3
    } 	WINSAT_OEM_CUSTOMIZATION_STATE;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_winsatcominterfacei_0000_0000_0002
    {	WINSAT_ASSESSMENT_STATE_MIN	= 0,
	WINSAT_ASSESSMENT_STATE_UNKNOWN	= 0,
	WINSAT_ASSESSMENT_STATE_VALID	= 1,
	WINSAT_ASSESSMENT_STATE_INCOHERENT_WITH_HARDWARE	= 2,
	WINSAT_ASSESSMENT_STATE_NOT_AVAILABLE	= 3,
	WINSAT_ASSESSMENT_STATE_INVALID	= 4,
	WINSAT_ASSESSMENT_STATE_MAX	= 4
    } 	WINSAT_ASSESSMENT_STATE;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_winsatcominterfacei_0000_0000_0003
    {	WINSAT_ASSESSMENT_MEMORY	= 0,
	WINSAT_ASSESSMENT_CPU	= 1,
	WINSAT_ASSESSMENT_DISK	= 2,
	WINSAT_ASSESSMENT_D3D	= 3,
	WINSAT_ASSESSMENT_GRAPHICS	= 4
    } 	WINSAT_ASSESSMENT_TYPE;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_winsatcominterfacei_0000_0000_0004
    {	WINSAT_BITMAP_SIZE_SMALL	= 0,
	WINSAT_BITMAP_SIZE_NORMAL	= 1
    } 	WINSAT_BITMAP_SIZE;



extern RPC_IF_HANDLE __MIDL_itf_winsatcominterfacei_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_winsatcominterfacei_0000_0000_v0_0_s_ifspec;

#ifndef __IWinSATTaskMangerTask_INTERFACE_DEFINED__
#define __IWinSATTaskMangerTask_INTERFACE_DEFINED__

/* interface IWinSATTaskMangerTask */
/* [unique][oleautomation][dual][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWinSATTaskMangerTask;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("295D2F4E-0B80-4892-A6CE-78C6957BD75A")
    IWinSATTaskMangerTask : public ITaskHandler
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ __RPC__in_opt IUnknown *pHandlerServices,
            /* [in] */ __RPC__in BSTR data) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Stop( 
            /* [out] */ __RPC__out HRESULT *pRetCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinSATTaskMangerTaskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinSATTaskMangerTask * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinSATTaskMangerTask * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinSATTaskMangerTask * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Start )( 
            IWinSATTaskMangerTask * This,
            /* [in] */ __RPC__in_opt IUnknown *pHandlerServices,
            /* [in] */ __RPC__in BSTR data);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IWinSATTaskMangerTask * This,
            /* [out] */ __RPC__out HRESULT *pRetCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IWinSATTaskMangerTask * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IWinSATTaskMangerTask * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Start )( 
            IWinSATTaskMangerTask * This,
            /* [in] */ __RPC__in_opt IUnknown *pHandlerServices,
            /* [in] */ __RPC__in BSTR data);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IWinSATTaskMangerTask * This,
            /* [out] */ __RPC__out HRESULT *pRetCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IWinSATTaskMangerTask * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IWinSATTaskMangerTask * This);
        
        END_INTERFACE
    } IWinSATTaskMangerTaskVtbl;

    interface IWinSATTaskMangerTask
    {
        CONST_VTBL struct IWinSATTaskMangerTaskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinSATTaskMangerTask_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinSATTaskMangerTask_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinSATTaskMangerTask_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinSATTaskMangerTask_Start(This,pHandlerServices,data)	\
    ( (This)->lpVtbl -> Start(This,pHandlerServices,data) ) 

#define IWinSATTaskMangerTask_Stop(This,pRetCode)	\
    ( (This)->lpVtbl -> Stop(This,pRetCode) ) 

#define IWinSATTaskMangerTask_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IWinSATTaskMangerTask_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 


#define IWinSATTaskMangerTask_Start(This,pHandlerServices,data)	\
    ( (This)->lpVtbl -> Start(This,pHandlerServices,data) ) 

#define IWinSATTaskMangerTask_Stop(This,pRetCode)	\
    ( (This)->lpVtbl -> Stop(This,pRetCode) ) 

#define IWinSATTaskMangerTask_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IWinSATTaskMangerTask_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWinSATTaskMangerTask_INTERFACE_DEFINED__ */


#ifndef __IProvideWinSATAssessmentInfo_INTERFACE_DEFINED__
#define __IProvideWinSATAssessmentInfo_INTERFACE_DEFINED__

/* interface IProvideWinSATAssessmentInfo */
/* [unique][oleautomation][dual][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IProvideWinSATAssessmentInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0CD1C380-52D3-4678-AC6F-E929E480BE9E")
    IProvideWinSATAssessmentInfo : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Score( 
            /* [retval][out] */ __RPC__out float *score) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [string][retval][out] */ __RPC__deref_out_opt_string BSTR *title) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [string][retval][out] */ __RPC__deref_out_opt_string BSTR *description) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideWinSATAssessmentInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProvideWinSATAssessmentInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProvideWinSATAssessmentInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProvideWinSATAssessmentInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IProvideWinSATAssessmentInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IProvideWinSATAssessmentInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IProvideWinSATAssessmentInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IProvideWinSATAssessmentInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Score )( 
            IProvideWinSATAssessmentInfo * This,
            /* [retval][out] */ __RPC__out float *score);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IProvideWinSATAssessmentInfo * This,
            /* [string][retval][out] */ __RPC__deref_out_opt_string BSTR *title);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IProvideWinSATAssessmentInfo * This,
            /* [string][retval][out] */ __RPC__deref_out_opt_string BSTR *description);
        
        END_INTERFACE
    } IProvideWinSATAssessmentInfoVtbl;

    interface IProvideWinSATAssessmentInfo
    {
        CONST_VTBL struct IProvideWinSATAssessmentInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideWinSATAssessmentInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProvideWinSATAssessmentInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProvideWinSATAssessmentInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProvideWinSATAssessmentInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IProvideWinSATAssessmentInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IProvideWinSATAssessmentInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IProvideWinSATAssessmentInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IProvideWinSATAssessmentInfo_get_Score(This,score)	\
    ( (This)->lpVtbl -> get_Score(This,score) ) 

#define IProvideWinSATAssessmentInfo_get_Title(This,title)	\
    ( (This)->lpVtbl -> get_Title(This,title) ) 

#define IProvideWinSATAssessmentInfo_get_Description(This,description)	\
    ( (This)->lpVtbl -> get_Description(This,description) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProvideWinSATAssessmentInfo_INTERFACE_DEFINED__ */


#ifndef __IProvideWinSATResultsInfo_INTERFACE_DEFINED__
#define __IProvideWinSATResultsInfo_INTERFACE_DEFINED__

/* interface IProvideWinSATResultsInfo */
/* [unique][oleautomation][dual][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IProvideWinSATResultsInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F8334D5D-568E-4075-875F-9DF341506640")
    IProvideWinSATResultsInfo : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetAssessmentInfo( 
            /* [in] */ WINSAT_ASSESSMENT_TYPE assessment,
            /* [retval][out] */ __RPC__deref_out_opt IProvideWinSATAssessmentInfo **ppinfo) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AssessmentState( 
            /* [retval][out] */ __RPC__out WINSAT_ASSESSMENT_STATE *state) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AssessmentDateTime( 
            /* [retval][out] */ __RPC__out VARIANT *fileTime) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SystemRating( 
            /* [retval][out] */ __RPC__out float *level) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RatingStateDesc( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideWinSATResultsInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProvideWinSATResultsInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProvideWinSATResultsInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProvideWinSATResultsInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IProvideWinSATResultsInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IProvideWinSATResultsInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IProvideWinSATResultsInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IProvideWinSATResultsInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetAssessmentInfo )( 
            IProvideWinSATResultsInfo * This,
            /* [in] */ WINSAT_ASSESSMENT_TYPE assessment,
            /* [retval][out] */ __RPC__deref_out_opt IProvideWinSATAssessmentInfo **ppinfo);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AssessmentState )( 
            IProvideWinSATResultsInfo * This,
            /* [retval][out] */ __RPC__out WINSAT_ASSESSMENT_STATE *state);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AssessmentDateTime )( 
            IProvideWinSATResultsInfo * This,
            /* [retval][out] */ __RPC__out VARIANT *fileTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SystemRating )( 
            IProvideWinSATResultsInfo * This,
            /* [retval][out] */ __RPC__out float *level);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RatingStateDesc )( 
            IProvideWinSATResultsInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description);
        
        END_INTERFACE
    } IProvideWinSATResultsInfoVtbl;

    interface IProvideWinSATResultsInfo
    {
        CONST_VTBL struct IProvideWinSATResultsInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideWinSATResultsInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProvideWinSATResultsInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProvideWinSATResultsInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProvideWinSATResultsInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IProvideWinSATResultsInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IProvideWinSATResultsInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IProvideWinSATResultsInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IProvideWinSATResultsInfo_GetAssessmentInfo(This,assessment,ppinfo)	\
    ( (This)->lpVtbl -> GetAssessmentInfo(This,assessment,ppinfo) ) 

#define IProvideWinSATResultsInfo_get_AssessmentState(This,state)	\
    ( (This)->lpVtbl -> get_AssessmentState(This,state) ) 

#define IProvideWinSATResultsInfo_get_AssessmentDateTime(This,fileTime)	\
    ( (This)->lpVtbl -> get_AssessmentDateTime(This,fileTime) ) 

#define IProvideWinSATResultsInfo_get_SystemRating(This,level)	\
    ( (This)->lpVtbl -> get_SystemRating(This,level) ) 

#define IProvideWinSATResultsInfo_get_RatingStateDesc(This,description)	\
    ( (This)->lpVtbl -> get_RatingStateDesc(This,description) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProvideWinSATResultsInfo_INTERFACE_DEFINED__ */


#ifndef __IQueryRecentWinSATAssessment_INTERFACE_DEFINED__
#define __IQueryRecentWinSATAssessment_INTERFACE_DEFINED__

/* interface IQueryRecentWinSATAssessment */
/* [unique][oleautomation][dual][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IQueryRecentWinSATAssessment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F8AD5D1F-3B47-4bdc-9375-7C6B1DA4ECA7")
    IQueryRecentWinSATAssessment : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_XML( 
            /* [string][in] */ __RPC__in_string BSTR xPath,
            /* [defaultvalue][string][in] */ __RPC__in_string BSTR namespaces,
            /* [retval][out] */ __RPC__deref_out_opt IXMLDOMNodeList **ppDomNodeList) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Info( 
            /* [retval][out] */ __RPC__deref_out_opt IProvideWinSATResultsInfo **ppWinSATAssessmentInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryRecentWinSATAssessmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueryRecentWinSATAssessment * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueryRecentWinSATAssessment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueryRecentWinSATAssessment * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IQueryRecentWinSATAssessment * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IQueryRecentWinSATAssessment * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IQueryRecentWinSATAssessment * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IQueryRecentWinSATAssessment * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_XML )( 
            IQueryRecentWinSATAssessment * This,
            /* [string][in] */ __RPC__in_string BSTR xPath,
            /* [defaultvalue][string][in] */ __RPC__in_string BSTR namespaces,
            /* [retval][out] */ __RPC__deref_out_opt IXMLDOMNodeList **ppDomNodeList);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Info )( 
            IQueryRecentWinSATAssessment * This,
            /* [retval][out] */ __RPC__deref_out_opt IProvideWinSATResultsInfo **ppWinSATAssessmentInfo);
        
        END_INTERFACE
    } IQueryRecentWinSATAssessmentVtbl;

    interface IQueryRecentWinSATAssessment
    {
        CONST_VTBL struct IQueryRecentWinSATAssessmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryRecentWinSATAssessment_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueryRecentWinSATAssessment_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueryRecentWinSATAssessment_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueryRecentWinSATAssessment_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IQueryRecentWinSATAssessment_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IQueryRecentWinSATAssessment_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IQueryRecentWinSATAssessment_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IQueryRecentWinSATAssessment_get_XML(This,xPath,namespaces,ppDomNodeList)	\
    ( (This)->lpVtbl -> get_XML(This,xPath,namespaces,ppDomNodeList) ) 

#define IQueryRecentWinSATAssessment_get_Info(This,ppWinSATAssessmentInfo)	\
    ( (This)->lpVtbl -> get_Info(This,ppWinSATAssessmentInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueryRecentWinSATAssessment_INTERFACE_DEFINED__ */


#ifndef __IProvideWinSATVisuals_INTERFACE_DEFINED__
#define __IProvideWinSATVisuals_INTERFACE_DEFINED__

/* interface IProvideWinSATVisuals */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IProvideWinSATVisuals;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9F4ADE0-871A-42a3-B813-3078D25162C9")
    IProvideWinSATVisuals : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_Bitmap( 
            /* [in] */ WINSAT_BITMAP_SIZE bitmapSize,
            WINSAT_ASSESSMENT_STATE state,
            float rating,
            /* [out] */ __RPC__deref_out_opt HBITMAP *pBitmap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideWinSATVisualsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProvideWinSATVisuals * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProvideWinSATVisuals * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProvideWinSATVisuals * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_Bitmap )( 
            IProvideWinSATVisuals * This,
            /* [in] */ WINSAT_BITMAP_SIZE bitmapSize,
            WINSAT_ASSESSMENT_STATE state,
            float rating,
            /* [out] */ __RPC__deref_out_opt HBITMAP *pBitmap);
        
        END_INTERFACE
    } IProvideWinSATVisualsVtbl;

    interface IProvideWinSATVisuals
    {
        CONST_VTBL struct IProvideWinSATVisualsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideWinSATVisuals_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProvideWinSATVisuals_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProvideWinSATVisuals_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProvideWinSATVisuals_get_Bitmap(This,bitmapSize,state,rating,pBitmap)	\
    ( (This)->lpVtbl -> get_Bitmap(This,bitmapSize,state,rating,pBitmap) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProvideWinSATVisuals_INTERFACE_DEFINED__ */


#ifndef __IQueryAllWinSATAssessments_INTERFACE_DEFINED__
#define __IQueryAllWinSATAssessments_INTERFACE_DEFINED__

/* interface IQueryAllWinSATAssessments */
/* [unique][oleautomation][dual][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IQueryAllWinSATAssessments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0B89ED1D-6398-4fea-87FC-567D8D19176F")
    IQueryAllWinSATAssessments : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllXML( 
            /* [string][in] */ __RPC__in_string BSTR xPath,
            /* [defaultvalue][string][in] */ __RPC__in_string BSTR namespaces,
            /* [retval][out] */ __RPC__deref_out_opt IXMLDOMNodeList **ppDomNodeList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryAllWinSATAssessmentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueryAllWinSATAssessments * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueryAllWinSATAssessments * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueryAllWinSATAssessments * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IQueryAllWinSATAssessments * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IQueryAllWinSATAssessments * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IQueryAllWinSATAssessments * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IQueryAllWinSATAssessments * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllXML )( 
            IQueryAllWinSATAssessments * This,
            /* [string][in] */ __RPC__in_string BSTR xPath,
            /* [defaultvalue][string][in] */ __RPC__in_string BSTR namespaces,
            /* [retval][out] */ __RPC__deref_out_opt IXMLDOMNodeList **ppDomNodeList);
        
        END_INTERFACE
    } IQueryAllWinSATAssessmentsVtbl;

    interface IQueryAllWinSATAssessments
    {
        CONST_VTBL struct IQueryAllWinSATAssessmentsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryAllWinSATAssessments_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueryAllWinSATAssessments_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueryAllWinSATAssessments_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueryAllWinSATAssessments_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IQueryAllWinSATAssessments_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IQueryAllWinSATAssessments_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IQueryAllWinSATAssessments_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IQueryAllWinSATAssessments_get_AllXML(This,xPath,namespaces,ppDomNodeList)	\
    ( (This)->lpVtbl -> get_AllXML(This,xPath,namespaces,ppDomNodeList) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueryAllWinSATAssessments_INTERFACE_DEFINED__ */


#ifndef __IWinSATInitiateEvents_INTERFACE_DEFINED__
#define __IWinSATInitiateEvents_INTERFACE_DEFINED__

/* interface IWinSATInitiateEvents */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWinSATInitiateEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("262A1918-BA0D-41d5-92C2-FAB4633EE74F")
    IWinSATInitiateEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WinSATComplete( 
            /* [in] */ HRESULT hresult,
            /* [string][in] */ __RPC__in_string LPCWSTR strDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WinSATUpdate( 
            /* [in] */ UINT uCurrentTick,
            /* [in] */ UINT uTickTotal,
            /* [string][in] */ __RPC__in_string LPCWSTR strCurrentState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinSATInitiateEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinSATInitiateEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinSATInitiateEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinSATInitiateEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *WinSATComplete )( 
            IWinSATInitiateEvents * This,
            /* [in] */ HRESULT hresult,
            /* [string][in] */ __RPC__in_string LPCWSTR strDescription);
        
        HRESULT ( STDMETHODCALLTYPE *WinSATUpdate )( 
            IWinSATInitiateEvents * This,
            /* [in] */ UINT uCurrentTick,
            /* [in] */ UINT uTickTotal,
            /* [string][in] */ __RPC__in_string LPCWSTR strCurrentState);
        
        END_INTERFACE
    } IWinSATInitiateEventsVtbl;

    interface IWinSATInitiateEvents
    {
        CONST_VTBL struct IWinSATInitiateEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinSATInitiateEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinSATInitiateEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinSATInitiateEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinSATInitiateEvents_WinSATComplete(This,hresult,strDescription)	\
    ( (This)->lpVtbl -> WinSATComplete(This,hresult,strDescription) ) 

#define IWinSATInitiateEvents_WinSATUpdate(This,uCurrentTick,uTickTotal,strCurrentState)	\
    ( (This)->lpVtbl -> WinSATUpdate(This,uCurrentTick,uTickTotal,strCurrentState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWinSATInitiateEvents_INTERFACE_DEFINED__ */


#ifndef __IInitiateWinSATAssessment_INTERFACE_DEFINED__
#define __IInitiateWinSATAssessment_INTERFACE_DEFINED__

/* interface IInitiateWinSATAssessment */
/* [uuid][object] */ 


EXTERN_C const IID IID_IInitiateWinSATAssessment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D983FC50-F5BF-49d5-B5ED-CCCB18AA7FC1")
    IInitiateWinSATAssessment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitiateAssessment( 
            /* [string][in] */ __RPC__in_string LPCWSTR cmdLine,
            /* [unique][optional][in] */ __RPC__in_opt IWinSATInitiateEvents *pCallbacks,
            /* [unique][optional][in] */ __RPC__in_opt HWND callerHwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitiateFormalAssessment( 
            /* [unique][optional][in] */ __RPC__in_opt IWinSATInitiateEvents *pCallbacks,
            /* [unique][optional][in] */ __RPC__in_opt HWND callerHwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelAssessment( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitiateWinSATAssessmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInitiateWinSATAssessment * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInitiateWinSATAssessment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInitiateWinSATAssessment * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitiateAssessment )( 
            IInitiateWinSATAssessment * This,
            /* [string][in] */ __RPC__in_string LPCWSTR cmdLine,
            /* [unique][optional][in] */ __RPC__in_opt IWinSATInitiateEvents *pCallbacks,
            /* [unique][optional][in] */ __RPC__in_opt HWND callerHwnd);
        
        HRESULT ( STDMETHODCALLTYPE *InitiateFormalAssessment )( 
            IInitiateWinSATAssessment * This,
            /* [unique][optional][in] */ __RPC__in_opt IWinSATInitiateEvents *pCallbacks,
            /* [unique][optional][in] */ __RPC__in_opt HWND callerHwnd);
        
        HRESULT ( STDMETHODCALLTYPE *CancelAssessment )( 
            IInitiateWinSATAssessment * This);
        
        END_INTERFACE
    } IInitiateWinSATAssessmentVtbl;

    interface IInitiateWinSATAssessment
    {
        CONST_VTBL struct IInitiateWinSATAssessmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitiateWinSATAssessment_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInitiateWinSATAssessment_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInitiateWinSATAssessment_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInitiateWinSATAssessment_InitiateAssessment(This,cmdLine,pCallbacks,callerHwnd)	\
    ( (This)->lpVtbl -> InitiateAssessment(This,cmdLine,pCallbacks,callerHwnd) ) 

#define IInitiateWinSATAssessment_InitiateFormalAssessment(This,pCallbacks,callerHwnd)	\
    ( (This)->lpVtbl -> InitiateFormalAssessment(This,pCallbacks,callerHwnd) ) 

#define IInitiateWinSATAssessment_CancelAssessment(This)	\
    ( (This)->lpVtbl -> CancelAssessment(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInitiateWinSATAssessment_INTERFACE_DEFINED__ */


#ifndef __IAccessibleWinSAT_INTERFACE_DEFINED__
#define __IAccessibleWinSAT_INTERFACE_DEFINED__

/* interface IAccessibleWinSAT */
/* [uuid][object] */ 


EXTERN_C const IID IID_IAccessibleWinSAT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30e6018a-94a8-4ff8-a69a-71b67413f07b")
    IAccessibleWinSAT : public IAccessible
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAccessiblityData( 
            /* [string][in] */ __RPC__in_string LPCWSTR wsName,
            /* [string][in] */ __RPC__in_string LPCWSTR wsValue,
            /* [string][in] */ __RPC__in_string LPCWSTR wsDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccessibleWinSATVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAccessibleWinSAT * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAccessibleWinSAT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAccessibleWinSAT * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAccessibleWinSAT * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAccessibleWinSAT * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAccessibleWinSAT * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAccessibleWinSAT * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accParent )( 
            IAccessibleWinSAT * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppdispParent);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accChildCount )( 
            IAccessibleWinSAT * This,
            /* [retval][out] */ __RPC__out long *pcountChildren);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accChild )( 
            IAccessibleWinSAT * This,
            /* [in] */ VARIANT varChild,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppdispChild);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accName )( 
            IAccessibleWinSAT * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszName);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accValue )( 
            IAccessibleWinSAT * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszValue);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accDescription )( 
            IAccessibleWinSAT * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszDescription);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accRole )( 
            IAccessibleWinSAT * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ __RPC__out VARIANT *pvarRole);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accState )( 
            IAccessibleWinSAT * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ __RPC__out VARIANT *pvarState);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accHelp )( 
            IAccessibleWinSAT * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszHelp);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accHelpTopic )( 
            IAccessibleWinSAT * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pszHelpFile,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ __RPC__out long *pidTopic);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accKeyboardShortcut )( 
            IAccessibleWinSAT * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszKeyboardShortcut);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accFocus )( 
            IAccessibleWinSAT * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarChild);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accSelection )( 
            IAccessibleWinSAT * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarChildren);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accDefaultAction )( 
            IAccessibleWinSAT * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszDefaultAction);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accSelect )( 
            IAccessibleWinSAT * This,
            /* [in] */ long flagsSelect,
            /* [optional][in] */ VARIANT varChild);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accLocation )( 
            IAccessibleWinSAT * This,
            /* [out] */ __RPC__out long *pxLeft,
            /* [out] */ __RPC__out long *pyTop,
            /* [out] */ __RPC__out long *pcxWidth,
            /* [out] */ __RPC__out long *pcyHeight,
            /* [optional][in] */ VARIANT varChild);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accNavigate )( 
            IAccessibleWinSAT * This,
            /* [in] */ long navDir,
            /* [optional][in] */ VARIANT varStart,
            /* [retval][out] */ __RPC__out VARIANT *pvarEndUpAt);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accHitTest )( 
            IAccessibleWinSAT * This,
            /* [in] */ long xLeft,
            /* [in] */ long yTop,
            /* [retval][out] */ __RPC__out VARIANT *pvarChild);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accDoDefaultAction )( 
            IAccessibleWinSAT * This,
            /* [optional][in] */ VARIANT varChild);
        
        /* [id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_accName )( 
            IAccessibleWinSAT * This,
            /* [optional][in] */ VARIANT varChild,
            /* [in] */ __RPC__in BSTR szName);
        
        /* [id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_accValue )( 
            IAccessibleWinSAT * This,
            /* [optional][in] */ VARIANT varChild,
            /* [in] */ __RPC__in BSTR szValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccessiblityData )( 
            IAccessibleWinSAT * This,
            /* [string][in] */ __RPC__in_string LPCWSTR wsName,
            /* [string][in] */ __RPC__in_string LPCWSTR wsValue,
            /* [string][in] */ __RPC__in_string LPCWSTR wsDesc);
        
        END_INTERFACE
    } IAccessibleWinSATVtbl;

    interface IAccessibleWinSAT
    {
        CONST_VTBL struct IAccessibleWinSATVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccessibleWinSAT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAccessibleWinSAT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAccessibleWinSAT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAccessibleWinSAT_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAccessibleWinSAT_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAccessibleWinSAT_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAccessibleWinSAT_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAccessibleWinSAT_get_accParent(This,ppdispParent)	\
    ( (This)->lpVtbl -> get_accParent(This,ppdispParent) ) 

#define IAccessibleWinSAT_get_accChildCount(This,pcountChildren)	\
    ( (This)->lpVtbl -> get_accChildCount(This,pcountChildren) ) 

#define IAccessibleWinSAT_get_accChild(This,varChild,ppdispChild)	\
    ( (This)->lpVtbl -> get_accChild(This,varChild,ppdispChild) ) 

#define IAccessibleWinSAT_get_accName(This,varChild,pszName)	\
    ( (This)->lpVtbl -> get_accName(This,varChild,pszName) ) 

#define IAccessibleWinSAT_get_accValue(This,varChild,pszValue)	\
    ( (This)->lpVtbl -> get_accValue(This,varChild,pszValue) ) 

#define IAccessibleWinSAT_get_accDescription(This,varChild,pszDescription)	\
    ( (This)->lpVtbl -> get_accDescription(This,varChild,pszDescription) ) 

#define IAccessibleWinSAT_get_accRole(This,varChild,pvarRole)	\
    ( (This)->lpVtbl -> get_accRole(This,varChild,pvarRole) ) 

#define IAccessibleWinSAT_get_accState(This,varChild,pvarState)	\
    ( (This)->lpVtbl -> get_accState(This,varChild,pvarState) ) 

#define IAccessibleWinSAT_get_accHelp(This,varChild,pszHelp)	\
    ( (This)->lpVtbl -> get_accHelp(This,varChild,pszHelp) ) 

#define IAccessibleWinSAT_get_accHelpTopic(This,pszHelpFile,varChild,pidTopic)	\
    ( (This)->lpVtbl -> get_accHelpTopic(This,pszHelpFile,varChild,pidTopic) ) 

#define IAccessibleWinSAT_get_accKeyboardShortcut(This,varChild,pszKeyboardShortcut)	\
    ( (This)->lpVtbl -> get_accKeyboardShortcut(This,varChild,pszKeyboardShortcut) ) 

#define IAccessibleWinSAT_get_accFocus(This,pvarChild)	\
    ( (This)->lpVtbl -> get_accFocus(This,pvarChild) ) 

#define IAccessibleWinSAT_get_accSelection(This,pvarChildren)	\
    ( (This)->lpVtbl -> get_accSelection(This,pvarChildren) ) 

#define IAccessibleWinSAT_get_accDefaultAction(This,varChild,pszDefaultAction)	\
    ( (This)->lpVtbl -> get_accDefaultAction(This,varChild,pszDefaultAction) ) 

#define IAccessibleWinSAT_accSelect(This,flagsSelect,varChild)	\
    ( (This)->lpVtbl -> accSelect(This,flagsSelect,varChild) ) 

#define IAccessibleWinSAT_accLocation(This,pxLeft,pyTop,pcxWidth,pcyHeight,varChild)	\
    ( (This)->lpVtbl -> accLocation(This,pxLeft,pyTop,pcxWidth,pcyHeight,varChild) ) 

#define IAccessibleWinSAT_accNavigate(This,navDir,varStart,pvarEndUpAt)	\
    ( (This)->lpVtbl -> accNavigate(This,navDir,varStart,pvarEndUpAt) ) 

#define IAccessibleWinSAT_accHitTest(This,xLeft,yTop,pvarChild)	\
    ( (This)->lpVtbl -> accHitTest(This,xLeft,yTop,pvarChild) ) 

#define IAccessibleWinSAT_accDoDefaultAction(This,varChild)	\
    ( (This)->lpVtbl -> accDoDefaultAction(This,varChild) ) 

#define IAccessibleWinSAT_put_accName(This,varChild,szName)	\
    ( (This)->lpVtbl -> put_accName(This,varChild,szName) ) 

#define IAccessibleWinSAT_put_accValue(This,varChild,szValue)	\
    ( (This)->lpVtbl -> put_accValue(This,varChild,szValue) ) 


#define IAccessibleWinSAT_SetAccessiblityData(This,wsName,wsValue,wsDesc)	\
    ( (This)->lpVtbl -> SetAccessiblityData(This,wsName,wsValue,wsDesc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAccessibleWinSAT_INTERFACE_DEFINED__ */


#ifndef __IQueryOEMWinSATCustomization_INTERFACE_DEFINED__
#define __IQueryOEMWinSATCustomization_INTERFACE_DEFINED__

/* interface IQueryOEMWinSATCustomization */
/* [uuid][object] */ 


EXTERN_C const IID IID_IQueryOEMWinSATCustomization;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BC9A6A9F-AD4E-420e-9953-B34671E9DF22")
    IQueryOEMWinSATCustomization : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOEMPrePopulationInfo( 
            /* [retval][out] */ __RPC__out WINSAT_OEM_CUSTOMIZATION_STATE *state) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryOEMWinSATCustomizationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueryOEMWinSATCustomization * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueryOEMWinSATCustomization * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueryOEMWinSATCustomization * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOEMPrePopulationInfo )( 
            IQueryOEMWinSATCustomization * This,
            /* [retval][out] */ __RPC__out WINSAT_OEM_CUSTOMIZATION_STATE *state);
        
        END_INTERFACE
    } IQueryOEMWinSATCustomizationVtbl;

    interface IQueryOEMWinSATCustomization
    {
        CONST_VTBL struct IQueryOEMWinSATCustomizationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryOEMWinSATCustomization_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueryOEMWinSATCustomization_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueryOEMWinSATCustomization_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueryOEMWinSATCustomization_GetOEMPrePopulationInfo(This,state)	\
    ( (This)->lpVtbl -> GetOEMPrePopulationInfo(This,state) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueryOEMWinSATCustomization_INTERFACE_DEFINED__ */



#ifndef __WINSATLib_LIBRARY_DEFINED__
#define __WINSATLib_LIBRARY_DEFINED__

/* library WINSATLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WINSATLib;

EXTERN_C const CLSID CLSID_CWinSATTaskMangerTask;

#ifdef __cplusplus

class DECLSPEC_UUID("A9A33436-678B-4c9c-A211-7CC38785E79D")
CWinSATTaskMangerTask;
#endif

EXTERN_C const CLSID CLSID_CInitiateWinSAT;

#ifdef __cplusplus

class DECLSPEC_UUID("489331DC-F5E0-4528-9FDA-45331BF4A571")
CInitiateWinSAT;
#endif

EXTERN_C const CLSID CLSID_CQueryWinSAT;

#ifdef __cplusplus

class DECLSPEC_UUID("F3BDFAD3-F276-49e9-9B17-C474F48F0764")
CQueryWinSAT;
#endif

EXTERN_C const CLSID CLSID_CQueryAllWinSAT;

#ifdef __cplusplus

class DECLSPEC_UUID("05DF8D13-C355-47f4-A11E-851B338CEFB8")
CQueryAllWinSAT;
#endif

EXTERN_C const CLSID CLSID_CProvideWinSATVisuals;

#ifdef __cplusplus

class DECLSPEC_UUID("9F377D7E-E551-44f8-9F94-9DB392B03B7B")
CProvideWinSATVisuals;
#endif

EXTERN_C const CLSID CLSID_CAccessiblityWinSAT;

#ifdef __cplusplus

class DECLSPEC_UUID("6e18f9c6-a3eb-495a-89b7-956482e19f7a")
CAccessiblityWinSAT;
#endif

EXTERN_C const CLSID CLSID_CQueryOEMWinSATCustomization;

#ifdef __cplusplus

class DECLSPEC_UUID("C47A41B7-B729-424f-9AF9-5CB3934F2DFA")
CQueryOEMWinSATCustomization;
#endif
#endif /* __WINSATLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HBITMAP_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HBITMAP * ); 
void                      __RPC_USER  HBITMAP_UserFree(     __RPC__in unsigned long *, __RPC__in HBITMAP * ); 

unsigned long             __RPC_USER  HWND_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HBITMAP_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HBITMAP * ); 
void                      __RPC_USER  HBITMAP_UserFree64(     __RPC__in unsigned long *, __RPC__in HBITMAP * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WinSmCrd.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    winsmcrd.h

Abstract:
    Smart Card class/port IOCTL codes. This file is required for all code
    user mode and kernel mode, using Smart Card IOCTL's, defines,
    data structures

Revision History:

--*/


#ifndef _NTDDSCRD_H2_
#define _NTDDSCRD_H2_

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WINSCARD_H_
typedef DWORD ULONG;
typedef WORD UWORD;
typedef BYTE UCHAR;
#else
typedef ULONG DWORD;
// typedef UWORD WORD;
typedef UCHAR BYTE;
#endif

#ifndef DEVICE_TYPE_SMARTCARD
#define FILE_DEVICE_SMARTCARD           0x00000031
#else
#if 0x00000031 != FILE_DEVICE_SMARTCARD
#error "Incorrect Smart Card Device Definition"
#endif
#endif


//
// Various constants
//

#define SCARD_ATR_LENGTH 33  // ISO 7816-3 spec.

//
///////////////////////////////////////////////////////////////////////////////
//
//  Protocol Flag definitions
//

#define SCARD_PROTOCOL_UNDEFINED    0x00000000  // There is no active protocol.
#define SCARD_PROTOCOL_T0           0x00000001  // T=0 is the active protocol.
#define SCARD_PROTOCOL_T1           0x00000002  // T=1 is the active protocol.
#define SCARD_PROTOCOL_RAW          0x00010000  // Raw is the active protocol.
//
// This is the mask of ISO defined transmission protocols
//
#define SCARD_PROTOCOL_Tx           (SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1)
//
// Use the default transmission parameters / card clock freq.
//
#define SCARD_PROTOCOL_DEFAULT      0x80000000
//
// Use optimal transmission parameters / card clock freq.
// Since using the optimal parameters is the default case no bit is defined to be 1
//
#define SCARD_PROTOCOL_OPTIMAL      0x00000000


//
// Ioctl parameters 1 for IOCTL_SMARTCARD_POWER
//
#define SCARD_POWER_DOWN 0          // Power down the card.
#define SCARD_COLD_RESET 1          // Cycle power and reset the card.
#define SCARD_WARM_RESET 2          // Force a reset on the card.

//
///////////////////////////////////////////////////////////////////////////////
//
//  Reader Action IOCTLs
//

#define SCARD_CTL_CODE(code)        CTL_CODE(FILE_DEVICE_SMARTCARD, \
                                            (code), \
                                            METHOD_BUFFERED, \
                                            FILE_ANY_ACCESS)

#define IOCTL_SMARTCARD_POWER           SCARD_CTL_CODE( 1)
#define IOCTL_SMARTCARD_GET_ATTRIBUTE   SCARD_CTL_CODE( 2)
#define IOCTL_SMARTCARD_SET_ATTRIBUTE   SCARD_CTL_CODE( 3)
#define IOCTL_SMARTCARD_CONFISCATE      SCARD_CTL_CODE( 4)
#define IOCTL_SMARTCARD_TRANSMIT        SCARD_CTL_CODE( 5)
#define IOCTL_SMARTCARD_EJECT           SCARD_CTL_CODE( 6)
#define IOCTL_SMARTCARD_SWALLOW         SCARD_CTL_CODE( 7)
// #define IOCTL_SMARTCARD_READ            SCARD_CTL_CODE( 8) obsolete
// #define IOCTL_SMARTCARD_WRITE           SCARD_CTL_CODE( 9) obsolete
#define IOCTL_SMARTCARD_IS_PRESENT      SCARD_CTL_CODE(10)
#define IOCTL_SMARTCARD_IS_ABSENT       SCARD_CTL_CODE(11)
#define IOCTL_SMARTCARD_SET_PROTOCOL    SCARD_CTL_CODE(12)
#define IOCTL_SMARTCARD_GET_STATE       SCARD_CTL_CODE(14)
#define IOCTL_SMARTCARD_GET_LAST_ERROR  SCARD_CTL_CODE(15)
#define IOCTL_SMARTCARD_GET_PERF_CNTR   SCARD_CTL_CODE(16)


//
///////////////////////////////////////////////////////////////////////////////
//
// Tags for requesting card and reader attributes
//

#define MAXIMUM_ATTR_STRING_LENGTH 32   // Nothing bigger than this from getAttr
#define MAXIMUM_SMARTCARD_READERS  10   // Limit the readers on the system

#define SCARD_ATTR_VALUE(Class, Tag) ((((ULONG)(Class)) << 16) | ((ULONG)(Tag)))

#define SCARD_CLASS_VENDOR_INFO     1   // Vendor information definitions
#define SCARD_CLASS_COMMUNICATIONS  2   // Communication definitions
#define SCARD_CLASS_PROTOCOL        3   // Protocol definitions
#define SCARD_CLASS_POWER_MGMT      4   // Power Management definitions
#define SCARD_CLASS_SECURITY        5   // Security Assurance definitions
#define SCARD_CLASS_MECHANICAL      6   // Mechanical characteristic definitions
#define SCARD_CLASS_VENDOR_DEFINED  7   // Vendor specific definitions
#define SCARD_CLASS_IFD_PROTOCOL    8   // Interface Device Protocol options
#define SCARD_CLASS_ICC_STATE       9   // ICC State specific definitions
#define SCARD_CLASS_PERF       0x7ffe   // performace counters
#define SCARD_CLASS_SYSTEM     0x7fff   // System-specific definitions

#define SCARD_ATTR_VENDOR_NAME SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_INFO, 0x0100)
#define SCARD_ATTR_VENDOR_IFD_TYPE SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_INFO, 0x0101)
#define SCARD_ATTR_VENDOR_IFD_VERSION SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_INFO, 0x0102)
#define SCARD_ATTR_VENDOR_IFD_SERIAL_NO SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_INFO, 0x0103)
#define SCARD_ATTR_CHANNEL_ID SCARD_ATTR_VALUE(SCARD_CLASS_COMMUNICATIONS, 0x0110)
#define SCARD_ATTR_PROTOCOL_TYPES SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0120)
// #define SCARD_ATTR_ASYNC_PROTOCOL_TYPES SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0120)
#define SCARD_ATTR_DEFAULT_CLK SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0121)
#define SCARD_ATTR_MAX_CLK SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0122)
#define SCARD_ATTR_DEFAULT_DATA_RATE SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0123)
#define SCARD_ATTR_MAX_DATA_RATE SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0124)
#define SCARD_ATTR_MAX_IFSD SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0125)
// #define SCARD_ATTR_SYNC_PROTOCOL_TYPES SCARD_ATTR_VALUE(SCARD_CLASS_PROTOCOL, 0x0126)
#define SCARD_ATTR_POWER_MGMT_SUPPORT SCARD_ATTR_VALUE(SCARD_CLASS_POWER_MGMT, 0x0131)
#define SCARD_ATTR_USER_TO_CARD_AUTH_DEVICE SCARD_ATTR_VALUE(SCARD_CLASS_SECURITY, 0x0140)
#define SCARD_ATTR_USER_AUTH_INPUT_DEVICE SCARD_ATTR_VALUE(SCARD_CLASS_SECURITY, 0x0142)
#define SCARD_ATTR_CHARACTERISTICS SCARD_ATTR_VALUE(SCARD_CLASS_MECHANICAL, 0x0150)

#define SCARD_ATTR_CURRENT_PROTOCOL_TYPE SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0201)
#define SCARD_ATTR_CURRENT_CLK SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0202)
#define SCARD_ATTR_CURRENT_F SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0203)
#define SCARD_ATTR_CURRENT_D SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0204)
#define SCARD_ATTR_CURRENT_N SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0205)
#define SCARD_ATTR_CURRENT_W SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0206)
#define SCARD_ATTR_CURRENT_IFSC SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0207)
#define SCARD_ATTR_CURRENT_IFSD SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0208)
#define SCARD_ATTR_CURRENT_BWT SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x0209)
#define SCARD_ATTR_CURRENT_CWT SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x020a)
#define SCARD_ATTR_CURRENT_EBC_ENCODING SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x020b)
#define SCARD_ATTR_EXTENDED_BWT SCARD_ATTR_VALUE(SCARD_CLASS_IFD_PROTOCOL, 0x020c)

#define SCARD_ATTR_ICC_PRESENCE SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0300)
#define SCARD_ATTR_ICC_INTERFACE_STATUS SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0301)
#define SCARD_ATTR_CURRENT_IO_STATE SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0302)
#define SCARD_ATTR_ATR_STRING SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0303)
#define SCARD_ATTR_ICC_TYPE_PER_ATR SCARD_ATTR_VALUE(SCARD_CLASS_ICC_STATE, 0x0304)

#define SCARD_ATTR_ESC_RESET SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED, 0xA000)
#define SCARD_ATTR_ESC_CANCEL SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED, 0xA003)
#define SCARD_ATTR_ESC_AUTHREQUEST SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED, 0xA005)
#define SCARD_ATTR_MAXINPUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED, 0xA007)

#define SCARD_ATTR_DEVICE_UNIT SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0001)
#define SCARD_ATTR_DEVICE_IN_USE SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0002)
#define SCARD_ATTR_DEVICE_FRIENDLY_NAME_A SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0003)
#define SCARD_ATTR_DEVICE_SYSTEM_NAME_A SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0004)
#define SCARD_ATTR_DEVICE_FRIENDLY_NAME_W SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0005)
#define SCARD_ATTR_DEVICE_SYSTEM_NAME_W SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0006)
#define SCARD_ATTR_SUPRESS_T1_IFS_REQUEST SCARD_ATTR_VALUE(SCARD_CLASS_SYSTEM, 0x0007)

#define SCARD_PERF_NUM_TRANSMISSIONS SCARD_ATTR_VALUE(SCARD_CLASS_PERF, 0x0001)
#define SCARD_PERF_BYTES_TRANSMITTED SCARD_ATTR_VALUE(SCARD_CLASS_PERF, 0x0002)
#define SCARD_PERF_TRANSMISSION_TIME SCARD_ATTR_VALUE(SCARD_CLASS_PERF, 0x0003)

#ifdef UNICODE
#define SCARD_ATTR_DEVICE_FRIENDLY_NAME SCARD_ATTR_DEVICE_FRIENDLY_NAME_W
#define SCARD_ATTR_DEVICE_SYSTEM_NAME SCARD_ATTR_DEVICE_SYSTEM_NAME_W
#else
#define SCARD_ATTR_DEVICE_FRIENDLY_NAME SCARD_ATTR_DEVICE_FRIENDLY_NAME_A
#define SCARD_ATTR_DEVICE_SYSTEM_NAME SCARD_ATTR_DEVICE_SYSTEM_NAME_A
#endif


//
// T=0 Protocol Defines
//

#define SCARD_T0_HEADER_LENGTH 7
#define SCARD_T0_CMD_LENGTH 5


//
// T=1 Protocol Defines
//

#define SCARD_T1_PROLOGUE_LENGTH 3
#define SCARD_T1_EPILOGUE_LENGTH 2
#define SCARD_T1_MAX_IFS 254


//
///////////////////////////////////////////////////////////////////////////////
//
//  Reader states
//

#define SCARD_UNKNOWN     0   // This value implies the driver is unaware
                              // of the current state of the reader.
#define SCARD_ABSENT      1   // This value implies there is no card in
                              // the reader.
#define SCARD_PRESENT     2   // This value implies there is a card is
                              // present in the reader, but that it has
                              // not been moved into position for use.
#define SCARD_SWALLOWED   3   // This value implies there is a card in the
                              // reader in position for use.  The card is
                              // not powered.
#define SCARD_POWERED     4   // This value implies there is power is
                              // being provided to the card, but the
                              // Reader Driver is unaware of the mode of
                              // the card.
#define SCARD_NEGOTIABLE  5   // This value implies the card has been
                              // reset and is awaiting PTS negotiation.
#define SCARD_SPECIFIC    6   // This value implies the card has been
                              // reset and specific communication
                              // protocols have been established.

////////////////////////////////////////////////////////////////////////////////
//
//  I/O Services
//
//      The following services provide access to the I/O capabilities of the
//      reader drivers.  Services of the Smart Card are requested by placing the
//      following structure into the protocol buffer:
//


typedef struct _SCARD_IO_REQUEST{
    DWORD dwProtocol;   // Protocol identifier
    DWORD cbPciLength;  // Protocol Control Information Length
} SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;
typedef const SCARD_IO_REQUEST *LPCSCARD_IO_REQUEST;


//
// T=0 protocol services.
//

typedef struct {
    BYTE
        bCla,   // The instruction class
        bIns,   // The instruction code within the instruction class
        bP1,
        bP2,    // Parameters to the instruction
        bP3;    // Size of I/O Transfer
} SCARD_T0_COMMAND, *LPSCARD_T0_COMMAND;

typedef struct {
    SCARD_IO_REQUEST ioRequest;
    BYTE
        bSw1,
        bSw2;           // Return codes from the instruction
    union
    {
        SCARD_T0_COMMAND CmdBytes;
        BYTE rgbHeader[5];
    } DUMMYUNIONNAME;
} SCARD_T0_REQUEST;

typedef SCARD_T0_REQUEST *PSCARD_T0_REQUEST, *LPSCARD_T0_REQUEST;


//
//  T=1 Protocol Services
//

typedef struct {
    SCARD_IO_REQUEST ioRequest;
} SCARD_T1_REQUEST;
typedef SCARD_T1_REQUEST *PSCARD_T1_REQUEST, *LPSCARD_T1_REQUEST;


//
////////////////////////////////////////////////////////////////////////////////
//
//  Driver attribute flags
//

#define SCARD_READER_SWALLOWS       0x00000001  // Reader has a card swallowing
                                                // mechanism.
#define SCARD_READER_EJECTS         0x00000002  // Reader has a card ejection
                                                // mechanism.
#define SCARD_READER_CONFISCATES    0x00000004  // Reader has a card capture
                                                // mechanism.

//
///////////////////////////////////////////////////////////////////////////////
//
// Type of reader
//
#define SCARD_READER_TYPE_SERIAL    0x01
#define SCARD_READER_TYPE_PARALELL  0x02
#define SCARD_READER_TYPE_KEYBOARD  0x04
#define SCARD_READER_TYPE_SCSI      0x08
#define SCARD_READER_TYPE_IDE       0x10
#define SCARD_READER_TYPE_USB       0x20
#define SCARD_READER_TYPE_PCMCIA    0x40
#define SCARD_READER_TYPE_VENDOR    0xF0

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WinSCard.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    WinSCard

Abstract:

    This header file provides the definitions and symbols necessary for an
    Application or Smart Card Service Provider to access the Smartcard
    Subsystem.

Environment:

    Win32

Notes:

--*/

#ifndef _WINSCARD_H_
#define _WINSCARD_H_

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#include <wtypes.h>
#include <winioctl.h>
#include "winsmcrd.h"
#ifndef SCARD_S_SUCCESS
#include "SCardErr.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const BYTE *LPCBYTE;
#endif
#ifndef _LPCVOID_DEFINED
#define _LPCVOID_DEFINED
typedef const VOID *LPCVOID;
#endif

#ifndef WINSCARDAPI
#define WINSCARDAPI
#endif
#ifndef WINSCARDDATA
#define WINSCARDDATA __declspec(dllimport)
#endif

/* In clr:pure we cannot mark data export with dllimport.
 * We should add small functions which returns the value of
 * the global.
 */
#if !defined(_M_CEE_PURE)
WINSCARDDATA extern const SCARD_IO_REQUEST
    g_rgSCardT0Pci,
    g_rgSCardT1Pci,
    g_rgSCardRawPci;
#define SCARD_PCI_T0  (&g_rgSCardT0Pci)
#define SCARD_PCI_T1  (&g_rgSCardT1Pci)
#define SCARD_PCI_RAW (&g_rgSCardRawPci)
#endif

//
////////////////////////////////////////////////////////////////////////////////
//
//  Service Manager Access Services
//
//      The following services are used to manage user and terminal contexts for
//      Smart Cards.
//

typedef ULONG_PTR SCARDCONTEXT;
typedef SCARDCONTEXT *PSCARDCONTEXT, *LPSCARDCONTEXT;

typedef ULONG_PTR SCARDHANDLE;
typedef SCARDHANDLE *PSCARDHANDLE, *LPSCARDHANDLE;

#define SCARD_AUTOALLOCATE (DWORD)(-1)

#define SCARD_SCOPE_USER     0  // The context is a user context, and any
                                // database operations are performed within the
                                // domain of the user.
#define SCARD_SCOPE_TERMINAL 1  // The context is that of the current terminal,
                                // and any database operations are performed
                                // within the domain of that terminal.  (The
                                // calling application must have appropriate
                                // access permissions for any database actions.)
#define SCARD_SCOPE_SYSTEM    2 // The context is the system context, and any
                                // database operations are performed within the
                                // domain of the system.  (The calling
                                // application must have appropriate access
                                // permissions for any database actions.)

extern WINSCARDAPI LONG WINAPI
SCardEstablishContext(
    __in  DWORD dwScope,
    __reserved  LPCVOID pvReserved1,
    __reserved  LPCVOID pvReserved2,
    __out LPSCARDCONTEXT phContext);

extern WINSCARDAPI LONG WINAPI
SCardReleaseContext(
    __in      SCARDCONTEXT hContext);

extern WINSCARDAPI LONG WINAPI
SCardIsValidContext(
    __in      SCARDCONTEXT hContext);


//
////////////////////////////////////////////////////////////////////////////////
//
//  Smart Card Database Management Services
//
//      The following services provide for managing the Smart Card Database.
//

#define SCARD_ALL_READERS       TEXT("SCard$AllReaders\000")
#define SCARD_DEFAULT_READERS   TEXT("SCard$DefaultReaders\000")
#define SCARD_LOCAL_READERS     TEXT("SCard$LocalReaders\000")
#define SCARD_SYSTEM_READERS    TEXT("SCard$SystemReaders\000")

#define SCARD_PROVIDER_PRIMARY  1   // Primary Provider Id
#define SCARD_PROVIDER_CSP      2   // Crypto Service Provider Id
#define SCARD_PROVIDER_KSP      3   // Key Storage Provider Id


//
// Database Reader routines
//

extern WINSCARDAPI LONG WINAPI
SCardListReaderGroupsA(
    __in    SCARDCONTEXT hContext,
    __nullnullterminated __out_ecount_opt(*pcchGroups)   LPSTR mszGroups,
    __inout LPDWORD pcchGroups);
extern WINSCARDAPI LONG WINAPI
SCardListReaderGroupsW(
    __in    SCARDCONTEXT hContext,
    __nullnullterminated __out_ecount_opt(*pcchGroups)   LPWSTR mszGroups,
    __inout LPDWORD pcchGroups);
#ifdef UNICODE
#define SCardListReaderGroups  SCardListReaderGroupsW
#else
#define SCardListReaderGroups  SCardListReaderGroupsA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardListReadersA(
    __in     SCARDCONTEXT hContext,
    __in_opt LPCSTR mszGroups,
    __nullnullterminated __out_ecount_opt(*pcchReaders) LPSTR mszReaders,
    __inout  LPDWORD pcchReaders);
extern WINSCARDAPI LONG WINAPI
SCardListReadersW(
    __in     SCARDCONTEXT hContext,
    __in_opt LPCWSTR mszGroups,
    __nullnullterminated __out_ecount_opt(*pcchReaders) LPWSTR mszReaders,
    __inout  LPDWORD pcchReaders);
#ifdef UNICODE
#define SCardListReaders  SCardListReadersW
#else
#define SCardListReaders  SCardListReadersA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardListCardsA(
    __in      SCARDCONTEXT hContext,
    __in_opt  LPCBYTE pbAtr,
    __in_ecount_opt(cguidInterfaceCount)  LPCGUID rgquidInterfaces,
    __in      DWORD cguidInterfaceCount,
    __nullnullterminated __out_ecount_opt(*pcchCards) LPSTR mszCards,
    __inout   LPDWORD pcchCards);
extern WINSCARDAPI LONG WINAPI
SCardListCardsW(
    __in      SCARDCONTEXT hContext,
    __in_opt  LPCBYTE pbAtr,
    __in_ecount_opt(cguidInterfaceCount)  LPCGUID rgquidInterfaces,
    __in      DWORD cguidInterfaceCount,
    __nullnullterminated __out_ecount_opt(*pcchCards) LPWSTR mszCards,
    __inout   LPDWORD pcchCards);
#ifdef UNICODE
#define SCardListCards  SCardListCardsW
#else
#define SCardListCards  SCardListCardsA
#endif // !UNICODE
//
// NOTE:    The routine SCardListCards name differs from the PC/SC definition.
//          It should be:
//
//              extern WINSCARDAPI LONG WINAPI
//              SCardListCardTypes(
//                  __in      SCARDCONTEXT hContext,
//                  __in_opt  LPCBYTE pbAtr,
//                  __in_opt  LPCGUID rgquidInterfaces,
//                  __in      DWORD cguidInterfaceCount,
//                  __out_opt LPTSTR mszCards,
//                  __inout   LPDWORD pcchCards);
//
//          Here's a work-around MACRO:
#define SCardListCardTypes SCardListCards

extern WINSCARDAPI LONG WINAPI
SCardListInterfacesA(
    __in     SCARDCONTEXT hContext,
    __in     LPCSTR szCard,
    __out    LPGUID pguidInterfaces,
    __inout  LPDWORD pcguidInterfaces);
extern WINSCARDAPI LONG WINAPI
SCardListInterfacesW(
    __in     SCARDCONTEXT hContext,
    __in     LPCWSTR szCard,
    __out    LPGUID pguidInterfaces,
    __inout  LPDWORD pcguidInterfaces);
#ifdef UNICODE
#define SCardListInterfaces  SCardListInterfacesW
#else
#define SCardListInterfaces  SCardListInterfacesA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardGetProviderIdA(
    __in     SCARDCONTEXT hContext,
    __in     LPCSTR szCard,
    __out    LPGUID pguidProviderId);
extern WINSCARDAPI LONG WINAPI
SCardGetProviderIdW(
    __in     SCARDCONTEXT hContext,
    __in     LPCWSTR szCard,
    __out    LPGUID pguidProviderId);
#ifdef UNICODE
#define SCardGetProviderId  SCardGetProviderIdW
#else
#define SCardGetProviderId  SCardGetProviderIdA
#endif // !UNICODE
//
// NOTE:    The routine SCardGetProviderId in this implementation uses GUIDs.
//          The PC/SC definition uses BYTEs.
//

extern WINSCARDAPI LONG WINAPI
SCardGetCardTypeProviderNameA(
    __in      SCARDCONTEXT hContext,
    __in      LPCSTR szCardName,
    __in      DWORD dwProviderId,
    __out_ecount_opt(*pcchProvider) LPSTR szProvider,
    __inout   LPDWORD pcchProvider);
extern WINSCARDAPI LONG WINAPI
SCardGetCardTypeProviderNameW(
    __in      SCARDCONTEXT hContext,
    __in      LPCWSTR szCardName,
    __in      DWORD dwProviderId,
    __out_ecount_opt(*pcchProvider) LPWSTR szProvider,
    __inout   LPDWORD pcchProvider);
#ifdef UNICODE
#define SCardGetCardTypeProviderName  SCardGetCardTypeProviderNameW
#else
#define SCardGetCardTypeProviderName  SCardGetCardTypeProviderNameA
#endif // !UNICODE
//
// NOTE:    This routine is an extension to the PC/SC definitions.
//


//
// Database Writer routines
//

extern WINSCARDAPI LONG WINAPI
SCardIntroduceReaderGroupA(
    __in SCARDCONTEXT hContext,
    __in LPCSTR szGroupName);
extern WINSCARDAPI LONG WINAPI
SCardIntroduceReaderGroupW(
    __in SCARDCONTEXT hContext,
    __in LPCWSTR szGroupName);
#ifdef UNICODE
#define SCardIntroduceReaderGroup  SCardIntroduceReaderGroupW
#else
#define SCardIntroduceReaderGroup  SCardIntroduceReaderGroupA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardForgetReaderGroupA(
    __in SCARDCONTEXT hContext,
    __in LPCSTR szGroupName);
extern WINSCARDAPI LONG WINAPI
SCardForgetReaderGroupW(
    __in SCARDCONTEXT hContext,
    __in LPCWSTR szGroupName);
#ifdef UNICODE
#define SCardForgetReaderGroup  SCardForgetReaderGroupW
#else
#define SCardForgetReaderGroup  SCardForgetReaderGroupA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardIntroduceReaderA(
    __in SCARDCONTEXT hContext,
    __in LPCSTR szReaderName,
    __in LPCSTR szDeviceName);
extern WINSCARDAPI LONG WINAPI
SCardIntroduceReaderW(
    __in SCARDCONTEXT hContext,
    __in LPCWSTR szReaderName,
    __in LPCWSTR szDeviceName);
#ifdef UNICODE
#define SCardIntroduceReader  SCardIntroduceReaderW
#else
#define SCardIntroduceReader  SCardIntroduceReaderA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardForgetReaderA(
    __in SCARDCONTEXT hContext,
    __in LPCSTR szReaderName);
extern WINSCARDAPI LONG WINAPI
SCardForgetReaderW(
    __in SCARDCONTEXT hContext,
    __in LPCWSTR szReaderName);
#ifdef UNICODE
#define SCardForgetReader  SCardForgetReaderW
#else
#define SCardForgetReader  SCardForgetReaderA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardAddReaderToGroupA(
    __in SCARDCONTEXT hContext,
    __in LPCSTR szReaderName,
    __in LPCSTR szGroupName);
extern WINSCARDAPI LONG WINAPI
SCardAddReaderToGroupW(
    __in SCARDCONTEXT hContext,
    __in LPCWSTR szReaderName,
    __in LPCWSTR szGroupName);
#ifdef UNICODE
#define SCardAddReaderToGroup  SCardAddReaderToGroupW
#else
#define SCardAddReaderToGroup  SCardAddReaderToGroupA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardRemoveReaderFromGroupA(
    __in SCARDCONTEXT hContext,
    __in LPCSTR szReaderName,
    __in LPCSTR szGroupName);
extern WINSCARDAPI LONG WINAPI
SCardRemoveReaderFromGroupW(
    __in SCARDCONTEXT hContext,
    __in LPCWSTR szReaderName,
    __in LPCWSTR szGroupName);
#ifdef UNICODE
#define SCardRemoveReaderFromGroup  SCardRemoveReaderFromGroupW
#else
#define SCardRemoveReaderFromGroup  SCardRemoveReaderFromGroupA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardIntroduceCardTypeA(
    __in     SCARDCONTEXT hContext,
    __in     LPCSTR szCardName,
    __in_opt LPCGUID pguidPrimaryProvider,
    __in_opt LPCGUID rgguidInterfaces,
    __in     DWORD dwInterfaceCount,
    __in     LPCBYTE pbAtr,
    __in     LPCBYTE pbAtrMask,
    __in     DWORD cbAtrLen);
extern WINSCARDAPI LONG WINAPI
SCardIntroduceCardTypeW(
    __in     SCARDCONTEXT hContext,
    __in     LPCWSTR szCardName,
    __in_opt LPCGUID pguidPrimaryProvider,
    __in_opt LPCGUID rgguidInterfaces,
    __in     DWORD dwInterfaceCount,
    __in     LPCBYTE pbAtr,
    __in     LPCBYTE pbAtrMask,
    __in     DWORD cbAtrLen);
#ifdef UNICODE
#define SCardIntroduceCardType  SCardIntroduceCardTypeW
#else
#define SCardIntroduceCardType  SCardIntroduceCardTypeA
#endif // !UNICODE
//
// NOTE:    The routine SCardIntroduceCardType's parameters' order differs from
//          the PC/SC definition.  It should be:
//
//              extern WINSCARDAPI LONG WINAPI
//              SCardIntroduceCardType(
//                  __in     SCARDCONTEXT hContext,
//                  __in     LPCTSTR szCardName,
//                  __in     LPCBYTE pbAtr,
//                  __in     LPCBYTE pbAtrMask,
//                  __in     DWORD cbAtrLen,
//                  __in_opt LPCGUID pguidPrimaryProvider,
//                  __in_opt LPCGUID rgguidInterfaces,
//                  __in     DWORD dwInterfaceCount);
//
//          Here's a work-around MACRO:
#define PCSCardIntroduceCardType(hContext, szCardName, pbAtr, pbAtrMask, cbAtrLen, pguidPrimaryProvider, rgguidInterfaces, dwInterfaceCount) \
          SCardIntroduceCardType(hContext, szCardName, pguidPrimaryProvider, rgguidInterfaces, dwInterfaceCount, pbAtr, pbAtrMask, cbAtrLen)

extern WINSCARDAPI LONG WINAPI
SCardSetCardTypeProviderNameA(
    __in SCARDCONTEXT hContext,
    __in LPCSTR szCardName,
    __in DWORD dwProviderId,
    __in LPCSTR szProvider);
extern WINSCARDAPI LONG WINAPI
SCardSetCardTypeProviderNameW(
    __in SCARDCONTEXT hContext,
    __in LPCWSTR szCardName,
    __in DWORD dwProviderId,
    __in LPCWSTR szProvider);
#ifdef UNICODE
#define SCardSetCardTypeProviderName  SCardSetCardTypeProviderNameW
#else
#define SCardSetCardTypeProviderName  SCardSetCardTypeProviderNameA
#endif // !UNICODE
//
// NOTE:    This routine is an extention to the PC/SC specifications.
//

extern WINSCARDAPI LONG WINAPI
SCardForgetCardTypeA(
    __in SCARDCONTEXT hContext,
    __in LPCSTR szCardName);
extern WINSCARDAPI LONG WINAPI
SCardForgetCardTypeW(
    __in SCARDCONTEXT hContext,
    __in LPCWSTR szCardName);
#ifdef UNICODE
#define SCardForgetCardType  SCardForgetCardTypeW
#else
#define SCardForgetCardType  SCardForgetCardTypeA
#endif // !UNICODE


//
////////////////////////////////////////////////////////////////////////////////
//
//  Service Manager Support Routines
//
//      The following services are supplied to simplify the use of the Service
//      Manager API.
//

extern WINSCARDAPI LONG WINAPI
SCardFreeMemory(
    __in SCARDCONTEXT hContext,
    __in LPCVOID pvMem);

#if (NTDDI_VERSION >= NTDDI_WINXP)
extern WINSCARDAPI HANDLE WINAPI
SCardAccessStartedEvent(void);

extern WINSCARDAPI void WINAPI
SCardReleaseStartedEvent(void);
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Services
//
//      The following services supply means for tracking cards within readers.
//

typedef struct {
    LPCSTR      szReader;       // reader name
    LPVOID      pvUserData;     // user defined data
    DWORD       dwCurrentState; // current state of reader at time of call
    DWORD       dwEventState;   // state of reader after state change
    DWORD       cbAtr;          // Number of bytes in the returned ATR.
    BYTE        rgbAtr[36];     // Atr of inserted card, (extra alignment bytes)
} SCARD_READERSTATEA, *PSCARD_READERSTATEA, *LPSCARD_READERSTATEA;
typedef struct {
    LPCWSTR     szReader;       // reader name
    LPVOID      pvUserData;     // user defined data
    DWORD       dwCurrentState; // current state of reader at time of call
    DWORD       dwEventState;   // state of reader after state change
    DWORD       cbAtr;          // Number of bytes in the returned ATR.
    BYTE        rgbAtr[36];     // Atr of inserted card, (extra alignment bytes)
} SCARD_READERSTATEW, *PSCARD_READERSTATEW, *LPSCARD_READERSTATEW;
#ifdef UNICODE
typedef SCARD_READERSTATEW SCARD_READERSTATE;
typedef PSCARD_READERSTATEW PSCARD_READERSTATE;
typedef LPSCARD_READERSTATEW LPSCARD_READERSTATE;
#else
typedef SCARD_READERSTATEA SCARD_READERSTATE;
typedef PSCARD_READERSTATEA PSCARD_READERSTATE;
typedef LPSCARD_READERSTATEA LPSCARD_READERSTATE;
#endif // UNICODE

// Backwards compatibility macros
#define SCARD_READERSTATE_A SCARD_READERSTATEA
#define SCARD_READERSTATE_W SCARD_READERSTATEW
#define PSCARD_READERSTATE_A PSCARD_READERSTATEA
#define PSCARD_READERSTATE_W PSCARD_READERSTATEW
#define LPSCARD_READERSTATE_A LPSCARD_READERSTATEA
#define LPSCARD_READERSTATE_W LPSCARD_READERSTATEW

#define SCARD_STATE_UNAWARE     0x00000000  // The application is unaware of the
                                            // current state, and would like to
                                            // know.  The use of this value
                                            // results in an immediate return
                                            // from state transition monitoring
                                            // services.  This is represented by
                                            // all bits set to zero.
#define SCARD_STATE_IGNORE      0x00000001  // The application requested that
                                            // this reader be ignored.  No other
                                            // bits will be set.
#define SCARD_STATE_CHANGED     0x00000002  // This implies that there is a
                                            // difference between the state
                                            // believed by the application, and
                                            // the state known by the Service
                                            // Manager.  When this bit is set,
                                            // the application may assume a
                                            // significant state change has
                                            // occurred on this reader.
#define SCARD_STATE_UNKNOWN     0x00000004  // This implies that the given
                                            // reader name is not recognized by
                                            // the Service Manager.  If this bit
                                            // is set, then SCARD_STATE_CHANGED
                                            // and SCARD_STATE_IGNORE will also
                                            // be set.
#define SCARD_STATE_UNAVAILABLE 0x00000008  // This implies that the actual
                                            // state of this reader is not
                                            // available.  If this bit is set,
                                            // then all the following bits are
                                            // clear.
#define SCARD_STATE_EMPTY       0x00000010  // This implies that there is not
                                            // card in the reader.  If this bit
                                            // is set, all the following bits
                                            // will be clear.
#define SCARD_STATE_PRESENT     0x00000020  // This implies that there is a card
                                            // in the reader.
#define SCARD_STATE_ATRMATCH    0x00000040  // This implies that there is a card
                                            // in the reader with an ATR
                                            // matching one of the target cards.
                                            // If this bit is set,
                                            // SCARD_STATE_PRESENT will also be
                                            // set.  This bit is only returned
                                            // on the SCardLocateCard() service.
#define SCARD_STATE_EXCLUSIVE   0x00000080  // This implies that the card in the
                                            // reader is allocated for exclusive
                                            // use by another application.  If
                                            // this bit is set,
                                            // SCARD_STATE_PRESENT will also be
                                            // set.
#define SCARD_STATE_INUSE       0x00000100  // This implies that the card in the
                                            // reader is in use by one or more
                                            // other applications, but may be
                                            // connected to in shared mode.  If
                                            // this bit is set,
                                            // SCARD_STATE_PRESENT will also be
                                            // set.
#define SCARD_STATE_MUTE        0x00000200  // This implies that the card in the
                                            // reader is unresponsive or not
                                            // supported by the reader or
                                            // software.
#define SCARD_STATE_UNPOWERED   0x00000400  // This implies that the card in the
                                            // reader has not been powered up.

extern WINSCARDAPI LONG WINAPI
SCardLocateCardsA(
    __in    SCARDCONTEXT hContext,
    __in    LPCSTR mszCards,
    __inout LPSCARD_READERSTATEA rgReaderStates,
    __in    DWORD cReaders);
extern WINSCARDAPI LONG WINAPI
SCardLocateCardsW(
    __in    SCARDCONTEXT hContext,
    __in    LPCWSTR mszCards,
    __inout LPSCARD_READERSTATEW rgReaderStates,
    __in    DWORD cReaders);
#ifdef UNICODE
#define SCardLocateCards  SCardLocateCardsW
#else
#define SCardLocateCards  SCardLocateCardsA
#endif // !UNICODE

#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef struct _SCARD_ATRMASK {
    DWORD       cbAtr;          // Number of bytes in the ATR and the mask.
    BYTE        rgbAtr[36];     // Atr of card (extra alignment bytes)
    BYTE        rgbMask[36];    // Mask for the Atr (extra alignment bytes)
} SCARD_ATRMASK, *PSCARD_ATRMASK, *LPSCARD_ATRMASK;


extern WINSCARDAPI LONG WINAPI
SCardLocateCardsByATRA(
    __in    SCARDCONTEXT hContext,
    __in    LPSCARD_ATRMASK rgAtrMasks,
    __in    DWORD cAtrs,
    __inout LPSCARD_READERSTATEA rgReaderStates,
    __in    DWORD cReaders);
extern WINSCARDAPI LONG WINAPI
SCardLocateCardsByATRW(
    __in    SCARDCONTEXT hContext,
    __in    LPSCARD_ATRMASK rgAtrMasks,
    __in    DWORD cAtrs,
    __inout LPSCARD_READERSTATEW rgReaderStates,
    __in    DWORD cReaders);
#ifdef UNICODE
#define SCardLocateCardsByATR  SCardLocateCardsByATRW
#else
#define SCardLocateCardsByATR  SCardLocateCardsByATRA
#endif // !UNICODE
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

extern WINSCARDAPI LONG WINAPI
SCardGetStatusChangeA(
    __in    SCARDCONTEXT hContext,
    __in    DWORD dwTimeout,
    __inout LPSCARD_READERSTATEA rgReaderStates,
    __in    DWORD cReaders);
extern WINSCARDAPI LONG WINAPI
SCardGetStatusChangeW(
    __in    SCARDCONTEXT hContext,
    __in    DWORD dwTimeout,
    __inout LPSCARD_READERSTATEW rgReaderStates,
    __in    DWORD cReaders);
#ifdef UNICODE
#define SCardGetStatusChange  SCardGetStatusChangeW
#else
#define SCardGetStatusChange  SCardGetStatusChangeA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardCancel(
    __in    SCARDCONTEXT hContext);


//
////////////////////////////////////////////////////////////////////////////////
//
//  Card/Reader Communication Services
//
//      The following services provide means for communication with the card.
//

#define SCARD_SHARE_EXCLUSIVE 1 // This application is not willing to share this
                                // card with other applications.
#define SCARD_SHARE_SHARED    2 // This application is willing to share this
                                // card with other applications.
#define SCARD_SHARE_DIRECT    3 // This application demands direct control of
                                // the reader, so it is not available to other
                                // applications.

#define SCARD_LEAVE_CARD      0 // Don't do anything special on close
#define SCARD_RESET_CARD      1 // Reset the card on close
#define SCARD_UNPOWER_CARD    2 // Power down the card on close
#define SCARD_EJECT_CARD      3 // Eject the card on close

extern WINSCARDAPI LONG WINAPI
SCardConnectA(
    __in    SCARDCONTEXT hContext,
    __in    LPCSTR szReader,
    __in    DWORD dwShareMode,
    __in    DWORD dwPreferredProtocols,
    __out   LPSCARDHANDLE phCard,
    __out   LPDWORD pdwActiveProtocol);
extern WINSCARDAPI LONG WINAPI
SCardConnectW(
    __in    SCARDCONTEXT hContext,
    __in    LPCWSTR szReader,
    __in    DWORD dwShareMode,
    __in    DWORD dwPreferredProtocols,
    __out   LPSCARDHANDLE phCard,
    __out   LPDWORD pdwActiveProtocol);
#ifdef UNICODE
#define SCardConnect  SCardConnectW
#else
#define SCardConnect  SCardConnectA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardReconnect(
    __in      SCARDHANDLE hCard,
    __in      DWORD dwShareMode,
    __in      DWORD dwPreferredProtocols,
    __in      DWORD dwInitialization,
    __out_opt LPDWORD pdwActiveProtocol);

extern WINSCARDAPI LONG WINAPI
SCardDisconnect(
    __in    SCARDHANDLE hCard,
    __in    DWORD dwDisposition);

extern WINSCARDAPI LONG WINAPI
SCardBeginTransaction(
    __in    SCARDHANDLE hCard);

extern WINSCARDAPI LONG WINAPI
SCardEndTransaction(
    __in    SCARDHANDLE hCard,
    __in    DWORD dwDisposition);

extern WINSCARDAPI LONG WINAPI
SCardCancelTransaction(
    __in    SCARDHANDLE hCard);
//
// NOTE:    This call corresponds to the PC/SC SCARDCOMM::Cancel routine,
//          terminating a blocked SCardBeginTransaction service.
//


extern WINSCARDAPI LONG WINAPI
SCardState(
    __in    SCARDHANDLE hCard,
    __out   LPDWORD pdwState,
    __out   LPDWORD pdwProtocol,
    __out_bcount(*pcbAtrLen)   LPBYTE pbAtr,
    __inout LPDWORD pcbAtrLen);
//
// NOTE:    SCardState is an obsolete routine.  PC/SC has replaced it with
//          SCardStatus.
//

extern WINSCARDAPI LONG WINAPI
SCardStatusA(
    __in        SCARDHANDLE hCard,
    __nullnullterminated __out_ecount_opt(*pcchReaderLen) LPSTR mszReaderNames,
    __inout_opt LPDWORD pcchReaderLen,
    __out_opt   LPDWORD pdwState,
    __out_opt   LPDWORD pdwProtocol,
    __out_ecount_opt(*pcbAtrLen) LPBYTE pbAtr,
    __inout_opt LPDWORD pcbAtrLen);
extern WINSCARDAPI LONG WINAPI
SCardStatusW(
    __in        SCARDHANDLE hCard,
    __nullnullterminated __out_ecount_opt(*pcchReaderLen) LPWSTR mszReaderNames,
    __inout_opt LPDWORD pcchReaderLen,
    __out_opt   LPDWORD pdwState,
    __out_opt   LPDWORD pdwProtocol,
    __out_ecount_opt(*pcbAtrLen) LPBYTE pbAtr,
    __inout_opt LPDWORD pcbAtrLen);
#ifdef UNICODE
#define SCardStatus  SCardStatusW
#else
#define SCardStatus  SCardStatusA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardTransmit(
    __in        SCARDHANDLE hCard,
    __in        LPCSCARD_IO_REQUEST pioSendPci,
    __in_bcount(cbSendLength) LPCBYTE pbSendBuffer,
    __in        DWORD cbSendLength,
    __inout_opt LPSCARD_IO_REQUEST pioRecvPci,
    __out_bcount(*pcbRecvLength) LPBYTE pbRecvBuffer,
    __inout     LPDWORD pcbRecvLength);

#if (NTDDI_VERSION >= NTDDI_VISTA)
extern WINSCARDAPI LONG WINAPI
SCardGetTransmitCount(
    __in SCARDHANDLE hCard,
    __out LPDWORD pcTransmitCount);
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Control Routines
//
//      The following services provide for direct, low-level manipulation of the
//      reader by the calling application allowing it control over the
//      attributes of the communications with the card.
//

extern WINSCARDAPI LONG WINAPI
SCardControl(
    __in    SCARDHANDLE hCard,
    __in    DWORD dwControlCode,
    __in_bcount(cbInBufferSize) LPCVOID lpInBuffer,
    __in    DWORD cbInBufferSize,
    __out_bcount(cbOutBufferSize) LPVOID lpOutBuffer,
    __in    DWORD cbOutBufferSize,
    __out   LPDWORD lpBytesReturned);

extern WINSCARDAPI LONG WINAPI
SCardGetAttrib(
    __in    SCARDHANDLE hCard,
    __in    DWORD dwAttrId,
    __out_bcount_opt(*pcbAttrLen) LPBYTE pbAttr,
    __inout LPDWORD pcbAttrLen);
//
// NOTE:    The routine SCardGetAttrib's name differs from the PC/SC definition.
//          It should be:
//
//              extern WINSCARDAPI LONG WINAPI
//              SCardGetReaderCapabilities(
//                  __in    SCARDHANDLE hCard,
//                  __in    DWORD dwTag,
//                  __out   LPBYTE pbAttr,
//                  __inout LPDWORD pcbAttrLen);
//
//          Here's a work-around MACRO:
#define SCardGetReaderCapabilities SCardGetAttrib

extern WINSCARDAPI LONG WINAPI
SCardSetAttrib(
    __in SCARDHANDLE hCard,
    __in DWORD dwAttrId,
    __in_bcount(cbAttrLen) LPCBYTE pbAttr,
    __in DWORD cbAttrLen);
//
// NOTE:    The routine SCardSetAttrib's name differs from the PC/SC definition.
//          It should be:
//
//              extern WINSCARDAPI LONG WINAPI
//              SCardSetReaderCapabilities(
//                  __in    SCARDHANDLE hCard,
//                  __in    DWORD dwTag,
//                  __in    LPCBYTE pbAttr,
//                  __in    DWORD cbAttrLen);
//
//          Here's a work-around MACRO:
#define SCardSetReaderCapabilities SCardSetAttrib


//
////////////////////////////////////////////////////////////////////////////////
//
//  Smart Card Dialog definitions
//
//      The following section contains structures and  exported function
//      declarations for the Smart Card Common Dialog dialog.
//

// Defined constants
// Flags
#define SC_DLG_MINIMAL_UI       0x01
#define SC_DLG_NO_UI            0x02
#define SC_DLG_FORCE_UI         0x04

#define SCERR_NOCARDNAME        0x4000
#define SCERR_NOGUIDS           0x8000

typedef SCARDHANDLE (WINAPI *LPOCNCONNPROCA) (__in SCARDCONTEXT, __in LPSTR, __in LPSTR, __in PVOID);
typedef SCARDHANDLE (WINAPI *LPOCNCONNPROCW) (__in SCARDCONTEXT, __in LPWSTR, __in LPWSTR, __in PVOID);
#ifdef UNICODE
#define LPOCNCONNPROC  LPOCNCONNPROCW
#else
#define LPOCNCONNPROC  LPOCNCONNPROCA
#endif // !UNICODE
typedef BOOL (WINAPI *LPOCNCHKPROC) (__in SCARDCONTEXT, __in SCARDHANDLE, __in PVOID);
typedef void (WINAPI *LPOCNDSCPROC) (__in SCARDCONTEXT, __in SCARDHANDLE, __in PVOID);


//
// OPENCARD_SEARCH_CRITERIA: In order to specify a user-extended search,
// lpfnCheck must not be NULL.  Moreover, the connection to be made to the
// card before performing the callback must be indicated by either providing
// lpfnConnect and lpfnDisconnect OR by setting dwShareMode.
// If both the connection callbacks and dwShareMode are non-NULL, the callbacks
// will be used.
//

typedef struct {
    DWORD           dwStructSize;
    LPSTR           lpstrGroupNames;        // OPTIONAL reader groups to include in
    DWORD           nMaxGroupNames;         //          search.  NULL defaults to
                                            //          SCard$DefaultReaders
    LPCGUID         rgguidInterfaces;       // OPTIONAL requested interfaces
    DWORD           cguidInterfaces;        //          supported by card's SSP
    LPSTR           lpstrCardNames;         // OPTIONAL requested card names; all cards w/
    DWORD           nMaxCardNames;          //          matching ATRs will be accepted
    LPOCNCHKPROC    lpfnCheck;              // OPTIONAL if NULL no user check will be performed.
    LPOCNCONNPROCA  lpfnConnect;            // OPTIONAL if lpfnConnect is provided,
    LPOCNDSCPROC    lpfnDisconnect;         //          lpfnDisconnect must also be set.
    LPVOID          pvUserData;             // OPTIONAL parameter to callbacks
    DWORD           dwShareMode;            // OPTIONAL must be set if lpfnCheck is not null
    DWORD           dwPreferredProtocols;   // OPTIONAL
} OPENCARD_SEARCH_CRITERIAA, *POPENCARD_SEARCH_CRITERIAA, *LPOPENCARD_SEARCH_CRITERIAA;
typedef struct {
    DWORD           dwStructSize;
    LPWSTR          lpstrGroupNames;        // OPTIONAL reader groups to include in
    DWORD           nMaxGroupNames;         //          search.  NULL defaults to
                                            //          SCard$DefaultReaders
    LPCGUID         rgguidInterfaces;       // OPTIONAL requested interfaces
    DWORD           cguidInterfaces;        //          supported by card's SSP
    LPWSTR          lpstrCardNames;         // OPTIONAL requested card names; all cards w/
    DWORD           nMaxCardNames;          //          matching ATRs will be accepted
    LPOCNCHKPROC    lpfnCheck;              // OPTIONAL if NULL no user check will be performed.
    LPOCNCONNPROCW  lpfnConnect;            // OPTIONAL if lpfnConnect is provided,
    LPOCNDSCPROC    lpfnDisconnect;         //          lpfnDisconnect must also be set.
    LPVOID          pvUserData;             // OPTIONAL parameter to callbacks
    DWORD           dwShareMode;            // OPTIONAL must be set if lpfnCheck is not null
    DWORD           dwPreferredProtocols;   // OPTIONAL
} OPENCARD_SEARCH_CRITERIAW, *POPENCARD_SEARCH_CRITERIAW, *LPOPENCARD_SEARCH_CRITERIAW;
#ifdef UNICODE
typedef OPENCARD_SEARCH_CRITERIAW OPENCARD_SEARCH_CRITERIA;
typedef POPENCARD_SEARCH_CRITERIAW POPENCARD_SEARCH_CRITERIA;
typedef LPOPENCARD_SEARCH_CRITERIAW LPOPENCARD_SEARCH_CRITERIA;
#else
typedef OPENCARD_SEARCH_CRITERIAA OPENCARD_SEARCH_CRITERIA;
typedef POPENCARD_SEARCH_CRITERIAA POPENCARD_SEARCH_CRITERIA;
typedef LPOPENCARD_SEARCH_CRITERIAA LPOPENCARD_SEARCH_CRITERIA;
#endif // UNICODE


//
// OPENCARDNAME_EX: used by SCardUIDlgSelectCard; replaces obsolete OPENCARDNAME
//

typedef struct {
    DWORD           dwStructSize;           // REQUIRED
    SCARDCONTEXT    hSCardContext;          // REQUIRED
    HWND            hwndOwner;              // OPTIONAL
    DWORD           dwFlags;                // OPTIONAL -- default is SC_DLG_MINIMAL_UI
    LPCSTR          lpstrTitle;             // OPTIONAL
    LPCSTR          lpstrSearchDesc;        // OPTIONAL (eg. "Please insert your <brandname> smart card.")
    HICON           hIcon;                  // OPTIONAL 32x32 icon for your brand insignia
    POPENCARD_SEARCH_CRITERIAA pOpenCardSearchCriteria; // OPTIONAL
    LPOCNCONNPROCA  lpfnConnect;            // OPTIONAL - performed on successful selection
    LPVOID          pvUserData;             // OPTIONAL parameter to lpfnConnect
    DWORD           dwShareMode;            // OPTIONAL - if lpfnConnect is NULL, dwShareMode and
    DWORD           dwPreferredProtocols;   // OPTIONAL dwPreferredProtocols will be used to
                                            //          connect to the selected card
    LPSTR           lpstrRdr;               // REQUIRED [IN|OUT] Name of selected reader
    DWORD           nMaxRdr;                // REQUIRED [IN|OUT]
    LPSTR           lpstrCard;              // REQUIRED [IN|OUT] Name of selected card
    DWORD           nMaxCard;               // REQUIRED [IN|OUT]
    DWORD           dwActiveProtocol;       // [OUT] set only if dwShareMode not NULL
    SCARDHANDLE     hCardHandle;            // [OUT] set if a card connection was indicated
} OPENCARDNAME_EXA, *POPENCARDNAME_EXA, *LPOPENCARDNAME_EXA;
typedef struct {
    DWORD           dwStructSize;           // REQUIRED
    SCARDCONTEXT    hSCardContext;          // REQUIRED
    HWND            hwndOwner;              // OPTIONAL
    DWORD           dwFlags;                // OPTIONAL -- default is SC_DLG_MINIMAL_UI
    LPCWSTR         lpstrTitle;             // OPTIONAL
    LPCWSTR         lpstrSearchDesc;        // OPTIONAL (eg. "Please insert your <brandname> smart card.")
    HICON           hIcon;                  // OPTIONAL 32x32 icon for your brand insignia
    POPENCARD_SEARCH_CRITERIAW pOpenCardSearchCriteria; // OPTIONAL
    LPOCNCONNPROCW  lpfnConnect;            // OPTIONAL - performed on successful selection
    LPVOID          pvUserData;             // OPTIONAL parameter to lpfnConnect
    DWORD           dwShareMode;            // OPTIONAL - if lpfnConnect is NULL, dwShareMode and
    DWORD           dwPreferredProtocols;   // OPTIONAL dwPreferredProtocols will be used to
                                            //          connect to the selected card
    LPWSTR          lpstrRdr;               // REQUIRED [IN|OUT] Name of selected reader
    DWORD           nMaxRdr;                // REQUIRED [IN|OUT]
    LPWSTR          lpstrCard;              // REQUIRED [IN|OUT] Name of selected card
    DWORD           nMaxCard;               // REQUIRED [IN|OUT]
    DWORD           dwActiveProtocol;       // [OUT] set only if dwShareMode not NULL
    SCARDHANDLE     hCardHandle;            // [OUT] set if a card connection was indicated
} OPENCARDNAME_EXW, *POPENCARDNAME_EXW, *LPOPENCARDNAME_EXW;
#ifdef UNICODE
typedef OPENCARDNAME_EXW OPENCARDNAME_EX;
typedef POPENCARDNAME_EXW POPENCARDNAME_EX;
typedef LPOPENCARDNAME_EXW LPOPENCARDNAME_EX;
#else
typedef OPENCARDNAME_EXA OPENCARDNAME_EX;
typedef POPENCARDNAME_EXA POPENCARDNAME_EX;
typedef LPOPENCARDNAME_EXA LPOPENCARDNAME_EX;
#endif // UNICODE

#define OPENCARDNAMEA_EX OPENCARDNAME_EXA
#define OPENCARDNAMEW_EX OPENCARDNAME_EXW
#define POPENCARDNAMEA_EX POPENCARDNAME_EXA
#define POPENCARDNAMEW_EX POPENCARDNAME_EXW
#define LPOPENCARDNAMEA_EX LPOPENCARDNAME_EXA
#define LPOPENCARDNAMEW_EX LPOPENCARDNAME_EXW


//
// SCardUIDlgSelectCard replaces GetOpenCardName
//

extern WINSCARDAPI LONG WINAPI
SCardUIDlgSelectCardA(
    LPOPENCARDNAMEA_EX);
extern WINSCARDAPI LONG WINAPI
SCardUIDlgSelectCardW(
    LPOPENCARDNAMEW_EX);
#ifdef UNICODE
#define SCardUIDlgSelectCard  SCardUIDlgSelectCardW
#else
#define SCardUIDlgSelectCard  SCardUIDlgSelectCardA
#endif // !UNICODE


//
// "Smart Card Common Dialog" definitions for backwards compatibility
//  with the Smart Card Base Services SDK version 1.0
//

typedef struct {
    DWORD           dwStructSize;
    HWND            hwndOwner;
    SCARDCONTEXT    hSCardContext;
    LPSTR           lpstrGroupNames;
    DWORD           nMaxGroupNames;
    LPSTR           lpstrCardNames;
    DWORD           nMaxCardNames;
    LPCGUID         rgguidInterfaces;
    DWORD           cguidInterfaces;
    LPSTR           lpstrRdr;
    DWORD           nMaxRdr;
    LPSTR           lpstrCard;
    DWORD           nMaxCard;
    LPCSTR          lpstrTitle;
    DWORD           dwFlags;
    LPVOID          pvUserData;
    DWORD           dwShareMode;
    DWORD           dwPreferredProtocols;
    DWORD           dwActiveProtocol;
    LPOCNCONNPROCA  lpfnConnect;
    LPOCNCHKPROC    lpfnCheck;
    LPOCNDSCPROC    lpfnDisconnect;
    SCARDHANDLE     hCardHandle;
} OPENCARDNAMEA, *POPENCARDNAMEA, *LPOPENCARDNAMEA;
typedef struct {
    DWORD           dwStructSize;
    HWND            hwndOwner;
    SCARDCONTEXT    hSCardContext;
    LPWSTR          lpstrGroupNames;
    DWORD           nMaxGroupNames;
    LPWSTR          lpstrCardNames;
    DWORD           nMaxCardNames;
    LPCGUID         rgguidInterfaces;
    DWORD           cguidInterfaces;
    LPWSTR          lpstrRdr;
    DWORD           nMaxRdr;
    LPWSTR          lpstrCard;
    DWORD           nMaxCard;
    LPCWSTR         lpstrTitle;
    DWORD           dwFlags;
    LPVOID          pvUserData;
    DWORD           dwShareMode;
    DWORD           dwPreferredProtocols;
    DWORD           dwActiveProtocol;
    LPOCNCONNPROCW  lpfnConnect;
    LPOCNCHKPROC    lpfnCheck;
    LPOCNDSCPROC    lpfnDisconnect;
    SCARDHANDLE     hCardHandle;
} OPENCARDNAMEW, *POPENCARDNAMEW, *LPOPENCARDNAMEW;
#ifdef UNICODE
typedef OPENCARDNAMEW OPENCARDNAME;
typedef POPENCARDNAMEW POPENCARDNAME;
typedef LPOPENCARDNAMEW LPOPENCARDNAME;
#else
typedef OPENCARDNAMEA OPENCARDNAME;
typedef POPENCARDNAMEA POPENCARDNAME;
typedef LPOPENCARDNAMEA LPOPENCARDNAME;
#endif // UNICODE

// Backwards compatibility macros
#define OPENCARDNAME_A OPENCARDNAMEA
#define OPENCARDNAME_W OPENCARDNAMEW
#define POPENCARDNAME_A POPENCARDNAMEA
#define POPENCARDNAME_W POPENCARDNAMEW
#define LPOPENCARDNAME_A LPOPENCARDNAMEA
#define LPOPENCARDNAME_W LPOPENCARDNAMEW

extern WINSCARDAPI LONG WINAPI
GetOpenCardNameA(
    LPOPENCARDNAMEA);
extern WINSCARDAPI LONG WINAPI
GetOpenCardNameW(
    LPOPENCARDNAMEW);
#ifdef UNICODE
#define GetOpenCardName  GetOpenCardNameW
#else
#define GetOpenCardName  GetOpenCardNameA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardDlgExtendedError (void);

#if (NTDDI_VERSION >= NTDDI_VISTA)

//
// Smartcard Caching API
//

extern WINSCARDAPI LONG WINAPI
SCardReadCacheA(
    __in  SCARDCONTEXT hContext,
    __in  UUID *CardIdentifier,
    __in  DWORD FreshnessCounter,
    __in  LPSTR LookupName,
    __out_bcount(*DataLen) PBYTE Data,
    __out DWORD *DataLen);
extern WINSCARDAPI LONG WINAPI
SCardReadCacheW(
    __in  SCARDCONTEXT hContext,
    __in  UUID *CardIdentifier,
    __in  DWORD FreshnessCounter,
    __in  LPWSTR LookupName,
    __out_bcount(*DataLen) PBYTE Data,
    __out DWORD *DataLen);
#ifdef UNICODE
#define SCardReadCache  SCardReadCacheW
#else
#define SCardReadCache  SCardReadCacheA
#endif // !UNICODE

extern WINSCARDAPI LONG WINAPI
SCardWriteCacheA(
    __in SCARDCONTEXT hContext,
    __in UUID *CardIdentifier,
    __in DWORD FreshnessCounter,
    __in LPSTR LookupName,
    __in_bcount(DataLen) PBYTE Data,
    __in DWORD DataLen);
extern WINSCARDAPI LONG WINAPI
SCardWriteCacheW(
    __in SCARDCONTEXT hContext,
    __in UUID *CardIdentifier,
    __in DWORD FreshnessCounter,
    __in LPWSTR LookupName,
    __in_bcount(DataLen) PBYTE Data,
    __in DWORD DataLen);
#ifdef UNICODE
#define SCardWriteCache  SCardWriteCacheW
#else
#define SCardWriteCache  SCardWriteCacheA
#endif // !UNICODE

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#ifdef __cplusplus
}
#endif
#endif // _WINSCARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WinSDKVer.h ===
/*

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WinSDKVer.h

Abstract:

    Master include file for versioning content that ships in the Windows SDK.

*/

#ifndef _INC_WINSDKVER
#define _INC_WINSDKVER

#pragma once

// This list contains the highest version constants supported by content in the Windows SDK.

#define _WIN32_MAXVER           0x0601
#define _WIN32_WINDOWS_MAXVER   0x0601
#define NTDDI_MAXVER            0x0601
#define _WIN32_IE_MAXVER        0x0800
#define _WIN32_WINNT_MAXVER     0x0601
#define WINVER_MAXVER           0x0601

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WinSock.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    118736
//  $AgreementName:  berkeley software distribution license
//  $AgreementType:  oss license
//  $ExternalOrigin: regents of the university of california
//$ENDTAG

//$TAG ENGR 
//  $Owner:    vadime
//  $Module:   published_inc
//
//$ENDTAG

/* WINSOCK.H--definitions to be used with the WINSOCK.DLL
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *
 * This header file corresponds to version 1.1 of the Windows Sockets specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 *
 */

#ifndef _WINSOCKAPI_
#define _WINSOCKAPI_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 * Pull in WINDOWS.H if necessary
 */
#ifndef _INC_WINDOWS
#include <windows.h>
#endif /* _INC_WINDOWS */

/*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 */
typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;

/*
 * The new type to be used in all
 * instances which refer to sockets.
 */

typedef UINT_PTR        SOCKET;

/*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be >= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK.H EXACTLY AS SHOWN HERE.
 */
#ifndef FD_SETSIZE
#define FD_SETSIZE      64
#endif /* FD_SETSIZE */

typedef struct fd_set {
        u_int   fd_count;               /* how many are SET? */
        SOCKET  fd_array[FD_SETSIZE];   /* an array of SOCKETs */
} fd_set;

#ifdef __cplusplus
extern "C" {
#endif

extern int PASCAL FAR __WSAFDIsSet(SOCKET, fd_set FAR *);

#ifdef __cplusplus
}
#endif


#define FD_CLR(fd, set) do { \
    u_int __i; \
    for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count ; __i++) { \
        if (((fd_set FAR *)(set))->fd_array[__i] == fd) { \
            while (__i < ((fd_set FAR *)(set))->fd_count-1) { \
                ((fd_set FAR *)(set))->fd_array[__i] = \
                    ((fd_set FAR *)(set))->fd_array[__i+1]; \
                __i++; \
            } \
            ((fd_set FAR *)(set))->fd_count--; \
            break; \
        } \
    } \
} while(0)

#define FD_SET(fd, set) do { \
    if (((fd_set FAR *)(set))->fd_count < FD_SETSIZE) \
        ((fd_set FAR *)(set))->fd_array[((fd_set FAR *)(set))->fd_count++]=(fd);\
} while(0)

#define FD_ZERO(set) (((fd_set FAR *)(set))->fd_count=0)

#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set FAR *)(set))

/*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 */
struct timeval {
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
};

/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 */
#define timerisset(tvp)         ((tvp)->tv_sec || (tvp)->tv_usec)
#define timercmp(tvp, uvp, cmp) \
        ((tvp)->tv_sec cmp (uvp)->tv_sec || \
         (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec)
#define timerclear(tvp)         (tvp)->tv_sec = (tvp)->tv_usec = 0

/*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */
#define IOCPARM_MASK    0x7f            /* parameters must be < 128 bytes */
#define IOC_VOID        0x20000000      /* no parameters */
#define IOC_OUT         0x40000000      /* copy out parameters */
#define IOC_IN          0x80000000      /* copy in parameters */
#define IOC_INOUT       (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))

#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define FIONREAD    _IOR('f', 127, u_long) /* get # bytes to read */
#define FIONBIO     _IOW('f', 126, u_long) /* set/clear non-blocking i/o */
#define FIOASYNC    _IOW('f', 125, u_long) /* set/clear async i/o */

/* Socket I/O Controls */
#define SIOCSHIWAT  _IOW('s',  0, u_long)  /* set high watermark */
#define SIOCGHIWAT  _IOR('s',  1, u_long)  /* get high watermark */
#define SIOCSLOWAT  _IOW('s',  2, u_long)  /* set low watermark */
#define SIOCGLOWAT  _IOR('s',  3, u_long)  /* get low watermark */
#define SIOCATMARK  _IOR('s',  7, u_long)  /* at oob mark? */

/*
 * Structures returned by network data base library, taken from the
 * BSD file netdb.h.  All addresses are supplied in host order, and
 * returned in network order (suitable for use in system calls).
 */

struct  hostent {
        char    FAR * h_name;           /* official name of host */
        char    FAR * FAR * h_aliases;  /* alias list */
        short   h_addrtype;             /* host address type */
        short   h_length;               /* length of address */
        char    FAR * FAR * h_addr_list; /* list of addresses */
#define h_addr  h_addr_list[0]          /* address, for backward compat */
};

/*
 * It is assumed here that a network number
 * fits in 32 bits.
 */
struct  netent {
        char    FAR * n_name;           /* official name of net */
        char    FAR * FAR * n_aliases;  /* alias list */
        short   n_addrtype;             /* net address type */
        u_long  n_net;                  /* network # */
};

struct  servent {
        char    FAR * s_name;           /* official service name */
        char    FAR * FAR * s_aliases;  /* alias list */
#ifdef _WIN64
        char    FAR * s_proto;          /* protocol to use */
        short   s_port;                 /* port # */
#else
        short   s_port;                 /* port # */
        char    FAR * s_proto;          /* protocol to use */
#endif
};

struct  protoent {
        char    FAR * p_name;           /* official protocol name */
        char    FAR * FAR * p_aliases;  /* alias list */
        short   p_proto;                /* protocol # */
};

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 */

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

/*
 * Port/socket numbers: network standard functions
 */
#define IPPORT_ECHO             7
#define IPPORT_DISCARD          9
#define IPPORT_SYSTAT           11
#define IPPORT_DAYTIME          13
#define IPPORT_NETSTAT          15
#define IPPORT_FTP              21
#define IPPORT_TELNET           23
#define IPPORT_SMTP             25
#define IPPORT_TIMESERVER       37
#define IPPORT_NAMESERVER       42
#define IPPORT_WHOIS            43
#define IPPORT_MTP              57

/*
 * Port/socket numbers: host specific functions
 */
#define IPPORT_TFTP             69
#define IPPORT_RJE              77
#define IPPORT_FINGER           79
#define IPPORT_TTYLINK          87
#define IPPORT_SUPDUP           95

/*
 * UNIX TCP sockets
 */
#define IPPORT_EXECSERVER       512
#define IPPORT_LOGINSERVER      513
#define IPPORT_CMDSERVER        514
#define IPPORT_EFSSERVER        520

/*
 * UNIX UDP sockets
 */
#define IPPORT_BIFFUDP          512
#define IPPORT_WHOSERVER        513
#define IPPORT_ROUTESERVER      520
                                        /* 520+1 also used */

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
#define IPPORT_RESERVED         1024

/*
 * Link numbers
 */
#define IMPLINK_IP              155
#define IMPLINK_LOWEXPER        156
#define IMPLINK_HIGHEXPER       158

#include <inaddr.h>

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */
#define IN_CLASSA(i)            (((long)(i) & 0x80000000) == 0)
#define IN_CLASSA_NET           0xff000000
#define IN_CLASSA_NSHIFT        24
#define IN_CLASSA_HOST          0x00ffffff
#define IN_CLASSA_MAX           128

#define IN_CLASSB(i)            (((long)(i) & 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET           0xffff0000
#define IN_CLASSB_NSHIFT        16
#define IN_CLASSB_HOST          0x0000ffff
#define IN_CLASSB_MAX           65536

#define IN_CLASSC(i)            (((long)(i) & 0xe0000000) == 0xc0000000)
#define IN_CLASSC_NET           0xffffff00
#define IN_CLASSC_NSHIFT        8
#define IN_CLASSC_HOST          0x000000ff

#define INADDR_ANY              (u_long)0x00000000
#define INADDR_LOOPBACK         0x7f000001
#define INADDR_BROADCAST        (u_long)0xffffffff
#define INADDR_NONE             0xffffffff

/*
 * Socket address, internet style.
 */
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};

#define WSADESCRIPTION_LEN      256
#define WSASYS_STATUS_LEN       128

typedef struct WSAData {
        WORD                    wVersion;
        WORD                    wHighVersion;
#ifdef _WIN64
        unsigned short          iMaxSockets;
        unsigned short          iMaxUdpDg;
        char FAR *              lpVendorInfo;
        char                    szDescription[WSADESCRIPTION_LEN+1];
        char                    szSystemStatus[WSASYS_STATUS_LEN+1];
#else
        char                    szDescription[WSADESCRIPTION_LEN+1];
        char                    szSystemStatus[WSASYS_STATUS_LEN+1];
        unsigned short          iMaxSockets;
        unsigned short          iMaxUdpDg;
        char FAR *              lpVendorInfo;
#endif
} WSADATA;

typedef WSADATA FAR *LPWSADATA;

/*
 * Options for use with [gs]etsockopt at the IP level.
 */
#define IP_OPTIONS          1           /* set/get IP per-packet options    */
#define IP_MULTICAST_IF     2           /* set/get IP multicast interface   */
#define IP_MULTICAST_TTL    3           /* set/get IP multicast timetolive  */
#define IP_MULTICAST_LOOP   4           /* set/get IP multicast loopback    */
#define IP_ADD_MEMBERSHIP   5           /* add  an IP group membership      */
#define IP_DROP_MEMBERSHIP  6           /* drop an IP group membership      */
#define IP_TTL              7           /* set/get IP Time To Live          */
#define IP_TOS              8           /* set/get IP Type Of Service       */
#define IP_DONTFRAGMENT     9           /* set/get IP Don't Fragment flag   */


#define IP_DEFAULT_MULTICAST_TTL   1    /* normally limit m'casts to 1 hop  */
#define IP_DEFAULT_MULTICAST_LOOP  1    /* normally hear sends if a member  */
#define IP_MAX_MEMBERSHIPS         20   /* per socket; must fit in one mbuf */

/*
 * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
 */
struct ip_mreq {
        struct in_addr  imr_multiaddr;  /* IP multicast address of group */
        struct in_addr  imr_interface;  /* local IP address of interface */
};

/*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 */

/*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 */
#define INVALID_SOCKET  (SOCKET)(~0)
#define SOCKET_ERROR            (-1)

/*
 * Types
 */
#define SOCK_STREAM     1               /* stream socket */
#define SOCK_DGRAM      2               /* datagram socket */
#define SOCK_RAW        3               /* raw-protocol interface */
#define SOCK_RDM        4               /* reliably-delivered message */
#define SOCK_SEQPACKET  5               /* sequenced packet stream */

/*
 * Option flags per-socket.
 */
#define SO_DEBUG        0x0001          /* turn on debugging info recording */
#define SO_ACCEPTCONN   0x0002          /* socket has had listen() */
#define SO_REUSEADDR    0x0004          /* allow local address reuse */
#define SO_KEEPALIVE    0x0008          /* keep connections alive */
#define SO_DONTROUTE    0x0010          /* just use interface addresses */
#define SO_BROADCAST    0x0020          /* permit sending of broadcast msgs */
#define SO_USELOOPBACK  0x0040          /* bypass hardware when possible */
#define SO_LINGER       0x0080          /* linger on close if data present */
#define SO_OOBINLINE    0x0100          /* leave received OOB data in line */

#define SO_DONTLINGER   (u_int)(~SO_LINGER)

/*
 * Additional options.
 */
#define SO_SNDBUF       0x1001          /* send buffer size */
#define SO_RCVBUF       0x1002          /* receive buffer size */
#define SO_SNDLOWAT     0x1003          /* send low-water mark */
#define SO_RCVLOWAT     0x1004          /* receive low-water mark */
#define SO_SNDTIMEO     0x1005          /* send timeout */
#define SO_RCVTIMEO     0x1006          /* receive timeout */
#define SO_ERROR        0x1007          /* get error status and clear */
#define SO_TYPE         0x1008          /* get socket type */

/*
 * Options for connect and disconnect data and options.  Used only by
 * non-TCP/IP transports such as DECNet, OSI TP4, etc.
 */
#define SO_CONNDATA     0x7000
#define SO_CONNOPT      0x7001
#define SO_DISCDATA     0x7002
#define SO_DISCOPT      0x7003
#define SO_CONNDATALEN  0x7004
#define SO_CONNOPTLEN   0x7005
#define SO_DISCDATALEN  0x7006
#define SO_DISCOPTLEN   0x7007

/*
 * Option for opening sockets for synchronous access.
 */
#define SO_OPENTYPE     0x7008

#define SO_SYNCHRONOUS_ALERT    0x10
#define SO_SYNCHRONOUS_NONALERT 0x20

/*
 * Other NT-specific options.
 */
#define SO_MAXDG        0x7009
#define SO_MAXPATHDG    0x700A
#define SO_UPDATE_ACCEPT_CONTEXT 0x700B
#define SO_CONNECT_TIME 0x700C

/*
 * TCP options.
 */
#define TCP_NODELAY     0x0001
#define TCP_BSDURGENT   0x7000

/*
 * Address families.
 */
#define AF_UNSPEC       0               /* unspecified */
#define AF_UNIX         1               /* local to host (pipes, portals) */
#define AF_INET         2               /* internetwork: UDP, TCP, etc. */
#define AF_IMPLINK      3               /* arpanet imp addresses */
#define AF_PUP          4               /* pup protocols: e.g. BSP */
#define AF_CHAOS        5               /* mit CHAOS protocols */
#define AF_IPX          6               /* IPX and SPX */
#define AF_NS           6               /* XEROX NS protocols */
#define AF_ISO          7               /* ISO protocols */
#define AF_OSI          AF_ISO          /* OSI is ISO */
#define AF_ECMA         8               /* european computer manufacturers */
#define AF_DATAKIT      9               /* datakit protocols */
#define AF_CCITT        10              /* CCITT protocols, X.25 etc */
#define AF_SNA          11              /* IBM SNA */
#define AF_DECnet       12              /* DECnet */
#define AF_DLI          13              /* Direct data link interface */
#define AF_LAT          14              /* LAT */
#define AF_HYLINK       15              /* NSC Hyperchannel */
#define AF_APPLETALK    16              /* AppleTalk */
#define AF_NETBIOS      17              /* NetBios-style addresses */
#define AF_VOICEVIEW    18              /* VoiceView */
#define AF_FIREFOX      19              /* FireFox */
#define AF_UNKNOWN1     20              /* Somebody is using this! */
#define AF_BAN          21              /* Banyan */

#define AF_MAX          22

/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
        u_short sa_family;              /* address family */
        char    sa_data[14];            /* up to 14 bytes of direct address */
};

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
        u_short sp_family;              /* address family */
        u_short sp_protocol;            /* protocol */
};

/*
 * Protocol families, same as address families for now.
 */
#define PF_UNSPEC       AF_UNSPEC
#define PF_UNIX         AF_UNIX
#define PF_INET         AF_INET
#define PF_IMPLINK      AF_IMPLINK
#define PF_PUP          AF_PUP
#define PF_CHAOS        AF_CHAOS
#define PF_NS           AF_NS
#define PF_IPX          AF_IPX
#define PF_ISO          AF_ISO
#define PF_OSI          AF_OSI
#define PF_ECMA         AF_ECMA
#define PF_DATAKIT      AF_DATAKIT
#define PF_CCITT        AF_CCITT
#define PF_SNA          AF_SNA
#define PF_DECnet       AF_DECnet
#define PF_DLI          AF_DLI
#define PF_LAT          AF_LAT
#define PF_HYLINK       AF_HYLINK
#define PF_APPLETALK    AF_APPLETALK
#define PF_VOICEVIEW    AF_VOICEVIEW
#define PF_FIREFOX      AF_FIREFOX
#define PF_UNKNOWN1     AF_UNKNOWN1
#define PF_BAN          AF_BAN

#define PF_MAX          AF_MAX

/*
 * Structure used for manipulating linger option.
 */
struct  linger {
        u_short l_onoff;                /* option on/off */
        u_short l_linger;               /* linger time */
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define SOL_SOCKET      0xffff          /* options for socket level */

/*
 * Maximum queue length specifiable by listen.
 */
#define SOMAXCONN       5

#define MSG_OOB         0x1             /* process out-of-band data */
#define MSG_PEEK        0x2             /* peek at incoming message */
#define MSG_DONTROUTE   0x4             /* send without using routing tables */

#define MSG_MAXIOVLEN   16

#define MSG_PARTIAL     0x8000          /* partial send or recv for message xport */

/*
 * Define constant based on rfc883, used by gethostbyxxxx() calls.
 */
#define MAXGETHOSTSTRUCT        1024

/*
 * Define flags to be used with the WSAAsyncSelect() call.
 */
#define FD_READ         0x01
#define FD_WRITE        0x02
#define FD_OOB          0x04
#define FD_ACCEPT       0x08
#define FD_CONNECT      0x10
#define FD_CLOSE        0x20

/*
 * WinSock error codes are also defined in winerror.h
 * Hence the IFDEF.
 */
#ifndef WSABASEERR

/*
 * All Windows Sockets error constants are biased by WSABASEERR from
 * the "normal"
 */
#define WSABASEERR              10000
/*
 * Windows Sockets definitions of regular Microsoft C error constants
 */
#define WSAEINTR                (WSABASEERR+4)
#define WSAEBADF                (WSABASEERR+9)
#define WSAEACCES               (WSABASEERR+13)
#define WSAEFAULT               (WSABASEERR+14)
#define WSAEINVAL               (WSABASEERR+22)
#define WSAEMFILE               (WSABASEERR+24)

/*
 * Windows Sockets definitions of regular Berkeley error constants
 */
#define WSAEWOULDBLOCK          (WSABASEERR+35)
#define WSAEINPROGRESS          (WSABASEERR+36)
#define WSAEALREADY             (WSABASEERR+37)
#define WSAENOTSOCK             (WSABASEERR+38)
#define WSAEDESTADDRREQ         (WSABASEERR+39)
#define WSAEMSGSIZE             (WSABASEERR+40)
#define WSAEPROTOTYPE           (WSABASEERR+41)
#define WSAENOPROTOOPT          (WSABASEERR+42)
#define WSAEPROTONOSUPPORT      (WSABASEERR+43)
#define WSAESOCKTNOSUPPORT      (WSABASEERR+44)
#define WSAEOPNOTSUPP           (WSABASEERR+45)
#define WSAEPFNOSUPPORT         (WSABASEERR+46)
#define WSAEAFNOSUPPORT         (WSABASEERR+47)
#define WSAEADDRINUSE           (WSABASEERR+48)
#define WSAEADDRNOTAVAIL        (WSABASEERR+49)
#define WSAENETDOWN             (WSABASEERR+50)
#define WSAENETUNREACH          (WSABASEERR+51)
#define WSAENETRESET            (WSABASEERR+52)
#define WSAECONNABORTED         (WSABASEERR+53)
#define WSAECONNRESET           (WSABASEERR+54)
#define WSAENOBUFS              (WSABASEERR+55)
#define WSAEISCONN              (WSABASEERR+56)
#define WSAENOTCONN             (WSABASEERR+57)
#define WSAESHUTDOWN            (WSABASEERR+58)
#define WSAETOOMANYREFS         (WSABASEERR+59)
#define WSAETIMEDOUT            (WSABASEERR+60)
#define WSAECONNREFUSED         (WSABASEERR+61)
#define WSAELOOP                (WSABASEERR+62)
#define WSAENAMETOOLONG         (WSABASEERR+63)
#define WSAEHOSTDOWN            (WSABASEERR+64)
#define WSAEHOSTUNREACH         (WSABASEERR+65)
#define WSAENOTEMPTY            (WSABASEERR+66)
#define WSAEPROCLIM             (WSABASEERR+67)
#define WSAEUSERS               (WSABASEERR+68)
#define WSAEDQUOT               (WSABASEERR+69)
#define WSAESTALE               (WSABASEERR+70)
#define WSAEREMOTE              (WSABASEERR+71)

#define WSAEDISCON              (WSABASEERR+101)

/*
 * Extended Windows Sockets error constant definitions
 */
#define WSASYSNOTREADY          (WSABASEERR+91)
#define WSAVERNOTSUPPORTED      (WSABASEERR+92)
#define WSANOTINITIALISED       (WSABASEERR+93)

/*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (when using the resolver). Note that these errors are
 * retrieved via WSAGetLastError() and must therefore follow
 * the rules for avoiding clashes with error numbers from
 * specific implementations or language run-time systems.
 * For this reason the codes are based at WSABASEERR+1001.
 * Note also that [WSA]NO_ADDRESS is defined only for
 * compatibility purposes.
 */


/* Authoritative Answer: Host not found */
#define WSAHOST_NOT_FOUND       (WSABASEERR+1001)

/* Non-Authoritative: Host not found, or SERVERFAIL */
#define WSATRY_AGAIN            (WSABASEERR+1002)

/* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
#define WSANO_RECOVERY          (WSABASEERR+1003)

/* Valid name, no data record of requested type */
#define WSANO_DATA              (WSABASEERR+1004)

/* Authoritative Answer: Host not found Securely */
#define WSA_SECURE_HOST_NOT_FOUND
 (WSABASEERR+1032)


/* Name based IPSEC policy could not be added*/
#define WSA_IPSEC_NAME_POLICY_ERROR (WSABASEERR+1033)

/*
 * WinSock error codes are also defined in winerror.h
 * Hence the IFDEF.
 */
#endif /* ifdef WSABASEERR */

/*
 * Compatibility macros.
 */


#define h_errno         WSAGetLastError()
#define HOST_NOT_FOUND          WSAHOST_NOT_FOUND
#define TRY_AGAIN               WSATRY_AGAIN
#define NO_RECOVERY             WSANO_RECOVERY
#define NO_DATA                 WSANO_DATA
/* no address, look for MX record */
#define WSANO_ADDRESS           WSANO_DATA
#define NO_ADDRESS              WSANO_ADDRESS

/*
 * Windows Sockets errors redefined as regular Berkeley error constants.
 * These are commented out in Windows NT to avoid conflicts with errno.h.
 * Use the WSA constants instead.
 */
#if 0
#define EWOULDBLOCK             WSAEWOULDBLOCK
#define EINPROGRESS             WSAEINPROGRESS
#define EALREADY                WSAEALREADY
#define ENOTSOCK                WSAENOTSOCK
#define EDESTADDRREQ            WSAEDESTADDRREQ
#define EMSGSIZE                WSAEMSGSIZE
#define EPROTOTYPE              WSAEPROTOTYPE
#define ENOPROTOOPT             WSAENOPROTOOPT
#define EPROTONOSUPPORT         WSAEPROTONOSUPPORT
#define ESOCKTNOSUPPORT         WSAESOCKTNOSUPPORT
#define EOPNOTSUPP              WSAEOPNOTSUPP
#define EPFNOSUPPORT            WSAEPFNOSUPPORT
#define EAFNOSUPPORT            WSAEAFNOSUPPORT
#define EADDRINUSE              WSAEADDRINUSE
#define EADDRNOTAVAIL           WSAEADDRNOTAVAIL
#define ENETDOWN                WSAENETDOWN
#define ENETUNREACH             WSAENETUNREACH
#define ENETRESET               WSAENETRESET
#define ECONNABORTED            WSAECONNABORTED
#define ECONNRESET              WSAECONNRESET
#define ENOBUFS                 WSAENOBUFS
#define EISCONN                 WSAEISCONN
#define ENOTCONN                WSAENOTCONN
#define ESHUTDOWN               WSAESHUTDOWN
#define ETOOMANYREFS            WSAETOOMANYREFS
#define ETIMEDOUT               WSAETIMEDOUT
#define ECONNREFUSED            WSAECONNREFUSED
#define ELOOP                   WSAELOOP
#define ENAMETOOLONG            WSAENAMETOOLONG
#define EHOSTDOWN               WSAEHOSTDOWN
#define EHOSTUNREACH            WSAEHOSTUNREACH
#define ENOTEMPTY               WSAENOTEMPTY
#define EPROCLIM                WSAEPROCLIM
#define EUSERS                  WSAEUSERS
#define EDQUOT                  WSAEDQUOT
#define ESTALE                  WSAESTALE
#define EREMOTE                 WSAEREMOTE
#endif

/* Socket function prototypes */

#ifdef __cplusplus
extern "C" {
#endif

SOCKET PASCAL FAR accept (
                          __in SOCKET s,
                          __out_bcount_opt(*addrlen) struct sockaddr FAR *addr,
                          __inout_opt int FAR *addrlen);

int PASCAL FAR bind (
                     __in SOCKET s,
                     __in_bcount(namelen) const struct sockaddr FAR *addr,
                     __in int namelen);

int PASCAL FAR closesocket ( IN SOCKET s);

int PASCAL FAR connect (
                        __in SOCKET s,
                        __in_bcount(namelen) const struct sockaddr FAR *name,
                        __in int namelen);

int PASCAL FAR ioctlsocket (
                            __in SOCKET s,
                            __in long cmd,
                            __inout u_long FAR *argp);

int PASCAL FAR getpeername (
                            __in SOCKET s,
                            __out_bcount_part(*namelen, *namelen) struct sockaddr FAR *name,
                            __inout int FAR * namelen);

int PASCAL FAR getsockname (
                            __in SOCKET s,
                            __out_bcount_part(*namelen, *namelen) struct sockaddr FAR *name,
                            __inout int FAR * namelen);

int PASCAL FAR getsockopt (
                           __in SOCKET s,
                           __in int level,
                           __in int optname,
                           __out_bcount(*optlen) char FAR * optval,
                           __inout int FAR *optlen);

u_long PASCAL FAR htonl ( __in u_long hostlong);

u_short PASCAL FAR htons (__in u_short hostshort);

unsigned long PASCAL FAR inet_addr (__in const char FAR * cp);

char FAR * PASCAL FAR inet_ntoa (__in struct in_addr in);

int PASCAL FAR listen (
                       __in SOCKET s,
                       __in int backlog);

u_long PASCAL FAR ntohl (__in u_long netlong);

u_short PASCAL FAR ntohs (__in u_short netshort);

int PASCAL FAR recv (
                     __in SOCKET s,
                     __out_bcount_part(len, return) __out_data_source(NETWORK) char FAR * buf,
                     __in int len,
                     __in int flags);

int PASCAL FAR recvfrom (
                         __in SOCKET s,
                         __out_bcount_part(len, return) __out_data_source(NETWORK) char FAR * buf,
                         __in int len,
                         __in int flags,
                         __out_bcount_opt(*fromlen) struct sockaddr FAR * from,
                         __inout_opt int FAR * fromlen);

int PASCAL FAR select (
                        __in int nfds,
                        __inout_opt fd_set FAR *readfds,
                        __inout_opt fd_set FAR *writefds,
                        __inout_opt fd_set FAR *exceptfds,
                        __in_opt  const struct timeval FAR *timeout);

int PASCAL FAR send (
                     __in SOCKET s,
                     __in_bcount(len) const char FAR * buf,
                     __in int len,
                     __in int flags);

int PASCAL FAR sendto (
                       __in SOCKET s,
                       __in_bcount(len) const char FAR * buf,
                       __in int len,
                       __in int flags,
                       __in_bcount_opt(tolen) const struct sockaddr FAR *to,
                       __in int tolen);

int PASCAL FAR setsockopt (
                           __in SOCKET s,
                           __in int level,
                           __in int optname,
                           __in_bcount_opt(optlen) const char FAR * optval,
                           __in int optlen);

int PASCAL FAR shutdown (
                         __in SOCKET s,
                         __in int how);

SOCKET PASCAL FAR socket (
                          __in int af,
                          __in int type,
                          __in int protocol);

/* Database function prototypes */

struct hostent FAR * PASCAL FAR gethostbyaddr(
                                              __in_bcount(len) const char FAR * addr,
                                              __in int len,
                                              __in int type);

struct hostent FAR * PASCAL FAR gethostbyname(__in_z const char FAR * name);

int PASCAL FAR gethostname (
                            __out_bcount_part(namelen, return) char FAR * name,
                            __in int namelen);

struct servent FAR * PASCAL FAR getservbyport(
                                              __in int port,
                                              __in_z const char FAR * proto);

struct servent FAR * PASCAL FAR getservbyname(
                                              __in_z const char FAR * name,
                                              __in_z const char FAR * proto);

struct protoent FAR * PASCAL FAR getprotobynumber(__in int proto);

struct protoent FAR * PASCAL FAR getprotobyname(__in_z const char FAR * name);

/* Microsoft Windows Extension function prototypes */

int PASCAL FAR WSAStartup(
                          __in WORD wVersionRequired,
                          __out LPWSADATA lpWSAData);

int PASCAL FAR WSACleanup(void);

void PASCAL FAR WSASetLastError(__in int iError);

int PASCAL FAR WSAGetLastError(void);

BOOL PASCAL FAR WSAIsBlocking(void);

int PASCAL FAR WSAUnhookBlockingHook(void);

FARPROC PASCAL FAR WSASetBlockingHook(__in FARPROC lpBlockFunc);

int PASCAL FAR WSACancelBlockingCall(void);

HANDLE PASCAL FAR WSAAsyncGetServByName(
                                        __in HWND hWnd,
                                        __in u_int wMsg,
                                        __in const char FAR * name,
                                        __in const char FAR * proto,
                                        __out_bcount(buflen) char FAR * buf,
                                        __in int buflen);

HANDLE PASCAL FAR WSAAsyncGetServByPort(
                                        __in HWND hWnd,
                                        __in u_int wMsg,
                                        __in int port,
                                        __in const char FAR * proto,
                                        __out_bcount(buflen) char FAR * buf,
                                        __in int buflen);

HANDLE PASCAL FAR WSAAsyncGetProtoByName(
                                         __in HWND hWnd,
                                         __in u_int wMsg,
                                         __in const char FAR * name,
                                         __out_bcount(buflen) char FAR * buf,
                                         __in int buflen);

HANDLE PASCAL FAR WSAAsyncGetProtoByNumber(
                                           __in HWND hWnd,
                                           __in u_int wMsg,
                                           __in int number,
                                           __out_bcount(buflen) char FAR * buf,
                                           __in int buflen);

HANDLE PASCAL FAR WSAAsyncGetHostByName(
                                        __in HWND hWnd,
                                        __in u_int wMsg,
                                        __in const char FAR * name,
                                        __out_bcount(buflen) char FAR * buf,
                                        __in int buflen);

HANDLE PASCAL FAR WSAAsyncGetHostByAddr(
                                        __in HWND hWnd,
                                        __in u_int wMsg,
                                        __in const char FAR * addr,
                                        __in int len,
                                        __in int type,
                                        __out_bcount(buflen) char FAR * buf,
                                        __in int buflen);

int PASCAL FAR WSACancelAsyncRequest(__in HANDLE hAsyncTaskHandle);

int PASCAL FAR WSAAsyncSelect(
                              __in SOCKET s,
                              __in HWND hWnd,
                              __in u_int wMsg,
                              __in long lEvent);

int PASCAL FAR WSARecvEx (
                          __in SOCKET s,
                          __out_bcount_part(len, return) __out_data_source(NETWORK) char FAR * buf,
                          __in int len,
                          __inout int FAR *flags);

typedef struct _TRANSMIT_FILE_BUFFERS {
    PVOID Head;
    DWORD HeadLength;
    PVOID Tail;
    DWORD TailLength;
} TRANSMIT_FILE_BUFFERS, *PTRANSMIT_FILE_BUFFERS, *LPTRANSMIT_FILE_BUFFERS;

#define TF_DISCONNECT       0x01
#define TF_REUSE_SOCKET     0x02
#define TF_WRITE_BEHIND     0x04

BOOL
PASCAL FAR
TransmitFile (
    __in SOCKET hSocket,
    __in HANDLE hFile,
    __in DWORD nNumberOfBytesToWrite,
    __in DWORD nNumberOfBytesPerSend,
    __inout_opt LPOVERLAPPED lpOverlapped,
    __in_opt LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    __in DWORD dwReserved
    );

BOOL
PASCAL FAR
AcceptEx (
    __in SOCKET sListenSocket,
    __in SOCKET sAcceptSocket,
    __out_bcount_part(dwReceiveDatalength+dwLocalAddressLength+dwRemoteAddressLength,
       *lpdwBytesReceived) PVOID lpOutputBuffer,
    __in DWORD dwReceiveDataLength,
    __in DWORD dwLocalAddressLength,
    __in DWORD dwRemoteAddressLength,
    __out LPDWORD lpdwBytesReceived,
    __inout LPOVERLAPPED lpOverlapped
    );

VOID
PASCAL FAR
GetAcceptExSockaddrs (
    __in_bcount(dwReceiveDataLength+dwLocalAddressLength+dwRemoteAddressLength) PVOID lpOutputBuffer,
    __in DWORD dwReceiveDataLength,
    __in DWORD dwLocalAddressLength,
    __in DWORD dwRemoteAddressLength,
    __deref_out_bcount(*LocalSockaddrLength) struct sockaddr **LocalSockaddr,
    __out LPINT LocalSockaddrLength,
    __deref_out_bcount(*RemoteSockaddrLength) struct sockaddr **RemoteSockaddr,
    __out LPINT RemoteSockaddrLength
    );

#ifdef __cplusplus
}
#endif

/* Microsoft Windows Extended data types */
typedef struct sockaddr SOCKADDR;
typedef struct sockaddr *PSOCKADDR;
typedef struct sockaddr FAR *LPSOCKADDR;

typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr_in *PSOCKADDR_IN;
typedef struct sockaddr_in FAR *LPSOCKADDR_IN;

typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger FAR *LPLINGER;

typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set FAR *LPFD_SET;

typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent FAR *LPHOSTENT;

typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent FAR *LPSERVENT;

typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent FAR *LPPROTOENT;

typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval FAR *LPTIMEVAL;

/*
 * Windows message parameter composition and decomposition
 * macros.
 *
 * WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to a WSAAsyncGetXByY() routine.
 */
#define WSAMAKEASYNCREPLY(buflen,error)     MAKELONG(buflen,error)
/*
 * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to WSAAsyncSelect().
 */
#define WSAMAKESELECTREPLY(event,error)     MAKELONG(event,error)
/*
 * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application
 * to extract the buffer length from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
/*
 * WSAGETASYNCERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
/*
 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
 * to extract the event code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTEVENT(lParam)           LOWORD(lParam)
/*
 * WSAGETSELECTERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTERROR(lParam)           HIWORD(lParam)

#if(_WIN32_WINNT >= 0x0501)
#ifdef IPV6STRICT
#error WINSOCK2 required.
#endif // IPV6STRICT
#endif //(_WIN32_WINNT >= 0x0501)

#endif  /* _WINSOCKAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WinSnmp.h ===
/* WinSNMP.h */
/* Copyright (C) 1993-1999 Microsoft Corporation */
/* v1.0 - Sep 13, 1993 */
/* v1.1 - Jun 12, 1994 */
/* v2.0 - Nov  1, 1997 */
/*      - Nov 17, 1997: inc limits.h, tests for ULONG/UINT_MAX */
/*      - Mar 23, 1998: fixed typo in "lpClientData" */

/* Questions/comments to Bob Natale, bnatale@acecomm.com */

#ifndef _INC_WINSNMP     /* Include WinSNMP declarations */
#define  _INC_WINSNMP    /* Just once! */

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_WINDOWS     /* Include Windows declarations, if not already done */
#include <windows.h>
#define _INC_WINDOWS     /* Just once! */
#endif                   /* _INC_WINDOWS */

#include <limits.h>

#ifdef __cplusplus
extern "C" {
#endif

/* WinSNMP API Type Definitions  */
typedef  HANDLE        HSNMP_SESSION,      FAR *LPHSNMP_SESSION;
typedef  HANDLE        HSNMP_ENTITY,       FAR *LPHSNMP_ENTITY;
typedef  HANDLE        HSNMP_CONTEXT,      FAR *LPHSNMP_CONTEXT;
typedef  HANDLE        HSNMP_PDU,          FAR *LPHSNMP_PDU;
typedef  HANDLE        HSNMP_VBL,          FAR *LPHSNMP_VBL;
typedef unsigned char    smiBYTE,          FAR *smiLPBYTE;
/* SNMP-related types */
#if ULONG_MAX == 4294967295U
typedef signed long      smiINT,           FAR *smiLPINT;
typedef smiINT           smiINT32,         FAR *smiLPINT32;
typedef unsigned long    smiUINT32,        FAR *smiLPUINT32;
#elif UINT_MAX == 4294967295U
typedef int              smiINT,           FAR *smiLPINT;
typedef smiINT           smiINT32,         FAR *smiLPINT32;
typedef unsigned int     smiUINT32,        FAR *smiLPUINT32;
#else
#error can not define smiINT and smiUINT
#endif
typedef struct {
     smiUINT32 len;
     smiLPBYTE ptr;}     smiOCTETS,        FAR *smiLPOCTETS;
typedef const smiOCTETS                    FAR *smiLPCOCTETS;
typedef smiOCTETS        smiBITS,          FAR *smiLPBITS;
typedef struct {
     smiUINT32   len;
     smiLPUINT32 ptr;}   smiOID,           FAR *smiLPOID;
typedef const smiOID                       FAR *smiLPCOID;
typedef smiOCTETS        smiIPADDR,        FAR *smiLPIPADDR;
typedef smiUINT32        smiCNTR32,        FAR *smiLPCNTR32;
typedef smiUINT32        smiGAUGE32,       FAR *smiLPGAUGE32;
typedef smiUINT32        smiTIMETICKS,     FAR *smiLPTIMETICKS;
typedef smiOCTETS        smiOPAQUE,        FAR *smiLPOPAQUE;
typedef smiOCTETS        smiNSAPADDR,      FAR *smiLPNSAPADDR;
typedef struct {
     smiUINT32 hipart;
     smiUINT32 lopart;}  smiCNTR64,        FAR *smiLPCNTR64;
/* ASN/BER Base Types */
/* (used in forming SYNTAXes and certain SNMP types/values) */
#define ASN_UNIVERSAL         (0x00)
#define ASN_APPLICATION       (0x40)
#define ASN_CONTEXT           (0x80)
#define ASN_PRIVATE           (0xC0)
#define ASN_PRIMITIVE         (0x00)
#define ASN_CONSTRUCTOR       (0x20)

/* SNMP ObjectSyntax Values */
#define SNMP_SYNTAX_SEQUENCE    (ASN_UNIVERSAL | ASN_CONSTRUCTOR | 0x10)
/* These values are used in the "syntax" member of the smiVALUE structure which follows */
#define SNMP_SYNTAX_INT         (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x02)
#define SNMP_SYNTAX_BITS        (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x03)
#define SNMP_SYNTAX_OCTETS      (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x04)
#define SNMP_SYNTAX_NULL        (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x05)
#define SNMP_SYNTAX_OID         (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x06)
#define SNMP_SYNTAX_INT32       SNMP_SYNTAX_INT
#define SNMP_SYNTAX_IPADDR      (ASN_APPLICATION | ASN_PRIMITIVE | 0x00)
#define SNMP_SYNTAX_CNTR32      (ASN_APPLICATION | ASN_PRIMITIVE | 0x01)
#define SNMP_SYNTAX_GAUGE32     (ASN_APPLICATION | ASN_PRIMITIVE | 0x02)
#define SNMP_SYNTAX_TIMETICKS   (ASN_APPLICATION | ASN_PRIMITIVE | 0x03)
#define SNMP_SYNTAX_OPAQUE      (ASN_APPLICATION | ASN_PRIMITIVE | 0x04)
#define SNMP_SYNTAX_NSAPADDR    (ASN_APPLICATION | ASN_PRIMITIVE | 0x05)
#define SNMP_SYNTAX_CNTR64      (ASN_APPLICATION | ASN_PRIMITIVE | 0x06)
#define SNMP_SYNTAX_UINT32      (ASN_APPLICATION | ASN_PRIMITIVE | 0x07)
#define SNMP_SYNTAX_UNSIGNED32  SNMP_SYNTAX_GAUGE32
/* Exception conditions in response PDUs for SNMPv2 */
#define SNMP_SYNTAX_NOSUCHOBJECT   (ASN_CONTEXT | ASN_PRIMITIVE | 0x00)
#define SNMP_SYNTAX_NOSUCHINSTANCE (ASN_CONTEXT | ASN_PRIMITIVE | 0x01)
#define SNMP_SYNTAX_ENDOFMIBVIEW   (ASN_CONTEXT | ASN_PRIMITIVE | 0x02)

typedef struct {              /* smiVALUE portion of VarBind */
     smiUINT32 syntax;        /* Insert SNMP_SYNTAX_<type> */
     union {
     smiINT    sNumber;       /* SNMP_SYNTAX_INT
                                 SNMP_SYNTAX_INT32 */
     smiUINT32 uNumber;       /* SNMP_SYNTAX_UINT32
                                 SNMP_SYNTAX_CNTR32
                                 SNMP_SYNTAX_GAUGE32
                                 SNMP_SYNTAX_TIMETICKS */
     smiCNTR64 hNumber;       /* SNMP_SYNTAX_CNTR64 */
     smiOCTETS string;        /* SNMP_SYNTAX_OCTETS
                                 SNMP_SYNTAX_BITS
                                 SNMP_SYNTAX_OPAQUE
                                 SNMP_SYNTAX_IPADDR
                                 SNMP_SYNTAX_NSAPADDR */
     smiOID    oid;           /* SNMP_SYNTAX_OID */
     smiBYTE   empty;         /* SNMP_SYNTAX_NULL
                                 SNMP_SYNTAX_NOSUCHOBJECT
                                 SNMP_SYNTAX_NOSUCHINSTANCE
                                 SNMP_SYNTAX_ENDOFMIBVIEW */
         }     value;         /* union */
     }         smiVALUE,      FAR *smiLPVALUE;
typedef const  smiVALUE       FAR *smiLPCVALUE;

/* SNMP Limits   */
#define MAXOBJIDSIZE     128  /* Max number of components in an OID */
#define MAXOBJIDSTRSIZE  1408 /* Max len of decoded MAXOBJIDSIZE OID */

/* PDU Type Values */
#define SNMP_PDU_GET          (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x0)
#define SNMP_PDU_GETNEXT      (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x1)
#define SNMP_PDU_RESPONSE     (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x2)
#define SNMP_PDU_SET          (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x3)
/* SNMP_PDU_V1TRAP is obsolete in SNMPv2 */
#define SNMP_PDU_V1TRAP       (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x4)
#define SNMP_PDU_GETBULK      (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x5)
#define SNMP_PDU_INFORM       (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x6)
#define SNMP_PDU_TRAP         (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x7)

/*Constants for SnmpListenEx*/
#define SNMPLISTEN_USEENTITY_ADDR    0 /*Use entity address*/
#define SNMPLISTEN_ALL_ADDR          1 /*Use any address based on address family and port no*/

/* SNMPv1 Trap Values */
/* (These values might be superfluous wrt WinSNMP applications) */
#define SNMP_TRAP_COLDSTART             0
#define SNMP_TRAP_WARMSTART             1
#define SNMP_TRAP_LINKDOWN              2
#define SNMP_TRAP_LINKUP                3
#define SNMP_TRAP_AUTHFAIL              4
#define SNMP_TRAP_EGPNEIGHBORLOSS       5
#define SNMP_TRAP_ENTERPRISESPECIFIC    6

/* SNMP Error Codes Returned in Error_status Field of PDU */
/* (these are NOT WinSNMP API Error Codes */
/* Error Codes Common to SNMPv1 and SNMPv2 */
#define SNMP_ERROR_NOERROR              0
#define SNMP_ERROR_TOOBIG               1
#define SNMP_ERROR_NOSUCHNAME           2
#define SNMP_ERROR_BADVALUE             3
#define SNMP_ERROR_READONLY             4
#define SNMP_ERROR_GENERR               5
/* Error Codes Added for SNMPv2 */
#define SNMP_ERROR_NOACCESS             6
#define SNMP_ERROR_WRONGTYPE            7
#define SNMP_ERROR_WRONGLENGTH          8
#define SNMP_ERROR_WRONGENCODING        9
#define SNMP_ERROR_WRONGVALUE           10
#define SNMP_ERROR_NOCREATION           11
#define SNMP_ERROR_INCONSISTENTVALUE    12
#define SNMP_ERROR_RESOURCEUNAVAILABLE  13
#define SNMP_ERROR_COMMITFAILED         14
#define SNMP_ERROR_UNDOFAILED           15
#define SNMP_ERROR_AUTHORIZATIONERROR   16
#define SNMP_ERROR_NOTWRITABLE          17
#define SNMP_ERROR_INCONSISTENTNAME     18

/* WinSNMP API Values */
/* Values used to indicate entity/context translation modes */
#define SNMPAPI_TRANSLATED         0
#define SNMPAPI_UNTRANSLATED_V1    1
#define SNMPAPI_UNTRANSLATED_V2    2

/* Values used to indicate "SNMP level" supported by the implementation */
#define SNMPAPI_NO_SUPPORT         0
#define SNMPAPI_V1_SUPPORT         1
#define SNMPAPI_V2_SUPPORT         2
#define SNMPAPI_M2M_SUPPORT        3

/* Values used to indicate retransmit mode in the implementation */
#define SNMPAPI_OFF                0    /* Refuse support */
#define SNMPAPI_ON                 1    /* Request support */

/* WinSNMP API Function Return Codes */
typedef smiUINT32    SNMPAPI_STATUS;    /* Used for function ret values */
#define SNMPAPI_FAILURE            0    /* Generic error code */
#define SNMPAPI_SUCCESS            1    /* Generic success code */
/* WinSNMP API Error Codes (for SnmpGetLastError) */
/* (NOT SNMP Response-PDU error_status codes) */
#define SNMPAPI_ALLOC_ERROR        2    /* Error allocating memory */
#define SNMPAPI_CONTEXT_INVALID    3    /* Invalid context parameter */
#define SNMPAPI_CONTEXT_UNKNOWN    4    /* Unknown context parameter */
#define SNMPAPI_ENTITY_INVALID     5    /* Invalid entity parameter */
#define SNMPAPI_ENTITY_UNKNOWN     6    /* Unknown entity parameter */
#define SNMPAPI_INDEX_INVALID      7    /* Invalid VBL index parameter */
#define SNMPAPI_NOOP               8    /* No operation performed */
#define SNMPAPI_OID_INVALID        9    /* Invalid OID parameter */
#define SNMPAPI_OPERATION_INVALID  10   /* Invalid/unsupported operation */
#define SNMPAPI_OUTPUT_TRUNCATED   11   /* Insufficient output buf len */
#define SNMPAPI_PDU_INVALID        12   /* Invalid PDU parameter */
#define SNMPAPI_SESSION_INVALID    13   /* Invalid session parameter */
#define SNMPAPI_SYNTAX_INVALID     14   /* Invalid syntax in smiVALUE */
#define SNMPAPI_VBL_INVALID        15   /* Invalid VBL parameter */
#define SNMPAPI_MODE_INVALID       16   /* Invalid mode parameter */
#define SNMPAPI_SIZE_INVALID       17   /* Invalid size/length parameter */
#define SNMPAPI_NOT_INITIALIZED    18   /* SnmpStartup failed/not called */
#define SNMPAPI_MESSAGE_INVALID    19   /* Invalid SNMP message format */
#define SNMPAPI_HWND_INVALID       20   /* Invalid Window handle */
#define SNMPAPI_OTHER_ERROR        99   /* For internal/undefined errors */
/* Generic Transport Layer (TL) Errors */
#define SNMPAPI_TL_NOT_INITIALIZED 100  /* TL not initialized */
#define SNMPAPI_TL_NOT_SUPPORTED   101  /* TL does not support protocol */
#define SNMPAPI_TL_NOT_AVAILABLE   102  /* Network subsystem has failed */
#define SNMPAPI_TL_RESOURCE_ERROR  103  /* TL resource error */
#define SNMPAPI_TL_UNDELIVERABLE   104  /* Destination unreachable */
#define SNMPAPI_TL_SRC_INVALID     105  /* Source endpoint invalid */
#define SNMPAPI_TL_INVALID_PARAM   106  /* Input parameter invalid */
#define SNMPAPI_TL_IN_USE          107  /* Source endpoint in use */
#define SNMPAPI_TL_TIMEOUT         108  /* No response before timeout */
#define SNMPAPI_TL_PDU_TOO_BIG     109  /* PDU too big for send/receive */
#define SNMPAPI_TL_OTHER           199  /* Undefined TL error */

/* WinSNMP API Function Prototypes */

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#define SNMPAPI_CALL     WINAPI         /* FAR PASCAL calling conventions */

/* v2.0: Structure for SnmpGetVendorInfo() output */
#define MAXVENDORINFO 32
typedef struct
    {
    char vendorName[MAXVENDORINFO*2];
    char vendorContact[MAXVENDORINFO*2];
    char vendorVersionId[MAXVENDORINFO];
    char vendorVersionDate[MAXVENDORINFO];
    smiUINT32 vendorEnterprise;
    } smiVENDORINFO, FAR *smiLPVENDORINFO;

/* v2.0: Callback format for SnmpCreateSession() fCallback parameter */
typedef SNMPAPI_STATUS (CALLBACK *SNMPAPI_CALLBACK)
                        (IN HSNMP_SESSION hSession,
                         IN HWND hWnd,
                         IN UINT wMsg,
                         IN WPARAM wParam,
                         IN LPARAM lParam,
                         IN LPVOID lpClientData);

/* Local Database Functions */
SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetTranslateMode
                              (OUT smiLPUINT32 nTranslateMode);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpSetTranslateMode
                              (IN smiUINT32 nTranslateMode);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetRetransmitMode
                              (OUT smiLPUINT32 nRetransmitMode);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpSetRetransmitMode
                              (IN smiUINT32 nRetransmitMode);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetTimeout
                              (IN HSNMP_ENTITY hEntity,
                              OUT smiLPTIMETICKS nPolicyTimeout,
                              OUT smiLPTIMETICKS nActualTimeout);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpSetTimeout
                              (IN HSNMP_ENTITY hEntity,
                              IN smiTIMETICKS nPolicyTimeout);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetRetry
                              (IN HSNMP_ENTITY hEntity,
                              OUT smiLPUINT32 nPolicyRetry,
                              OUT smiLPUINT32 nActualRetry);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpSetRetry
                              (IN HSNMP_ENTITY hEntity,
                              IN smiUINT32 nPolicyRetry);

/* Following Local Database Functions added in v2.0 */
SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetVendorInfo
                              (OUT smiLPVENDORINFO vendorInfo);

/* Communications Functions */
SNMPAPI_STATUS SNMPAPI_CALL   SnmpStartup
                              (OUT smiLPUINT32 nMajorVersion,
                              OUT smiLPUINT32 nMinorVersion,
                              OUT smiLPUINT32 nLevel,
                              OUT smiLPUINT32 nTranslateMode,
                              OUT smiLPUINT32 nRetransmitMode);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpCleanup
                              (void);

HSNMP_SESSION  SNMPAPI_CALL   SnmpOpen
                              (IN HWND hWnd,
                              IN UINT wMsg);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpClose
                              (IN HSNMP_SESSION session);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpSendMsg
                              (IN HSNMP_SESSION session,
                              IN HSNMP_ENTITY srcEntity,
                              IN HSNMP_ENTITY dstEntity,
                              IN HSNMP_CONTEXT context,
                              IN HSNMP_PDU PDU);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpRecvMsg
                              (IN HSNMP_SESSION session,
                              OUT LPHSNMP_ENTITY srcEntity,
                              OUT LPHSNMP_ENTITY dstEntity,
                              OUT LPHSNMP_CONTEXT  context,
                              OUT LPHSNMP_PDU PDU);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpRegister
                              (IN HSNMP_SESSION session,
                              IN HSNMP_ENTITY srcEntity,
                              IN HSNMP_ENTITY dstEntity,
                              IN HSNMP_CONTEXT context,
                              IN smiLPCOID notification,
                              IN smiUINT32 state);

/* Following Communications Functions added in v2.0 */
HSNMP_SESSION  SNMPAPI_CALL   SnmpCreateSession
                              (IN HWND hWnd,
                              IN UINT wMsg,
                              IN SNMPAPI_CALLBACK fCallBack,
                              IN LPVOID lpClientData);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpListen
                              (IN HSNMP_ENTITY hEntity,
                              IN SNMPAPI_STATUS lStatus);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpListenEx
                              (IN HSNMP_ENTITY hEntity,
                              IN SNMPAPI_STATUS lStatus,
                              IN smiUINT32 nUseEntityAddr);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpCancelMsg
                              (IN HSNMP_SESSION session,
                              IN smiINT32 reqId);

/* Extensions to Communications Functions */
SNMPAPI_STATUS SNMPAPI_CALL SnmpStartupEx 
                            (OUT smiLPUINT32 nMajorVersion,
                             OUT smiLPUINT32 nMinorVersion,
                             OUT smiLPUINT32 nLevel,
                             OUT smiLPUINT32 nTranslateMode,
                             OUT smiLPUINT32 nRetransmitMode);
typedef SNMPAPI_STATUS (SNMPAPI_CALL * PFNSNMPSTARTUPEX)(  smiLPUINT32,
                                                        smiLPUINT32,
                                                        smiLPUINT32,
                                                        smiLPUINT32,
                                                        smiLPUINT32);
SNMPAPI_STATUS SNMPAPI_CALL SnmpCleanupEx 
                            (void);
typedef SNMPAPI_STATUS (SNMPAPI_CALL * PFNSNMPCLEANUPEX)(void);

/* Entity/Context Functions */
HSNMP_ENTITY   SNMPAPI_CALL   SnmpStrToEntity
                              (IN HSNMP_SESSION session,
                              IN LPCSTR string);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpEntityToStr
                              (__in HSNMP_ENTITY entity,
                              __in smiUINT32 size,
                              __out_ecount(size) LPSTR string);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpFreeEntity
                              (IN HSNMP_ENTITY entity);

HSNMP_CONTEXT  SNMPAPI_CALL   SnmpStrToContext
                              (IN HSNMP_SESSION session,
                              IN smiLPCOCTETS string);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpContextToStr
                              (IN HSNMP_CONTEXT context,
                              OUT smiLPOCTETS string);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpFreeContext
                              (IN HSNMP_CONTEXT context);

/* Following Entity/Context Functions added in v2.0 */
SNMPAPI_STATUS SNMPAPI_CALL   SnmpSetPort
                              (IN HSNMP_ENTITY hEntity,
                              IN UINT nPort);

/* PDU Functions */
HSNMP_PDU      SNMPAPI_CALL   SnmpCreatePdu
                              (IN HSNMP_SESSION session,
                              IN smiINT PDU_type,
                              IN smiINT32 request_id,
                              IN smiINT error_status,
                              IN smiINT error_index,
                              IN HSNMP_VBL varbindlist);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetPduData
                              (IN HSNMP_PDU PDU,
                              OUT smiLPINT PDU_type,
                              OUT smiLPINT32 request_id,
                              OUT smiLPINT error_status,
                              OUT smiLPINT error_index,
                              OUT LPHSNMP_VBL varbindlist);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpSetPduData
                              (IN HSNMP_PDU PDU,
                              IN const smiINT FAR *PDU_type,
                              IN const smiINT32 FAR *request_id,
                              IN const smiINT FAR *non_repeaters,
                              IN const smiINT FAR *max_repetitions,
                              IN const HSNMP_VBL FAR *varbindlist);

HSNMP_PDU      SNMPAPI_CALL   SnmpDuplicatePdu
                              (IN HSNMP_SESSION session,
                              IN HSNMP_PDU PDU);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpFreePdu
                              (IN HSNMP_PDU PDU);

/* Variable-Binding Functions */
HSNMP_VBL      SNMPAPI_CALL   SnmpCreateVbl
                              (IN HSNMP_SESSION session,
                              IN smiLPCOID name,
                              IN smiLPCVALUE value);

HSNMP_VBL      SNMPAPI_CALL   SnmpDuplicateVbl
                              (IN HSNMP_SESSION session,
                              IN HSNMP_VBL vbl);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpFreeVbl
                              (IN HSNMP_VBL vbl);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpCountVbl
                              (IN HSNMP_VBL vbl);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetVb
                              (IN HSNMP_VBL vbl,
                              IN smiUINT32 index,
                              OUT smiLPOID name,
                              OUT smiLPVALUE value);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpSetVb
                              (IN HSNMP_VBL vbl,
                              IN smiUINT32 index,
                              IN smiLPCOID name,
                              IN smiLPCVALUE value);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpDeleteVb
                              (IN HSNMP_VBL vbl,
                              IN smiUINT32 index);

/* Utility Functions */
SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetLastError
                              (IN HSNMP_SESSION session);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpStrToOid
                              (IN LPCSTR string,
                              OUT smiLPOID dstOID);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpOidToStr
                              (__in smiLPCOID srcOID,
                              __in smiUINT32 size,
                              __out_ecount(size) LPSTR string);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpOidCopy
                              (IN smiLPCOID srcOID,
                              OUT smiLPOID dstOID);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpOidCompare
                              (IN smiLPCOID xOID,
                              IN smiLPCOID yOID,
                              IN smiUINT32 maxlen,
                              OUT smiLPINT result);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpEncodeMsg
                              (IN HSNMP_SESSION session,
                              IN HSNMP_ENTITY srcEntity,
                              IN HSNMP_ENTITY dstEntity,
                              IN HSNMP_CONTEXT context,
                              IN HSNMP_PDU pdu,
                              OUT smiLPOCTETS msgBufDesc);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpDecodeMsg
                              (IN HSNMP_SESSION session,
                              OUT LPHSNMP_ENTITY srcEntity,
                              OUT LPHSNMP_ENTITY dstEntity,
                              OUT LPHSNMP_CONTEXT context,
                              OUT LPHSNMP_PDU pdu,
                              IN smiLPCOCTETS msgBufDesc);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpFreeDescriptor
                              (IN smiUINT32 syntax,
                              IN smiLPOPAQUE descriptor);

#ifdef __cplusplus
}
#endif

#endif         /* _INC_WINSNMP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WinSock2.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    118736
//  $AgreementName:  berkeley software distribution license
//  $AgreementType:  oss license
//  $ExternalOrigin: regents of the university of california
//$ENDTAG

//$TAG ENGR 
//  $Owner:    vadime
//  $Module:   published_inc
//
//$ENDTAG

/* Winsock2.h -- definitions to be used with the WinSock 2 DLL and
 *               WinSock 2 applications.
 *
 * This header file corresponds to version 2.2.x of the WinSock API
 * specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 */

#ifndef _WINSOCK2API_
#define _WINSOCK2API_
#define _WINSOCKAPI_   /* Prevent inclusion of winsock.h in windows.h */

#pragma once

/*
 * Ensure structures are packed consistently.
 * Not necessary for WIN32, it is already packed >=4 and there are
 * no structures in this header that have alignment requirement 
 * higher than 4.
 * For WIN64 we do not have compatibility requirement because it is
 * not possible to mix 32/16 bit code with 64 bit code in the same
 * process.
 */

#if (!defined(_WIN64) && !defined(WIN32))
#include <pshpack4.h>
/* WIN32 can be defined between here and the required poppack 
   so define this special macro to ensure poppack */
#define _NEED_POPPACK
#endif

/*
 * Default: include function prototypes, don't include function typedefs.
 */

#ifndef INCL_WINSOCK_API_PROTOTYPES
#define INCL_WINSOCK_API_PROTOTYPES 1
#endif

#ifndef INCL_WINSOCK_API_TYPEDEFS
#define INCL_WINSOCK_API_TYPEDEFS 0
#endif

/*
 * Pull in WINDOWS.H if necessary
 */
#ifndef _INC_WINDOWS
#include <windows.h>
#endif /* _INC_WINDOWS */

/*
 * Define the current Winsock version. To build an earlier Winsock version
 * application redefine this value prior to including Winsock2.h.
 */

#if !defined(MAKEWORD)
#define MAKEWORD(low,high) \
        ((WORD)(((BYTE)(low)) | ((WORD)((BYTE)(high))) << 8))
#endif

#ifndef WINSOCK_VERSION
#define WINSOCK_VERSION MAKEWORD(2,2)
#endif

/*
 * Establish DLL function linkage if supported by the current build
 * environment and not previously defined.
 */

#ifndef WINSOCK_API_LINKAGE
#ifdef DECLSPEC_IMPORT
#define WINSOCK_API_LINKAGE DECLSPEC_IMPORT
#else
#define WINSOCK_API_LINKAGE
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 */
typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;

#if(_WIN32_WINNT >= 0x0501)
typedef unsigned __int64 u_int64;
#endif //(_WIN32_WINNT >= 0x0501)

#include <ws2def.h>

/*
 * The new type to be used in all
 * instances which refer to sockets.
 */
typedef UINT_PTR        SOCKET;

/*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be >= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK2.H EXACTLY AS SHOWN HERE.
 */
#ifndef FD_SETSIZE
#define FD_SETSIZE      64
#endif /* FD_SETSIZE */

typedef struct fd_set {
        u_int fd_count;               /* how many are SET? */
        SOCKET  fd_array[FD_SETSIZE];   /* an array of SOCKETs */
} fd_set;

__control_entrypoint(DllExport) extern int PASCAL FAR __WSAFDIsSet(SOCKET fd, fd_set FAR *);

#define FD_CLR(fd, set) do { \
    u_int __i; \
    for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count ; __i++) { \
        if (((fd_set FAR *)(set))->fd_array[__i] == fd) { \
            while (__i < ((fd_set FAR *)(set))->fd_count-1) { \
                ((fd_set FAR *)(set))->fd_array[__i] = \
                    ((fd_set FAR *)(set))->fd_array[__i+1]; \
                __i++; \
            } \
            ((fd_set FAR *)(set))->fd_count--; \
            break; \
        } \
    } \
} while(0)

#define FD_SET(fd, set) do { \
    u_int __i; \
    for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count; __i++) { \
        if (((fd_set FAR *)(set))->fd_array[__i] == (fd)) { \
            break; \
        } \
    } \
    if (__i == ((fd_set FAR *)(set))->fd_count) { \
        if (((fd_set FAR *)(set))->fd_count < FD_SETSIZE) { \
            ((fd_set FAR *)(set))->fd_array[__i] = (fd); \
            ((fd_set FAR *)(set))->fd_count++; \
        } \
    } \
} while(0)

#define FD_ZERO(set) (((fd_set FAR *)(set))->fd_count=0)

#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set FAR *)(set))

/*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 */
struct timeval {
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
};

/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 */
#define timerisset(tvp)         ((tvp)->tv_sec || (tvp)->tv_usec)
#define timercmp(tvp, uvp, cmp) \
        ((tvp)->tv_sec cmp (uvp)->tv_sec || \
         (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec)
#define timerclear(tvp)         (tvp)->tv_sec = (tvp)->tv_usec = 0

/*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */
#define IOCPARM_MASK    0x7f            /* parameters must be < 128 bytes */
#define IOC_VOID        0x20000000      /* no parameters */
#define IOC_OUT         0x40000000      /* copy out parameters */
#define IOC_IN          0x80000000      /* copy in parameters */
#define IOC_INOUT       (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))

#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define FIONREAD    _IOR('f', 127, u_long) /* get # bytes to read */
#define FIONBIO     _IOW('f', 126, u_long) /* set/clear non-blocking i/o */
#define FIOASYNC    _IOW('f', 125, u_long) /* set/clear async i/o */

/* Socket I/O Controls */
#define SIOCSHIWAT  _IOW('s',  0, u_long)  /* set high watermark */
#define SIOCGHIWAT  _IOR('s',  1, u_long)  /* get high watermark */
#define SIOCSLOWAT  _IOW('s',  2, u_long)  /* set low watermark */
#define SIOCGLOWAT  _IOR('s',  3, u_long)  /* get low watermark */
#define SIOCATMARK  _IOR('s',  7, u_long)  /* at oob mark? */

/*
 * Structures returned by network data base library, taken from the
 * BSD file netdb.h.  All addresses are supplied in host order, and
 * returned in network order (suitable for use in system calls).
 */

struct  hostent {
        char    FAR * h_name;           /* official name of host */
        char    FAR * FAR * h_aliases;  /* alias list */
        short   h_addrtype;             /* host address type */
        short   h_length;               /* length of address */
        char    FAR * FAR * h_addr_list; /* list of addresses */
#define h_addr  h_addr_list[0]          /* address, for backward compat */
};

/*
 * It is assumed here that a network number
 * fits in 32 bits.
 */
struct  netent {
        char    FAR * n_name;           /* official name of net */
        char    FAR * FAR * n_aliases;  /* alias list */
        short   n_addrtype;             /* net address type */
        u_long  n_net;                  /* network # */
};

struct  servent {
        char    FAR * s_name;           /* official service name */
        char    FAR * FAR * s_aliases;  /* alias list */
#ifdef _WIN64
        char    FAR * s_proto;          /* protocol to use */
        short   s_port;                 /* port # */
#else
        short   s_port;                 /* port # */
        char    FAR * s_proto;          /* protocol to use */
#endif
};

struct  protoent {
        char    FAR * p_name;           /* official protocol name */
        char    FAR * FAR * p_aliases;  /* alias list */
        short   p_proto;                /* protocol # */
};

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 * IPv6 additions per RFC 2292.
 */

/*
 * Port/socket numbers: network standard functions
 */
#define IPPORT_ECHO             7
#define IPPORT_DISCARD          9
#define IPPORT_SYSTAT           11
#define IPPORT_DAYTIME          13
#define IPPORT_NETSTAT          15
#define IPPORT_FTP              21
#define IPPORT_TELNET           23
#define IPPORT_SMTP             25
#define IPPORT_TIMESERVER       37
#define IPPORT_NAMESERVER       42
#define IPPORT_WHOIS            43
#define IPPORT_MTP              57

/*
 * Port/socket numbers: host specific functions
 */
#define IPPORT_TFTP             69
#define IPPORT_RJE              77
#define IPPORT_FINGER           79
#define IPPORT_TTYLINK          87
#define IPPORT_SUPDUP           95

/*
 * UNIX TCP sockets
 */
#define IPPORT_EXECSERVER       512
#define IPPORT_LOGINSERVER      513
#define IPPORT_CMDSERVER        514
#define IPPORT_EFSSERVER        520

/*
 * UNIX UDP sockets
 */
#define IPPORT_BIFFUDP          512
#define IPPORT_WHOSERVER        513
#define IPPORT_ROUTESERVER      520
                                        /* 520+1 also used */

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
#define IPPORT_RESERVED         1024

/*
 * Link numbers
 */
#define IMPLINK_IP              155
#define IMPLINK_LOWEXPER        156
#define IMPLINK_HIGHEXPER       158

#ifndef s_addr
/*
 * Internet address (old style... should be updated)
 */
struct in_addr {
        union {
                struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { u_short s_w1,s_w2; } S_un_w;
                u_long S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};
#endif

#define ADDR_ANY                INADDR_ANY

#define WSADESCRIPTION_LEN      256
#define WSASYS_STATUS_LEN       128

typedef struct WSAData {
        WORD                    wVersion;
        WORD                    wHighVersion;
#ifdef _WIN64
        unsigned short          iMaxSockets;
        unsigned short          iMaxUdpDg;
        char FAR *              lpVendorInfo;
        char                    szDescription[WSADESCRIPTION_LEN+1];
        char                    szSystemStatus[WSASYS_STATUS_LEN+1];
#else
        char                    szDescription[WSADESCRIPTION_LEN+1];
        char                    szSystemStatus[WSASYS_STATUS_LEN+1];
        unsigned short          iMaxSockets;
        unsigned short          iMaxUdpDg;
        char FAR *              lpVendorInfo;
#endif
} WSADATA, FAR * LPWSADATA;

/*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 */

/*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 */
#define INVALID_SOCKET  (SOCKET)(~0)
#define SOCKET_ERROR            (-1)

/*
 * The  following  may  be used in place of the address family, socket type, or
 * protocol  in  a  call  to WSASocket to indicate that the corresponding value
 * should  be taken from the supplied WSAPROTOCOL_INFO structure instead of the
 * parameter itself.
 */
#define FROM_PROTOCOL_INFO (-1)

/*
 * Types
 */
#define SOCK_STREAM     1               /* stream socket */
#define SOCK_DGRAM      2               /* datagram socket */
#define SOCK_RAW        3               /* raw-protocol interface */
#define SOCK_RDM        4               /* reliably-delivered message */
#define SOCK_SEQPACKET  5               /* sequenced packet stream */

/*
 * Option flags per-socket.
 */
#define SO_DEBUG        0x0001          /* turn on debugging info recording */
#define SO_ACCEPTCONN   0x0002          /* socket has had listen() */
#define SO_REUSEADDR    0x0004          /* allow local address reuse */
#define SO_KEEPALIVE    0x0008          /* keep connections alive */
#define SO_DONTROUTE    0x0010          /* just use interface addresses */
#define SO_BROADCAST    0x0020          /* permit sending of broadcast msgs */
#define SO_USELOOPBACK  0x0040          /* bypass hardware when possible */
#define SO_LINGER       0x0080          /* linger on close if data present */
#define SO_OOBINLINE    0x0100          /* leave received OOB data in line */

#define SO_DONTLINGER   (int)(~SO_LINGER)
#define SO_EXCLUSIVEADDRUSE ((int)(~SO_REUSEADDR)) /* disallow local address reuse */

/*
 * Additional options.
 */
#define SO_SNDBUF       0x1001          /* send buffer size */
#define SO_RCVBUF       0x1002          /* receive buffer size */
#define SO_SNDLOWAT     0x1003          /* send low-water mark */
#define SO_RCVLOWAT     0x1004          /* receive low-water mark */
#define SO_SNDTIMEO     0x1005          /* send timeout */
#define SO_RCVTIMEO     0x1006          /* receive timeout */
#define SO_ERROR        0x1007          /* get error status and clear */
#define SO_TYPE         0x1008          /* get socket type */

/*
 * WinSock 2 extension -- new options
 */
#define SO_GROUP_ID       0x2001      /* ID of a socket group */
#define SO_GROUP_PRIORITY 0x2002      /* the relative priority within a group*/
#define SO_MAX_MSG_SIZE   0x2003      /* maximum message size */
#define SO_PROTOCOL_INFOA 0x2004      /* WSAPROTOCOL_INFOA structure */
#define SO_PROTOCOL_INFOW 0x2005      /* WSAPROTOCOL_INFOW structure */
#ifdef UNICODE
#define SO_PROTOCOL_INFO  SO_PROTOCOL_INFOW
#else
#define SO_PROTOCOL_INFO  SO_PROTOCOL_INFOA
#endif /* UNICODE */
#define PVD_CONFIG        0x3001       /* configuration info for service provider */
#define SO_CONDITIONAL_ACCEPT 0x3002   /* enable true conditional accept: */
                                       /*  connection is not ack-ed to the */
                                       /*  other side until conditional */
                                       /*  function returns CF_ACCEPT */

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
        u_short sp_family;              /* address family */
        u_short sp_protocol;            /* protocol */
};

/*
 * Protocol families, same as address families for now.
 */
#define PF_UNSPEC       AF_UNSPEC
#define PF_UNIX         AF_UNIX
#define PF_INET         AF_INET
#define PF_IMPLINK      AF_IMPLINK
#define PF_PUP          AF_PUP
#define PF_CHAOS        AF_CHAOS
#define PF_NS           AF_NS
#define PF_IPX          AF_IPX
#define PF_ISO          AF_ISO
#define PF_OSI          AF_OSI
#define PF_ECMA         AF_ECMA
#define PF_DATAKIT      AF_DATAKIT
#define PF_CCITT        AF_CCITT
#define PF_SNA          AF_SNA
#define PF_DECnet       AF_DECnet
#define PF_DLI          AF_DLI
#define PF_LAT          AF_LAT
#define PF_HYLINK       AF_HYLINK
#define PF_APPLETALK    AF_APPLETALK
#define PF_VOICEVIEW    AF_VOICEVIEW
#define PF_FIREFOX      AF_FIREFOX
#define PF_UNKNOWN1     AF_UNKNOWN1
#define PF_BAN          AF_BAN
#define PF_ATM          AF_ATM
#define PF_INET6        AF_INET6
#if(_WIN32_WINNT >= 0x0600)
#define PF_BTH          AF_BTH
#endif //(_WIN32_WINNT >= 0x0600)

#define PF_MAX          AF_MAX

/*
 * Structure used for manipulating linger option.
 */
struct  linger {
        u_short l_onoff;                /* option on/off */
        u_short l_linger;               /* linger time */
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define SOL_SOCKET      0xffff          /* options for socket level */

/*
 * Maximum queue length specifiable by listen.
 */
#define SOMAXCONN       0x7fffffff

#define MSG_OOB         0x1             /* process out-of-band data */
#define MSG_PEEK        0x2             /* peek at incoming message */
#define MSG_DONTROUTE   0x4             /* send without using routing tables */

#if(_WIN32_WINNT >= 0x0502)
#define MSG_WAITALL     0x8             /* do not complete until packet is completely filled */
#endif //(_WIN32_WINNT >= 0x0502)

#define MSG_PARTIAL     0x8000          /* partial send or recv for message xport */

/*
 * WinSock 2 extension -- new flags for WSASend(), WSASendTo(), WSARecv() and
 *                          WSARecvFrom()
 */
#define MSG_INTERRUPT   0x10            /* send/recv in the interrupt context */

#define MSG_MAXIOVLEN   16

/*
 * Define constant based on rfc883, used by gethostbyxxxx() calls.
 */
#define MAXGETHOSTSTRUCT        1024

/*
 * WinSock 2 extension -- bit values and indices for FD_XXX network events
 */
#define FD_READ_BIT      0
#define FD_READ          (1 << FD_READ_BIT)

#define FD_WRITE_BIT     1
#define FD_WRITE         (1 << FD_WRITE_BIT)

#define FD_OOB_BIT       2
#define FD_OOB           (1 << FD_OOB_BIT)

#define FD_ACCEPT_BIT    3
#define FD_ACCEPT        (1 << FD_ACCEPT_BIT)

#define FD_CONNECT_BIT   4
#define FD_CONNECT       (1 << FD_CONNECT_BIT)

#define FD_CLOSE_BIT     5
#define FD_CLOSE         (1 << FD_CLOSE_BIT)

#define FD_QOS_BIT       6
#define FD_QOS           (1 << FD_QOS_BIT)

#define FD_GROUP_QOS_BIT 7
#define FD_GROUP_QOS     (1 << FD_GROUP_QOS_BIT)

#define FD_ROUTING_INTERFACE_CHANGE_BIT 8
#define FD_ROUTING_INTERFACE_CHANGE     (1 << FD_ROUTING_INTERFACE_CHANGE_BIT)

#define FD_ADDRESS_LIST_CHANGE_BIT 9
#define FD_ADDRESS_LIST_CHANGE     (1 << FD_ADDRESS_LIST_CHANGE_BIT)

#define FD_MAX_EVENTS    10
#define FD_ALL_EVENTS    ((1 << FD_MAX_EVENTS) - 1)


/*
 * WinSock error codes are also defined in winerror.h
 * Hence the IFDEF.
 */
#ifndef WSABASEERR

/*
 * All Windows Sockets error constants are biased by WSABASEERR from
 * the "normal"
 */
#define WSABASEERR              10000

/*
 * Windows Sockets definitions of regular Microsoft C error constants
 */
#define WSAEINTR                (WSABASEERR+4)
#define WSAEBADF                (WSABASEERR+9)
#define WSAEACCES               (WSABASEERR+13)
#define WSAEFAULT               (WSABASEERR+14)
#define WSAEINVAL               (WSABASEERR+22)
#define WSAEMFILE               (WSABASEERR+24)

/*
 * Windows Sockets definitions of regular Berkeley error constants
 */
#define WSAEWOULDBLOCK          (WSABASEERR+35)
#define WSAEINPROGRESS          (WSABASEERR+36)
#define WSAEALREADY             (WSABASEERR+37)
#define WSAENOTSOCK             (WSABASEERR+38)
#define WSAEDESTADDRREQ         (WSABASEERR+39)
#define WSAEMSGSIZE             (WSABASEERR+40)
#define WSAEPROTOTYPE           (WSABASEERR+41)
#define WSAENOPROTOOPT          (WSABASEERR+42)
#define WSAEPROTONOSUPPORT      (WSABASEERR+43)
#define WSAESOCKTNOSUPPORT      (WSABASEERR+44)
#define WSAEOPNOTSUPP           (WSABASEERR+45)
#define WSAEPFNOSUPPORT         (WSABASEERR+46)
#define WSAEAFNOSUPPORT         (WSABASEERR+47)
#define WSAEADDRINUSE           (WSABASEERR+48)
#define WSAEADDRNOTAVAIL        (WSABASEERR+49)
#define WSAENETDOWN             (WSABASEERR+50)
#define WSAENETUNREACH          (WSABASEERR+51)
#define WSAENETRESET            (WSABASEERR+52)
#define WSAECONNABORTED         (WSABASEERR+53)
#define WSAECONNRESET           (WSABASEERR+54)
#define WSAENOBUFS              (WSABASEERR+55)
#define WSAEISCONN              (WSABASEERR+56)
#define WSAENOTCONN             (WSABASEERR+57)
#define WSAESHUTDOWN            (WSABASEERR+58)
#define WSAETOOMANYREFS         (WSABASEERR+59)
#define WSAETIMEDOUT            (WSABASEERR+60)
#define WSAECONNREFUSED         (WSABASEERR+61)
#define WSAELOOP                (WSABASEERR+62)
#define WSAENAMETOOLONG         (WSABASEERR+63)
#define WSAEHOSTDOWN            (WSABASEERR+64)
#define WSAEHOSTUNREACH         (WSABASEERR+65)
#define WSAENOTEMPTY            (WSABASEERR+66)
#define WSAEPROCLIM             (WSABASEERR+67)
#define WSAEUSERS               (WSABASEERR+68)
#define WSAEDQUOT               (WSABASEERR+69)
#define WSAESTALE               (WSABASEERR+70)
#define WSAEREMOTE              (WSABASEERR+71)

/*
 * Extended Windows Sockets error constant definitions
 */
#define WSASYSNOTREADY          (WSABASEERR+91)
#define WSAVERNOTSUPPORTED      (WSABASEERR+92)
#define WSANOTINITIALISED       (WSABASEERR+93)
#define WSAEDISCON              (WSABASEERR+101)
#define WSAENOMORE              (WSABASEERR+102)
#define WSAECANCELLED           (WSABASEERR+103)
#define WSAEINVALIDPROCTABLE    (WSABASEERR+104)
#define WSAEINVALIDPROVIDER     (WSABASEERR+105)
#define WSAEPROVIDERFAILEDINIT  (WSABASEERR+106)
#define WSASYSCALLFAILURE       (WSABASEERR+107)
#define WSASERVICE_NOT_FOUND    (WSABASEERR+108)
#define WSATYPE_NOT_FOUND       (WSABASEERR+109)
#define WSA_E_NO_MORE           (WSABASEERR+110)
#define WSA_E_CANCELLED         (WSABASEERR+111)
#define WSAEREFUSED             (WSABASEERR+112)

/*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (when using the resolver). Note that these errors are
 * retrieved via WSAGetLastError() and must therefore follow
 * the rules for avoiding clashes with error numbers from
 * specific implementations or language run-time systems.
 * For this reason the codes are based at WSABASEERR+1001.
 * Note also that [WSA]NO_ADDRESS is defined only for
 * compatibility purposes.
 */

/* Authoritative Answer: Host not found */
#define WSAHOST_NOT_FOUND       (WSABASEERR+1001)

/* Non-Authoritative: Host not found, or SERVERFAIL */
#define WSATRY_AGAIN            (WSABASEERR+1002)

/* Non-recoverable errors, FORMERR, REFUSED, NOTIMP */
#define WSANO_RECOVERY          (WSABASEERR+1003)

/* Valid name, no data record of requested type */
#define WSANO_DATA              (WSABASEERR+1004)

/*
 * Define QOS related error return codes
 *
 */
#define  WSA_QOS_RECEIVERS               (WSABASEERR + 1005)
         /* at least one Reserve has arrived */
#define  WSA_QOS_SENDERS                 (WSABASEERR + 1006)
         /* at least one Path has arrived */
#define  WSA_QOS_NO_SENDERS              (WSABASEERR + 1007)
         /* there are no senders */
#define  WSA_QOS_NO_RECEIVERS            (WSABASEERR + 1008)
         /* there are no receivers */
#define  WSA_QOS_REQUEST_CONFIRMED       (WSABASEERR + 1009)
         /* Reserve has been confirmed */
#define  WSA_QOS_ADMISSION_FAILURE       (WSABASEERR + 1010)
         /* error due to lack of resources */
#define  WSA_QOS_POLICY_FAILURE          (WSABASEERR + 1011)
         /* rejected for administrative reasons - bad credentials */
#define  WSA_QOS_BAD_STYLE               (WSABASEERR + 1012)
         /* unknown or conflicting style */
#define  WSA_QOS_BAD_OBJECT              (WSABASEERR + 1013)
         /* problem with some part of the filterspec or providerspecific
          * buffer in general */
#define  WSA_QOS_TRAFFIC_CTRL_ERROR      (WSABASEERR + 1014)
         /* problem with some part of the flowspec */
#define  WSA_QOS_GENERIC_ERROR           (WSABASEERR + 1015)
         /* general error */
#define  WSA_QOS_ESERVICETYPE            (WSABASEERR + 1016)
         /* invalid service type in flowspec */
#define  WSA_QOS_EFLOWSPEC               (WSABASEERR + 1017)
         /* invalid flowspec */
#define  WSA_QOS_EPROVSPECBUF            (WSABASEERR + 1018)
         /* invalid provider specific buffer */
#define  WSA_QOS_EFILTERSTYLE            (WSABASEERR + 1019)
         /* invalid filter style */
#define  WSA_QOS_EFILTERTYPE             (WSABASEERR + 1020)
         /* invalid filter type */
#define  WSA_QOS_EFILTERCOUNT            (WSABASEERR + 1021)
         /* incorrect number of filters */
#define  WSA_QOS_EOBJLENGTH              (WSABASEERR + 1022)
         /* invalid object length */
#define  WSA_QOS_EFLOWCOUNT              (WSABASEERR + 1023)
         /* incorrect number of flows */
#define  WSA_QOS_EUNKOWNPSOBJ            (WSABASEERR + 1024)
         /* unknown object in provider specific buffer */
#define  WSA_QOS_EPOLICYOBJ              (WSABASEERR + 1025)
         /* invalid policy object in provider specific buffer */
#define  WSA_QOS_EFLOWDESC               (WSABASEERR + 1026)
         /* invalid flow descriptor in the list */
#define  WSA_QOS_EPSFLOWSPEC             (WSABASEERR + 1027)
         /* inconsistent flow spec in provider specific buffer */
#define  WSA_QOS_EPSFILTERSPEC           (WSABASEERR + 1028)
         /* invalid filter spec in provider specific buffer */
#define  WSA_QOS_ESDMODEOBJ              (WSABASEERR + 1029)
         /* invalid shape discard mode object in provider specific buffer */
#define  WSA_QOS_ESHAPERATEOBJ           (WSABASEERR + 1030)
         /* invalid shaping rate object in provider specific buffer */
#define  WSA_QOS_RESERVED_PETYPE         (WSABASEERR + 1031)
         /* reserved policy element in provider specific buffer */



/*
 * WinSock error codes are also defined in winerror.h
 * Hence the IFDEF.
 */
#endif /* ifdef WSABASEERR */

/*
 * Compatibility macros.
 */

#define h_errno         WSAGetLastError()
#define HOST_NOT_FOUND          WSAHOST_NOT_FOUND
#define TRY_AGAIN               WSATRY_AGAIN
#define NO_RECOVERY             WSANO_RECOVERY
#define NO_DATA                 WSANO_DATA
/* no address, look for MX record */
#define WSANO_ADDRESS           WSANO_DATA
#define NO_ADDRESS              WSANO_ADDRESS



/*
 * Windows Sockets errors redefined as regular Berkeley error constants.
 * These are commented out in Windows NT to avoid conflicts with errno.h.
 * Use the WSA constants instead.
 */
#if 0
#define EWOULDBLOCK             WSAEWOULDBLOCK
#define EINPROGRESS             WSAEINPROGRESS
#define EALREADY                WSAEALREADY
#define ENOTSOCK                WSAENOTSOCK
#define EDESTADDRREQ            WSAEDESTADDRREQ
#define EMSGSIZE                WSAEMSGSIZE
#define EPROTOTYPE              WSAEPROTOTYPE
#define ENOPROTOOPT             WSAENOPROTOOPT
#define EPROTONOSUPPORT         WSAEPROTONOSUPPORT
#define ESOCKTNOSUPPORT         WSAESOCKTNOSUPPORT
#define EOPNOTSUPP              WSAEOPNOTSUPP
#define EPFNOSUPPORT            WSAEPFNOSUPPORT
#define EAFNOSUPPORT            WSAEAFNOSUPPORT
#define EADDRINUSE              WSAEADDRINUSE
#define EADDRNOTAVAIL           WSAEADDRNOTAVAIL
#define ENETDOWN                WSAENETDOWN
#define ENETUNREACH             WSAENETUNREACH
#define ENETRESET               WSAENETRESET
#define ECONNABORTED            WSAECONNABORTED
#define ECONNRESET              WSAECONNRESET
#define ENOBUFS                 WSAENOBUFS
#define EISCONN                 WSAEISCONN
#define ENOTCONN                WSAENOTCONN
#define ESHUTDOWN               WSAESHUTDOWN
#define ETOOMANYREFS            WSAETOOMANYREFS
#define ETIMEDOUT               WSAETIMEDOUT
#define ECONNREFUSED            WSAECONNREFUSED
#define ELOOP                   WSAELOOP
#define ENAMETOOLONG            WSAENAMETOOLONG
#define EHOSTDOWN               WSAEHOSTDOWN
#define EHOSTUNREACH            WSAEHOSTUNREACH
#define ENOTEMPTY               WSAENOTEMPTY
#define EPROCLIM                WSAEPROCLIM
#define EUSERS                  WSAEUSERS
#define EDQUOT                  WSAEDQUOT
#define ESTALE                  WSAESTALE
#define EREMOTE                 WSAEREMOTE
#endif

/*
 * WinSock 2 extension -- new error codes and type definition
 */

#ifdef WIN32

#define WSAAPI                  FAR PASCAL
#define WSAEVENT                HANDLE
#define LPWSAEVENT              LPHANDLE
#define WSAOVERLAPPED           OVERLAPPED
typedef struct _OVERLAPPED *    LPWSAOVERLAPPED;

#define WSA_IO_PENDING          (ERROR_IO_PENDING)
#define WSA_IO_INCOMPLETE       (ERROR_IO_INCOMPLETE)
#define WSA_INVALID_HANDLE      (ERROR_INVALID_HANDLE)
#define WSA_INVALID_PARAMETER   (ERROR_INVALID_PARAMETER)
#define WSA_NOT_ENOUGH_MEMORY   (ERROR_NOT_ENOUGH_MEMORY)
#define WSA_OPERATION_ABORTED   (ERROR_OPERATION_ABORTED)

#define WSA_INVALID_EVENT       ((WSAEVENT)NULL)
#define WSA_MAXIMUM_WAIT_EVENTS (MAXIMUM_WAIT_OBJECTS)
#define WSA_WAIT_FAILED         (WAIT_FAILED)
#define WSA_WAIT_EVENT_0        (WAIT_OBJECT_0)
#define WSA_WAIT_IO_COMPLETION  (WAIT_IO_COMPLETION)
#define WSA_WAIT_TIMEOUT        (WAIT_TIMEOUT)
#define WSA_INFINITE            (INFINITE)

#else /* WIN16 */

#define WSAAPI                  FAR PASCAL
typedef DWORD                   WSAEVENT, FAR * LPWSAEVENT;

typedef struct _WSAOVERLAPPED {
    DWORD    Internal;
    DWORD    InternalHigh;
    DWORD    Offset;
    DWORD    OffsetHigh;
    WSAEVENT hEvent;
} WSAOVERLAPPED, FAR * LPWSAOVERLAPPED;

#define WSA_IO_PENDING          (WSAEWOULDBLOCK)
#define WSA_IO_INCOMPLETE       (WSAEWOULDBLOCK)
#define WSA_INVALID_HANDLE      (WSAENOTSOCK)
#define WSA_INVALID_PARAMETER   (WSAEINVAL)
#define WSA_NOT_ENOUGH_MEMORY   (WSAENOBUFS)
#define WSA_OPERATION_ABORTED   (WSAEINTR)

#define WSA_INVALID_EVENT       ((WSAEVENT)NULL)
#define WSA_MAXIMUM_WAIT_EVENTS (MAXIMUM_WAIT_OBJECTS)
#define WSA_WAIT_FAILED         ((DWORD)-1L)
#define WSA_WAIT_EVENT_0        ((DWORD)0)
#define WSA_WAIT_TIMEOUT        ((DWORD)0x102L)
#define WSA_INFINITE            ((DWORD)-1L)

#endif  /* WIN32 */

/*
 * Include qos.h to pull in FLOWSPEC and related definitions
 */
#include <qos.h>

typedef struct _QualityOfService
{
    FLOWSPEC      SendingFlowspec;       /* the flow spec for data sending */
    FLOWSPEC      ReceivingFlowspec;     /* the flow spec for data receiving */
    WSABUF        ProviderSpecific;      /* additional provider specific stuff */
} QOS, FAR * LPQOS;

/*
 * WinSock 2 extension -- manifest constants for return values of the condition function
 */
#define CF_ACCEPT       0x0000
#define CF_REJECT       0x0001
#define CF_DEFER        0x0002

/*
 * WinSock 2 extension -- manifest constants for shutdown()
 */
#define SD_RECEIVE      0x00
#define SD_SEND         0x01
#define SD_BOTH         0x02

/*
 * WinSock 2 extension -- data type and manifest constants for socket groups
 */
typedef unsigned int             GROUP;

#define SG_UNCONSTRAINED_GROUP   0x01
#define SG_CONSTRAINED_GROUP     0x02

/*
 * WinSock 2 extension -- data type for WSAEnumNetworkEvents()
 */
typedef struct _WSANETWORKEVENTS {
       long lNetworkEvents;
       int iErrorCode[FD_MAX_EVENTS];
} WSANETWORKEVENTS, FAR * LPWSANETWORKEVENTS;

/*
 * WinSock 2 extension -- WSAPROTOCOL_INFO structure and associated
 * manifest constants
 */

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

#define MAX_PROTOCOL_CHAIN 7

#define BASE_PROTOCOL      1
#define LAYERED_PROTOCOL   0

typedef struct _WSAPROTOCOLCHAIN {
    int ChainLen;                                 /* the length of the chain,     */
                                                  /* length = 0 means layered protocol, */
                                                  /* length = 1 means base protocol, */
                                                  /* length > 1 means protocol chain */
    DWORD ChainEntries[MAX_PROTOCOL_CHAIN];       /* a list of dwCatalogEntryIds */
} WSAPROTOCOLCHAIN, FAR * LPWSAPROTOCOLCHAIN;

#define WSAPROTOCOL_LEN  255

typedef struct _WSAPROTOCOL_INFOA {
    DWORD dwServiceFlags1;
    DWORD dwServiceFlags2;
    DWORD dwServiceFlags3;
    DWORD dwServiceFlags4;
    DWORD dwProviderFlags;
    GUID ProviderId;
    DWORD dwCatalogEntryId;
    WSAPROTOCOLCHAIN ProtocolChain;
    int iVersion;
    int iAddressFamily;
    int iMaxSockAddr;
    int iMinSockAddr;
    int iSocketType;
    int iProtocol;
    int iProtocolMaxOffset;
    int iNetworkByteOrder;
    int iSecurityScheme;
    DWORD dwMessageSize;
    DWORD dwProviderReserved;
    CHAR   szProtocol[WSAPROTOCOL_LEN+1];
} WSAPROTOCOL_INFOA, FAR * LPWSAPROTOCOL_INFOA;
typedef struct _WSAPROTOCOL_INFOW {
    DWORD dwServiceFlags1;
    DWORD dwServiceFlags2;
    DWORD dwServiceFlags3;
    DWORD dwServiceFlags4;
    DWORD dwProviderFlags;
    GUID ProviderId;
    DWORD dwCatalogEntryId;
    WSAPROTOCOLCHAIN ProtocolChain;
    int iVersion;
    int iAddressFamily;
    int iMaxSockAddr;
    int iMinSockAddr;
    int iSocketType;
    int iProtocol;
    int iProtocolMaxOffset;
    int iNetworkByteOrder;
    int iSecurityScheme;
    DWORD dwMessageSize;
    DWORD dwProviderReserved;
    WCHAR  szProtocol[WSAPROTOCOL_LEN+1];
} WSAPROTOCOL_INFOW, FAR * LPWSAPROTOCOL_INFOW;
#ifdef UNICODE
typedef WSAPROTOCOL_INFOW WSAPROTOCOL_INFO;
typedef LPWSAPROTOCOL_INFOW LPWSAPROTOCOL_INFO;
#else
typedef WSAPROTOCOL_INFOA WSAPROTOCOL_INFO;
typedef LPWSAPROTOCOL_INFOA LPWSAPROTOCOL_INFO;
#endif /* UNICODE */

/* Flag bit definitions for dwProviderFlags */
#define PFL_MULTIPLE_PROTO_ENTRIES          0x00000001
#define PFL_RECOMMENDED_PROTO_ENTRY         0x00000002
#define PFL_HIDDEN                          0x00000004
#define PFL_MATCHES_PROTOCOL_ZERO           0x00000008
#define PFL_NETWORKDIRECT_PROVIDER          0x00000010

/* Flag bit definitions for dwServiceFlags1 */
#define XP1_CONNECTIONLESS                  0x00000001
#define XP1_GUARANTEED_DELIVERY             0x00000002
#define XP1_GUARANTEED_ORDER                0x00000004
#define XP1_MESSAGE_ORIENTED                0x00000008
#define XP1_PSEUDO_STREAM                   0x00000010
#define XP1_GRACEFUL_CLOSE                  0x00000020
#define XP1_EXPEDITED_DATA                  0x00000040
#define XP1_CONNECT_DATA                    0x00000080
#define XP1_DISCONNECT_DATA                 0x00000100
#define XP1_SUPPORT_BROADCAST               0x00000200
#define XP1_SUPPORT_MULTIPOINT              0x00000400
#define XP1_MULTIPOINT_CONTROL_PLANE        0x00000800
#define XP1_MULTIPOINT_DATA_PLANE           0x00001000
#define XP1_QOS_SUPPORTED                   0x00002000
#define XP1_INTERRUPT                       0x00004000
#define XP1_UNI_SEND                        0x00008000
#define XP1_UNI_RECV                        0x00010000
#define XP1_IFS_HANDLES                     0x00020000
#define XP1_PARTIAL_MESSAGE                 0x00040000
#define XP1_SAN_SUPPORT_SDP                 0x00080000

#define BIGENDIAN                           0x0000
#define LITTLEENDIAN                        0x0001

#define SECURITY_PROTOCOL_NONE              0x0000

/*
 * WinSock 2 extension -- manifest constants for WSAJoinLeaf()
 */
#define JL_SENDER_ONLY    0x01
#define JL_RECEIVER_ONLY  0x02
#define JL_BOTH           0x04

/*
 * WinSock 2 extension -- manifest constants for WSASocket()
 */
#define WSA_FLAG_OVERLAPPED           0x01
#define WSA_FLAG_MULTIPOINT_C_ROOT    0x02
#define WSA_FLAG_MULTIPOINT_C_LEAF    0x04
#define WSA_FLAG_MULTIPOINT_D_ROOT    0x08
#define WSA_FLAG_MULTIPOINT_D_LEAF    0x10
#define WSA_FLAG_ACCESS_SYSTEM_SECURITY 0x40

/*
 * WinSock 2 extensions -- data types for the condition function in
 * WSAAccept() and overlapped I/O completion routine.
 */

typedef
int
(CALLBACK * LPCONDITIONPROC)(
    IN LPWSABUF lpCallerId,
    IN LPWSABUF lpCallerData,
    IN OUT LPQOS lpSQOS,
    IN OUT LPQOS lpGQOS,
    IN LPWSABUF lpCalleeId,
    IN LPWSABUF lpCalleeData,
    OUT GROUP FAR * g,
    IN DWORD_PTR dwCallbackData
    );

typedef
void
(CALLBACK * LPWSAOVERLAPPED_COMPLETION_ROUTINE)(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN DWORD dwFlags
    );

#if(_WIN32_WINNT >= 0x0501)

/*
 * WinSock 2 extension -- manifest constants and associated structures
 * for WSANSPIoctl()
 */
#define SIO_NSP_NOTIFY_CHANGE         _WSAIOW(IOC_WS2,25)

typedef enum _WSACOMPLETIONTYPE {
    NSP_NOTIFY_IMMEDIATELY = 0,
    NSP_NOTIFY_HWND,
    NSP_NOTIFY_EVENT,
    NSP_NOTIFY_PORT,
    NSP_NOTIFY_APC,
} WSACOMPLETIONTYPE, *PWSACOMPLETIONTYPE, FAR * LPWSACOMPLETIONTYPE;

typedef struct _WSACOMPLETION {
    WSACOMPLETIONTYPE Type;
    union {
        struct {
            HWND hWnd;
            UINT uMsg;
            WPARAM context;
        } WindowMessage;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
        } Event;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
            LPWSAOVERLAPPED_COMPLETION_ROUTINE lpfnCompletionProc;
        } Apc;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
            HANDLE hPort;
            ULONG_PTR Key;
        } Port;
    } Parameters;
} WSACOMPLETION, *PWSACOMPLETION, FAR *LPWSACOMPLETION;
#endif //(_WIN32_WINNT >= 0x0501)

/*
 * WinSock 2 extension -- manifest constants for SIO_TRANSLATE_HANDLE ioctl
 */
#define TH_NETDEV        0x00000001
#define TH_TAPI          0x00000002

/*
 * Manifest constants and type definitions related to name resolution and
 * registration (RNR) API
 */

#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED
typedef struct _BLOB {
    ULONG cbSize ;
#ifdef MIDL_PASS
    [size_is(cbSize)] BYTE *pBlobData;
#else  /* MIDL_PASS */
    __field_bcount(cbSize) BYTE *pBlobData ;
#endif /* MIDL_PASS */
} BLOB, *LPBLOB ;
#endif

/*
 * Service Install Flags
 */

#define SERVICE_MULTIPLE       (0x00000001)

/*
 *& Name Spaces
 */

#define NS_ALL                      (0)

#define NS_SAP                      (1)
#define NS_NDS                      (2)
#define NS_PEER_BROWSE              (3)
#define NS_SLP                      (5)
#define NS_DHCP                     (6)

#define NS_TCPIP_LOCAL              (10)
#define NS_TCPIP_HOSTS              (11)
#define NS_DNS                      (12)
#define NS_NETBT                    (13)
#define NS_WINS                     (14)

#if(_WIN32_WINNT >= 0x0501)
#define NS_NLA                      (15)    /* Network Location Awareness */
#endif //(_WIN32_WINNT >= 0x0501)

#if(_WIN32_WINNT >= 0x0600)
#define NS_BTH                      (16)    /* Bluetooth SDP Namespace */
#endif //(_WIN32_WINNT >= 0x0600)

#define NS_NBP                      (20)

#define NS_MS                       (30)
#define NS_STDA                     (31)
#define NS_NTDS                     (32)

#if(_WIN32_WINNT >= 0x0600)
#define NS_EMAIL                    (37)
#define NS_PNRPNAME                 (38)
#define NS_PNRPCLOUD                (39)
#endif //(_WIN32_WINNT >= 0x0600)

#define NS_X500                     (40)
#define NS_NIS                      (41)
#define NS_NISPLUS                  (42)

#define NS_WRQ                      (50)

#define NS_NETDES                   (60)    /* Network Designers Limited */

/*
 *& Name Spaces
 */

#define NS_ALL                      (0)

#define NS_SAP                      (1)
#define NS_NDS                      (2)
#define NS_PEER_BROWSE              (3)
#define NS_SLP                      (5)
#define NS_DHCP                     (6)

#define NS_TCPIP_LOCAL              (10)
#define NS_TCPIP_HOSTS              (11)
#define NS_DNS                      (12)
#define NS_NETBT                    (13)
#define NS_WINS                     (14)

#if(_WIN32_WINNT >= 0x0501)
#define NS_NLA                      (15)    /* Network Location Awareness */
#endif //(_WIN32_WINNT >= 0x0501)

#if(_WIN32_WINNT >= 0x0600)
#define NS_BTH                      (16)    /* Bluetooth SDP Namespace */
#endif //(_WIN32_WINNT >= 0x0600)

#define NS_LOCALNAME                (19)    /* Windows Live */

#define NS_NBP                      (20)

#define NS_MS                       (30)
#define NS_STDA                     (31)
#define NS_NTDS                     (32)

#if(_WIN32_WINNT >= 0x0600)
#define NS_EMAIL                    (37)
#define NS_PNRPNAME                 (38)
#define NS_PNRPCLOUD                (39)
#endif //(_WIN32_WINNT >= 0x0600)

#define NS_X500                     (40)
#define NS_NIS                      (41)
#define NS_NISPLUS                  (42)

#define NS_WRQ                      (50)

#define NS_NETDES                   (60)    /* Network Designers Limited */

/*
 * Resolution flags for WSAGetAddressByName().
 * Note these are also used by the 1.1 API GetAddressByName, so
 * leave them around.
 */
#define RES_UNUSED_1                (0x00000001)
#define RES_FLUSH_CACHE             (0x00000002)
#ifndef RES_SERVICE
#define RES_SERVICE                 (0x00000004)
#endif /* RES_SERVICE */

/*
 * Well known value names for Service Types
 */

#define SERVICE_TYPE_VALUE_IPXPORTA      "IpxSocket"
#define SERVICE_TYPE_VALUE_IPXPORTW     L"IpxSocket"
#define SERVICE_TYPE_VALUE_SAPIDA        "SapId"
#define SERVICE_TYPE_VALUE_SAPIDW       L"SapId"

#define SERVICE_TYPE_VALUE_TCPPORTA      "TcpPort"
#define SERVICE_TYPE_VALUE_TCPPORTW     L"TcpPort"

#define SERVICE_TYPE_VALUE_UDPPORTA      "UdpPort"
#define SERVICE_TYPE_VALUE_UDPPORTW     L"UdpPort"

#define SERVICE_TYPE_VALUE_OBJECTIDA     "ObjectId"
#define SERVICE_TYPE_VALUE_OBJECTIDW    L"ObjectId"

#ifdef UNICODE

#define SERVICE_TYPE_VALUE_SAPID        SERVICE_TYPE_VALUE_SAPIDW
#define SERVICE_TYPE_VALUE_TCPPORT      SERVICE_TYPE_VALUE_TCPPORTW
#define SERVICE_TYPE_VALUE_UDPPORT      SERVICE_TYPE_VALUE_UDPPORTW
#define SERVICE_TYPE_VALUE_OBJECTID     SERVICE_TYPE_VALUE_OBJECTIDW

#else /* not UNICODE */

#define SERVICE_TYPE_VALUE_SAPID        SERVICE_TYPE_VALUE_SAPIDA
#define SERVICE_TYPE_VALUE_TCPPORT      SERVICE_TYPE_VALUE_TCPPORTA
#define SERVICE_TYPE_VALUE_UDPPORT      SERVICE_TYPE_VALUE_UDPPORTA
#define SERVICE_TYPE_VALUE_OBJECTID     SERVICE_TYPE_VALUE_OBJECTIDA

#endif

/*
 *  Address Family/Protocol Tuples
 */
typedef struct _AFPROTOCOLS {
    INT iAddressFamily;
    INT iProtocol;
} AFPROTOCOLS, *PAFPROTOCOLS, *LPAFPROTOCOLS;

/*
 * Client Query API Typedefs
 */

/*
 * The comparators
 */
typedef enum _WSAEcomparator
{
    COMP_EQUAL = 0,
    COMP_NOTLESS
} WSAECOMPARATOR, *PWSAECOMPARATOR, *LPWSAECOMPARATOR;

typedef struct _WSAVersion
{
    DWORD           dwVersion;
    WSAECOMPARATOR  ecHow;
}WSAVERSION, *PWSAVERSION, *LPWSAVERSION;

typedef struct _WSAQuerySetA
{
    DWORD           dwSize;
    LPSTR           lpszServiceInstanceName;
    LPGUID          lpServiceClassId;
    LPWSAVERSION    lpVersion;
    LPSTR           lpszComment;
    DWORD           dwNameSpace;
    LPGUID          lpNSProviderId;
    LPSTR           lpszContext;
    DWORD           dwNumberOfProtocols;
    __field_ecount(dwNumberOfProtocols) LPAFPROTOCOLS   lpafpProtocols;
    LPSTR           lpszQueryString;
    DWORD           dwNumberOfCsAddrs;
    __field_ecount(dwNumberOfCsAddrs) LPCSADDR_INFO   lpcsaBuffer;
    DWORD           dwOutputFlags;
    LPBLOB          lpBlob;
} WSAQUERYSETA, *PWSAQUERYSETA, *LPWSAQUERYSETA;
typedef __struct_bcount(dwSize) struct _WSAQuerySetW
{
    DWORD           dwSize;
    LPWSTR          lpszServiceInstanceName;
    LPGUID          lpServiceClassId;
    LPWSAVERSION    lpVersion;
    LPWSTR          lpszComment;
    DWORD           dwNameSpace;
    LPGUID          lpNSProviderId;
    LPWSTR          lpszContext;
    DWORD           dwNumberOfProtocols;
    __field_ecount(dwNumberOfProtocols) LPAFPROTOCOLS   lpafpProtocols;
    LPWSTR          lpszQueryString;
    DWORD           dwNumberOfCsAddrs;
    __field_ecount(dwNumberOfCsAddrs) LPCSADDR_INFO   lpcsaBuffer;
    DWORD           dwOutputFlags;
    LPBLOB          lpBlob;
} WSAQUERYSETW, *PWSAQUERYSETW, *LPWSAQUERYSETW;

typedef struct _WSAQuerySet2A
{
    DWORD           dwSize;
    LPSTR           lpszServiceInstanceName;
    LPWSAVERSION    lpVersion;
    LPSTR           lpszComment;
    DWORD           dwNameSpace;
    LPGUID          lpNSProviderId;
    LPSTR           lpszContext;
    DWORD           dwNumberOfProtocols;
    LPAFPROTOCOLS   lpafpProtocols;
    LPSTR           lpszQueryString;
    DWORD           dwNumberOfCsAddrs;
    LPCSADDR_INFO   lpcsaBuffer;
    DWORD           dwOutputFlags;
    LPBLOB          lpBlob;   
} WSAQUERYSET2A, *PWSAQUERYSET2A, *LPWSAQUERYSET2A;
typedef struct _WSAQuerySet2W
{
    DWORD           dwSize;
    LPWSTR          lpszServiceInstanceName;
    LPWSAVERSION    lpVersion;
    LPWSTR          lpszComment;
    DWORD           dwNameSpace;
    LPGUID          lpNSProviderId;
    LPWSTR          lpszContext;
    DWORD           dwNumberOfProtocols;
    __field_ecount(dwNumberOfProtocols) LPAFPROTOCOLS   lpafpProtocols;
    LPWSTR          lpszQueryString;
    DWORD           dwNumberOfCsAddrs;
    __field_ecount(dwNumberOfCsAddrs) LPCSADDR_INFO   lpcsaBuffer;
    DWORD           dwOutputFlags;
    LPBLOB          lpBlob;   
} WSAQUERYSET2W, *PWSAQUERYSET2W, *LPWSAQUERYSET2W;

#ifdef UNICODE
typedef WSAQUERYSETW WSAQUERYSET;
typedef PWSAQUERYSETW PWSAQUERYSET;
typedef LPWSAQUERYSETW LPWSAQUERYSET;
typedef WSAQUERYSET2W WSAQUERYSET2;
typedef PWSAQUERYSET2W PWSAQUERYSET2;
typedef LPWSAQUERYSET2W LPWSAQUERYSET2;
#else
typedef WSAQUERYSETA WSAQUERYSET;
typedef PWSAQUERYSETA PWSAQUERYSET;
typedef LPWSAQUERYSETA LPWSAQUERYSET;
typedef WSAQUERYSET2A WSAQUERYSET2;
typedef PWSAQUERYSET2A PWSAQUERYSET2;
typedef LPWSAQUERYSET2A LPWSAQUERYSET2;
#endif /* UNICODE */

#define LUP_DEEP                0x0001
#define LUP_CONTAINERS          0x0002
#define LUP_NOCONTAINERS        0x0004
#define LUP_NEAREST             0x0008
#define LUP_RETURN_NAME         0x0010
#define LUP_RETURN_TYPE         0x0020
#define LUP_RETURN_VERSION      0x0040
#define LUP_RETURN_COMMENT      0x0080
#define LUP_RETURN_ADDR         0x0100
#define LUP_RETURN_BLOB         0x0200
#define LUP_RETURN_ALIASES      0x0400
#define LUP_RETURN_QUERY_STRING 0x0800
#define LUP_RETURN_ALL          0x0FF0
#define LUP_RES_SERVICE         0x8000

#define LUP_FLUSHCACHE          0x1000
#define LUP_FLUSHPREVIOUS       0x2000

#define LUP_NON_AUTHORITATIVE   0x4000
#define LUP_SECURE              0x8000
#define LUP_RETURN_PREFERRED_NAMES  0x10000

#define LUP_ADDRCONFIG          0x00100000
#define LUP_DUAL_ADDR           0x00200000
#define LUP_FILESERVER          0x00400000


/*
 * Return flags
 */

#define  RESULT_IS_ALIAS      0x0001
#if(_WIN32_WINNT >= 0x0501)
#define  RESULT_IS_ADDED      0x0010
#define  RESULT_IS_CHANGED    0x0020
#define  RESULT_IS_DELETED    0x0040
#endif //(_WIN32_WINNT >= 0x0501)

/*
 * Service Address Registration and Deregistration Data Types.
 */

typedef enum _WSAESETSERVICEOP
{
    RNRSERVICE_REGISTER=0,
    RNRSERVICE_DEREGISTER,
    RNRSERVICE_DELETE
} WSAESETSERVICEOP, *PWSAESETSERVICEOP, *LPWSAESETSERVICEOP;

/*
 * Service Installation/Removal Data Types.
 */

typedef struct _WSANSClassInfoA
{
    LPSTR   lpszName;
    DWORD   dwNameSpace;
    DWORD   dwValueType;
    DWORD   dwValueSize;
    LPVOID  lpValue;
}WSANSCLASSINFOA, *PWSANSCLASSINFOA, *LPWSANSCLASSINFOA;
typedef struct _WSANSClassInfoW
{
    LPWSTR  lpszName;
    DWORD   dwNameSpace;
    DWORD   dwValueType;
    DWORD   dwValueSize;
    LPVOID  lpValue;
}WSANSCLASSINFOW, *PWSANSCLASSINFOW, *LPWSANSCLASSINFOW;
#ifdef UNICODE
typedef WSANSCLASSINFOW WSANSCLASSINFO;
typedef PWSANSCLASSINFOW PWSANSCLASSINFO;
typedef LPWSANSCLASSINFOW LPWSANSCLASSINFO;
#else
typedef WSANSCLASSINFOA WSANSCLASSINFO;
typedef PWSANSCLASSINFOA PWSANSCLASSINFO;
typedef LPWSANSCLASSINFOA LPWSANSCLASSINFO;
#endif /* UNICODE */

typedef struct _WSAServiceClassInfoA
{
    LPGUID              lpServiceClassId;
    LPSTR               lpszServiceClassName;
    DWORD               dwCount;
    LPWSANSCLASSINFOA   lpClassInfos;
}WSASERVICECLASSINFOA, *PWSASERVICECLASSINFOA, *LPWSASERVICECLASSINFOA;
typedef struct _WSAServiceClassInfoW
{
    LPGUID              lpServiceClassId;
    LPWSTR              lpszServiceClassName;
    DWORD               dwCount;
    LPWSANSCLASSINFOW   lpClassInfos;
}WSASERVICECLASSINFOW, *PWSASERVICECLASSINFOW, *LPWSASERVICECLASSINFOW;
#ifdef UNICODE
typedef WSASERVICECLASSINFOW WSASERVICECLASSINFO;
typedef PWSASERVICECLASSINFOW PWSASERVICECLASSINFO;
typedef LPWSASERVICECLASSINFOW LPWSASERVICECLASSINFO;
#else
typedef WSASERVICECLASSINFOA WSASERVICECLASSINFO;
typedef PWSASERVICECLASSINFOA PWSASERVICECLASSINFO;
typedef LPWSASERVICECLASSINFOA LPWSASERVICECLASSINFO;
#endif /* UNICODE */

typedef struct _WSANAMESPACE_INFOA {
    GUID                NSProviderId;
    DWORD               dwNameSpace;
    BOOL                fActive;
    DWORD               dwVersion;
    LPSTR               lpszIdentifier;
} WSANAMESPACE_INFOA, *PWSANAMESPACE_INFOA, *LPWSANAMESPACE_INFOA;

typedef struct _WSANAMESPACE_INFOW {
    GUID                NSProviderId;
    DWORD               dwNameSpace;
    BOOL                fActive;
    DWORD               dwVersion;
    LPWSTR              lpszIdentifier;
} WSANAMESPACE_INFOW, *PWSANAMESPACE_INFOW, *LPWSANAMESPACE_INFOW;

typedef struct _WSANAMESPACE_INFOEXA {
    GUID                NSProviderId;
    DWORD               dwNameSpace;
    BOOL                fActive;
    DWORD               dwVersion;
    LPSTR               lpszIdentifier;
    BLOB                ProviderSpecific;
} WSANAMESPACE_INFOEXA, *PWSANAMESPACE_INFOEXA, *LPWSANAMESPACE_INFOEXA;

typedef struct _WSANAMESPACE_INFOEXW {
    GUID                NSProviderId;
    DWORD               dwNameSpace;
    BOOL                fActive;
    DWORD               dwVersion;
    LPWSTR              lpszIdentifier;
    BLOB                ProviderSpecific;
} WSANAMESPACE_INFOEXW, *PWSANAMESPACE_INFOEXW, *LPWSANAMESPACE_INFOEXW;

#ifdef UNICODE
typedef WSANAMESPACE_INFOW WSANAMESPACE_INFO;
typedef PWSANAMESPACE_INFOW PWSANAMESPACE_INFO;
typedef LPWSANAMESPACE_INFOW LPWSANAMESPACE_INFO;
typedef WSANAMESPACE_INFOEXW WSANAMESPACE_INFOEX;
typedef PWSANAMESPACE_INFOEXW PWSANAMESPACE_INFOEX;
typedef LPWSANAMESPACE_INFOEXW LPWSANAMESPACE_INFOEX;
#else
typedef WSANAMESPACE_INFOA WSANAMESPACE_INFO;
typedef PWSANAMESPACE_INFOA PWSANAMESPACE_INFO;
typedef LPWSANAMESPACE_INFOA LPWSANAMESPACE_INFO;
typedef WSANAMESPACE_INFOEXA WSANAMESPACE_INFOEX;
typedef PWSANAMESPACE_INFOEXA PWSANAMESPACE_INFOEX;
typedef LPWSANAMESPACE_INFOEXA LPWSANAMESPACE_INFOEX;
#endif /* UNICODE */


#if(_WIN32_WINNT >= 0x0600)

/* Event flag definitions for WSAPoll(). */

#define POLLRDNORM  0x0100
#define POLLRDBAND  0x0200
#define POLLIN      (POLLRDNORM | POLLRDBAND)
#define POLLPRI     0x0400

#define POLLWRNORM  0x0010
#define POLLOUT     (POLLWRNORM)
#define POLLWRBAND  0x0020

#define POLLERR     0x0001
#define POLLHUP     0x0002
#define POLLNVAL    0x0004

typedef struct pollfd {

    SOCKET  fd;
    SHORT   events;
    SHORT   revents;

} WSAPOLLFD, *PWSAPOLLFD, FAR *LPWSAPOLLFD;

#endif // (_WIN32_WINNT >= 0x0600)


/* Socket function prototypes */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
__checkReturn
SOCKET
WSAAPI
accept(
    __in SOCKET s,
    __out_bcount_opt(*addrlen) struct sockaddr FAR * addr,
    __inout_opt int FAR * addrlen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
__checkReturn
SOCKET
(WSAAPI * LPFN_ACCEPT)(
    __in SOCKET s,
    __out_bcount_opt(*addrlen) struct sockaddr FAR * addr,
    __inout_opt int FAR * addrlen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
bind(
    __in SOCKET s,
    __in_bcount(namelen) const struct sockaddr FAR * name,
    __in int namelen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_BIND)(
    __in SOCKET s,
    __in_bcount(namelen) const struct sockaddr FAR * name,
    __in int namelen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
closesocket(
    __in SOCKET s
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_CLOSESOCKET)(
    __in SOCKET s
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
connect(
    __in SOCKET s,
    __in_bcount(namelen) const struct sockaddr FAR * name,
    __in int namelen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_CONNECT)(
    __in SOCKET s,
    __in_bcount(namelen) const struct sockaddr FAR * name,
    __in int namelen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
ioctlsocket(
    __in SOCKET s,
    __in long cmd,
    __inout u_long FAR * argp
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_IOCTLSOCKET)(
    __in SOCKET s,
    __in long cmd,
    __inout u_long FAR * argp
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
getpeername(
    __in SOCKET s,
    __out_bcount_part(*namelen,*namelen) struct sockaddr FAR * name,
    __inout int FAR * namelen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_GETPEERNAME)(
    __in SOCKET s,
    __out_bcount_part(*namelen,*namelen) struct sockaddr FAR * name,
    __inout int FAR * namelen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
getsockname(
    __in SOCKET s,
    __out_bcount_part(*namelen,*namelen) struct sockaddr FAR * name,
    __inout int FAR * namelen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_GETSOCKNAME)(
    __in SOCKET s,
    __out_bcount_part(*namelen,*namelen) struct sockaddr FAR * name,
    __inout int FAR * namelen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
getsockopt(
    __in SOCKET s,
    __in int level,
    __in int optname,
    __out_bcount(*optlen) char FAR * optval,
    __inout int FAR * optlen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_GETSOCKOPT)(
    __in SOCKET s,
    __in int level,
    __in int optname,
    __out_bcount(*optlen) char FAR * optval,
    __inout int FAR * optlen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
u_long
WSAAPI
htonl(
    __in u_long hostlong
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
u_long
(WSAAPI * LPFN_HTONL)(
    __in u_long hostlong
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
u_short
WSAAPI
htons(
    __in u_short hostshort
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
u_short
(WSAAPI * LPFN_HTONS)(
    __in u_short hostshort
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
unsigned long
WSAAPI
inet_addr(
    __in IN const char FAR * cp
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
unsigned long
(WSAAPI * LPFN_INET_ADDR)(
    __in const char FAR * cp
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
char FAR *
WSAAPI
inet_ntoa(
    __in struct in_addr in
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
char FAR *
(WSAAPI * LPFN_INET_NTOA)(
    __in struct in_addr in
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
listen(
    __in SOCKET s,
    __in int backlog
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_LISTEN)(
    __in SOCKET s,
    __in int backlog
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
u_long
WSAAPI
ntohl(
    __in u_long netlong
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
u_long
(WSAAPI * LPFN_NTOHL)(
    __in u_long netlong
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
u_short
WSAAPI
ntohs(
    __in u_short netshort
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
u_short
(WSAAPI * LPFN_NTOHS)(
    __in u_short netshort
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
recv(
    __in SOCKET s,
    __out_bcount_part(len, return) __out_data_source(NETWORK) char FAR * buf,
    __in int len,
    __in int flags
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_RECV)(
    __in SOCKET s,
    __out_bcount_part(len, return) char FAR * buf,
    __in int len,
    __in int flags
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
int
WSAAPI
recvfrom(
    __in SOCKET s,
    __out_bcount_part(len, return) __out_data_source(NETWORK) char FAR * buf,
    __in int len,
    __in int flags,
    __out_bcount_part_opt(*fromlen, *fromlen) struct sockaddr FAR * from,
    __inout_opt int FAR * fromlen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_RECVFROM)(
    __in SOCKET s,
    __out_bcount_part(len, return) char FAR * buf,
    __in int len,
    __in int flags,
    __out_bcount_part_opt(*fromlen, *fromlen) struct sockaddr FAR * from,
    __inout_opt int FAR * fromlen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
select(
    __in int nfds,
    __inout_opt fd_set FAR * readfds,
    __inout_opt fd_set FAR * writefds,
    __inout_opt fd_set FAR * exceptfds,
    __in_opt const struct timeval FAR * timeout
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_SELECT)(
    __in int nfds,
    __inout_opt fd_set FAR * readfds,
    __inout_opt fd_set FAR * writefds,
    __inout_opt fd_set FAR *exceptfds,
    __in_opt const struct timeval FAR * timeout
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
send(
    __in SOCKET s,
    __in_bcount(len) const char FAR * buf,
    __in int len,
    __in int flags
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_SEND)(
    __in SOCKET s,
    __in_bcount(len) const char FAR * buf,
    __in int len,
    __in int flags
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
sendto(
    __in SOCKET s,
    __in_bcount(len) const char FAR * buf,
    __in int len,
    __in int flags,
    __in_bcount(tolen) const struct sockaddr FAR * to,
    __in int tolen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_SENDTO)(
    __in SOCKET s,
    __in_bcount(len) const char FAR * buf,
    __in int len,
    __in int flags,
    __in_bcount(tolen) const struct sockaddr FAR * to,
    __in int tolen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
setsockopt(
    __in SOCKET s,
    __in int level,
    __in int optname,
    __in_bcount_opt(optlen) const char FAR * optval,
    __in int optlen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_SETSOCKOPT)(
    __in SOCKET s,
    __in int level,
    __in int optname,
    __in_bcount(optlen) const char FAR * optval,
    __in int optlen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
shutdown(
    __in SOCKET s,
    __in int how
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_SHUTDOWN)(
    __in SOCKET s,
    __in int how
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
__checkReturn
SOCKET
WSAAPI
socket(
    __in int af,
    __in int type,
    __in int protocol
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
__checkReturn
SOCKET
(WSAAPI * LPFN_SOCKET)(
    __in int af,
    __in int type,
    __in int protocol
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

/* Database function prototypes */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
struct hostent FAR *
WSAAPI
gethostbyaddr(
    __in_bcount(len) const char FAR * addr,
    __in int len,
    __in int type
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
struct hostent FAR *
(WSAAPI * LPFN_GETHOSTBYADDR)(
    __in_bcount(len) const char FAR * addr,
    __in int len,
    __in int type
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
struct hostent FAR *
WSAAPI
gethostbyname(
    __in const char FAR * name
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
struct hostent FAR *
(WSAAPI * LPFN_GETHOSTBYNAME)(
    __in const char FAR * name
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
gethostname(
    __out_bcount(namelen) char FAR * name,
    __in int namelen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_GETHOSTNAME)(
    __out_bcount(namelen) char FAR * name,
    __in int namelen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
struct servent FAR *
WSAAPI
getservbyport(
    __in int port,
    __in_z const char FAR * proto
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
struct servent FAR *
(WSAAPI * LPFN_GETSERVBYPORT)(
    __in int port,
    __in_z const char FAR * proto
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
struct servent FAR *
WSAAPI
getservbyname(
    __in_z const char FAR * name,
    __in_z const char FAR * proto
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
struct servent FAR *
(WSAAPI * LPFN_GETSERVBYNAME)(
    __in_z const char FAR * name,
    __in_z const char FAR * proto
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
struct protoent FAR *
WSAAPI
getprotobynumber(
    __in int number
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
struct protoent FAR *
(WSAAPI * LPFN_GETPROTOBYNUMBER)(
    __in int number
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
struct protoent FAR *
WSAAPI
getprotobyname(
    __in_z const char FAR * name
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
struct protoent FAR *
(WSAAPI * LPFN_GETPROTOBYNAME)(
    __in_z const char FAR * name
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

/* Microsoft Windows Extension function prototypes */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
__checkReturn
int
WSAAPI
WSAStartup(
    __in WORD wVersionRequested,
    __out LPWSADATA lpWSAData
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
__checkReturn
int
(WSAAPI * LPFN_WSASTARTUP)(
    __in WORD wVersionRequested,
    __out LPWSADATA lpWSAData
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSACleanup(
    void
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSACLEANUP)(
    void
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
void
WSAAPI
WSASetLastError(
    __in int iError
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
void
(WSAAPI * LPFN_WSASETLASTERROR)(
    int iError
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSAGetLastError(
    void
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSAGETLASTERROR)(
    void
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
BOOL
WSAAPI
WSAIsBlocking(
    void
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
BOOL
(WSAAPI * LPFN_WSAISBLOCKING)(
    void
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSAUnhookBlockingHook(
    void
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSAUNHOOKBLOCKINGHOOK)(
    void
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
FARPROC
WSAAPI
WSASetBlockingHook(
    __in FARPROC lpBlockFunc
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
FARPROC
(WSAAPI * LPFN_WSASETBLOCKINGHOOK)(
    __in FARPROC lpBlockFunc
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSACancelBlockingCall(
    void
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSACANCELBLOCKINGCALL)(
    void
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
HANDLE
WSAAPI
WSAAsyncGetServByName(
    __in HWND hWnd,
    __in u_int wMsg,
    __in const char FAR * name,
    __in const char FAR * proto,
    __out_bcount(buflen) char FAR * buf,
    __in int buflen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
HANDLE
(WSAAPI * LPFN_WSAASYNCGETSERVBYNAME)(
    __in HWND hWnd,
    __in u_int wMsg,
    __in const char FAR * name,
    __in const char FAR * proto,
    __out_bcount(buflen) char FAR * buf,
    __in int buflen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
HANDLE
WSAAPI
WSAAsyncGetServByPort(
    __in HWND hWnd,
    __in u_int wMsg,
    __in int port,
    __in const char FAR * proto,
    __out_bcount(buflen) char FAR * buf,
    __in int buflen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
HANDLE
(WSAAPI * LPFN_WSAASYNCGETSERVBYPORT)(
    __in HWND hWnd,
    __in u_int wMsg,
    __in int port,
    __in const char FAR * proto,
    __out_bcount(buflen) char FAR * buf,
    __in int buflen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
HANDLE
WSAAPI
WSAAsyncGetProtoByName(
    __in HWND hWnd,
    __in u_int wMsg,
    __in const char FAR * name,
    __out_bcount(buflen) char FAR * buf,
    __in int buflen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
HANDLE
(WSAAPI * LPFN_WSAASYNCGETPROTOBYNAME)(
    __in HWND hWnd,
    __in u_int wMsg,
    __in const char FAR * name,
    __out_bcount(buflen) char FAR * buf,
    __in int buflen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
HANDLE
WSAAPI
WSAAsyncGetProtoByNumber(
    __in HWND hWnd,
    __in u_int wMsg,
    __in int number,
    __out_bcount(buflen) char FAR * buf,
    __in int buflen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
HANDLE
(WSAAPI * LPFN_WSAASYNCGETPROTOBYNUMBER)(
    __in HWND hWnd,
    __in u_int wMsg,
    __in int number,
    __out_bcount(buflen) char FAR * buf,
    __in int buflen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
HANDLE
WSAAPI
WSAAsyncGetHostByName(
    __in HWND hWnd,
    __in u_int wMsg,
    __in const char FAR * name,
    __out_bcount(buflen) char FAR * buf,
    __in int buflen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
HANDLE
(WSAAPI * LPFN_WSAASYNCGETHOSTBYNAME)(
    __in HWND hWnd,
    __in u_int wMsg,
    __in const char FAR * name,
    __out_bcount(buflen) char FAR * buf,
    __in int buflen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
HANDLE
WSAAPI
WSAAsyncGetHostByAddr(
    __in HWND hWnd,
    __in u_int wMsg,
    __in_bcount(len) const char FAR * addr,
    __in int len,
    __in int type,
    __out_bcount(buflen) char FAR * buf,
    __in int buflen
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
HANDLE
(WSAAPI * LPFN_WSAASYNCGETHOSTBYADDR)(
    __in HWND hWnd,
    __in u_int wMsg,
    __in_bcount(len) const char FAR * addr,
    __in int len,
    __in int type,
    __out_bcount(buflen) char FAR * buf,
    __in int buflen
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
int
WSAAPI
WSACancelAsyncRequest(
    __in HANDLE hAsyncTaskHandle
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSACANCELASYNCREQUEST)(
    __in HANDLE hAsyncTaskHandle
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
int
WSAAPI
WSAAsyncSelect(
    __in SOCKET s,
    __in HWND hWnd,
    __in u_int wMsg,
    __in long lEvent
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSAASYNCSELECT)(
    __in SOCKET s,
    __in HWND hWnd,
    __in u_int wMsg,
    __in long lEvent
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

/* WinSock 2 API new function prototypes */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
__checkReturn
SOCKET
WSAAPI
WSAAccept(
    __in SOCKET s,
    __out_bcount_part_opt(*addrlen,*addrlen) struct sockaddr FAR * addr,
    __inout_opt LPINT addrlen,
    __in_opt LPCONDITIONPROC lpfnCondition,
    __in_opt DWORD_PTR dwCallbackData
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
__checkReturn
SOCKET
(WSAAPI * LPFN_WSAACCEPT)(
    __in SOCKET s,
    __out_bcount_part_opt(*addrlen,*addrlen) struct sockaddr FAR * addr,
    __inout_opt LPINT addrlen,
    __in_opt LPCONDITIONPROC lpfnCondition,
    __in_opt DWORD_PTR dwCallbackData
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
BOOL
WSAAPI
WSACloseEvent(
    __in WSAEVENT hEvent
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
BOOL
(WSAAPI * LPFN_WSACLOSEEVENT)(
    __in WSAEVENT hEvent
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSAConnect(
    __in SOCKET s,
    __in_bcount(namelen) const struct sockaddr FAR * name,
    __in int namelen,
    __in_opt LPWSABUF lpCallerData,
    __out_opt LPWSABUF lpCalleeData,
    __in_opt LPQOS lpSQOS,
    __in_opt LPQOS lpGQOS
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_PROTOTYPES

#ifdef UNICODE
#define WSAConnectByName    WSAConnectByNameW
#else
#define WSAConnectByName    WSAConnectByNameA
#endif

__control_entrypoint(DllExport)
__data_entrypoint(Network)
BOOL
PASCAL
WSAConnectByNameW(
    __in SOCKET s,
    __in_z LPWSTR nodename,
    __in_z LPWSTR servicename,
    __inout LPDWORD LocalAddressLength,
    __out_bcount_part(*LocalAddressLength,*LocalAddressLength) LPSOCKADDR LocalAddress,
    __inout LPDWORD RemoteAddressLength,
    __out_bcount_part(*RemoteAddressLength,*RemoteAddressLength) LPSOCKADDR RemoteAddress,
    __in const struct timeval * timeout,
    __in_opt LPWSAOVERLAPPED Reserved);

__control_entrypoint(DllExport)
__data_entrypoint(Network)
BOOL
PASCAL
WSAConnectByNameA(
    __in SOCKET s,
    __in_z LPCSTR nodename,
    __in_z LPCSTR servicename,
    __inout LPDWORD LocalAddressLength,
    __out_bcount_part(*LocalAddressLength,*LocalAddressLength) LPSOCKADDR LocalAddress,
    __inout LPDWORD RemoteAddressLength,
    __out_bcount_part(*RemoteAddressLength,*RemoteAddressLength) LPSOCKADDR RemoteAddress,
    __in const struct timeval * timeout,
    __in_opt LPWSAOVERLAPPED Reserved);

__control_entrypoint(DllExport)
__data_entrypoint(Network)
BOOL
PASCAL
WSAConnectByList(
    __in SOCKET s,
    __in PSOCKET_ADDRESS_LIST SocketAddress,
    __inout LPDWORD LocalAddressLength,
    __out_bcount_part(*LocalAddressLength,*LocalAddressLength) LPSOCKADDR LocalAddress,
    __inout LPDWORD RemoteAddressLength,
    __out_bcount_part(*RemoteAddressLength,*RemoteAddressLength) LPSOCKADDR RemoteAddress,
    __in const struct timeval * timeout,
    __in_opt LPWSAOVERLAPPED Reserved);
#endif

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSACONNECT)(
    __in SOCKET s,
    __in_bcount(namelen) const struct sockaddr FAR * name,
    __in int namelen,
    __in_opt LPWSABUF lpCallerData,
    __out_opt LPWSABUF lpCalleeData,
    __in_opt LPQOS lpSQOS,
    __in_opt LPQOS lpGQOS
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
WSAEVENT
WSAAPI
WSACreateEvent(
    void
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
WSAEVENT
(WSAAPI * LPFN_WSACREATEEVENT)(
    void
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
int
WSAAPI
WSADuplicateSocketA(
    __in SOCKET s,
    __in DWORD dwProcessId,
    __out LPWSAPROTOCOL_INFOA lpProtocolInfo
    );
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
int
WSAAPI
WSADuplicateSocketW(
    __in SOCKET s,
    __in DWORD dwProcessId,
    __out LPWSAPROTOCOL_INFOW lpProtocolInfo
    );
#ifdef UNICODE
#define WSADuplicateSocket  WSADuplicateSocketW
#else
#define WSADuplicateSocket  WSADuplicateSocketA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSADUPLICATESOCKETA)(
    __in SOCKET s,
    __in DWORD dwProcessId,
    __out LPWSAPROTOCOL_INFOA lpProtocolInfo
    );
typedef
int
(WSAAPI * LPFN_WSADUPLICATESOCKETW)(
    __in SOCKET s,
    __in DWORD dwProcessId,
    __out LPWSAPROTOCOL_INFOW lpProtocolInfo
    );
#ifdef UNICODE
#define LPFN_WSADUPLICATESOCKET  LPFN_WSADUPLICATESOCKETW
#else
#define LPFN_WSADUPLICATESOCKET  LPFN_WSADUPLICATESOCKETA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
int
WSAAPI
WSAEnumNetworkEvents(
    __in SOCKET s,
    __in WSAEVENT hEventObject,
    __out LPWSANETWORKEVENTS lpNetworkEvents
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSAENUMNETWORKEVENTS)(
    __in SOCKET s,
    __in WSAEVENT hEventObject,
    __out LPWSANETWORKEVENTS lpNetworkEvents
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSAEnumProtocolsA(
    __in_opt LPINT lpiProtocols,
    __out_bcount_part_opt(*lpdwBufferLength,*lpdwBufferLength) LPWSAPROTOCOL_INFOA lpProtocolBuffer,
    __inout LPDWORD lpdwBufferLength
    );
WINSOCK_API_LINKAGE
int
WSAAPI
WSAEnumProtocolsW(
    __in_opt LPINT lpiProtocols,
    __out_bcount_part_opt(*lpdwBufferLength,*lpdwBufferLength) LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    __inout LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define WSAEnumProtocols  WSAEnumProtocolsW
#else
#define WSAEnumProtocols  WSAEnumProtocolsA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSAENUMPROTOCOLSA)(
    __in_opt LPINT lpiProtocols,
    __out_bcount_part_opt(*lpdwBufferLength,*lpdwBufferLength) LPWSAPROTOCOL_INFOA lpProtocolBuffer,
    __inout LPDWORD lpdwBufferLength
    );
typedef
int
(WSAAPI * LPFN_WSAENUMPROTOCOLSW)(
    __in_opt LPINT lpiProtocols,
    __out_bcount_part_opt(*lpdwBufferLength,*lpdwBufferLength) LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    __inout LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define LPFN_WSAENUMPROTOCOLS  LPFN_WSAENUMPROTOCOLSW
#else
#define LPFN_WSAENUMPROTOCOLS  LPFN_WSAENUMPROTOCOLSA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSAEventSelect(
    __in SOCKET s,
    __in WSAEVENT hEventObject,
    __in long lNetworkEvents
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSAEVENTSELECT)(
    __in SOCKET s,
    __in WSAEVENT hEventObject,
    __in long lNetworkEvents
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
BOOL
WSAAPI
WSAGetOverlappedResult(
    __in SOCKET s,
    __in LPWSAOVERLAPPED lpOverlapped,
    __out LPDWORD lpcbTransfer,
    __in BOOL fWait,
    __out LPDWORD lpdwFlags
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
BOOL
(WSAAPI * LPFN_WSAGETOVERLAPPEDRESULT)(
    __in SOCKET s,
    __in LPWSAOVERLAPPED lpOverlapped,
    __out LPDWORD lpcbTransfer,
    __in BOOL fWait,
    __out LPDWORD lpdwFlags
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
BOOL
WSAAPI
WSAGetQOSByName(
    __in SOCKET s,
    __in LPWSABUF lpQOSName,
    __out LPQOS lpQOS
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
BOOL
(WSAAPI * LPFN_WSAGETQOSBYNAME)(
    __in SOCKET s,
    __in LPWSABUF lpQOSName,
    __out LPQOS lpQOS
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
int
WSAAPI
WSAHtonl(
    __in IN SOCKET s,
    __in IN u_long hostlong,
    __out OUT u_long FAR * lpnetlong
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSAHTONL)(
    __in SOCKET s,
    __in u_long hostlong,
    __out u_long FAR * lpnetlong
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
int
WSAAPI
WSAHtons(
    __in IN SOCKET s,
    __in IN u_short hostshort,
    __out OUT u_short FAR * lpnetshort
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSAHTONS)(
    __in SOCKET s,
    __in u_short hostshort,
    __out u_short FAR * lpnetshort
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
int
WSAAPI
WSAIoctl(
    __in SOCKET s,
    __in DWORD dwIoControlCode,
    __in_bcount_opt(cbInBuffer) LPVOID lpvInBuffer,
    __in DWORD cbInBuffer,
    __out_bcount_part_opt(cbOutBuffer, *lpcbBytesReturned) LPVOID lpvOutBuffer,
    __in DWORD cbOutBuffer,
    __out LPDWORD lpcbBytesReturned,
    __inout_opt LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSAIOCTL)(
    __in SOCKET s,
    __in DWORD dwIoControlCode,
    __in_bcount_opt(cbInBuffer) LPVOID lpvInBuffer,
    __in DWORD cbInBuffer,
    __out_bcount_part_opt(cbOutBuffer, *lpcbBytesReturned) LPVOID lpvOutBuffer,
    __in DWORD cbOutBuffer,
    __out LPDWORD lpcbBytesReturned,
    __inout_opt LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
SOCKET
WSAAPI
WSAJoinLeaf(
    __in SOCKET s,
    __in_bcount(namelen) const struct sockaddr FAR * name,
    __in int namelen,
    __in_opt LPWSABUF lpCallerData,
    __out_opt LPWSABUF lpCalleeData,
    __in_opt LPQOS lpSQOS,
    __in_opt LPQOS lpGQOS,
    __in DWORD dwFlags
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
SOCKET
(WSAAPI * LPFN_WSAJOINLEAF)(
    __in SOCKET s,
    __in_bcount(namelen) const struct sockaddr FAR * name,
    __in int namelen,
    __in_opt LPWSABUF lpCallerData,
    __out_opt LPWSABUF lpCalleeData,
    __in_opt LPQOS lpSQOS,
    __in_opt LPQOS lpGQOS,
    __in DWORD dwFlags
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
int
WSAAPI
WSANtohl(
    __in SOCKET s,
    __in u_long netlong,
    __out u_long FAR * lphostlong
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSANTOHL)(
    __in SOCKET s,
    __in u_long netlong,
    __out u_long FAR * lphostlong
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
int
WSAAPI
WSANtohs(
    __in SOCKET s,
    __in u_short netshort,
    __out u_short FAR * lphostshort
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSANTOHS)(
    __in SOCKET s,
    __in u_short netshort,
    __out u_short FAR * lphostshort
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSARecv(
    __in SOCKET s,
    __in_ecount(dwBufferCount) __out_data_source(NETWORK) LPWSABUF lpBuffers,
    __in DWORD dwBufferCount,
    __out_opt LPDWORD lpNumberOfBytesRecvd,
    __inout LPDWORD lpFlags,
    __inout_opt LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSARECV)(
    __in SOCKET s,
    __in_ecount(dwBufferCount) LPWSABUF lpBuffers,
    __in DWORD dwBufferCount,
    __out_opt LPDWORD lpNumberOfBytesRecvd,
    __inout LPDWORD lpFlags,
    __inout_opt LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSARecvDisconnect(
    __in SOCKET s,
    __in_opt __out_data_source(NETWORK) LPWSABUF lpInboundDisconnectData
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSARECVDISCONNECT)(
    __in SOCKET s,
    __out_data_source(NETWORK) LPWSABUF lpInboundDisconnectData
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSARecvFrom(
    __in SOCKET s,
    __in_ecount(dwBufferCount) __out_data_source(NETWORK) LPWSABUF lpBuffers,
    __in DWORD dwBufferCount,
    __out_opt LPDWORD lpNumberOfBytesRecvd,
    __inout LPDWORD lpFlags,
    __out_bcount_part_opt(*lpFromlen,*lpFromlen) struct sockaddr FAR * lpFrom,
    __inout_opt LPINT lpFromlen,
    __inout_opt LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSARECVFROM)(
    __in SOCKET s,
    __in_ecount(dwBufferCount) LPWSABUF lpBuffers,
    __in DWORD dwBufferCount,
    __out_opt LPDWORD lpNumberOfBytesRecvd,
    __inout LPDWORD lpFlags,
    __out_bcount_part_opt(*lpFromlen,*lpFromLen) struct sockaddr FAR * lpFrom,
    __inout_opt LPINT lpFromlen,
    __inout_opt LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
BOOL
WSAAPI
WSAResetEvent(
    __in WSAEVENT hEvent
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
BOOL
(WSAAPI * LPFN_WSARESETEVENT)(
    __in WSAEVENT hEvent
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSASend(
    __in SOCKET s,
    __in_ecount(dwBufferCount) LPWSABUF lpBuffers,
    __in DWORD dwBufferCount,
    __out_opt LPDWORD lpNumberOfBytesSent,
    __in DWORD dwFlags,
    __inout_opt LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSASEND)(
    __in SOCKET s,
    __in_ecount(dwBufferCount) LPWSABUF lpBuffers,
    __in DWORD dwBufferCount,
    __out_opt LPDWORD lpNumberOfBytesSent,
    __in  DWORD dwFlags,
    __inout_opt LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if(_WIN32_WINNT >= 0x0600)
#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int 
WSAAPI 
WSASendMsg(
    __in SOCKET Handle,
    __in LPWSAMSG lpMsg,
    __in DWORD dwFlags,
    __out_opt LPDWORD lpNumberOfBytesSent,
    __inout_opt LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */
#endif // (_WIN32_WINNT >= 0x0600)

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
int
WSAAPI
WSASendDisconnect(
    __in SOCKET s,
    __in_opt LPWSABUF lpOutboundDisconnectData
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSASENDDISCONNECT)(
    __in SOCKET s,
    __in_opt LPWSABUF lpOutboundDisconnectData
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSASendTo(
    __in SOCKET s,
    __in_ecount(dwBufferCount) LPWSABUF lpBuffers,
    __in DWORD dwBufferCount,
    __out_opt LPDWORD lpNumberOfBytesSent,
    __in DWORD dwFlags,
    __in_bcount_opt(iTolen) const struct sockaddr FAR * lpTo,
    __in int iTolen,
    __inout_opt LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSASENDTO)(
    __in SOCKET s,
    __in_ecount(dwBufferCount) LPWSABUF lpBuffers,
    __in DWORD dwBufferCount,
    __out_opt LPDWORD lpNumberOfBytesSent,
    __in DWORD dwFlags,
    __in_bcount_opt(iTolen) const struct sockaddr FAR * lpTo,
    __in int iTolen,
    __inout_opt LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
BOOL
WSAAPI
WSASetEvent(
    __in WSAEVENT hEvent
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
BOOL
(WSAAPI * LPFN_WSASETEVENT)(
    __in WSAEVENT hEvent
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
__checkReturn
SOCKET
WSAAPI
WSASocketA(
    __in int af,
    __in int type,
    __in int protocol,
    __in_opt LPWSAPROTOCOL_INFOA lpProtocolInfo,
    __in GROUP g,
    __in DWORD dwFlags
    );

__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
__checkReturn
SOCKET
WSAAPI
WSASocketW(
    __in int af,
    __in int type,
    __in int protocol,
    __in_opt LPWSAPROTOCOL_INFOW lpProtocolInfo,
    __in GROUP g,
    __in DWORD dwFlags
    );
#ifdef UNICODE
#define WSASocket  WSASocketW
#else
#define WSASocket  WSASocketA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
__checkReturn
SOCKET
(WSAAPI * LPFN_WSASOCKETA)(
    __in int af,
    __in int type,
    __in int protocol,
    __in_opt LPWSAPROTOCOL_INFOA lpProtocolInfo,
    __in GROUP g,
    __in DWORD dwFlags
    );

typedef
__checkReturn
SOCKET
(WSAAPI * LPFN_WSASOCKETW)(
    __in int af,
    __in int type,
    __in int protocol,
    __in_opt LPWSAPROTOCOL_INFOW lpProtocolInfo,
    __in GROUP g,
    __in DWORD dwFlags
    );
#ifdef UNICODE
#define LPFN_WSASOCKET  LPFN_WSASOCKETW
#else
#define LPFN_WSASOCKET  LPFN_WSASOCKETA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
DWORD
WSAAPI
WSAWaitForMultipleEvents(
    __in DWORD cEvents,
    __in_ecount(cEvents) const WSAEVENT FAR * lphEvents,
    __in BOOL fWaitAll,
    __in DWORD dwTimeout,
    __in BOOL fAlertable
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
DWORD
(WSAAPI * LPFN_WSAWAITFORMULTIPLEEVENTS)(
    __in DWORD cEvents,
    __in_ecount(cEvents) const WSAEVENT FAR * lphEvents,
    __in BOOL fWaitAll,
    __in DWORD dwTimeout,
    __in BOOL fAlertable
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
INT
WSAAPI
WSAAddressToStringA(
    __in_bcount(dwAddressLength) LPSOCKADDR lpsaAddress,
    __in     DWORD               dwAddressLength,
    __in_opt LPWSAPROTOCOL_INFOA lpProtocolInfo,
    __out_ecount_part(*lpdwAddressStringLength,*lpdwAddressStringLength) LPSTR lpszAddressString,
    __inout  LPDWORD             lpdwAddressStringLength
    );
WINSOCK_API_LINKAGE
INT
WSAAPI
WSAAddressToStringW(
    __in_bcount(dwAddressLength) LPSOCKADDR lpsaAddress,
    __in     DWORD               dwAddressLength,
    __in_opt LPWSAPROTOCOL_INFOW lpProtocolInfo,
    __out_ecount_part(*lpdwAddressStringLength,*lpdwAddressStringLength) LPWSTR lpszAddressString,
    __inout  LPDWORD             lpdwAddressStringLength
    );
#ifdef UNICODE
#define WSAAddressToString  WSAAddressToStringW
#else
#define WSAAddressToString  WSAAddressToStringA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_WSAADDRESSTOSTRINGA)(
    __in_bcount(dwAddressLength) LPSOCKADDR lpsaAddress,
    __in     DWORD               dwAddressLength,
    __in_opt LPWSAPROTOCOL_INFOA lpProtocolInfo,
    __out_ecount_part(*lpdwAddressStringLength,*lpdwAddressStringLength) LPSTR lpszAddressString,
    __inout  LPDWORD             lpdwAddressStringLength
    );
typedef
INT
(WSAAPI * LPFN_WSAADDRESSTOSTRINGW)(
    __in_bcount(dwAddressLength) LPSOCKADDR lpsaAddress,
    __in     DWORD               dwAddressLength,
    __in_opt LPWSAPROTOCOL_INFOW lpProtocolInfo,
    __out_ecount_part(*lpdwAddressStringLength,*lpdwAddressStringLength) LPWSTR lpszAddressString,
    __inout  LPDWORD             lpdwAddressStringLength
    );
#ifdef UNICODE
#define LPFN_WSAADDRESSTOSTRING  LPFN_WSAADDRESSTOSTRINGW
#else
#define LPFN_WSAADDRESSTOSTRING  LPFN_WSAADDRESSTOSTRINGA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
INT
WSAAPI
WSAStringToAddressA(
    __in    LPSTR               AddressString,
    __in    INT                 AddressFamily,
    __in_opt LPWSAPROTOCOL_INFOA lpProtocolInfo,
    __out_bcount_part(*lpAddressLength,*lpAddressLength) LPSOCKADDR lpAddress,
    __inout LPINT               lpAddressLength
    );
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
INT
WSAAPI
WSAStringToAddressW(
    __in    LPWSTR             AddressString,
    __in    INT                AddressFamily,
    __in_opt LPWSAPROTOCOL_INFOW lpProtocolInfo,
    __out_bcount_part(*lpAddressLength,*lpAddressLength) LPSOCKADDR lpAddress,
    __inout LPINT              lpAddressLength
    );
#ifdef UNICODE
#define WSAStringToAddress  WSAStringToAddressW
#else
#define WSAStringToAddress  WSAStringToAddressA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_WSASTRINGTOADDRESSA)(
    __in    LPSTR              AddressString,
    __in    INT                AddressFamily,
    __in_opt LPWSAPROTOCOL_INFOA lpProtocolInfo,
    __out_bcount_part(*lpAddressLength,*lpAddressLength) LPSOCKADDR lpAddress,
    __inout LPINT              lpAddressLength
    );
typedef
INT
(WSAAPI * LPFN_WSASTRINGTOADDRESSW)(
    __in    LPWSTR             AddressString,
    __in    INT                AddressFamily,
    __in_opt LPWSAPROTOCOL_INFOW lpProtocolInfo,
    __out_bcount_part(*lpAddressLength,*lpAddressLength) LPSOCKADDR lpAddress,
    __inout LPINT              lpAddressLength
    );
#ifdef UNICODE
#define LPFN_WSASTRINGTOADDRESS  LPFN_WSASTRINGTOADDRESSW
#else
#define LPFN_WSASTRINGTOADDRESS  LPFN_WSASTRINGTOADDRESSA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_TYPEDEFS */

/* Registration and Name Resolution API functions */


#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
INT
WSAAPI
WSALookupServiceBeginA(
    __in LPWSAQUERYSETA lpqsRestrictions,
    __in DWORD          dwControlFlags,
    __out LPHANDLE       lphLookup
    );
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
INT
WSAAPI
WSALookupServiceBeginW(
    __in LPWSAQUERYSETW lpqsRestrictions,
    __in DWORD          dwControlFlags,
    __out LPHANDLE       lphLookup
    );
#ifdef UNICODE
#define WSALookupServiceBegin  WSALookupServiceBeginW
#else
#define WSALookupServiceBegin  WSALookupServiceBeginA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_WSALOOKUPSERVICEBEGINA)(
    __in  LPWSAQUERYSETA lpqsRestrictions,
    __in  DWORD          dwControlFlags,
    __out LPHANDLE       lphLookup
    );
typedef
INT
(WSAAPI * LPFN_WSALOOKUPSERVICEBEGINW)(
    __in  LPWSAQUERYSETW lpqsRestrictions,
    __in  DWORD          dwControlFlags,
    __out LPHANDLE       lphLookup
    );
#ifdef UNICODE
#define LPFN_WSALOOKUPSERVICEBEGIN  LPFN_WSALOOKUPSERVICEBEGINW
#else
#define LPFN_WSALOOKUPSERVICEBEGIN  LPFN_WSALOOKUPSERVICEBEGINA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
INT
WSAAPI
WSALookupServiceNextA(
    __in HANDLE           hLookup,
    __in DWORD            dwControlFlags,
    __inout LPDWORD       lpdwBufferLength,
    __out_bcount_part(*lpdwBufferLength,*lpdwBufferLength) LPWSAQUERYSETA lpqsResults
    );
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
INT
WSAAPI
WSALookupServiceNextW(
    __in HANDLE           hLookup,
    __in DWORD            dwControlFlags,
    __inout LPDWORD       lpdwBufferLength,
    __out_bcount_part_opt(*lpdwBufferLength,*lpdwBufferLength) LPWSAQUERYSETW lpqsResults
    );
#ifdef UNICODE
#define WSALookupServiceNext  WSALookupServiceNextW
#else
#define WSALookupServiceNext  WSALookupServiceNextA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_WSALOOKUPSERVICENEXTA)(
    __in   HANDLE           hLookup,
    __in   DWORD            dwControlFlags,
    __inout LPDWORD         lpdwBufferLength,
    __out_bcount_part(*lpdwBufferLength,*lpdwBufferLength) LPWSAQUERYSETA   lpqsResults
    );
typedef
INT
(WSAAPI * LPFN_WSALOOKUPSERVICENEXTW)(
    __in   HANDLE           hLookup,
    __in   DWORD            dwControlFlags,
    __inout LPDWORD         lpdwBufferLength,
    __out_bcount_part_opt(*lpdwBufferLength,*lpdwBufferLength) LPWSAQUERYSETW   lpqsResults
    );
#ifdef UNICODE
#define LPFN_WSALOOKUPSERVICENEXT  LPFN_WSALOOKUPSERVICENEXTW
#else
#define LPFN_WSALOOKUPSERVICENEXT  LPFN_WSALOOKUPSERVICENEXTA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if(_WIN32_WINNT >= 0x0501)
#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
INT
WSAAPI
WSANSPIoctl(
    __in HANDLE           hLookup,
    __in DWORD            dwControlCode,
    __in_bcount_opt(cbInBuffer) LPVOID lpvInBuffer,
    __in DWORD            cbInBuffer,
    __out_bcount_part_opt(cbOutBuffer, *lpcbBytesReturned) LPVOID lpvOutBuffer,
    __in DWORD            cbOutBuffer,
    __out LPDWORD        lpcbBytesReturned,
    __in_opt LPWSACOMPLETION lpCompletion
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_WSANSPIOCTL)(
    IN  HANDLE           hLookup,
    IN  DWORD            dwControlCode,
    __in_bcount_opt(cbInBuffer) LPVOID lpvInBuffer,
    IN  DWORD            cbInBuffer,
    __out_bcount_part_opt(cbOutBuffer, *lpcbBytesReturned) LPVOID lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    __out LPDWORD        lpcbBytesReturned,
    __in_opt LPWSACOMPLETION lpCompletion
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */
#endif //(_WIN32_WINNT >= 0x0501)

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport) WINSOCK_API_LINKAGE
INT
WSAAPI
WSALookupServiceEnd(
    __in HANDLE  hLookup
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_WSALOOKUPSERVICEEND)(
    __in HANDLE  hLookup
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
INT
WSAAPI
WSAInstallServiceClassA(
    __in  LPWSASERVICECLASSINFOA   lpServiceClassInfo
    );
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
INT
WSAAPI
WSAInstallServiceClassW(
    __in  LPWSASERVICECLASSINFOW   lpServiceClassInfo
    );
#ifdef UNICODE
#define WSAInstallServiceClass  WSAInstallServiceClassW
#else
#define WSAInstallServiceClass  WSAInstallServiceClassA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_WSAINSTALLSERVICECLASSA)(
    __in  LPWSASERVICECLASSINFOA   lpServiceClassInfo
    );
typedef
INT
(WSAAPI * LPFN_WSAINSTALLSERVICECLASSW)(
    __in  LPWSASERVICECLASSINFOW   lpServiceClassInfo
    );
#ifdef UNICODE
#define LPFN_WSAINSTALLSERVICECLASS  LPFN_WSAINSTALLSERVICECLASSW
#else
#define LPFN_WSAINSTALLSERVICECLASS  LPFN_WSAINSTALLSERVICECLASSA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
INT
WSAAPI
WSARemoveServiceClass(
    __in  LPGUID  lpServiceClassId
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_WSAREMOVESERVICECLASS)(
    __in  LPGUID  lpServiceClassId
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
INT
WSAAPI
WSAGetServiceClassInfoA(
    __in  LPGUID  lpProviderId,
    __in  LPGUID  lpServiceClassId,
    __inout LPDWORD  lpdwBufSize,
    __out_bcount_part(*lpdwBufSize,*lpdwBufSize) LPWSASERVICECLASSINFOA lpServiceClassInfo
    );
WINSOCK_API_LINKAGE
INT
WSAAPI
WSAGetServiceClassInfoW(
    __in  LPGUID  lpProviderId,
    __in  LPGUID  lpServiceClassId,
    __inout LPDWORD  lpdwBufSize,
    __out_bcount_part(*lpdwBufSize,*lpdwBufSize) LPWSASERVICECLASSINFOW lpServiceClassInfo
    );
#ifdef UNICODE
#define WSAGetServiceClassInfo  WSAGetServiceClassInfoW
#else
#define WSAGetServiceClassInfo  WSAGetServiceClassInfoA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_WSAGETSERVICECLASSINFOA)(
    __in  LPGUID  lpProviderId,
    __in  LPGUID  lpServiceClassId,
    __inout LPDWORD  lpdwBufSize,
    __out_bcount_part(*lpdwBufSize,*lpdwBufSize) LPWSASERVICECLASSINFOA lpServiceClassInfo
    );
typedef
INT
(WSAAPI * LPFN_WSAGETSERVICECLASSINFOW)(
    __in  LPGUID  lpProviderId,
    __in  LPGUID  lpServiceClassId,
    __inout LPDWORD  lpdwBufSize,
    __out_bcount_part(*lpdwBufSize,*lpdwBufSize) LPWSASERVICECLASSINFOW lpServiceClassInfo
    );
#ifdef UNICODE
#define LPFN_WSAGETSERVICECLASSINFO  LPFN_WSAGETSERVICECLASSINFOW
#else
#define LPFN_WSAGETSERVICECLASSINFO  LPFN_WSAGETSERVICECLASSINFOA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
INT
WSAAPI
WSAEnumNameSpaceProvidersA(
    __inout LPDWORD             lpdwBufferLength,
    __out_bcount_part(*lpdwBufferLength,*lpdwBufferLength) LPWSANAMESPACE_INFOA lpnspBuffer
    );
WINSOCK_API_LINKAGE
INT
WSAAPI
WSAEnumNameSpaceProvidersW(
    __inout LPDWORD             lpdwBufferLength,
    __out_bcount_part(*lpdwBufferLength,*lpdwBufferLength) LPWSANAMESPACE_INFOW lpnspBuffer
    );

#ifdef UNICODE
#define WSAEnumNameSpaceProviders   WSAEnumNameSpaceProvidersW
#else
#define WSAEnumNameSpaceProviders   WSAEnumNameSpaceProvidersA
#endif /* !UNICODE */

#if(_WIN32_WINNT >= 0x0600 )
WINSOCK_API_LINKAGE
INT
WSAAPI
WSAEnumNameSpaceProvidersExA(
    __inout LPDWORD             lpdwBufferLength,
    __out_bcount_part(*lpdwBufferLength,*lpdwBufferLength) LPWSANAMESPACE_INFOEXA lpnspBuffer
    );
WINSOCK_API_LINKAGE
INT
WSAAPI
WSAEnumNameSpaceProvidersExW(
    __inout LPDWORD             lpdwBufferLength,
    __out_bcount_part(*lpdwBufferLength,*lpdwBufferLength) LPWSANAMESPACE_INFOEXW lpnspBuffer
    );

#ifdef UNICODE
#define WSAEnumNameSpaceProvidersEx WSAEnumNameSpaceProvidersExW
#else
#define WSAEnumNameSpaceProvidersEx WSAEnumNameSpaceProvidersExA
#endif /* !UNICODE */

#endif //(_WIN32_WINNT >= 0x0600 )


#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_WSAENUMNAMESPACEPROVIDERSA)(
    __inout LPDWORD              lpdwBufferLength,
    __out_bcount_part(*lpdwBufferLength,*lpdwBufferLength) LPWSANAMESPACE_INFOA lpnspBuffer
    );
typedef
INT
(WSAAPI * LPFN_WSAENUMNAMESPACEPROVIDERSW)(
    __inout LPDWORD              lpdwBufferLength,
    __out_bcount_part(*lpdwBufferLength,*lpdwBufferLength) LPWSANAMESPACE_INFOW lpnspBuffer
    );
#ifdef UNICODE
#define LPFN_WSAENUMNAMESPACEPROVIDERS  LPFN_WSAENUMNAMESPACEPROVIDERSW
#else
#define LPFN_WSAENUMNAMESPACEPROVIDERS  LPFN_WSAENUMNAMESPACEPROVIDERSA
#endif /* !UNICODE */

#if (_WIN32_WINNT >= 0x0600)
typedef
INT
(WSAAPI * LPFN_WSAENUMNAMESPACEPROVIDERSEXA)(
    __inout LPDWORD              lpdwBufferLength,
    __out_bcount_part(*lpdwBufferLength,*lpdwBufferLength) LPWSANAMESPACE_INFOEXA lpnspBuffer
    );
typedef
INT
(WSAAPI * LPFN_WSAENUMNAMESPACEPROVIDERSEXW)(
    __inout LPDWORD              lpdwBufferLength,
    __out_bcount_part(*lpdwBufferLength,*lpdwBufferLength) LPWSANAMESPACE_INFOEXW lpnspBuffer
    );
#ifdef UNICODE
#define LPFN_WSAENUMNAMESPACEPROVIDERSEX  LPFN_WSAENUMNAMESPACEPROVIDERSEXW
#else
#define LPFN_WSAENUMNAMESPACEPROVIDERSEX  LPFN_WSAENUMNAMESPACEPROVIDERSEXA
#endif /* !UNICODE */

#endif //(_WIN32_WINNT >= 0x600)

#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
__success(return == 0) INT
WSAAPI
WSAGetServiceClassNameByClassIdA(
    __in       LPGUID  lpServiceClassId,
    __out_bcount_part(*lpdwBufferLength,*lpdwBufferLength) LPSTR lpszServiceClassName,
    __inout LPDWORD lpdwBufferLength
    );
WINSOCK_API_LINKAGE
__success(return == 0) INT
WSAAPI
WSAGetServiceClassNameByClassIdW(
    __in       LPGUID  lpServiceClassId,
    __out_bcount_part(*lpdwBufferLength,*lpdwBufferLength) LPWSTR lpszServiceClassName,
    __inout LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define WSAGetServiceClassNameByClassId  WSAGetServiceClassNameByClassIdW
#else
#define WSAGetServiceClassNameByClassId  WSAGetServiceClassNameByClassIdA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA)(
    __in      LPGUID  lpServiceClassId,
    __out_bcount_part(*lpdwBufferLength,*lpdwBufferLength) LPSTR lpszServiceClassName,
    __inout LPDWORD lpdwBufferLength
    );
typedef
INT
(WSAAPI * LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW)(
    __in      LPGUID  lpServiceClassId,
    __out_bcount_part(*lpdwBufferLength,*lpdwBufferLength) LPWSTR lpszServiceClassName,
    __inout LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define LPFN_WSAGETSERVICECLASSNAMEBYCLASSID  LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW
#else
#define LPFN_WSAGETSERVICECLASSNAMEBYCLASSID  LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
INT
WSAAPI
WSASetServiceA(
    __in LPWSAQUERYSETA lpqsRegInfo,
    __in WSAESETSERVICEOP essoperation,
    __in DWORD dwControlFlags
    );
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
INT
WSAAPI
WSASetServiceW(
    __in LPWSAQUERYSETW lpqsRegInfo,
    __in WSAESETSERVICEOP essoperation,
    __in DWORD dwControlFlags
    );
#ifdef UNICODE
#define WSASetService  WSASetServiceW
#else
#define WSASetService  WSASetServiceA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_WSASETSERVICEA)(
    __in LPWSAQUERYSETA lpqsRegInfo,
    __in WSAESETSERVICEOP essoperation,
    __in DWORD dwControlFlags
    );
typedef
INT
(WSAAPI * LPFN_WSASETSERVICEW)(
    __in LPWSAQUERYSETW lpqsRegInfo,
    __in WSAESETSERVICEOP essoperation,
    __in DWORD dwControlFlags
    );
#ifdef UNICODE
#define LPFN_WSASETSERVICE  LPFN_WSASETSERVICEW
#else
#define LPFN_WSASETSERVICE  LPFN_WSASETSERVICEA
#endif /* !UNICODE */
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
INT
WSAAPI
WSAProviderConfigChange(
    __deref_inout_opt LPHANDLE lpNotificationHandle,
    __inout_opt LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_WSAPROVIDERCONFIGCHANGE)(
    __deref_inout_opt LPHANDLE lpNotificationHandle,
    __inout_opt LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif /* INCL_WINSOCK_API_TYPEDEFS */

#if(_WIN32_WINNT >= 0x0600)
#if INCL_WINSOCK_API_PROTOTYPES
__control_entrypoint(DllExport)
WINSOCK_API_LINKAGE
int
WSAAPI
WSAPoll(
    __inout LPWSAPOLLFD fdArray,
    __in ULONG fds,
    __in INT timeout
    );
#endif /* INCL_WINSOCK_API_PROTOTYPES */
#endif // (_WIN32_WINNT >= 0x0600)



/* Microsoft Windows Extended data types */
typedef struct sockaddr_in FAR *LPSOCKADDR_IN;

typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger FAR *LPLINGER;

typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set FAR *LPFD_SET;

typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent FAR *LPHOSTENT;

typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent FAR *LPSERVENT;

typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent FAR *LPPROTOENT;

typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval FAR *LPTIMEVAL;

/*
 * Windows message parameter composition and decomposition
 * macros.
 *
 * WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to a WSAAsyncGetXByY() routine.
 */
#define WSAMAKEASYNCREPLY(buflen,error)     MAKELONG(buflen,error)
/*
 * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to WSAAsyncSelect().
 */
#define WSAMAKESELECTREPLY(event,error)     MAKELONG(event,error)
/*
 * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application
 * to extract the buffer length from the lParam in the response
 * to a WSAAsyncGetXByY().
 */
#define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
/*
 * WSAGETASYNCERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
/*
 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
 * to extract the event code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTEVENT(lParam)           LOWORD(lParam)
/*
 * WSAGETSELECTERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTERROR(lParam)           HIWORD(lParam)

#ifdef __cplusplus
}
#endif

#ifdef _NEED_POPPACK
#include <poppack.h>
#endif

#if(_WIN32_WINNT >= 0x0501)
#ifdef IPV6STRICT
#include <wsipv6ok.h>
#endif // IPV6STRICT
#endif //(_WIN32_WINNT >= 0x0501)

#endif  /* _WINSOCK2API_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WinSvc.h ===
/*++ BUILD Version: 0010    // Increment this if a change has global effects

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    winsvc.h

Abstract:

    Header file for the Service Control Manager

Environment:

    User Mode - Win32

--*/
#ifndef _WINSVC_
#define _WINSVC_

//
// Define API decoration for direct importing of DLL references.
//

#if !defined(WINADVAPI)
#if !defined(_ADVAPI32_)
#define WINADVAPI DECLSPEC_IMPORT
#else
#define WINADVAPI
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Constants
//

//
// Service database names
//

#define SERVICES_ACTIVE_DATABASEW      L"ServicesActive"
#define SERVICES_FAILED_DATABASEW      L"ServicesFailed"

#define SERVICES_ACTIVE_DATABASEA      "ServicesActive"
#define SERVICES_FAILED_DATABASEA      "ServicesFailed"

//
// Character to designate that a name is a group
//

#define SC_GROUP_IDENTIFIERW           L'+'
#define SC_GROUP_IDENTIFIERA           '+'

#ifdef UNICODE

#define SERVICES_ACTIVE_DATABASE       SERVICES_ACTIVE_DATABASEW
#define SERVICES_FAILED_DATABASE       SERVICES_FAILED_DATABASEW


#define SC_GROUP_IDENTIFIER            SC_GROUP_IDENTIFIERW

#else // ndef UNICODE

#define SERVICES_ACTIVE_DATABASE       SERVICES_ACTIVE_DATABASEA
#define SERVICES_FAILED_DATABASE       SERVICES_FAILED_DATABASEA

#define SC_GROUP_IDENTIFIER            SC_GROUP_IDENTIFIERA
#endif // ndef UNICODE


//
// Value to indicate no change to an optional parameter
//
#define SERVICE_NO_CHANGE              0xffffffff

//
// Service State -- for Enum Requests (Bit Mask)
//
#define SERVICE_ACTIVE                 0x00000001
#define SERVICE_INACTIVE               0x00000002
#define SERVICE_STATE_ALL              (SERVICE_ACTIVE   | \
                                        SERVICE_INACTIVE)

//
// Controls
//
#define SERVICE_CONTROL_STOP                   0x00000001
#define SERVICE_CONTROL_PAUSE                  0x00000002
#define SERVICE_CONTROL_CONTINUE               0x00000003
#define SERVICE_CONTROL_INTERROGATE            0x00000004
#define SERVICE_CONTROL_SHUTDOWN               0x00000005
#define SERVICE_CONTROL_PARAMCHANGE            0x00000006
#define SERVICE_CONTROL_NETBINDADD             0x00000007
#define SERVICE_CONTROL_NETBINDREMOVE          0x00000008
#define SERVICE_CONTROL_NETBINDENABLE          0x00000009
#define SERVICE_CONTROL_NETBINDDISABLE         0x0000000A
#define SERVICE_CONTROL_DEVICEEVENT            0x0000000B
#define SERVICE_CONTROL_HARDWAREPROFILECHANGE  0x0000000C
#define SERVICE_CONTROL_POWEREVENT             0x0000000D
#define SERVICE_CONTROL_SESSIONCHANGE          0x0000000E
#define SERVICE_CONTROL_PRESHUTDOWN            0x0000000F
#define SERVICE_CONTROL_TIMECHANGE             0x00000010
#define SERVICE_CONTROL_TRIGGEREVENT           0x00000020

//
// Service State -- for CurrentState
//
#define SERVICE_STOPPED                        0x00000001
#define SERVICE_START_PENDING                  0x00000002
#define SERVICE_STOP_PENDING                   0x00000003
#define SERVICE_RUNNING                        0x00000004
#define SERVICE_CONTINUE_PENDING               0x00000005
#define SERVICE_PAUSE_PENDING                  0x00000006
#define SERVICE_PAUSED                         0x00000007

//
// Controls Accepted  (Bit Mask)
//
#define SERVICE_ACCEPT_STOP                    0x00000001
#define SERVICE_ACCEPT_PAUSE_CONTINUE          0x00000002
#define SERVICE_ACCEPT_SHUTDOWN                0x00000004
#define SERVICE_ACCEPT_PARAMCHANGE             0x00000008
#define SERVICE_ACCEPT_NETBINDCHANGE           0x00000010
#define SERVICE_ACCEPT_HARDWAREPROFILECHANGE   0x00000020
#define SERVICE_ACCEPT_POWEREVENT              0x00000040
#define SERVICE_ACCEPT_SESSIONCHANGE           0x00000080
#define SERVICE_ACCEPT_PRESHUTDOWN             0x00000100
#define SERVICE_ACCEPT_TIMECHANGE              0x00000200
#define SERVICE_ACCEPT_TRIGGEREVENT            0x00000400

//
// Service Control Manager object specific access types
//
#define SC_MANAGER_CONNECT             0x0001
#define SC_MANAGER_CREATE_SERVICE      0x0002
#define SC_MANAGER_ENUMERATE_SERVICE   0x0004
#define SC_MANAGER_LOCK                0x0008
#define SC_MANAGER_QUERY_LOCK_STATUS   0x0010
#define SC_MANAGER_MODIFY_BOOT_CONFIG  0x0020

#define SC_MANAGER_ALL_ACCESS          (STANDARD_RIGHTS_REQUIRED      | \
                                        SC_MANAGER_CONNECT            | \
                                        SC_MANAGER_CREATE_SERVICE     | \
                                        SC_MANAGER_ENUMERATE_SERVICE  | \
                                        SC_MANAGER_LOCK               | \
                                        SC_MANAGER_QUERY_LOCK_STATUS  | \
                                        SC_MANAGER_MODIFY_BOOT_CONFIG)



//
// Service object specific access type
//
#define SERVICE_QUERY_CONFIG           0x0001
#define SERVICE_CHANGE_CONFIG          0x0002
#define SERVICE_QUERY_STATUS           0x0004
#define SERVICE_ENUMERATE_DEPENDENTS   0x0008
#define SERVICE_START                  0x0010
#define SERVICE_STOP                   0x0020
#define SERVICE_PAUSE_CONTINUE         0x0040
#define SERVICE_INTERROGATE            0x0080
#define SERVICE_USER_DEFINED_CONTROL   0x0100

#define SERVICE_ALL_ACCESS             (STANDARD_RIGHTS_REQUIRED     | \
                                        SERVICE_QUERY_CONFIG         | \
                                        SERVICE_CHANGE_CONFIG        | \
                                        SERVICE_QUERY_STATUS         | \
                                        SERVICE_ENUMERATE_DEPENDENTS | \
                                        SERVICE_START                | \
                                        SERVICE_STOP                 | \
                                        SERVICE_PAUSE_CONTINUE       | \
                                        SERVICE_INTERROGATE          | \
                                        SERVICE_USER_DEFINED_CONTROL)

//
// Service flags for QueryServiceStatusEx
//
#define SERVICE_RUNS_IN_SYSTEM_PROCESS  0x00000001

//
// Info levels for ChangeServiceConfig2 and QueryServiceConfig2
//
#define SERVICE_CONFIG_DESCRIPTION              1
#define SERVICE_CONFIG_FAILURE_ACTIONS          2
#define SERVICE_CONFIG_DELAYED_AUTO_START_INFO  3
#define SERVICE_CONFIG_FAILURE_ACTIONS_FLAG     4
#define SERVICE_CONFIG_SERVICE_SID_INFO         5
#define SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO 6
#define SERVICE_CONFIG_PRESHUTDOWN_INFO         7
#define SERVICE_CONFIG_TRIGGER_INFO             8
#define SERVICE_CONFIG_PREFERRED_NODE           9

//
// Info levels for NotifyServiceStatusChange
//
#define SERVICE_NOTIFY_STATUS_CHANGE_1          1
#define SERVICE_NOTIFY_STATUS_CHANGE_2          2

#define SERVICE_NOTIFY_STATUS_CHANGE            SERVICE_NOTIFY_STATUS_CHANGE_2

//
// Service notification masks
//
#define SERVICE_NOTIFY_STOPPED                  0x00000001
#define SERVICE_NOTIFY_START_PENDING            0x00000002
#define SERVICE_NOTIFY_STOP_PENDING             0x00000004
#define SERVICE_NOTIFY_RUNNING                  0x00000008
#define SERVICE_NOTIFY_CONTINUE_PENDING         0x00000010
#define SERVICE_NOTIFY_PAUSE_PENDING            0x00000020
#define SERVICE_NOTIFY_PAUSED                   0x00000040
#define SERVICE_NOTIFY_CREATED                  0x00000080
#define SERVICE_NOTIFY_DELETED                  0x00000100
#define SERVICE_NOTIFY_DELETE_PENDING           0x00000200

//
// The following defines are for service stop reason codes
//

//
// Stop reason flags. Update SERVICE_STOP_REASON_FLAG_MAX when
// new flags are added.
//
#define SERVICE_STOP_REASON_FLAG_MIN                            0x00000000
#define SERVICE_STOP_REASON_FLAG_UNPLANNED                      0x10000000
#define SERVICE_STOP_REASON_FLAG_CUSTOM                         0x20000000
#define SERVICE_STOP_REASON_FLAG_PLANNED                        0x40000000
#define SERVICE_STOP_REASON_FLAG_MAX                            0x80000000

//
// Microsoft major reasons. Update SERVICE_STOP_REASON_MAJOR_MAX when
// new codes are added.
//
#define SERVICE_STOP_REASON_MAJOR_MIN                           0x00000000
#define SERVICE_STOP_REASON_MAJOR_OTHER                         0x00010000
#define SERVICE_STOP_REASON_MAJOR_HARDWARE                      0x00020000
#define SERVICE_STOP_REASON_MAJOR_OPERATINGSYSTEM               0x00030000
#define SERVICE_STOP_REASON_MAJOR_SOFTWARE                      0x00040000
#define SERVICE_STOP_REASON_MAJOR_APPLICATION                   0x00050000
#define SERVICE_STOP_REASON_MAJOR_NONE                          0x00060000
#define SERVICE_STOP_REASON_MAJOR_MAX                           0x00070000
#define SERVICE_STOP_REASON_MAJOR_MIN_CUSTOM                    0x00400000
#define SERVICE_STOP_REASON_MAJOR_MAX_CUSTOM                    0x00ff0000

//
// Microsoft minor reasons. Update SERVICE_STOP_REASON_MINOR_MAX when
// new codes are added.
//
#define SERVICE_STOP_REASON_MINOR_MIN                           0x00000000
#define SERVICE_STOP_REASON_MINOR_OTHER                         0x00000001
#define SERVICE_STOP_REASON_MINOR_MAINTENANCE                   0x00000002
#define SERVICE_STOP_REASON_MINOR_INSTALLATION                  0x00000003
#define SERVICE_STOP_REASON_MINOR_UPGRADE                       0x00000004
#define SERVICE_STOP_REASON_MINOR_RECONFIG                      0x00000005
#define SERVICE_STOP_REASON_MINOR_HUNG                          0x00000006
#define SERVICE_STOP_REASON_MINOR_UNSTABLE                      0x00000007
#define SERVICE_STOP_REASON_MINOR_DISK                          0x00000008
#define SERVICE_STOP_REASON_MINOR_NETWORKCARD                   0x00000009
#define SERVICE_STOP_REASON_MINOR_ENVIRONMENT                   0x0000000a
#define SERVICE_STOP_REASON_MINOR_HARDWARE_DRIVER               0x0000000b
#define SERVICE_STOP_REASON_MINOR_OTHERDRIVER                   0x0000000c
#define SERVICE_STOP_REASON_MINOR_SERVICEPACK                   0x0000000d
#define SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE               0x0000000e
#define SERVICE_STOP_REASON_MINOR_SECURITYFIX                   0x0000000f
#define SERVICE_STOP_REASON_MINOR_SECURITY                      0x00000010
#define SERVICE_STOP_REASON_MINOR_NETWORK_CONNECTIVITY          0x00000011
#define SERVICE_STOP_REASON_MINOR_WMI                           0x00000012
#define SERVICE_STOP_REASON_MINOR_SERVICEPACK_UNINSTALL         0x00000013
#define SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE_UNINSTALL     0x00000014
#define SERVICE_STOP_REASON_MINOR_SECURITYFIX_UNINSTALL         0x00000015
#define SERVICE_STOP_REASON_MINOR_MMC                           0x00000016
#define SERVICE_STOP_REASON_MINOR_NONE                          0x00000017
#define SERVICE_STOP_REASON_MINOR_MAX                           0x00000018
#define SERVICE_STOP_REASON_MINOR_MIN_CUSTOM                    0x00000100
#define SERVICE_STOP_REASON_MINOR_MAX_CUSTOM                    0x0000FFFF

//
// Info levels for ControlServiceEx
//
#define SERVICE_CONTROL_STATUS_REASON_INFO      1

//
// Service SID types supported
//
#define SERVICE_SID_TYPE_NONE                                   0x00000000
#define SERVICE_SID_TYPE_UNRESTRICTED                           0x00000001
#define SERVICE_SID_TYPE_RESTRICTED                             ( 0x00000002 | SERVICE_SID_TYPE_UNRESTRICTED )

//
// Service trigger types
//
#define SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL               1
#define SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY                2
#define SERVICE_TRIGGER_TYPE_DOMAIN_JOIN                            3
#define SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT                    4
#define SERVICE_TRIGGER_TYPE_GROUP_POLICY                           5
#define SERVICE_TRIGGER_TYPE_CUSTOM                                 20

//
// Service trigger data types
//
#define SERVICE_TRIGGER_DATA_TYPE_BINARY                            1
#define SERVICE_TRIGGER_DATA_TYPE_STRING                            2

//
//  NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID & NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID are used with
//  SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY trigger.
//
DEFINE_GUID ( /* 4f27f2de-14e2-430b-a549-7cd48cbc8245 */
    NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID,
    0x4f27f2de,
    0x14e2,
    0x430b,
    0xa5, 0x49, 0x7c, 0xd4, 0x8c, 0xbc, 0x82, 0x45
  );

DEFINE_GUID ( /* cc4ba62a-162e-4648-847a-b6bdf993e335 */
    NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID,
    0xcc4ba62a,
    0x162e,
    0x4648,
    0x84, 0x7a, 0xb6, 0xbd, 0xf9, 0x93, 0xe3, 0x35
  );

//
//  DOMAIN_JOIN_GUID & DOMAIN_LEAVE_GUID are used with SERVICE_TRIGGER_TYPE_DOMAIN_JOIN trigger.
//
DEFINE_GUID ( /* 1ce20aba-9851-4421-9430-1ddeb766e809 */
    DOMAIN_JOIN_GUID,
    0x1ce20aba,
    0x9851,
    0x4421,
    0x94, 0x30, 0x1d, 0xde, 0xb7, 0x66, 0xe8, 0x09
  );

DEFINE_GUID ( /* ddaf516e-58c2-4866-9574-c3b615d42ea1 */
    DOMAIN_LEAVE_GUID,
    0xddaf516e,
    0x58c2,
    0x4866,
    0x95, 0x74, 0xc3, 0xb6, 0x15, 0xd4, 0x2e, 0xa1
  );

//
//  FIREWALL_PORT_OPEN_GUID & FIREWALL_PORT_CLOSE_GUID are used with
//  SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT trigger.
//
DEFINE_GUID ( /* b7569e07-8421-4ee0-ad10-86915afdad09 */
    FIREWALL_PORT_OPEN_GUID,
    0xb7569e07,
    0x8421,
    0x4ee0,
    0xad, 0x10, 0x86, 0x91, 0x5a, 0xfd, 0xad, 0x09
  );

DEFINE_GUID ( /* a144ed38-8e12-4de4-9d96-e64740b1a524 */
    FIREWALL_PORT_CLOSE_GUID,
    0xa144ed38,
    0x8e12,
    0x4de4,
    0x9d, 0x96, 0xe6, 0x47, 0x40, 0xb1, 0xa5, 0x24
  );

//
//  MACHINE_POLICY_PRESENT_GUID & USER_POLICY_PRESENT_GUID are used with
//  SERVICE_TRIGGER_TYPE_GROUP_POLICY trigger.
//
DEFINE_GUID ( /* 659FCAE6-5BDB-4DA9-B1FF-CA2A178D46E0 */
    MACHINE_POLICY_PRESENT_GUID,
    0x659FCAE6,
    0x5BDB,
    0x4DA9,
    0xB1, 0xFF, 0xCA, 0x2A, 0x17, 0x8D, 0x46, 0xE0
  );

DEFINE_GUID ( /* 54FB46C8-F089-464C-B1FD-59D1B62C3B50 */
    USER_POLICY_PRESENT_GUID,
    0x54FB46C8,
    0xF089,
    0x464C,
    0xB1, 0xFD, 0x59, 0xD1, 0xB6, 0x2C, 0x3B, 0x50
  );

//
// Service trigger actions
//
#define SERVICE_TRIGGER_ACTION_SERVICE_START                        1
#define SERVICE_TRIGGER_ACTION_SERVICE_STOP                         2

//
// argv[1] passed into ServiceMain of trigger started services
//
#define SERVICE_TRIGGER_STARTED_ARGUMENT                L"TriggerStarted"

//
// Service description string
//
typedef struct _SERVICE_DESCRIPTIONA {
    LPSTR       lpDescription;
} SERVICE_DESCRIPTIONA, *LPSERVICE_DESCRIPTIONA;
//
// Service description string
//
typedef struct _SERVICE_DESCRIPTIONW {
    LPWSTR      lpDescription;
} SERVICE_DESCRIPTIONW, *LPSERVICE_DESCRIPTIONW;
#ifdef UNICODE
typedef SERVICE_DESCRIPTIONW SERVICE_DESCRIPTION;
typedef LPSERVICE_DESCRIPTIONW LPSERVICE_DESCRIPTION;
#else
typedef SERVICE_DESCRIPTIONA SERVICE_DESCRIPTION;
typedef LPSERVICE_DESCRIPTIONA LPSERVICE_DESCRIPTION;
#endif // UNICODE

//
// Actions to take on service failure
//
typedef enum _SC_ACTION_TYPE {
        SC_ACTION_NONE          = 0,
        SC_ACTION_RESTART       = 1,
        SC_ACTION_REBOOT        = 2,
        SC_ACTION_RUN_COMMAND   = 3
} SC_ACTION_TYPE;

typedef struct _SC_ACTION {
    SC_ACTION_TYPE  Type;
    DWORD           Delay;
} SC_ACTION, *LPSC_ACTION;

typedef struct _SERVICE_FAILURE_ACTIONSA {
    DWORD       dwResetPeriod;
    LPSTR       lpRebootMsg;
    LPSTR       lpCommand;
#ifdef __midl
    [range(0, 1024)]
#endif
    DWORD       cActions;
#ifdef __midl
    [size_is(cActions)]
#endif
    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSA, *LPSERVICE_FAILURE_ACTIONSA;
typedef struct _SERVICE_FAILURE_ACTIONSW {
    DWORD       dwResetPeriod;
    LPWSTR      lpRebootMsg;
    LPWSTR      lpCommand;
#ifdef __midl
    [range(0, 1024)]
#endif
    DWORD       cActions;
#ifdef __midl
    [size_is(cActions)]
#endif
    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSW, *LPSERVICE_FAILURE_ACTIONSW;
#ifdef UNICODE
typedef SERVICE_FAILURE_ACTIONSW SERVICE_FAILURE_ACTIONS;
typedef LPSERVICE_FAILURE_ACTIONSW LPSERVICE_FAILURE_ACTIONS;
#else
typedef SERVICE_FAILURE_ACTIONSA SERVICE_FAILURE_ACTIONS;
typedef LPSERVICE_FAILURE_ACTIONSA LPSERVICE_FAILURE_ACTIONS;
#endif // UNICODE

//
// Service delayed autostart info setting
//
typedef struct _SERVICE_DELAYED_AUTO_START_INFO {
    BOOL       fDelayedAutostart;      // Delayed autostart flag
} SERVICE_DELAYED_AUTO_START_INFO, *LPSERVICE_DELAYED_AUTO_START_INFO;

//
// Service failure actions flag setting
//
typedef struct _SERVICE_FAILURE_ACTIONS_FLAG {
    BOOL       fFailureActionsOnNonCrashFailures;       // Failure actions flag
} SERVICE_FAILURE_ACTIONS_FLAG, *LPSERVICE_FAILURE_ACTIONS_FLAG;

//
// Service SID info setting
//
typedef struct _SERVICE_SID_INFO {
    DWORD       dwServiceSidType;     // Service SID type
} SERVICE_SID_INFO, *LPSERVICE_SID_INFO;

//
// Service required privileges information
//
typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOA {
    LPSTR       pmszRequiredPrivileges;             // Required privileges multi-sz
} SERVICE_REQUIRED_PRIVILEGES_INFOA, *LPSERVICE_REQUIRED_PRIVILEGES_INFOA;
//
// Service required privileges information
//
typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOW {
    LPWSTR      pmszRequiredPrivileges;             // Required privileges multi-sz
} SERVICE_REQUIRED_PRIVILEGES_INFOW, *LPSERVICE_REQUIRED_PRIVILEGES_INFOW;
#ifdef UNICODE
typedef SERVICE_REQUIRED_PRIVILEGES_INFOW SERVICE_REQUIRED_PRIVILEGES_INFO;
typedef LPSERVICE_REQUIRED_PRIVILEGES_INFOW LPSERVICE_REQUIRED_PRIVILEGES_INFO;
#else
typedef SERVICE_REQUIRED_PRIVILEGES_INFOA SERVICE_REQUIRED_PRIVILEGES_INFO;
typedef LPSERVICE_REQUIRED_PRIVILEGES_INFOA LPSERVICE_REQUIRED_PRIVILEGES_INFO;
#endif // UNICODE

//
// Service preshutdown timeout setting
//
typedef struct _SERVICE_PRESHUTDOWN_INFO {
    DWORD       dwPreshutdownTimeout;   // Timeout in msecs
} SERVICE_PRESHUTDOWN_INFO, *LPSERVICE_PRESHUTDOWN_INFO;

//
//  Service trigger data item
//
typedef struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM
{
    DWORD   dwDataType; // Data type -- one of SERVICE_TRIGGER_DATA_TYPE_* constants
#ifdef __midl
    [range(0, 1024)]
#endif
    DWORD   cbData;     // Size of trigger specific data
#ifdef __midl
    [size_is(cbData)]
#endif
    PBYTE   pData;      // Trigger specific data
} SERVICE_TRIGGER_SPECIFIC_DATA_ITEM, *PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM;

//
//  Trigger-specific information
//
typedef struct _SERVICE_TRIGGER
{
    DWORD                       dwTriggerType;              // One of SERVICE_TRIGGER_TYPE_* constants
    DWORD                       dwAction;                   // One of SERVICE_TRIGGER_ACTION_* constants
    GUID    *                   pTriggerSubtype;            // Provider GUID if the trigger type is SERVICE_TRIGGER_TYPE_CUSTOM
                                                            // Device class interface GUID if the trigger type is
                                                            // SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL
#ifdef __midl
    [range(0, 64)]
#endif
    DWORD                       cDataItems;                 // Number of data items in pDataItems array
#ifdef __midl
    [size_is(cDataItems)]
#endif
    PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM  pDataItems;       // Trigger specific data
} SERVICE_TRIGGER, *PSERVICE_TRIGGER;

//
// Service trigger information
//
typedef struct _SERVICE_TRIGGER_INFO {
#ifdef __midl
    [range(0, 64)]
#endif
    DWORD                   cTriggers;  // Number of triggers in the pTriggers array
#ifdef __midl
    [size_is(cTriggers)]
#endif
    PSERVICE_TRIGGER        pTriggers;  // Array of triggers
    PBYTE                   pReserved;  // Reserved, must be NULL
} SERVICE_TRIGGER_INFO, *PSERVICE_TRIGGER_INFO;

//
// Preferred node information
//
typedef struct _SERVICE_PREFERRED_NODE_INFO {
    USHORT                  usPreferredNode;    // Preferred node
    BOOLEAN                 fDelete;            // Delete the preferred node setting
} SERVICE_PREFERRED_NODE_INFO, *LPSERVICE_PREFERRED_NODE_INFO;

//
// Time change information
//
typedef struct _SERVICE_TIMECHANGE_INFO {
    LARGE_INTEGER   liNewTime;      // New time
    LARGE_INTEGER   liOldTime;      // Old time
} SERVICE_TIMECHANGE_INFO, *PSERVICE_TIMECHANGE_INFO;

//
// Handle Types
//

DECLARE_HANDLE(SC_HANDLE);
typedef SC_HANDLE   *LPSC_HANDLE;

DECLARE_HANDLE(SERVICE_STATUS_HANDLE);

//
// Info levels for QueryServiceStatusEx
//

typedef enum _SC_STATUS_TYPE {
    SC_STATUS_PROCESS_INFO      = 0
} SC_STATUS_TYPE;

//
// Info levels for EnumServicesStatusEx
//
typedef enum _SC_ENUM_TYPE {
    SC_ENUM_PROCESS_INFO        = 0
} SC_ENUM_TYPE;


//
// Service Status Structures
//

typedef struct _SERVICE_STATUS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;

typedef struct _SERVICE_STATUS_PROCESS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
    DWORD   dwProcessId;
    DWORD   dwServiceFlags;
} SERVICE_STATUS_PROCESS, *LPSERVICE_STATUS_PROCESS;


//
// Service Status Enumeration Structure
//

typedef struct _ENUM_SERVICE_STATUSA {
    LPSTR             lpServiceName;
    LPSTR             lpDisplayName;
    SERVICE_STATUS    ServiceStatus;
} ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;
typedef struct _ENUM_SERVICE_STATUSW {
    LPWSTR            lpServiceName;
    LPWSTR            lpDisplayName;
    SERVICE_STATUS    ServiceStatus;
} ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW;
#ifdef UNICODE
typedef ENUM_SERVICE_STATUSW ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSW LPENUM_SERVICE_STATUS;
#else
typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSA LPENUM_SERVICE_STATUS;
#endif // UNICODE

typedef struct _ENUM_SERVICE_STATUS_PROCESSA {
    LPSTR                     lpServiceName;
    LPSTR                     lpDisplayName;
    SERVICE_STATUS_PROCESS    ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSA, *LPENUM_SERVICE_STATUS_PROCESSA;
typedef struct _ENUM_SERVICE_STATUS_PROCESSW {
    LPWSTR                    lpServiceName;
    LPWSTR                    lpDisplayName;
    SERVICE_STATUS_PROCESS    ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSW, *LPENUM_SERVICE_STATUS_PROCESSW;
#ifdef UNICODE
typedef ENUM_SERVICE_STATUS_PROCESSW ENUM_SERVICE_STATUS_PROCESS;
typedef LPENUM_SERVICE_STATUS_PROCESSW LPENUM_SERVICE_STATUS_PROCESS;
#else
typedef ENUM_SERVICE_STATUS_PROCESSA ENUM_SERVICE_STATUS_PROCESS;
typedef LPENUM_SERVICE_STATUS_PROCESSA LPENUM_SERVICE_STATUS_PROCESS;
#endif // UNICODE

//
// Structures for the Lock API functions
//

typedef LPVOID  SC_LOCK;

typedef struct _QUERY_SERVICE_LOCK_STATUSA {
    DWORD   fIsLocked;
    LPSTR   lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA;
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
    DWORD   fIsLocked;
    LPWSTR  lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW;
#ifdef UNICODE
typedef QUERY_SERVICE_LOCK_STATUSW QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSW LPQUERY_SERVICE_LOCK_STATUS;
#else
typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSA LPQUERY_SERVICE_LOCK_STATUS;
#endif // UNICODE



//
// Query Service Configuration Structure
//

typedef struct _QUERY_SERVICE_CONFIGA {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPSTR   lpBinaryPathName;
    LPSTR   lpLoadOrderGroup;
    DWORD   dwTagId;
    LPSTR   lpDependencies;
    LPSTR   lpServiceStartName;
    LPSTR   lpDisplayName;
} QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA;
typedef struct _QUERY_SERVICE_CONFIGW {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPWSTR  lpBinaryPathName;
    LPWSTR  lpLoadOrderGroup;
    DWORD   dwTagId;
    LPWSTR  lpDependencies;
    LPWSTR  lpServiceStartName;
    LPWSTR  lpDisplayName;
} QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;
#ifdef UNICODE
typedef QUERY_SERVICE_CONFIGW QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGW LPQUERY_SERVICE_CONFIG;
#else
typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGA LPQUERY_SERVICE_CONFIG;
#endif // UNICODE



//
// Function Prototype for the Service Main Function
//

typedef VOID (WINAPI *LPSERVICE_MAIN_FUNCTIONW)(
    DWORD   dwNumServicesArgs,
    LPWSTR  *lpServiceArgVectors
    );

typedef VOID (WINAPI *LPSERVICE_MAIN_FUNCTIONA)(
    DWORD   dwNumServicesArgs,
    LPSTR   *lpServiceArgVectors
    );

#ifdef UNICODE
#define LPSERVICE_MAIN_FUNCTION LPSERVICE_MAIN_FUNCTIONW
#else
#define LPSERVICE_MAIN_FUNCTION LPSERVICE_MAIN_FUNCTIONA
#endif //UNICODE


//
// Service Start Table
//

typedef struct _SERVICE_TABLE_ENTRYA {
    LPSTR                       lpServiceName;
    LPSERVICE_MAIN_FUNCTIONA    lpServiceProc;
}SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR                      lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW    lpServiceProc;
}SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;
#ifdef UNICODE
typedef SERVICE_TABLE_ENTRYW SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYW LPSERVICE_TABLE_ENTRY;
#else
typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYA LPSERVICE_TABLE_ENTRY;
#endif // UNICODE

//
// Prototype for the Service Control Handler Function
//

typedef VOID (WINAPI *LPHANDLER_FUNCTION)(
    DWORD    dwControl
    );

typedef DWORD (WINAPI *LPHANDLER_FUNCTION_EX)(
    DWORD    dwControl,
    DWORD    dwEventType,
    LPVOID   lpEventData,
    LPVOID   lpContext
    );

//
// Service notification parameters
//
typedef
VOID
( CALLBACK * PFN_SC_NOTIFY_CALLBACK ) (
    __in PVOID pParameter
    );

//
//  Each new notify structure is a superset of the older version
//
typedef struct _SERVICE_NOTIFY_1 {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
} SERVICE_NOTIFY_1, *PSERVICE_NOTIFY_1;

typedef struct _SERVICE_NOTIFY_2A {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
    DWORD                   dwNotificationTriggered;
    LPSTR                   pszServiceNames;
} SERVICE_NOTIFY_2A, *PSERVICE_NOTIFY_2A;
typedef struct _SERVICE_NOTIFY_2W {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
    DWORD                   dwNotificationTriggered;
    LPWSTR                  pszServiceNames;
} SERVICE_NOTIFY_2W, *PSERVICE_NOTIFY_2W;
#ifdef UNICODE
typedef SERVICE_NOTIFY_2W SERVICE_NOTIFY_2;
typedef PSERVICE_NOTIFY_2W PSERVICE_NOTIFY_2;
#else
typedef SERVICE_NOTIFY_2A SERVICE_NOTIFY_2;
typedef PSERVICE_NOTIFY_2A PSERVICE_NOTIFY_2;
#endif // UNICODE

typedef SERVICE_NOTIFY_2A SERVICE_NOTIFYA, *PSERVICE_NOTIFYA;
typedef SERVICE_NOTIFY_2W SERVICE_NOTIFYW, *PSERVICE_NOTIFYW;
#ifdef UNICODE
typedef SERVICE_NOTIFYW SERVICE_NOTIFY;
typedef PSERVICE_NOTIFYW PSERVICE_NOTIFY;
#else
typedef SERVICE_NOTIFYA SERVICE_NOTIFY;
typedef PSERVICE_NOTIFYA PSERVICE_NOTIFY;
#endif // UNICODE

//
// Service control status reason parameters
//
typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA {
    DWORD                   dwReason;
    LPSTR                   pszComment;
    SERVICE_STATUS_PROCESS  ServiceStatus;
} SERVICE_CONTROL_STATUS_REASON_PARAMSA, *PSERVICE_CONTROL_STATUS_REASON_PARAMSA;
//
// Service control status reason parameters
//
typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW {
    DWORD                   dwReason;
    LPWSTR                  pszComment;
    SERVICE_STATUS_PROCESS  ServiceStatus;
} SERVICE_CONTROL_STATUS_REASON_PARAMSW, *PSERVICE_CONTROL_STATUS_REASON_PARAMSW;
#ifdef UNICODE
typedef SERVICE_CONTROL_STATUS_REASON_PARAMSW SERVICE_CONTROL_STATUS_REASON_PARAMS;
typedef PSERVICE_CONTROL_STATUS_REASON_PARAMSW PSERVICE_CONTROL_STATUS_REASON_PARAMS;
#else
typedef SERVICE_CONTROL_STATUS_REASON_PARAMSA SERVICE_CONTROL_STATUS_REASON_PARAMS;
typedef PSERVICE_CONTROL_STATUS_REASON_PARAMSA PSERVICE_CONTROL_STATUS_REASON_PARAMS;
#endif // UNICODE

///////////////////////////////////////////////////////////////////////////
// API Function Prototypes
///////////////////////////////////////////////////////////////////////////

WINADVAPI
BOOL
WINAPI
ChangeServiceConfigA(
    __in        SC_HANDLE    hService,
    __in        DWORD        dwServiceType,
    __in        DWORD        dwStartType,
    __in        DWORD        dwErrorControl,
    __in_opt    LPCSTR     lpBinaryPathName,
    __in_opt    LPCSTR     lpLoadOrderGroup,
    __out_opt   LPDWORD      lpdwTagId,
    __in_opt    LPCSTR     lpDependencies,
    __in_opt    LPCSTR     lpServiceStartName,
    __in_opt    LPCSTR     lpPassword,
    __in_opt    LPCSTR     lpDisplayName
    );
WINADVAPI
BOOL
WINAPI
ChangeServiceConfigW(
    __in        SC_HANDLE    hService,
    __in        DWORD        dwServiceType,
    __in        DWORD        dwStartType,
    __in        DWORD        dwErrorControl,
    __in_opt    LPCWSTR     lpBinaryPathName,
    __in_opt    LPCWSTR     lpLoadOrderGroup,
    __out_opt   LPDWORD      lpdwTagId,
    __in_opt    LPCWSTR     lpDependencies,
    __in_opt    LPCWSTR     lpServiceStartName,
    __in_opt    LPCWSTR     lpPassword,
    __in_opt    LPCWSTR     lpDisplayName
    );
#ifdef UNICODE
#define ChangeServiceConfig  ChangeServiceConfigW
#else
#define ChangeServiceConfig  ChangeServiceConfigA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
ChangeServiceConfig2A(
    __in        SC_HANDLE    hService,
    __in        DWORD        dwInfoLevel,
    __in_opt    LPVOID       lpInfo
    );
WINADVAPI
BOOL
WINAPI
ChangeServiceConfig2W(
    __in        SC_HANDLE    hService,
    __in        DWORD        dwInfoLevel,
    __in_opt    LPVOID       lpInfo
    );
#ifdef UNICODE
#define ChangeServiceConfig2  ChangeServiceConfig2W
#else
#define ChangeServiceConfig2  ChangeServiceConfig2A
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
CloseServiceHandle(
    __in        SC_HANDLE   hSCObject
    );

WINADVAPI
BOOL
WINAPI
ControlService(
    __in        SC_HANDLE           hService,
    __in        DWORD               dwControl,
    __out       LPSERVICE_STATUS    lpServiceStatus
    );

__checkReturn
WINADVAPI
SC_HANDLE
WINAPI
CreateServiceA(
    __in        SC_HANDLE    hSCManager,
    __in        LPCSTR     lpServiceName,
    __in_opt    LPCSTR     lpDisplayName,
    __in        DWORD        dwDesiredAccess,
    __in        DWORD        dwServiceType,
    __in        DWORD        dwStartType,
    __in        DWORD        dwErrorControl,
    __in_opt    LPCSTR     lpBinaryPathName,
    __in_opt    LPCSTR     lpLoadOrderGroup,
    __out_opt   LPDWORD      lpdwTagId,
    __in_opt    LPCSTR     lpDependencies,
    __in_opt    LPCSTR     lpServiceStartName,
    __in_opt    LPCSTR     lpPassword
    );
__checkReturn
WINADVAPI
SC_HANDLE
WINAPI
CreateServiceW(
    __in        SC_HANDLE    hSCManager,
    __in        LPCWSTR     lpServiceName,
    __in_opt    LPCWSTR     lpDisplayName,
    __in        DWORD        dwDesiredAccess,
    __in        DWORD        dwServiceType,
    __in        DWORD        dwStartType,
    __in        DWORD        dwErrorControl,
    __in_opt    LPCWSTR     lpBinaryPathName,
    __in_opt    LPCWSTR     lpLoadOrderGroup,
    __out_opt   LPDWORD      lpdwTagId,
    __in_opt    LPCWSTR     lpDependencies,
    __in_opt    LPCWSTR     lpServiceStartName,
    __in_opt    LPCWSTR     lpPassword
    );
#ifdef UNICODE
#define CreateService  CreateServiceW
#else
#define CreateService  CreateServiceA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
DeleteService(
    __in        SC_HANDLE   hService
    );

__checkReturn
WINADVAPI
BOOL
WINAPI
EnumDependentServicesA(
    __in            SC_HANDLE               hService,
    __in            DWORD                   dwServiceState,
    __out_bcount_opt(cbBufSize)
                    LPENUM_SERVICE_STATUSA  lpServices,
    __in            DWORD                   cbBufSize,
    __out           LPDWORD                 pcbBytesNeeded,
    __out           LPDWORD                 lpServicesReturned
    );
__checkReturn
WINADVAPI
BOOL
WINAPI
EnumDependentServicesW(
    __in            SC_HANDLE               hService,
    __in            DWORD                   dwServiceState,
    __out_bcount_opt(cbBufSize)
                    LPENUM_SERVICE_STATUSW  lpServices,
    __in            DWORD                   cbBufSize,
    __out           LPDWORD                 pcbBytesNeeded,
    __out           LPDWORD                 lpServicesReturned
    );
#ifdef UNICODE
#define EnumDependentServices  EnumDependentServicesW
#else
#define EnumDependentServices  EnumDependentServicesA
#endif // !UNICODE

__checkReturn
WINADVAPI
BOOL
WINAPI
EnumServicesStatusA(
    __in            SC_HANDLE               hSCManager,
    __in            DWORD                   dwServiceType,
    __in            DWORD                   dwServiceState,
    __out_bcount_opt(cbBufSize)
                    LPENUM_SERVICE_STATUSA  lpServices,
    __in            DWORD                   cbBufSize,
    __out           LPDWORD                 pcbBytesNeeded,
    __out           LPDWORD                 lpServicesReturned,
    __inout_opt     LPDWORD                 lpResumeHandle
    );
__checkReturn
WINADVAPI
BOOL
WINAPI
EnumServicesStatusW(
    __in            SC_HANDLE               hSCManager,
    __in            DWORD                   dwServiceType,
    __in            DWORD                   dwServiceState,
    __out_bcount_opt(cbBufSize)
                    LPENUM_SERVICE_STATUSW  lpServices,
    __in            DWORD                   cbBufSize,
    __out           LPDWORD                 pcbBytesNeeded,
    __out           LPDWORD                 lpServicesReturned,
    __inout_opt     LPDWORD                 lpResumeHandle
    );
#ifdef UNICODE
#define EnumServicesStatus  EnumServicesStatusW
#else
#define EnumServicesStatus  EnumServicesStatusA
#endif // !UNICODE

__checkReturn
WINADVAPI
BOOL
WINAPI
EnumServicesStatusExA(
    __in            SC_HANDLE               hSCManager,
    __in            SC_ENUM_TYPE            InfoLevel,
    __in            DWORD                   dwServiceType,
    __in            DWORD                   dwServiceState,
    __out_bcount_opt(cbBufSize)
                    LPBYTE                  lpServices,
    __in            DWORD                   cbBufSize,
    __out           LPDWORD                 pcbBytesNeeded,
    __out           LPDWORD                 lpServicesReturned,
    __inout_opt     LPDWORD                 lpResumeHandle,
    __in_opt        LPCSTR                pszGroupName
    );
__checkReturn
WINADVAPI
BOOL
WINAPI
EnumServicesStatusExW(
    __in            SC_HANDLE               hSCManager,
    __in            SC_ENUM_TYPE            InfoLevel,
    __in            DWORD                   dwServiceType,
    __in            DWORD                   dwServiceState,
    __out_bcount_opt(cbBufSize)
                    LPBYTE                  lpServices,
    __in            DWORD                   cbBufSize,
    __out           LPDWORD                 pcbBytesNeeded,
    __out           LPDWORD                 lpServicesReturned,
    __inout_opt     LPDWORD                 lpResumeHandle,
    __in_opt        LPCWSTR                pszGroupName
    );
#ifdef UNICODE
#define EnumServicesStatusEx  EnumServicesStatusExW
#else
#define EnumServicesStatusEx  EnumServicesStatusExA
#endif // !UNICODE

__checkReturn
WINADVAPI
BOOL
WINAPI
GetServiceKeyNameA(
    __in            SC_HANDLE               hSCManager,
    __in            LPCSTR                lpDisplayName,
    __out_ecount_opt(*lpcchBuffer)
                    LPSTR                 lpServiceName,
    __inout         LPDWORD                 lpcchBuffer
    );
__checkReturn
WINADVAPI
BOOL
WINAPI
GetServiceKeyNameW(
    __in            SC_HANDLE               hSCManager,
    __in            LPCWSTR                lpDisplayName,
    __out_ecount_opt(*lpcchBuffer)
                    LPWSTR                 lpServiceName,
    __inout         LPDWORD                 lpcchBuffer
    );
#ifdef UNICODE
#define GetServiceKeyName  GetServiceKeyNameW
#else
#define GetServiceKeyName  GetServiceKeyNameA
#endif // !UNICODE

__checkReturn
WINADVAPI
BOOL
WINAPI
GetServiceDisplayNameA(
    __in            SC_HANDLE               hSCManager,
    __in            LPCSTR                lpServiceName,
    __out_ecount_opt(*lpcchBuffer)
                    LPSTR                 lpDisplayName,
    __inout         LPDWORD                 lpcchBuffer
    );
__checkReturn
WINADVAPI
BOOL
WINAPI
GetServiceDisplayNameW(
    __in            SC_HANDLE               hSCManager,
    __in            LPCWSTR                lpServiceName,
    __out_ecount_opt(*lpcchBuffer)
                    LPWSTR                 lpDisplayName,
    __inout         LPDWORD                 lpcchBuffer
    );
#ifdef UNICODE
#define GetServiceDisplayName  GetServiceDisplayNameW
#else
#define GetServiceDisplayName  GetServiceDisplayNameA
#endif // !UNICODE

WINADVAPI
SC_LOCK
WINAPI
LockServiceDatabase(
    __in            SC_HANDLE               hSCManager
    );

WINADVAPI
BOOL
WINAPI
NotifyBootConfigStatus(
    __in            BOOL                    BootAcceptable
    );

__checkReturn
WINADVAPI
SC_HANDLE
WINAPI
OpenSCManagerA(
    __in_opt        LPCSTR                lpMachineName,
    __in_opt        LPCSTR                lpDatabaseName,
    __in            DWORD                   dwDesiredAccess
    );
__checkReturn
WINADVAPI
SC_HANDLE
WINAPI
OpenSCManagerW(
    __in_opt        LPCWSTR                lpMachineName,
    __in_opt        LPCWSTR                lpDatabaseName,
    __in            DWORD                   dwDesiredAccess
    );
#ifdef UNICODE
#define OpenSCManager  OpenSCManagerW
#else
#define OpenSCManager  OpenSCManagerA
#endif // !UNICODE

__checkReturn
WINADVAPI
SC_HANDLE
WINAPI
OpenServiceA(
    __in            SC_HANDLE               hSCManager,
    __in            LPCSTR                lpServiceName,
    __in            DWORD                   dwDesiredAccess
    );
__checkReturn
WINADVAPI
SC_HANDLE
WINAPI
OpenServiceW(
    __in            SC_HANDLE               hSCManager,
    __in            LPCWSTR                lpServiceName,
    __in            DWORD                   dwDesiredAccess
    );
#ifdef UNICODE
#define OpenService  OpenServiceW
#else
#define OpenService  OpenServiceA
#endif // !UNICODE

__checkReturn
WINADVAPI
BOOL
WINAPI
QueryServiceConfigA(
    __in            SC_HANDLE               hService,
    __out_bcount_opt(cbBufSize)
                    LPQUERY_SERVICE_CONFIGA lpServiceConfig,
    __in            DWORD                   cbBufSize,
    __out           LPDWORD                 pcbBytesNeeded
    );
__checkReturn
WINADVAPI
BOOL
WINAPI
QueryServiceConfigW(
    __in            SC_HANDLE               hService,
    __out_bcount_opt(cbBufSize)
                    LPQUERY_SERVICE_CONFIGW lpServiceConfig,
    __in            DWORD                   cbBufSize,
    __out           LPDWORD                 pcbBytesNeeded
    );
#ifdef UNICODE
#define QueryServiceConfig  QueryServiceConfigW
#else
#define QueryServiceConfig  QueryServiceConfigA
#endif // !UNICODE

__checkReturn
WINADVAPI
BOOL
WINAPI
QueryServiceConfig2A(
    __in            SC_HANDLE               hService,
    __in            DWORD                   dwInfoLevel,
    __out_bcount_opt(cbBufSize)
                    LPBYTE                  lpBuffer,
    __in            DWORD                   cbBufSize,
    __out           LPDWORD                 pcbBytesNeeded
    );
__checkReturn
WINADVAPI
BOOL
WINAPI
QueryServiceConfig2W(
    __in            SC_HANDLE               hService,
    __in            DWORD                   dwInfoLevel,
    __out_bcount_opt(cbBufSize)
                    LPBYTE                  lpBuffer,
    __in            DWORD                   cbBufSize,
    __out           LPDWORD                 pcbBytesNeeded
    );
#ifdef UNICODE
#define QueryServiceConfig2  QueryServiceConfig2W
#else
#define QueryServiceConfig2  QueryServiceConfig2A
#endif // !UNICODE

__checkReturn
WINADVAPI
BOOL
WINAPI
QueryServiceLockStatusA(
    __in            SC_HANDLE                       hSCManager,
    __out_bcount_opt(cbBufSize)
                    LPQUERY_SERVICE_LOCK_STATUSA    lpLockStatus,
    __in            DWORD                           cbBufSize,
    __out           LPDWORD                         pcbBytesNeeded
    );
__checkReturn
WINADVAPI
BOOL
WINAPI
QueryServiceLockStatusW(
    __in            SC_HANDLE                       hSCManager,
    __out_bcount_opt(cbBufSize)
                    LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
    __in            DWORD                           cbBufSize,
    __out           LPDWORD                         pcbBytesNeeded
    );
#ifdef UNICODE
#define QueryServiceLockStatus  QueryServiceLockStatusW
#else
#define QueryServiceLockStatus  QueryServiceLockStatusA
#endif // !UNICODE

__checkReturn
WINADVAPI
BOOL
WINAPI
QueryServiceObjectSecurity(
    __in            SC_HANDLE               hService,
    __in            SECURITY_INFORMATION    dwSecurityInformation,
    __out_bcount_opt(cbBufSize)
                    PSECURITY_DESCRIPTOR    lpSecurityDescriptor,
    __in            DWORD                   cbBufSize,
    __out           LPDWORD                 pcbBytesNeeded
    );

__checkReturn
WINADVAPI
BOOL
WINAPI
QueryServiceStatus(
    __in            SC_HANDLE           hService,
    __out           LPSERVICE_STATUS    lpServiceStatus
    );

__checkReturn
WINADVAPI
BOOL
WINAPI
QueryServiceStatusEx(
    __in            SC_HANDLE           hService,
    __in            SC_STATUS_TYPE      InfoLevel,
    __out_bcount_opt(cbBufSize)
                    LPBYTE              lpBuffer,
    __in            DWORD               cbBufSize,
    __out           LPDWORD             pcbBytesNeeded
    );

__checkReturn
WINADVAPI
SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerA(
    __in    LPCSTR                    lpServiceName,
    __in    __callback
            LPHANDLER_FUNCTION          lpHandlerProc
    );
__checkReturn
WINADVAPI
SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerW(
    __in    LPCWSTR                    lpServiceName,
    __in    __callback
            LPHANDLER_FUNCTION          lpHandlerProc
    );
#ifdef UNICODE
#define RegisterServiceCtrlHandler  RegisterServiceCtrlHandlerW
#else
#define RegisterServiceCtrlHandler  RegisterServiceCtrlHandlerA
#endif // !UNICODE

__checkReturn
WINADVAPI
SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerExA(
    __in    LPCSTR                    lpServiceName,
    __in    __callback
            LPHANDLER_FUNCTION_EX       lpHandlerProc,
    __in_opt LPVOID                     lpContext
    );
__checkReturn
WINADVAPI
SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerExW(
    __in    LPCWSTR                    lpServiceName,
    __in    __callback
            LPHANDLER_FUNCTION_EX       lpHandlerProc,
    __in_opt LPVOID                     lpContext
    );
#ifdef UNICODE
#define RegisterServiceCtrlHandlerEx  RegisterServiceCtrlHandlerExW
#else
#define RegisterServiceCtrlHandlerEx  RegisterServiceCtrlHandlerExA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
SetServiceObjectSecurity(
    __in        SC_HANDLE               hService,
    __in        SECURITY_INFORMATION    dwSecurityInformation,
    __in        PSECURITY_DESCRIPTOR    lpSecurityDescriptor
    );

WINADVAPI
BOOL
WINAPI
SetServiceStatus(
    __in        SERVICE_STATUS_HANDLE   hServiceStatus,
    __in        LPSERVICE_STATUS        lpServiceStatus
    );

WINADVAPI
BOOL
WINAPI
StartServiceCtrlDispatcherA(
    __in CONST  SERVICE_TABLE_ENTRYA    *lpServiceStartTable
    );
WINADVAPI
BOOL
WINAPI
StartServiceCtrlDispatcherW(
    __in CONST  SERVICE_TABLE_ENTRYW    *lpServiceStartTable
    );
#ifdef UNICODE
#define StartServiceCtrlDispatcher  StartServiceCtrlDispatcherW
#else
#define StartServiceCtrlDispatcher  StartServiceCtrlDispatcherA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
StartServiceA(
    __in            SC_HANDLE            hService,
    __in            DWORD                dwNumServiceArgs,
    __in_ecount_opt(dwNumServiceArgs)
                    LPCSTR             *lpServiceArgVectors
    );
WINADVAPI
BOOL
WINAPI
StartServiceW(
    __in            SC_HANDLE            hService,
    __in            DWORD                dwNumServiceArgs,
    __in_ecount_opt(dwNumServiceArgs)
                    LPCWSTR             *lpServiceArgVectors
    );
#ifdef UNICODE
#define StartService  StartServiceW
#else
#define StartService  StartServiceA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
UnlockServiceDatabase(
    __in            SC_LOCK             ScLock
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)

WINADVAPI
DWORD
WINAPI
NotifyServiceStatusChangeA (
    __in        SC_HANDLE               hService,
    __in        DWORD                   dwNotifyMask,
    __in        PSERVICE_NOTIFYA        pNotifyBuffer
    );
WINADVAPI
DWORD
WINAPI
NotifyServiceStatusChangeW (
    __in        SC_HANDLE               hService,
    __in        DWORD                   dwNotifyMask,
    __in        PSERVICE_NOTIFYW        pNotifyBuffer
    );
#ifdef UNICODE
#define NotifyServiceStatusChange  NotifyServiceStatusChangeW
#else
#define NotifyServiceStatusChange  NotifyServiceStatusChangeA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
ControlServiceExA(
    __in        SC_HANDLE               hService,
    __in        DWORD                   dwControl,
    __in        DWORD                   dwInfoLevel,
    __inout     PVOID                   pControlParams
    );
WINADVAPI
BOOL
WINAPI
ControlServiceExW(
    __in        SC_HANDLE               hService,
    __in        DWORD                   dwControl,
    __in        DWORD                   dwInfoLevel,
    __inout     PVOID                   pControlParams
    );
#ifdef UNICODE
#define ControlServiceEx  ControlServiceExW
#else
#define ControlServiceEx  ControlServiceExA
#endif // !UNICODE

#endif // NTDDI_VERSION >= NTDDI_VISTA
    
#ifdef __cplusplus
}
#endif

#endif // _WINSVC_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WinSpool.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    WinSpool.h

Abstract:

    Header file for Print APIs

Revision History:

--*/

#ifndef _WINSPOOL_
#define _WINSPOOL_

#ifdef _WINUSER_
#include <prsht.h>
#endif


#ifndef OSVERSION_MASK

#define OSVERSION_MASK      0xFFFF0000
#define SPVERSION_MASK      0x0000FF00
#define SUBVERSION_MASK     0x000000FF

//
// macros to extract various version fields from the NTDDI version
//
//
// macros to extract various version fields from the NTDDI version
//
#define OSVER(Version) ((Version) & OSVERSION_MASK)

#define SPVER(Version) ( ((Version) & SPVERSION_MASK) >> 8)

#define SUBVER(Version) ( ((Version) & SUBVERSION_MASK) )

#endif   // OSVERSION_MASK

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _PRINTER_INFO_1A {
    DWORD   Flags;
    LPSTR   pDescription;
    LPSTR   pName;
    LPSTR   pComment;
} PRINTER_INFO_1A, *PPRINTER_INFO_1A, *LPPRINTER_INFO_1A;
typedef struct _PRINTER_INFO_1W {
    DWORD   Flags;
    LPWSTR  pDescription;
    LPWSTR  pName;
    LPWSTR  pComment;
} PRINTER_INFO_1W, *PPRINTER_INFO_1W, *LPPRINTER_INFO_1W;
#ifdef UNICODE
typedef PRINTER_INFO_1W PRINTER_INFO_1;
typedef PPRINTER_INFO_1W PPRINTER_INFO_1;
typedef LPPRINTER_INFO_1W LPPRINTER_INFO_1;
#else
typedef PRINTER_INFO_1A PRINTER_INFO_1;
typedef PPRINTER_INFO_1A PPRINTER_INFO_1;
typedef LPPRINTER_INFO_1A LPPRINTER_INFO_1;
#endif // UNICODE

typedef struct _PRINTER_INFO_2A {
    LPSTR     pServerName;
    LPSTR     pPrinterName;
    LPSTR     pShareName;
    LPSTR     pPortName;
    LPSTR     pDriverName;
    LPSTR     pComment;
    LPSTR     pLocation;
    LPDEVMODEA pDevMode;
    LPSTR     pSepFile;
    LPSTR     pPrintProcessor;
    LPSTR     pDatatype;
    LPSTR     pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD   Attributes;
    DWORD   Priority;
    DWORD   DefaultPriority;
    DWORD   StartTime;
    DWORD   UntilTime;
    DWORD   Status;
    DWORD   cJobs;
    DWORD   AveragePPM;
} PRINTER_INFO_2A, *PPRINTER_INFO_2A, *LPPRINTER_INFO_2A;
typedef struct _PRINTER_INFO_2W {
    LPWSTR    pServerName;
    LPWSTR    pPrinterName;
    LPWSTR    pShareName;
    LPWSTR    pPortName;
    LPWSTR    pDriverName;
    LPWSTR    pComment;
    LPWSTR    pLocation;
    LPDEVMODEW pDevMode;
    LPWSTR    pSepFile;
    LPWSTR    pPrintProcessor;
    LPWSTR    pDatatype;
    LPWSTR    pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD   Attributes;
    DWORD   Priority;
    DWORD   DefaultPriority;
    DWORD   StartTime;
    DWORD   UntilTime;
    DWORD   Status;
    DWORD   cJobs;
    DWORD   AveragePPM;
} PRINTER_INFO_2W, *PPRINTER_INFO_2W, *LPPRINTER_INFO_2W;
#ifdef UNICODE
typedef PRINTER_INFO_2W PRINTER_INFO_2;
typedef PPRINTER_INFO_2W PPRINTER_INFO_2;
typedef LPPRINTER_INFO_2W LPPRINTER_INFO_2;
#else
typedef PRINTER_INFO_2A PRINTER_INFO_2;
typedef PPRINTER_INFO_2A PPRINTER_INFO_2;
typedef LPPRINTER_INFO_2A LPPRINTER_INFO_2;
#endif // UNICODE

typedef struct _PRINTER_INFO_3 {
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
} PRINTER_INFO_3, *PPRINTER_INFO_3, *LPPRINTER_INFO_3;

typedef struct _PRINTER_INFO_4A {
    LPSTR   pPrinterName;
    LPSTR   pServerName;
    DWORD   Attributes;
} PRINTER_INFO_4A, *PPRINTER_INFO_4A, *LPPRINTER_INFO_4A;
typedef struct _PRINTER_INFO_4W {
    LPWSTR  pPrinterName;
    LPWSTR  pServerName;
    DWORD   Attributes;
} PRINTER_INFO_4W, *PPRINTER_INFO_4W, *LPPRINTER_INFO_4W;
#ifdef UNICODE
typedef PRINTER_INFO_4W PRINTER_INFO_4;
typedef PPRINTER_INFO_4W PPRINTER_INFO_4;
typedef LPPRINTER_INFO_4W LPPRINTER_INFO_4;
#else
typedef PRINTER_INFO_4A PRINTER_INFO_4;
typedef PPRINTER_INFO_4A PPRINTER_INFO_4;
typedef LPPRINTER_INFO_4A LPPRINTER_INFO_4;
#endif // UNICODE

typedef struct _PRINTER_INFO_5A {
    LPSTR   pPrinterName;
    LPSTR   pPortName;
    DWORD   Attributes;
    DWORD   DeviceNotSelectedTimeout;
    DWORD   TransmissionRetryTimeout;
} PRINTER_INFO_5A, *PPRINTER_INFO_5A, *LPPRINTER_INFO_5A;
typedef struct _PRINTER_INFO_5W {
    LPWSTR  pPrinterName;
    LPWSTR  pPortName;
    DWORD   Attributes;
    DWORD   DeviceNotSelectedTimeout;
    DWORD   TransmissionRetryTimeout;
} PRINTER_INFO_5W, *PPRINTER_INFO_5W, *LPPRINTER_INFO_5W;
#ifdef UNICODE
typedef PRINTER_INFO_5W PRINTER_INFO_5;
typedef PPRINTER_INFO_5W PPRINTER_INFO_5;
typedef LPPRINTER_INFO_5W LPPRINTER_INFO_5;
#else
typedef PRINTER_INFO_5A PRINTER_INFO_5;
typedef PPRINTER_INFO_5A PPRINTER_INFO_5;
typedef LPPRINTER_INFO_5A LPPRINTER_INFO_5;
#endif // UNICODE

typedef struct _PRINTER_INFO_6 {
    DWORD   dwStatus;
} PRINTER_INFO_6, *PPRINTER_INFO_6, *LPPRINTER_INFO_6;


typedef struct _PRINTER_INFO_7A {
  LPSTR    pszObjectGUID;
  DWORD    dwAction;
} PRINTER_INFO_7A, *PPRINTER_INFO_7A, *LPPRINTER_INFO_7A;
typedef struct _PRINTER_INFO_7W {
  LPWSTR   pszObjectGUID;
  DWORD    dwAction;
} PRINTER_INFO_7W, *PPRINTER_INFO_7W, *LPPRINTER_INFO_7W;
#ifdef UNICODE
typedef PRINTER_INFO_7W PRINTER_INFO_7;
typedef PPRINTER_INFO_7W PPRINTER_INFO_7;
typedef LPPRINTER_INFO_7W LPPRINTER_INFO_7;
#else
typedef PRINTER_INFO_7A PRINTER_INFO_7;
typedef PPRINTER_INFO_7A PPRINTER_INFO_7;
typedef LPPRINTER_INFO_7A LPPRINTER_INFO_7;
#endif // UNICODE

#define DSPRINT_PUBLISH         0x00000001
#define DSPRINT_UPDATE          0x00000002
#define DSPRINT_UNPUBLISH       0x00000004
#define DSPRINT_REPUBLISH       0x00000008
#define DSPRINT_PENDING         0x80000000

typedef struct _PRINTER_INFO_8A {
    LPDEVMODEA pDevMode;
} PRINTER_INFO_8A, *PPRINTER_INFO_8A, *LPPRINTER_INFO_8A;
typedef struct _PRINTER_INFO_8W {
    LPDEVMODEW pDevMode;
} PRINTER_INFO_8W, *PPRINTER_INFO_8W, *LPPRINTER_INFO_8W;
#ifdef UNICODE
typedef PRINTER_INFO_8W PRINTER_INFO_8;
typedef PPRINTER_INFO_8W PPRINTER_INFO_8;
typedef LPPRINTER_INFO_8W LPPRINTER_INFO_8;
#else
typedef PRINTER_INFO_8A PRINTER_INFO_8;
typedef PPRINTER_INFO_8A PPRINTER_INFO_8;
typedef LPPRINTER_INFO_8A LPPRINTER_INFO_8;
#endif // UNICODE

typedef struct _PRINTER_INFO_9A {
    LPDEVMODEA pDevMode;
} PRINTER_INFO_9A, *PPRINTER_INFO_9A, *LPPRINTER_INFO_9A;
typedef struct _PRINTER_INFO_9W {
    LPDEVMODEW pDevMode;
} PRINTER_INFO_9W, *PPRINTER_INFO_9W, *LPPRINTER_INFO_9W;
#ifdef UNICODE
typedef PRINTER_INFO_9W PRINTER_INFO_9;
typedef PPRINTER_INFO_9W PPRINTER_INFO_9;
typedef LPPRINTER_INFO_9W LPPRINTER_INFO_9;
#else
typedef PRINTER_INFO_9A PRINTER_INFO_9;
typedef PPRINTER_INFO_9A PPRINTER_INFO_9;
typedef LPPRINTER_INFO_9A LPPRINTER_INFO_9;
#endif // UNICODE

#define PRINTER_CONTROL_PAUSE            1
#define PRINTER_CONTROL_RESUME           2
#define PRINTER_CONTROL_PURGE            3
#define PRINTER_CONTROL_SET_STATUS       4

#define PRINTER_STATUS_PAUSED            0x00000001
#define PRINTER_STATUS_ERROR             0x00000002
#define PRINTER_STATUS_PENDING_DELETION  0x00000004
#define PRINTER_STATUS_PAPER_JAM         0x00000008
#define PRINTER_STATUS_PAPER_OUT         0x00000010
#define PRINTER_STATUS_MANUAL_FEED       0x00000020
#define PRINTER_STATUS_PAPER_PROBLEM     0x00000040
#define PRINTER_STATUS_OFFLINE           0x00000080
#define PRINTER_STATUS_IO_ACTIVE         0x00000100
#define PRINTER_STATUS_BUSY              0x00000200
#define PRINTER_STATUS_PRINTING          0x00000400
#define PRINTER_STATUS_OUTPUT_BIN_FULL   0x00000800
#define PRINTER_STATUS_NOT_AVAILABLE     0x00001000
#define PRINTER_STATUS_WAITING           0x00002000
#define PRINTER_STATUS_PROCESSING        0x00004000
#define PRINTER_STATUS_INITIALIZING      0x00008000
#define PRINTER_STATUS_WARMING_UP        0x00010000
#define PRINTER_STATUS_TONER_LOW         0x00020000
#define PRINTER_STATUS_NO_TONER          0x00040000
#define PRINTER_STATUS_PAGE_PUNT         0x00080000
#define PRINTER_STATUS_USER_INTERVENTION 0x00100000
#define PRINTER_STATUS_OUT_OF_MEMORY     0x00200000
#define PRINTER_STATUS_DOOR_OPEN         0x00400000
#define PRINTER_STATUS_SERVER_UNKNOWN    0x00800000
#define PRINTER_STATUS_POWER_SAVE        0x01000000
#define PRINTER_STATUS_SERVER_OFFLINE    0x02000000
#define PRINTER_STATUS_DRIVER_UPDATE_NEEDED    0x04000000

#define PRINTER_ATTRIBUTE_QUEUED         0x00000001
#define PRINTER_ATTRIBUTE_DIRECT         0x00000002
#define PRINTER_ATTRIBUTE_DEFAULT        0x00000004
#define PRINTER_ATTRIBUTE_SHARED         0x00000008
#define PRINTER_ATTRIBUTE_NETWORK        0x00000010
#define PRINTER_ATTRIBUTE_HIDDEN         0x00000020
#define PRINTER_ATTRIBUTE_LOCAL          0x00000040

#define PRINTER_ATTRIBUTE_ENABLE_DEVQ       0x00000080
#define PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS   0x00000100
#define PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST 0x00000200

#define PRINTER_ATTRIBUTE_WORK_OFFLINE      0x00000400
#define PRINTER_ATTRIBUTE_ENABLE_BIDI       0x00000800
#define PRINTER_ATTRIBUTE_RAW_ONLY          0x00001000
#define PRINTER_ATTRIBUTE_PUBLISHED         0x00002000

#if (NTDDI_VERSION >= NTDDI_WINXP)
    #define PRINTER_ATTRIBUTE_FAX           0x00004000
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#if ((NTDDI_VERSION >= NTDDI_WS03) ||\
     ((OSVER(NTDDI_VERSION) == NTDDI_WIN2K) && (SPVER(NTDDI_VERSION) >= 4)))
    #define PRINTER_ATTRIBUTE_TS            0x00008000
#endif // ((NTDDI_VERSION >= NTDDI_WS03) ||\ ...

#if (NTDDI_VERSION >= NTDDI_VISTA)

    //
    // The printer attribute pushed xxx bits below are used by the
    // pushing printer connection code to keep track of the type
    // of printer connection.  These bits are per user resources
    // hence the local print provider has no knowledge about these
    // bit and will not accepts them.  The remote print provider
    // is responsible for storeing and persisting these bits.
    //
    #define PRINTER_ATTRIBUTE_PUSHED_USER       0x00020000
    #define PRINTER_ATTRIBUTE_PUSHED_MACHINE    0x00040000
    #define PRINTER_ATTRIBUTE_MACHINE           0x00080000

    #define PRINTER_ATTRIBUTE_FRIENDLY_NAME     0x00100000

    //
    // If the redirected TS printer is installed with generic
    // TS printer driver (TSPRINT.dll) then this attribute is set
    // by the UMRDP service and passed on to the spooler
    //
    #define PRINTER_ATTRIBUTE_TS_GENERIC_DRIVER 0x00200000

#endif // (NTDDI_VERSION >= NTDDI_VISTA)


#define NO_PRIORITY   0
#define MAX_PRIORITY 99
#define MIN_PRIORITY  1
#define DEF_PRIORITY  1

typedef struct _JOB_INFO_1A {
   DWORD    JobId;
   LPSTR      pPrinterName;
   LPSTR      pMachineName;
   LPSTR      pUserName;
   LPSTR      pDocument;
   LPSTR      pDatatype;
   LPSTR      pStatus;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    TotalPages;
   DWORD    PagesPrinted;
   SYSTEMTIME Submitted;
} JOB_INFO_1A, *PJOB_INFO_1A, *LPJOB_INFO_1A;
typedef struct _JOB_INFO_1W {
   DWORD    JobId;
   LPWSTR     pPrinterName;
   LPWSTR     pMachineName;
   LPWSTR     pUserName;
   LPWSTR     pDocument;
   LPWSTR     pDatatype;
   LPWSTR     pStatus;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    TotalPages;
   DWORD    PagesPrinted;
   SYSTEMTIME Submitted;
} JOB_INFO_1W, *PJOB_INFO_1W, *LPJOB_INFO_1W;
#ifdef UNICODE
typedef JOB_INFO_1W JOB_INFO_1;
typedef PJOB_INFO_1W PJOB_INFO_1;
typedef LPJOB_INFO_1W LPJOB_INFO_1;
#else
typedef JOB_INFO_1A JOB_INFO_1;
typedef PJOB_INFO_1A PJOB_INFO_1;
typedef LPJOB_INFO_1A LPJOB_INFO_1;
#endif // UNICODE

typedef struct _JOB_INFO_2A {
   DWORD    JobId;
   LPSTR      pPrinterName;
   LPSTR      pMachineName;
   LPSTR      pUserName;
   LPSTR      pDocument;
   LPSTR      pNotifyName;
   LPSTR      pDatatype;
   LPSTR      pPrintProcessor;
   LPSTR      pParameters;
   LPSTR      pDriverName;
   LPDEVMODEA pDevMode;
   LPSTR      pStatus;
   PSECURITY_DESCRIPTOR pSecurityDescriptor;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    StartTime;
   DWORD    UntilTime;
   DWORD    TotalPages;
   DWORD    Size;
   SYSTEMTIME Submitted;    // Time the job was spooled
   DWORD    Time;           // How many miliseconds the job has been printing
   DWORD    PagesPrinted;
} JOB_INFO_2A, *PJOB_INFO_2A, *LPJOB_INFO_2A;
typedef struct _JOB_INFO_2W {
   DWORD    JobId;
   LPWSTR     pPrinterName;
   LPWSTR     pMachineName;
   LPWSTR     pUserName;
   LPWSTR     pDocument;
   LPWSTR     pNotifyName;
   LPWSTR     pDatatype;
   LPWSTR     pPrintProcessor;
   LPWSTR     pParameters;
   LPWSTR     pDriverName;
   LPDEVMODEW pDevMode;
   LPWSTR     pStatus;
   PSECURITY_DESCRIPTOR pSecurityDescriptor;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    StartTime;
   DWORD    UntilTime;
   DWORD    TotalPages;
   DWORD    Size;
   SYSTEMTIME Submitted;    // Time the job was spooled
   DWORD    Time;           // How many miliseconds the job has been printing
   DWORD    PagesPrinted;
} JOB_INFO_2W, *PJOB_INFO_2W, *LPJOB_INFO_2W;
#ifdef UNICODE
typedef JOB_INFO_2W JOB_INFO_2;
typedef PJOB_INFO_2W PJOB_INFO_2;
typedef LPJOB_INFO_2W LPJOB_INFO_2;
#else
typedef JOB_INFO_2A JOB_INFO_2;
typedef PJOB_INFO_2A PJOB_INFO_2;
typedef LPJOB_INFO_2A LPJOB_INFO_2;
#endif // UNICODE

typedef struct _JOB_INFO_3 {
    DWORD   JobId;
    DWORD   NextJobId;
    DWORD   Reserved;
} JOB_INFO_3, *PJOB_INFO_3, *LPJOB_INFO_3;

typedef struct _JOB_INFO_4A {
   DWORD          JobId;
   LPSTR          pPrinterName;
   LPSTR          pMachineName;
   LPSTR          pUserName;
   LPSTR          pDocument;
   LPSTR          pNotifyName;
   LPSTR          pDatatype;
   LPSTR          pPrintProcessor;
   LPSTR          pParameters;
   LPSTR          pDriverName;
   LPDEVMODEA     pDevMode;
   LPSTR          pStatus;
   PSECURITY_DESCRIPTOR pSecurityDescriptor;
   DWORD          Status;
   DWORD          Priority;
   DWORD          Position;
   DWORD          StartTime;
   DWORD          UntilTime;
   DWORD          TotalPages;
   DWORD          Size;
   SYSTEMTIME     Submitted;
   DWORD          Time;
   DWORD          PagesPrinted;
   LONG           SizeHigh;
} JOB_INFO_4A, *PJOB_INFO_4A, *LPJOB_INFO_4A;
typedef struct _JOB_INFO_4W {
   DWORD          JobId;
   LPWSTR         pPrinterName;
   LPWSTR         pMachineName;
   LPWSTR         pUserName;
   LPWSTR         pDocument;
   LPWSTR         pNotifyName;
   LPWSTR         pDatatype;
   LPWSTR         pPrintProcessor;
   LPWSTR         pParameters;
   LPWSTR         pDriverName;
   LPDEVMODEW     pDevMode;
   LPWSTR         pStatus;
   PSECURITY_DESCRIPTOR pSecurityDescriptor;
   DWORD          Status;
   DWORD          Priority;
   DWORD          Position;
   DWORD          StartTime;
   DWORD          UntilTime;
   DWORD          TotalPages;
   DWORD          Size;
   SYSTEMTIME     Submitted;
   DWORD          Time;
   DWORD          PagesPrinted;
   LONG           SizeHigh;
} JOB_INFO_4W, *PJOB_INFO_4W, *LPJOB_INFO_4W;
#ifdef UNICODE
typedef JOB_INFO_4W JOB_INFO_4;
typedef PJOB_INFO_4W PJOB_INFO_4;
typedef LPJOB_INFO_4W LPJOB_INFO_4;
#else
typedef JOB_INFO_4A JOB_INFO_4;
typedef PJOB_INFO_4A PJOB_INFO_4;
typedef LPJOB_INFO_4A LPJOB_INFO_4;
#endif // UNICODE

#define JOB_CONTROL_PAUSE              1
#define JOB_CONTROL_RESUME             2
#define JOB_CONTROL_CANCEL             3
#define JOB_CONTROL_RESTART            4
#define JOB_CONTROL_DELETE             5
#define JOB_CONTROL_SENT_TO_PRINTER    6
#define JOB_CONTROL_LAST_PAGE_EJECTED  7

#if (NTDDI_VERSION >= NTDDI_VISTA)
    #define JOB_CONTROL_RETAIN         8
    #define JOB_CONTROL_RELEASE        9
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define JOB_STATUS_PAUSED               0x00000001
#define JOB_STATUS_ERROR                0x00000002
#define JOB_STATUS_DELETING             0x00000004
#define JOB_STATUS_SPOOLING             0x00000008
#define JOB_STATUS_PRINTING             0x00000010
#define JOB_STATUS_OFFLINE              0x00000020
#define JOB_STATUS_PAPEROUT             0x00000040
#define JOB_STATUS_PRINTED              0x00000080
#define JOB_STATUS_DELETED              0x00000100
#define JOB_STATUS_BLOCKED_DEVQ         0x00000200
#define JOB_STATUS_USER_INTERVENTION    0x00000400
#define JOB_STATUS_RESTART              0x00000800

#if (NTDDI_VERSION >= NTDDI_WINXP)
    #define JOB_STATUS_COMPLETE         0x00001000
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION >= NTDDI_VISTA)
    #define JOB_STATUS_RETAINED             0x00002000
    #define JOB_STATUS_RENDERING_LOCALLY    0x00004000
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define JOB_POSITION_UNSPECIFIED       0

typedef struct _ADDJOB_INFO_1A {
    LPSTR     Path;
    DWORD   JobId;
} ADDJOB_INFO_1A, *PADDJOB_INFO_1A, *LPADDJOB_INFO_1A;
typedef struct _ADDJOB_INFO_1W {
    LPWSTR    Path;
    DWORD   JobId;
} ADDJOB_INFO_1W, *PADDJOB_INFO_1W, *LPADDJOB_INFO_1W;
#ifdef UNICODE
typedef ADDJOB_INFO_1W ADDJOB_INFO_1;
typedef PADDJOB_INFO_1W PADDJOB_INFO_1;
typedef LPADDJOB_INFO_1W LPADDJOB_INFO_1;
#else
typedef ADDJOB_INFO_1A ADDJOB_INFO_1;
typedef PADDJOB_INFO_1A PADDJOB_INFO_1;
typedef LPADDJOB_INFO_1A LPADDJOB_INFO_1;
#endif // UNICODE


typedef struct _DRIVER_INFO_1A {
    LPSTR     pName;              // QMS 810
} DRIVER_INFO_1A, *PDRIVER_INFO_1A, *LPDRIVER_INFO_1A;
typedef struct _DRIVER_INFO_1W {
    LPWSTR    pName;              // QMS 810
} DRIVER_INFO_1W, *PDRIVER_INFO_1W, *LPDRIVER_INFO_1W;
#ifdef UNICODE
typedef DRIVER_INFO_1W DRIVER_INFO_1;
typedef PDRIVER_INFO_1W PDRIVER_INFO_1;
typedef LPDRIVER_INFO_1W LPDRIVER_INFO_1;
#else
typedef DRIVER_INFO_1A DRIVER_INFO_1;
typedef PDRIVER_INFO_1A PDRIVER_INFO_1;
typedef LPDRIVER_INFO_1A LPDRIVER_INFO_1;
#endif // UNICODE

typedef struct _DRIVER_INFO_2A {
    DWORD   cVersion;
    LPSTR     pName;              // QMS 810
    LPSTR     pEnvironment;       // Win32 x86
    LPSTR     pDriverPath;        // c:\drivers\pscript.dll
    LPSTR     pDataFile;          // c:\drivers\QMS810.PPD
    LPSTR     pConfigFile;        // c:\drivers\PSCRPTUI.DLL
} DRIVER_INFO_2A, *PDRIVER_INFO_2A, *LPDRIVER_INFO_2A;
typedef struct _DRIVER_INFO_2W {
    DWORD   cVersion;
    LPWSTR    pName;              // QMS 810
    LPWSTR    pEnvironment;       // Win32 x86
    LPWSTR    pDriverPath;        // c:\drivers\pscript.dll
    LPWSTR    pDataFile;          // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;        // c:\drivers\PSCRPTUI.DLL
} DRIVER_INFO_2W, *PDRIVER_INFO_2W, *LPDRIVER_INFO_2W;
#ifdef UNICODE
typedef DRIVER_INFO_2W DRIVER_INFO_2;
typedef PDRIVER_INFO_2W PDRIVER_INFO_2;
typedef LPDRIVER_INFO_2W LPDRIVER_INFO_2;
#else
typedef DRIVER_INFO_2A DRIVER_INFO_2;
typedef PDRIVER_INFO_2A PDRIVER_INFO_2;
typedef LPDRIVER_INFO_2A LPDRIVER_INFO_2;
#endif // UNICODE

typedef struct _DRIVER_INFO_3A {
    DWORD   cVersion;
    LPSTR     pName;                    // QMS 810
    LPSTR     pEnvironment;             // Win32 x86
    LPSTR     pDriverPath;              // c:\drivers\pscript.dll
    LPSTR     pDataFile;                // c:\drivers\QMS810.PPD
    LPSTR     pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    LPSTR     pHelpFile;                // c:\drivers\PSCRPTUI.HLP
    LPSTR     pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0
    LPSTR     pMonitorName;             // "PJL monitor"
    LPSTR     pDefaultDataType;         // "EMF"
} DRIVER_INFO_3A, *PDRIVER_INFO_3A, *LPDRIVER_INFO_3A;
typedef struct _DRIVER_INFO_3W {
    DWORD   cVersion;
    LPWSTR    pName;                    // QMS 810
    LPWSTR    pEnvironment;             // Win32 x86
    LPWSTR    pDriverPath;              // c:\drivers\pscript.dll
    LPWSTR    pDataFile;                // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    LPWSTR    pHelpFile;                // c:\drivers\PSCRPTUI.HLP
    LPWSTR    pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0
    LPWSTR    pMonitorName;             // "PJL monitor"
    LPWSTR    pDefaultDataType;         // "EMF"
} DRIVER_INFO_3W, *PDRIVER_INFO_3W, *LPDRIVER_INFO_3W;
#ifdef UNICODE
typedef DRIVER_INFO_3W DRIVER_INFO_3;
typedef PDRIVER_INFO_3W PDRIVER_INFO_3;
typedef LPDRIVER_INFO_3W LPDRIVER_INFO_3;
#else
typedef DRIVER_INFO_3A DRIVER_INFO_3;
typedef PDRIVER_INFO_3A PDRIVER_INFO_3;
typedef LPDRIVER_INFO_3A LPDRIVER_INFO_3;
#endif // UNICODE

typedef struct _DRIVER_INFO_4A {
    DWORD   cVersion;
    LPSTR     pName;                    // QMS 810
    LPSTR     pEnvironment;             // Win32 x86
    LPSTR     pDriverPath;              // c:\drivers\pscript.dll
    LPSTR     pDataFile;                // c:\drivers\QMS810.PPD
    LPSTR     pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    LPSTR     pHelpFile;                // c:\drivers\PSCRPTUI.HLP
    LPSTR     pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0
    LPSTR     pMonitorName;             // "PJL monitor"
    LPSTR     pDefaultDataType;         // "EMF"
    LPSTR     pszzPreviousNames;        // "OldName1\0OldName2\0\0
} DRIVER_INFO_4A, *PDRIVER_INFO_4A, *LPDRIVER_INFO_4A;
typedef struct _DRIVER_INFO_4W {
    DWORD   cVersion;
    LPWSTR    pName;                    // QMS 810
    LPWSTR    pEnvironment;             // Win32 x86
    LPWSTR    pDriverPath;              // c:\drivers\pscript.dll
    LPWSTR    pDataFile;                // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    LPWSTR    pHelpFile;                // c:\drivers\PSCRPTUI.HLP
    LPWSTR    pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0
    LPWSTR    pMonitorName;             // "PJL monitor"
    LPWSTR    pDefaultDataType;         // "EMF"
    LPWSTR    pszzPreviousNames;        // "OldName1\0OldName2\0\0
} DRIVER_INFO_4W, *PDRIVER_INFO_4W, *LPDRIVER_INFO_4W;
#ifdef UNICODE
typedef DRIVER_INFO_4W DRIVER_INFO_4;
typedef PDRIVER_INFO_4W PDRIVER_INFO_4;
typedef LPDRIVER_INFO_4W LPDRIVER_INFO_4;
#else
typedef DRIVER_INFO_4A DRIVER_INFO_4;
typedef PDRIVER_INFO_4A PDRIVER_INFO_4;
typedef LPDRIVER_INFO_4A LPDRIVER_INFO_4;
#endif // UNICODE

typedef struct _DRIVER_INFO_5A {
    DWORD   cVersion;
    LPSTR     pName;                    // QMS 810
    LPSTR     pEnvironment;             // Win32 x86
    LPSTR     pDriverPath;              // c:\drivers\pscript.dll
    LPSTR     pDataFile;                // c:\drivers\QMS810.PPD
    LPSTR     pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    DWORD     dwDriverAttributes;       // driver attributes (like UMPD/KMPD)
    DWORD     dwConfigVersion;          // version number of the config file since reboot
    DWORD     dwDriverVersion;          // version number of the driver file since reboot
} DRIVER_INFO_5A, *PDRIVER_INFO_5A, *LPDRIVER_INFO_5A;
typedef struct _DRIVER_INFO_5W {
    DWORD   cVersion;
    LPWSTR    pName;                    // QMS 810
    LPWSTR    pEnvironment;             // Win32 x86
    LPWSTR    pDriverPath;              // c:\drivers\pscript.dll
    LPWSTR    pDataFile;                // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    DWORD     dwDriverAttributes;       // driver attributes (like UMPD/KMPD)
    DWORD     dwConfigVersion;          // version number of the config file since reboot
    DWORD     dwDriverVersion;          // version number of the driver file since reboot
} DRIVER_INFO_5W, *PDRIVER_INFO_5W, *LPDRIVER_INFO_5W;
#ifdef UNICODE
typedef DRIVER_INFO_5W DRIVER_INFO_5;
typedef PDRIVER_INFO_5W PDRIVER_INFO_5;
typedef LPDRIVER_INFO_5W LPDRIVER_INFO_5;
#else
typedef DRIVER_INFO_5A DRIVER_INFO_5;
typedef PDRIVER_INFO_5A PDRIVER_INFO_5;
typedef LPDRIVER_INFO_5A LPDRIVER_INFO_5;
#endif // UNICODE

typedef struct _DRIVER_INFO_6A {
    DWORD     cVersion;
    LPSTR     pName;                    // QMS 810
    LPSTR     pEnvironment;             // Win32 x86
    LPSTR     pDriverPath;              // c:\drivers\pscript.dll
    LPSTR     pDataFile;                // c:\drivers\QMS810.PPD
    LPSTR     pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    LPSTR     pHelpFile;                // c:\drivers\PSCRPTUI.HLP
    LPSTR     pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0
    LPSTR     pMonitorName;             // "PJL monitor"
    LPSTR     pDefaultDataType;         // "EMF"
    LPSTR     pszzPreviousNames;        // "OldName1\0OldName2\0\0
    FILETIME  ftDriverDate;
    DWORDLONG dwlDriverVersion;
    LPSTR      pszMfgName;
    LPSTR      pszOEMUrl;
    LPSTR      pszHardwareID;
    LPSTR      pszProvider;
} DRIVER_INFO_6A, *PDRIVER_INFO_6A, *LPDRIVER_INFO_6A;
typedef struct _DRIVER_INFO_6W {
    DWORD     cVersion;
    LPWSTR    pName;                    // QMS 810
    LPWSTR    pEnvironment;             // Win32 x86
    LPWSTR    pDriverPath;              // c:\drivers\pscript.dll
    LPWSTR    pDataFile;                // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    LPWSTR    pHelpFile;                // c:\drivers\PSCRPTUI.HLP
    LPWSTR    pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0
    LPWSTR    pMonitorName;             // "PJL monitor"
    LPWSTR    pDefaultDataType;         // "EMF"
    LPWSTR    pszzPreviousNames;        // "OldName1\0OldName2\0\0
    FILETIME  ftDriverDate;
    DWORDLONG dwlDriverVersion;
    LPWSTR     pszMfgName;
    LPWSTR     pszOEMUrl;
    LPWSTR     pszHardwareID;
    LPWSTR     pszProvider;
} DRIVER_INFO_6W, *PDRIVER_INFO_6W, *LPDRIVER_INFO_6W;
#ifdef UNICODE
typedef DRIVER_INFO_6W DRIVER_INFO_6;
typedef PDRIVER_INFO_6W PDRIVER_INFO_6;
typedef LPDRIVER_INFO_6W LPDRIVER_INFO_6;
#else
typedef DRIVER_INFO_6A DRIVER_INFO_6;
typedef PDRIVER_INFO_6A PDRIVER_INFO_6;
typedef LPDRIVER_INFO_6A LPDRIVER_INFO_6;
#endif // UNICODE

#define PRINTER_DRIVER_PACKAGE_AWARE    0x00000001
#define PRINTER_DRIVER_SANDBOX_ENABLED  0x00000004

typedef struct _DRIVER_INFO_8A {
    DWORD      cVersion;
    LPSTR      pName;                    // QMS 810
    LPSTR      pEnvironment;             // Win32 x86
    LPSTR      pDriverPath;              // c:\drivers\pscript.dll
    LPSTR      pDataFile;                // c:\drivers\QMS810.PPD
    LPSTR      pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    LPSTR      pHelpFile;                // c:\drivers\PSCRPTUI.HLP
    LPSTR      pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0
    LPSTR      pMonitorName;             // "PJL monitor"
    LPSTR      pDefaultDataType;         // "EMF"
    LPSTR      pszzPreviousNames;        // "OldName1\0OldName2\0\0
    FILETIME   ftDriverDate;
    DWORDLONG  dwlDriverVersion;
    LPSTR      pszMfgName;
    LPSTR      pszOEMUrl;
    LPSTR      pszHardwareID;
    LPSTR      pszProvider;
    LPSTR      pszPrintProcessor;
    LPSTR      pszVendorSetup;
    LPSTR      pszzColorProfiles;
    LPSTR      pszInfPath;
    DWORD      dwPrinterDriverAttributes;
    LPSTR      pszzCoreDriverDependencies;
    FILETIME   ftMinInboxDriverVerDate;
    DWORDLONG  dwlMinInboxDriverVerVersion;
} DRIVER_INFO_8A, *PDRIVER_INFO_8A, *LPDRIVER_INFO_8A;
typedef struct _DRIVER_INFO_8W {
    DWORD      cVersion;
    LPWSTR     pName;                    // QMS 810
    LPWSTR     pEnvironment;             // Win32 x86
    LPWSTR     pDriverPath;              // c:\drivers\pscript.dll
    LPWSTR     pDataFile;                // c:\drivers\QMS810.PPD
    LPWSTR     pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    LPWSTR     pHelpFile;                // c:\drivers\PSCRPTUI.HLP
    LPWSTR     pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0
    LPWSTR     pMonitorName;             // "PJL monitor"
    LPWSTR     pDefaultDataType;         // "EMF"
    LPWSTR     pszzPreviousNames;        // "OldName1\0OldName2\0\0
    FILETIME   ftDriverDate;
    DWORDLONG  dwlDriverVersion;
    LPWSTR     pszMfgName;
    LPWSTR     pszOEMUrl;
    LPWSTR     pszHardwareID;
    LPWSTR     pszProvider;
    LPWSTR     pszPrintProcessor;
    LPWSTR     pszVendorSetup;
    LPWSTR     pszzColorProfiles;
    LPWSTR     pszInfPath;
    DWORD      dwPrinterDriverAttributes;
    LPWSTR     pszzCoreDriverDependencies;
    FILETIME   ftMinInboxDriverVerDate;
    DWORDLONG  dwlMinInboxDriverVerVersion;
} DRIVER_INFO_8W, *PDRIVER_INFO_8W, *LPDRIVER_INFO_8W;
#ifdef UNICODE
typedef DRIVER_INFO_8W DRIVER_INFO_8;
typedef PDRIVER_INFO_8W PDRIVER_INFO_8;
typedef LPDRIVER_INFO_8W LPDRIVER_INFO_8;
#else
typedef DRIVER_INFO_8A DRIVER_INFO_8;
typedef PDRIVER_INFO_8A PDRIVER_INFO_8;
typedef LPDRIVER_INFO_8A LPDRIVER_INFO_8;
#endif // UNICODE


// FLAGS for dwDriverAttributes
#define DRIVER_KERNELMODE                0x00000001
#define DRIVER_USERMODE                  0x00000002

// FLAGS for DeletePrinterDriverEx.
#define DPD_DELETE_UNUSED_FILES          0x00000001
#define DPD_DELETE_SPECIFIC_VERSION      0x00000002
#define DPD_DELETE_ALL_FILES             0x00000004

// FLAGS for AddPrinterDriverEx.
#define APD_STRICT_UPGRADE               0x00000001
#define APD_STRICT_DOWNGRADE             0x00000002
#define APD_COPY_ALL_FILES               0x00000004
#define APD_COPY_NEW_FILES               0x00000008

#if (NTDDI_VERSION >= NTDDI_WINXP)
    #define APD_COPY_FROM_DIRECTORY      0x00000010
#endif // (NTDDI_VERSION >= NTDDI_WINXP)


// String for EnumPrinterDrivers. Used by Windows Update

typedef struct _DOC_INFO_1A {
    LPSTR     pDocName;
    LPSTR     pOutputFile;
    LPSTR     pDatatype;
} DOC_INFO_1A, *PDOC_INFO_1A, *LPDOC_INFO_1A;
typedef struct _DOC_INFO_1W {
    LPWSTR    pDocName;
    LPWSTR    pOutputFile;
    LPWSTR    pDatatype;
} DOC_INFO_1W, *PDOC_INFO_1W, *LPDOC_INFO_1W;
#ifdef UNICODE
typedef DOC_INFO_1W DOC_INFO_1;
typedef PDOC_INFO_1W PDOC_INFO_1;
typedef LPDOC_INFO_1W LPDOC_INFO_1;
#else
typedef DOC_INFO_1A DOC_INFO_1;
typedef PDOC_INFO_1A PDOC_INFO_1;
typedef LPDOC_INFO_1A LPDOC_INFO_1;
#endif // UNICODE

typedef struct _FORM_INFO_1A {
    DWORD   Flags;
    LPSTR     pName;
    SIZEL   Size;
    RECTL   ImageableArea;
} FORM_INFO_1A, *PFORM_INFO_1A, *LPFORM_INFO_1A;
typedef struct _FORM_INFO_1W {
    DWORD   Flags;
    LPWSTR    pName;
    SIZEL   Size;
    RECTL   ImageableArea;
} FORM_INFO_1W, *PFORM_INFO_1W, *LPFORM_INFO_1W;
#ifdef UNICODE
typedef FORM_INFO_1W FORM_INFO_1;
typedef PFORM_INFO_1W PFORM_INFO_1;
typedef LPFORM_INFO_1W LPFORM_INFO_1;
#else
typedef FORM_INFO_1A FORM_INFO_1;
typedef PFORM_INFO_1A PFORM_INFO_1;
typedef LPFORM_INFO_1A LPFORM_INFO_1;
#endif // UNICODE

#if (NTDDI_VERSION >= NTDDI_VISTA)
    #define  STRING_NONE     0x00000001
    #define  STRING_MUIDLL   0x00000002
    #define  STRING_LANGPAIR 0x00000004

    #define MAX_FORM_KEYWORD_LENGTH 63+1

    typedef struct _FORM_INFO_2A {
        DWORD           Flags;
        LPCSTR          pName;
        SIZEL           Size;
        RECTL           ImageableArea;
        LPCSTR          pKeyword;
        DWORD           StringType;
        LPCSTR          pMuiDll;
        DWORD           dwResourceId;
        LPCSTR          pDisplayName;
        LANGID          wLangId;
    } FORM_INFO_2A, *PFORM_INFO_2A, *LPFORM_INFO_2A;
    typedef struct _FORM_INFO_2W {
        DWORD           Flags;
        LPCWSTR         pName;
        SIZEL           Size;
        RECTL           ImageableArea;
        LPCSTR          pKeyword;
        DWORD           StringType;
        LPCWSTR         pMuiDll;
        DWORD           dwResourceId;
        LPCWSTR         pDisplayName;
        LANGID          wLangId;
    } FORM_INFO_2W, *PFORM_INFO_2W, *LPFORM_INFO_2W;
#ifdef UNICODE
typedef FORM_INFO_2W FORM_INFO_2;
typedef PFORM_INFO_2W PFORM_INFO_2;
typedef LPFORM_INFO_2W LPFORM_INFO_2;
#else
typedef FORM_INFO_2A FORM_INFO_2;
typedef PFORM_INFO_2A PFORM_INFO_2;
typedef LPFORM_INFO_2A LPFORM_INFO_2;
#endif // UNICODE
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

typedef struct _DOC_INFO_2A {
    LPSTR     pDocName;
    LPSTR     pOutputFile;
    LPSTR     pDatatype;
    DWORD   dwMode;
    DWORD   JobId;
} DOC_INFO_2A, *PDOC_INFO_2A, *LPDOC_INFO_2A;
typedef struct _DOC_INFO_2W {
    LPWSTR    pDocName;
    LPWSTR    pOutputFile;
    LPWSTR    pDatatype;
    DWORD   dwMode;
    DWORD   JobId;
} DOC_INFO_2W, *PDOC_INFO_2W, *LPDOC_INFO_2W;
#ifdef UNICODE
typedef DOC_INFO_2W DOC_INFO_2;
typedef PDOC_INFO_2W PDOC_INFO_2;
typedef LPDOC_INFO_2W LPDOC_INFO_2;
#else
typedef DOC_INFO_2A DOC_INFO_2;
typedef PDOC_INFO_2A PDOC_INFO_2;
typedef LPDOC_INFO_2A LPDOC_INFO_2;
#endif // UNICODE

#define DI_CHANNEL              1    // start direct read/write channel,


#define DI_READ_SPOOL_JOB       3

typedef struct _DOC_INFO_3A {
    LPSTR     pDocName;
    LPSTR     pOutputFile;
    LPSTR     pDatatype;
    DWORD     dwFlags;
} DOC_INFO_3A, *PDOC_INFO_3A, *LPDOC_INFO_3A;
typedef struct _DOC_INFO_3W {
    LPWSTR    pDocName;
    LPWSTR    pOutputFile;
    LPWSTR    pDatatype;
    DWORD     dwFlags;
} DOC_INFO_3W, *PDOC_INFO_3W, *LPDOC_INFO_3W;
#ifdef UNICODE
typedef DOC_INFO_3W DOC_INFO_3;
typedef PDOC_INFO_3W PDOC_INFO_3;
typedef LPDOC_INFO_3W LPDOC_INFO_3;
#else
typedef DOC_INFO_3A DOC_INFO_3;
typedef PDOC_INFO_3A PDOC_INFO_3;
typedef LPDOC_INFO_3A LPDOC_INFO_3;
#endif // UNICODE

#define DI_MEMORYMAP_WRITE   0x00000001

#define FORM_USER       0x00000000
#define FORM_BUILTIN    0x00000001
#define FORM_PRINTER    0x00000002

typedef struct _PRINTPROCESSOR_INFO_1A {
    LPSTR     pName;
} PRINTPROCESSOR_INFO_1A, *PPRINTPROCESSOR_INFO_1A, *LPPRINTPROCESSOR_INFO_1A;
typedef struct _PRINTPROCESSOR_INFO_1W {
    LPWSTR    pName;
} PRINTPROCESSOR_INFO_1W, *PPRINTPROCESSOR_INFO_1W, *LPPRINTPROCESSOR_INFO_1W;
#ifdef UNICODE
typedef PRINTPROCESSOR_INFO_1W PRINTPROCESSOR_INFO_1;
typedef PPRINTPROCESSOR_INFO_1W PPRINTPROCESSOR_INFO_1;
typedef LPPRINTPROCESSOR_INFO_1W LPPRINTPROCESSOR_INFO_1;
#else
typedef PRINTPROCESSOR_INFO_1A PRINTPROCESSOR_INFO_1;
typedef PPRINTPROCESSOR_INFO_1A PPRINTPROCESSOR_INFO_1;
typedef LPPRINTPROCESSOR_INFO_1A LPPRINTPROCESSOR_INFO_1;
#endif // UNICODE

#if (NTDDI_VERSION >= NTDDI_WINXP)
    typedef struct _PRINTPROCESSOR_CAPS_1 {
        DWORD     dwLevel;
        DWORD     dwNupOptions;
        DWORD     dwPageOrderFlags;
        DWORD     dwNumberOfCopies;
    } PRINTPROCESSOR_CAPS_1, *PPRINTPROCESSOR_CAPS_1;

    #define NORMAL_PRINT                   ( 0x00000000 )
    #define REVERSE_PRINT                  ( 0x00000001 )
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION >= NTDDI_VISTA)
    typedef struct _PRINTPROCESSOR_CAPS_2 {
        DWORD     dwLevel;
        DWORD     dwNupOptions;
        DWORD     dwPageOrderFlags;
        DWORD     dwNumberOfCopies;

        // _PRINTPROCESSOR_CAPS_2 specific fields.
        DWORD     dwDuplexHandlingCaps;
        DWORD     dwNupDirectionCaps;
        DWORD     dwNupBorderCaps;
        DWORD     dwBookletHandlingCaps;
        DWORD     dwScalingCaps;

    } PRINTPROCESSOR_CAPS_2, *PPRINTPROCESSOR_CAPS_2;

    //Flags for dwNupDirectionCaps.
    #define PPCAPS_RIGHT_THEN_DOWN                  ( 0x00000001      ) // 0x00000001
    #define PPCAPS_DOWN_THEN_RIGHT                  ( 0x00000001 << 1 ) // 0x00000002
    #define PPCAPS_LEFT_THEN_DOWN                   ( 0x00000001 << 2 ) // 0x00000004
    #define PPCAPS_DOWN_THEN_LEFT                   ( 0x00000001 << 3 ) // 0x00000008

    //dwNupBorderCaps
    #define PPCAPS_BORDER_PRINT                     ( 0x00000001 )      // 0x00000001

    //dwBookletHandlingCaps
    #define PPCAPS_BOOKLET_EDGE                     ( 0x00000001 )

    //dwDuplexHandlingCaps
    // The below flag tells that print processor can flip page order within sheet
    // while printing reverse duplex.
    // e.g. Instead of playing pages in order 4,3,2,1, print processor can play them 3,4,1,2
    #define PPCAPS_REVERSE_PAGES_FOR_REVERSE_DUPLEX  ( 0x00000001      )
    #define PPCAPS_DONT_SEND_EXTRA_PAGES_FOR_DUPLEX  ( 0x00000001 << 1 )

    //dwScalingCaps
    #define PPCAPS_SQUARE_SCALING                   ( 0x00000001 )


#endif // (NTDDI_VERSION >= NTDDI_VISTA)

typedef struct _PORT_INFO_1A {
    LPSTR     pName;
} PORT_INFO_1A, *PPORT_INFO_1A, *LPPORT_INFO_1A;
typedef struct _PORT_INFO_1W {
    LPWSTR    pName;
} PORT_INFO_1W, *PPORT_INFO_1W, *LPPORT_INFO_1W;
#ifdef UNICODE
typedef PORT_INFO_1W PORT_INFO_1;
typedef PPORT_INFO_1W PPORT_INFO_1;
typedef LPPORT_INFO_1W LPPORT_INFO_1;
#else
typedef PORT_INFO_1A PORT_INFO_1;
typedef PPORT_INFO_1A PPORT_INFO_1;
typedef LPPORT_INFO_1A LPPORT_INFO_1;
#endif // UNICODE

typedef struct _PORT_INFO_2A {
    LPSTR     pPortName;
    LPSTR     pMonitorName;
    LPSTR     pDescription;
    DWORD     fPortType;
    DWORD     Reserved;
} PORT_INFO_2A, *PPORT_INFO_2A, *LPPORT_INFO_2A;
typedef struct _PORT_INFO_2W {
    LPWSTR    pPortName;
    LPWSTR    pMonitorName;
    LPWSTR    pDescription;
    DWORD     fPortType;
    DWORD     Reserved;
} PORT_INFO_2W, *PPORT_INFO_2W, *LPPORT_INFO_2W;
#ifdef UNICODE
typedef PORT_INFO_2W PORT_INFO_2;
typedef PPORT_INFO_2W PPORT_INFO_2;
typedef LPPORT_INFO_2W LPPORT_INFO_2;
#else
typedef PORT_INFO_2A PORT_INFO_2;
typedef PPORT_INFO_2A PPORT_INFO_2;
typedef LPPORT_INFO_2A LPPORT_INFO_2;
#endif // UNICODE

#define PORT_TYPE_WRITE         0x0001
#define PORT_TYPE_READ          0x0002
#define PORT_TYPE_REDIRECTED    0x0004
#define PORT_TYPE_NET_ATTACHED  0x0008

typedef struct _PORT_INFO_3A {
    DWORD   dwStatus;
    LPSTR   pszStatus;
    DWORD   dwSeverity;
} PORT_INFO_3A, *PPORT_INFO_3A, *LPPORT_INFO_3A;
typedef struct _PORT_INFO_3W {
    DWORD   dwStatus;
    LPWSTR  pszStatus;
    DWORD   dwSeverity;
} PORT_INFO_3W, *PPORT_INFO_3W, *LPPORT_INFO_3W;
#ifdef UNICODE
typedef PORT_INFO_3W PORT_INFO_3;
typedef PPORT_INFO_3W PPORT_INFO_3;
typedef LPPORT_INFO_3W LPPORT_INFO_3;
#else
typedef PORT_INFO_3A PORT_INFO_3;
typedef PPORT_INFO_3A PPORT_INFO_3;
typedef LPPORT_INFO_3A LPPORT_INFO_3;
#endif // UNICODE

#define PORT_STATUS_TYPE_ERROR      1
#define PORT_STATUS_TYPE_WARNING    2
#define PORT_STATUS_TYPE_INFO       3

#define     PORT_STATUS_OFFLINE                 1
#define     PORT_STATUS_PAPER_JAM               2
#define     PORT_STATUS_PAPER_OUT               3
#define     PORT_STATUS_OUTPUT_BIN_FULL         4
#define     PORT_STATUS_PAPER_PROBLEM           5
#define     PORT_STATUS_NO_TONER                6
#define     PORT_STATUS_DOOR_OPEN               7
#define     PORT_STATUS_USER_INTERVENTION       8
#define     PORT_STATUS_OUT_OF_MEMORY           9

#define     PORT_STATUS_TONER_LOW              10

#define     PORT_STATUS_WARMING_UP             11
#define     PORT_STATUS_POWER_SAVE             12


typedef struct _MONITOR_INFO_1A{
    LPSTR     pName;
} MONITOR_INFO_1A, *PMONITOR_INFO_1A, *LPMONITOR_INFO_1A;
typedef struct _MONITOR_INFO_1W{
    LPWSTR    pName;
} MONITOR_INFO_1W, *PMONITOR_INFO_1W, *LPMONITOR_INFO_1W;
#ifdef UNICODE
typedef MONITOR_INFO_1W MONITOR_INFO_1;
typedef PMONITOR_INFO_1W PMONITOR_INFO_1;
typedef LPMONITOR_INFO_1W LPMONITOR_INFO_1;
#else
typedef MONITOR_INFO_1A MONITOR_INFO_1;
typedef PMONITOR_INFO_1A PMONITOR_INFO_1;
typedef LPMONITOR_INFO_1A LPMONITOR_INFO_1;
#endif // UNICODE

typedef struct _MONITOR_INFO_2A{
    LPSTR     pName;
    LPSTR     pEnvironment;
    LPSTR     pDLLName;
} MONITOR_INFO_2A, *PMONITOR_INFO_2A, *LPMONITOR_INFO_2A;
typedef struct _MONITOR_INFO_2W{
    LPWSTR    pName;
    LPWSTR    pEnvironment;
    LPWSTR    pDLLName;
} MONITOR_INFO_2W, *PMONITOR_INFO_2W, *LPMONITOR_INFO_2W;
#ifdef UNICODE
typedef MONITOR_INFO_2W MONITOR_INFO_2;
typedef PMONITOR_INFO_2W PMONITOR_INFO_2;
typedef LPMONITOR_INFO_2W LPMONITOR_INFO_2;
#else
typedef MONITOR_INFO_2A MONITOR_INFO_2;
typedef PMONITOR_INFO_2A PMONITOR_INFO_2;
typedef LPMONITOR_INFO_2A LPMONITOR_INFO_2;
#endif // UNICODE

typedef struct _DATATYPES_INFO_1A{
    LPSTR     pName;
} DATATYPES_INFO_1A, *PDATATYPES_INFO_1A, *LPDATATYPES_INFO_1A;
typedef struct _DATATYPES_INFO_1W{
    LPWSTR    pName;
} DATATYPES_INFO_1W, *PDATATYPES_INFO_1W, *LPDATATYPES_INFO_1W;
#ifdef UNICODE
typedef DATATYPES_INFO_1W DATATYPES_INFO_1;
typedef PDATATYPES_INFO_1W PDATATYPES_INFO_1;
typedef LPDATATYPES_INFO_1W LPDATATYPES_INFO_1;
#else
typedef DATATYPES_INFO_1A DATATYPES_INFO_1;
typedef PDATATYPES_INFO_1A PDATATYPES_INFO_1;
typedef LPDATATYPES_INFO_1A LPDATATYPES_INFO_1;
#endif // UNICODE

typedef struct _PRINTER_DEFAULTSA{
    LPSTR         pDatatype;
    LPDEVMODEA pDevMode;
    ACCESS_MASK DesiredAccess;
} PRINTER_DEFAULTSA, *PPRINTER_DEFAULTSA, *LPPRINTER_DEFAULTSA;
typedef struct _PRINTER_DEFAULTSW{
    LPWSTR        pDatatype;
    LPDEVMODEW pDevMode;
    ACCESS_MASK DesiredAccess;
} PRINTER_DEFAULTSW, *PPRINTER_DEFAULTSW, *LPPRINTER_DEFAULTSW;
#ifdef UNICODE
typedef PRINTER_DEFAULTSW PRINTER_DEFAULTS;
typedef PPRINTER_DEFAULTSW PPRINTER_DEFAULTS;
typedef LPPRINTER_DEFAULTSW LPPRINTER_DEFAULTS;
#else
typedef PRINTER_DEFAULTSA PRINTER_DEFAULTS;
typedef PPRINTER_DEFAULTSA PPRINTER_DEFAULTS;
typedef LPPRINTER_DEFAULTSA LPPRINTER_DEFAULTS;
#endif // UNICODE

typedef struct _PRINTER_ENUM_VALUESA {
    LPSTR   pValueName;
    DWORD   cbValueName;
    DWORD   dwType;
    LPBYTE  pData;
    DWORD   cbData;
} PRINTER_ENUM_VALUESA, *PPRINTER_ENUM_VALUESA, *LPPRINTER_ENUM_VALUESA;
typedef struct _PRINTER_ENUM_VALUESW {
    LPWSTR  pValueName;
    DWORD   cbValueName;
    DWORD   dwType;
    LPBYTE  pData;
    DWORD   cbData;
} PRINTER_ENUM_VALUESW, *PPRINTER_ENUM_VALUESW, *LPPRINTER_ENUM_VALUESW;
#ifdef UNICODE
typedef PRINTER_ENUM_VALUESW PRINTER_ENUM_VALUES;
typedef PPRINTER_ENUM_VALUESW PPRINTER_ENUM_VALUES;
typedef LPPRINTER_ENUM_VALUESW LPPRINTER_ENUM_VALUES;
#else
typedef PRINTER_ENUM_VALUESA PRINTER_ENUM_VALUES;
typedef PPRINTER_ENUM_VALUESA PPRINTER_ENUM_VALUES;
typedef LPPRINTER_ENUM_VALUESA LPPRINTER_ENUM_VALUES;
#endif // UNICODE

BOOL
WINAPI
EnumPrintersA(
__in          DWORD   Flags,
__in_opt      LPSTR Name,
              DWORD   Level,
__out_bcount_opt(cbBuf)
              LPBYTE  pPrinterEnum,
              DWORD   cbBuf,
__out         LPDWORD pcbNeeded,
__out         LPDWORD pcReturned
);
BOOL
WINAPI
EnumPrintersW(
__in          DWORD   Flags,
__in_opt      LPWSTR Name,
              DWORD   Level,
__out_bcount_opt(cbBuf)
              LPBYTE  pPrinterEnum,
              DWORD   cbBuf,
__out         LPDWORD pcbNeeded,
__out         LPDWORD pcReturned
);
#ifdef UNICODE
#define EnumPrinters  EnumPrintersW
#else
#define EnumPrinters  EnumPrintersA
#endif // !UNICODE

#define PRINTER_ENUM_DEFAULT     0x00000001
#define PRINTER_ENUM_LOCAL       0x00000002
#define PRINTER_ENUM_CONNECTIONS 0x00000004
#define PRINTER_ENUM_FAVORITE    0x00000004
#define PRINTER_ENUM_NAME        0x00000008
#define PRINTER_ENUM_REMOTE      0x00000010
#define PRINTER_ENUM_SHARED      0x00000020
#define PRINTER_ENUM_NETWORK     0x00000040


#define PRINTER_ENUM_EXPAND      0x00004000
#define PRINTER_ENUM_CONTAINER   0x00008000

#define PRINTER_ENUM_ICONMASK    0x00ff0000
#define PRINTER_ENUM_ICON1       0x00010000
#define PRINTER_ENUM_ICON2       0x00020000
#define PRINTER_ENUM_ICON3       0x00040000
#define PRINTER_ENUM_ICON4       0x00080000
#define PRINTER_ENUM_ICON5       0x00100000
#define PRINTER_ENUM_ICON6       0x00200000
#define PRINTER_ENUM_ICON7       0x00400000
#define PRINTER_ENUM_ICON8       0x00800000
#define PRINTER_ENUM_HIDE        0x01000000



#define SPOOL_FILE_PERSISTENT    0x00000001
#define SPOOL_FILE_TEMPORARY     0x00000002

HANDLE
WINAPI
GetSpoolFileHandle(
__in    HANDLE  hPrinter
);

HANDLE
WINAPI
CommitSpoolData(
__in    HANDLE  hPrinter,
__in    HANDLE  hSpoolFile,
        DWORD   cbCommit
);

BOOL
WINAPI
CloseSpoolFileHandle(
__in    HANDLE  hPrinter,
__in    HANDLE  hSpoolFile
);

BOOL
WINAPI
OpenPrinterA(
__in_opt    LPSTR             pPrinterName,
__out       LPHANDLE            phPrinter,
__in_opt    LPPRINTER_DEFAULTSA pDefault
);
BOOL
WINAPI
OpenPrinterW(
__in_opt    LPWSTR             pPrinterName,
__out       LPHANDLE            phPrinter,
__in_opt    LPPRINTER_DEFAULTSW pDefault
);
#ifdef UNICODE
#define OpenPrinter  OpenPrinterW
#else
#define OpenPrinter  OpenPrinterA
#endif // !UNICODE

BOOL
WINAPI
ResetPrinterA(
__in        HANDLE                hPrinter,
__in_opt    LPPRINTER_DEFAULTSA   pDefault
);
BOOL
WINAPI
ResetPrinterW(
__in        HANDLE                hPrinter,
__in_opt    LPPRINTER_DEFAULTSW   pDefault
);
#ifdef UNICODE
#define ResetPrinter  ResetPrinterW
#else
#define ResetPrinter  ResetPrinterA
#endif // !UNICODE

BOOL
WINAPI
SetJobA(
__in        HANDLE  hPrinter,
            DWORD   JobId,
            DWORD   Level,
__in_opt    LPBYTE  pJob,
            DWORD   Command
);
BOOL
WINAPI
SetJobW(
__in        HANDLE  hPrinter,
            DWORD   JobId,
            DWORD   Level,
__in_opt    LPBYTE  pJob,
            DWORD   Command
);
#ifdef UNICODE
#define SetJob  SetJobW
#else
#define SetJob  SetJobA
#endif // !UNICODE

BOOL
WINAPI
GetJobA(
__in  HANDLE   hPrinter,
      DWORD    JobId,
      DWORD    Level,
__out_bcount_opt(cbBuf)
      LPBYTE   pJob,
      DWORD    cbBuf,
__out LPDWORD  pcbNeeded
);
BOOL
WINAPI
GetJobW(
__in  HANDLE   hPrinter,
      DWORD    JobId,
      DWORD    Level,
__out_bcount_opt(cbBuf)
      LPBYTE   pJob,
      DWORD    cbBuf,
__out LPDWORD  pcbNeeded
);
#ifdef UNICODE
#define GetJob  GetJobW
#else
#define GetJob  GetJobA
#endif // !UNICODE

BOOL
WINAPI
EnumJobsA(
__in  HANDLE  hPrinter,
      DWORD   FirstJob,
      DWORD   NoJobs,
      DWORD   Level,
__out_bcount_opt(cbBuf)
      LPBYTE  pJob,
      DWORD   cbBuf,
__out LPDWORD pcbNeeded,
__out LPDWORD pcReturned
);
BOOL
WINAPI
EnumJobsW(
__in  HANDLE  hPrinter,
      DWORD   FirstJob,
      DWORD   NoJobs,
      DWORD   Level,
__out_bcount_opt(cbBuf)
      LPBYTE  pJob,
      DWORD   cbBuf,
__out LPDWORD pcbNeeded,
__out LPDWORD pcReturned
);
#ifdef UNICODE
#define EnumJobs  EnumJobsW
#else
#define EnumJobs  EnumJobsA
#endif // !UNICODE

HANDLE
WINAPI
AddPrinterA(
__in_opt    LPSTR    pName,
            DWORD      Level,
__in        LPBYTE     pPrinter
);
HANDLE
WINAPI
AddPrinterW(
__in_opt    LPWSTR    pName,
            DWORD      Level,
__in        LPBYTE     pPrinter
);
#ifdef UNICODE
#define AddPrinter  AddPrinterW
#else
#define AddPrinter  AddPrinterA
#endif // !UNICODE

BOOL
WINAPI
DeletePrinter(
__inout HANDLE   hPrinter
);

BOOL
WINAPI
SetPrinterA(
__in     HANDLE  hPrinter,
         DWORD   Level,
__in_opt LPBYTE  pPrinter,
         DWORD   Command
);
BOOL
WINAPI
SetPrinterW(
__in     HANDLE  hPrinter,
         DWORD   Level,
__in_opt LPBYTE  pPrinter,
         DWORD   Command
);
#ifdef UNICODE
#define SetPrinter  SetPrinterW
#else
#define SetPrinter  SetPrinterA
#endif // !UNICODE

BOOL
WINAPI
GetPrinterA(
__in  HANDLE  hPrinter,
      DWORD   Level,
__out_bcount_opt(cbBuf)
      LPBYTE  pPrinter,
      DWORD   cbBuf,
__out LPDWORD pcbNeeded
);
BOOL
WINAPI
GetPrinterW(
__in  HANDLE  hPrinter,
      DWORD   Level,
__out_bcount_opt(cbBuf)
      LPBYTE  pPrinter,
      DWORD   cbBuf,
__out LPDWORD pcbNeeded
);
#ifdef UNICODE
#define GetPrinter  GetPrinterW
#else
#define GetPrinter  GetPrinterA
#endif // !UNICODE

BOOL
WINAPI
AddPrinterDriverA(
__in_opt    LPSTR   pName,
            DWORD     Level,
__in        LPBYTE    pDriverInfo
);
BOOL
WINAPI
AddPrinterDriverW(
__in_opt    LPWSTR   pName,
            DWORD     Level,
__in        LPBYTE    pDriverInfo
);
#ifdef UNICODE
#define AddPrinterDriver  AddPrinterDriverW
#else
#define AddPrinterDriver  AddPrinterDriverA
#endif // !UNICODE

BOOL
WINAPI
AddPrinterDriverExA(
__in_opt    LPSTR   pName,
            DWORD     Level,
__in        LPBYTE      pDriverInfo,
            DWORD     dwFileCopyFlags
);
BOOL
WINAPI
AddPrinterDriverExW(
__in_opt    LPWSTR   pName,
            DWORD     Level,
__in        LPBYTE      pDriverInfo,
            DWORD     dwFileCopyFlags
);
#ifdef UNICODE
#define AddPrinterDriverEx  AddPrinterDriverExW
#else
#define AddPrinterDriverEx  AddPrinterDriverExA
#endif // !UNICODE

BOOL
WINAPI
EnumPrinterDriversA(
__in_opt    LPSTR        pName,
__in_opt    LPSTR        pEnvironment,
            DWORD          Level,
__out_bcount_opt(cbBuf)
            LPBYTE        pDriverInfo,
            DWORD          cbBuf,
__out       LPDWORD        pcbNeeded,
__out       LPDWORD        pcReturned
);
BOOL
WINAPI
EnumPrinterDriversW(
__in_opt    LPWSTR        pName,
__in_opt    LPWSTR        pEnvironment,
            DWORD          Level,
__out_bcount_opt(cbBuf)
            LPBYTE        pDriverInfo,
            DWORD          cbBuf,
__out       LPDWORD        pcbNeeded,
__out       LPDWORD        pcReturned
);
#ifdef UNICODE
#define EnumPrinterDrivers  EnumPrinterDriversW
#else
#define EnumPrinterDrivers  EnumPrinterDriversA
#endif // !UNICODE

BOOL
WINAPI
GetPrinterDriverA(
__in        HANDLE  hPrinter,
__in_opt    LPSTR pEnvironment,
            DWORD   Level,
__out_bcount_opt(cbBuf)
            LPBYTE  pDriverInfo,
            DWORD   cbBuf,
__out       LPDWORD pcbNeeded
);
BOOL
WINAPI
GetPrinterDriverW(
__in        HANDLE  hPrinter,
__in_opt    LPWSTR pEnvironment,
            DWORD   Level,
__out_bcount_opt(cbBuf)
            LPBYTE  pDriverInfo,
            DWORD   cbBuf,
__out       LPDWORD pcbNeeded
);
#ifdef UNICODE
#define GetPrinterDriver  GetPrinterDriverW
#else
#define GetPrinterDriver  GetPrinterDriverA
#endif // !UNICODE

BOOL
WINAPI
GetPrinterDriverDirectoryA(
__in_opt    LPSTR   pName,
__in_opt    LPSTR   pEnvironment,
            DWORD     Level,
__out_bcount_opt(cbBuf)
            LPBYTE    pDriverDirectory,
            DWORD     cbBuf,
__out       LPDWORD   pcbNeeded
);
BOOL
WINAPI
GetPrinterDriverDirectoryW(
__in_opt    LPWSTR   pName,
__in_opt    LPWSTR   pEnvironment,
            DWORD     Level,
__out_bcount_opt(cbBuf)
            LPBYTE    pDriverDirectory,
            DWORD     cbBuf,
__out       LPDWORD   pcbNeeded
);
#ifdef UNICODE
#define GetPrinterDriverDirectory  GetPrinterDriverDirectoryW
#else
#define GetPrinterDriverDirectory  GetPrinterDriverDirectoryA
#endif // !UNICODE

BOOL
WINAPI
DeletePrinterDriverA(
__in_opt    LPSTR    pName,
__in_opt    LPSTR    pEnvironment,
__in        LPSTR    pDriverName
);
BOOL
WINAPI
DeletePrinterDriverW(
__in_opt    LPWSTR    pName,
__in_opt    LPWSTR    pEnvironment,
__in        LPWSTR    pDriverName
);
#ifdef UNICODE
#define DeletePrinterDriver  DeletePrinterDriverW
#else
#define DeletePrinterDriver  DeletePrinterDriverA
#endif // !UNICODE

BOOL
WINAPI
DeletePrinterDriverExA(
__in_opt    LPSTR    pName,
__in_opt    LPSTR    pEnvironment,
__in        LPSTR    pDriverName,
            DWORD      dwDeleteFlag,
            DWORD      dwVersionFlag
);
BOOL
WINAPI
DeletePrinterDriverExW(
__in_opt    LPWSTR    pName,
__in_opt    LPWSTR    pEnvironment,
__in        LPWSTR    pDriverName,
            DWORD      dwDeleteFlag,
            DWORD      dwVersionFlag
);
#ifdef UNICODE
#define DeletePrinterDriverEx  DeletePrinterDriverExW
#else
#define DeletePrinterDriverEx  DeletePrinterDriverExA
#endif // !UNICODE



BOOL
WINAPI
AddPrintProcessorA(
__in_opt   LPSTR   pName,
__in_opt   LPSTR   pEnvironment,
__in       LPSTR   pPathName,
__in       LPSTR   pPrintProcessorName
);
BOOL
WINAPI
AddPrintProcessorW(
__in_opt   LPWSTR   pName,
__in_opt   LPWSTR   pEnvironment,
__in       LPWSTR   pPathName,
__in       LPWSTR   pPrintProcessorName
);
#ifdef UNICODE
#define AddPrintProcessor  AddPrintProcessorW
#else
#define AddPrintProcessor  AddPrintProcessorA
#endif // !UNICODE

BOOL
WINAPI
EnumPrintProcessorsA(
__in_opt   LPSTR   pName,
__in_opt   LPSTR   pEnvironment,
           DWORD     Level,
__out_bcount_opt(cbBuf)
           LPBYTE    pPrintProcessorInfo,
           DWORD     cbBuf,
__out      LPDWORD   pcbNeeded,
__out      LPDWORD   pcReturned
);
BOOL
WINAPI
EnumPrintProcessorsW(
__in_opt   LPWSTR   pName,
__in_opt   LPWSTR   pEnvironment,
           DWORD     Level,
__out_bcount_opt(cbBuf)
           LPBYTE    pPrintProcessorInfo,
           DWORD     cbBuf,
__out      LPDWORD   pcbNeeded,
__out      LPDWORD   pcReturned
);
#ifdef UNICODE
#define EnumPrintProcessors  EnumPrintProcessorsW
#else
#define EnumPrintProcessors  EnumPrintProcessorsA
#endif // !UNICODE



BOOL
WINAPI
GetPrintProcessorDirectoryA(
__in_opt   LPSTR    pName,
__in_opt   LPSTR    pEnvironment,
           DWORD      Level,
__out_bcount_opt(cbBuf)
           LPBYTE     pPrintProcessorInfo,
           DWORD      cbBuf,
__out      LPDWORD    pcbNeeded
);
BOOL
WINAPI
GetPrintProcessorDirectoryW(
__in_opt   LPWSTR    pName,
__in_opt   LPWSTR    pEnvironment,
           DWORD      Level,
__out_bcount_opt(cbBuf)
           LPBYTE     pPrintProcessorInfo,
           DWORD      cbBuf,
__out      LPDWORD    pcbNeeded
);
#ifdef UNICODE
#define GetPrintProcessorDirectory  GetPrintProcessorDirectoryW
#else
#define GetPrintProcessorDirectory  GetPrintProcessorDirectoryA
#endif // !UNICODE

BOOL
WINAPI
EnumPrintProcessorDatatypesA(
__in_opt    LPSTR   pName,
__in        LPSTR   pPrintProcessorName,
            DWORD     Level,
__out_bcount_opt(cbBuf)
            LPBYTE    pDatatypes,
            DWORD     cbBuf,
__out       LPDWORD   pcbNeeded,
__out       LPDWORD   pcReturned
);
BOOL
WINAPI
EnumPrintProcessorDatatypesW(
__in_opt    LPWSTR   pName,
__in        LPWSTR   pPrintProcessorName,
            DWORD     Level,
__out_bcount_opt(cbBuf)
            LPBYTE    pDatatypes,
            DWORD     cbBuf,
__out       LPDWORD   pcbNeeded,
__out       LPDWORD   pcReturned
);
#ifdef UNICODE
#define EnumPrintProcessorDatatypes  EnumPrintProcessorDatatypesW
#else
#define EnumPrintProcessorDatatypes  EnumPrintProcessorDatatypesA
#endif // !UNICODE

BOOL
WINAPI
DeletePrintProcessorA(
__in_opt    LPSTR   pName,
__in_opt    LPSTR   pEnvironment,
__in        LPSTR   pPrintProcessorName
);
BOOL
WINAPI
DeletePrintProcessorW(
__in_opt    LPWSTR   pName,
__in_opt    LPWSTR   pEnvironment,
__in        LPWSTR   pPrintProcessorName
);
#ifdef UNICODE
#define DeletePrintProcessor  DeletePrintProcessorW
#else
#define DeletePrintProcessor  DeletePrintProcessorA
#endif // !UNICODE

DWORD
WINAPI
StartDocPrinterA(
__in    HANDLE  hPrinter,
        DWORD   Level,
__in    LPBYTE  pDocInfo
);
DWORD
WINAPI
StartDocPrinterW(
__in    HANDLE  hPrinter,
        DWORD   Level,
__in    LPBYTE  pDocInfo
);
#ifdef UNICODE
#define StartDocPrinter  StartDocPrinterW
#else
#define StartDocPrinter  StartDocPrinterA
#endif // !UNICODE

BOOL
WINAPI
StartPagePrinter(
__in    HANDLE  hPrinter
);

BOOL
WINAPI
WritePrinter(
__in    HANDLE  hPrinter,
__in_bcount(cbBuf)
        LPVOID  pBuf,
        DWORD   cbBuf,
__out   LPDWORD pcWritten
);


BOOL
WINAPI
FlushPrinter(
__in    HANDLE  hPrinter,
__in_bcount_opt(cbBuf)
        LPVOID  pBuf,
        DWORD   cbBuf,
__out   LPDWORD pcWritten,
        DWORD   cSleep
);

BOOL
WINAPI
EndPagePrinter(
__in    HANDLE   hPrinter
);

BOOL
WINAPI
AbortPrinter(
__in    HANDLE   hPrinter
);

BOOL
WINAPI
ReadPrinter(
__in    HANDLE  hPrinter,
__out_bcount(cbBuf)
        LPVOID  pBuf,
        DWORD   cbBuf,
__out   LPDWORD pNoBytesRead
);

BOOL
WINAPI
EndDocPrinter(
    __in  HANDLE   hPrinter
    );

BOOL
WINAPI
AddJobA(
__in    HANDLE  hPrinter,
        DWORD   Level,
__out_bcount_opt(cbBuf)
        LPBYTE  pData,
        DWORD   cbBuf,
__out   LPDWORD pcbNeeded
);
BOOL
WINAPI
AddJobW(
__in    HANDLE  hPrinter,
        DWORD   Level,
__out_bcount_opt(cbBuf)
        LPBYTE  pData,
        DWORD   cbBuf,
__out   LPDWORD pcbNeeded
);
#ifdef UNICODE
#define AddJob  AddJobW
#else
#define AddJob  AddJobA
#endif // !UNICODE

BOOL
WINAPI
ScheduleJob(
__in    HANDLE  hPrinter,
        DWORD   JobId
);

BOOL
WINAPI
PrinterProperties(
__in    HWND    hWnd,
__in    HANDLE  hPrinter
);

LONG
WINAPI
DocumentPropertiesA(
__in_opt        HWND      hWnd,
__in            HANDLE    hPrinter,
__in            LPSTR   pDeviceName,
__out_opt       PDEVMODEA pDevModeOutput,
__in_opt        PDEVMODEA pDevModeInput,
                DWORD     fMode
);
LONG
WINAPI
DocumentPropertiesW(
__in_opt        HWND      hWnd,
__in            HANDLE    hPrinter,
__in            LPWSTR   pDeviceName,
__out_opt       PDEVMODEW pDevModeOutput,
__in_opt        PDEVMODEW pDevModeInput,
                DWORD     fMode
);
#ifdef UNICODE
#define DocumentProperties  DocumentPropertiesW
#else
#define DocumentProperties  DocumentPropertiesA
#endif // !UNICODE

LONG
WINAPI
AdvancedDocumentPropertiesA(
__in            HWND        hWnd,
__in            HANDLE      hPrinter,
__in            LPSTR     pDeviceName,
__inout_opt     PDEVMODEA   pDevModeOutput,
__in_opt        PDEVMODEA   pDevModeInput
);
LONG
WINAPI
AdvancedDocumentPropertiesW(
__in            HWND        hWnd,
__in            HANDLE      hPrinter,
__in            LPWSTR     pDeviceName,
__inout_opt     PDEVMODEW   pDevModeOutput,
__in_opt        PDEVMODEW   pDevModeInput
);
#ifdef UNICODE
#define AdvancedDocumentProperties  AdvancedDocumentPropertiesW
#else
#define AdvancedDocumentProperties  AdvancedDocumentPropertiesA
#endif // !UNICODE

#if (NTDDI_VERSION >= NTDDI_WINXPSP1)
    LONG
    ExtDeviceMode(
    __in_opt        HWND        hWnd,
    __in_opt        HANDLE      hInst,
    __inout_opt     LPDEVMODEA  pDevModeOutput,
    __in_opt        LPSTR       pDeviceName,
    __in_opt        LPSTR       pPort,
    __in_opt        LPDEVMODEA  pDevModeInput,
    __in_opt        LPSTR       pProfile,
                    DWORD       fMode
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXPSP1)


DWORD
WINAPI
GetPrinterDataA(
__in         HANDLE   hPrinter,
__in         LPSTR  pValueName,
__out_opt    LPDWORD  pType,
__out_bcount_opt(nSize)
             LPBYTE   pData,
             DWORD    nSize,
__out        LPDWORD  pcbNeeded
);
DWORD
WINAPI
GetPrinterDataW(
__in         HANDLE   hPrinter,
__in         LPWSTR  pValueName,
__out_opt    LPDWORD  pType,
__out_bcount_opt(nSize)
             LPBYTE   pData,
             DWORD    nSize,
__out        LPDWORD  pcbNeeded
);
#ifdef UNICODE
#define GetPrinterData  GetPrinterDataW
#else
#define GetPrinterData  GetPrinterDataA
#endif // !UNICODE

DWORD
WINAPI
GetPrinterDataExA(
__in         HANDLE   hPrinter,
__in         LPCSTR pKeyName,
__in         LPCSTR pValueName,
__out_opt    LPDWORD  pType,
__out_bcount_opt(nSize)
             LPBYTE   pData,
             DWORD    nSize,
__out        LPDWORD  pcbNeeded
);
DWORD
WINAPI
GetPrinterDataExW(
__in         HANDLE   hPrinter,
__in         LPCWSTR pKeyName,
__in         LPCWSTR pValueName,
__out_opt    LPDWORD  pType,
__out_bcount_opt(nSize)
             LPBYTE   pData,
             DWORD    nSize,
__out        LPDWORD  pcbNeeded
);
#ifdef UNICODE
#define GetPrinterDataEx  GetPrinterDataExW
#else
#define GetPrinterDataEx  GetPrinterDataExA
#endif // !UNICODE

DWORD
WINAPI
EnumPrinterDataA(
__in        HANDLE   hPrinter,
            DWORD    dwIndex,
__out_bcount(cbValueName)
            LPSTR  pValueName,
            DWORD    cbValueName,
__out       LPDWORD  pcbValueName,
__out_opt   LPDWORD  pType,
            LPBYTE   pData,
            DWORD    cbData,
__out_opt   LPDWORD  pcbData
);
DWORD
WINAPI
EnumPrinterDataW(
__in        HANDLE   hPrinter,
            DWORD    dwIndex,
__out_bcount(cbValueName)
            LPWSTR  pValueName,
            DWORD    cbValueName,
__out       LPDWORD  pcbValueName,
__out_opt   LPDWORD  pType,
            LPBYTE   pData,
            DWORD    cbData,
__out_opt   LPDWORD  pcbData
);
#ifdef UNICODE
#define EnumPrinterData  EnumPrinterDataW
#else
#define EnumPrinterData  EnumPrinterDataA
#endif // !UNICODE

DWORD
WINAPI
EnumPrinterDataExA(
__in    HANDLE    hPrinter,
__in    LPCSTR  pKeyName,
__out_bcount_opt(cbEnumValues)
        LPBYTE    pEnumValues,
        DWORD     cbEnumValues,
__out   LPDWORD   pcbEnumValues,
__out   LPDWORD   pnEnumValues
);
DWORD
WINAPI
EnumPrinterDataExW(
__in    HANDLE    hPrinter,
__in    LPCWSTR  pKeyName,
__out_bcount_opt(cbEnumValues)
        LPBYTE    pEnumValues,
        DWORD     cbEnumValues,
__out   LPDWORD   pcbEnumValues,
__out   LPDWORD   pnEnumValues
);
#ifdef UNICODE
#define EnumPrinterDataEx  EnumPrinterDataExW
#else
#define EnumPrinterDataEx  EnumPrinterDataExA
#endif // !UNICODE

DWORD
WINAPI
EnumPrinterKeyA(
__in    HANDLE   hPrinter,
__in    LPCSTR pKeyName,
__out_bcount_opt(cbSubkey)
        LPSTR  pSubkey,
        DWORD    cbSubkey,
__out   LPDWORD  pcbSubkey
);
DWORD
WINAPI
EnumPrinterKeyW(
__in    HANDLE   hPrinter,
__in    LPCWSTR pKeyName,
__out_bcount_opt(cbSubkey)
        LPWSTR  pSubkey,
        DWORD    cbSubkey,
__out   LPDWORD  pcbSubkey
);
#ifdef UNICODE
#define EnumPrinterKey  EnumPrinterKeyW
#else
#define EnumPrinterKey  EnumPrinterKeyA
#endif // !UNICODE


DWORD
WINAPI
SetPrinterDataA(
__in    HANDLE  hPrinter,
__in    LPSTR pValueName,
        DWORD   Type,
__in_bcount(cbData)
        LPBYTE  pData,
        DWORD   cbData
);
DWORD
WINAPI
SetPrinterDataW(
__in    HANDLE  hPrinter,
__in    LPWSTR pValueName,
        DWORD   Type,
__in_bcount(cbData)
        LPBYTE  pData,
        DWORD   cbData
);
#ifdef UNICODE
#define SetPrinterData  SetPrinterDataW
#else
#define SetPrinterData  SetPrinterDataA
#endif // !UNICODE


DWORD
WINAPI
SetPrinterDataExA(
__in    HANDLE   hPrinter,
__in    LPCSTR pKeyName,
__in    LPCSTR pValueName,
        DWORD    Type,
__in_bcount(cbData)
        LPBYTE   pData,
        DWORD    cbData
);
DWORD
WINAPI
SetPrinterDataExW(
__in    HANDLE   hPrinter,
__in    LPCWSTR pKeyName,
__in    LPCWSTR pValueName,
        DWORD    Type,
__in_bcount(cbData)
        LPBYTE   pData,
        DWORD    cbData
);
#ifdef UNICODE
#define SetPrinterDataEx  SetPrinterDataExW
#else
#define SetPrinterDataEx  SetPrinterDataExA
#endif // !UNICODE



DWORD
WINAPI
DeletePrinterDataA(
__in    HANDLE  hPrinter,
__in    LPSTR pValueName
);
DWORD
WINAPI
DeletePrinterDataW(
__in    HANDLE  hPrinter,
__in    LPWSTR pValueName
);
#ifdef UNICODE
#define DeletePrinterData  DeletePrinterDataW
#else
#define DeletePrinterData  DeletePrinterDataA
#endif // !UNICODE


DWORD
WINAPI
DeletePrinterDataExA(
__in    HANDLE   hPrinter,
__in    LPCSTR pKeyName,
__in    LPCSTR pValueName
);
DWORD
WINAPI
DeletePrinterDataExW(
__in    HANDLE   hPrinter,
__in    LPCWSTR pKeyName,
__in    LPCWSTR pValueName
);
#ifdef UNICODE
#define DeletePrinterDataEx  DeletePrinterDataExW
#else
#define DeletePrinterDataEx  DeletePrinterDataExA
#endif // !UNICODE


DWORD
WINAPI
DeletePrinterKeyA(
__in    HANDLE   hPrinter,
__in    LPCSTR pKeyName
);
DWORD
WINAPI
DeletePrinterKeyW(
__in    HANDLE   hPrinter,
__in    LPCWSTR pKeyName
);
#ifdef UNICODE
#define DeletePrinterKey  DeletePrinterKeyW
#else
#define DeletePrinterKey  DeletePrinterKeyA
#endif // !UNICODE


#define PRINTER_NOTIFY_TYPE 0x00
#define JOB_NOTIFY_TYPE     0x01
#define SERVER_NOTIFY_TYPE  0x02

#define PRINTER_NOTIFY_FIELD_SERVER_NAME             0x00
#define PRINTER_NOTIFY_FIELD_PRINTER_NAME            0x01
#define PRINTER_NOTIFY_FIELD_SHARE_NAME              0x02
#define PRINTER_NOTIFY_FIELD_PORT_NAME               0x03
#define PRINTER_NOTIFY_FIELD_DRIVER_NAME             0x04
#define PRINTER_NOTIFY_FIELD_COMMENT                 0x05
#define PRINTER_NOTIFY_FIELD_LOCATION                0x06
#define PRINTER_NOTIFY_FIELD_DEVMODE                 0x07
#define PRINTER_NOTIFY_FIELD_SEPFILE                 0x08
#define PRINTER_NOTIFY_FIELD_PRINT_PROCESSOR         0x09
#define PRINTER_NOTIFY_FIELD_PARAMETERS              0x0A
#define PRINTER_NOTIFY_FIELD_DATATYPE                0x0B
#define PRINTER_NOTIFY_FIELD_SECURITY_DESCRIPTOR     0x0C
#define PRINTER_NOTIFY_FIELD_ATTRIBUTES              0x0D
#define PRINTER_NOTIFY_FIELD_PRIORITY                0x0E
#define PRINTER_NOTIFY_FIELD_DEFAULT_PRIORITY        0x0F
#define PRINTER_NOTIFY_FIELD_START_TIME              0x10
#define PRINTER_NOTIFY_FIELD_UNTIL_TIME              0x11
#define PRINTER_NOTIFY_FIELD_STATUS                  0x12
#define PRINTER_NOTIFY_FIELD_STATUS_STRING           0x13
#define PRINTER_NOTIFY_FIELD_CJOBS                   0x14
#define PRINTER_NOTIFY_FIELD_AVERAGE_PPM             0x15
#define PRINTER_NOTIFY_FIELD_TOTAL_PAGES             0x16
#define PRINTER_NOTIFY_FIELD_PAGES_PRINTED           0x17
#define PRINTER_NOTIFY_FIELD_TOTAL_BYTES             0x18
#define PRINTER_NOTIFY_FIELD_BYTES_PRINTED           0x19
#define PRINTER_NOTIFY_FIELD_OBJECT_GUID             0x1A

#if (NTDDI_VERSION >= NTDDI_VISTA)
    #define PRINTER_NOTIFY_FIELD_FRIENDLY_NAME       0x1B
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define JOB_NOTIFY_FIELD_PRINTER_NAME                0x00
#define JOB_NOTIFY_FIELD_MACHINE_NAME                0x01
#define JOB_NOTIFY_FIELD_PORT_NAME                   0x02
#define JOB_NOTIFY_FIELD_USER_NAME                   0x03
#define JOB_NOTIFY_FIELD_NOTIFY_NAME                 0x04
#define JOB_NOTIFY_FIELD_DATATYPE                    0x05
#define JOB_NOTIFY_FIELD_PRINT_PROCESSOR             0x06
#define JOB_NOTIFY_FIELD_PARAMETERS                  0x07
#define JOB_NOTIFY_FIELD_DRIVER_NAME                 0x08
#define JOB_NOTIFY_FIELD_DEVMODE                     0x09
#define JOB_NOTIFY_FIELD_STATUS                      0x0A
#define JOB_NOTIFY_FIELD_STATUS_STRING               0x0B
#define JOB_NOTIFY_FIELD_SECURITY_DESCRIPTOR         0x0C
#define JOB_NOTIFY_FIELD_DOCUMENT                    0x0D
#define JOB_NOTIFY_FIELD_PRIORITY                    0x0E
#define JOB_NOTIFY_FIELD_POSITION                    0x0F
#define JOB_NOTIFY_FIELD_SUBMITTED                   0x10
#define JOB_NOTIFY_FIELD_START_TIME                  0x11
#define JOB_NOTIFY_FIELD_UNTIL_TIME                  0x12
#define JOB_NOTIFY_FIELD_TIME                        0x13
#define JOB_NOTIFY_FIELD_TOTAL_PAGES                 0x14
#define JOB_NOTIFY_FIELD_PAGES_PRINTED               0x15
#define JOB_NOTIFY_FIELD_TOTAL_BYTES                 0x16
#define JOB_NOTIFY_FIELD_BYTES_PRINTED               0x17
#define JOB_NOTIFY_FIELD_REMOTE_JOB_ID               0x18

#if (NTDDI_VERSION >= NTDDI_WIN7)
#define SERVER_NOTIFY_FIELD_PRINT_DRIVER_ISOLATION_GROUP    0x00
#endif


typedef struct _PRINTER_NOTIFY_OPTIONS_TYPE {
    WORD Type;
    WORD Reserved0;
    DWORD Reserved1;
    DWORD Reserved2;
    DWORD Count;
    PWORD pFields;
} PRINTER_NOTIFY_OPTIONS_TYPE, *PPRINTER_NOTIFY_OPTIONS_TYPE, *LPPRINTER_NOTIFY_OPTIONS_TYPE;


#define PRINTER_NOTIFY_OPTIONS_REFRESH  0x01

typedef struct _PRINTER_NOTIFY_OPTIONS {
    DWORD Version;
    DWORD Flags;
    DWORD Count;
    PPRINTER_NOTIFY_OPTIONS_TYPE pTypes;
} PRINTER_NOTIFY_OPTIONS, *PPRINTER_NOTIFY_OPTIONS, *LPPRINTER_NOTIFY_OPTIONS;



#define PRINTER_NOTIFY_INFO_DISCARDED       0x01

typedef struct _PRINTER_NOTIFY_INFO_DATA {
    WORD Type;
    WORD Field;
    DWORD Reserved;
    DWORD Id;
    union {
        DWORD adwData[2];
        struct {
            DWORD  cbBuf;
            LPVOID pBuf;
        } Data;
    } NotifyData;
} PRINTER_NOTIFY_INFO_DATA, *PPRINTER_NOTIFY_INFO_DATA, *LPPRINTER_NOTIFY_INFO_DATA;

typedef struct _PRINTER_NOTIFY_INFO {
    DWORD Version;
    DWORD Flags;
    DWORD Count;
    PRINTER_NOTIFY_INFO_DATA aData[1];
} PRINTER_NOTIFY_INFO, *PPRINTER_NOTIFY_INFO, *LPPRINTER_NOTIFY_INFO;

#if (NTDDI_VERSION >= NTDDI_WINXP)
    typedef struct _BINARY_CONTAINER{
        DWORD cbBuf;
        LPBYTE pData;
    } BINARY_CONTAINER, *PBINARY_CONTAINER;


    typedef struct _BIDI_DATA{
        DWORD dwBidiType;
        union {
            BOOL   bData;
            LONG   iData;
            LPWSTR sData;
            FLOAT  fData;
            BINARY_CONTAINER biData;
            }u;
    } BIDI_DATA, *PBIDI_DATA, *LPBIDI_DATA;


    typedef struct _BIDI_REQUEST_DATA{
        DWORD     dwReqNumber;
        LPWSTR    pSchema;
        BIDI_DATA data;
    } BIDI_REQUEST_DATA , *PBIDI_REQUEST_DATA , *LPBIDI_REQUEST_DATA;


    typedef struct _BIDI_REQUEST_CONTAINER{
        DWORD Version;
        DWORD Flags;
        DWORD Count;
        BIDI_REQUEST_DATA aData[ 1 ];
    }BIDI_REQUEST_CONTAINER, *PBIDI_REQUEST_CONTAINER, *LPBIDI_REQUEST_CONTAINER;

    typedef struct _BIDI_RESPONSE_DATA{
        DWORD  dwResult;
        DWORD  dwReqNumber;
        LPWSTR pSchema;
        BIDI_DATA data;
    } BIDI_RESPONSE_DATA, *PBIDI_RESPONSE_DATA, *LPBIDI_RESPONSE_DATA;

    typedef struct _BIDI_RESPONSE_CONTAINER{
        DWORD Version;
        DWORD Flags;
        DWORD Count;
        BIDI_RESPONSE_DATA aData[ 1 ];
    } BIDI_RESPONSE_CONTAINER, *PBIDI_RESPONSE_CONTAINER, *LPBIDI_RESPONSE_CONTAINER;

    #define BIDI_ACTION_ENUM_SCHEMA                 L"EnumSchema"
    #define BIDI_ACTION_GET                         L"Get"
    #define BIDI_ACTION_SET                         L"Set"
    #define BIDI_ACTION_GET_ALL                     L"GetAll"

    typedef enum {
        BIDI_NULL   = 0,
        BIDI_INT    = 1,
        BIDI_FLOAT  = 2,
        BIDI_BOOL   = 3,
        BIDI_STRING = 4,
        BIDI_TEXT   = 5,
        BIDI_ENUM   = 6,
        BIDI_BLOB   = 7
    } BIDI_TYPE;

    #define BIDI_ACCESS_ADMINISTRATOR  0x1
    #define BIDI_ACCESS_USER           0x2


    /*
        Error code for bidi apis
    */

    #define ERROR_BIDI_STATUS_OK                0
    #define ERROR_BIDI_NOT_SUPPORTED            ERROR_NOT_SUPPORTED

    #define ERROR_BIDI_ERROR_BASE 13000
    #define ERROR_BIDI_STATUS_WARNING           (ERROR_BIDI_ERROR_BASE + 1)
    #define ERROR_BIDI_SCHEMA_READ_ONLY         (ERROR_BIDI_ERROR_BASE + 2)
    #define ERROR_BIDI_SERVER_OFFLINE           (ERROR_BIDI_ERROR_BASE + 3)
    #define ERROR_BIDI_DEVICE_OFFLINE           (ERROR_BIDI_ERROR_BASE + 4)
    #define ERROR_BIDI_SCHEMA_NOT_SUPPORTED     (ERROR_BIDI_ERROR_BASE + 5)
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

DWORD
WINAPI
WaitForPrinterChange(
__in HANDLE  hPrinter,
     DWORD   Flags
);

HANDLE
WINAPI
FindFirstPrinterChangeNotification(
__in     HANDLE hPrinter,
         DWORD  fdwFilter,
         DWORD  fdwOptions,
__in_opt PVOID  pPrinterNotifyOptions
    );


BOOL
WINAPI
FindNextPrinterChangeNotification(
__in        HANDLE hChange,
__out_opt   PDWORD pdwChange,
__in_opt    LPVOID pvReserved,
__out_opt   LPVOID *ppPrinterNotifyInfo
    );

BOOL
WINAPI
FreePrinterNotifyInfo(
__in   PPRINTER_NOTIFY_INFO pPrinterNotifyInfo
    );

BOOL
WINAPI
FindClosePrinterChangeNotification(
__in   HANDLE hChange
    );

#define PRINTER_CHANGE_ADD_PRINTER              0x00000001
#define PRINTER_CHANGE_SET_PRINTER              0x00000002
#define PRINTER_CHANGE_DELETE_PRINTER           0x00000004
#define PRINTER_CHANGE_FAILED_CONNECTION_PRINTER    0x00000008
#define PRINTER_CHANGE_PRINTER                  0x000000FF
#define PRINTER_CHANGE_ADD_JOB                  0x00000100
#define PRINTER_CHANGE_SET_JOB                  0x00000200
#define PRINTER_CHANGE_DELETE_JOB               0x00000400
#define PRINTER_CHANGE_WRITE_JOB                0x00000800
#define PRINTER_CHANGE_JOB                      0x0000FF00
#define PRINTER_CHANGE_ADD_FORM                 0x00010000
#define PRINTER_CHANGE_SET_FORM                 0x00020000
#define PRINTER_CHANGE_DELETE_FORM              0x00040000
#define PRINTER_CHANGE_FORM                     0x00070000
#define PRINTER_CHANGE_ADD_PORT                 0x00100000
#define PRINTER_CHANGE_CONFIGURE_PORT           0x00200000
#define PRINTER_CHANGE_DELETE_PORT              0x00400000
#define PRINTER_CHANGE_PORT                     0x00700000
#define PRINTER_CHANGE_ADD_PRINT_PROCESSOR      0x01000000
#define PRINTER_CHANGE_DELETE_PRINT_PROCESSOR   0x04000000
#define PRINTER_CHANGE_PRINT_PROCESSOR          0x07000000
#if (NTDDI_VERSION >= NTDDI_WIN7)
#define PRINTER_CHANGE_SERVER                   0x08000000
#endif
#define PRINTER_CHANGE_ADD_PRINTER_DRIVER       0x10000000
#define PRINTER_CHANGE_SET_PRINTER_DRIVER       0x20000000
#define PRINTER_CHANGE_DELETE_PRINTER_DRIVER    0x40000000
#define PRINTER_CHANGE_PRINTER_DRIVER           0x70000000
#define PRINTER_CHANGE_TIMEOUT                  0x80000000
#define PRINTER_CHANGE_ALL                      0x7777FFFF

DWORD
WINAPI
PrinterMessageBoxA(
__in   HANDLE    hPrinter,
       DWORD     Error,
__in   HWND      hWnd,
__in   LPSTR   pText,
__in   LPSTR   pCaption,
       DWORD     dwType
);
DWORD
WINAPI
PrinterMessageBoxW(
__in   HANDLE    hPrinter,
       DWORD     Error,
__in   HWND      hWnd,
__in   LPWSTR   pText,
__in   LPWSTR   pCaption,
       DWORD     dwType
);
#ifdef UNICODE
#define PrinterMessageBox  PrinterMessageBoxW
#else
#define PrinterMessageBox  PrinterMessageBoxA
#endif // !UNICODE



#define PRINTER_ERROR_INFORMATION   0x80000000
#define PRINTER_ERROR_WARNING       0x40000000
#define PRINTER_ERROR_SEVERE        0x20000000

#define PRINTER_ERROR_OUTOFPAPER    0x00000001
#define PRINTER_ERROR_JAM           0x00000002
#define PRINTER_ERROR_OUTOFTONER    0x00000004

BOOL
WINAPI
ClosePrinter(
__in HANDLE hPrinter
);

BOOL
WINAPI
AddFormA(
__in    HANDLE  hPrinter,
        DWORD   Level,
__in    LPBYTE  pForm
);
BOOL
WINAPI
AddFormW(
__in    HANDLE  hPrinter,
        DWORD   Level,
__in    LPBYTE  pForm
);
#ifdef UNICODE
#define AddForm  AddFormW
#else
#define AddForm  AddFormA
#endif // !UNICODE



BOOL
WINAPI
DeleteFormA(
__in    HANDLE    hPrinter,
__in    LPSTR   pFormName
);
BOOL
WINAPI
DeleteFormW(
__in    HANDLE    hPrinter,
__in    LPWSTR   pFormName
);
#ifdef UNICODE
#define DeleteForm  DeleteFormW
#else
#define DeleteForm  DeleteFormA
#endif // !UNICODE



BOOL
WINAPI
GetFormA(
__in    HANDLE        hPrinter,
__in    LPSTR       pFormName,
        DWORD         Level,
__out_bcount_opt(cbBuf)
        LPBYTE        pForm,
        DWORD         cbBuf,
__out   LPDWORD       pcbNeeded
);
BOOL
WINAPI
GetFormW(
__in    HANDLE        hPrinter,
__in    LPWSTR       pFormName,
        DWORD         Level,
__out_bcount_opt(cbBuf)
        LPBYTE        pForm,
        DWORD         cbBuf,
__out   LPDWORD       pcbNeeded
);
#ifdef UNICODE
#define GetForm  GetFormW
#else
#define GetForm  GetFormA
#endif // !UNICODE



BOOL
WINAPI
SetFormA(
__in    HANDLE  hPrinter,
__in    LPSTR pFormName,
        DWORD   Level,
__in    LPBYTE  pForm
);
BOOL
WINAPI
SetFormW(
__in    HANDLE  hPrinter,
__in    LPWSTR pFormName,
        DWORD   Level,
__in    LPBYTE  pForm
);
#ifdef UNICODE
#define SetForm  SetFormW
#else
#define SetForm  SetFormA
#endif // !UNICODE



BOOL
WINAPI
EnumFormsA(
__in    HANDLE  hPrinter,
        DWORD   Level,
__out_bcount_opt(cbBuf)
        LPBYTE  pForm,
        DWORD   cbBuf,
__out   LPDWORD pcbNeeded,
__out   LPDWORD pcReturned
);
BOOL
WINAPI
EnumFormsW(
__in    HANDLE  hPrinter,
        DWORD   Level,
__out_bcount_opt(cbBuf)
        LPBYTE  pForm,
        DWORD   cbBuf,
__out   LPDWORD pcbNeeded,
__out   LPDWORD pcReturned
);
#ifdef UNICODE
#define EnumForms  EnumFormsW
#else
#define EnumForms  EnumFormsA
#endif // !UNICODE


BOOL
WINAPI
EnumMonitorsA(
__in_opt    LPSTR   pName,
            DWORD       Level,
__out_bcount_opt(cbBuf)
            LPBYTE      pMonitor,
            DWORD       cbBuf,
__out       LPDWORD    pcbNeeded,
__out       LPDWORD    pcReturned
);
BOOL
WINAPI
EnumMonitorsW(
__in_opt    LPWSTR   pName,
            DWORD       Level,
__out_bcount_opt(cbBuf)
            LPBYTE      pMonitor,
            DWORD       cbBuf,
__out       LPDWORD    pcbNeeded,
__out       LPDWORD    pcReturned
);
#ifdef UNICODE
#define EnumMonitors  EnumMonitorsW
#else
#define EnumMonitors  EnumMonitorsA
#endif // !UNICODE



BOOL
WINAPI
AddMonitorA(
__in_opt    LPSTR pName,
            DWORD   Level,
__in        LPBYTE  pMonitors
);
BOOL
WINAPI
AddMonitorW(
__in_opt    LPWSTR pName,
            DWORD   Level,
__in        LPBYTE  pMonitors
);
#ifdef UNICODE
#define AddMonitor  AddMonitorW
#else
#define AddMonitor  AddMonitorA
#endif // !UNICODE



BOOL
WINAPI
DeleteMonitorA(
__in_opt    LPSTR     pName,
__in_opt    LPSTR     pEnvironment,
__in        LPSTR     pMonitorName
);
BOOL
WINAPI
DeleteMonitorW(
__in_opt    LPWSTR     pName,
__in_opt    LPWSTR     pEnvironment,
__in        LPWSTR     pMonitorName
);
#ifdef UNICODE
#define DeleteMonitor  DeleteMonitorW
#else
#define DeleteMonitor  DeleteMonitorA
#endif // !UNICODE



BOOL
WINAPI
EnumPortsA(
__in_opt    LPSTR pName,
            DWORD   Level,
__out_bcount_opt(cbBuf)
            LPBYTE  pPort,
            DWORD   cbBuf,
__out       LPDWORD pcbNeeded,
__out       LPDWORD pcReturned
);
BOOL
WINAPI
EnumPortsW(
__in_opt    LPWSTR pName,
            DWORD   Level,
__out_bcount_opt(cbBuf)
            LPBYTE  pPort,
            DWORD   cbBuf,
__out       LPDWORD pcbNeeded,
__out       LPDWORD pcReturned
);
#ifdef UNICODE
#define EnumPorts  EnumPortsW
#else
#define EnumPorts  EnumPortsA
#endif // !UNICODE


BOOL
WINAPI
AddPortA(
__in_opt    LPSTR   pName,
__in        HWND      hWnd,
__in        LPSTR   pMonitorName
);
BOOL
WINAPI
AddPortW(
__in_opt    LPWSTR   pName,
__in        HWND      hWnd,
__in        LPWSTR   pMonitorName
);
#ifdef UNICODE
#define AddPort  AddPortW
#else
#define AddPort  AddPortA
#endif // !UNICODE



BOOL
WINAPI
ConfigurePortA(
__in_opt    LPSTR   pName,
__in        HWND      hWnd,
__in        LPSTR   pPortName
);
BOOL
WINAPI
ConfigurePortW(
__in_opt    LPWSTR   pName,
__in        HWND      hWnd,
__in        LPWSTR   pPortName
);
#ifdef UNICODE
#define ConfigurePort  ConfigurePortW
#else
#define ConfigurePort  ConfigurePortA
#endif // !UNICODE

BOOL
WINAPI
DeletePortA(
__in_opt    LPSTR pName,
__in        HWND    hWnd,
__in        LPSTR pPortName
);
BOOL
WINAPI
DeletePortW(
__in_opt    LPWSTR pName,
__in        HWND    hWnd,
__in        LPWSTR pPortName
);
#ifdef UNICODE
#define DeletePort  DeletePortW
#else
#define DeletePort  DeletePortA
#endif // !UNICODE

BOOL
WINAPI
XcvDataW(
__in        HANDLE  hXcv,
__in        PCWSTR  pszDataName,
__in_bcount_opt(cbInputData)
            PBYTE   pInputData,
            DWORD   cbInputData,
__out_bcount_opt(cbOutputData)
            PBYTE   pOutputData,
            DWORD   cbOutputData,
__out       PDWORD  pcbOutputNeeded,
__out_opt   PDWORD  pdwStatus
);
#define XcvData  XcvDataW

BOOL
WINAPI
GetDefaultPrinterA(
    __out_ecount_opt(*pcchBuffer)   LPSTR   pszBuffer,
    __inout                         LPDWORD   pcchBuffer
    );
BOOL
WINAPI
GetDefaultPrinterW(
    __out_ecount_opt(*pcchBuffer)   LPWSTR   pszBuffer,
    __inout                         LPDWORD   pcchBuffer
    );
#ifdef UNICODE
#define GetDefaultPrinter  GetDefaultPrinterW
#else
#define GetDefaultPrinter  GetDefaultPrinterA
#endif // !UNICODE

BOOL
WINAPI
SetDefaultPrinterA(
__in    LPCSTR pszPrinter
    );
BOOL
WINAPI
SetDefaultPrinterW(
__in    LPCWSTR pszPrinter
    );
#ifdef UNICODE
#define SetDefaultPrinter  SetDefaultPrinterW
#else
#define SetDefaultPrinter  SetDefaultPrinterA
#endif // !UNICODE


BOOL
WINAPI
SetPortA(
__in_opt    LPSTR     pName,
__in        LPSTR     pPortName,
            DWORD       dwLevel,
__in        LPBYTE      pPortInfo
);
BOOL
WINAPI
SetPortW(
__in_opt    LPWSTR     pName,
__in        LPWSTR     pPortName,
            DWORD       dwLevel,
__in        LPBYTE      pPortInfo
);
#ifdef UNICODE
#define SetPort  SetPortW
#else
#define SetPort  SetPortA
#endif // !UNICODE



BOOL
WINAPI
AddPrinterConnectionA(
__in LPSTR   pName
);
BOOL
WINAPI
AddPrinterConnectionW(
__in LPWSTR   pName
);
#ifdef UNICODE
#define AddPrinterConnection  AddPrinterConnectionW
#else
#define AddPrinterConnection  AddPrinterConnectionA
#endif // !UNICODE



BOOL
WINAPI
DeletePrinterConnectionA(
__in LPSTR   pName
);
BOOL
WINAPI
DeletePrinterConnectionW(
__in LPWSTR   pName
);
#ifdef UNICODE
#define DeletePrinterConnection  DeletePrinterConnectionW
#else
#define DeletePrinterConnection  DeletePrinterConnectionA
#endif // !UNICODE



HANDLE
WINAPI
ConnectToPrinterDlg(
__in    HWND    hwnd,
       DWORD    Flags
);

typedef struct _PROVIDOR_INFO_1A{
    LPSTR     pName;
    LPSTR     pEnvironment;
    LPSTR     pDLLName;
} PROVIDOR_INFO_1A, *PPROVIDOR_INFO_1A, *LPPROVIDOR_INFO_1A;
typedef struct _PROVIDOR_INFO_1W{
    LPWSTR    pName;
    LPWSTR    pEnvironment;
    LPWSTR    pDLLName;
} PROVIDOR_INFO_1W, *PPROVIDOR_INFO_1W, *LPPROVIDOR_INFO_1W;
#ifdef UNICODE
typedef PROVIDOR_INFO_1W PROVIDOR_INFO_1;
typedef PPROVIDOR_INFO_1W PPROVIDOR_INFO_1;
typedef LPPROVIDOR_INFO_1W LPPROVIDOR_INFO_1;
#else
typedef PROVIDOR_INFO_1A PROVIDOR_INFO_1;
typedef PPROVIDOR_INFO_1A PPROVIDOR_INFO_1;
typedef LPPROVIDOR_INFO_1A LPPROVIDOR_INFO_1;
#endif // UNICODE

typedef struct _PROVIDOR_INFO_2A{
    LPSTR     pOrder;
} PROVIDOR_INFO_2A, *PPROVIDOR_INFO_2A, *LPPROVIDOR_INFO_2A;
typedef struct _PROVIDOR_INFO_2W{
    LPWSTR    pOrder;
} PROVIDOR_INFO_2W, *PPROVIDOR_INFO_2W, *LPPROVIDOR_INFO_2W;
#ifdef UNICODE
typedef PROVIDOR_INFO_2W PROVIDOR_INFO_2;
typedef PPROVIDOR_INFO_2W PPROVIDOR_INFO_2;
typedef LPPROVIDOR_INFO_2W LPPROVIDOR_INFO_2;
#else
typedef PROVIDOR_INFO_2A PROVIDOR_INFO_2;
typedef PPROVIDOR_INFO_2A PPROVIDOR_INFO_2;
typedef LPPROVIDOR_INFO_2A LPPROVIDOR_INFO_2;
#endif // UNICODE

BOOL
WINAPI
AddPrintProvidorA(
__in_opt    LPSTR  pName,
            DWORD    level,
__in        LPBYTE   pProvidorInfo
);
BOOL
WINAPI
AddPrintProvidorW(
__in_opt    LPWSTR  pName,
            DWORD    level,
__in        LPBYTE   pProvidorInfo
);
#ifdef UNICODE
#define AddPrintProvidor  AddPrintProvidorW
#else
#define AddPrintProvidor  AddPrintProvidorA
#endif // !UNICODE

BOOL
WINAPI
DeletePrintProvidorA(
__in_opt    LPSTR   pName,
__in_opt    LPSTR   pEnvironment,
__in        LPSTR   pPrintProvidorName
);
BOOL
WINAPI
DeletePrintProvidorW(
__in_opt    LPWSTR   pName,
__in_opt    LPWSTR   pEnvironment,
__in        LPWSTR   pPrintProvidorName
);
#ifdef UNICODE
#define DeletePrintProvidor  DeletePrintProvidorW
#else
#define DeletePrintProvidor  DeletePrintProvidorA
#endif // !UNICODE

#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
    BOOL
    WINAPI
    IsValidDevmodeA(
        __in_opt    PDEVMODEA   pDevmode,
                    size_t      DevmodeSize
        );
    BOOL
    WINAPI
    IsValidDevmodeW(
        __in_opt    PDEVMODEW   pDevmode,
                    size_t      DevmodeSize
        );
#ifdef UNICODE
#define IsValidDevmode  IsValidDevmodeW
#else
#define IsValidDevmode  IsValidDevmodeA
#endif // !UNICODE
#endif // (NTDDI_VERSION >= NTDDI_WINXPSP2)


/*
 * SetPrinterData and GetPrinterData Server Handle Key values
 */

#define    SPLREG_DEFAULT_SPOOL_DIRECTORY             TEXT("DefaultSpoolDirectory")
#define    SPLREG_PORT_THREAD_PRIORITY_DEFAULT        TEXT("PortThreadPriorityDefault")
#define    SPLREG_PORT_THREAD_PRIORITY                TEXT("PortThreadPriority")
#define    SPLREG_SCHEDULER_THREAD_PRIORITY_DEFAULT   TEXT("SchedulerThreadPriorityDefault")
#define    SPLREG_SCHEDULER_THREAD_PRIORITY           TEXT("SchedulerThreadPriority")
#define    SPLREG_BEEP_ENABLED                        TEXT("BeepEnabled")
#define    SPLREG_NET_POPUP                           TEXT("NetPopup")
#define    SPLREG_RETRY_POPUP                         TEXT("RetryPopup")
#define    SPLREG_NET_POPUP_TO_COMPUTER               TEXT("NetPopupToComputer")
#define    SPLREG_EVENT_LOG                           TEXT("EventLog")
#define    SPLREG_MAJOR_VERSION                       TEXT("MajorVersion")
#define    SPLREG_MINOR_VERSION                       TEXT("MinorVersion")
#define    SPLREG_ARCHITECTURE                        TEXT("Architecture")

#if (NTDDI_VERSION >= NTDDI_WINXP)
    #define    SPLREG_OS_VERSION                      TEXT("OSVersion")
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define    SPLREG_OS_VERSIONEX                        TEXT("OSVersionEx")
#define    SPLREG_DS_PRESENT                          TEXT("DsPresent")
#define    SPLREG_DS_PRESENT_FOR_USER                 TEXT("DsPresentForUser")
#define    SPLREG_REMOTE_FAX                          TEXT("RemoteFax")
#define    SPLREG_RESTART_JOB_ON_POOL_ERROR           TEXT("RestartJobOnPoolError")
#define    SPLREG_RESTART_JOB_ON_POOL_ENABLED         TEXT("RestartJobOnPoolEnabled")
#define    SPLREG_DNS_MACHINE_NAME                    TEXT("DNSMachineName")

#if ((OSVER(NTDDI_VERSION) == NTDDI_WINXP) && (SPVER(NTDDI_VERSION) >= 2) || \
     (NTDDI_VERSION >= NTDDI_WS03SP1))
    #define    SPLREG_ALLOW_USER_MANAGEFORMS          TEXT("AllowUserManageForms")
#endif // ((OSVER(NTDDI_VERSION) == NTDDI_WINXP) ...

#if (NTDDI_VERSION >= NTDDI_WS03)
    #define    SPLREG_WEBSHAREMGMT                    TEXT("WebShareMgmt")
#endif // (NTDDI_VERSION >= NTDDI_WS03)


#if (NTDDI_VERSION >= NTDDI_WIN7)
#define    SPLREG_PRINT_DRIVER_ISOLATION_GROUPS_SEPARATOR           L'\\'
#define    SPLREG_PRINT_DRIVER_ISOLATION_GROUPS                     TEXT("PrintDriverIsolationGroups")
#define    SPLREG_PRINT_DRIVER_ISOLATION_TIME_BEFORE_RECYCLE        TEXT("PrintDriverIsolationTimeBeforeRecycle")
#define    SPLREG_PRINT_DRIVER_ISOLATION_MAX_OBJECTS_BEFORE_RECYCLE TEXT("PrintDriverIsolationMaxobjsBeforeRecycle")
#define    SPLREG_PRINT_DRIVER_ISOLATION_IDLE_TIMEOUT               TEXT("PrintDriverIsolationIdleTimeout")
#define    SPLREG_PRINT_DRIVER_ISOLATION_EXECUTION_POLICY           TEXT("PrintDriverIsolationExecutionPolicy")
#define    SPLREG_PRINT_DRIVER_ISOLATION_OVERRIDE_POLICY            TEXT("PrintDriverIsolationOverrideCompat")
#endif // (NTDDI_VERSION >= NTDDI_WIN7)

#define SERVER_ACCESS_ADMINISTER    0x00000001
#define SERVER_ACCESS_ENUMERATE     0x00000002

#define PRINTER_ACCESS_ADMINISTER   0x00000004
#define PRINTER_ACCESS_USE          0x00000008

#define JOB_ACCESS_ADMINISTER       0x00000010

#if ((NTDDI_VERSION >= NTDDI_WINXPSP1) || \
     ((OSVER(NTDDI_VERSION) == NTDDI_WIN2K) && (SPVER(NTDDI_VERSION) >= 3)))
    #define JOB_ACCESS_READ         0x00000020
#endif // ((NTDDI_VERSION >= NTDDI_WINXPSP1) ...

/*
 * Access rights for print servers
 */

#define SERVER_ALL_ACCESS    (STANDARD_RIGHTS_REQUIRED      |\
                              SERVER_ACCESS_ADMINISTER      |\
                              SERVER_ACCESS_ENUMERATE)

#define SERVER_READ          (STANDARD_RIGHTS_READ          |\
                              SERVER_ACCESS_ENUMERATE)

#define SERVER_WRITE         (STANDARD_RIGHTS_WRITE         |\
                              SERVER_ACCESS_ADMINISTER      |\
                              SERVER_ACCESS_ENUMERATE)

#define SERVER_EXECUTE       (STANDARD_RIGHTS_EXECUTE       |\
                              SERVER_ACCESS_ENUMERATE)

/*
 * Access rights for printers
 */

#define PRINTER_ALL_ACCESS    (STANDARD_RIGHTS_REQUIRED     |\
                               PRINTER_ACCESS_ADMINISTER    |\
                               PRINTER_ACCESS_USE)

#define PRINTER_READ          (STANDARD_RIGHTS_READ         |\
                               PRINTER_ACCESS_USE)

#define PRINTER_WRITE         (STANDARD_RIGHTS_WRITE        |\
                               PRINTER_ACCESS_USE)

#define PRINTER_EXECUTE       (STANDARD_RIGHTS_EXECUTE      |\
                               PRINTER_ACCESS_USE)

/*
 * Access rights for jobs
 */

#if ((NTDDI_VERSION >= NTDDI_WINXPSP1) || \
     ((OSVER(NTDDI_VERSION) == NTDDI_WIN2K) && (SPVER(NTDDI_VERSION) >= 3)))
    #define JOB_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED    |\
                                    JOB_ACCESS_ADMINISTER       |\
                                    JOB_ACCESS_READ)
#else
    #define JOB_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED    |\
                                    JOB_ACCESS_ADMINISTER)
#endif

#if ((NTDDI_VERSION >= NTDDI_WINXPSP1) || \
     ((OSVER(NTDDI_VERSION) == NTDDI_WIN2K) && (SPVER(NTDDI_VERSION) >= 3)))
    #define JOB_READ               (STANDARD_RIGHTS_READ        |\
                                    JOB_ACCESS_READ)
#else
    #define JOB_READ               (STANDARD_RIGHTS_READ        |\
                                    JOB_ACCESS_ADMINISTER)

#endif

#define JOB_WRITE              (STANDARD_RIGHTS_WRITE       |\
                                JOB_ACCESS_ADMINISTER)

#define JOB_EXECUTE            (STANDARD_RIGHTS_EXECUTE     |\
                                JOB_ACCESS_ADMINISTER)


/*
 * DS Print-Queue property tables
 */


// Predefined Registry Keys used by Set/GetPrinterDataEx
#define SPLDS_SPOOLER_KEY                       TEXT("DsSpooler")
#define SPLDS_DRIVER_KEY                        TEXT("DsDriver")
#define SPLDS_USER_KEY                          TEXT("DsUser")


// DS Print-Queue properties

#define SPLDS_ASSET_NUMBER                      TEXT("assetNumber")
#define SPLDS_BYTES_PER_MINUTE                  TEXT("bytesPerMinute")
#define SPLDS_DESCRIPTION                       TEXT("description")
#define SPLDS_DRIVER_NAME                       TEXT("driverName")
#define SPLDS_DRIVER_VERSION                    TEXT("driverVersion")
#define SPLDS_LOCATION                          TEXT("location")
#define SPLDS_PORT_NAME                         TEXT("portName")
#define SPLDS_PRINT_ATTRIBUTES                  TEXT("printAttributes")
#define SPLDS_PRINT_BIN_NAMES                   TEXT("printBinNames")
#define SPLDS_PRINT_COLLATE                     TEXT("printCollate")
#define SPLDS_PRINT_COLOR                       TEXT("printColor")
#define SPLDS_PRINT_DUPLEX_SUPPORTED            TEXT("printDuplexSupported")
#define SPLDS_PRINT_END_TIME                    TEXT("printEndTime")
#define SPLDS_PRINTER_CLASS                     TEXT("printQueue")
#define SPLDS_PRINTER_NAME                      TEXT("printerName")
#define SPLDS_PRINT_KEEP_PRINTED_JOBS           TEXT("printKeepPrintedJobs")
#define SPLDS_PRINT_LANGUAGE                    TEXT("printLanguage")
#define SPLDS_PRINT_MAC_ADDRESS                 TEXT("printMACAddress")
#define SPLDS_PRINT_MAX_X_EXTENT                TEXT("printMaxXExtent")
#define SPLDS_PRINT_MAX_Y_EXTENT                TEXT("printMaxYExtent")
#define SPLDS_PRINT_MAX_RESOLUTION_SUPPORTED    TEXT("printMaxResolutionSupported")
#define SPLDS_PRINT_MEDIA_READY                 TEXT("printMediaReady")
#define SPLDS_PRINT_MEDIA_SUPPORTED             TEXT("printMediaSupported")
#define SPLDS_PRINT_MEMORY                      TEXT("printMemory")
#define SPLDS_PRINT_MIN_X_EXTENT                TEXT("printMinXExtent")
#define SPLDS_PRINT_MIN_Y_EXTENT                TEXT("printMinYExtent")
#define SPLDS_PRINT_NETWORK_ADDRESS             TEXT("printNetworkAddress")
#define SPLDS_PRINT_NOTIFY                      TEXT("printNotify")
#define SPLDS_PRINT_NUMBER_UP                   TEXT("printNumberUp")
#define SPLDS_PRINT_ORIENTATIONS_SUPPORTED      TEXT("printOrientationsSupported")
#define SPLDS_PRINT_OWNER                       TEXT("printOwner")
#define SPLDS_PRINT_PAGES_PER_MINUTE            TEXT("printPagesPerMinute")
#define SPLDS_PRINT_RATE                        TEXT("printRate")
#define SPLDS_PRINT_RATE_UNIT                   TEXT("printRateUnit")
#define SPLDS_PRINT_SEPARATOR_FILE              TEXT("printSeparatorFile")
#define SPLDS_PRINT_SHARE_NAME                  TEXT("printShareName")
#define SPLDS_PRINT_SPOOLING                    TEXT("printSpooling")
#define SPLDS_PRINT_STAPLING_SUPPORTED          TEXT("printStaplingSupported")
#define SPLDS_PRINT_START_TIME                  TEXT("printStartTime")
#define SPLDS_PRINT_STATUS                      TEXT("printStatus")
#define SPLDS_PRIORITY                          TEXT("priority")
#define SPLDS_SERVER_NAME                       TEXT("serverName")
#define SPLDS_SHORT_SERVER_NAME                 TEXT("shortServerName")
#define SPLDS_UNC_NAME                          TEXT("uNCName")
#define SPLDS_URL                               TEXT("url")
#define SPLDS_FLAGS                             TEXT("flags")
#define SPLDS_VERSION_NUMBER                    TEXT("versionNumber")

/*
    -- Additional Print-Queue properties --

    These properties are not defined in the default Directory Services Schema,
    but should be used when extending the Schema so a consistent interface is maintained.

*/

#define SPLDS_PRINTER_NAME_ALIASES              TEXT("printerNameAliases")      // MULTI_SZ
#define SPLDS_PRINTER_LOCATIONS                 TEXT("printerLocations")        // MULTI_SZ
#define SPLDS_PRINTER_MODEL                     TEXT("printerModel")            // SZ



#if (NTDDI_VERSION >= NTDDI_VISTA)
    //
    // Printer option flags that can be passed to OpenPrinter2 for
    // controlling whether the cached or non cached handle is used.
    //
    typedef enum _PRINTER_OPTION_FLAGS
    {
        PRINTER_OPTION_NO_CACHE       = 1 << 0,
        PRINTER_OPTION_CACHE          = 1 << 1,
        PRINTER_OPTION_CLIENT_CHANGE  = 1 << 2,
        PRINTER_OPTION_NO_CLIENT_DATA = 1 << 3,
    } PRINTER_OPTION_FLAGS;


    typedef struct _PRINTER_OPTIONSA
    {
        UINT            cbSize;
        DWORD           dwFlags;
    } PRINTER_OPTIONSA, *PPRINTER_OPTIONSA, *LPPRINTER_OPTIONSA;
    typedef struct _PRINTER_OPTIONSW
    {
        UINT            cbSize;
        DWORD           dwFlags;
    } PRINTER_OPTIONSW, *PPRINTER_OPTIONSW, *LPPRINTER_OPTIONSW;
#ifdef UNICODE
typedef PRINTER_OPTIONSW PRINTER_OPTIONS;
typedef PPRINTER_OPTIONSW PPRINTER_OPTIONS;
typedef LPPRINTER_OPTIONSW LPPRINTER_OPTIONS;
#else
typedef PRINTER_OPTIONSA PRINTER_OPTIONS;
typedef PPRINTER_OPTIONSA PPRINTER_OPTIONS;
typedef LPPRINTER_OPTIONSA LPPRINTER_OPTIONS;
#endif // UNICODE

    BOOL
    WINAPI
    OpenPrinter2A(
    __in_opt      LPCSTR                pPrinterName,
    __out         LPHANDLE                phPrinter,
    __in_opt      PPRINTER_DEFAULTSA      pDefault,
    __in_opt      PPRINTER_OPTIONSA       pOptions
    );
    BOOL
    WINAPI
    OpenPrinter2W(
    __in_opt      LPCWSTR                pPrinterName,
    __out         LPHANDLE                phPrinter,
    __in_opt      PPRINTER_DEFAULTSW      pDefault,
    __in_opt      PPRINTER_OPTIONSW       pOptions
    );
#ifdef UNICODE
#define OpenPrinter2  OpenPrinter2W
#else
#define OpenPrinter2  OpenPrinter2A
#endif // !UNICODE

    #define PRINTER_CONNECTION_MISMATCH             0x00000020      // printer should be mismatched
    #define PRINTER_CONNECTION_NO_UI                0x00000040      // Fail call if UI is needed in order to install printer driver

    typedef struct _PRINTER_CONNECTION_INFO_1A
    {
        DWORD       dwFlags;
        LPSTR       pszDriverName;
    } PRINTER_CONNECTION_INFO_1A, *PPRINTER_CONNECTION_INFO_1A;
    typedef struct _PRINTER_CONNECTION_INFO_1W
    {
        DWORD       dwFlags;
        LPWSTR      pszDriverName;
    } PRINTER_CONNECTION_INFO_1W, *PPRINTER_CONNECTION_INFO_1W;
#ifdef UNICODE
typedef PRINTER_CONNECTION_INFO_1W PRINTER_CONNECTION_INFO_1;
typedef PPRINTER_CONNECTION_INFO_1W PPRINTER_CONNECTION_INFO_1;
#else
typedef PRINTER_CONNECTION_INFO_1A PRINTER_CONNECTION_INFO_1;
typedef PPRINTER_CONNECTION_INFO_1A PPRINTER_CONNECTION_INFO_1;
#endif // UNICODE

    BOOL
    WINAPI
    AddPrinterConnection2A(
    __in_opt    HWND            hWnd,
    __in        LPCSTR        pszName,
                DWORD           dwLevel,
    __in        PVOID           pConnectionInfo
        );
    BOOL
    WINAPI
    AddPrinterConnection2W(
    __in_opt    HWND            hWnd,
    __in        LPCWSTR        pszName,
                DWORD           dwLevel,
    __in        PVOID           pConnectionInfo
        );
#ifdef UNICODE
#define AddPrinterConnection2  AddPrinterConnection2W
#else
#define AddPrinterConnection2  AddPrinterConnection2A
#endif // !UNICODE


//
// Unless IPDFP_COPY_ALL_FILES is specified it is always
// assumed that we use the latest files (APD_COPY_NEW_FILES)
//
#define IPDFP_COPY_ALL_FILES                0x00000001

    HRESULT
    WINAPI
    InstallPrinterDriverFromPackageA(
    __in_opt   LPCSTR    pszServer,
    __in_opt   LPCSTR    pszInfPath,
    __in       LPCSTR    pszDriverName,
    __in_opt   LPCSTR    pszEnvironment,
    __in       DWORD       dwFlags
    );
    HRESULT
    WINAPI
    InstallPrinterDriverFromPackageW(
    __in_opt   LPCWSTR    pszServer,
    __in_opt   LPCWSTR    pszInfPath,
    __in       LPCWSTR    pszDriverName,
    __in_opt   LPCWSTR    pszEnvironment,
    __in       DWORD       dwFlags
    );
#ifdef UNICODE
#define InstallPrinterDriverFromPackage  InstallPrinterDriverFromPackageW
#else
#define InstallPrinterDriverFromPackage  InstallPrinterDriverFromPackageA
#endif // !UNICODE

#define UPDP_SILENT_UPLOAD      0x00000001  // If specified we will not show UI during UploadPrinterDriverPackage API.
#define UPDP_UPLOAD_ALWAYS      0x00000002  // Will not do the optimization of not uploading the files if the
                                            // driver package is already present on remote machine.
#define UPDP_CHECK_DRIVERSTORE  0x00000004  // Check whether the given package exists in driver store or not.

    HRESULT
    WINAPI
    UploadPrinterDriverPackageA(
    __in_opt   LPCSTR    pszServer,
    __in       LPCSTR    pszInfPath,
    __in_opt   LPCSTR    pszEnvironment,
    __in       DWORD       dwFlags,
    __in       HWND        hwnd,
    __out_ecount(*pcchDestInfPath)
               LPSTR     pszDestInfPath,
    __inout    PULONG      pcchDestInfPath
    );
    HRESULT
    WINAPI
    UploadPrinterDriverPackageW(
    __in_opt   LPCWSTR    pszServer,
    __in       LPCWSTR    pszInfPath,
    __in_opt   LPCWSTR    pszEnvironment,
    __in       DWORD       dwFlags,
    __in       HWND        hwnd,
    __out_ecount(*pcchDestInfPath)
               LPWSTR     pszDestInfPath,
    __inout    PULONG      pcchDestInfPath
    );
#ifdef UNICODE
#define UploadPrinterDriverPackage  UploadPrinterDriverPackageW
#else
#define UploadPrinterDriverPackage  UploadPrinterDriverPackageA
#endif // !UNICODE

    typedef struct _CORE_PRINTER_DRIVERA
    {
        GUID         CoreDriverGUID;
        FILETIME     ftDriverDate;
        DWORDLONG    dwlDriverVersion;
        CHAR         szPackageID[MAX_PATH];
    } CORE_PRINTER_DRIVERA, *PCORE_PRINTER_DRIVERA;
    typedef struct _CORE_PRINTER_DRIVERW
    {
        GUID         CoreDriverGUID;
        FILETIME     ftDriverDate;
        DWORDLONG    dwlDriverVersion;
        WCHAR        szPackageID[MAX_PATH];
    } CORE_PRINTER_DRIVERW, *PCORE_PRINTER_DRIVERW;
#ifdef UNICODE
typedef CORE_PRINTER_DRIVERW CORE_PRINTER_DRIVER;
typedef PCORE_PRINTER_DRIVERW PCORE_PRINTER_DRIVER;
#else
typedef CORE_PRINTER_DRIVERA CORE_PRINTER_DRIVER;
typedef PCORE_PRINTER_DRIVERA PCORE_PRINTER_DRIVER;
#endif // UNICODE

    HRESULT
    WINAPI
    GetCorePrinterDriversA(
    __in_opt                          LPCSTR               pszServer,
    __in_opt                          LPCSTR               pszEnvironment,
    __in                              LPCSTR               pszzCoreDriverDependencies,
    __in                              DWORD                  cCorePrinterDrivers,
    __out_ecount(cCorePrinterDrivers) PCORE_PRINTER_DRIVERA  pCorePrinterDrivers
    );
    HRESULT
    WINAPI
    GetCorePrinterDriversW(
    __in_opt                          LPCWSTR               pszServer,
    __in_opt                          LPCWSTR               pszEnvironment,
    __in                              LPCWSTR               pszzCoreDriverDependencies,
    __in                              DWORD                  cCorePrinterDrivers,
    __out_ecount(cCorePrinterDrivers) PCORE_PRINTER_DRIVERW  pCorePrinterDrivers
    );
#ifdef UNICODE
#define GetCorePrinterDrivers  GetCorePrinterDriversW
#else
#define GetCorePrinterDrivers  GetCorePrinterDriversA
#endif // !UNICODE

    HRESULT
    WINAPI
    CorePrinterDriverInstalledA(
    __in_opt            LPCSTR     pszServer,
    __in_opt            LPCSTR     pszEnvironment,
    __in                GUID         CoreDriverGUID,
    __in                FILETIME     ftDriverDate,
    __in                DWORDLONG    dwlDriverVersion,
    __out               BOOL         *pbDriverInstalled
    );
    HRESULT
    WINAPI
    CorePrinterDriverInstalledW(
    __in_opt            LPCWSTR     pszServer,
    __in_opt            LPCWSTR     pszEnvironment,
    __in                GUID         CoreDriverGUID,
    __in                FILETIME     ftDriverDate,
    __in                DWORDLONG    dwlDriverVersion,
    __out               BOOL         *pbDriverInstalled
    );
#ifdef UNICODE
#define CorePrinterDriverInstalled  CorePrinterDriverInstalledW
#else
#define CorePrinterDriverInstalled  CorePrinterDriverInstalledA
#endif // !UNICODE

    HRESULT
    WINAPI
    GetPrinterDriverPackagePathA(
    __in_opt                                   LPCSTR      pszServer,
    __in_opt                                   LPCSTR      pszEnvironment,
    __in_opt                                   LPCSTR      pszLanguage,
    __in                                       LPCSTR      pszPackageID,
    __inout_ecount_opt(cchDriverPackageCab)    LPSTR       pszDriverPackageCab,
    __in_opt                                   DWORD         cchDriverPackageCab,
    __out                                      LPDWORD       pcchRequiredSize
    );
    HRESULT
    WINAPI
    GetPrinterDriverPackagePathW(
    __in_opt                                   LPCWSTR      pszServer,
    __in_opt                                   LPCWSTR      pszEnvironment,
    __in_opt                                   LPCWSTR      pszLanguage,
    __in                                       LPCWSTR      pszPackageID,
    __inout_ecount_opt(cchDriverPackageCab)    LPWSTR       pszDriverPackageCab,
    __in_opt                                   DWORD         cchDriverPackageCab,
    __out                                      LPDWORD       pcchRequiredSize
    );
#ifdef UNICODE
#define GetPrinterDriverPackagePath  GetPrinterDriverPackagePathW
#else
#define GetPrinterDriverPackagePath  GetPrinterDriverPackagePathA
#endif // !UNICODE

    HRESULT
    WINAPI
    DeletePrinterDriverPackageA(
    __in_opt   LPCSTR    pszServer,
    __in       LPCSTR    pszInfPath,
    __in_opt   LPCSTR    pszEnvironment
    );
    HRESULT
    WINAPI
    DeletePrinterDriverPackageW(
    __in_opt   LPCWSTR    pszServer,
    __in       LPCWSTR    pszInfPath,
    __in_opt   LPCWSTR    pszEnvironment
    );
#ifdef UNICODE
#define DeletePrinterDriverPackage  DeletePrinterDriverPackageW
#else
#define DeletePrinterDriverPackage  DeletePrinterDriverPackageA
#endif // !UNICODE

    typedef enum
    {
        kPropertyTypeString = 1,
        kPropertyTypeInt32,
        kPropertyTypeInt64,
        kPropertyTypeByte,
        kPropertyTypeTime,
        kPropertyTypeDevMode,
        kPropertyTypeSD,
        kPropertyTypeNotificationReply,
        kPropertyTypeNotificationOptions,
        kPropertyTypeBuffer

    } EPrintPropertyType;

    typedef enum
    {
        kAddingDocumentSequence = 0,
        kDocumentSequenceAdded  = 1,
        kAddingFixedDocument    = 2,
        kFixedDocumentAdded     = 3,
        kAddingFixedPage        = 4,
        kFixedPageAdded         = 5,
        kResourceAdded          = 6,
        kFontAdded              = 7,
        kImageAdded             = 8,
        kXpsDocumentCommitted   = 9

    } EPrintXPSJobProgress;

    typedef enum
    {
        kJobProduction = 1,
        kJobConsumption

    } EPrintXPSJobOperation;

    typedef struct
    {
        EPrintPropertyType       ePropertyType;
        union
        {
            BYTE                 propertyByte;
            PWSTR                propertyString;
            LONG                 propertyInt32;
            LONGLONG             propertyInt64;
            struct {
                DWORD  cbBuf;
                LPVOID pBuf;
            }                    propertyBlob;
        } value;

    }PrintPropertyValue;

    typedef struct
    {
        WCHAR*                  propertyName;
        PrintPropertyValue      propertyValue;

    }PrintNamedProperty;

    typedef struct
    {
        ULONG                   numberOfProperties;
        PrintNamedProperty*     propertiesCollection;

    }PrintPropertiesCollection;

    HRESULT
    WINAPI
    ReportJobProcessingProgress(
    __in        HANDLE                         printerHandle,
                ULONG                          jobId,
                EPrintXPSJobOperation          jobOperation,
                EPrintXPSJobProgress           jobProgress
        );

    BOOL
    WINAPI
    GetPrinterDriver2A(
        __in_opt    HWND    hWnd,
        __in        HANDLE  hPrinter,
        __in_opt    LPSTR pEnvironment,
                    DWORD   Level,
        __out_bcount_opt(cbBuf)
                    LPBYTE  pDriverInfo,
                    DWORD   cbBuf,
        __out       LPDWORD pcbNeeded
    );
    BOOL
    WINAPI
    GetPrinterDriver2W(
        __in_opt    HWND    hWnd,
        __in        HANDLE  hPrinter,
        __in_opt    LPWSTR pEnvironment,
                    DWORD   Level,
        __out_bcount_opt(cbBuf)
                    LPBYTE  pDriverInfo,
                    DWORD   cbBuf,
        __out       LPDWORD pcbNeeded
    );
#ifdef UNICODE
#define GetPrinterDriver2  GetPrinterDriver2W
#else
#define GetPrinterDriver2  GetPrinterDriver2A
#endif // !UNICODE

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WIN7)

typedef enum
{
    PRINT_EXECUTION_CONTEXT_APPLICATION = 0,
    PRINT_EXECUTION_CONTEXT_SPOOLER_SERVICE = 1,
    PRINT_EXECUTION_CONTEXT_SPOOLER_ISOLATION_HOST = 2,
    PRINT_EXECUTION_CONTEXT_FILTER_PIPELINE = 3,
    PRINT_EXECUTION_CONTEXT_WOW64 = 4
}
PRINT_EXECUTION_CONTEXT;

typedef struct
{
    PRINT_EXECUTION_CONTEXT context;
    DWORD                   clientAppPID;
}
PRINT_EXECUTION_DATA;

BOOL
WINAPI
GetPrintExecutionData(
    __out PRINT_EXECUTION_DATA *pData
    );


#endif // (NTDDI_VERSION >= NTDDI_WIN7)

#ifdef __cplusplus
}
#endif


#endif // _WINSPOOL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WinVer.h ===
/*****************************************************************************\
*                                                                             *
* winver.h -    Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL.  This library is                    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               Copyright (c) Microsoft Corporation. All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef VER_H
#define VER_H

#include <SpecStrings.h>
#include <verrsrc.h>


#ifdef __cplusplus
extern "C" {
#endif

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */


/* ----- Function prototypes ----- */

DWORD
APIENTRY
VerFindFileA(
        __in                         DWORD uFlags,
        __in                         LPCSTR szFileName,
        __in_opt                     LPCSTR szWinDir,
        __in                         LPCSTR szAppDir,
        __out_ecount(*lpuCurDirLen)  LPSTR szCurDir,
        __inout                      PUINT lpuCurDirLen,
        __out_ecount(*lpuDestDirLen) LPSTR szDestDir,
        __inout                      PUINT lpuDestDirLen
        );
DWORD
APIENTRY
VerFindFileW(
        __in                         DWORD uFlags,
        __in                         LPCWSTR szFileName,
        __in_opt                     LPCWSTR szWinDir,
        __in                         LPCWSTR szAppDir,
        __out_ecount(*lpuCurDirLen)  LPWSTR szCurDir,
        __inout                      PUINT lpuCurDirLen,
        __out_ecount(*lpuDestDirLen) LPWSTR szDestDir,
        __inout                      PUINT lpuDestDirLen
        );
#ifdef UNICODE
#define VerFindFile  VerFindFileW
#else
#define VerFindFile  VerFindFileA
#endif // !UNICODE

DWORD
APIENTRY
VerInstallFileA(
        __in                         DWORD uFlags,
        __in                         LPCSTR szSrcFileName,
        __in                         LPCSTR szDestFileName,
        __in                         LPCSTR szSrcDir,
        __in                         LPCSTR szDestDir,
        __in                         LPCSTR szCurDir,
        __out_ecount(*lpuTmpFileLen) LPSTR szTmpFile,
        __inout                      PUINT lpuTmpFileLen
        );
DWORD
APIENTRY
VerInstallFileW(
        __in                         DWORD uFlags,
        __in                         LPCWSTR szSrcFileName,
        __in                         LPCWSTR szDestFileName,
        __in                         LPCWSTR szSrcDir,
        __in                         LPCWSTR szDestDir,
        __in                         LPCWSTR szCurDir,
        __out_ecount(*lpuTmpFileLen) LPWSTR szTmpFile,
        __inout                      PUINT lpuTmpFileLen
        );
#ifdef UNICODE
#define VerInstallFile  VerInstallFileW
#else
#define VerInstallFile  VerInstallFileA
#endif // !UNICODE

/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeA(
        __in        LPCSTR lptstrFilename, /* Filename of version stamped file */
        __out_opt LPDWORD lpdwHandle       /* Information for use by GetFileVersionInfo */
        );
/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeW(
        __in        LPCWSTR lptstrFilename, /* Filename of version stamped file */
        __out_opt LPDWORD lpdwHandle       /* Information for use by GetFileVersionInfo */
        );
#ifdef UNICODE
#define GetFileVersionInfoSize  GetFileVersionInfoSizeW
#else
#define GetFileVersionInfoSize  GetFileVersionInfoSizeA
#endif // !UNICODE

/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoA(
        __in                LPCSTR lptstrFilename, /* Filename of version stamped file */
        __reserved          DWORD dwHandle,          /* Information from GetFileVersionSize */
        __in                DWORD dwLen,             /* Length of buffer for info */
        __out_bcount(dwLen) LPVOID lpData            /* Buffer to place the data structure */
        );
/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoW(
        __in                LPCWSTR lptstrFilename, /* Filename of version stamped file */
        __reserved          DWORD dwHandle,          /* Information from GetFileVersionSize */
        __in                DWORD dwLen,             /* Length of buffer for info */
        __out_bcount(dwLen) LPVOID lpData            /* Buffer to place the data structure */
        );
#ifdef UNICODE
#define GetFileVersionInfo  GetFileVersionInfoW
#else
#define GetFileVersionInfo  GetFileVersionInfoA
#endif // !UNICODE

DWORD APIENTRY GetFileVersionInfoSizeExA(__in DWORD dwFlags, __in LPCSTR lpwstrFilename, __out LPDWORD lpdwHandle);
DWORD APIENTRY GetFileVersionInfoSizeExW(__in DWORD dwFlags, __in LPCWSTR lpwstrFilename, __out LPDWORD lpdwHandle);
#ifdef UNICODE
#define GetFileVersionInfoSizeEx  GetFileVersionInfoSizeExW
#else
#define GetFileVersionInfoSizeEx  GetFileVersionInfoSizeExA
#endif // !UNICODE

BOOL APIENTRY GetFileVersionInfoExA(__in DWORD dwFlags,
                                    __in LPCSTR lpwstrFilename,
                                    __reserved DWORD dwHandle,
                                    __in DWORD dwLen,
                                    __out_bcount(dwLen) LPVOID lpData);
BOOL APIENTRY GetFileVersionInfoExW(__in DWORD dwFlags,
                                    __in LPCWSTR lpwstrFilename,
                                    __reserved DWORD dwHandle,
                                    __in DWORD dwLen,
                                    __out_bcount(dwLen) LPVOID lpData);
#ifdef UNICODE
#define GetFileVersionInfoEx  GetFileVersionInfoExW
#else
#define GetFileVersionInfoEx  GetFileVersionInfoExA
#endif // !UNICODE


DWORD
APIENTRY
VerLanguageNameA(
        __in                  DWORD wLang,
        __out_ecount(cchLang) LPSTR szLang,
        __in                  DWORD cchLang
        );
DWORD
APIENTRY
VerLanguageNameW(
        __in                  DWORD wLang,
        __out_ecount(cchLang) LPWSTR szLang,
        __in                  DWORD cchLang
        );
#ifdef UNICODE
#define VerLanguageName  VerLanguageNameW
#else
#define VerLanguageName  VerLanguageNameA
#endif // !UNICODE

BOOL
APIENTRY
VerQueryValueA(
        __in LPCVOID pBlock,
        __in LPCSTR lpSubBlock,
        __deref_out_xcount("buffer can be PWSTR or DWORD*") LPVOID * lplpBuffer,
        __out PUINT puLen
        );
BOOL
APIENTRY
VerQueryValueW(
        __in LPCVOID pBlock,
        __in LPCWSTR lpSubBlock,
        __deref_out_xcount("buffer can be PWSTR or DWORD*") LPVOID * lplpBuffer,
        __out PUINT puLen
        );
#ifdef UNICODE
#define VerQueryValue  VerQueryValueW
#else
#define VerQueryValue  VerQueryValueA
#endif // !UNICODE


#endif  /* !RC_INVOKED */

#ifdef __cplusplus
}
#endif


#endif  /* !VER_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\winsxs.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for winsxs.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __winsxs_h__
#define __winsxs_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAssemblyName_FWD_DEFINED__
#define __IAssemblyName_FWD_DEFINED__
typedef interface IAssemblyName IAssemblyName;
#endif 	/* __IAssemblyName_FWD_DEFINED__ */


#ifndef __IAssemblyCacheItem_FWD_DEFINED__
#define __IAssemblyCacheItem_FWD_DEFINED__
typedef interface IAssemblyCacheItem IAssemblyCacheItem;
#endif 	/* __IAssemblyCacheItem_FWD_DEFINED__ */


#ifndef __IAssemblyCache_FWD_DEFINED__
#define __IAssemblyCache_FWD_DEFINED__
typedef interface IAssemblyCache IAssemblyCache;
#endif 	/* __IAssemblyCache_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_winsxs_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// winsxs.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Fusion Interfaces for sxs assemblies.

#define STREAM_FORMAT_COMPLIB_MODULE    0
#define STREAM_FORMAT_COMPLIB_MANIFEST  1
#define STREAM_FORMAT_WIN32_MODULE      2
#define STREAM_FORMAT_WIN32_MANIFEST    4



EXTERN_C const IID IID_IAssemblyName;       
EXTERN_C const IID IID_IAssemblyCacheItem;  
EXTERN_C const IID IID_IAssemblyScavenger;      
EXTERN_C const IID IID_IAssemblyCache;      
#ifndef _LPFUSION_DEFINED
#define _LPFUSION_DEFINED
#define IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH (0x00000001)
#define QUERYASMINFO_FLAG_VALIDATE             (0x1)
#define ASSEMBLYINFO_FLAG_INSTALLED (0x00000001)
#define ASSEMBLYINFO_FLAG_PAYLOADRESIDENT (0x00000002)
typedef struct _ASSEMBLY_INFO
    {
    ULONG cbAssemblyInfo;
    DWORD dwAssemblyFlags;
    ULARGE_INTEGER uliAssemblySizeInKB;
    LPWSTR pszCurrentAssemblyPathBuf;
    ULONG cchBuf;
    } 	ASSEMBLY_INFO;

#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED (1)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE (2)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED (3)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING (4)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED (1)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED (2)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED (3)
// {8cedc215-ac4b-488b-93c0-a50a49cb2fb8}
DEFINE_GUID(FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID, 0x8cedc215, 0xac4b, 0x488b, 0x93, 0xc0, 0xa5, 0x0a, 0x49, 0xcb, 0x2f, 0xb8);

// {b02f9d65-fb77-4f7a-afa5-b391309f11c9}
DEFINE_GUID(FUSION_REFCOUNT_FILEPATH_GUID, 0xb02f9d65, 0xfb77, 0x4f7a, 0xaf, 0xa5, 0xb3, 0x91, 0x30, 0x9f, 0x11, 0xc9);

// {2ec93463-b0c3-45e1-8364-327e96aea856}
DEFINE_GUID(FUSION_REFCOUNT_OPAQUE_STRING_GUID, 0x2ec93463, 0xb0c3, 0x45e1, 0x83, 0x64, 0x32, 0x7e, 0x96, 0xae, 0xa8, 0x56);
typedef struct _FUSION_INSTALL_REFERENCE_
    {
    DWORD cbSize;
    DWORD dwFlags;
    GUID guidScheme;
    LPCWSTR szIdentifier;
    LPCWSTR szNonCannonicalData;
    } 	FUSION_INSTALL_REFERENCE;

typedef struct _FUSION_INSTALL_REFERENCE_ *LPFUSION_INSTALL_REFERENCE;

typedef const struct _FUSION_INSTALL_REFERENCE_ *LPCFUSION_INSTALL_REFERENCE;



extern RPC_IF_HANDLE __MIDL_itf_winsxs_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_winsxs_0000_0000_v0_0_s_ifspec;

#ifndef __IAssemblyName_INTERFACE_DEFINED__
#define __IAssemblyName_INTERFACE_DEFINED__

/* interface IAssemblyName */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyName *LPASSEMBLYNAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0001
    {	ASM_NAME_PUBLIC_KEY	= 0,
	ASM_NAME_PUBLIC_KEY_TOKEN	= ( ASM_NAME_PUBLIC_KEY + 1 ) ,
	ASM_NAME_HASH_VALUE	= ( ASM_NAME_PUBLIC_KEY_TOKEN + 1 ) ,
	ASM_NAME_NAME	= ( ASM_NAME_HASH_VALUE + 1 ) ,
	ASM_NAME_MAJOR_VERSION	= ( ASM_NAME_NAME + 1 ) ,
	ASM_NAME_MINOR_VERSION	= ( ASM_NAME_MAJOR_VERSION + 1 ) ,
	ASM_NAME_BUILD_NUMBER	= ( ASM_NAME_MINOR_VERSION + 1 ) ,
	ASM_NAME_REVISION_NUMBER	= ( ASM_NAME_BUILD_NUMBER + 1 ) ,
	ASM_NAME_CULTURE	= ( ASM_NAME_REVISION_NUMBER + 1 ) ,
	ASM_NAME_PROCESSOR_ID_ARRAY	= ( ASM_NAME_CULTURE + 1 ) ,
	ASM_NAME_OSINFO_ARRAY	= ( ASM_NAME_PROCESSOR_ID_ARRAY + 1 ) ,
	ASM_NAME_HASH_ALGID	= ( ASM_NAME_OSINFO_ARRAY + 1 ) ,
	ASM_NAME_ALIAS	= ( ASM_NAME_HASH_ALGID + 1 ) ,
	ASM_NAME_CODEBASE_URL	= ( ASM_NAME_ALIAS + 1 ) ,
	ASM_NAME_CODEBASE_LASTMOD	= ( ASM_NAME_CODEBASE_URL + 1 ) ,
	ASM_NAME_NULL_PUBLIC_KEY	= ( ASM_NAME_CODEBASE_LASTMOD + 1 ) ,
	ASM_NAME_NULL_PUBLIC_KEY_TOKEN	= ( ASM_NAME_NULL_PUBLIC_KEY + 1 ) ,
	ASM_NAME_CUSTOM	= ( ASM_NAME_NULL_PUBLIC_KEY_TOKEN + 1 ) ,
	ASM_NAME_NULL_CUSTOM	= ( ASM_NAME_CUSTOM + 1 ) ,
	ASM_NAME_MVID	= ( ASM_NAME_NULL_CUSTOM + 1 ) ,
	ASM_NAME_MAX_PARAMS	= ( ASM_NAME_MVID + 1 ) 
    } 	ASM_NAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0002
    {	ASM_BINDF_FORCE_CACHE_INSTALL	= 0x1,
	ASM_BINDF_RFS_INTEGRITY_CHECK	= 0x2,
	ASM_BINDF_RFS_MODULE_CHECK	= 0x4,
	ASM_BINDF_BINPATH_PROBE_ONLY	= 0x8,
	ASM_BINDF_SHARED_BINPATH_HINT	= 0x10,
	ASM_BINDF_PARENT_ASM_HINT	= 0x20
    } 	ASM_BIND_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0003
    {	ASM_DISPLAYF_VERSION	= 0x1,
	ASM_DISPLAYF_CULTURE	= 0x2,
	ASM_DISPLAYF_PUBLIC_KEY_TOKEN	= 0x4,
	ASM_DISPLAYF_PUBLIC_KEY	= 0x8,
	ASM_DISPLAYF_CUSTOM	= 0x10,
	ASM_DISPLAYF_PROCESSORARCHITECTURE	= 0x20,
	ASM_DISPLAYF_LANGUAGEID	= 0x40
    } 	ASM_DISPLAY_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0004
    {	ASM_CMPF_NAME	= 0x1,
	ASM_CMPF_MAJOR_VERSION	= 0x2,
	ASM_CMPF_MINOR_VERSION	= 0x4,
	ASM_CMPF_BUILD_NUMBER	= 0x8,
	ASM_CMPF_REVISION_NUMBER	= 0x10,
	ASM_CMPF_PUBLIC_KEY_TOKEN	= 0x20,
	ASM_CMPF_CULTURE	= 0x40,
	ASM_CMPF_CUSTOM	= 0x80,
	ASM_CMPF_ALL	= ( ( ( ( ( ( ( ASM_CMPF_NAME | ASM_CMPF_MAJOR_VERSION )  | ASM_CMPF_MINOR_VERSION )  | ASM_CMPF_REVISION_NUMBER )  | ASM_CMPF_BUILD_NUMBER )  | ASM_CMPF_PUBLIC_KEY_TOKEN )  | ASM_CMPF_CULTURE )  | ASM_CMPF_CUSTOM ) ,
	ASM_CMPF_DEFAULT	= 0x100
    } 	ASM_CMP_FLAGS;


EXTERN_C const IID IID_IAssemblyName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")
    IAssemblyName : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finalize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [annotation][out] */ 
            __out_ecount_opt(*pccDisplayName)  LPWSTR szDisplayName,
            /* [annotation][out][in] */ 
            __inout  LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reserved( 
            /* [in] */ REFIID refIID,
            /* [in] */ IUnknown *pUnkReserved1,
            /* [in] */ IUnknown *pUnkReserved2,
            /* [in] */ LPCOLESTR szReserved,
            /* [in] */ LONGLONG llReserved,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [annotation][out][in] */ 
            __inout  LPDWORD lpcwBuffer,
            /* [annotation][out] */ 
            __out_ecount_opt(*lpcwBuffer)  LPWSTR pwzName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyName **pName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyNameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyName * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyName * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *Finalize )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IAssemblyName * This,
            /* [annotation][out] */ 
            __out_ecount_opt(*pccDisplayName)  LPWSTR szDisplayName,
            /* [annotation][out][in] */ 
            __inout  LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Reserved )( 
            IAssemblyName * This,
            /* [in] */ REFIID refIID,
            /* [in] */ IUnknown *pUnkReserved1,
            /* [in] */ IUnknown *pUnkReserved2,
            /* [in] */ LPCOLESTR szReserved,
            /* [in] */ LONGLONG llReserved,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IAssemblyName * This,
            /* [annotation][out][in] */ 
            __inout  LPDWORD lpcwBuffer,
            /* [annotation][out] */ 
            __out_ecount_opt(*lpcwBuffer)  LPWSTR pwzName);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            IAssemblyName * This,
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IAssemblyName * This,
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyName * This,
            /* [out] */ IAssemblyName **pName);
        
        END_INTERFACE
    } IAssemblyNameVtbl;

    interface IAssemblyName
    {
        CONST_VTBL struct IAssemblyNameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyName_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAssemblyName_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAssemblyName_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAssemblyName_SetProperty(This,PropertyId,pvProperty,cbProperty)	\
    ( (This)->lpVtbl -> SetProperty(This,PropertyId,pvProperty,cbProperty) ) 

#define IAssemblyName_GetProperty(This,PropertyId,pvProperty,pcbProperty)	\
    ( (This)->lpVtbl -> GetProperty(This,PropertyId,pvProperty,pcbProperty) ) 

#define IAssemblyName_Finalize(This)	\
    ( (This)->lpVtbl -> Finalize(This) ) 

#define IAssemblyName_GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)	\
    ( (This)->lpVtbl -> GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags) ) 

#define IAssemblyName_Reserved(This,refIID,pUnkReserved1,pUnkReserved2,szReserved,llReserved,pvReserved,cbReserved,ppReserved)	\
    ( (This)->lpVtbl -> Reserved(This,refIID,pUnkReserved1,pUnkReserved2,szReserved,llReserved,pvReserved,cbReserved,ppReserved) ) 

#define IAssemblyName_GetName(This,lpcwBuffer,pwzName)	\
    ( (This)->lpVtbl -> GetName(This,lpcwBuffer,pwzName) ) 

#define IAssemblyName_GetVersion(This,pdwVersionHi,pdwVersionLow)	\
    ( (This)->lpVtbl -> GetVersion(This,pdwVersionHi,pdwVersionLow) ) 

#define IAssemblyName_IsEqual(This,pName,dwCmpFlags)	\
    ( (This)->lpVtbl -> IsEqual(This,pName,dwCmpFlags) ) 

#define IAssemblyName_Clone(This,pName)	\
    ( (This)->lpVtbl -> Clone(This,pName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAssemblyName_INTERFACE_DEFINED__ */


#ifndef __IAssemblyCacheItem_INTERFACE_DEFINED__
#define __IAssemblyCacheItem_INTERFACE_DEFINED__

/* interface IAssemblyCacheItem */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyCacheItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e3aaeb4-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCacheItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortItem( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCacheItem * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCacheItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCacheItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStream )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *AbortItem )( 
            IAssemblyCacheItem * This);
        
        END_INTERFACE
    } IAssemblyCacheItemVtbl;

    interface IAssemblyCacheItem
    {
        CONST_VTBL struct IAssemblyCacheItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCacheItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAssemblyCacheItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAssemblyCacheItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAssemblyCacheItem_CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)	\
    ( (This)->lpVtbl -> CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize) ) 

#define IAssemblyCacheItem_Commit(This,dwFlags,pulDisposition)	\
    ( (This)->lpVtbl -> Commit(This,dwFlags,pulDisposition) ) 

#define IAssemblyCacheItem_AbortItem(This)	\
    ( (This)->lpVtbl -> AbortItem(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAssemblyCacheItem_INTERFACE_DEFINED__ */


#ifndef __IAssemblyCache_INTERFACE_DEFINED__
#define __IAssemblyCache_INTERFACE_DEFINED__

/* interface IAssemblyCache */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e707dcde-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UninstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAssemblyInfo( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyCacheItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reserved( 
            /* [out] */ IUnknown **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCache * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *UninstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAssemblyInfo )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyCacheItem )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *Reserved )( 
            IAssemblyCache * This,
            /* [out] */ IUnknown **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *InstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData);
        
        END_INTERFACE
    } IAssemblyCacheVtbl;

    interface IAssemblyCache
    {
        CONST_VTBL struct IAssemblyCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCache_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAssemblyCache_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAssemblyCache_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAssemblyCache_UninstallAssembly(This,dwFlags,pszAssemblyName,pRefData,pulDisposition)	\
    ( (This)->lpVtbl -> UninstallAssembly(This,dwFlags,pszAssemblyName,pRefData,pulDisposition) ) 

#define IAssemblyCache_QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)	\
    ( (This)->lpVtbl -> QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo) ) 

#define IAssemblyCache_CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)	\
    ( (This)->lpVtbl -> CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName) ) 

#define IAssemblyCache_Reserved(This,ppUnk)	\
    ( (This)->lpVtbl -> Reserved(This,ppUnk) ) 

#define IAssemblyCache_InstallAssembly(This,dwFlags,pszManifestFilePath,pRefData)	\
    ( (This)->lpVtbl -> InstallAssembly(This,dwFlags,pszManifestFilePath,pRefData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAssemblyCache_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_winsxs_0000_0003 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_winsxs_0000_0003_0001
    {	CANOF_PARSE_DISPLAY_NAME	= 0x1,
	CANOF_SET_DEFAULT_VALUES	= 0x2
    } 	CREATE_ASM_NAME_OBJ_FLAGS;

STDAPI CreateAssemblyNameObject(LPASSEMBLYNAME *ppAssemblyNameObj, LPCWSTR szAssemblyName, DWORD dwFlags, LPVOID pvReserved);             
STDAPI CreateAssemblyCache(IAssemblyCache **ppAsmCache, DWORD dwReserved); 
#endif


extern RPC_IF_HANDLE __MIDL_itf_winsxs_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_winsxs_0000_0003_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\winternl.h ===
/************************************************************************
*                                                                       *
*   winternl.h -- This module defines the internal NT APIs and data     *
*       structures that are intended for the use only by internal core  *
*       Windows components.  These APIs and data structures may change  *
*       at any time.                                                    *
*                                                                       *
*   These APIs and data structures are subject to changes from one      *
*       Windows release to another Windows release.  To maintain the    *
*       compatiblity of your application, avoid using these APIs and    *
*       data structures.                                                *
*                                                                       *
*   The appropriate mechanism for accessing the functions defined in    *
*       this header is to use LoadLibrary() for ntdll.dll and           *
*       GetProcAddress() for the particular function.  By using this    *
*       approach, your application will be more resilient to changes    *
*       for these functions between Windows releases.  If a function    *
*       prototype does change, then GetProcAddress() for that function  *
*       might detect the change and fail the function call, which your  *
*       application will be able to detect.  GetProcAddress() may not   *
*       be able to detect all signature changes, thus avoid using these *
*       internal functions.  Instead, your application should use the   *
*       appropriate Win32 function that provides equivalent or similiar *
*       functionality.                                                  *
*                                                                       *
*   Copyright (c) Microsoft Corp. All rights reserved.                  *
*                                                                       *
************************************************************************/

#ifndef _WINTERNL_
#define _WINTERNL_

#if (_WIN32_WINNT >= 0x0500)

#include <windef.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// These data structures and type definitions are needed for compilation and
// use of the internal Windows APIs defined in this header.
//

typedef __success(return >= 0) LONG NTSTATUS;

typedef CONST char *PCSZ;

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;
typedef PSTRING PCANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;
typedef CONST STRING* PCOEM_STRING;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

//
// The PEB_LDR_DATA, LDR_DATA_TABLE_ENTRY, RTL_USER_PROCESS_PARAMETERS, PEB
// and TEB structures are subject to changes between Windows releases; thus,
// the field offsets and reserved fields may change. The reserved fields are
// reserved for use only by the Windows operating systems. Do not assume a
// maximum size for these structures.
//
// Instead of using the InMemoryOrderModuleList field of the
//     LDR_DATA_TABLE_ENTRY structure, use the Win32 API EnumProcessModules
//
// Instead of using the IsBeingDebugged field of the PEB structure, use the
//     Win32 APIs IsDebuggerPresent or CheckRemoteDebuggerPresent
//
// Instead of using the SessionId field of the PEB structure, use the Win32
//     APIs GetCurrentProcessId and ProcessIdToSessionId
//
// Instead of using the Tls fields of the TEB structure, use the Win32 APIs
//     TlsAlloc, TlsGetValue, TlsSetValue and TlsFree
//
// Instead of using the ReservedForOle field, use the COM API
//     CoGetContextToken
//
// Sample x86 assembly code that gets the SessionId (subject to change
//     between Windows releases, use the Win32 APIs to make your application
//     resilient to changes)
//     mov     eax,fs:[00000018]
//     mov     eax,[eax+0x30]
//     mov     eax,[eax+0x1d4]
//

typedef struct _PEB_LDR_DATA {
    BYTE Reserved1[8];
    PVOID Reserved2[3];
    LIST_ENTRY InMemoryOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY {
    PVOID Reserved1[2];
    LIST_ENTRY InMemoryOrderLinks;
    PVOID Reserved2[2];
    PVOID DllBase;
    PVOID Reserved3[2];
    UNICODE_STRING FullDllName;
    BYTE Reserved4[8];
    PVOID Reserved5[3];
    union {
        ULONG CheckSum;
        PVOID Reserved6;
    } DUMMYUNIONNAME;
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
    BYTE Reserved1[16];
    PVOID Reserved2[10];
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

typedef
VOID
(NTAPI *PPS_POST_PROCESS_INIT_ROUTINE) (
    VOID
    );

typedef struct _PEB {
    BYTE Reserved1[2];
    BYTE BeingDebugged;
    BYTE Reserved2[1];
    PVOID Reserved3[2];
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    BYTE Reserved4[104];
    PVOID Reserved5[52];
    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
    BYTE Reserved6[128];
    PVOID Reserved7[1];
    ULONG SessionId;
} PEB, *PPEB;

typedef struct _TEB {
    BYTE Reserved1[1952];
    PVOID Reserved2[412];
    PVOID TlsSlots[64];
    BYTE Reserved3[8];
    PVOID Reserved4[26];
    PVOID ReservedForOle;  // Windows 2000 only
    PVOID Reserved5[4];
    PVOID TlsExpansionSlots;
} TEB, *PTEB;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    } DUMMYUNIONNAME;

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef
VOID
(NTAPI *PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

typedef struct _PROCESS_BASIC_INFORMATION {
    PVOID Reserved1;
    PPEB PebBaseAddress;
    PVOID Reserved2[2];
    ULONG_PTR UniqueProcessId;
    PVOID Reserved3;
} PROCESS_BASIC_INFORMATION;
typedef PROCESS_BASIC_INFORMATION *PPROCESS_BASIC_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
    LARGE_INTEGER IdleTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER Reserved1[2];
    ULONG Reserved2;
} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION, *PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    BYTE Reserved1[52];
    PVOID Reserved2[3];
    HANDLE UniqueProcessId;
    PVOID Reserved3;
    ULONG HandleCount;
    BYTE Reserved4[4];
    PVOID Reserved5[11];
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER Reserved6[6];
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef struct _SYSTEM_REGISTRY_QUOTA_INFORMATION {
    ULONG RegistryQuotaAllowed;
    ULONG RegistryQuotaUsed;
    PVOID Reserved1;
} SYSTEM_REGISTRY_QUOTA_INFORMATION, *PSYSTEM_REGISTRY_QUOTA_INFORMATION;

typedef struct _SYSTEM_BASIC_INFORMATION {
    BYTE Reserved1[24];
    PVOID Reserved2[4];
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION {
    BYTE Reserved1[48];
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

typedef struct _SYSTEM_PERFORMANCE_INFORMATION {
    BYTE Reserved1[312];
} SYSTEM_PERFORMANCE_INFORMATION, *PSYSTEM_PERFORMANCE_INFORMATION;

typedef struct _SYSTEM_EXCEPTION_INFORMATION {
    BYTE Reserved1[16];
} SYSTEM_EXCEPTION_INFORMATION, *PSYSTEM_EXCEPTION_INFORMATION;

typedef struct _SYSTEM_LOOKASIDE_INFORMATION {
    BYTE Reserved1[32];
} SYSTEM_LOOKASIDE_INFORMATION, *PSYSTEM_LOOKASIDE_INFORMATION;

typedef struct _SYSTEM_INTERRUPT_INFORMATION {
    BYTE Reserved1[24];
} SYSTEM_INTERRUPT_INFORMATION, *PSYSTEM_INTERRUPT_INFORMATION;

typedef enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1
} FILE_INFORMATION_CLASS;

typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation = 0,
    ProcessWow64Information = 26
} PROCESSINFOCLASS;

typedef enum _THREADINFOCLASS {
    ThreadIsIoPending = 16
} THREADINFOCLASS;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemProcessInformation = 5,
    SystemProcessorPerformanceInformation = 8,
    SystemInterruptInformation = 23,
    SystemExceptionInformation = 33,
    SystemRegistryQuotaInformation = 37,
    SystemLookasideInformation = 45
} SYSTEM_INFORMATION_CLASS;

//
// Object Information Classes
//

typedef enum _OBJECT_INFORMATION_CLASS {
    ObjectBasicInformation = 0,
    ObjectTypeInformation = 2
} OBJECT_INFORMATION_CLASS;

//
//  Public Object Information definitions
//

typedef struct _PUBLIC_OBJECT_BASIC_INFORMATION {
    ULONG Attributes;
    ACCESS_MASK GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;

    ULONG Reserved[10];    // reserved for internal use

} PUBLIC_OBJECT_BASIC_INFORMATION, *PPUBLIC_OBJECT_BASIC_INFORMATION;

typedef struct __PUBLIC_OBJECT_TYPE_INFORMATION {

    UNICODE_STRING TypeName;

    ULONG Reserved [22];    // reserved for internal use

} PUBLIC_OBJECT_TYPE_INFORMATION, *PPUBLIC_OBJECT_TYPE_INFORMATION;

#if (_WIN32_WINNT >= 0x0501)
//
// use the WTS API instead
//     WTSGetActiveConsoleSessionId
// The active console id is cached as a volatile ULONG in a constant
// memory location.  This x86 memory location is subject to changes between
// Windows releases.  Use the WTS API to make your application resilient to
// changes.
//
#define INTERNAL_TS_ACTIVE_CONSOLE_ID ( *((volatile ULONG*)(0x7ffe02d8)) )
#endif // (_WIN32_WINNT >= 0x0501)

//
// These functions are intended for use by internal core Windows components
// since these functions may change between Windows releases.
//

#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))

//
// use the Win32 API instead
//     CloseHandle
//
__kernel_entry NTSTATUS
NTAPI 
NtClose (
    IN HANDLE Handle
    );

//
// use the Win32 API instead
//     CreateFile
//
__kernel_entry NTSTATUS
NTAPI 
NtCreateFile (
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

//
// use the Win32 API instead
//     CreateFile
//
__kernel_entry NTSTATUS
NTAPI 
NtOpenFile (
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );

//
// use the Win32 API instead
//     DeviceIoControl
//
__kernel_entry NTSTATUS
NTAPI 
NtDeviceIoControlFile (
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

//
// use the Win32 API instead
//     WaitForSingleObjectEx
//
NTSTATUS
NTAPI 
NtWaitForSingleObject (
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

//
// use the Win32 API instead
//     CheckNameLegalDOS8Dot3
//
BOOLEAN
NTAPI 
RtlIsNameLegalDOS8Dot3 (
    IN PUNICODE_STRING Name,
    IN OUT POEM_STRING OemName OPTIONAL,
    IN OUT PBOOLEAN NameContainsSpaces OPTIONAL
    );

//
// This function might be needed for some of the internal Windows functions,
// defined in this header file.
//
ULONG
NTAPI 
RtlNtStatusToDosError (
   NTSTATUS Status
   );

//
// use the Win32 APIs instead
//     GetProcessHandleCount
//     GetProcessId
//
__kernel_entry NTSTATUS
NTAPI 
NtQueryInformationProcess (
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

//
// use the Win32 API instead
//     GetThreadIOPendingFlag
//
__kernel_entry NTSTATUS
NTAPI 
NtQueryInformationThread (
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

//
// use the Win32 APIs instead
//     GetFileInformationByHandle
//     GetFileInformationByHandleEx
//     GetProcessInformation
//     GetThreadInformation
//     

__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryObject (
    __in_opt HANDLE Handle,
    __in OBJECT_INFORMATION_CLASS ObjectInformationClass,
    __out_bcount_opt(ObjectInformationLength) PVOID ObjectInformation,
    __in ULONG ObjectInformationLength,
    __out_opt PULONG ReturnLength
    );

//
// use the Win32 APIs instead
//     GetSystemRegistryQuota
//     GetSystemTimes
// use the CryptoAPIs instead for generating random data
//     CryptGenRandom
//
__kernel_entry NTSTATUS
NTAPI 
NtQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

//
// use the Win32 API instead
//     GetSystemTimeAsFileTime
//
__kernel_entry NTSTATUS
NTAPI 
NtQuerySystemTime (
    OUT PLARGE_INTEGER SystemTime
    );

//
// use the Win32 API instead
//     LocalFileTimeToFileTime
//
NTSTATUS
NTAPI 
RtlLocalTimeToSystemTime (
    IN PLARGE_INTEGER LocalTime,
    OUT PLARGE_INTEGER SystemTime
    );

//
// use the Win32 API instead
//     SystemTimeToFileTime to convert to FILETIME structures
//     copy the resulting FILETIME structures to ULARGE_INTEGER structures
//     perform the calculation
//
BOOLEAN
NTAPI 
RtlTimeToSecondsSince1970 (
    PLARGE_INTEGER Time,
    PULONG ElapsedSeconds
    );

//
// These APIs might be need for some of the internal Windows functions,
// defined in this header file.
//
VOID
NTAPI 
RtlFreeAnsiString (
    PANSI_STRING AnsiString
    );

VOID
NTAPI 
RtlFreeUnicodeString (
    PUNICODE_STRING UnicodeString
    );

VOID
NTAPI 
RtlFreeOemString(
    POEM_STRING OemString
    );

VOID
NTAPI 
RtlInitString (
    PSTRING DestinationString,
    PCSZ SourceString
    );

VOID
NTAPI 
RtlInitAnsiString (
    PANSI_STRING DestinationString,
    PCSZ SourceString
    );

VOID
NTAPI 
RtlInitUnicodeString (
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

NTSTATUS
NTAPI 
RtlAnsiStringToUnicodeString (
    PUNICODE_STRING DestinationString,
    PCANSI_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI 
RtlUnicodeStringToAnsiString (
    PANSI_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI 
RtlUnicodeStringToOemString(
    POEM_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

//
// Use the Win32 API instead
//     WideCharToMultiByte
//     set CodePage to CP_ACP
//     set cbMultiByte to 0
//
NTSTATUS
NTAPI 
RtlUnicodeToMultiByteSize(
    __out PULONG BytesInMultiByteString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString
    );

//
// Use the C runtime function instead
//     strtol
//
NTSTATUS
NTAPI 
RtlCharToInteger (
    PCSZ String,
    ULONG Base,
    PULONG Value
    );

//
// use the Win32 API instead
//     ConvertSidToStringSid
//
NTSTATUS
NTAPI 
RtlConvertSidToUnicodeString (
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    );

//
// use the CryptoAPIs instead
//     CryptGenRandom
//
ULONG
NTAPI 
RtlUniform (
    PULONG Seed
    );


#define LOGONID_CURRENT     ((ULONG)-1)
#define SERVERNAME_CURRENT  ((HANDLE)NULL)

typedef enum _WINSTATIONINFOCLASS {
    WinStationInformation = 8
} WINSTATIONINFOCLASS;


typedef struct _WINSTATIONINFORMATIONW {
    BYTE Reserved2[70];
    ULONG LogonId;
    BYTE Reserved3[1140];
} WINSTATIONINFORMATIONW, * PWINSTATIONINFORMATIONW;

//
// this function is implemented in winsta.dll (you need to loadlibrary to call this function)
// this internal function retrives the LogonId (also called SessionId) for the current process
// You should avoid using this function as it can change. you can retrieve the same information 
// Using public api WTSQuerySessionInformation. Pass WTSSessionId as the WTSInfoClass parameter
// 
typedef BOOLEAN (WINAPI * PWINSTATIONQUERYINFORMATIONW)(
    HANDLE, ULONG, WINSTATIONINFOCLASS, PVOID, ULONG, PULONG );

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif

//
// Generic test for information on any status value.
//

#ifndef NT_INFORMATION
#define NT_INFORMATION(Status) ((((ULONG)(Status)) >> 30) == 1)
#endif

//
// Generic test for warning on any status value.
//

#ifndef NT_WARNING
#define NT_WARNING(Status) ((((ULONG)(Status)) >> 30) == 2)
#endif

//
// Generic test for error on any status value.
//

#ifndef NT_ERROR
#define NT_ERROR(Status) ((((ULONG)(Status)) >> 30) == 3)
#endif

//++
//
// VOID
// InitializeObjectAttributes(
//     OUT POBJECT_ATTRIBUTES p,
//     IN PUNICODE_STRING n,
//     IN ULONG a,
//     IN HANDLE r,
//     IN PSECURITY_DESCRIPTOR s
//     )
//
//--

#ifndef InitializeObjectAttributes
#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }
#endif

//
// Valid values for the Attributes field
//

#define OBJ_INHERIT             0x00000002L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_OPENLINK            0x00000100L
#define OBJ_KERNEL_HANDLE       0x00000200L
#define OBJ_FORCE_ACCESS_CHECK  0x00000400L
#define OBJ_VALID_ATTRIBUTES    0x000007F2L

//
// Define the create disposition values
//

#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005

//
// Define the create/open option flags
//

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_REMOTE_INSTANCE               0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define FILE_OPEN_REQUIRING_OPLOCK              0x00010000
#endif

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

//
// Define the I/O status information return values for NtCreateFile/NtOpenFile
//

#define FILE_SUPERSEDED                 0x00000000
#define FILE_OPENED                     0x00000001
#define FILE_CREATED                    0x00000002
#define FILE_OVERWRITTEN                0x00000003
#define FILE_EXISTS                     0x00000004
#define FILE_DOES_NOT_EXIST             0x00000005

#ifdef __cplusplus
}
#endif

#endif // (_WIN32_WINNT >= 0x0500)

#endif // _WINTERNL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WinTrust.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wintrust.h
//
//  Contents:   Microsoft Internet Security Trust Provider Model
//
//  History:    31-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef WINTRUST_H
#define WINTRUST_H

#include    <wincrypt.h>

#if defined(_MSC_VER) && (_MSC_VER >= 800)
    #if _MSC_VER > 1000
        #pragma once
    #endif
    #if _MSC_VER >= 1200
        #pragma warning(push)
    #endif
    #pragma warning(disable:4201) // nonstandard extension used : nameless struct/union
#endif

#ifdef __cplusplus
extern "C"
{
#endif


#ifndef WIN_CERT_REVISION_1_0   // there were duplicate definitions in winbase.h
#   define  WT_DEFINE_ALL_APIS
#else
#   undef   WT_DEFINE_ALL_APIS
#endif

#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////
//
// Wintrust Registry Configuration Definitions.
//
//////////////////////////////////////////////////////////////////////////////

#define WINTRUST_CONFIG_REGPATH L"Software\\Microsoft\\Cryptography\\Wintrust\\Config"

// The following are REG_DWORD's. These configuration parameters are used
// to limit the number of file bytes mapped at a time. Should be a multiple of
// dwAllocationGranularity returned by GetSystemInfo(). This allows
// very large files, > 2Gig bytes, to be authenticated signed and verified
// using a much smaller virtual memory address range.

// The length of the header bytes for a PE, CAB or any file that is
// authenticode signed must be less than the following value.
#define WINTRUST_MAX_HEADER_BYTES_TO_MAP_VALUE_NAME     L"MaxHeaderBytesToMap"
// 0x00A0'0000 (10,485,760) Bytes
#define WINTRUST_MAX_HEADER_BYTES_TO_MAP_DEFAULT        0x00A00000

// If the file size doesn't fit within the above header length, the following
// value is used to set the maximum number of remaining file bytes that are
// mapped/hashed/unmapped at time.
#define WINTRUST_MAX_HASH_BYTES_TO_MAP_VALUE_NAME       L"MaxHashBytesToMap"
// 0x0010'0000 (1,048,576) Bytes
#define WINTRUST_MAX_HASH_BYTES_TO_MAP_DEFAULT          0x00100000


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//      Client definitions, typedefs, and prototypes
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_DATA Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust to pass necessary information into
//  the Providers.
//
typedef struct _WINTRUST_DATA
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_DATA)

    LPVOID          pPolicyCallbackData;        // optional: used to pass data between the app and policy
    LPVOID          pSIPClientData;             // optional: used to pass data between the app and SIP.

    DWORD           dwUIChoice;                 // required: UI choice.  One of the following.
#                       define      WTD_UI_ALL              1
#                       define      WTD_UI_NONE             2
#                       define      WTD_UI_NOBAD            3
#                       define      WTD_UI_NOGOOD           4

    DWORD           fdwRevocationChecks;        // required: certificate revocation check options
#                       define      WTD_REVOKE_NONE         0x00000000
#                       define      WTD_REVOKE_WHOLECHAIN   0x00000001

    DWORD           dwUnionChoice;              // required: which structure is being passed in?
#                       define      WTD_CHOICE_FILE         1
#                       define      WTD_CHOICE_CATALOG      2
#                       define      WTD_CHOICE_BLOB         3
#                       define      WTD_CHOICE_SIGNER       4
#                       define      WTD_CHOICE_CERT         5
    union
    {
        struct WINTRUST_FILE_INFO_      *pFile;         // individual file
        struct WINTRUST_CATALOG_INFO_   *pCatalog;      // member of a Catalog File
        struct WINTRUST_BLOB_INFO_      *pBlob;         // memory blob
        struct WINTRUST_SGNR_INFO_      *pSgnr;         // signer structure only
        struct WINTRUST_CERT_INFO_      *pCert;
    };

    DWORD           dwStateAction;                      // optional (Catalog File Processing)
#                       define      WTD_STATEACTION_IGNORE           0x00000000
#                       define      WTD_STATEACTION_VERIFY           0x00000001
#                       define      WTD_STATEACTION_CLOSE            0x00000002
#                       define      WTD_STATEACTION_AUTO_CACHE       0x00000003
#                       define      WTD_STATEACTION_AUTO_CACHE_FLUSH 0x00000004

    HANDLE          hWVTStateData;                      // optional (Catalog File Processing)

    WCHAR           *pwszURLReference;          // optional: (future) used to determine zone.

    DWORD           dwProvFlags;
#       define WTD_PROV_FLAGS_MASK                      0x0000FFFF
#       define WTD_USE_IE4_TRUST_FLAG                   0x00000001
#       define WTD_NO_IE4_CHAIN_FLAG                    0x00000002
#       define WTD_NO_POLICY_USAGE_FLAG                 0x00000004
#       define WTD_REVOCATION_CHECK_NONE                0x00000010
#       define WTD_REVOCATION_CHECK_END_CERT            0x00000020
#       define WTD_REVOCATION_CHECK_CHAIN               0x00000040
#       define WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT  0x00000080
#       define WTD_SAFER_FLAG                           0x00000100
#       define WTD_HASH_ONLY_FLAG                       0x00000200
#       define WTD_USE_DEFAULT_OSVER_CHECK              0x00000400
#       define WTD_LIFETIME_SIGNING_FLAG                0x00000800
#       define WTD_CACHE_ONLY_URL_RETRIEVAL             0x00001000 // affects CRL retrieval and AIA retrieval

    DWORD           dwUIContext;
#       define WTD_UICONTEXT_EXECUTE                    0
#       define WTD_UICONTEXT_INSTALL                    1

} WINTRUST_DATA, *PWINTRUST_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_FILE_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against an individual file.
//
typedef struct WINTRUST_FILE_INFO_
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_FILE_INFO)

    LPCWSTR         pcwszFilePath;              // required, file name to be verified
    HANDLE          hFile;                      // optional, open handle to pcwszFilePath

    GUID            *pgKnownSubject;            // optional: fill if the subject type is known.

} WINTRUST_FILE_INFO, *PWINTRUST_FILE_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_CATALOG_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a member of a Microsoft Catalog
//  file.
//
typedef struct WINTRUST_CATALOG_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_CATALOG_INFO)

    DWORD           dwCatalogVersion;       // optional: Catalog version number
    LPCWSTR         pcwszCatalogFilePath;   // required: path/name to Catalog file

    LPCWSTR         pcwszMemberTag;         // optional: tag to member in Catalog
    LPCWSTR         pcwszMemberFilePath;    // required: path/name to member file
    HANDLE          hMemberFile;            // optional: open handle to pcwszMemberFilePath

    __field_ecount(cbCalculatedFileHash) BYTE            *pbCalculatedFileHash;  // optional: pass in the calculated hash
    DWORD           cbCalculatedFileHash;   // optional: pass in the count bytes of the calc hash

    PCCTL_CONTEXT   pcCatalogContext;       // optional: pass in to use instead of CatalogFilePath.

} WINTRUST_CATALOG_INFO, *PWINTRUST_CATALOG_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_BLOB_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a memory blob.
//
typedef struct WINTRUST_BLOB_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_BLOB_INFO)

    GUID            gSubject;               // SIP to load

    LPCWSTR         pcwszDisplayName;       // display name of object

    DWORD           cbMemObject;
    BYTE            *pbMemObject;

    DWORD           cbMemSignedMsg;
    BYTE            *pbMemSignedMsg;

} WINTRUST_BLOB_INFO, *PWINTRUST_BLOB_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_SGNR_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a CMSG_SIGNER_INFO Structure
//
typedef struct WINTRUST_SGNR_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_SGNR_INFO)

    LPCWSTR         pcwszDisplayName;       // name of the "thing" the pbMem is pointing to.

    CMSG_SIGNER_INFO *psSignerInfo;

    DWORD           chStores;               // number of stores in pahStores
    HCERTSTORE      *pahStores;             // array of stores to add to internal list

} WINTRUST_SGNR_INFO, *PWINTRUST_SGNR_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_CERT_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a CERT_CONTEXT Structure
//
typedef struct WINTRUST_CERT_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_CERT_INFO)

    LPCWSTR         pcwszDisplayName;       // display name

    CERT_CONTEXT    *psCertContext;

    DWORD           chStores;               // number of stores in pahStores
    HCERTSTORE      *pahStores;             // array of stores to add to internal list

    DWORD           dwFlags;
#                       define      WTCI_DONT_OPEN_STORES   0x00000001  // only open dummy "root" all other are in pahStores.
#                       define      WTCI_OPEN_ONLY_ROOT     0x00000002
#                       define      WTCI_USE_LOCAL_MACHINE  0x00000004 // Local machine context

    FILETIME        *psftVerifyAsOf;        // if not null, each cert will be validated as of this time.

} WINTRUST_CERT_INFO, *PWINTRUST_CERT_INFO;

#include <poppack.h>


//////////////////////////////////////////////////////////////////////////////
//
// WinVerifyTrust
//----------------------------------------------------------------------------
//  Exported from WINTRUST.DLL.
//  Call this function to verify the trust based on a digital signer.
//
//  pWVTData points to a WINTRUST_DATA data structure.
//
//  WTD_SAFER_FLAG should be set in WINTRUST_DATA's dwProvFlags to enable
//  the following semantics for the WINTRUST_ACTION_GENERIC_VERIFY_V2
//  policy provider specified in pgActionID:
//   - return TRUST_E_NOSIGNATURE if the subject isn't signed, has an
//     invalid signature or unable to find the signer certificate.
//     UI will never be displayed when not signed.
//   - ignore NO_CHECK revocation errors. Otherwise, continue to return
//     CERT_E_REVOCATION_FAILURE.
//   - search the code hash and publisher databases for the WTD_UI_NONE
//     dwUIChoice case. The default is to only search these databases when
//     UI has been enabled or user trust has been disabled.
//
//
//  Returns:
//          ERROR_SUCCESS               If the trust is authenticated or
//                                      if the user accepted the risk.
//
//          TRUST_E_PROVIDER_UNKNOWN    there was an error loading one of the
//                                      required Providers.
//
//          all error codes passed back are based on the Policy Provider used.
//
//  The following errors are returned when the
//  WINTRUST_ACTION_GENERIC_VERIFY_V2 policy provider is specified in
//  pgActionID:
//
//    TRUST_E_NOSIGNATURE (when WTD_SAFER_FLAG is set in dwProvFlags)
//      The subject isn't signed, has an invalid signature or unable
//      to find the signer certificate. All signature verification
//      errors will map to this error. Basically all errors except for
//      publisher or timestamp certificate verification.
//
//      Call GetLastError() to get the underlying reason for not having
//      a valid signature.
//
//      The following LastErrors indicate that the file doesn't have a
//      signature: TRUST_E_NOSIGNATURE, TRUST_E_SUBJECT_FORM_UNKNOWN or
//      TRUST_E_PROVIDER_UNKNOWN.
//
//      UI will never be displayed for this case.
//
//    TRUST_E_EXPLICIT_DISTRUST
//      Returned if the hash representing the subject is trusted as
//      AUTHZLEVELID_DISALLOWED or the publisher is in the "Disallowed"
//      store. Also returned if the publisher certificate is revoked.
//
//      UI will never be displayed for this case.
//
//    ERROR_SUCCESS
//      No UI unless noted below.
//
//      Returned for the following:
//       - Hash representing the subject is trusted as
//         AUTHZLEVELID_FULLYTRUSTED
//       - The publisher certificate exists in the
//         "TrustedPublisher" store and there weren't any verification errors.
//       - UI was enabled and the user clicked "Yes" when asked
//         to install and run the signed subject.
//       - UI was disabled. No publisher or timestamp chain error.
//
//    TRUST_E_SUBJECT_NOT_TRUSTED
//      UI was enabled and the the user clicked "No" when asked to install
//      and run the signed subject.
//
//    CRYPT_E_SECURITY_SETTINGS
//      The subject hash or publisher wasn't explicitly trusted and
//      user trust wasn't allowed in the safer authenticode flags.
//      No UI will be displayed for this case.
//
//      The subject is signed and its signature successfully
//      verified.
//
//    Any publisher or timestamp chain error. If WTD_SAFER_FLAG wasn't set in
//    dwProvFlags, any signed code verification error.
//
extern LONG WINAPI WinVerifyTrust(HWND hwnd, GUID *pgActionID,
                                  LPVOID pWVTData);


//////////////////////////////////////////////////////////////////////////////
//
// WinVerifyTrustEx
//----------------------------------------------------------------------------
//      *** DO NOT USE ***
//
//
extern HRESULT WINAPI WinVerifyTrustEx(HWND hwnd, GUID *pgActionID,
                                       WINTRUST_DATA *pWinTrustData);


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//      Trust, Policy, and UI Provider definitions, typedefs, and prototypes
//
//  Model:
//      A client wishing to validate trust through WinVerifyTrust will
//      select an appropriate Action ID guid for the call.
//      This guid is defined by each Policy Provider and represents the
//      functions called based on the policy for the given object.
//
//      In this model, the Policy Provider determines which style of UI
//      will be shown to the user (this only applies to style, the
//      determination of whether UI is displayed is set by the calling client
//      in the UI flags member of WINTRUST_DATA).
//
//      Since the function entry points are common (same return value and
//      parameters), it allows Policy Provider developers to take advantage
//      of existing, generic, code to fill the CRYPT_PROVIDER_DATA structure.
//
//      This also allows the developer to simply add the specific policy they
//      need, then, call the generic Policy Provider - if appropriate.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// Wintrust Policy Flags
//----------------------------------------------------------------------------
//  These are set during install and can be modified by the user
//  through various means.  The SETREG.EXE utility (found in the Authenticode
//  Tools Pack) will select/deselect each of them.
//
#define WTPF_TRUSTTEST              0x00000020  // trust any "TEST" certificate
#define WTPF_TESTCANBEVALID         0x00000080
#define WTPF_IGNOREEXPIRATION       0x00000100  // Use expiration date
#define WTPF_IGNOREREVOKATION       0x00000200  // Do revocation check
#define WTPF_OFFLINEOK_IND          0x00000400  // off-line is ok individual certs
#define WTPF_OFFLINEOK_COM          0x00000800  // off-line is ok commercial certs
#define WTPF_OFFLINEOKNBU_IND       0x00001000  // off-line is ok individual certs, no bad ui
#define WTPF_OFFLINEOKNBU_COM       0x00002000  // off-line is ok commercial certs, no bad ui
#define WTPF_VERIFY_V1_OFF          0x00010000  // turn verify of v1 certs off
#define WTPF_IGNOREREVOCATIONONTS   0x00020000  // ignore TimeStamp revocation checks
#define WTPF_ALLOWONLYPERTRUST      0x00040000  // allow only items in personal trust db.

//////////////////////////////////////////////////////////////////////////////
//
// WintrustGetRegPolicyFlags
//----------------------------------------------------------------------------
//  This API call is exported from WINTRUST.DLL and is the recommended method
//  of retrieving the DWORD representing the Policy Flags.
//
extern void WINAPI      WintrustGetRegPolicyFlags(DWORD *pdwPolicyFlags);

//////////////////////////////////////////////////////////////////////////////
//
// WintrustSetRegPolicyFlags
//----------------------------------------------------------------------------
//  This API call is exported from WINTRUST.DLL and is the recommended method
//  of setting the DWORD representing the Policy Flags.  MAKE SURE to call
//  WintrustGetRegPolicyFlags to get the current value and or/and the value
//  you need then call the set the flags.
//
extern BOOL WINAPI      WintrustSetRegPolicyFlags(DWORD dwPolicyFlags);



//////////////////////////////////////////////////////////////////////////////
//
// Trust Provider "Step" Error defines
//----------------------------------------------------------------------------
//  Each "step" of the Trust process has an error "slot" associated with it.
//  If an error occurs, the "step" will assign its result to this "slot".  These
//  errors can be any valid WINERROR.H HRESULT code.
//

    //
    //  step errors 0 through 20 are reserved for Authenticode specific.  If
    //  you are not calling any of the SOFTPUB.DLL (Authenticode) providers, you
    //  may use these as needed.
    //
#define TRUSTERROR_STEP_WVTPARAMS                   0
#define TRUSTERROR_STEP_FILEIO                      2
#define TRUSTERROR_STEP_SIP                         3
#define TRUSTERROR_STEP_SIPSUBJINFO                 5
#define TRUSTERROR_STEP_CATALOGFILE                 6
#define TRUSTERROR_STEP_CERTSTORE                   7
#define TRUSTERROR_STEP_MESSAGE                     8
#define TRUSTERROR_STEP_MSG_SIGNERCOUNT             9
#define TRUSTERROR_STEP_MSG_INNERCNTTYPE            10
#define TRUSTERROR_STEP_MSG_INNERCNT                11
#define TRUSTERROR_STEP_MSG_STORE                   12
#define TRUSTERROR_STEP_MSG_SIGNERINFO              13
#define TRUSTERROR_STEP_MSG_SIGNERCERT              14
#define TRUSTERROR_STEP_MSG_CERTCHAIN               15
#define TRUSTERROR_STEP_MSG_COUNTERSIGINFO          16
#define TRUSTERROR_STEP_MSG_COUNTERSIGCERT          17
#define TRUSTERROR_STEP_VERIFY_MSGHASH              18
#define TRUSTERROR_STEP_VERIFY_MSGINDIRECTDATA      19

    //
    //  step errors 30 through 37 are reserved for the ending error code for each
    //  entry point in the Trust Model.
    //
#define TRUSTERROR_STEP_FINAL_WVTINIT               30
#define TRUSTERROR_STEP_FINAL_INITPROV              31
#define TRUSTERROR_STEP_FINAL_OBJPROV               32
#define TRUSTERROR_STEP_FINAL_SIGPROV               33
#define TRUSTERROR_STEP_FINAL_CERTPROV              34
#define TRUSTERROR_STEP_FINAL_CERTCHKPROV           35
#define TRUSTERROR_STEP_FINAL_POLICYPROV            36
#define TRUSTERROR_STEP_FINAL_UIPROV                37

#define TRUSTERROR_MAX_STEPS                        38

//////////////////////////////////////////////////////////////////////////////
//
//  allocation and free function prototypes
//----------------------------------------------------------------------------
//
typedef void        *(*PFN_CPD_MEM_ALLOC)(__in DWORD cbSize);
typedef void        (*PFN_CPD_MEM_FREE)(__in void *pvMem2Free);

struct _CRYPT_PROVIDER_DATA;
struct _CRYPT_PROVIDER_SGNR;
struct _CRYPT_PROVIDER_PRIVDATA;

typedef BOOL        (*PFN_CPD_ADD_STORE)(__in struct _CRYPT_PROVIDER_DATA *pProvData,
                                         __in HCERTSTORE hStore2Add);

typedef BOOL        (*PFN_CPD_ADD_SGNR)(__in          struct _CRYPT_PROVIDER_DATA *pProvData,
                                        __in          BOOL fCounterSigner,
                                        __in_opt      DWORD idxSigner,
                                        __in          struct _CRYPT_PROVIDER_SGNR *pSgnr2Add);

typedef BOOL        (*PFN_CPD_ADD_CERT)(__in          struct _CRYPT_PROVIDER_DATA *pProvData,
                                        __in          DWORD idxSigner,
                                        __in          BOOL fCounterSigner,
                                        __in_opt      DWORD idxCounterSigner,
                                        __in          PCCERT_CONTEXT pCert2Add);

typedef BOOL        (*PFN_CPD_ADD_PRIVDATA)(__in struct _CRYPT_PROVIDER_DATA *pProvData,
                                            __in struct _CRYPT_PROVIDER_PRIVDATA *pPrivData2Add);

//////////////////////////////////////////////////////////////////////////////
//
//  Provider function prototypes
//----------------------------------------------------------------------------
//

//
//  entry point for the object provider
//
typedef HRESULT     (*PFN_PROVIDER_INIT_CALL)(__inout struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the object provider
//
typedef HRESULT     (*PFN_PROVIDER_OBJTRUST_CALL)(__inout struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Signature Provider
//
typedef HRESULT     (*PFN_PROVIDER_SIGTRUST_CALL)(__inout struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Certificate Provider
//
typedef HRESULT     (*PFN_PROVIDER_CERTTRUST_CALL)(__inout struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's final call (from the trust provider)
//
typedef HRESULT     (*PFN_PROVIDER_FINALPOLICY_CALL)(__inout struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's "dump structure" call
//
typedef HRESULT     (*PFN_PROVIDER_TESTFINALPOLICY_CALL)(__inout struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's clean up routine for any PRIVDATA allocated
//
typedef HRESULT     (*PFN_PROVIDER_CLEANUP_CALL)(__inout struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's Cert Check call.  This will return
//  true if the Trust Provider is to continue building the certificate chain.
//  If the PP returns FALSE, it is assumed that we have reached a "TRUSTED",
//  self-signed, root.  it is also the CertCheck's responsibility to set the
//  fTrustedRoot flag in the certificate structure.
//
typedef BOOL        (*PFN_PROVIDER_CERTCHKPOLICY_CALL)( __in          struct _CRYPT_PROVIDER_DATA *pProvData,
                                                        __in          DWORD idxSigner,
                                                        __in          BOOL fCounterSignerChain,
                                                        __in_opt      DWORD idxCounterSigner);


#define WVT_OFFSETOF(t,f)   ((ULONG)((ULONG_PTR)(&((t*)0)->f)))

// WOB #1251526 -- macro must check whether _all_ bytes of the member
// lie within the struct size specified
#define WVT_ISINSTRUCT(structtypedef, structpassedsize, member) \
	((WVT_OFFSETOF(structtypedef, member) + sizeof(((structtypedef *) 0)->member) <= structpassedsize) ? TRUE : FALSE)


#define WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(structtypedef, structpassedsize, member) \
                    WVT_ISINSTRUCT(structtypedef, structpassedsize, member)

#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_DATA Structure
//----------------------------------------------------------------------------
//  Used to pass information between WinVerifyTrust and all of the Provider
//  calls.
//
//  IMPORTANT:  1.  All dynamically allocated members MUST use the allocation
//                  and Add2 functions provided.
//
typedef struct _CRYPT_PROVIDER_DATA
{
    DWORD                               cbStruct;               // = sizeof(TRUST_PROVIDER_DATA) (set in WVT)

    WINTRUST_DATA                       *pWintrustData;         // NOT verified (set in WVT)
    BOOL                                fOpenedFile;            // the provider opened the file handle (if applicable)
    HWND                                hWndParent;             // if passed in, else, Desktop hWnd (set in WVT).
    GUID                                *pgActionID;            // represents the Provider combination (set in WVT).

    HCRYPTPROV                          hProv;                  // set to NULL to let CryptoAPI to assign.

    DWORD                               dwError;                // error if a low-level, system error was encountered

    DWORD                               dwRegSecuritySettings;  // ie security settings (set in WVT)
    DWORD                               dwRegPolicySettings;    // setreg settings (set in WVT)

    struct _CRYPT_PROVIDER_FUNCTIONS    *psPfns;                // set in WVT.

    DWORD                               cdwTrustStepErrors;     // set in WVT.
    DWORD                               *padwTrustStepErrors;   // allocated in WVT.  filled in WVT & Trust Provider

    DWORD                               chStores;               // number of stores in pahStores (root set in WVT)
    HCERTSTORE                          *pahStores;             // array of known stores (root set in WVT) root is ALWAYS #0!!!

    DWORD                               dwEncoding;             // message encoding type (set in WVT and Signature Prov)
    HCRYPTMSG                           hMsg;                   // set in Signature Prov.

    DWORD                               csSigners;              // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_SGNR         *pasSigners;            // use Add2 and Get functions!

    DWORD                               csProvPrivData;         // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_PRIVDATA     *pasProvPrivData;       // use Add2 and Get functions!

    DWORD                               dwSubjectChoice;
#                       define              CPD_CHOICE_SIP          1

    union
    {
        struct _PROVDATA_SIP            *pPDSip;
    };

    char                                *pszUsageOID;           // set in Init Provider

    BOOL                                fRecallWithState;       // state was maintained for Catalog Files.

    FILETIME                            sftSystemTime;

    char                                *pszCTLSignerUsageOID;

    // LOWORD intialized from WINTRUST_DATA's dwProvFlags.
    DWORD                               dwProvFlags;
#       define CPD_USE_NT5_CHAIN_FLAG                   0x80000000
#       define CPD_REVOCATION_CHECK_NONE                0x00010000
#       define CPD_REVOCATION_CHECK_END_CERT            0x00020000
#       define CPD_REVOCATION_CHECK_CHAIN               0x00040000
#       define CPD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT  0x00080000

    DWORD                               dwFinalError;

    PCERT_USAGE_MATCH                                   pRequestUsage;

    DWORD                               dwTrustPubSettings;

    DWORD           dwUIStateFlags;
#       define CPD_UISTATE_MODE_PROMPT                  0x00000000
#       define CPD_UISTATE_MODE_BLOCK                   0x00000001
#       define CPD_UISTATE_MODE_ALLOW                   0x00000002
#       define CPD_UISTATE_MODE_MASK                    0x00000003

} CRYPT_PROVIDER_DATA, *PCRYPT_PROVIDER_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_FUNCTIONS structure
//----------------------------------------------------------------------------
//
typedef struct _CRYPT_PROVIDER_FUNCTIONS
{
    DWORD                               cbStruct;

    PFN_CPD_MEM_ALLOC                   pfnAlloc;               // set in WVT
    PFN_CPD_MEM_FREE                    pfnFree;                // set in WVT

    PFN_CPD_ADD_STORE                   pfnAddStore2Chain;      // call to add a store to the chain.
    PFN_CPD_ADD_SGNR                    pfnAddSgnr2Chain;       // call to add a sgnr struct to a msg struct sgnr chain
    PFN_CPD_ADD_CERT                    pfnAddCert2Chain;       // call to add a cert struct to a sgnr struct cert chain
    PFN_CPD_ADD_PRIVDATA                pfnAddPrivData2Chain;   // call to add provider private data to struct.

    PFN_PROVIDER_INIT_CALL              pfnInitialize;          // initialize Policy data.
    PFN_PROVIDER_OBJTRUST_CALL          pfnObjectTrust;         // build info up to the signer info(s).
    PFN_PROVIDER_SIGTRUST_CALL          pfnSignatureTrust;      // build info to the signing cert
    PFN_PROVIDER_CERTTRUST_CALL         pfnCertificateTrust;    // build the chain
    PFN_PROVIDER_FINALPOLICY_CALL       pfnFinalPolicy;         // final call to policy
    PFN_PROVIDER_CERTCHKPOLICY_CALL     pfnCertCheckPolicy;     // check each cert will building chain
    PFN_PROVIDER_TESTFINALPOLICY_CALL   pfnTestFinalPolicy;     // dump structures to a file (or whatever the policy chooses)

    struct _CRYPT_PROVUI_FUNCS          *psUIpfns;

    PFN_PROVIDER_CLEANUP_CALL           pfnCleanupPolicy;       // PRIVDATA cleanup routine.

} CRYPT_PROVIDER_FUNCTIONS, *PCRYPT_PROVIDER_FUNCTIONS;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVUI_FUNCS structure
//----------------------------------------------------------------------------
//

typedef BOOL        (*PFN_PROVUI_CALL)(__in HWND hWndSecurityDialog, __in struct _CRYPT_PROVIDER_DATA *pProvData);

typedef struct _CRYPT_PROVUI_FUNCS
{
    DWORD                               cbStruct;

    struct _CRYPT_PROVUI_DATA           *psUIData;

    PFN_PROVUI_CALL                     pfnOnMoreInfoClick;
    PFN_PROVUI_CALL                     pfnOnMoreInfoClickDefault;

    PFN_PROVUI_CALL                     pfnOnAdvancedClick;
    PFN_PROVUI_CALL                     pfnOnAdvancedClickDefault;

} CRYPT_PROVUI_FUNCS, *PCRYPT_PROVUI_FUNCS;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVUI_DATA
//----------------------------------------------------------------------------
//
typedef struct _CRYPT_PROVUI_DATA
{
    DWORD                               cbStruct;

    DWORD                               dwFinalError;

    WCHAR                               *pYesButtonText;        // default: "&Yes"
    WCHAR                               *pNoButtonText;         // default: "&No"
    WCHAR                               *pMoreInfoButtonText;   // default: "&More Info"
    WCHAR                               *pAdvancedLinkText;     // default: <none>

        // good: default:
                // "Do you want to install and run ""%1"" signed on %2 and distributed by:"
    WCHAR                               *pCopyActionText;
        // good no time stamp: default:
                // "Do you want to install and run ""%1"" signed on an unknown date/time and distributed by:"
    WCHAR                               *pCopyActionTextNoTS;
        // bad: default:
                // "Do you want to install and run ""%1""?"
    WCHAR                               *pCopyActionTextNotSigned;


} CRYPT_PROVUI_DATA, *PCRYPT_PROVUI_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_SGNR structure
//----------------------------------------------------------------------------
//  After the Signature Provider is finished there will be zero to many of these
//  filled out.  One for each signer of the message.  Also, there will be zero
//  to many of these filled out inside this structure.  One for each counter
//  signer of the signer.
//
//  IMPORTANT:  1.  All dynamically allocated members MUST use allocation
//                  and Add2 functions provided.
//
typedef struct _CRYPT_PROVIDER_SGNR
{
    DWORD                               cbStruct;

    FILETIME                            sftVerifyAsOf;      // either today's filetime or the timestamps

    DWORD                               csCertChain;        // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_CERT         *pasCertChain;      // use Add2 and Get functions!

    DWORD                               dwSignerType;       // set if known by policy
#                                           define  SGNR_TYPE_TIMESTAMP     0x00000010

    CMSG_SIGNER_INFO                    *psSigner;          // must use the pfnAlloc allocator!

    DWORD                               dwError;            // error encounted while building/verifying the signer.

    DWORD                               csCounterSigners;   // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_SGNR         *pasCounterSigners; // use Add2 and Get functions!

    PCCERT_CHAIN_CONTEXT                pChainContext;

} CRYPT_PROVIDER_SGNR, *PCRYPT_PROVIDER_SGNR;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_CERT structure
//----------------------------------------------------------------------------
//  After the Signature and Certificate Providers are finished there will
//  be zero to many of these filled out in the CRYPT_PROVIDER_SGNR
//  structure.  One for each certificate in the chain.
//
//
typedef struct _CRYPT_PROVIDER_CERT
{
    DWORD                               cbStruct;

    PCCERT_CONTEXT                      pCert;              // must have its own ref-count!

    BOOL                                fCommercial;
    BOOL                                fTrustedRoot;       // certchk policy should set this.
    BOOL                                fSelfSigned;        // set in cert provider

    BOOL                                fTestCert;          // certchk policy will set

    DWORD                               dwRevokedReason;

    DWORD                               dwConfidence;       // set in the Certificate Provider
#                                           define  CERT_CONFIDENCE_SIG             0x10000000  // this cert
#                                           define  CERT_CONFIDENCE_TIME            0x01000000  // issuer cert
#                                           define  CERT_CONFIDENCE_TIMENEST        0x00100000  // this cert
#                                           define  CERT_CONFIDENCE_AUTHIDEXT       0x00010000  // this cert
#                                           define  CERT_CONFIDENCE_HYGIENE         0x00001000  // this cert
#                                           define  CERT_CONFIDENCE_HIGHEST         0x11111000

    DWORD                               dwError;

    CTL_CONTEXT                         *pTrustListContext;

    BOOL                                fTrustListSignerCert;

    //
    // The following two are only applicable to Self Signed certificates
    // residing in a CTL.
    PCCTL_CONTEXT                       pCtlContext;
    DWORD                               dwCtlError;

    BOOL                                fIsCyclic;

    PCERT_CHAIN_ELEMENT                 pChainElement;
} CRYPT_PROVIDER_CERT, *PCRYPT_PROVIDER_CERT;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_PRIVDATA structure
//----------------------------------------------------------------------------
//  This structure is to allow Policy Provider functions to share
//  POLICY SPECIFIC data between Policy Functions.
//  The Policy must use the pfnAddPrivateData2Chain function and
//  must free any data within the member before the Final Policy returns
//  to WVT.
//  To allow multiple providers to use this feature, each provider that
//  uses this member must set the provider ID to it's Action ID so that
//  the provider can find its data and ignore any other.
//
typedef struct _CRYPT_PROVIDER_PRIVDATA
{
    DWORD                               cbStruct;

    GUID                                gProviderID;

    DWORD                               cbProvData;
    void                                *pvProvData;

} CRYPT_PROVIDER_PRIVDATA, *PCRYPT_PROVIDER_PRIVDATA;

//////////////////////////////////////////////////////////////////////////////
//
// PROVDATA_SIP
//----------------------------------------------------------------------------
//
typedef struct _PROVDATA_SIP
{
    DWORD                               cbStruct;               // = sizeof(PROVDATA_SIP)

    GUID                                gSubject;               // subject guid of file/member file. (set in Sig Prov)

    struct SIP_DISPATCH_INFO_           *pSip;                  // set in Sig Prov - defined in sipbase.h
    struct SIP_DISPATCH_INFO_           *pCATSip;               // set in Sig Prov - defined in sipbase.h
    struct SIP_SUBJECTINFO_             *psSipSubjectInfo;      // set in Sig Prov - defined in sipbase.h
    struct SIP_SUBJECTINFO_             *psSipCATSubjectInfo;   // set in Sig Prov - defined in sipbase.h
    struct SIP_INDIRECT_DATA_           *psIndirectData;        // set in Sig Prov - defined in sipbase.h

} PROVDATA_SIP, *PPROVDATA_SIP;

//////////////////////////////////////////////////////////////////////////////
//
// structures used to register action IDs
//----------------------------------------------------------------------------
//
#define WT_CURRENT_VERSION                  0x00000200

typedef struct _CRYPT_TRUST_REG_ENTRY
{
    DWORD                               cbStruct;

    WCHAR                               *pwszDLLName;
    WCHAR                               *pwszFunctionName;  // no more than WT_MAX_FUNC_NAME!

} CRYPT_TRUST_REG_ENTRY, *PCRYPT_TRUST_REG_ENTRY;

typedef struct _CRYPT_REGISTER_ACTIONID
{
    DWORD                               cbStruct;

    CRYPT_TRUST_REG_ENTRY               sInitProvider;
    CRYPT_TRUST_REG_ENTRY               sObjectProvider;
    CRYPT_TRUST_REG_ENTRY               sSignatureProvider;
    CRYPT_TRUST_REG_ENTRY               sCertificateProvider;
    CRYPT_TRUST_REG_ENTRY               sCertificatePolicyProvider;
    CRYPT_TRUST_REG_ENTRY               sFinalPolicyProvider;
    CRYPT_TRUST_REG_ENTRY               sTestPolicyProvider;

    CRYPT_TRUST_REG_ENTRY               sCleanupProvider;

} CRYPT_REGISTER_ACTIONID, *PCRYPT_REGISTER_ACTIONID;

struct _CRYPT_PROVIDER_DEFUSAGE;

typedef BOOL (*PFN_ALLOCANDFILLDEFUSAGE)(__in const char *pszUsageOID,
                                         __in struct _CRYPT_PROVIDER_DEFUSAGE *psDefUsage);
typedef BOOL (*PFN_FREEDEFUSAGE)(__in const char *pszUsageOID,
                                 __in struct _CRYPT_PROVIDER_DEFUSAGE *psDefUsage);

typedef struct _CRYPT_PROVIDER_REGDEFUSAGE
{
    DWORD                   cbStruct;   // = sizeof CRYPT_PROVIDER_REGDEFUSAGE

    GUID                    *pgActionID;

    WCHAR                   *pwszDllName;
    char                    *pwszLoadCallbackDataFunctionName;
    char                    *pwszFreeCallbackDataFunctionName;

} CRYPT_PROVIDER_REGDEFUSAGE, *PCRYPT_PROVIDER_REGDEFUSAGE;

typedef struct _CRYPT_PROVIDER_DEFUSAGE
{
    DWORD                   cbStruct;               // = sizeof CRYPT_PROVIDER_DEFUSAGE

    GUID                    gActionID;            // ActionID of provider

    LPVOID                  pDefPolicyCallbackData; // normally filled in WINTRUST_DATA
    LPVOID                  pDefSIPClientData;      // normally filled in WINTRUST_DATA

} CRYPT_PROVIDER_DEFUSAGE, *PCRYPT_PROVIDER_DEFUSAGE;

#include <poppack.h>

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST.DLL Provider defines
//----------------------------------------------------------------------------
//  The following are definitions of the Microsoft Generic Cert Provider
//
#define WT_PROVIDER_DLL_NAME                L"WINTRUST.DLL"
#define WT_PROVIDER_CERTTRUST_FUNCTION      L"WintrustCertificateTrust"

//////////////////////////////////////////////////////////////////////////////
//
// WintrustAddActionID
//----------------------------------------------------------------------------
//  Adds a new Provider combination to the users'
//  system.  Creates all necessary registry entries, etc.  This should be done
//  during the Policy Provider's DllRegisterServer.
//
//  *** THE ONLY ONE WHO SHOULD CALL THIS IS THE POLICY PROVIDER ***
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
extern BOOL WINAPI  WintrustAddActionID(__in GUID *pgActionID,
                                        __in DWORD fdwFlags,
                                        __in CRYPT_REGISTER_ACTIONID *psProvInfo);

// By default, WintrustAddActionID doesn't return registry errors.
// Set this flag to return registry errors. If FALSE is returned,
// LastError is set.
#define WT_ADD_ACTION_ID_RET_RESULT_FLAG    0x1


//////////////////////////////////////////////////////////////////////////////
//
// WintrustRemoveActionID
//----------------------------------------------------------------------------
//  Removes the Provider action combination from the users'
//  system.
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
extern BOOL WINAPI  WintrustRemoveActionID(__in GUID *pgActionID);

//////////////////////////////////////////////////////////////////////////////
//
// WintrustLoadFunctionPointers
//----------------------------------------------------------------------------
//  Retrieves the function entry points based on the Action ID given.
//
// Returns:
//      TRUE                            success.
//      FALSE                           fail.
//
extern BOOL WINAPI WintrustLoadFunctionPointers(GUID *pgActionID, CRYPT_PROVIDER_FUNCTIONS *pPfns);


//////////////////////////////////////////////////////////////////////////////
//
// WintrustAddDefaultForUsage
//----------------------------------------------------------------------------
//  Sets the default Action ID for the usage.  If the provider uses this
//  function, and the provider requires any of the "callback" data in
//  WINTRUST_DATA to be filled out, it MUST completely fill out the
//  CRYPT_PROVIDER_REGDEFUSAGE structure.
//
// Returns:
//      TRUE                            success.
//      FALSE                           fail.
//
extern BOOL WINAPI              WintrustAddDefaultForUsage(__in const char *pszUsageOID,
                                                           __in CRYPT_PROVIDER_REGDEFUSAGE *psDefUsage);

//////////////////////////////////////////////////////////////////////////////
//
// WintrustGetDefaultForUsage
//----------------------------------------------------------------------------
//  Retrieves the Action ID and default callback data for the specified usage
//
//  this function must be called again with dwAction set to FREE to deallocate
//
//
// Returns:
//      TRUE                            success.
//      FALSE                           fail.
//
#define                             DWACTION_ALLOCANDFILL           1
#define                             DWACTION_FREE                   2
extern BOOL WINAPI              WintrustGetDefaultForUsage(__in DWORD dwAction,
                                                           __in const char *pszUsageOID,
                                                           __inout CRYPT_PROVIDER_DEFUSAGE *psUsage);

extern CRYPT_PROVIDER_SGNR * WINAPI     WTHelperGetProvSignerFromChain(CRYPT_PROVIDER_DATA *pProvData,
                                                                       DWORD idxSigner,
                                                                       BOOL fCounterSigner,
                                                                       DWORD idxCounterSigner);
extern CRYPT_PROVIDER_CERT * WINAPI     WTHelperGetProvCertFromChain(CRYPT_PROVIDER_SGNR *pSgnr,
                                                                     DWORD idxCert);

extern CRYPT_PROVIDER_DATA * WINAPI     WTHelperProvDataFromStateData(HANDLE hStateData);

extern CRYPT_PROVIDER_PRIVDATA * WINAPI WTHelperGetProvPrivateDataFromChain(CRYPT_PROVIDER_DATA *pProvData,
                                                                            GUID *pgProviderID);
extern BOOL WINAPI                      WTHelperCertIsSelfSigned(DWORD dwEncoding, CERT_INFO *pCert);

extern HRESULT WINAPI                   WTHelperCertCheckValidSignature(CRYPT_PROVIDER_DATA *pProvData);

//////////////////////////////////////////////////////////////////////////////
//
// Supported ASN structures contained in WINTRUST.DLL
//----------------------------------------------------------------------------
//
#include <pshpack8.h>

//
//  CTL Trusted CA Lists
//
#define szOID_TRUSTED_CODESIGNING_CA_LIST   "1.3.6.1.4.1.311.2.2.1"
#define szOID_TRUSTED_CLIENT_AUTH_CA_LIST   "1.3.6.1.4.1.311.2.2.2"
#define szOID_TRUSTED_SERVER_AUTH_CA_LIST   "1.3.6.1.4.1.311.2.2.3"

//
//  encode/decode OID defines
//
#define SPC_COMMON_NAME_OBJID               szOID_COMMON_NAME
#define SPC_TIME_STAMP_REQUEST_OBJID        "1.3.6.1.4.1.311.3.2.1"
#define SPC_INDIRECT_DATA_OBJID             "1.3.6.1.4.1.311.2.1.4"
#define SPC_SP_AGENCY_INFO_OBJID            "1.3.6.1.4.1.311.2.1.10"
#define SPC_STATEMENT_TYPE_OBJID            "1.3.6.1.4.1.311.2.1.11"
#define SPC_SP_OPUS_INFO_OBJID              "1.3.6.1.4.1.311.2.1.12"
#define SPC_CERT_EXTENSIONS_OBJID           "1.3.6.1.4.1.311.2.1.14"
#define SPC_PE_IMAGE_DATA_OBJID             "1.3.6.1.4.1.311.2.1.15"
#define SPC_RAW_FILE_DATA_OBJID             "1.3.6.1.4.1.311.2.1.18"
#define SPC_STRUCTURED_STORAGE_DATA_OBJID   "1.3.6.1.4.1.311.2.1.19"
#define SPC_JAVA_CLASS_DATA_OBJID           "1.3.6.1.4.1.311.2.1.20"
#define SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.21"
#define SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.22"
#define SPC_CAB_DATA_OBJID                  "1.3.6.1.4.1.311.2.1.25"
#define SPC_GLUE_RDN_OBJID                  "1.3.6.1.4.1.311.2.1.25"    // obsolete!
#define SPC_MINIMAL_CRITERIA_OBJID          "1.3.6.1.4.1.311.2.1.26"
#define SPC_FINANCIAL_CRITERIA_OBJID        "1.3.6.1.4.1.311.2.1.27"
#define SPC_LINK_OBJID                      "1.3.6.1.4.1.311.2.1.28"
#define SPC_SIGINFO_OBJID                   "1.3.6.1.4.1.311.2.1.30"

//
//  Page hash versions
//
#define SPC_PE_IMAGE_PAGE_HASHES_V1_OBJID   "1.3.6.1.4.1.311.2.3.1"     // V1
#define SPC_PE_IMAGE_PAGE_HASHES_V2_OBJID   "1.3.6.1.4.1.311.2.3.2"     // V2

//
//  Catalog entries
//
#define CAT_NAMEVALUE_OBJID                 "1.3.6.1.4.1.311.12.2.1"
#define CAT_MEMBERINFO_OBJID                "1.3.6.1.4.1.311.12.2.2"

//
//  encode/decode internal defines
//
#define SPC_SP_AGENCY_INFO_STRUCT           ((LPCSTR) 2000)
#define SPC_MINIMAL_CRITERIA_STRUCT         ((LPCSTR) 2001)
#define SPC_FINANCIAL_CRITERIA_STRUCT       ((LPCSTR) 2002)
#define SPC_INDIRECT_DATA_CONTENT_STRUCT    ((LPCSTR) 2003)
#define SPC_PE_IMAGE_DATA_STRUCT            ((LPCSTR) 2004)
#define SPC_LINK_STRUCT                     ((LPCSTR) 2005)
#define SPC_STATEMENT_TYPE_STRUCT           ((LPCSTR) 2006)
#define SPC_SP_OPUS_INFO_STRUCT             ((LPCSTR) 2007)
#define SPC_CAB_DATA_STRUCT                 ((LPCSTR) 2008)
#define SPC_JAVA_CLASS_DATA_STRUCT          ((LPCSTR) 2009)

#define SPC_SIGINFO_STRUCT                  ((LPCSTR) 2130)

#define CAT_NAMEVALUE_STRUCT                ((LPCSTR) 2221)
#define CAT_MEMBERINFO_STRUCT               ((LPCSTR) 2222)

#define SPC_UUID_LENGTH     16
typedef BYTE SPC_UUID[SPC_UUID_LENGTH];

#define SpcSerializedObjectAttributesClassId    {0xA6, 0xB5, 0x86, 0xD5, \
                                                 0xB4, 0xA1, 0x24, 0x66, \
                                                 0xAE, 0x05, 0xA2, 0x17, \
                                                 0xDA, 0x8E, 0x60, 0xD6}

typedef struct _SPC_SERIALIZED_OBJECT
{
    SPC_UUID            ClassId;
    CRYPT_DATA_BLOB     SerializedData;

} SPC_SERIALIZED_OBJECT, *PSPC_SERIALIZED_OBJECT;

typedef struct SPC_SIGINFO_
{
    DWORD       dwSipVersion;
    GUID        gSIPGuid;
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
    DWORD       dwReserved5;

} SPC_SIGINFO, *PSPC_SIGINFO;

typedef struct SPC_LINK_
{
    DWORD dwLinkChoice;
#               define          SPC_URL_LINK_CHOICE         1
#               define          SPC_MONIKER_LINK_CHOICE     2
#               define          SPC_FILE_LINK_CHOICE        3

    union
    {
        LPWSTR                  pwszUrl;
        SPC_SERIALIZED_OBJECT   Moniker;
        LPWSTR                  pwszFile;
    };

} SPC_LINK, *PSPC_LINK;

typedef struct _SPC_PE_IMAGE_DATA
{
    CRYPT_BIT_BLOB            Flags;
    PSPC_LINK                 pFile;

} SPC_PE_IMAGE_DATA, *PSPC_PE_IMAGE_DATA;

typedef struct _SPC_INDIRECT_DATA_CONTENT
{
    CRYPT_ATTRIBUTE_TYPE_VALUE  Data;
    CRYPT_ALGORITHM_IDENTIFIER  DigestAlgorithm;
    CRYPT_HASH_BLOB             Digest;

} SPC_INDIRECT_DATA_CONTENT, *PSPC_INDIRECT_DATA_CONTENT;

typedef struct _SPC_FINANCIAL_CRITERIA
{
    BOOL                        fFinancialInfoAvailable;
    BOOL                        fMeetsCriteria;

} SPC_FINANCIAL_CRITERIA, *PSPC_FINANCIAL_CRITERIA;

typedef struct _SPC_IMAGE
{
    struct SPC_LINK_            *pImageLink;
    CRYPT_DATA_BLOB             Bitmap;
    CRYPT_DATA_BLOB             Metafile;
    CRYPT_DATA_BLOB             EnhancedMetafile;
    CRYPT_DATA_BLOB             GifFile;

} SPC_IMAGE, *PSPC_IMAGE;

typedef struct _SPC_SP_AGENCY_INFO
{
    struct SPC_LINK_            *pPolicyInformation;
    LPWSTR                      pwszPolicyDisplayText;
    PSPC_IMAGE                  pLogoImage;
    struct SPC_LINK_            *pLogoLink;

} SPC_SP_AGENCY_INFO, *PSPC_SP_AGENCY_INFO;

typedef struct _SPC_STATEMENT_TYPE
{
    DWORD                       cKeyPurposeId;
    LPSTR                       *rgpszKeyPurposeId;     // pszObjId

} SPC_STATEMENT_TYPE, *PSPC_STATEMENT_TYPE;

typedef struct _SPC_SP_OPUS_INFO
{
    LPCWSTR                     pwszProgramName;
    struct SPC_LINK_            *pMoreInfo;
    struct SPC_LINK_            *pPublisherInfo;

} SPC_SP_OPUS_INFO, *PSPC_SP_OPUS_INFO;

typedef struct _CAT_NAMEVALUE
{
    LPWSTR          pwszTag;
    DWORD           fdwFlags;
    CRYPT_DATA_BLOB Value;

} CAT_NAMEVALUE, *PCAT_NAMEVALUE;

typedef struct _CAT_MEMBERINFO
{
    LPWSTR          pwszSubjGuid;
    DWORD           dwCertVersion;

} CAT_MEMBERINFO, *PCAT_MEMBERINFO;

#include <poppack.h>



//////////////////////////////////////////////////////////////////////////////////
//
//  support for old calling convention: *** DO NOT USE ***
//
#ifdef WT_DEFINE_ALL_APIS

typedef struct _WIN_CERTIFICATE
{
    DWORD       dwLength;
    WORD        wRevision;
    WORD        wCertificateType;   // WIN_CERT_TYPE_xxx
    BYTE        bCertificate[ANYSIZE_ARRAY];

} WIN_CERTIFICATE, *LPWIN_CERTIFICATE;

#define WIN_CERT_REVISION_1_0               (0x0100)
#define WIN_CERT_REVISION_2_0               (0x0200)

#define WIN_CERT_TYPE_X509                  (0x0001)   // bCertificate contains an X.509 Certificate
#define WIN_CERT_TYPE_PKCS_SIGNED_DATA      (0x0002)   // bCertificate contains a PKCS SignedData structure
#define WIN_CERT_TYPE_RESERVED_1            (0x0003)   // Reserved
#define WIN_CERT_TYPE_TS_STACK_SIGNED       (0x0004)   // Terminal Server Protocol Stack Certificate signing


typedef LPVOID WIN_TRUST_SUBJECT;

typedef struct _WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT
{
    HANDLE            hClientToken;
    GUID *            SubjectType;
    WIN_TRUST_SUBJECT Subject;

} WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT, *LPWIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT ;


typedef struct _WIN_TRUST_ACTDATA_SUBJECT_ONLY
{
    GUID *            SubjectType;
    WIN_TRUST_SUBJECT Subject;

} WIN_TRUST_ACTDATA_SUBJECT_ONLY, *LPWIN_TRUST_ACTDATA_SUBJECT_ONLY;

/* RawFile == 959dc450-8d9e-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_RAW_FILE                              \
            { 0x959dc450,                                        \
              0x8d9e,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

/* PeImage == 43c9a1e0-8da0-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_PE_IMAGE                              \
            { 0x43c9a1e0,                                        \
              0x8da0,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }


/* JavaClass = 08ad3990-8da1-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_JAVA_CLASS                            \
            { 0x08ad3990,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }
/* Cabinet = d17c5374-a392-11cf-9df5-00aa00c184e0 */
#define WIN_TRUST_SUBJTYPE_CABINET                               \
            { 0xd17c5374,                                        \
              0xa392,                                            \
              0x11cf,                                            \
              { 0x9d, 0xf5, 0x0, 0xaa, 0x0, 0xc1, 0x84, 0xe0 }   \
            }

typedef struct _WIN_TRUST_SUBJECT_FILE
{
    HANDLE  hFile;
    LPCWSTR lpPath;

} WIN_TRUST_SUBJECT_FILE, *LPWIN_TRUST_SUBJECT_FILE;

#define WIN_TRUST_SUBJTYPE_RAW_FILEEX                            \
            { 0x6f458110,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_PE_IMAGEEX                            \
            { 0x6f458111,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_JAVA_CLASSEX                          \
            { 0x6f458113,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_CABINETEX                             \
            { 0x6f458114,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

typedef struct _WIN_TRUST_SUBJECT_FILE_AND_DISPLAY
{
    HANDLE  hFile;              // handle to the open file if you got it
    LPCWSTR lpPath;             // the path to open if you don't
    LPCWSTR lpDisplayName;      // (optional) display name to show to user

} WIN_TRUST_SUBJECT_FILE_AND_DISPLAY, *LPWIN_TRUST_SUBJECT_FILE_AND_DISPLAY;

/* OleStorage == c257e740-8da0-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_OLE_STORAGE                           \
            { 0xc257e740,                                        \
              0x8da0,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }


/* TrustedPublisher == 66426730-8da1-11cf-8736-00aa00a485eb */
#define WIN_SPUB_ACTION_TRUSTED_PUBLISHER                        \
            { 0x66426730,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

/* NtActivateImage == 8bc96b00-8da1-11cf-8736-00aa00a485eb */
#define     WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE                    \
            { 0x8bc96b00,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

/* PublishedSoftware == 64b9d180-8da2-11cf-8736-00aa00a485eb */
#define WIN_SPUB_ACTION_PUBLISHED_SOFTWARE                       \
            { 0x64b9d180,                                        \
              0x8da2,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

typedef struct _WIN_SPUB_TRUSTED_PUBLISHER_DATA
{
    HANDLE            hClientToken;
    LPWIN_CERTIFICATE lpCertificate;

} WIN_SPUB_TRUSTED_PUBLISHER_DATA, *LPWIN_SPUB_TRUSTED_PUBLISHER_DATA;

#endif



// Open the cert manager UI dialog's TrustedPublisher Tab.
//
// The following flags may be set:
//   WT_TRUSTDBDIALOG_NO_UI_FLAG
//      Set this flag in conjunction with
//      WT_TRUSTDBDIALOG_WRITE_LEGACY_REG_FLAG and/or
//      WT_TRUSTDBDIALOG_WRITE_IEAK_STORE_FLAG to do the registry and/or
//      store write without any UI.
//   WT_TRUSTDBDIALOG_ONLY_PUB_TAB_FLAG
//      By default all of the UI tabs are displayed with TrustedPublisher
//      as the initial tab. Setting this flag only displays the
//      TrustedPublisher tab.
//   WT_TRUSTDBDIALOG_WRITE_LEGACY_REG_FLAG
//      Setting this flag causes the trusted publishers to be written to the
//      following legacy registry location:
//          "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\
//              WinTrust\Trust Providers\Software Publishing\Trust Database\0"
//      The registry value names are constructed as ascii generated
//      representations of the md5 hash of the issuer name and the cert's serial
//      number. The string value is the subject display name.
//
//      Note, the above registry key is initially deleted to force the removal
//      of any previous publisher values.
//   WT_TRUSTDBDIALOG_WRITE_IEAK_STORE_FLAG
//      Setting this flag causes all of the trusted publishers to be copied to
//      the "TrustedPublisher_IEAK" system registry store at the following
//      location:
//          "HKEY_CURRENT_USER\Software\Microsoft\SystemCertificates\
//              TrustedPublisher_IEAK\Certificates\..."
//      Note, the logical HKCU TrustedPublisher store inherits from HKLM and
//      GroupPolicy. The TrustedPublisher_IEAK will contain the entire set
//      under a single registry subkey.
//
//      Note, initially all certs are removed from the above store.
//
extern BOOL WINAPI OpenPersonalTrustDBDialogEx(
    __in_opt HWND hwndParent,
    __in DWORD dwFlags,
    __inout_opt PVOID *pvReserved
    );

#define WT_TRUSTDBDIALOG_NO_UI_FLAG             0x00000001
#define WT_TRUSTDBDIALOG_ONLY_PUB_TAB_FLAG      0x00000002
#define WT_TRUSTDBDIALOG_WRITE_LEGACY_REG_FLAG  0x00000100
#define WT_TRUSTDBDIALOG_WRITE_IEAK_STORE_FLAG  0x00000200


// Calls above with dwFlags = 0 and pvReserved = NULL
extern BOOL WINAPI OpenPersonalTrustDBDialog(
    __in_opt HWND hwndParent
    );

//////////////////////////////////////////////////////////////////////////////
//
// WintrustSetDefaultIncludePEPageHashes
//----------------------------------------------------------------------------
//  This API may be called to set the default setting for including page
//  hashes when creating SIP indirect data for PE files.
//
//  Unless explicitly set, the default is not to include page hashes.
//
extern
void
WINAPI
WintrustSetDefaultIncludePEPageHashes(
    BOOL fIncludePEPageHashes
    );


#ifdef __cplusplus
}
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 800)
    #if _MSC_VER >= 1200
        #pragma warning(pop)
    #else
        #pragma warning(default:4201) // nonstandard extension used : nameless struct/union
    #endif
#endif

#endif // WINTRUST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\winsync.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for winsync.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __winsync_h__
#define __winsync_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IClockVectorElement_FWD_DEFINED__
#define __IClockVectorElement_FWD_DEFINED__
typedef interface IClockVectorElement IClockVectorElement;
#endif 	/* __IClockVectorElement_FWD_DEFINED__ */


#ifndef __IFeedClockVectorElement_FWD_DEFINED__
#define __IFeedClockVectorElement_FWD_DEFINED__
typedef interface IFeedClockVectorElement IFeedClockVectorElement;
#endif 	/* __IFeedClockVectorElement_FWD_DEFINED__ */


#ifndef __IClockVector_FWD_DEFINED__
#define __IClockVector_FWD_DEFINED__
typedef interface IClockVector IClockVector;
#endif 	/* __IClockVector_FWD_DEFINED__ */


#ifndef __IFeedClockVector_FWD_DEFINED__
#define __IFeedClockVector_FWD_DEFINED__
typedef interface IFeedClockVector IFeedClockVector;
#endif 	/* __IFeedClockVector_FWD_DEFINED__ */


#ifndef __IEnumClockVector_FWD_DEFINED__
#define __IEnumClockVector_FWD_DEFINED__
typedef interface IEnumClockVector IEnumClockVector;
#endif 	/* __IEnumClockVector_FWD_DEFINED__ */


#ifndef __IEnumFeedClockVector_FWD_DEFINED__
#define __IEnumFeedClockVector_FWD_DEFINED__
typedef interface IEnumFeedClockVector IEnumFeedClockVector;
#endif 	/* __IEnumFeedClockVector_FWD_DEFINED__ */


#ifndef __ICoreFragment_FWD_DEFINED__
#define __ICoreFragment_FWD_DEFINED__
typedef interface ICoreFragment ICoreFragment;
#endif 	/* __ICoreFragment_FWD_DEFINED__ */


#ifndef __ICoreFragmentInspector_FWD_DEFINED__
#define __ICoreFragmentInspector_FWD_DEFINED__
typedef interface ICoreFragmentInspector ICoreFragmentInspector;
#endif 	/* __ICoreFragmentInspector_FWD_DEFINED__ */


#ifndef __IRangeException_FWD_DEFINED__
#define __IRangeException_FWD_DEFINED__
typedef interface IRangeException IRangeException;
#endif 	/* __IRangeException_FWD_DEFINED__ */


#ifndef __IEnumRangeExceptions_FWD_DEFINED__
#define __IEnumRangeExceptions_FWD_DEFINED__
typedef interface IEnumRangeExceptions IEnumRangeExceptions;
#endif 	/* __IEnumRangeExceptions_FWD_DEFINED__ */


#ifndef __ISingleItemException_FWD_DEFINED__
#define __ISingleItemException_FWD_DEFINED__
typedef interface ISingleItemException ISingleItemException;
#endif 	/* __ISingleItemException_FWD_DEFINED__ */


#ifndef __IEnumSingleItemExceptions_FWD_DEFINED__
#define __IEnumSingleItemExceptions_FWD_DEFINED__
typedef interface IEnumSingleItemExceptions IEnumSingleItemExceptions;
#endif 	/* __IEnumSingleItemExceptions_FWD_DEFINED__ */


#ifndef __IChangeUnitException_FWD_DEFINED__
#define __IChangeUnitException_FWD_DEFINED__
typedef interface IChangeUnitException IChangeUnitException;
#endif 	/* __IChangeUnitException_FWD_DEFINED__ */


#ifndef __IEnumChangeUnitExceptions_FWD_DEFINED__
#define __IEnumChangeUnitExceptions_FWD_DEFINED__
typedef interface IEnumChangeUnitExceptions IEnumChangeUnitExceptions;
#endif 	/* __IEnumChangeUnitExceptions_FWD_DEFINED__ */


#ifndef __IReplicaKeyMap_FWD_DEFINED__
#define __IReplicaKeyMap_FWD_DEFINED__
typedef interface IReplicaKeyMap IReplicaKeyMap;
#endif 	/* __IReplicaKeyMap_FWD_DEFINED__ */


#ifndef __IConstructReplicaKeyMap_FWD_DEFINED__
#define __IConstructReplicaKeyMap_FWD_DEFINED__
typedef interface IConstructReplicaKeyMap IConstructReplicaKeyMap;
#endif 	/* __IConstructReplicaKeyMap_FWD_DEFINED__ */


#ifndef __ISyncKnowledge_FWD_DEFINED__
#define __ISyncKnowledge_FWD_DEFINED__
typedef interface ISyncKnowledge ISyncKnowledge;
#endif 	/* __ISyncKnowledge_FWD_DEFINED__ */


#ifndef __IForgottenKnowledge_FWD_DEFINED__
#define __IForgottenKnowledge_FWD_DEFINED__
typedef interface IForgottenKnowledge IForgottenKnowledge;
#endif 	/* __IForgottenKnowledge_FWD_DEFINED__ */


#ifndef __ISyncKnowledge2_FWD_DEFINED__
#define __ISyncKnowledge2_FWD_DEFINED__
typedef interface ISyncKnowledge2 ISyncKnowledge2;
#endif 	/* __ISyncKnowledge2_FWD_DEFINED__ */


#ifndef __IRecoverableErrorData_FWD_DEFINED__
#define __IRecoverableErrorData_FWD_DEFINED__
typedef interface IRecoverableErrorData IRecoverableErrorData;
#endif 	/* __IRecoverableErrorData_FWD_DEFINED__ */


#ifndef __IRecoverableError_FWD_DEFINED__
#define __IRecoverableError_FWD_DEFINED__
typedef interface IRecoverableError IRecoverableError;
#endif 	/* __IRecoverableError_FWD_DEFINED__ */


#ifndef __IChangeConflict_FWD_DEFINED__
#define __IChangeConflict_FWD_DEFINED__
typedef interface IChangeConflict IChangeConflict;
#endif 	/* __IChangeConflict_FWD_DEFINED__ */


#ifndef __ISyncCallback_FWD_DEFINED__
#define __ISyncCallback_FWD_DEFINED__
typedef interface ISyncCallback ISyncCallback;
#endif 	/* __ISyncCallback_FWD_DEFINED__ */


#ifndef __ISyncCallback2_FWD_DEFINED__
#define __ISyncCallback2_FWD_DEFINED__
typedef interface ISyncCallback2 ISyncCallback2;
#endif 	/* __ISyncCallback2_FWD_DEFINED__ */


#ifndef __ISyncProvider_FWD_DEFINED__
#define __ISyncProvider_FWD_DEFINED__
typedef interface ISyncProvider ISyncProvider;
#endif 	/* __ISyncProvider_FWD_DEFINED__ */


#ifndef __ISyncSessionState_FWD_DEFINED__
#define __ISyncSessionState_FWD_DEFINED__
typedef interface ISyncSessionState ISyncSessionState;
#endif 	/* __ISyncSessionState_FWD_DEFINED__ */


#ifndef __ISyncSessionExtendedErrorInfo_FWD_DEFINED__
#define __ISyncSessionExtendedErrorInfo_FWD_DEFINED__
typedef interface ISyncSessionExtendedErrorInfo ISyncSessionExtendedErrorInfo;
#endif 	/* __ISyncSessionExtendedErrorInfo_FWD_DEFINED__ */


#ifndef __ISyncSessionState2_FWD_DEFINED__
#define __ISyncSessionState2_FWD_DEFINED__
typedef interface ISyncSessionState2 ISyncSessionState2;
#endif 	/* __ISyncSessionState2_FWD_DEFINED__ */


#ifndef __ISyncFilterInfo_FWD_DEFINED__
#define __ISyncFilterInfo_FWD_DEFINED__
typedef interface ISyncFilterInfo ISyncFilterInfo;
#endif 	/* __ISyncFilterInfo_FWD_DEFINED__ */


#ifndef __ISyncFilterInfo2_FWD_DEFINED__
#define __ISyncFilterInfo2_FWD_DEFINED__
typedef interface ISyncFilterInfo2 ISyncFilterInfo2;
#endif 	/* __ISyncFilterInfo2_FWD_DEFINED__ */


#ifndef __IChangeUnitListFilterInfo_FWD_DEFINED__
#define __IChangeUnitListFilterInfo_FWD_DEFINED__
typedef interface IChangeUnitListFilterInfo IChangeUnitListFilterInfo;
#endif 	/* __IChangeUnitListFilterInfo_FWD_DEFINED__ */


#ifndef __IEnumSyncChanges_FWD_DEFINED__
#define __IEnumSyncChanges_FWD_DEFINED__
typedef interface IEnumSyncChanges IEnumSyncChanges;
#endif 	/* __IEnumSyncChanges_FWD_DEFINED__ */


#ifndef __ISyncChangeBuilder_FWD_DEFINED__
#define __ISyncChangeBuilder_FWD_DEFINED__
typedef interface ISyncChangeBuilder ISyncChangeBuilder;
#endif 	/* __ISyncChangeBuilder_FWD_DEFINED__ */


#ifndef __ISyncChangeBatchBase_FWD_DEFINED__
#define __ISyncChangeBatchBase_FWD_DEFINED__
typedef interface ISyncChangeBatchBase ISyncChangeBatchBase;
#endif 	/* __ISyncChangeBatchBase_FWD_DEFINED__ */


#ifndef __ISyncChangeBatch_FWD_DEFINED__
#define __ISyncChangeBatch_FWD_DEFINED__
typedef interface ISyncChangeBatch ISyncChangeBatch;
#endif 	/* __ISyncChangeBatch_FWD_DEFINED__ */


#ifndef __ISyncFullEnumerationChangeBatch_FWD_DEFINED__
#define __ISyncFullEnumerationChangeBatch_FWD_DEFINED__
typedef interface ISyncFullEnumerationChangeBatch ISyncFullEnumerationChangeBatch;
#endif 	/* __ISyncFullEnumerationChangeBatch_FWD_DEFINED__ */


#ifndef __ISyncChangeBatchWithPrerequisite_FWD_DEFINED__
#define __ISyncChangeBatchWithPrerequisite_FWD_DEFINED__
typedef interface ISyncChangeBatchWithPrerequisite ISyncChangeBatchWithPrerequisite;
#endif 	/* __ISyncChangeBatchWithPrerequisite_FWD_DEFINED__ */


#ifndef __ISyncChangeBatchBase2_FWD_DEFINED__
#define __ISyncChangeBatchBase2_FWD_DEFINED__
typedef interface ISyncChangeBatchBase2 ISyncChangeBatchBase2;
#endif 	/* __ISyncChangeBatchBase2_FWD_DEFINED__ */


#ifndef __ISyncChangeBatchAdvanced_FWD_DEFINED__
#define __ISyncChangeBatchAdvanced_FWD_DEFINED__
typedef interface ISyncChangeBatchAdvanced ISyncChangeBatchAdvanced;
#endif 	/* __ISyncChangeBatchAdvanced_FWD_DEFINED__ */


#ifndef __IKnowledgeSyncProvider_FWD_DEFINED__
#define __IKnowledgeSyncProvider_FWD_DEFINED__
typedef interface IKnowledgeSyncProvider IKnowledgeSyncProvider;
#endif 	/* __IKnowledgeSyncProvider_FWD_DEFINED__ */


#ifndef __ISyncChangeUnit_FWD_DEFINED__
#define __ISyncChangeUnit_FWD_DEFINED__
typedef interface ISyncChangeUnit ISyncChangeUnit;
#endif 	/* __ISyncChangeUnit_FWD_DEFINED__ */


#ifndef __IEnumSyncChangeUnits_FWD_DEFINED__
#define __IEnumSyncChangeUnits_FWD_DEFINED__
typedef interface IEnumSyncChangeUnits IEnumSyncChangeUnits;
#endif 	/* __IEnumSyncChangeUnits_FWD_DEFINED__ */


#ifndef __ISyncChange_FWD_DEFINED__
#define __ISyncChange_FWD_DEFINED__
typedef interface ISyncChange ISyncChange;
#endif 	/* __ISyncChange_FWD_DEFINED__ */


#ifndef __ISyncChangeWithPrerequisite_FWD_DEFINED__
#define __ISyncChangeWithPrerequisite_FWD_DEFINED__
typedef interface ISyncChangeWithPrerequisite ISyncChangeWithPrerequisite;
#endif 	/* __ISyncChangeWithPrerequisite_FWD_DEFINED__ */


#ifndef __ISyncFullEnumerationChange_FWD_DEFINED__
#define __ISyncFullEnumerationChange_FWD_DEFINED__
typedef interface ISyncFullEnumerationChange ISyncFullEnumerationChange;
#endif 	/* __ISyncFullEnumerationChange_FWD_DEFINED__ */


#ifndef __IDataRetrieverCallback_FWD_DEFINED__
#define __IDataRetrieverCallback_FWD_DEFINED__
typedef interface IDataRetrieverCallback IDataRetrieverCallback;
#endif 	/* __IDataRetrieverCallback_FWD_DEFINED__ */


#ifndef __ILoadChangeContext_FWD_DEFINED__
#define __ILoadChangeContext_FWD_DEFINED__
typedef interface ILoadChangeContext ILoadChangeContext;
#endif 	/* __ILoadChangeContext_FWD_DEFINED__ */


#ifndef __ISynchronousDataRetriever_FWD_DEFINED__
#define __ISynchronousDataRetriever_FWD_DEFINED__
typedef interface ISynchronousDataRetriever ISynchronousDataRetriever;
#endif 	/* __ISynchronousDataRetriever_FWD_DEFINED__ */


#ifndef __IAsynchronousDataRetriever_FWD_DEFINED__
#define __IAsynchronousDataRetriever_FWD_DEFINED__
typedef interface IAsynchronousDataRetriever IAsynchronousDataRetriever;
#endif 	/* __IAsynchronousDataRetriever_FWD_DEFINED__ */


#ifndef __IFilterRequestCallback_FWD_DEFINED__
#define __IFilterRequestCallback_FWD_DEFINED__
typedef interface IFilterRequestCallback IFilterRequestCallback;
#endif 	/* __IFilterRequestCallback_FWD_DEFINED__ */


#ifndef __IRequestFilteredSync_FWD_DEFINED__
#define __IRequestFilteredSync_FWD_DEFINED__
typedef interface IRequestFilteredSync IRequestFilteredSync;
#endif 	/* __IRequestFilteredSync_FWD_DEFINED__ */


#ifndef __ISupportFilteredSync_FWD_DEFINED__
#define __ISupportFilteredSync_FWD_DEFINED__
typedef interface ISupportFilteredSync ISupportFilteredSync;
#endif 	/* __ISupportFilteredSync_FWD_DEFINED__ */


#ifndef __ISupportLastWriteTime_FWD_DEFINED__
#define __ISupportLastWriteTime_FWD_DEFINED__
typedef interface ISupportLastWriteTime ISupportLastWriteTime;
#endif 	/* __ISupportLastWriteTime_FWD_DEFINED__ */


#ifndef __IProviderConverter_FWD_DEFINED__
#define __IProviderConverter_FWD_DEFINED__
typedef interface IProviderConverter IProviderConverter;
#endif 	/* __IProviderConverter_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_winsync_0000_0000 */
/* [local] */ 

#pragma warning ( disable : 28718 )
typedef struct _ID_PARAMETER_PAIR
    {
    BOOL fIsVariable;
    USHORT cbIdSize;
    } 	ID_PARAMETER_PAIR;

typedef struct _ID_PARAMETERS
    {
    DWORD dwSize;
    ID_PARAMETER_PAIR replicaId;
    ID_PARAMETER_PAIR itemId;
    ID_PARAMETER_PAIR changeUnitId;
    } 	ID_PARAMETERS;

typedef struct _SYNC_SESSION_STATISTICS
    {
    DWORD dwChangesApplied;
    DWORD dwChangesFailed;
    } 	SYNC_SESSION_STATISTICS;

typedef struct _SYNC_VERSION
    {
    DWORD dwLastUpdatingReplicaKey;
    ULONGLONG ullTickCount;
    } 	SYNC_VERSION;

typedef struct _SYNC_RANGE
    {
    BYTE *pbClosedLowerBound;
    BYTE *pbClosedUpperBound;
    } 	SYNC_RANGE;

typedef struct _SYNC_TIME
    {
    DWORD dwDate;
    DWORD dwTime;
    } 	SYNC_TIME;

typedef /* [public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_winsync_0000_0000_0001
    {	SPR_SOURCE	= 0,
	SPR_DESTINATION	= ( SPR_SOURCE + 1 ) 
    } 	SYNC_PROVIDER_ROLE;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_winsync_0000_0000_0002
    {	CRP_NONE	= 0,
	CRP_DESTINATION_PROVIDER_WINS	= ( CRP_NONE + 1 ) ,
	CRP_SOURCE_PROVIDER_WINS	= ( CRP_DESTINATION_PROVIDER_WINS + 1 ) ,
	CRP_LAST	= ( CRP_SOURCE_PROVIDER_WINS + 1 ) 
    } 	CONFLICT_RESOLUTION_POLICY;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_winsync_0000_0000_0003
    {	SPS_CHANGE_DETECTION	= 0,
	SPS_CHANGE_ENUMERATION	= ( SPS_CHANGE_DETECTION + 1 ) ,
	SPS_CHANGE_APPLICATION	= ( SPS_CHANGE_ENUMERATION + 1 ) 
    } 	SYNC_PROGRESS_STAGE;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_winsync_0000_0000_0004
    {	SFEA_FULL_ENUMERATION	= 0,
	SFEA_PARTIAL_SYNC	= ( SFEA_FULL_ENUMERATION + 1 ) ,
	SFEA_ABORT	= ( SFEA_PARTIAL_SYNC + 1 ) 
    } 	SYNC_FULL_ENUMERATION_ACTION;

typedef /* [public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_winsync_0000_0000_0005
    {	SRA_DEFER	= 0,
	SRA_ACCEPT_DESTINATION_PROVIDER	= ( SRA_DEFER + 1 ) ,
	SRA_ACCEPT_SOURCE_PROVIDER	= ( SRA_ACCEPT_DESTINATION_PROVIDER + 1 ) ,
	SRA_MERGE	= ( SRA_ACCEPT_SOURCE_PROVIDER + 1 ) ,
	SRA_TRANSFER_AND_DEFER	= ( SRA_MERGE + 1 ) ,
	SRA_LAST	= ( SRA_TRANSFER_AND_DEFER + 1 ) 
    } 	SYNC_RESOLVE_ACTION;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_winsync_0000_0000_0006
    {	SYNC_STATISTICS_RANGE_COUNT	= 0
    } 	SYNC_STATISTICS;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_winsync_0000_0000_0007
    {	SYNC_SERIALIZATION_VERSION_V1	= 1,
	SYNC_SERIALIZATION_VERSION_V2	= 4
    } 	SYNC_SERIALIZATION_VERSION;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_winsync_0000_0000_0008
    {	FT_CURRENT_ITEMS_ONLY	= 0
    } 	FILTERING_TYPE;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_winsync_0000_0000_0009
    {	KCCR_COOKIE_KNOWLEDGE_EQUAL	= 0,
	KCCR_COOKIE_KNOWLEDGE_CONTAINED	= ( KCCR_COOKIE_KNOWLEDGE_EQUAL + 1 ) ,
	KCCR_COOKIE_KNOWLEDGE_CONTAINS	= ( KCCR_COOKIE_KNOWLEDGE_CONTAINED + 1 ) ,
	KCCR_COOKIE_KNOWLEDGE_NOT_COMPARABLE	= ( KCCR_COOKIE_KNOWLEDGE_CONTAINS + 1 ) 
    } 	KNOWLEDGE_COOKIE_COMPARISON_RESULT;



extern RPC_IF_HANDLE __MIDL_itf_winsync_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_winsync_0000_0000_v0_0_s_ifspec;

#ifndef __IClockVectorElement_INTERFACE_DEFINED__
#define __IClockVectorElement_INTERFACE_DEFINED__

/* interface IClockVectorElement */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IClockVectorElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e71c4250-adf8-4a07-8fae-5669596909c1")
    IClockVectorElement : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReplicaKey( 
            /* [out] */ DWORD *pdwReplicaKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTickCount( 
            /* [out] */ ULONGLONG *pullTickCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClockVectorElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IClockVectorElement * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IClockVectorElement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IClockVectorElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReplicaKey )( 
            IClockVectorElement * This,
            /* [out] */ DWORD *pdwReplicaKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetTickCount )( 
            IClockVectorElement * This,
            /* [out] */ ULONGLONG *pullTickCount);
        
        END_INTERFACE
    } IClockVectorElementVtbl;

    interface IClockVectorElement
    {
        CONST_VTBL struct IClockVectorElementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClockVectorElement_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IClockVectorElement_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IClockVectorElement_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IClockVectorElement_GetReplicaKey(This,pdwReplicaKey)	\
    ( (This)->lpVtbl -> GetReplicaKey(This,pdwReplicaKey) ) 

#define IClockVectorElement_GetTickCount(This,pullTickCount)	\
    ( (This)->lpVtbl -> GetTickCount(This,pullTickCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IClockVectorElement_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_winsync_0000_0001 */
/* [local] */ 

#define SYNC_VERSION_FLAG_FROM_FEED              0x00000001
#define SYNC_VERSION_FLAG_HAS_BY                 0x00000002


extern RPC_IF_HANDLE __MIDL_itf_winsync_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_winsync_0000_0001_v0_0_s_ifspec;

#ifndef __IFeedClockVectorElement_INTERFACE_DEFINED__
#define __IFeedClockVectorElement_INTERFACE_DEFINED__

/* interface IFeedClockVectorElement */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IFeedClockVectorElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a40b46d2-e97b-4156-b6da-991f501b0f05")
    IFeedClockVectorElement : public IClockVectorElement
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSyncTime( 
            /* [out] */ SYNC_TIME *pSyncTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ BYTE *pbFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFeedClockVectorElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFeedClockVectorElement * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFeedClockVectorElement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFeedClockVectorElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReplicaKey )( 
            IFeedClockVectorElement * This,
            /* [out] */ DWORD *pdwReplicaKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetTickCount )( 
            IFeedClockVectorElement * This,
            /* [out] */ ULONGLONG *pullTickCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncTime )( 
            IFeedClockVectorElement * This,
            /* [out] */ SYNC_TIME *pSyncTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IFeedClockVectorElement * This,
            /* [out] */ BYTE *pbFlags);
        
        END_INTERFACE
    } IFeedClockVectorElementVtbl;

    interface IFeedClockVectorElement
    {
        CONST_VTBL struct IFeedClockVectorElementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFeedClockVectorElement_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFeedClockVectorElement_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFeedClockVectorElement_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFeedClockVectorElement_GetReplicaKey(This,pdwReplicaKey)	\
    ( (This)->lpVtbl -> GetReplicaKey(This,pdwReplicaKey) ) 

#define IFeedClockVectorElement_GetTickCount(This,pullTickCount)	\
    ( (This)->lpVtbl -> GetTickCount(This,pullTickCount) ) 


#define IFeedClockVectorElement_GetSyncTime(This,pSyncTime)	\
    ( (This)->lpVtbl -> GetSyncTime(This,pSyncTime) ) 

#define IFeedClockVectorElement_GetFlags(This,pbFlags)	\
    ( (This)->lpVtbl -> GetFlags(This,pbFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFeedClockVectorElement_INTERFACE_DEFINED__ */


#ifndef __IClockVector_INTERFACE_DEFINED__
#define __IClockVector_INTERFACE_DEFINED__

/* interface IClockVector */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IClockVector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14b2274a-8698-4cc6-9333-f89bd1d47bc4")
    IClockVector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClockVectorElements( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppiEnumClockVector) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClockVectorElementCount( 
            /* [out] */ DWORD *pdwCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClockVectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IClockVector * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IClockVector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IClockVector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClockVectorElements )( 
            IClockVector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppiEnumClockVector);
        
        HRESULT ( STDMETHODCALLTYPE *GetClockVectorElementCount )( 
            IClockVector * This,
            /* [out] */ DWORD *pdwCount);
        
        END_INTERFACE
    } IClockVectorVtbl;

    interface IClockVector
    {
        CONST_VTBL struct IClockVectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClockVector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IClockVector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IClockVector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IClockVector_GetClockVectorElements(This,riid,ppiEnumClockVector)	\
    ( (This)->lpVtbl -> GetClockVectorElements(This,riid,ppiEnumClockVector) ) 

#define IClockVector_GetClockVectorElementCount(This,pdwCount)	\
    ( (This)->lpVtbl -> GetClockVectorElementCount(This,pdwCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IClockVector_INTERFACE_DEFINED__ */


#ifndef __IFeedClockVector_INTERFACE_DEFINED__
#define __IFeedClockVector_INTERFACE_DEFINED__

/* interface IFeedClockVector */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IFeedClockVector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8d1d98d1-9fb8-4ec9-a553-54dd924e0f67")
    IFeedClockVector : public IClockVector
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUpdateCount( 
            /* [out] */ DWORD *pdwUpdateCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsNoConflictsSpecified( 
            /* [out] */ BOOL *pfIsNoConflictsSpecified) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFeedClockVectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFeedClockVector * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFeedClockVector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFeedClockVector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClockVectorElements )( 
            IFeedClockVector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppiEnumClockVector);
        
        HRESULT ( STDMETHODCALLTYPE *GetClockVectorElementCount )( 
            IFeedClockVector * This,
            /* [out] */ DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetUpdateCount )( 
            IFeedClockVector * This,
            /* [out] */ DWORD *pdwUpdateCount);
        
        HRESULT ( STDMETHODCALLTYPE *IsNoConflictsSpecified )( 
            IFeedClockVector * This,
            /* [out] */ BOOL *pfIsNoConflictsSpecified);
        
        END_INTERFACE
    } IFeedClockVectorVtbl;

    interface IFeedClockVector
    {
        CONST_VTBL struct IFeedClockVectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFeedClockVector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFeedClockVector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFeedClockVector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFeedClockVector_GetClockVectorElements(This,riid,ppiEnumClockVector)	\
    ( (This)->lpVtbl -> GetClockVectorElements(This,riid,ppiEnumClockVector) ) 

#define IFeedClockVector_GetClockVectorElementCount(This,pdwCount)	\
    ( (This)->lpVtbl -> GetClockVectorElementCount(This,pdwCount) ) 


#define IFeedClockVector_GetUpdateCount(This,pdwUpdateCount)	\
    ( (This)->lpVtbl -> GetUpdateCount(This,pdwUpdateCount) ) 

#define IFeedClockVector_IsNoConflictsSpecified(This,pfIsNoConflictsSpecified)	\
    ( (This)->lpVtbl -> IsNoConflictsSpecified(This,pfIsNoConflictsSpecified) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFeedClockVector_INTERFACE_DEFINED__ */


#ifndef __IEnumClockVector_INTERFACE_DEFINED__
#define __IEnumClockVector_INTERFACE_DEFINED__

/* interface IEnumClockVector */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IEnumClockVector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("525844db-2837-4799-9e80-81a66e02220c")
    IEnumClockVector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [range][in] */ ULONG cClockVectorElements,
            /* [length_is][size_is][out] */ IClockVectorElement **ppiClockVectorElements,
            /* [unique][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cSyncVersions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumClockVector **ppiEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumClockVectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumClockVector * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumClockVector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumClockVector * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumClockVector * This,
            /* [range][in] */ ULONG cClockVectorElements,
            /* [length_is][size_is][out] */ IClockVectorElement **ppiClockVectorElements,
            /* [unique][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumClockVector * This,
            /* [in] */ ULONG cSyncVersions);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumClockVector * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumClockVector * This,
            /* [out] */ IEnumClockVector **ppiEnum);
        
        END_INTERFACE
    } IEnumClockVectorVtbl;

    interface IEnumClockVector
    {
        CONST_VTBL struct IEnumClockVectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumClockVector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumClockVector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumClockVector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumClockVector_Next(This,cClockVectorElements,ppiClockVectorElements,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cClockVectorElements,ppiClockVectorElements,pcFetched) ) 

#define IEnumClockVector_Skip(This,cSyncVersions)	\
    ( (This)->lpVtbl -> Skip(This,cSyncVersions) ) 

#define IEnumClockVector_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumClockVector_Clone(This,ppiEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppiEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumClockVector_INTERFACE_DEFINED__ */


#ifndef __IEnumFeedClockVector_INTERFACE_DEFINED__
#define __IEnumFeedClockVector_INTERFACE_DEFINED__

/* interface IEnumFeedClockVector */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IEnumFeedClockVector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("550f763d-146a-48f6-abeb-6c88c7f70514")
    IEnumFeedClockVector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cClockVectorElements,
            /* [length_is][size_is][out] */ IFeedClockVectorElement **ppiClockVectorElements,
            /* [unique][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cSyncVersions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumFeedClockVector **ppiEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumFeedClockVectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumFeedClockVector * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumFeedClockVector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumFeedClockVector * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumFeedClockVector * This,
            /* [in] */ ULONG cClockVectorElements,
            /* [length_is][size_is][out] */ IFeedClockVectorElement **ppiClockVectorElements,
            /* [unique][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumFeedClockVector * This,
            /* [in] */ ULONG cSyncVersions);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumFeedClockVector * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumFeedClockVector * This,
            /* [out] */ IEnumFeedClockVector **ppiEnum);
        
        END_INTERFACE
    } IEnumFeedClockVectorVtbl;

    interface IEnumFeedClockVector
    {
        CONST_VTBL struct IEnumFeedClockVectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumFeedClockVector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumFeedClockVector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumFeedClockVector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumFeedClockVector_Next(This,cClockVectorElements,ppiClockVectorElements,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cClockVectorElements,ppiClockVectorElements,pcFetched) ) 

#define IEnumFeedClockVector_Skip(This,cSyncVersions)	\
    ( (This)->lpVtbl -> Skip(This,cSyncVersions) ) 

#define IEnumFeedClockVector_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumFeedClockVector_Clone(This,ppiEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppiEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumFeedClockVector_INTERFACE_DEFINED__ */


#ifndef __ICoreFragment_INTERFACE_DEFINED__
#define __ICoreFragment_INTERFACE_DEFINED__

/* interface ICoreFragment */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ICoreFragment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("613b2ab5-b304-47d9-9c31-ce6c54401a15")
    ICoreFragment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NextColumn( 
            /* [size_is][unique][out][in] */ BYTE *pChangeUnitId,
            /* [out][in] */ DWORD *pChangeUnitIdSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextRange( 
            /* [size_is][unique][out][in] */ BYTE *pItemId,
            /* [out][in] */ DWORD *pItemIdSize,
            /* [out] */ IClockVector **piClockVector) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnCount( 
            /* [out] */ DWORD *pColumnCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRangeCount( 
            /* [out] */ DWORD *pRangeCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICoreFragmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICoreFragment * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICoreFragment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICoreFragment * This);
        
        HRESULT ( STDMETHODCALLTYPE *NextColumn )( 
            ICoreFragment * This,
            /* [size_is][unique][out][in] */ BYTE *pChangeUnitId,
            /* [out][in] */ DWORD *pChangeUnitIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *NextRange )( 
            ICoreFragment * This,
            /* [size_is][unique][out][in] */ BYTE *pItemId,
            /* [out][in] */ DWORD *pItemIdSize,
            /* [out] */ IClockVector **piClockVector);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICoreFragment * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnCount )( 
            ICoreFragment * This,
            /* [out] */ DWORD *pColumnCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetRangeCount )( 
            ICoreFragment * This,
            /* [out] */ DWORD *pRangeCount);
        
        END_INTERFACE
    } ICoreFragmentVtbl;

    interface ICoreFragment
    {
        CONST_VTBL struct ICoreFragmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICoreFragment_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICoreFragment_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICoreFragment_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICoreFragment_NextColumn(This,pChangeUnitId,pChangeUnitIdSize)	\
    ( (This)->lpVtbl -> NextColumn(This,pChangeUnitId,pChangeUnitIdSize) ) 

#define ICoreFragment_NextRange(This,pItemId,pItemIdSize,piClockVector)	\
    ( (This)->lpVtbl -> NextRange(This,pItemId,pItemIdSize,piClockVector) ) 

#define ICoreFragment_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define ICoreFragment_GetColumnCount(This,pColumnCount)	\
    ( (This)->lpVtbl -> GetColumnCount(This,pColumnCount) ) 

#define ICoreFragment_GetRangeCount(This,pRangeCount)	\
    ( (This)->lpVtbl -> GetRangeCount(This,pRangeCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICoreFragment_INTERFACE_DEFINED__ */


#ifndef __ICoreFragmentInspector_INTERFACE_DEFINED__
#define __ICoreFragmentInspector_INTERFACE_DEFINED__

/* interface ICoreFragmentInspector */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ICoreFragmentInspector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f7fcc5fd-ae26-4679-ba16-96aac583c134")
    ICoreFragmentInspector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NextCoreFragments( 
            /* [in] */ ULONG requestedCount,
            /* [length_is][size_is][out] */ ICoreFragment **ppiCoreFragments,
            /* [out][in] */ ULONG *pFetchedCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICoreFragmentInspectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICoreFragmentInspector * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICoreFragmentInspector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICoreFragmentInspector * This);
        
        HRESULT ( STDMETHODCALLTYPE *NextCoreFragments )( 
            ICoreFragmentInspector * This,
            /* [in] */ ULONG requestedCount,
            /* [length_is][size_is][out] */ ICoreFragment **ppiCoreFragments,
            /* [out][in] */ ULONG *pFetchedCount);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICoreFragmentInspector * This);
        
        END_INTERFACE
    } ICoreFragmentInspectorVtbl;

    interface ICoreFragmentInspector
    {
        CONST_VTBL struct ICoreFragmentInspectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICoreFragmentInspector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICoreFragmentInspector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICoreFragmentInspector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICoreFragmentInspector_NextCoreFragments(This,requestedCount,ppiCoreFragments,pFetchedCount)	\
    ( (This)->lpVtbl -> NextCoreFragments(This,requestedCount,ppiCoreFragments,pFetchedCount) ) 

#define ICoreFragmentInspector_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICoreFragmentInspector_INTERFACE_DEFINED__ */


#ifndef __IRangeException_INTERFACE_DEFINED__
#define __IRangeException_INTERFACE_DEFINED__

/* interface IRangeException */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IRangeException;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75ae8777-6848-49f7-956c-a3a92f5096e8")
    IRangeException : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClosedRangeStart( 
            /* [size_is][unique][out][in] */ BYTE *pbClosedRangeStart,
            /* [out][in] */ DWORD *pcbIdSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClosedRangeEnd( 
            /* [size_is][unique][out][in] */ BYTE *pbClosedRangeEnd,
            /* [out][in] */ DWORD *pcbIdSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClockVector( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRangeExceptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRangeException * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRangeException * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRangeException * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClosedRangeStart )( 
            IRangeException * This,
            /* [size_is][unique][out][in] */ BYTE *pbClosedRangeStart,
            /* [out][in] */ DWORD *pcbIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetClosedRangeEnd )( 
            IRangeException * This,
            /* [size_is][unique][out][in] */ BYTE *pbClosedRangeEnd,
            /* [out][in] */ DWORD *pcbIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetClockVector )( 
            IRangeException * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        END_INTERFACE
    } IRangeExceptionVtbl;

    interface IRangeException
    {
        CONST_VTBL struct IRangeExceptionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRangeException_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRangeException_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRangeException_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRangeException_GetClosedRangeStart(This,pbClosedRangeStart,pcbIdSize)	\
    ( (This)->lpVtbl -> GetClosedRangeStart(This,pbClosedRangeStart,pcbIdSize) ) 

#define IRangeException_GetClosedRangeEnd(This,pbClosedRangeEnd,pcbIdSize)	\
    ( (This)->lpVtbl -> GetClosedRangeEnd(This,pbClosedRangeEnd,pcbIdSize) ) 

#define IRangeException_GetClockVector(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetClockVector(This,riid,ppUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRangeException_INTERFACE_DEFINED__ */


#ifndef __IEnumRangeExceptions_INTERFACE_DEFINED__
#define __IEnumRangeExceptions_INTERFACE_DEFINED__

/* interface IEnumRangeExceptions */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IEnumRangeExceptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0944439f-ddb1-4176-b703-046ff22a2386")
    IEnumRangeExceptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [range][in] */ ULONG cExceptions,
            /* [length_is][size_is][out] */ IRangeException **ppRangeException,
            /* [unique][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cExceptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRangeExceptions **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRangeExceptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRangeExceptions * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRangeExceptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRangeExceptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRangeExceptions * This,
            /* [range][in] */ ULONG cExceptions,
            /* [length_is][size_is][out] */ IRangeException **ppRangeException,
            /* [unique][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRangeExceptions * This,
            /* [in] */ ULONG cExceptions);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRangeExceptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRangeExceptions * This,
            /* [out] */ IEnumRangeExceptions **ppEnum);
        
        END_INTERFACE
    } IEnumRangeExceptionsVtbl;

    interface IEnumRangeExceptions
    {
        CONST_VTBL struct IEnumRangeExceptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRangeExceptions_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumRangeExceptions_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumRangeExceptions_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumRangeExceptions_Next(This,cExceptions,ppRangeException,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cExceptions,ppRangeException,pcFetched) ) 

#define IEnumRangeExceptions_Skip(This,cExceptions)	\
    ( (This)->lpVtbl -> Skip(This,cExceptions) ) 

#define IEnumRangeExceptions_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumRangeExceptions_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumRangeExceptions_INTERFACE_DEFINED__ */


#ifndef __ISingleItemException_INTERFACE_DEFINED__
#define __ISingleItemException_INTERFACE_DEFINED__

/* interface ISingleItemException */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISingleItemException;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("892fb9b0-7c55-4a18-9316-fdF449569b64")
    ISingleItemException : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetItemId( 
            /* [size_is][unique][out][in] */ BYTE *pbItemId,
            /* [out][in] */ DWORD *pcbIdSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClockVector( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISingleItemExceptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISingleItemException * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISingleItemException * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISingleItemException * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemId )( 
            ISingleItemException * This,
            /* [size_is][unique][out][in] */ BYTE *pbItemId,
            /* [out][in] */ DWORD *pcbIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetClockVector )( 
            ISingleItemException * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        END_INTERFACE
    } ISingleItemExceptionVtbl;

    interface ISingleItemException
    {
        CONST_VTBL struct ISingleItemExceptionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISingleItemException_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISingleItemException_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISingleItemException_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISingleItemException_GetItemId(This,pbItemId,pcbIdSize)	\
    ( (This)->lpVtbl -> GetItemId(This,pbItemId,pcbIdSize) ) 

#define ISingleItemException_GetClockVector(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetClockVector(This,riid,ppUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISingleItemException_INTERFACE_DEFINED__ */


#ifndef __IEnumSingleItemExceptions_INTERFACE_DEFINED__
#define __IEnumSingleItemExceptions_INTERFACE_DEFINED__

/* interface IEnumSingleItemExceptions */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IEnumSingleItemExceptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e563381c-1b4d-4c66-9796-c86faccdcd40")
    IEnumSingleItemExceptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [range][in] */ ULONG cExceptions,
            /* [length_is][size_is][out] */ ISingleItemException **ppSingleItemException,
            /* [unique][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cExceptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumSingleItemExceptions **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSingleItemExceptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSingleItemExceptions * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSingleItemExceptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSingleItemExceptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSingleItemExceptions * This,
            /* [range][in] */ ULONG cExceptions,
            /* [length_is][size_is][out] */ ISingleItemException **ppSingleItemException,
            /* [unique][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSingleItemExceptions * This,
            /* [in] */ ULONG cExceptions);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSingleItemExceptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSingleItemExceptions * This,
            /* [out] */ IEnumSingleItemExceptions **ppEnum);
        
        END_INTERFACE
    } IEnumSingleItemExceptionsVtbl;

    interface IEnumSingleItemExceptions
    {
        CONST_VTBL struct IEnumSingleItemExceptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSingleItemExceptions_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSingleItemExceptions_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSingleItemExceptions_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSingleItemExceptions_Next(This,cExceptions,ppSingleItemException,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cExceptions,ppSingleItemException,pcFetched) ) 

#define IEnumSingleItemExceptions_Skip(This,cExceptions)	\
    ( (This)->lpVtbl -> Skip(This,cExceptions) ) 

#define IEnumSingleItemExceptions_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSingleItemExceptions_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumSingleItemExceptions_INTERFACE_DEFINED__ */


#ifndef __IChangeUnitException_INTERFACE_DEFINED__
#define __IChangeUnitException_INTERFACE_DEFINED__

/* interface IChangeUnitException */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IChangeUnitException;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0cd7ee7c-fec0-4021-99ee-f0e5348f2a5f")
    IChangeUnitException : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetItemId( 
            /* [size_is][unique][out][in] */ BYTE *pbItemId,
            /* [out][in] */ DWORD *pcbIdSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeUnitId( 
            /* [size_is][unique][out][in] */ BYTE *pbChangeUnitId,
            /* [out][in] */ DWORD *pcbIdSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClockVector( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IChangeUnitExceptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IChangeUnitException * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IChangeUnitException * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IChangeUnitException * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemId )( 
            IChangeUnitException * This,
            /* [size_is][unique][out][in] */ BYTE *pbItemId,
            /* [out][in] */ DWORD *pcbIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeUnitId )( 
            IChangeUnitException * This,
            /* [size_is][unique][out][in] */ BYTE *pbChangeUnitId,
            /* [out][in] */ DWORD *pcbIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetClockVector )( 
            IChangeUnitException * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        END_INTERFACE
    } IChangeUnitExceptionVtbl;

    interface IChangeUnitException
    {
        CONST_VTBL struct IChangeUnitExceptionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IChangeUnitException_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IChangeUnitException_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IChangeUnitException_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IChangeUnitException_GetItemId(This,pbItemId,pcbIdSize)	\
    ( (This)->lpVtbl -> GetItemId(This,pbItemId,pcbIdSize) ) 

#define IChangeUnitException_GetChangeUnitId(This,pbChangeUnitId,pcbIdSize)	\
    ( (This)->lpVtbl -> GetChangeUnitId(This,pbChangeUnitId,pcbIdSize) ) 

#define IChangeUnitException_GetClockVector(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetClockVector(This,riid,ppUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IChangeUnitException_INTERFACE_DEFINED__ */


#ifndef __IEnumChangeUnitExceptions_INTERFACE_DEFINED__
#define __IEnumChangeUnitExceptions_INTERFACE_DEFINED__

/* interface IEnumChangeUnitExceptions */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IEnumChangeUnitExceptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3074e802-9319-4420-be21-1022e2e21da8")
    IEnumChangeUnitExceptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [range][in] */ ULONG cExceptions,
            /* [length_is][size_is][out] */ IChangeUnitException **ppChangeUnitException,
            /* [unique][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cExceptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumChangeUnitExceptions **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumChangeUnitExceptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumChangeUnitExceptions * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumChangeUnitExceptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumChangeUnitExceptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumChangeUnitExceptions * This,
            /* [range][in] */ ULONG cExceptions,
            /* [length_is][size_is][out] */ IChangeUnitException **ppChangeUnitException,
            /* [unique][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumChangeUnitExceptions * This,
            /* [in] */ ULONG cExceptions);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumChangeUnitExceptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumChangeUnitExceptions * This,
            /* [out] */ IEnumChangeUnitExceptions **ppEnum);
        
        END_INTERFACE
    } IEnumChangeUnitExceptionsVtbl;

    interface IEnumChangeUnitExceptions
    {
        CONST_VTBL struct IEnumChangeUnitExceptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumChangeUnitExceptions_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumChangeUnitExceptions_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumChangeUnitExceptions_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumChangeUnitExceptions_Next(This,cExceptions,ppChangeUnitException,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cExceptions,ppChangeUnitException,pcFetched) ) 

#define IEnumChangeUnitExceptions_Skip(This,cExceptions)	\
    ( (This)->lpVtbl -> Skip(This,cExceptions) ) 

#define IEnumChangeUnitExceptions_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumChangeUnitExceptions_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumChangeUnitExceptions_INTERFACE_DEFINED__ */


#ifndef __IReplicaKeyMap_INTERFACE_DEFINED__
#define __IReplicaKeyMap_INTERFACE_DEFINED__

/* interface IReplicaKeyMap */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IReplicaKeyMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2209F4FC-FD10-4ff0-84A8-F0A1982E440E")
    IReplicaKeyMap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LookupReplicaKey( 
            /* [in] */ const BYTE *pbReplicaId,
            /* [out] */ DWORD *pdwReplicaKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LookupReplicaId( 
            /* [in] */ DWORD dwReplicaKey,
            /* [size_is][unique][out][in] */ BYTE *pbReplicaId,
            /* [out][in] */ DWORD *pcbIdSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [size_is][unique][out][in] */ BYTE *pbReplicaKeyMap,
            /* [out][in] */ DWORD *pcbReplicaKeyMap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReplicaKeyMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IReplicaKeyMap * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IReplicaKeyMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IReplicaKeyMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *LookupReplicaKey )( 
            IReplicaKeyMap * This,
            /* [in] */ const BYTE *pbReplicaId,
            /* [out] */ DWORD *pdwReplicaKey);
        
        HRESULT ( STDMETHODCALLTYPE *LookupReplicaId )( 
            IReplicaKeyMap * This,
            /* [in] */ DWORD dwReplicaKey,
            /* [size_is][unique][out][in] */ BYTE *pbReplicaId,
            /* [out][in] */ DWORD *pcbIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            IReplicaKeyMap * This,
            /* [size_is][unique][out][in] */ BYTE *pbReplicaKeyMap,
            /* [out][in] */ DWORD *pcbReplicaKeyMap);
        
        END_INTERFACE
    } IReplicaKeyMapVtbl;

    interface IReplicaKeyMap
    {
        CONST_VTBL struct IReplicaKeyMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReplicaKeyMap_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IReplicaKeyMap_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IReplicaKeyMap_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IReplicaKeyMap_LookupReplicaKey(This,pbReplicaId,pdwReplicaKey)	\
    ( (This)->lpVtbl -> LookupReplicaKey(This,pbReplicaId,pdwReplicaKey) ) 

#define IReplicaKeyMap_LookupReplicaId(This,dwReplicaKey,pbReplicaId,pcbIdSize)	\
    ( (This)->lpVtbl -> LookupReplicaId(This,dwReplicaKey,pbReplicaId,pcbIdSize) ) 

#define IReplicaKeyMap_Serialize(This,pbReplicaKeyMap,pcbReplicaKeyMap)	\
    ( (This)->lpVtbl -> Serialize(This,pbReplicaKeyMap,pcbReplicaKeyMap) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IReplicaKeyMap_INTERFACE_DEFINED__ */


#ifndef __IConstructReplicaKeyMap_INTERFACE_DEFINED__
#define __IConstructReplicaKeyMap_INTERFACE_DEFINED__

/* interface IConstructReplicaKeyMap */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IConstructReplicaKeyMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ded10970-ec85-4115-b52c-4405845642a5")
    IConstructReplicaKeyMap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindOrAddReplica( 
            /* [in] */ const BYTE *pbReplicaId,
            /* [out] */ DWORD *pdwReplicaKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConstructReplicaKeyMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConstructReplicaKeyMap * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConstructReplicaKeyMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConstructReplicaKeyMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindOrAddReplica )( 
            IConstructReplicaKeyMap * This,
            /* [in] */ const BYTE *pbReplicaId,
            /* [out] */ DWORD *pdwReplicaKey);
        
        END_INTERFACE
    } IConstructReplicaKeyMapVtbl;

    interface IConstructReplicaKeyMap
    {
        CONST_VTBL struct IConstructReplicaKeyMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConstructReplicaKeyMap_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConstructReplicaKeyMap_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConstructReplicaKeyMap_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConstructReplicaKeyMap_FindOrAddReplica(This,pbReplicaId,pdwReplicaKey)	\
    ( (This)->lpVtbl -> FindOrAddReplica(This,pbReplicaId,pdwReplicaKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IConstructReplicaKeyMap_INTERFACE_DEFINED__ */


#ifndef __ISyncKnowledge_INTERFACE_DEFINED__
#define __ISyncKnowledge_INTERFACE_DEFINED__

/* interface ISyncKnowledge */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncKnowledge;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("615bbb53-c945-4203-bf4b-2cb65919a0aa")
    ISyncKnowledge : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwnerReplicaId( 
            /* [size_is][unique][out][in] */ BYTE *pbReplicaId,
            /* [out][in] */ DWORD *pcbIdSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [in] */ BOOL fSerializeReplicaKeyMap,
            /* [size_is][unique][out][in] */ BYTE *pbKnowledge,
            /* [out][in] */ DWORD *pcbKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocalTickCount( 
            /* [in] */ ULONGLONG ullTickCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ContainsChange( 
            /* [in] */ const BYTE *pbVersionOwnerReplicaId,
            /* [in] */ const BYTE *pgidItemId,
            /* [in] */ const SYNC_VERSION *pSyncVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ContainsChangeUnit( 
            /* [in] */ const BYTE *pbVersionOwnerReplicaId,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [in] */ const SYNC_VERSION *pSyncVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScopeVector( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReplicaKeyMap( 
            /* [out] */ IReplicaKeyMap **ppReplicaKeyMap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ ISyncKnowledge **ppClonedKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertVersion( 
            /* [in] */ ISyncKnowledge *pKnowledgeIn,
            /* [in] */ const BYTE *pbCurrentOwnerId,
            /* [in] */ const SYNC_VERSION *pVersionIn,
            /* [unique][in] */ BYTE *pbNewOwnerId,
            /* [out][in] */ DWORD *pcbIdSize,
            /* [out] */ SYNC_VERSION *pVersionOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapRemoteToLocal( 
            /* [in] */ ISyncKnowledge *pRemoteKnowledge,
            /* [out] */ ISyncKnowledge **ppMappedKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Union( 
            /* [in] */ ISyncKnowledge *pKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProjectOntoItem( 
            /* [in] */ const BYTE *pbItemId,
            /* [out] */ ISyncKnowledge **ppKnowledgeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProjectOntoChangeUnit( 
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [out] */ ISyncKnowledge **ppKnowledgeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProjectOntoRange( 
            /* [in] */ const SYNC_RANGE *psrngSyncRange,
            /* [out] */ ISyncKnowledge **ppKnowledgeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExcludeItem( 
            /* [in] */ const BYTE *pbItemId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExcludeChangeUnit( 
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ContainsKnowledge( 
            /* [in] */ ISyncKnowledge *pKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindMinTickCountForReplica( 
            /* [in] */ const BYTE *pbReplicaId,
            /* [out] */ ULONGLONG *pullReplicaTickCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRangeExceptions( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSingleItemExceptions( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeUnitExceptions( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindClockVectorForItem( 
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindClockVectorForChangeUnit( 
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ DWORD *pdwVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncKnowledgeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncKnowledge * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncKnowledge * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncKnowledge * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwnerReplicaId )( 
            ISyncKnowledge * This,
            /* [size_is][unique][out][in] */ BYTE *pbReplicaId,
            /* [out][in] */ DWORD *pcbIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ISyncKnowledge * This,
            /* [in] */ BOOL fSerializeReplicaKeyMap,
            /* [size_is][unique][out][in] */ BYTE *pbKnowledge,
            /* [out][in] */ DWORD *pcbKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocalTickCount )( 
            ISyncKnowledge * This,
            /* [in] */ ULONGLONG ullTickCount);
        
        HRESULT ( STDMETHODCALLTYPE *ContainsChange )( 
            ISyncKnowledge * This,
            /* [in] */ const BYTE *pbVersionOwnerReplicaId,
            /* [in] */ const BYTE *pgidItemId,
            /* [in] */ const SYNC_VERSION *pSyncVersion);
        
        HRESULT ( STDMETHODCALLTYPE *ContainsChangeUnit )( 
            ISyncKnowledge * This,
            /* [in] */ const BYTE *pbVersionOwnerReplicaId,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [in] */ const SYNC_VERSION *pSyncVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetScopeVector )( 
            ISyncKnowledge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetReplicaKeyMap )( 
            ISyncKnowledge * This,
            /* [out] */ IReplicaKeyMap **ppReplicaKeyMap);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ISyncKnowledge * This,
            /* [out] */ ISyncKnowledge **ppClonedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertVersion )( 
            ISyncKnowledge * This,
            /* [in] */ ISyncKnowledge *pKnowledgeIn,
            /* [in] */ const BYTE *pbCurrentOwnerId,
            /* [in] */ const SYNC_VERSION *pVersionIn,
            /* [unique][in] */ BYTE *pbNewOwnerId,
            /* [out][in] */ DWORD *pcbIdSize,
            /* [out] */ SYNC_VERSION *pVersionOut);
        
        HRESULT ( STDMETHODCALLTYPE *MapRemoteToLocal )( 
            ISyncKnowledge * This,
            /* [in] */ ISyncKnowledge *pRemoteKnowledge,
            /* [out] */ ISyncKnowledge **ppMappedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *Union )( 
            ISyncKnowledge * This,
            /* [in] */ ISyncKnowledge *pKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *ProjectOntoItem )( 
            ISyncKnowledge * This,
            /* [in] */ const BYTE *pbItemId,
            /* [out] */ ISyncKnowledge **ppKnowledgeOut);
        
        HRESULT ( STDMETHODCALLTYPE *ProjectOntoChangeUnit )( 
            ISyncKnowledge * This,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [out] */ ISyncKnowledge **ppKnowledgeOut);
        
        HRESULT ( STDMETHODCALLTYPE *ProjectOntoRange )( 
            ISyncKnowledge * This,
            /* [in] */ const SYNC_RANGE *psrngSyncRange,
            /* [out] */ ISyncKnowledge **ppKnowledgeOut);
        
        HRESULT ( STDMETHODCALLTYPE *ExcludeItem )( 
            ISyncKnowledge * This,
            /* [in] */ const BYTE *pbItemId);
        
        HRESULT ( STDMETHODCALLTYPE *ExcludeChangeUnit )( 
            ISyncKnowledge * This,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId);
        
        HRESULT ( STDMETHODCALLTYPE *ContainsKnowledge )( 
            ISyncKnowledge * This,
            /* [in] */ ISyncKnowledge *pKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *FindMinTickCountForReplica )( 
            ISyncKnowledge * This,
            /* [in] */ const BYTE *pbReplicaId,
            /* [out] */ ULONGLONG *pullReplicaTickCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetRangeExceptions )( 
            ISyncKnowledge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetSingleItemExceptions )( 
            ISyncKnowledge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeUnitExceptions )( 
            ISyncKnowledge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *FindClockVectorForItem )( 
            ISyncKnowledge * This,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *FindClockVectorForChangeUnit )( 
            ISyncKnowledge * This,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            ISyncKnowledge * This,
            /* [out] */ DWORD *pdwVersion);
        
        END_INTERFACE
    } ISyncKnowledgeVtbl;

    interface ISyncKnowledge
    {
        CONST_VTBL struct ISyncKnowledgeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncKnowledge_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncKnowledge_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncKnowledge_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncKnowledge_GetOwnerReplicaId(This,pbReplicaId,pcbIdSize)	\
    ( (This)->lpVtbl -> GetOwnerReplicaId(This,pbReplicaId,pcbIdSize) ) 

#define ISyncKnowledge_Serialize(This,fSerializeReplicaKeyMap,pbKnowledge,pcbKnowledge)	\
    ( (This)->lpVtbl -> Serialize(This,fSerializeReplicaKeyMap,pbKnowledge,pcbKnowledge) ) 

#define ISyncKnowledge_SetLocalTickCount(This,ullTickCount)	\
    ( (This)->lpVtbl -> SetLocalTickCount(This,ullTickCount) ) 

#define ISyncKnowledge_ContainsChange(This,pbVersionOwnerReplicaId,pgidItemId,pSyncVersion)	\
    ( (This)->lpVtbl -> ContainsChange(This,pbVersionOwnerReplicaId,pgidItemId,pSyncVersion) ) 

#define ISyncKnowledge_ContainsChangeUnit(This,pbVersionOwnerReplicaId,pbItemId,pbChangeUnitId,pSyncVersion)	\
    ( (This)->lpVtbl -> ContainsChangeUnit(This,pbVersionOwnerReplicaId,pbItemId,pbChangeUnitId,pSyncVersion) ) 

#define ISyncKnowledge_GetScopeVector(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetScopeVector(This,riid,ppUnk) ) 

#define ISyncKnowledge_GetReplicaKeyMap(This,ppReplicaKeyMap)	\
    ( (This)->lpVtbl -> GetReplicaKeyMap(This,ppReplicaKeyMap) ) 

#define ISyncKnowledge_Clone(This,ppClonedKnowledge)	\
    ( (This)->lpVtbl -> Clone(This,ppClonedKnowledge) ) 

#define ISyncKnowledge_ConvertVersion(This,pKnowledgeIn,pbCurrentOwnerId,pVersionIn,pbNewOwnerId,pcbIdSize,pVersionOut)	\
    ( (This)->lpVtbl -> ConvertVersion(This,pKnowledgeIn,pbCurrentOwnerId,pVersionIn,pbNewOwnerId,pcbIdSize,pVersionOut) ) 

#define ISyncKnowledge_MapRemoteToLocal(This,pRemoteKnowledge,ppMappedKnowledge)	\
    ( (This)->lpVtbl -> MapRemoteToLocal(This,pRemoteKnowledge,ppMappedKnowledge) ) 

#define ISyncKnowledge_Union(This,pKnowledge)	\
    ( (This)->lpVtbl -> Union(This,pKnowledge) ) 

#define ISyncKnowledge_ProjectOntoItem(This,pbItemId,ppKnowledgeOut)	\
    ( (This)->lpVtbl -> ProjectOntoItem(This,pbItemId,ppKnowledgeOut) ) 

#define ISyncKnowledge_ProjectOntoChangeUnit(This,pbItemId,pbChangeUnitId,ppKnowledgeOut)	\
    ( (This)->lpVtbl -> ProjectOntoChangeUnit(This,pbItemId,pbChangeUnitId,ppKnowledgeOut) ) 

#define ISyncKnowledge_ProjectOntoRange(This,psrngSyncRange,ppKnowledgeOut)	\
    ( (This)->lpVtbl -> ProjectOntoRange(This,psrngSyncRange,ppKnowledgeOut) ) 

#define ISyncKnowledge_ExcludeItem(This,pbItemId)	\
    ( (This)->lpVtbl -> ExcludeItem(This,pbItemId) ) 

#define ISyncKnowledge_ExcludeChangeUnit(This,pbItemId,pbChangeUnitId)	\
    ( (This)->lpVtbl -> ExcludeChangeUnit(This,pbItemId,pbChangeUnitId) ) 

#define ISyncKnowledge_ContainsKnowledge(This,pKnowledge)	\
    ( (This)->lpVtbl -> ContainsKnowledge(This,pKnowledge) ) 

#define ISyncKnowledge_FindMinTickCountForReplica(This,pbReplicaId,pullReplicaTickCount)	\
    ( (This)->lpVtbl -> FindMinTickCountForReplica(This,pbReplicaId,pullReplicaTickCount) ) 

#define ISyncKnowledge_GetRangeExceptions(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetRangeExceptions(This,riid,ppUnk) ) 

#define ISyncKnowledge_GetSingleItemExceptions(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetSingleItemExceptions(This,riid,ppUnk) ) 

#define ISyncKnowledge_GetChangeUnitExceptions(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetChangeUnitExceptions(This,riid,ppUnk) ) 

#define ISyncKnowledge_FindClockVectorForItem(This,pbItemId,riid,ppUnk)	\
    ( (This)->lpVtbl -> FindClockVectorForItem(This,pbItemId,riid,ppUnk) ) 

#define ISyncKnowledge_FindClockVectorForChangeUnit(This,pbItemId,pbChangeUnitId,riid,ppUnk)	\
    ( (This)->lpVtbl -> FindClockVectorForChangeUnit(This,pbItemId,pbChangeUnitId,riid,ppUnk) ) 

#define ISyncKnowledge_GetVersion(This,pdwVersion)	\
    ( (This)->lpVtbl -> GetVersion(This,pdwVersion) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncKnowledge_INTERFACE_DEFINED__ */


#ifndef __IForgottenKnowledge_INTERFACE_DEFINED__
#define __IForgottenKnowledge_INTERFACE_DEFINED__

/* interface IForgottenKnowledge */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IForgottenKnowledge;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("456e0f96-6036-452b-9f9d-bcc4b4a85db2")
    IForgottenKnowledge : public ISyncKnowledge
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ForgetToVersion( 
            /* [in] */ ISyncKnowledge *pKnowledge,
            /* [in] */ const SYNC_VERSION *pVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IForgottenKnowledgeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IForgottenKnowledge * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IForgottenKnowledge * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IForgottenKnowledge * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwnerReplicaId )( 
            IForgottenKnowledge * This,
            /* [size_is][unique][out][in] */ BYTE *pbReplicaId,
            /* [out][in] */ DWORD *pcbIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            IForgottenKnowledge * This,
            /* [in] */ BOOL fSerializeReplicaKeyMap,
            /* [size_is][unique][out][in] */ BYTE *pbKnowledge,
            /* [out][in] */ DWORD *pcbKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocalTickCount )( 
            IForgottenKnowledge * This,
            /* [in] */ ULONGLONG ullTickCount);
        
        HRESULT ( STDMETHODCALLTYPE *ContainsChange )( 
            IForgottenKnowledge * This,
            /* [in] */ const BYTE *pbVersionOwnerReplicaId,
            /* [in] */ const BYTE *pgidItemId,
            /* [in] */ const SYNC_VERSION *pSyncVersion);
        
        HRESULT ( STDMETHODCALLTYPE *ContainsChangeUnit )( 
            IForgottenKnowledge * This,
            /* [in] */ const BYTE *pbVersionOwnerReplicaId,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [in] */ const SYNC_VERSION *pSyncVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetScopeVector )( 
            IForgottenKnowledge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetReplicaKeyMap )( 
            IForgottenKnowledge * This,
            /* [out] */ IReplicaKeyMap **ppReplicaKeyMap);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IForgottenKnowledge * This,
            /* [out] */ ISyncKnowledge **ppClonedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertVersion )( 
            IForgottenKnowledge * This,
            /* [in] */ ISyncKnowledge *pKnowledgeIn,
            /* [in] */ const BYTE *pbCurrentOwnerId,
            /* [in] */ const SYNC_VERSION *pVersionIn,
            /* [unique][in] */ BYTE *pbNewOwnerId,
            /* [out][in] */ DWORD *pcbIdSize,
            /* [out] */ SYNC_VERSION *pVersionOut);
        
        HRESULT ( STDMETHODCALLTYPE *MapRemoteToLocal )( 
            IForgottenKnowledge * This,
            /* [in] */ ISyncKnowledge *pRemoteKnowledge,
            /* [out] */ ISyncKnowledge **ppMappedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *Union )( 
            IForgottenKnowledge * This,
            /* [in] */ ISyncKnowledge *pKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *ProjectOntoItem )( 
            IForgottenKnowledge * This,
            /* [in] */ const BYTE *pbItemId,
            /* [out] */ ISyncKnowledge **ppKnowledgeOut);
        
        HRESULT ( STDMETHODCALLTYPE *ProjectOntoChangeUnit )( 
            IForgottenKnowledge * This,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [out] */ ISyncKnowledge **ppKnowledgeOut);
        
        HRESULT ( STDMETHODCALLTYPE *ProjectOntoRange )( 
            IForgottenKnowledge * This,
            /* [in] */ const SYNC_RANGE *psrngSyncRange,
            /* [out] */ ISyncKnowledge **ppKnowledgeOut);
        
        HRESULT ( STDMETHODCALLTYPE *ExcludeItem )( 
            IForgottenKnowledge * This,
            /* [in] */ const BYTE *pbItemId);
        
        HRESULT ( STDMETHODCALLTYPE *ExcludeChangeUnit )( 
            IForgottenKnowledge * This,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId);
        
        HRESULT ( STDMETHODCALLTYPE *ContainsKnowledge )( 
            IForgottenKnowledge * This,
            /* [in] */ ISyncKnowledge *pKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *FindMinTickCountForReplica )( 
            IForgottenKnowledge * This,
            /* [in] */ const BYTE *pbReplicaId,
            /* [out] */ ULONGLONG *pullReplicaTickCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetRangeExceptions )( 
            IForgottenKnowledge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetSingleItemExceptions )( 
            IForgottenKnowledge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeUnitExceptions )( 
            IForgottenKnowledge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *FindClockVectorForItem )( 
            IForgottenKnowledge * This,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *FindClockVectorForChangeUnit )( 
            IForgottenKnowledge * This,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            IForgottenKnowledge * This,
            /* [out] */ DWORD *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE *ForgetToVersion )( 
            IForgottenKnowledge * This,
            /* [in] */ ISyncKnowledge *pKnowledge,
            /* [in] */ const SYNC_VERSION *pVersion);
        
        END_INTERFACE
    } IForgottenKnowledgeVtbl;

    interface IForgottenKnowledge
    {
        CONST_VTBL struct IForgottenKnowledgeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IForgottenKnowledge_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IForgottenKnowledge_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IForgottenKnowledge_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IForgottenKnowledge_GetOwnerReplicaId(This,pbReplicaId,pcbIdSize)	\
    ( (This)->lpVtbl -> GetOwnerReplicaId(This,pbReplicaId,pcbIdSize) ) 

#define IForgottenKnowledge_Serialize(This,fSerializeReplicaKeyMap,pbKnowledge,pcbKnowledge)	\
    ( (This)->lpVtbl -> Serialize(This,fSerializeReplicaKeyMap,pbKnowledge,pcbKnowledge) ) 

#define IForgottenKnowledge_SetLocalTickCount(This,ullTickCount)	\
    ( (This)->lpVtbl -> SetLocalTickCount(This,ullTickCount) ) 

#define IForgottenKnowledge_ContainsChange(This,pbVersionOwnerReplicaId,pgidItemId,pSyncVersion)	\
    ( (This)->lpVtbl -> ContainsChange(This,pbVersionOwnerReplicaId,pgidItemId,pSyncVersion) ) 

#define IForgottenKnowledge_ContainsChangeUnit(This,pbVersionOwnerReplicaId,pbItemId,pbChangeUnitId,pSyncVersion)	\
    ( (This)->lpVtbl -> ContainsChangeUnit(This,pbVersionOwnerReplicaId,pbItemId,pbChangeUnitId,pSyncVersion) ) 

#define IForgottenKnowledge_GetScopeVector(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetScopeVector(This,riid,ppUnk) ) 

#define IForgottenKnowledge_GetReplicaKeyMap(This,ppReplicaKeyMap)	\
    ( (This)->lpVtbl -> GetReplicaKeyMap(This,ppReplicaKeyMap) ) 

#define IForgottenKnowledge_Clone(This,ppClonedKnowledge)	\
    ( (This)->lpVtbl -> Clone(This,ppClonedKnowledge) ) 

#define IForgottenKnowledge_ConvertVersion(This,pKnowledgeIn,pbCurrentOwnerId,pVersionIn,pbNewOwnerId,pcbIdSize,pVersionOut)	\
    ( (This)->lpVtbl -> ConvertVersion(This,pKnowledgeIn,pbCurrentOwnerId,pVersionIn,pbNewOwnerId,pcbIdSize,pVersionOut) ) 

#define IForgottenKnowledge_MapRemoteToLocal(This,pRemoteKnowledge,ppMappedKnowledge)	\
    ( (This)->lpVtbl -> MapRemoteToLocal(This,pRemoteKnowledge,ppMappedKnowledge) ) 

#define IForgottenKnowledge_Union(This,pKnowledge)	\
    ( (This)->lpVtbl -> Union(This,pKnowledge) ) 

#define IForgottenKnowledge_ProjectOntoItem(This,pbItemId,ppKnowledgeOut)	\
    ( (This)->lpVtbl -> ProjectOntoItem(This,pbItemId,ppKnowledgeOut) ) 

#define IForgottenKnowledge_ProjectOntoChangeUnit(This,pbItemId,pbChangeUnitId,ppKnowledgeOut)	\
    ( (This)->lpVtbl -> ProjectOntoChangeUnit(This,pbItemId,pbChangeUnitId,ppKnowledgeOut) ) 

#define IForgottenKnowledge_ProjectOntoRange(This,psrngSyncRange,ppKnowledgeOut)	\
    ( (This)->lpVtbl -> ProjectOntoRange(This,psrngSyncRange,ppKnowledgeOut) ) 

#define IForgottenKnowledge_ExcludeItem(This,pbItemId)	\
    ( (This)->lpVtbl -> ExcludeItem(This,pbItemId) ) 

#define IForgottenKnowledge_ExcludeChangeUnit(This,pbItemId,pbChangeUnitId)	\
    ( (This)->lpVtbl -> ExcludeChangeUnit(This,pbItemId,pbChangeUnitId) ) 

#define IForgottenKnowledge_ContainsKnowledge(This,pKnowledge)	\
    ( (This)->lpVtbl -> ContainsKnowledge(This,pKnowledge) ) 

#define IForgottenKnowledge_FindMinTickCountForReplica(This,pbReplicaId,pullReplicaTickCount)	\
    ( (This)->lpVtbl -> FindMinTickCountForReplica(This,pbReplicaId,pullReplicaTickCount) ) 

#define IForgottenKnowledge_GetRangeExceptions(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetRangeExceptions(This,riid,ppUnk) ) 

#define IForgottenKnowledge_GetSingleItemExceptions(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetSingleItemExceptions(This,riid,ppUnk) ) 

#define IForgottenKnowledge_GetChangeUnitExceptions(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetChangeUnitExceptions(This,riid,ppUnk) ) 

#define IForgottenKnowledge_FindClockVectorForItem(This,pbItemId,riid,ppUnk)	\
    ( (This)->lpVtbl -> FindClockVectorForItem(This,pbItemId,riid,ppUnk) ) 

#define IForgottenKnowledge_FindClockVectorForChangeUnit(This,pbItemId,pbChangeUnitId,riid,ppUnk)	\
    ( (This)->lpVtbl -> FindClockVectorForChangeUnit(This,pbItemId,pbChangeUnitId,riid,ppUnk) ) 

#define IForgottenKnowledge_GetVersion(This,pdwVersion)	\
    ( (This)->lpVtbl -> GetVersion(This,pdwVersion) ) 


#define IForgottenKnowledge_ForgetToVersion(This,pKnowledge,pVersion)	\
    ( (This)->lpVtbl -> ForgetToVersion(This,pKnowledge,pVersion) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IForgottenKnowledge_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_winsync_0000_0018 */
/* [local] */ 

#define SYNC_SERIALIZE_REPLICA_KEY_MAP                 0x00000001


extern RPC_IF_HANDLE __MIDL_itf_winsync_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_winsync_0000_0018_v0_0_s_ifspec;

#ifndef __ISyncKnowledge2_INTERFACE_DEFINED__
#define __ISyncKnowledge2_INTERFACE_DEFINED__

/* interface ISyncKnowledge2 */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncKnowledge2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ed0addc0-3b4b-46a1-9a45-45661d2114c8")
    ISyncKnowledge2 : public ISyncKnowledge
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIdParameters( 
            /* [out] */ ID_PARAMETERS *pIdParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProjectOntoColumnSet( 
            /* [in] */ const BYTE **ppColumns,
            /* [in] */ DWORD count,
            /* [out] */ ISyncKnowledge2 **ppiKnowledgeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SerializeWithOptions( 
            /* [in] */ SYNC_SERIALIZATION_VERSION targetFormatVersion,
            /* [in] */ DWORD dwFlags,
            /* [size_is][unique][out][in] */ BYTE *pbBuffer,
            /* [out][in] */ DWORD *pdwSerializedSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLowestUncontainedId( 
            /* [in] */ ISyncKnowledge2 *piSyncKnowledge,
            /* [size_is][unique][out][in] */ BYTE *pbItemId,
            /* [out][in] */ DWORD *pcbItemIdSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInspector( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppiInspector) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinimumSupportedVersion( 
            /* [out] */ SYNC_SERIALIZATION_VERSION *pVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ SYNC_STATISTICS which,
            /* [out] */ DWORD *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ContainsKnowledgeForItem( 
            /* [in] */ ISyncKnowledge *pKnowledge,
            /* [in] */ const BYTE *pbItemId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ContainsKnowledgeForChangeUnit( 
            /* [in] */ ISyncKnowledge *pKnowledge,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProjectOntoKnowledgeWithPrerequisite( 
            /* [in] */ ISyncKnowledge *pPrerequisiteKnowledge,
            /* [in] */ ISyncKnowledge *pTemplateKnowledge,
            /* [out] */ ISyncKnowledge **ppProjectedKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Complement( 
            /* [in] */ ISyncKnowledge *pSyncKnowledge,
            /* [out] */ ISyncKnowledge **ppComplementedKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IntersectsWithKnowledge( 
            /* [in] */ ISyncKnowledge *pSyncKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKnowledgeCookie( 
            /* [out] */ IUnknown **ppKnowledgeCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareToKnowledgeCookie( 
            /* [in] */ IUnknown *pKnowledgeCookie,
            /* [out] */ KNOWLEDGE_COOKIE_COMPARISON_RESULT *pResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncKnowledge2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncKnowledge2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncKnowledge2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncKnowledge2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwnerReplicaId )( 
            ISyncKnowledge2 * This,
            /* [size_is][unique][out][in] */ BYTE *pbReplicaId,
            /* [out][in] */ DWORD *pcbIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ISyncKnowledge2 * This,
            /* [in] */ BOOL fSerializeReplicaKeyMap,
            /* [size_is][unique][out][in] */ BYTE *pbKnowledge,
            /* [out][in] */ DWORD *pcbKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocalTickCount )( 
            ISyncKnowledge2 * This,
            /* [in] */ ULONGLONG ullTickCount);
        
        HRESULT ( STDMETHODCALLTYPE *ContainsChange )( 
            ISyncKnowledge2 * This,
            /* [in] */ const BYTE *pbVersionOwnerReplicaId,
            /* [in] */ const BYTE *pgidItemId,
            /* [in] */ const SYNC_VERSION *pSyncVersion);
        
        HRESULT ( STDMETHODCALLTYPE *ContainsChangeUnit )( 
            ISyncKnowledge2 * This,
            /* [in] */ const BYTE *pbVersionOwnerReplicaId,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [in] */ const SYNC_VERSION *pSyncVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetScopeVector )( 
            ISyncKnowledge2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetReplicaKeyMap )( 
            ISyncKnowledge2 * This,
            /* [out] */ IReplicaKeyMap **ppReplicaKeyMap);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ISyncKnowledge2 * This,
            /* [out] */ ISyncKnowledge **ppClonedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertVersion )( 
            ISyncKnowledge2 * This,
            /* [in] */ ISyncKnowledge *pKnowledgeIn,
            /* [in] */ const BYTE *pbCurrentOwnerId,
            /* [in] */ const SYNC_VERSION *pVersionIn,
            /* [unique][in] */ BYTE *pbNewOwnerId,
            /* [out][in] */ DWORD *pcbIdSize,
            /* [out] */ SYNC_VERSION *pVersionOut);
        
        HRESULT ( STDMETHODCALLTYPE *MapRemoteToLocal )( 
            ISyncKnowledge2 * This,
            /* [in] */ ISyncKnowledge *pRemoteKnowledge,
            /* [out] */ ISyncKnowledge **ppMappedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *Union )( 
            ISyncKnowledge2 * This,
            /* [in] */ ISyncKnowledge *pKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *ProjectOntoItem )( 
            ISyncKnowledge2 * This,
            /* [in] */ const BYTE *pbItemId,
            /* [out] */ ISyncKnowledge **ppKnowledgeOut);
        
        HRESULT ( STDMETHODCALLTYPE *ProjectOntoChangeUnit )( 
            ISyncKnowledge2 * This,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [out] */ ISyncKnowledge **ppKnowledgeOut);
        
        HRESULT ( STDMETHODCALLTYPE *ProjectOntoRange )( 
            ISyncKnowledge2 * This,
            /* [in] */ const SYNC_RANGE *psrngSyncRange,
            /* [out] */ ISyncKnowledge **ppKnowledgeOut);
        
        HRESULT ( STDMETHODCALLTYPE *ExcludeItem )( 
            ISyncKnowledge2 * This,
            /* [in] */ const BYTE *pbItemId);
        
        HRESULT ( STDMETHODCALLTYPE *ExcludeChangeUnit )( 
            ISyncKnowledge2 * This,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId);
        
        HRESULT ( STDMETHODCALLTYPE *ContainsKnowledge )( 
            ISyncKnowledge2 * This,
            /* [in] */ ISyncKnowledge *pKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *FindMinTickCountForReplica )( 
            ISyncKnowledge2 * This,
            /* [in] */ const BYTE *pbReplicaId,
            /* [out] */ ULONGLONG *pullReplicaTickCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetRangeExceptions )( 
            ISyncKnowledge2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetSingleItemExceptions )( 
            ISyncKnowledge2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeUnitExceptions )( 
            ISyncKnowledge2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *FindClockVectorForItem )( 
            ISyncKnowledge2 * This,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *FindClockVectorForChangeUnit )( 
            ISyncKnowledge2 * This,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            ISyncKnowledge2 * This,
            /* [out] */ DWORD *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdParameters )( 
            ISyncKnowledge2 * This,
            /* [out] */ ID_PARAMETERS *pIdParameters);
        
        HRESULT ( STDMETHODCALLTYPE *ProjectOntoColumnSet )( 
            ISyncKnowledge2 * This,
            /* [in] */ const BYTE **ppColumns,
            /* [in] */ DWORD count,
            /* [out] */ ISyncKnowledge2 **ppiKnowledgeOut);
        
        HRESULT ( STDMETHODCALLTYPE *SerializeWithOptions )( 
            ISyncKnowledge2 * This,
            /* [in] */ SYNC_SERIALIZATION_VERSION targetFormatVersion,
            /* [in] */ DWORD dwFlags,
            /* [size_is][unique][out][in] */ BYTE *pbBuffer,
            /* [out][in] */ DWORD *pdwSerializedSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetLowestUncontainedId )( 
            ISyncKnowledge2 * This,
            /* [in] */ ISyncKnowledge2 *piSyncKnowledge,
            /* [size_is][unique][out][in] */ BYTE *pbItemId,
            /* [out][in] */ DWORD *pcbItemIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetInspector )( 
            ISyncKnowledge2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppiInspector);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinimumSupportedVersion )( 
            ISyncKnowledge2 * This,
            /* [out] */ SYNC_SERIALIZATION_VERSION *pVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            ISyncKnowledge2 * This,
            /* [in] */ SYNC_STATISTICS which,
            /* [out] */ DWORD *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *ContainsKnowledgeForItem )( 
            ISyncKnowledge2 * This,
            /* [in] */ ISyncKnowledge *pKnowledge,
            /* [in] */ const BYTE *pbItemId);
        
        HRESULT ( STDMETHODCALLTYPE *ContainsKnowledgeForChangeUnit )( 
            ISyncKnowledge2 * This,
            /* [in] */ ISyncKnowledge *pKnowledge,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId);
        
        HRESULT ( STDMETHODCALLTYPE *ProjectOntoKnowledgeWithPrerequisite )( 
            ISyncKnowledge2 * This,
            /* [in] */ ISyncKnowledge *pPrerequisiteKnowledge,
            /* [in] */ ISyncKnowledge *pTemplateKnowledge,
            /* [out] */ ISyncKnowledge **ppProjectedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *Complement )( 
            ISyncKnowledge2 * This,
            /* [in] */ ISyncKnowledge *pSyncKnowledge,
            /* [out] */ ISyncKnowledge **ppComplementedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *IntersectsWithKnowledge )( 
            ISyncKnowledge2 * This,
            /* [in] */ ISyncKnowledge *pSyncKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetKnowledgeCookie )( 
            ISyncKnowledge2 * This,
            /* [out] */ IUnknown **ppKnowledgeCookie);
        
        HRESULT ( STDMETHODCALLTYPE *CompareToKnowledgeCookie )( 
            ISyncKnowledge2 * This,
            /* [in] */ IUnknown *pKnowledgeCookie,
            /* [out] */ KNOWLEDGE_COOKIE_COMPARISON_RESULT *pResult);
        
        END_INTERFACE
    } ISyncKnowledge2Vtbl;

    interface ISyncKnowledge2
    {
        CONST_VTBL struct ISyncKnowledge2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncKnowledge2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncKnowledge2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncKnowledge2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncKnowledge2_GetOwnerReplicaId(This,pbReplicaId,pcbIdSize)	\
    ( (This)->lpVtbl -> GetOwnerReplicaId(This,pbReplicaId,pcbIdSize) ) 

#define ISyncKnowledge2_Serialize(This,fSerializeReplicaKeyMap,pbKnowledge,pcbKnowledge)	\
    ( (This)->lpVtbl -> Serialize(This,fSerializeReplicaKeyMap,pbKnowledge,pcbKnowledge) ) 

#define ISyncKnowledge2_SetLocalTickCount(This,ullTickCount)	\
    ( (This)->lpVtbl -> SetLocalTickCount(This,ullTickCount) ) 

#define ISyncKnowledge2_ContainsChange(This,pbVersionOwnerReplicaId,pgidItemId,pSyncVersion)	\
    ( (This)->lpVtbl -> ContainsChange(This,pbVersionOwnerReplicaId,pgidItemId,pSyncVersion) ) 

#define ISyncKnowledge2_ContainsChangeUnit(This,pbVersionOwnerReplicaId,pbItemId,pbChangeUnitId,pSyncVersion)	\
    ( (This)->lpVtbl -> ContainsChangeUnit(This,pbVersionOwnerReplicaId,pbItemId,pbChangeUnitId,pSyncVersion) ) 

#define ISyncKnowledge2_GetScopeVector(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetScopeVector(This,riid,ppUnk) ) 

#define ISyncKnowledge2_GetReplicaKeyMap(This,ppReplicaKeyMap)	\
    ( (This)->lpVtbl -> GetReplicaKeyMap(This,ppReplicaKeyMap) ) 

#define ISyncKnowledge2_Clone(This,ppClonedKnowledge)	\
    ( (This)->lpVtbl -> Clone(This,ppClonedKnowledge) ) 

#define ISyncKnowledge2_ConvertVersion(This,pKnowledgeIn,pbCurrentOwnerId,pVersionIn,pbNewOwnerId,pcbIdSize,pVersionOut)	\
    ( (This)->lpVtbl -> ConvertVersion(This,pKnowledgeIn,pbCurrentOwnerId,pVersionIn,pbNewOwnerId,pcbIdSize,pVersionOut) ) 

#define ISyncKnowledge2_MapRemoteToLocal(This,pRemoteKnowledge,ppMappedKnowledge)	\
    ( (This)->lpVtbl -> MapRemoteToLocal(This,pRemoteKnowledge,ppMappedKnowledge) ) 

#define ISyncKnowledge2_Union(This,pKnowledge)	\
    ( (This)->lpVtbl -> Union(This,pKnowledge) ) 

#define ISyncKnowledge2_ProjectOntoItem(This,pbItemId,ppKnowledgeOut)	\
    ( (This)->lpVtbl -> ProjectOntoItem(This,pbItemId,ppKnowledgeOut) ) 

#define ISyncKnowledge2_ProjectOntoChangeUnit(This,pbItemId,pbChangeUnitId,ppKnowledgeOut)	\
    ( (This)->lpVtbl -> ProjectOntoChangeUnit(This,pbItemId,pbChangeUnitId,ppKnowledgeOut) ) 

#define ISyncKnowledge2_ProjectOntoRange(This,psrngSyncRange,ppKnowledgeOut)	\
    ( (This)->lpVtbl -> ProjectOntoRange(This,psrngSyncRange,ppKnowledgeOut) ) 

#define ISyncKnowledge2_ExcludeItem(This,pbItemId)	\
    ( (This)->lpVtbl -> ExcludeItem(This,pbItemId) ) 

#define ISyncKnowledge2_ExcludeChangeUnit(This,pbItemId,pbChangeUnitId)	\
    ( (This)->lpVtbl -> ExcludeChangeUnit(This,pbItemId,pbChangeUnitId) ) 

#define ISyncKnowledge2_ContainsKnowledge(This,pKnowledge)	\
    ( (This)->lpVtbl -> ContainsKnowledge(This,pKnowledge) ) 

#define ISyncKnowledge2_FindMinTickCountForReplica(This,pbReplicaId,pullReplicaTickCount)	\
    ( (This)->lpVtbl -> FindMinTickCountForReplica(This,pbReplicaId,pullReplicaTickCount) ) 

#define ISyncKnowledge2_GetRangeExceptions(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetRangeExceptions(This,riid,ppUnk) ) 

#define ISyncKnowledge2_GetSingleItemExceptions(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetSingleItemExceptions(This,riid,ppUnk) ) 

#define ISyncKnowledge2_GetChangeUnitExceptions(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetChangeUnitExceptions(This,riid,ppUnk) ) 

#define ISyncKnowledge2_FindClockVectorForItem(This,pbItemId,riid,ppUnk)	\
    ( (This)->lpVtbl -> FindClockVectorForItem(This,pbItemId,riid,ppUnk) ) 

#define ISyncKnowledge2_FindClockVectorForChangeUnit(This,pbItemId,pbChangeUnitId,riid,ppUnk)	\
    ( (This)->lpVtbl -> FindClockVectorForChangeUnit(This,pbItemId,pbChangeUnitId,riid,ppUnk) ) 

#define ISyncKnowledge2_GetVersion(This,pdwVersion)	\
    ( (This)->lpVtbl -> GetVersion(This,pdwVersion) ) 


#define ISyncKnowledge2_GetIdParameters(This,pIdParameters)	\
    ( (This)->lpVtbl -> GetIdParameters(This,pIdParameters) ) 

#define ISyncKnowledge2_ProjectOntoColumnSet(This,ppColumns,count,ppiKnowledgeOut)	\
    ( (This)->lpVtbl -> ProjectOntoColumnSet(This,ppColumns,count,ppiKnowledgeOut) ) 

#define ISyncKnowledge2_SerializeWithOptions(This,targetFormatVersion,dwFlags,pbBuffer,pdwSerializedSize)	\
    ( (This)->lpVtbl -> SerializeWithOptions(This,targetFormatVersion,dwFlags,pbBuffer,pdwSerializedSize) ) 

#define ISyncKnowledge2_GetLowestUncontainedId(This,piSyncKnowledge,pbItemId,pcbItemIdSize)	\
    ( (This)->lpVtbl -> GetLowestUncontainedId(This,piSyncKnowledge,pbItemId,pcbItemIdSize) ) 

#define ISyncKnowledge2_GetInspector(This,riid,ppiInspector)	\
    ( (This)->lpVtbl -> GetInspector(This,riid,ppiInspector) ) 

#define ISyncKnowledge2_GetMinimumSupportedVersion(This,pVersion)	\
    ( (This)->lpVtbl -> GetMinimumSupportedVersion(This,pVersion) ) 

#define ISyncKnowledge2_GetStatistics(This,which,pValue)	\
    ( (This)->lpVtbl -> GetStatistics(This,which,pValue) ) 

#define ISyncKnowledge2_ContainsKnowledgeForItem(This,pKnowledge,pbItemId)	\
    ( (This)->lpVtbl -> ContainsKnowledgeForItem(This,pKnowledge,pbItemId) ) 

#define ISyncKnowledge2_ContainsKnowledgeForChangeUnit(This,pKnowledge,pbItemId,pbChangeUnitId)	\
    ( (This)->lpVtbl -> ContainsKnowledgeForChangeUnit(This,pKnowledge,pbItemId,pbChangeUnitId) ) 

#define ISyncKnowledge2_ProjectOntoKnowledgeWithPrerequisite(This,pPrerequisiteKnowledge,pTemplateKnowledge,ppProjectedKnowledge)	\
    ( (This)->lpVtbl -> ProjectOntoKnowledgeWithPrerequisite(This,pPrerequisiteKnowledge,pTemplateKnowledge,ppProjectedKnowledge) ) 

#define ISyncKnowledge2_Complement(This,pSyncKnowledge,ppComplementedKnowledge)	\
    ( (This)->lpVtbl -> Complement(This,pSyncKnowledge,ppComplementedKnowledge) ) 

#define ISyncKnowledge2_IntersectsWithKnowledge(This,pSyncKnowledge)	\
    ( (This)->lpVtbl -> IntersectsWithKnowledge(This,pSyncKnowledge) ) 

#define ISyncKnowledge2_GetKnowledgeCookie(This,ppKnowledgeCookie)	\
    ( (This)->lpVtbl -> GetKnowledgeCookie(This,ppKnowledgeCookie) ) 

#define ISyncKnowledge2_CompareToKnowledgeCookie(This,pKnowledgeCookie,pResult)	\
    ( (This)->lpVtbl -> CompareToKnowledgeCookie(This,pKnowledgeCookie,pResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncKnowledge2_INTERFACE_DEFINED__ */


#ifndef __IRecoverableErrorData_INTERFACE_DEFINED__
#define __IRecoverableErrorData_INTERFACE_DEFINED__

/* interface IRecoverableErrorData */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IRecoverableErrorData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b37c4a0a-4b7d-4c2d-9711-3b00d119b1c8")
    IRecoverableErrorData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [unique][in] */ LPCWSTR pcszItemDisplayName,
            /* [unique][in] */ LPCWSTR pcszErrorDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemDisplayName( 
            /* [size_is][string][unique][out][in] */ LPWSTR pszItemDisplayName,
            /* [out][in] */ DWORD *pcchItemDisplayName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorDescription( 
            /* [size_is][string][unique][out][in] */ LPWSTR pszErrorDescription,
            /* [out][in] */ DWORD *pcchErrorDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRecoverableErrorDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRecoverableErrorData * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRecoverableErrorData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRecoverableErrorData * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IRecoverableErrorData * This,
            /* [unique][in] */ LPCWSTR pcszItemDisplayName,
            /* [unique][in] */ LPCWSTR pcszErrorDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemDisplayName )( 
            IRecoverableErrorData * This,
            /* [size_is][string][unique][out][in] */ LPWSTR pszItemDisplayName,
            /* [out][in] */ DWORD *pcchItemDisplayName);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorDescription )( 
            IRecoverableErrorData * This,
            /* [size_is][string][unique][out][in] */ LPWSTR pszErrorDescription,
            /* [out][in] */ DWORD *pcchErrorDescription);
        
        END_INTERFACE
    } IRecoverableErrorDataVtbl;

    interface IRecoverableErrorData
    {
        CONST_VTBL struct IRecoverableErrorDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRecoverableErrorData_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRecoverableErrorData_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRecoverableErrorData_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRecoverableErrorData_Initialize(This,pcszItemDisplayName,pcszErrorDescription)	\
    ( (This)->lpVtbl -> Initialize(This,pcszItemDisplayName,pcszErrorDescription) ) 

#define IRecoverableErrorData_GetItemDisplayName(This,pszItemDisplayName,pcchItemDisplayName)	\
    ( (This)->lpVtbl -> GetItemDisplayName(This,pszItemDisplayName,pcchItemDisplayName) ) 

#define IRecoverableErrorData_GetErrorDescription(This,pszErrorDescription,pcchErrorDescription)	\
    ( (This)->lpVtbl -> GetErrorDescription(This,pszErrorDescription,pcchErrorDescription) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRecoverableErrorData_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_winsync_0000_0020 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_winsync_0000_0020_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_winsync_0000_0020_v0_0_s_ifspec;

#ifndef __IRecoverableError_INTERFACE_DEFINED__
#define __IRecoverableError_INTERFACE_DEFINED__

/* interface IRecoverableError */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IRecoverableError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0f5625e8-0a7b-45ee-9637-1ce13645909e")
    IRecoverableError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStage( 
            /* [out] */ SYNC_PROGRESS_STAGE *pStage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ SYNC_PROVIDER_ROLE *pProviderRole) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeWithRecoverableError( 
            /* [out] */ ISyncChange **ppChangeWithRecoverableError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecoverableErrorDataForChange( 
            /* [out] */ HRESULT *phrError,
            /* [out] */ IRecoverableErrorData **ppErrorData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecoverableErrorDataForChangeUnit( 
            /* [in] */ ISyncChangeUnit *pChangeUnit,
            /* [out] */ HRESULT *phrError,
            /* [out] */ IRecoverableErrorData **ppErrorData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRecoverableErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRecoverableError * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRecoverableError * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRecoverableError * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStage )( 
            IRecoverableError * This,
            /* [out] */ SYNC_PROGRESS_STAGE *pStage);
        
        HRESULT ( STDMETHODCALLTYPE *GetProvider )( 
            IRecoverableError * This,
            /* [out] */ SYNC_PROVIDER_ROLE *pProviderRole);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeWithRecoverableError )( 
            IRecoverableError * This,
            /* [out] */ ISyncChange **ppChangeWithRecoverableError);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecoverableErrorDataForChange )( 
            IRecoverableError * This,
            /* [out] */ HRESULT *phrError,
            /* [out] */ IRecoverableErrorData **ppErrorData);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecoverableErrorDataForChangeUnit )( 
            IRecoverableError * This,
            /* [in] */ ISyncChangeUnit *pChangeUnit,
            /* [out] */ HRESULT *phrError,
            /* [out] */ IRecoverableErrorData **ppErrorData);
        
        END_INTERFACE
    } IRecoverableErrorVtbl;

    interface IRecoverableError
    {
        CONST_VTBL struct IRecoverableErrorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRecoverableError_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRecoverableError_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRecoverableError_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRecoverableError_GetStage(This,pStage)	\
    ( (This)->lpVtbl -> GetStage(This,pStage) ) 

#define IRecoverableError_GetProvider(This,pProviderRole)	\
    ( (This)->lpVtbl -> GetProvider(This,pProviderRole) ) 

#define IRecoverableError_GetChangeWithRecoverableError(This,ppChangeWithRecoverableError)	\
    ( (This)->lpVtbl -> GetChangeWithRecoverableError(This,ppChangeWithRecoverableError) ) 

#define IRecoverableError_GetRecoverableErrorDataForChange(This,phrError,ppErrorData)	\
    ( (This)->lpVtbl -> GetRecoverableErrorDataForChange(This,phrError,ppErrorData) ) 

#define IRecoverableError_GetRecoverableErrorDataForChangeUnit(This,pChangeUnit,phrError,ppErrorData)	\
    ( (This)->lpVtbl -> GetRecoverableErrorDataForChangeUnit(This,pChangeUnit,phrError,ppErrorData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRecoverableError_INTERFACE_DEFINED__ */


#ifndef __IChangeConflict_INTERFACE_DEFINED__
#define __IChangeConflict_INTERFACE_DEFINED__

/* interface IChangeConflict */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IChangeConflict;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("014ebf97-9f20-4f7a-bdd4-25979c77c002")
    IChangeConflict : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDestinationProviderConflictingChange( 
            /* [out] */ ISyncChange **ppConflictingChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceProviderConflictingChange( 
            /* [out] */ ISyncChange **ppConflictingChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDestinationProviderConflictingData( 
            /* [out] */ IUnknown **ppConflictingData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceProviderConflictingData( 
            /* [out] */ IUnknown **ppConflictingData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResolveActionForChange( 
            /* [out] */ SYNC_RESOLVE_ACTION *pResolveAction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResolveActionForChange( 
            /* [in] */ SYNC_RESOLVE_ACTION resolveAction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResolveActionForChangeUnit( 
            /* [in] */ ISyncChangeUnit *pChangeUnit,
            /* [out] */ SYNC_RESOLVE_ACTION *pResolveAction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResolveActionForChangeUnit( 
            /* [in] */ ISyncChangeUnit *pChangeUnit,
            /* [in] */ SYNC_RESOLVE_ACTION resolveAction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IChangeConflictVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IChangeConflict * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IChangeConflict * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IChangeConflict * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationProviderConflictingChange )( 
            IChangeConflict * This,
            /* [out] */ ISyncChange **ppConflictingChange);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceProviderConflictingChange )( 
            IChangeConflict * This,
            /* [out] */ ISyncChange **ppConflictingChange);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationProviderConflictingData )( 
            IChangeConflict * This,
            /* [out] */ IUnknown **ppConflictingData);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceProviderConflictingData )( 
            IChangeConflict * This,
            /* [out] */ IUnknown **ppConflictingData);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolveActionForChange )( 
            IChangeConflict * This,
            /* [out] */ SYNC_RESOLVE_ACTION *pResolveAction);
        
        HRESULT ( STDMETHODCALLTYPE *SetResolveActionForChange )( 
            IChangeConflict * This,
            /* [in] */ SYNC_RESOLVE_ACTION resolveAction);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolveActionForChangeUnit )( 
            IChangeConflict * This,
            /* [in] */ ISyncChangeUnit *pChangeUnit,
            /* [out] */ SYNC_RESOLVE_ACTION *pResolveAction);
        
        HRESULT ( STDMETHODCALLTYPE *SetResolveActionForChangeUnit )( 
            IChangeConflict * This,
            /* [in] */ ISyncChangeUnit *pChangeUnit,
            /* [in] */ SYNC_RESOLVE_ACTION resolveAction);
        
        END_INTERFACE
    } IChangeConflictVtbl;

    interface IChangeConflict
    {
        CONST_VTBL struct IChangeConflictVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IChangeConflict_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IChangeConflict_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IChangeConflict_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IChangeConflict_GetDestinationProviderConflictingChange(This,ppConflictingChange)	\
    ( (This)->lpVtbl -> GetDestinationProviderConflictingChange(This,ppConflictingChange) ) 

#define IChangeConflict_GetSourceProviderConflictingChange(This,ppConflictingChange)	\
    ( (This)->lpVtbl -> GetSourceProviderConflictingChange(This,ppConflictingChange) ) 

#define IChangeConflict_GetDestinationProviderConflictingData(This,ppConflictingData)	\
    ( (This)->lpVtbl -> GetDestinationProviderConflictingData(This,ppConflictingData) ) 

#define IChangeConflict_GetSourceProviderConflictingData(This,ppConflictingData)	\
    ( (This)->lpVtbl -> GetSourceProviderConflictingData(This,ppConflictingData) ) 

#define IChangeConflict_GetResolveActionForChange(This,pResolveAction)	\
    ( (This)->lpVtbl -> GetResolveActionForChange(This,pResolveAction) ) 

#define IChangeConflict_SetResolveActionForChange(This,resolveAction)	\
    ( (This)->lpVtbl -> SetResolveActionForChange(This,resolveAction) ) 

#define IChangeConflict_GetResolveActionForChangeUnit(This,pChangeUnit,pResolveAction)	\
    ( (This)->lpVtbl -> GetResolveActionForChangeUnit(This,pChangeUnit,pResolveAction) ) 

#define IChangeConflict_SetResolveActionForChangeUnit(This,pChangeUnit,resolveAction)	\
    ( (This)->lpVtbl -> SetResolveActionForChangeUnit(This,pChangeUnit,resolveAction) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IChangeConflict_INTERFACE_DEFINED__ */


#ifndef __ISyncCallback_INTERFACE_DEFINED__
#define __ISyncCallback_INTERFACE_DEFINED__

/* interface ISyncCallback */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0599797f-5ed9-485c-ae36-0c5d1bf2e7a5")
    ISyncCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ SYNC_PROVIDER_ROLE provider,
            /* [in] */ SYNC_PROGRESS_STAGE syncStage,
            /* [in] */ DWORD dwCompletedWork,
            /* [in] */ DWORD dwTotalWork) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnChange( 
            /* [in] */ ISyncChange *pSyncChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnConflict( 
            /* [in] */ IChangeConflict *pConflict) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFullEnumerationNeeded( 
            /* [out] */ SYNC_FULL_ENUMERATION_ACTION *pFullEnumerationAction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnRecoverableError( 
            /* [in] */ IRecoverableError *pRecoverableError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncCallback * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            ISyncCallback * This,
            /* [in] */ SYNC_PROVIDER_ROLE provider,
            /* [in] */ SYNC_PROGRESS_STAGE syncStage,
            /* [in] */ DWORD dwCompletedWork,
            /* [in] */ DWORD dwTotalWork);
        
        HRESULT ( STDMETHODCALLTYPE *OnChange )( 
            ISyncCallback * This,
            /* [in] */ ISyncChange *pSyncChange);
        
        HRESULT ( STDMETHODCALLTYPE *OnConflict )( 
            ISyncCallback * This,
            /* [in] */ IChangeConflict *pConflict);
        
        HRESULT ( STDMETHODCALLTYPE *OnFullEnumerationNeeded )( 
            ISyncCallback * This,
            /* [out] */ SYNC_FULL_ENUMERATION_ACTION *pFullEnumerationAction);
        
        HRESULT ( STDMETHODCALLTYPE *OnRecoverableError )( 
            ISyncCallback * This,
            /* [in] */ IRecoverableError *pRecoverableError);
        
        END_INTERFACE
    } ISyncCallbackVtbl;

    interface ISyncCallback
    {
        CONST_VTBL struct ISyncCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncCallback_OnProgress(This,provider,syncStage,dwCompletedWork,dwTotalWork)	\
    ( (This)->lpVtbl -> OnProgress(This,provider,syncStage,dwCompletedWork,dwTotalWork) ) 

#define ISyncCallback_OnChange(This,pSyncChange)	\
    ( (This)->lpVtbl -> OnChange(This,pSyncChange) ) 

#define ISyncCallback_OnConflict(This,pConflict)	\
    ( (This)->lpVtbl -> OnConflict(This,pConflict) ) 

#define ISyncCallback_OnFullEnumerationNeeded(This,pFullEnumerationAction)	\
    ( (This)->lpVtbl -> OnFullEnumerationNeeded(This,pFullEnumerationAction) ) 

#define ISyncCallback_OnRecoverableError(This,pRecoverableError)	\
    ( (This)->lpVtbl -> OnRecoverableError(This,pRecoverableError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncCallback_INTERFACE_DEFINED__ */


#ifndef __ISyncCallback2_INTERFACE_DEFINED__
#define __ISyncCallback2_INTERFACE_DEFINED__

/* interface ISyncCallback2 */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncCallback2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47ce84af-7442-4ead-8630-12015e030ad7")
    ISyncCallback2 : public ISyncCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnChangeApplied( 
            /* [in] */ DWORD dwChangesApplied,
            /* [in] */ DWORD dwChangesFailed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnChangeFailed( 
            /* [in] */ DWORD dwChangesApplied,
            /* [in] */ DWORD dwChangesFailed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncCallback2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncCallback2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncCallback2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            ISyncCallback2 * This,
            /* [in] */ SYNC_PROVIDER_ROLE provider,
            /* [in] */ SYNC_PROGRESS_STAGE syncStage,
            /* [in] */ DWORD dwCompletedWork,
            /* [in] */ DWORD dwTotalWork);
        
        HRESULT ( STDMETHODCALLTYPE *OnChange )( 
            ISyncCallback2 * This,
            /* [in] */ ISyncChange *pSyncChange);
        
        HRESULT ( STDMETHODCALLTYPE *OnConflict )( 
            ISyncCallback2 * This,
            /* [in] */ IChangeConflict *pConflict);
        
        HRESULT ( STDMETHODCALLTYPE *OnFullEnumerationNeeded )( 
            ISyncCallback2 * This,
            /* [out] */ SYNC_FULL_ENUMERATION_ACTION *pFullEnumerationAction);
        
        HRESULT ( STDMETHODCALLTYPE *OnRecoverableError )( 
            ISyncCallback2 * This,
            /* [in] */ IRecoverableError *pRecoverableError);
        
        HRESULT ( STDMETHODCALLTYPE *OnChangeApplied )( 
            ISyncCallback2 * This,
            /* [in] */ DWORD dwChangesApplied,
            /* [in] */ DWORD dwChangesFailed);
        
        HRESULT ( STDMETHODCALLTYPE *OnChangeFailed )( 
            ISyncCallback2 * This,
            /* [in] */ DWORD dwChangesApplied,
            /* [in] */ DWORD dwChangesFailed);
        
        END_INTERFACE
    } ISyncCallback2Vtbl;

    interface ISyncCallback2
    {
        CONST_VTBL struct ISyncCallback2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncCallback2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncCallback2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncCallback2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncCallback2_OnProgress(This,provider,syncStage,dwCompletedWork,dwTotalWork)	\
    ( (This)->lpVtbl -> OnProgress(This,provider,syncStage,dwCompletedWork,dwTotalWork) ) 

#define ISyncCallback2_OnChange(This,pSyncChange)	\
    ( (This)->lpVtbl -> OnChange(This,pSyncChange) ) 

#define ISyncCallback2_OnConflict(This,pConflict)	\
    ( (This)->lpVtbl -> OnConflict(This,pConflict) ) 

#define ISyncCallback2_OnFullEnumerationNeeded(This,pFullEnumerationAction)	\
    ( (This)->lpVtbl -> OnFullEnumerationNeeded(This,pFullEnumerationAction) ) 

#define ISyncCallback2_OnRecoverableError(This,pRecoverableError)	\
    ( (This)->lpVtbl -> OnRecoverableError(This,pRecoverableError) ) 


#define ISyncCallback2_OnChangeApplied(This,dwChangesApplied,dwChangesFailed)	\
    ( (This)->lpVtbl -> OnChangeApplied(This,dwChangesApplied,dwChangesFailed) ) 

#define ISyncCallback2_OnChangeFailed(This,dwChangesApplied,dwChangesFailed)	\
    ( (This)->lpVtbl -> OnChangeFailed(This,dwChangesApplied,dwChangesFailed) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncCallback2_INTERFACE_DEFINED__ */


#ifndef __ISyncProvider_INTERFACE_DEFINED__
#define __ISyncProvider_INTERFACE_DEFINED__

/* interface ISyncProvider */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8f657056-2bce-4a17-8c68-c7bb7898b56f")
    ISyncProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIdParameters( 
            /* [out] */ ID_PARAMETERS *pIdParameters) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncProvider * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdParameters )( 
            ISyncProvider * This,
            /* [out] */ ID_PARAMETERS *pIdParameters);
        
        END_INTERFACE
    } ISyncProviderVtbl;

    interface ISyncProvider
    {
        CONST_VTBL struct ISyncProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncProvider_GetIdParameters(This,pIdParameters)	\
    ( (This)->lpVtbl -> GetIdParameters(This,pIdParameters) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncProvider_INTERFACE_DEFINED__ */


#ifndef __ISyncSessionState_INTERFACE_DEFINED__
#define __ISyncSessionState_INTERFACE_DEFINED__

/* interface ISyncSessionState */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncSessionState;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b8a940fe-9f01-483b-9434-c37d361225d9")
    ISyncSessionState : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsCanceled( 
            /* [out] */ BOOL *pfIsCanceled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfoForChangeApplication( 
            /* [size_is][unique][out][in] */ BYTE *pbChangeApplierInfo,
            /* [out][in] */ DWORD *pcbChangeApplierInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadInfoFromChangeApplication( 
            /* [size_is][in] */ const BYTE *pbChangeApplierInfo,
            /* [in] */ DWORD cbChangeApplierInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForgottenKnowledgeRecoveryRangeStart( 
            /* [size_is][unique][out][in] */ BYTE *pbRangeStart,
            /* [out][in] */ DWORD *pcbRangeStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForgottenKnowledgeRecoveryRangeEnd( 
            /* [size_is][unique][out][in] */ BYTE *pbRangeEnd,
            /* [out][in] */ DWORD *pcbRangeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetForgottenKnowledgeRecoveryRange( 
            /* [in] */ const SYNC_RANGE *pRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ SYNC_PROVIDER_ROLE provider,
            /* [in] */ SYNC_PROGRESS_STAGE syncStage,
            /* [in] */ DWORD dwCompletedWork,
            /* [in] */ DWORD dwTotalWork) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncSessionStateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncSessionState * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncSessionState * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncSessionState * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsCanceled )( 
            ISyncSessionState * This,
            /* [out] */ BOOL *pfIsCanceled);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfoForChangeApplication )( 
            ISyncSessionState * This,
            /* [size_is][unique][out][in] */ BYTE *pbChangeApplierInfo,
            /* [out][in] */ DWORD *pcbChangeApplierInfo);
        
        HRESULT ( STDMETHODCALLTYPE *LoadInfoFromChangeApplication )( 
            ISyncSessionState * This,
            /* [size_is][in] */ const BYTE *pbChangeApplierInfo,
            /* [in] */ DWORD cbChangeApplierInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetForgottenKnowledgeRecoveryRangeStart )( 
            ISyncSessionState * This,
            /* [size_is][unique][out][in] */ BYTE *pbRangeStart,
            /* [out][in] */ DWORD *pcbRangeStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetForgottenKnowledgeRecoveryRangeEnd )( 
            ISyncSessionState * This,
            /* [size_is][unique][out][in] */ BYTE *pbRangeEnd,
            /* [out][in] */ DWORD *pcbRangeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetForgottenKnowledgeRecoveryRange )( 
            ISyncSessionState * This,
            /* [in] */ const SYNC_RANGE *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            ISyncSessionState * This,
            /* [in] */ SYNC_PROVIDER_ROLE provider,
            /* [in] */ SYNC_PROGRESS_STAGE syncStage,
            /* [in] */ DWORD dwCompletedWork,
            /* [in] */ DWORD dwTotalWork);
        
        END_INTERFACE
    } ISyncSessionStateVtbl;

    interface ISyncSessionState
    {
        CONST_VTBL struct ISyncSessionStateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncSessionState_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncSessionState_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncSessionState_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncSessionState_IsCanceled(This,pfIsCanceled)	\
    ( (This)->lpVtbl -> IsCanceled(This,pfIsCanceled) ) 

#define ISyncSessionState_GetInfoForChangeApplication(This,pbChangeApplierInfo,pcbChangeApplierInfo)	\
    ( (This)->lpVtbl -> GetInfoForChangeApplication(This,pbChangeApplierInfo,pcbChangeApplierInfo) ) 

#define ISyncSessionState_LoadInfoFromChangeApplication(This,pbChangeApplierInfo,cbChangeApplierInfo)	\
    ( (This)->lpVtbl -> LoadInfoFromChangeApplication(This,pbChangeApplierInfo,cbChangeApplierInfo) ) 

#define ISyncSessionState_GetForgottenKnowledgeRecoveryRangeStart(This,pbRangeStart,pcbRangeStart)	\
    ( (This)->lpVtbl -> GetForgottenKnowledgeRecoveryRangeStart(This,pbRangeStart,pcbRangeStart) ) 

#define ISyncSessionState_GetForgottenKnowledgeRecoveryRangeEnd(This,pbRangeEnd,pcbRangeEnd)	\
    ( (This)->lpVtbl -> GetForgottenKnowledgeRecoveryRangeEnd(This,pbRangeEnd,pcbRangeEnd) ) 

#define ISyncSessionState_SetForgottenKnowledgeRecoveryRange(This,pRange)	\
    ( (This)->lpVtbl -> SetForgottenKnowledgeRecoveryRange(This,pRange) ) 

#define ISyncSessionState_OnProgress(This,provider,syncStage,dwCompletedWork,dwTotalWork)	\
    ( (This)->lpVtbl -> OnProgress(This,provider,syncStage,dwCompletedWork,dwTotalWork) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncSessionState_INTERFACE_DEFINED__ */


#ifndef __ISyncSessionExtendedErrorInfo_INTERFACE_DEFINED__
#define __ISyncSessionExtendedErrorInfo_INTERFACE_DEFINED__

/* interface ISyncSessionExtendedErrorInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncSessionExtendedErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("326c6810-790a-409b-b741-6999388761eb")
    ISyncSessionExtendedErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSyncProviderWithError( 
            /* [retval][out] */ ISyncProvider **ppProviderWithError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncSessionExtendedErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncSessionExtendedErrorInfo * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncSessionExtendedErrorInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncSessionExtendedErrorInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncProviderWithError )( 
            ISyncSessionExtendedErrorInfo * This,
            /* [retval][out] */ ISyncProvider **ppProviderWithError);
        
        END_INTERFACE
    } ISyncSessionExtendedErrorInfoVtbl;

    interface ISyncSessionExtendedErrorInfo
    {
        CONST_VTBL struct ISyncSessionExtendedErrorInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncSessionExtendedErrorInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncSessionExtendedErrorInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncSessionExtendedErrorInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncSessionExtendedErrorInfo_GetSyncProviderWithError(This,ppProviderWithError)	\
    ( (This)->lpVtbl -> GetSyncProviderWithError(This,ppProviderWithError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncSessionExtendedErrorInfo_INTERFACE_DEFINED__ */


#ifndef __ISyncSessionState2_INTERFACE_DEFINED__
#define __ISyncSessionState2_INTERFACE_DEFINED__

/* interface ISyncSessionState2 */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncSessionState2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e37cfa3-9e38-4c61-9ca3-ffe810b45ca2")
    ISyncSessionState2 : public ISyncSessionState
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProviderWithError( 
            /* [in] */ BOOL fSelf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSessionErrorStatus( 
            /* [retval][out] */ HRESULT *phrSessionError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncSessionState2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncSessionState2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncSessionState2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncSessionState2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsCanceled )( 
            ISyncSessionState2 * This,
            /* [out] */ BOOL *pfIsCanceled);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfoForChangeApplication )( 
            ISyncSessionState2 * This,
            /* [size_is][unique][out][in] */ BYTE *pbChangeApplierInfo,
            /* [out][in] */ DWORD *pcbChangeApplierInfo);
        
        HRESULT ( STDMETHODCALLTYPE *LoadInfoFromChangeApplication )( 
            ISyncSessionState2 * This,
            /* [size_is][in] */ const BYTE *pbChangeApplierInfo,
            /* [in] */ DWORD cbChangeApplierInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetForgottenKnowledgeRecoveryRangeStart )( 
            ISyncSessionState2 * This,
            /* [size_is][unique][out][in] */ BYTE *pbRangeStart,
            /* [out][in] */ DWORD *pcbRangeStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetForgottenKnowledgeRecoveryRangeEnd )( 
            ISyncSessionState2 * This,
            /* [size_is][unique][out][in] */ BYTE *pbRangeEnd,
            /* [out][in] */ DWORD *pcbRangeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetForgottenKnowledgeRecoveryRange )( 
            ISyncSessionState2 * This,
            /* [in] */ const SYNC_RANGE *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            ISyncSessionState2 * This,
            /* [in] */ SYNC_PROVIDER_ROLE provider,
            /* [in] */ SYNC_PROGRESS_STAGE syncStage,
            /* [in] */ DWORD dwCompletedWork,
            /* [in] */ DWORD dwTotalWork);
        
        HRESULT ( STDMETHODCALLTYPE *SetProviderWithError )( 
            ISyncSessionState2 * This,
            /* [in] */ BOOL fSelf);
        
        HRESULT ( STDMETHODCALLTYPE *GetSessionErrorStatus )( 
            ISyncSessionState2 * This,
            /* [retval][out] */ HRESULT *phrSessionError);
        
        END_INTERFACE
    } ISyncSessionState2Vtbl;

    interface ISyncSessionState2
    {
        CONST_VTBL struct ISyncSessionState2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncSessionState2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncSessionState2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncSessionState2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncSessionState2_IsCanceled(This,pfIsCanceled)	\
    ( (This)->lpVtbl -> IsCanceled(This,pfIsCanceled) ) 

#define ISyncSessionState2_GetInfoForChangeApplication(This,pbChangeApplierInfo,pcbChangeApplierInfo)	\
    ( (This)->lpVtbl -> GetInfoForChangeApplication(This,pbChangeApplierInfo,pcbChangeApplierInfo) ) 

#define ISyncSessionState2_LoadInfoFromChangeApplication(This,pbChangeApplierInfo,cbChangeApplierInfo)	\
    ( (This)->lpVtbl -> LoadInfoFromChangeApplication(This,pbChangeApplierInfo,cbChangeApplierInfo) ) 

#define ISyncSessionState2_GetForgottenKnowledgeRecoveryRangeStart(This,pbRangeStart,pcbRangeStart)	\
    ( (This)->lpVtbl -> GetForgottenKnowledgeRecoveryRangeStart(This,pbRangeStart,pcbRangeStart) ) 

#define ISyncSessionState2_GetForgottenKnowledgeRecoveryRangeEnd(This,pbRangeEnd,pcbRangeEnd)	\
    ( (This)->lpVtbl -> GetForgottenKnowledgeRecoveryRangeEnd(This,pbRangeEnd,pcbRangeEnd) ) 

#define ISyncSessionState2_SetForgottenKnowledgeRecoveryRange(This,pRange)	\
    ( (This)->lpVtbl -> SetForgottenKnowledgeRecoveryRange(This,pRange) ) 

#define ISyncSessionState2_OnProgress(This,provider,syncStage,dwCompletedWork,dwTotalWork)	\
    ( (This)->lpVtbl -> OnProgress(This,provider,syncStage,dwCompletedWork,dwTotalWork) ) 


#define ISyncSessionState2_SetProviderWithError(This,fSelf)	\
    ( (This)->lpVtbl -> SetProviderWithError(This,fSelf) ) 

#define ISyncSessionState2_GetSessionErrorStatus(This,phrSessionError)	\
    ( (This)->lpVtbl -> GetSessionErrorStatus(This,phrSessionError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncSessionState2_INTERFACE_DEFINED__ */


#ifndef __ISyncFilterInfo_INTERFACE_DEFINED__
#define __ISyncFilterInfo_INTERFACE_DEFINED__

/* interface ISyncFilterInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncFilterInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("794eaaf8-3f2e-47e6-9728-17e6fcf94cb7")
    ISyncFilterInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [size_is][unique][out][in] */ BYTE *pbBuffer,
            /* [out][in] */ DWORD *pcbBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncFilterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncFilterInfo * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncFilterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncFilterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ISyncFilterInfo * This,
            /* [size_is][unique][out][in] */ BYTE *pbBuffer,
            /* [out][in] */ DWORD *pcbBuffer);
        
        END_INTERFACE
    } ISyncFilterInfoVtbl;

    interface ISyncFilterInfo
    {
        CONST_VTBL struct ISyncFilterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncFilterInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncFilterInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncFilterInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncFilterInfo_Serialize(This,pbBuffer,pcbBuffer)	\
    ( (This)->lpVtbl -> Serialize(This,pbBuffer,pcbBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncFilterInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_winsync_0000_0029 */
/* [local] */ 

#define SYNC_FILTER_INFO_FLAG_ITEM_LIST          0x00000001
#define SYNC_FILTER_INFO_FLAG_CHANGE_UNIT_LIST   0x00000002


extern RPC_IF_HANDLE __MIDL_itf_winsync_0000_0029_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_winsync_0000_0029_v0_0_s_ifspec;

#ifndef __ISyncFilterInfo2_INTERFACE_DEFINED__
#define __ISyncFilterInfo2_INTERFACE_DEFINED__

/* interface ISyncFilterInfo2 */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncFilterInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19b394ba-e3d0-468c-934d-321968b2ab34")
    ISyncFilterInfo2 : public ISyncFilterInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncFilterInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncFilterInfo2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncFilterInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncFilterInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ISyncFilterInfo2 * This,
            /* [size_is][unique][out][in] */ BYTE *pbBuffer,
            /* [out][in] */ DWORD *pcbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            ISyncFilterInfo2 * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } ISyncFilterInfo2Vtbl;

    interface ISyncFilterInfo2
    {
        CONST_VTBL struct ISyncFilterInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncFilterInfo2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncFilterInfo2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncFilterInfo2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncFilterInfo2_Serialize(This,pbBuffer,pcbBuffer)	\
    ( (This)->lpVtbl -> Serialize(This,pbBuffer,pcbBuffer) ) 


#define ISyncFilterInfo2_GetFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetFlags(This,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncFilterInfo2_INTERFACE_DEFINED__ */


#ifndef __IChangeUnitListFilterInfo_INTERFACE_DEFINED__
#define __IChangeUnitListFilterInfo_INTERFACE_DEFINED__

/* interface IChangeUnitListFilterInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IChangeUnitListFilterInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f2837671-0bdf-43fa-b502-232375fb50c2")
    IChangeUnitListFilterInfo : public ISyncFilterInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [size_is][in] */ const BYTE *const *ppbChangeUnitIds,
            /* [in] */ DWORD dwChangeUnitCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeUnitIdCount( 
            /* [retval][out] */ DWORD *pdwChangeUnitIdCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeUnitId( 
            /* [in] */ DWORD dwChangeUnitIdIndex,
            /* [size_is][unique][out][in] */ BYTE *pbChangeUnitId,
            /* [out][in] */ DWORD *pcbIdSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IChangeUnitListFilterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IChangeUnitListFilterInfo * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IChangeUnitListFilterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IChangeUnitListFilterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            IChangeUnitListFilterInfo * This,
            /* [size_is][unique][out][in] */ BYTE *pbBuffer,
            /* [out][in] */ DWORD *pcbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IChangeUnitListFilterInfo * This,
            /* [size_is][in] */ const BYTE *const *ppbChangeUnitIds,
            /* [in] */ DWORD dwChangeUnitCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeUnitIdCount )( 
            IChangeUnitListFilterInfo * This,
            /* [retval][out] */ DWORD *pdwChangeUnitIdCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeUnitId )( 
            IChangeUnitListFilterInfo * This,
            /* [in] */ DWORD dwChangeUnitIdIndex,
            /* [size_is][unique][out][in] */ BYTE *pbChangeUnitId,
            /* [out][in] */ DWORD *pcbIdSize);
        
        END_INTERFACE
    } IChangeUnitListFilterInfoVtbl;

    interface IChangeUnitListFilterInfo
    {
        CONST_VTBL struct IChangeUnitListFilterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IChangeUnitListFilterInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IChangeUnitListFilterInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IChangeUnitListFilterInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IChangeUnitListFilterInfo_Serialize(This,pbBuffer,pcbBuffer)	\
    ( (This)->lpVtbl -> Serialize(This,pbBuffer,pcbBuffer) ) 


#define IChangeUnitListFilterInfo_Initialize(This,ppbChangeUnitIds,dwChangeUnitCount)	\
    ( (This)->lpVtbl -> Initialize(This,ppbChangeUnitIds,dwChangeUnitCount) ) 

#define IChangeUnitListFilterInfo_GetChangeUnitIdCount(This,pdwChangeUnitIdCount)	\
    ( (This)->lpVtbl -> GetChangeUnitIdCount(This,pdwChangeUnitIdCount) ) 

#define IChangeUnitListFilterInfo_GetChangeUnitId(This,dwChangeUnitIdIndex,pbChangeUnitId,pcbIdSize)	\
    ( (This)->lpVtbl -> GetChangeUnitId(This,dwChangeUnitIdIndex,pbChangeUnitId,pcbIdSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IChangeUnitListFilterInfo_INTERFACE_DEFINED__ */


#ifndef __IEnumSyncChanges_INTERFACE_DEFINED__
#define __IEnumSyncChanges_INTERFACE_DEFINED__

/* interface IEnumSyncChanges */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IEnumSyncChanges;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5f86be4a-5e78-4e32-ac1c-c24fd223ef85")
    IEnumSyncChanges : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [range][in] */ ULONG cChanges,
            /* [length_is][size_is][out] */ ISyncChange **ppChange,
            /* [unique][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cChanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumSyncChanges **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSyncChangesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSyncChanges * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSyncChanges * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSyncChanges * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSyncChanges * This,
            /* [range][in] */ ULONG cChanges,
            /* [length_is][size_is][out] */ ISyncChange **ppChange,
            /* [unique][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSyncChanges * This,
            /* [in] */ ULONG cChanges);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSyncChanges * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSyncChanges * This,
            /* [out] */ IEnumSyncChanges **ppEnum);
        
        END_INTERFACE
    } IEnumSyncChangesVtbl;

    interface IEnumSyncChanges
    {
        CONST_VTBL struct IEnumSyncChangesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSyncChanges_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSyncChanges_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSyncChanges_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSyncChanges_Next(This,cChanges,ppChange,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cChanges,ppChange,pcFetched) ) 

#define IEnumSyncChanges_Skip(This,cChanges)	\
    ( (This)->lpVtbl -> Skip(This,cChanges) ) 

#define IEnumSyncChanges_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSyncChanges_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumSyncChanges_INTERFACE_DEFINED__ */


#ifndef __ISyncChangeBuilder_INTERFACE_DEFINED__
#define __ISyncChangeBuilder_INTERFACE_DEFINED__

/* interface ISyncChangeBuilder */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncChangeBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56f14771-8677-484f-a170-e386e418a676")
    ISyncChangeBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddChangeUnitMetadata( 
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [in] */ const SYNC_VERSION *pChangeUnitVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncChangeBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncChangeBuilder * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncChangeBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncChangeBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddChangeUnitMetadata )( 
            ISyncChangeBuilder * This,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [in] */ const SYNC_VERSION *pChangeUnitVersion);
        
        END_INTERFACE
    } ISyncChangeBuilderVtbl;

    interface ISyncChangeBuilder
    {
        CONST_VTBL struct ISyncChangeBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncChangeBuilder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncChangeBuilder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncChangeBuilder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncChangeBuilder_AddChangeUnitMetadata(This,pbChangeUnitId,pChangeUnitVersion)	\
    ( (This)->lpVtbl -> AddChangeUnitMetadata(This,pbChangeUnitId,pChangeUnitVersion) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncChangeBuilder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_winsync_0000_0033 */
/* [local] */ 

#define SYNC_CHANGE_FLAG_DELETED                 0x00000001
#define SYNC_CHANGE_FLAG_DOES_NOT_EXIST          0x00000002


extern RPC_IF_HANDLE __MIDL_itf_winsync_0000_0033_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_winsync_0000_0033_v0_0_s_ifspec;

#ifndef __ISyncChangeBatchBase_INTERFACE_DEFINED__
#define __ISyncChangeBatchBase_INTERFACE_DEFINED__

/* interface ISyncChangeBatchBase */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncChangeBatchBase;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52F6E694-6A71-4494-A184-A8311BF5D227")
    ISyncChangeBatchBase : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetChangeEnumerator( 
            /* [out] */ IEnumSyncChanges **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIsLastBatch( 
            /* [out] */ BOOL *pfLastBatch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorkEstimateForBatch( 
            /* [out] */ DWORD *pdwWorkForBatch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemainingWorkEstimateForSession( 
            /* [out] */ DWORD *pdwRemainingWorkForSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginOrderedGroup( 
            /* [in] */ const BYTE *pbLowerBound) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndOrderedGroup( 
            /* [in] */ const BYTE *pbUpperBound,
            /* [in] */ ISyncKnowledge *pMadeWithKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddItemMetadataToGroup( 
            /* [in] */ const BYTE *pbOwnerReplicaId,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const SYNC_VERSION *pChangeVersion,
            /* [in] */ const SYNC_VERSION *pCreationVersion,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwWorkForChange,
            /* [unique][out][in] */ ISyncChangeBuilder **ppChangeBuilder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLearnedKnowledge( 
            /* [out] */ ISyncKnowledge **ppLearnedKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrerequisiteKnowledge( 
            /* [out] */ ISyncKnowledge **ppPrerequisteKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceForgottenKnowledge( 
            /* [out] */ IForgottenKnowledge **ppSourceForgottenKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLastBatch( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorkEstimateForBatch( 
            /* [in] */ DWORD dwWorkForBatch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRemainingWorkEstimateForSession( 
            /* [in] */ DWORD dwRemainingWorkForSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [size_is][unique][out][in] */ BYTE *pbChangeBatch,
            /* [out][in] */ DWORD *pcbChangeBatch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncChangeBatchBaseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncChangeBatchBase * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncChangeBatchBase * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncChangeBatchBase * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeEnumerator )( 
            ISyncChangeBatchBase * This,
            /* [out] */ IEnumSyncChanges **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsLastBatch )( 
            ISyncChangeBatchBase * This,
            /* [out] */ BOOL *pfLastBatch);
        
        HRESULT ( STDMETHODCALLTYPE *GetWorkEstimateForBatch )( 
            ISyncChangeBatchBase * This,
            /* [out] */ DWORD *pdwWorkForBatch);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemainingWorkEstimateForSession )( 
            ISyncChangeBatchBase * This,
            /* [out] */ DWORD *pdwRemainingWorkForSession);
        
        HRESULT ( STDMETHODCALLTYPE *BeginOrderedGroup )( 
            ISyncChangeBatchBase * This,
            /* [in] */ const BYTE *pbLowerBound);
        
        HRESULT ( STDMETHODCALLTYPE *EndOrderedGroup )( 
            ISyncChangeBatchBase * This,
            /* [in] */ const BYTE *pbUpperBound,
            /* [in] */ ISyncKnowledge *pMadeWithKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *AddItemMetadataToGroup )( 
            ISyncChangeBatchBase * This,
            /* [in] */ const BYTE *pbOwnerReplicaId,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const SYNC_VERSION *pChangeVersion,
            /* [in] */ const SYNC_VERSION *pCreationVersion,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwWorkForChange,
            /* [unique][out][in] */ ISyncChangeBuilder **ppChangeBuilder);
        
        HRESULT ( STDMETHODCALLTYPE *GetLearnedKnowledge )( 
            ISyncChangeBatchBase * This,
            /* [out] */ ISyncKnowledge **ppLearnedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrerequisiteKnowledge )( 
            ISyncChangeBatchBase * This,
            /* [out] */ ISyncKnowledge **ppPrerequisteKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceForgottenKnowledge )( 
            ISyncChangeBatchBase * This,
            /* [out] */ IForgottenKnowledge **ppSourceForgottenKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *SetLastBatch )( 
            ISyncChangeBatchBase * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetWorkEstimateForBatch )( 
            ISyncChangeBatchBase * This,
            /* [in] */ DWORD dwWorkForBatch);
        
        HRESULT ( STDMETHODCALLTYPE *SetRemainingWorkEstimateForSession )( 
            ISyncChangeBatchBase * This,
            /* [in] */ DWORD dwRemainingWorkForSession);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ISyncChangeBatchBase * This,
            /* [size_is][unique][out][in] */ BYTE *pbChangeBatch,
            /* [out][in] */ DWORD *pcbChangeBatch);
        
        END_INTERFACE
    } ISyncChangeBatchBaseVtbl;

    interface ISyncChangeBatchBase
    {
        CONST_VTBL struct ISyncChangeBatchBaseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncChangeBatchBase_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncChangeBatchBase_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncChangeBatchBase_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncChangeBatchBase_GetChangeEnumerator(This,ppEnum)	\
    ( (This)->lpVtbl -> GetChangeEnumerator(This,ppEnum) ) 

#define ISyncChangeBatchBase_GetIsLastBatch(This,pfLastBatch)	\
    ( (This)->lpVtbl -> GetIsLastBatch(This,pfLastBatch) ) 

#define ISyncChangeBatchBase_GetWorkEstimateForBatch(This,pdwWorkForBatch)	\
    ( (This)->lpVtbl -> GetWorkEstimateForBatch(This,pdwWorkForBatch) ) 

#define ISyncChangeBatchBase_GetRemainingWorkEstimateForSession(This,pdwRemainingWorkForSession)	\
    ( (This)->lpVtbl -> GetRemainingWorkEstimateForSession(This,pdwRemainingWorkForSession) ) 

#define ISyncChangeBatchBase_BeginOrderedGroup(This,pbLowerBound)	\
    ( (This)->lpVtbl -> BeginOrderedGroup(This,pbLowerBound) ) 

#define ISyncChangeBatchBase_EndOrderedGroup(This,pbUpperBound,pMadeWithKnowledge)	\
    ( (This)->lpVtbl -> EndOrderedGroup(This,pbUpperBound,pMadeWithKnowledge) ) 

#define ISyncChangeBatchBase_AddItemMetadataToGroup(This,pbOwnerReplicaId,pbItemId,pChangeVersion,pCreationVersion,dwFlags,dwWorkForChange,ppChangeBuilder)	\
    ( (This)->lpVtbl -> AddItemMetadataToGroup(This,pbOwnerReplicaId,pbItemId,pChangeVersion,pCreationVersion,dwFlags,dwWorkForChange,ppChangeBuilder) ) 

#define ISyncChangeBatchBase_GetLearnedKnowledge(This,ppLearnedKnowledge)	\
    ( (This)->lpVtbl -> GetLearnedKnowledge(This,ppLearnedKnowledge) ) 

#define ISyncChangeBatchBase_GetPrerequisiteKnowledge(This,ppPrerequisteKnowledge)	\
    ( (This)->lpVtbl -> GetPrerequisiteKnowledge(This,ppPrerequisteKnowledge) ) 

#define ISyncChangeBatchBase_GetSourceForgottenKnowledge(This,ppSourceForgottenKnowledge)	\
    ( (This)->lpVtbl -> GetSourceForgottenKnowledge(This,ppSourceForgottenKnowledge) ) 

#define ISyncChangeBatchBase_SetLastBatch(This)	\
    ( (This)->lpVtbl -> SetLastBatch(This) ) 

#define ISyncChangeBatchBase_SetWorkEstimateForBatch(This,dwWorkForBatch)	\
    ( (This)->lpVtbl -> SetWorkEstimateForBatch(This,dwWorkForBatch) ) 

#define ISyncChangeBatchBase_SetRemainingWorkEstimateForSession(This,dwRemainingWorkForSession)	\
    ( (This)->lpVtbl -> SetRemainingWorkEstimateForSession(This,dwRemainingWorkForSession) ) 

#define ISyncChangeBatchBase_Serialize(This,pbChangeBatch,pcbChangeBatch)	\
    ( (This)->lpVtbl -> Serialize(This,pbChangeBatch,pcbChangeBatch) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncChangeBatchBase_INTERFACE_DEFINED__ */


#ifndef __ISyncChangeBatch_INTERFACE_DEFINED__
#define __ISyncChangeBatch_INTERFACE_DEFINED__

/* interface ISyncChangeBatch */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncChangeBatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70c64dee-380f-4c2e-8f70-31c55bd5f9b3")
    ISyncChangeBatch : public ISyncChangeBatchBase
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginUnorderedGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndUnorderedGroup( 
            /* [in] */ ISyncKnowledge *pMadeWithKnowledge,
            /* [in] */ BOOL fAllChangesForKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddLoggedConflict( 
            /* [in] */ const BYTE *pbOwnerReplicaId,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const SYNC_VERSION *pChangeVersion,
            /* [in] */ const SYNC_VERSION *pCreationVersion,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwWorkForChange,
            /* [in] */ ISyncKnowledge *pConflictKnowledge,
            /* [out] */ ISyncChangeBuilder **ppChangeBuilder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncChangeBatchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncChangeBatch * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncChangeBatch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncChangeBatch * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeEnumerator )( 
            ISyncChangeBatch * This,
            /* [out] */ IEnumSyncChanges **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsLastBatch )( 
            ISyncChangeBatch * This,
            /* [out] */ BOOL *pfLastBatch);
        
        HRESULT ( STDMETHODCALLTYPE *GetWorkEstimateForBatch )( 
            ISyncChangeBatch * This,
            /* [out] */ DWORD *pdwWorkForBatch);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemainingWorkEstimateForSession )( 
            ISyncChangeBatch * This,
            /* [out] */ DWORD *pdwRemainingWorkForSession);
        
        HRESULT ( STDMETHODCALLTYPE *BeginOrderedGroup )( 
            ISyncChangeBatch * This,
            /* [in] */ const BYTE *pbLowerBound);
        
        HRESULT ( STDMETHODCALLTYPE *EndOrderedGroup )( 
            ISyncChangeBatch * This,
            /* [in] */ const BYTE *pbUpperBound,
            /* [in] */ ISyncKnowledge *pMadeWithKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *AddItemMetadataToGroup )( 
            ISyncChangeBatch * This,
            /* [in] */ const BYTE *pbOwnerReplicaId,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const SYNC_VERSION *pChangeVersion,
            /* [in] */ const SYNC_VERSION *pCreationVersion,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwWorkForChange,
            /* [unique][out][in] */ ISyncChangeBuilder **ppChangeBuilder);
        
        HRESULT ( STDMETHODCALLTYPE *GetLearnedKnowledge )( 
            ISyncChangeBatch * This,
            /* [out] */ ISyncKnowledge **ppLearnedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrerequisiteKnowledge )( 
            ISyncChangeBatch * This,
            /* [out] */ ISyncKnowledge **ppPrerequisteKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceForgottenKnowledge )( 
            ISyncChangeBatch * This,
            /* [out] */ IForgottenKnowledge **ppSourceForgottenKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *SetLastBatch )( 
            ISyncChangeBatch * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetWorkEstimateForBatch )( 
            ISyncChangeBatch * This,
            /* [in] */ DWORD dwWorkForBatch);
        
        HRESULT ( STDMETHODCALLTYPE *SetRemainingWorkEstimateForSession )( 
            ISyncChangeBatch * This,
            /* [in] */ DWORD dwRemainingWorkForSession);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ISyncChangeBatch * This,
            /* [size_is][unique][out][in] */ BYTE *pbChangeBatch,
            /* [out][in] */ DWORD *pcbChangeBatch);
        
        HRESULT ( STDMETHODCALLTYPE *BeginUnorderedGroup )( 
            ISyncChangeBatch * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndUnorderedGroup )( 
            ISyncChangeBatch * This,
            /* [in] */ ISyncKnowledge *pMadeWithKnowledge,
            /* [in] */ BOOL fAllChangesForKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *AddLoggedConflict )( 
            ISyncChangeBatch * This,
            /* [in] */ const BYTE *pbOwnerReplicaId,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const SYNC_VERSION *pChangeVersion,
            /* [in] */ const SYNC_VERSION *pCreationVersion,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwWorkForChange,
            /* [in] */ ISyncKnowledge *pConflictKnowledge,
            /* [out] */ ISyncChangeBuilder **ppChangeBuilder);
        
        END_INTERFACE
    } ISyncChangeBatchVtbl;

    interface ISyncChangeBatch
    {
        CONST_VTBL struct ISyncChangeBatchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncChangeBatch_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncChangeBatch_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncChangeBatch_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncChangeBatch_GetChangeEnumerator(This,ppEnum)	\
    ( (This)->lpVtbl -> GetChangeEnumerator(This,ppEnum) ) 

#define ISyncChangeBatch_GetIsLastBatch(This,pfLastBatch)	\
    ( (This)->lpVtbl -> GetIsLastBatch(This,pfLastBatch) ) 

#define ISyncChangeBatch_GetWorkEstimateForBatch(This,pdwWorkForBatch)	\
    ( (This)->lpVtbl -> GetWorkEstimateForBatch(This,pdwWorkForBatch) ) 

#define ISyncChangeBatch_GetRemainingWorkEstimateForSession(This,pdwRemainingWorkForSession)	\
    ( (This)->lpVtbl -> GetRemainingWorkEstimateForSession(This,pdwRemainingWorkForSession) ) 

#define ISyncChangeBatch_BeginOrderedGroup(This,pbLowerBound)	\
    ( (This)->lpVtbl -> BeginOrderedGroup(This,pbLowerBound) ) 

#define ISyncChangeBatch_EndOrderedGroup(This,pbUpperBound,pMadeWithKnowledge)	\
    ( (This)->lpVtbl -> EndOrderedGroup(This,pbUpperBound,pMadeWithKnowledge) ) 

#define ISyncChangeBatch_AddItemMetadataToGroup(This,pbOwnerReplicaId,pbItemId,pChangeVersion,pCreationVersion,dwFlags,dwWorkForChange,ppChangeBuilder)	\
    ( (This)->lpVtbl -> AddItemMetadataToGroup(This,pbOwnerReplicaId,pbItemId,pChangeVersion,pCreationVersion,dwFlags,dwWorkForChange,ppChangeBuilder) ) 

#define ISyncChangeBatch_GetLearnedKnowledge(This,ppLearnedKnowledge)	\
    ( (This)->lpVtbl -> GetLearnedKnowledge(This,ppLearnedKnowledge) ) 

#define ISyncChangeBatch_GetPrerequisiteKnowledge(This,ppPrerequisteKnowledge)	\
    ( (This)->lpVtbl -> GetPrerequisiteKnowledge(This,ppPrerequisteKnowledge) ) 

#define ISyncChangeBatch_GetSourceForgottenKnowledge(This,ppSourceForgottenKnowledge)	\
    ( (This)->lpVtbl -> GetSourceForgottenKnowledge(This,ppSourceForgottenKnowledge) ) 

#define ISyncChangeBatch_SetLastBatch(This)	\
    ( (This)->lpVtbl -> SetLastBatch(This) ) 

#define ISyncChangeBatch_SetWorkEstimateForBatch(This,dwWorkForBatch)	\
    ( (This)->lpVtbl -> SetWorkEstimateForBatch(This,dwWorkForBatch) ) 

#define ISyncChangeBatch_SetRemainingWorkEstimateForSession(This,dwRemainingWorkForSession)	\
    ( (This)->lpVtbl -> SetRemainingWorkEstimateForSession(This,dwRemainingWorkForSession) ) 

#define ISyncChangeBatch_Serialize(This,pbChangeBatch,pcbChangeBatch)	\
    ( (This)->lpVtbl -> Serialize(This,pbChangeBatch,pcbChangeBatch) ) 


#define ISyncChangeBatch_BeginUnorderedGroup(This)	\
    ( (This)->lpVtbl -> BeginUnorderedGroup(This) ) 

#define ISyncChangeBatch_EndUnorderedGroup(This,pMadeWithKnowledge,fAllChangesForKnowledge)	\
    ( (This)->lpVtbl -> EndUnorderedGroup(This,pMadeWithKnowledge,fAllChangesForKnowledge) ) 

#define ISyncChangeBatch_AddLoggedConflict(This,pbOwnerReplicaId,pbItemId,pChangeVersion,pCreationVersion,dwFlags,dwWorkForChange,pConflictKnowledge,ppChangeBuilder)	\
    ( (This)->lpVtbl -> AddLoggedConflict(This,pbOwnerReplicaId,pbItemId,pChangeVersion,pCreationVersion,dwFlags,dwWorkForChange,pConflictKnowledge,ppChangeBuilder) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncChangeBatch_INTERFACE_DEFINED__ */


#ifndef __ISyncFullEnumerationChangeBatch_INTERFACE_DEFINED__
#define __ISyncFullEnumerationChangeBatch_INTERFACE_DEFINED__

/* interface ISyncFullEnumerationChangeBatch */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncFullEnumerationChangeBatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EF64197D-4F44-4ea2-B355-4524713E3BED")
    ISyncFullEnumerationChangeBatch : public ISyncChangeBatchBase
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLearnedKnowledgeAfterRecoveryComplete( 
            /* [out] */ ISyncKnowledge **ppLearnedKnowledgeAfterRecoveryComplete) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClosedLowerBoundItemId( 
            /* [size_is][unique][out][in] */ BYTE *pbClosedLowerBoundItemId,
            /* [out][in] */ DWORD *pcbIdSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClosedUpperBoundItemId( 
            /* [size_is][unique][out][in] */ BYTE *pbClosedUpperBoundItemId,
            /* [out][in] */ DWORD *pcbIdSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncFullEnumerationChangeBatchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncFullEnumerationChangeBatch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncFullEnumerationChangeBatch * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeEnumerator )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [out] */ IEnumSyncChanges **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsLastBatch )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [out] */ BOOL *pfLastBatch);
        
        HRESULT ( STDMETHODCALLTYPE *GetWorkEstimateForBatch )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [out] */ DWORD *pdwWorkForBatch);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemainingWorkEstimateForSession )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [out] */ DWORD *pdwRemainingWorkForSession);
        
        HRESULT ( STDMETHODCALLTYPE *BeginOrderedGroup )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [in] */ const BYTE *pbLowerBound);
        
        HRESULT ( STDMETHODCALLTYPE *EndOrderedGroup )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [in] */ const BYTE *pbUpperBound,
            /* [in] */ ISyncKnowledge *pMadeWithKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *AddItemMetadataToGroup )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [in] */ const BYTE *pbOwnerReplicaId,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const SYNC_VERSION *pChangeVersion,
            /* [in] */ const SYNC_VERSION *pCreationVersion,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwWorkForChange,
            /* [unique][out][in] */ ISyncChangeBuilder **ppChangeBuilder);
        
        HRESULT ( STDMETHODCALLTYPE *GetLearnedKnowledge )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [out] */ ISyncKnowledge **ppLearnedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrerequisiteKnowledge )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [out] */ ISyncKnowledge **ppPrerequisteKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceForgottenKnowledge )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [out] */ IForgottenKnowledge **ppSourceForgottenKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *SetLastBatch )( 
            ISyncFullEnumerationChangeBatch * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetWorkEstimateForBatch )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [in] */ DWORD dwWorkForBatch);
        
        HRESULT ( STDMETHODCALLTYPE *SetRemainingWorkEstimateForSession )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [in] */ DWORD dwRemainingWorkForSession);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [size_is][unique][out][in] */ BYTE *pbChangeBatch,
            /* [out][in] */ DWORD *pcbChangeBatch);
        
        HRESULT ( STDMETHODCALLTYPE *GetLearnedKnowledgeAfterRecoveryComplete )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [out] */ ISyncKnowledge **ppLearnedKnowledgeAfterRecoveryComplete);
        
        HRESULT ( STDMETHODCALLTYPE *GetClosedLowerBoundItemId )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [size_is][unique][out][in] */ BYTE *pbClosedLowerBoundItemId,
            /* [out][in] */ DWORD *pcbIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetClosedUpperBoundItemId )( 
            ISyncFullEnumerationChangeBatch * This,
            /* [size_is][unique][out][in] */ BYTE *pbClosedUpperBoundItemId,
            /* [out][in] */ DWORD *pcbIdSize);
        
        END_INTERFACE
    } ISyncFullEnumerationChangeBatchVtbl;

    interface ISyncFullEnumerationChangeBatch
    {
        CONST_VTBL struct ISyncFullEnumerationChangeBatchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncFullEnumerationChangeBatch_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncFullEnumerationChangeBatch_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncFullEnumerationChangeBatch_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncFullEnumerationChangeBatch_GetChangeEnumerator(This,ppEnum)	\
    ( (This)->lpVtbl -> GetChangeEnumerator(This,ppEnum) ) 

#define ISyncFullEnumerationChangeBatch_GetIsLastBatch(This,pfLastBatch)	\
    ( (This)->lpVtbl -> GetIsLastBatch(This,pfLastBatch) ) 

#define ISyncFullEnumerationChangeBatch_GetWorkEstimateForBatch(This,pdwWorkForBatch)	\
    ( (This)->lpVtbl -> GetWorkEstimateForBatch(This,pdwWorkForBatch) ) 

#define ISyncFullEnumerationChangeBatch_GetRemainingWorkEstimateForSession(This,pdwRemainingWorkForSession)	\
    ( (This)->lpVtbl -> GetRemainingWorkEstimateForSession(This,pdwRemainingWorkForSession) ) 

#define ISyncFullEnumerationChangeBatch_BeginOrderedGroup(This,pbLowerBound)	\
    ( (This)->lpVtbl -> BeginOrderedGroup(This,pbLowerBound) ) 

#define ISyncFullEnumerationChangeBatch_EndOrderedGroup(This,pbUpperBound,pMadeWithKnowledge)	\
    ( (This)->lpVtbl -> EndOrderedGroup(This,pbUpperBound,pMadeWithKnowledge) ) 

#define ISyncFullEnumerationChangeBatch_AddItemMetadataToGroup(This,pbOwnerReplicaId,pbItemId,pChangeVersion,pCreationVersion,dwFlags,dwWorkForChange,ppChangeBuilder)	\
    ( (This)->lpVtbl -> AddItemMetadataToGroup(This,pbOwnerReplicaId,pbItemId,pChangeVersion,pCreationVersion,dwFlags,dwWorkForChange,ppChangeBuilder) ) 

#define ISyncFullEnumerationChangeBatch_GetLearnedKnowledge(This,ppLearnedKnowledge)	\
    ( (This)->lpVtbl -> GetLearnedKnowledge(This,ppLearnedKnowledge) ) 

#define ISyncFullEnumerationChangeBatch_GetPrerequisiteKnowledge(This,ppPrerequisteKnowledge)	\
    ( (This)->lpVtbl -> GetPrerequisiteKnowledge(This,ppPrerequisteKnowledge) ) 

#define ISyncFullEnumerationChangeBatch_GetSourceForgottenKnowledge(This,ppSourceForgottenKnowledge)	\
    ( (This)->lpVtbl -> GetSourceForgottenKnowledge(This,ppSourceForgottenKnowledge) ) 

#define ISyncFullEnumerationChangeBatch_SetLastBatch(This)	\
    ( (This)->lpVtbl -> SetLastBatch(This) ) 

#define ISyncFullEnumerationChangeBatch_SetWorkEstimateForBatch(This,dwWorkForBatch)	\
    ( (This)->lpVtbl -> SetWorkEstimateForBatch(This,dwWorkForBatch) ) 

#define ISyncFullEnumerationChangeBatch_SetRemainingWorkEstimateForSession(This,dwRemainingWorkForSession)	\
    ( (This)->lpVtbl -> SetRemainingWorkEstimateForSession(This,dwRemainingWorkForSession) ) 

#define ISyncFullEnumerationChangeBatch_Serialize(This,pbChangeBatch,pcbChangeBatch)	\
    ( (This)->lpVtbl -> Serialize(This,pbChangeBatch,pcbChangeBatch) ) 


#define ISyncFullEnumerationChangeBatch_GetLearnedKnowledgeAfterRecoveryComplete(This,ppLearnedKnowledgeAfterRecoveryComplete)	\
    ( (This)->lpVtbl -> GetLearnedKnowledgeAfterRecoveryComplete(This,ppLearnedKnowledgeAfterRecoveryComplete) ) 

#define ISyncFullEnumerationChangeBatch_GetClosedLowerBoundItemId(This,pbClosedLowerBoundItemId,pcbIdSize)	\
    ( (This)->lpVtbl -> GetClosedLowerBoundItemId(This,pbClosedLowerBoundItemId,pcbIdSize) ) 

#define ISyncFullEnumerationChangeBatch_GetClosedUpperBoundItemId(This,pbClosedUpperBoundItemId,pcbIdSize)	\
    ( (This)->lpVtbl -> GetClosedUpperBoundItemId(This,pbClosedUpperBoundItemId,pcbIdSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncFullEnumerationChangeBatch_INTERFACE_DEFINED__ */


#ifndef __ISyncChangeBatchWithPrerequisite_INTERFACE_DEFINED__
#define __ISyncChangeBatchWithPrerequisite_INTERFACE_DEFINED__

/* interface ISyncChangeBatchWithPrerequisite */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncChangeBatchWithPrerequisite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("097f13be-5b92-4048-b3f2-7b42a2515e07")
    ISyncChangeBatchWithPrerequisite : public ISyncChangeBatchBase
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPrerequisiteKnowledge( 
            /* [in] */ ISyncKnowledge *pPrerequisiteKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLearnedKnowledgeWithPrerequisite( 
            /* [in] */ ISyncKnowledge *pDestinationKnowledge,
            /* [out] */ ISyncKnowledge **ppLearnedWithPrerequisiteKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLearnedForgottenKnowledge( 
            /* [out] */ IForgottenKnowledge **ppLearnedForgottenKnowledge) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncChangeBatchWithPrerequisiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncChangeBatchWithPrerequisite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncChangeBatchWithPrerequisite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeEnumerator )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [out] */ IEnumSyncChanges **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsLastBatch )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [out] */ BOOL *pfLastBatch);
        
        HRESULT ( STDMETHODCALLTYPE *GetWorkEstimateForBatch )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [out] */ DWORD *pdwWorkForBatch);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemainingWorkEstimateForSession )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [out] */ DWORD *pdwRemainingWorkForSession);
        
        HRESULT ( STDMETHODCALLTYPE *BeginOrderedGroup )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [in] */ const BYTE *pbLowerBound);
        
        HRESULT ( STDMETHODCALLTYPE *EndOrderedGroup )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [in] */ const BYTE *pbUpperBound,
            /* [in] */ ISyncKnowledge *pMadeWithKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *AddItemMetadataToGroup )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [in] */ const BYTE *pbOwnerReplicaId,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const SYNC_VERSION *pChangeVersion,
            /* [in] */ const SYNC_VERSION *pCreationVersion,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwWorkForChange,
            /* [unique][out][in] */ ISyncChangeBuilder **ppChangeBuilder);
        
        HRESULT ( STDMETHODCALLTYPE *GetLearnedKnowledge )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [out] */ ISyncKnowledge **ppLearnedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrerequisiteKnowledge )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [out] */ ISyncKnowledge **ppPrerequisteKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceForgottenKnowledge )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [out] */ IForgottenKnowledge **ppSourceForgottenKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *SetLastBatch )( 
            ISyncChangeBatchWithPrerequisite * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetWorkEstimateForBatch )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [in] */ DWORD dwWorkForBatch);
        
        HRESULT ( STDMETHODCALLTYPE *SetRemainingWorkEstimateForSession )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [in] */ DWORD dwRemainingWorkForSession);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [size_is][unique][out][in] */ BYTE *pbChangeBatch,
            /* [out][in] */ DWORD *pcbChangeBatch);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrerequisiteKnowledge )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [in] */ ISyncKnowledge *pPrerequisiteKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetLearnedKnowledgeWithPrerequisite )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [in] */ ISyncKnowledge *pDestinationKnowledge,
            /* [out] */ ISyncKnowledge **ppLearnedWithPrerequisiteKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetLearnedForgottenKnowledge )( 
            ISyncChangeBatchWithPrerequisite * This,
            /* [out] */ IForgottenKnowledge **ppLearnedForgottenKnowledge);
        
        END_INTERFACE
    } ISyncChangeBatchWithPrerequisiteVtbl;

    interface ISyncChangeBatchWithPrerequisite
    {
        CONST_VTBL struct ISyncChangeBatchWithPrerequisiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncChangeBatchWithPrerequisite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncChangeBatchWithPrerequisite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncChangeBatchWithPrerequisite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncChangeBatchWithPrerequisite_GetChangeEnumerator(This,ppEnum)	\
    ( (This)->lpVtbl -> GetChangeEnumerator(This,ppEnum) ) 

#define ISyncChangeBatchWithPrerequisite_GetIsLastBatch(This,pfLastBatch)	\
    ( (This)->lpVtbl -> GetIsLastBatch(This,pfLastBatch) ) 

#define ISyncChangeBatchWithPrerequisite_GetWorkEstimateForBatch(This,pdwWorkForBatch)	\
    ( (This)->lpVtbl -> GetWorkEstimateForBatch(This,pdwWorkForBatch) ) 

#define ISyncChangeBatchWithPrerequisite_GetRemainingWorkEstimateForSession(This,pdwRemainingWorkForSession)	\
    ( (This)->lpVtbl -> GetRemainingWorkEstimateForSession(This,pdwRemainingWorkForSession) ) 

#define ISyncChangeBatchWithPrerequisite_BeginOrderedGroup(This,pbLowerBound)	\
    ( (This)->lpVtbl -> BeginOrderedGroup(This,pbLowerBound) ) 

#define ISyncChangeBatchWithPrerequisite_EndOrderedGroup(This,pbUpperBound,pMadeWithKnowledge)	\
    ( (This)->lpVtbl -> EndOrderedGroup(This,pbUpperBound,pMadeWithKnowledge) ) 

#define ISyncChangeBatchWithPrerequisite_AddItemMetadataToGroup(This,pbOwnerReplicaId,pbItemId,pChangeVersion,pCreationVersion,dwFlags,dwWorkForChange,ppChangeBuilder)	\
    ( (This)->lpVtbl -> AddItemMetadataToGroup(This,pbOwnerReplicaId,pbItemId,pChangeVersion,pCreationVersion,dwFlags,dwWorkForChange,ppChangeBuilder) ) 

#define ISyncChangeBatchWithPrerequisite_GetLearnedKnowledge(This,ppLearnedKnowledge)	\
    ( (This)->lpVtbl -> GetLearnedKnowledge(This,ppLearnedKnowledge) ) 

#define ISyncChangeBatchWithPrerequisite_GetPrerequisiteKnowledge(This,ppPrerequisteKnowledge)	\
    ( (This)->lpVtbl -> GetPrerequisiteKnowledge(This,ppPrerequisteKnowledge) ) 

#define ISyncChangeBatchWithPrerequisite_GetSourceForgottenKnowledge(This,ppSourceForgottenKnowledge)	\
    ( (This)->lpVtbl -> GetSourceForgottenKnowledge(This,ppSourceForgottenKnowledge) ) 

#define ISyncChangeBatchWithPrerequisite_SetLastBatch(This)	\
    ( (This)->lpVtbl -> SetLastBatch(This) ) 

#define ISyncChangeBatchWithPrerequisite_SetWorkEstimateForBatch(This,dwWorkForBatch)	\
    ( (This)->lpVtbl -> SetWorkEstimateForBatch(This,dwWorkForBatch) ) 

#define ISyncChangeBatchWithPrerequisite_SetRemainingWorkEstimateForSession(This,dwRemainingWorkForSession)	\
    ( (This)->lpVtbl -> SetRemainingWorkEstimateForSession(This,dwRemainingWorkForSession) ) 

#define ISyncChangeBatchWithPrerequisite_Serialize(This,pbChangeBatch,pcbChangeBatch)	\
    ( (This)->lpVtbl -> Serialize(This,pbChangeBatch,pcbChangeBatch) ) 


#define ISyncChangeBatchWithPrerequisite_SetPrerequisiteKnowledge(This,pPrerequisiteKnowledge)	\
    ( (This)->lpVtbl -> SetPrerequisiteKnowledge(This,pPrerequisiteKnowledge) ) 

#define ISyncChangeBatchWithPrerequisite_GetLearnedKnowledgeWithPrerequisite(This,pDestinationKnowledge,ppLearnedWithPrerequisiteKnowledge)	\
    ( (This)->lpVtbl -> GetLearnedKnowledgeWithPrerequisite(This,pDestinationKnowledge,ppLearnedWithPrerequisiteKnowledge) ) 

#define ISyncChangeBatchWithPrerequisite_GetLearnedForgottenKnowledge(This,ppLearnedForgottenKnowledge)	\
    ( (This)->lpVtbl -> GetLearnedForgottenKnowledge(This,ppLearnedForgottenKnowledge) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncChangeBatchWithPrerequisite_INTERFACE_DEFINED__ */


#ifndef __ISyncChangeBatchBase2_INTERFACE_DEFINED__
#define __ISyncChangeBatchBase2_INTERFACE_DEFINED__

/* interface ISyncChangeBatchBase2 */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncChangeBatchBase2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6fdb596a-d755-4584-bd0c-c0c23a548fbf")
    ISyncChangeBatchBase2 : public ISyncChangeBatchBase
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SerializeWithOptions( 
            /* [in] */ SYNC_SERIALIZATION_VERSION targetFormatVersion,
            /* [in] */ DWORD dwFlags,
            /* [size_is][unique][out][in] */ BYTE *pbBuffer,
            /* [out][in] */ DWORD *pdwSerializedSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncChangeBatchBase2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncChangeBatchBase2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncChangeBatchBase2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncChangeBatchBase2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeEnumerator )( 
            ISyncChangeBatchBase2 * This,
            /* [out] */ IEnumSyncChanges **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsLastBatch )( 
            ISyncChangeBatchBase2 * This,
            /* [out] */ BOOL *pfLastBatch);
        
        HRESULT ( STDMETHODCALLTYPE *GetWorkEstimateForBatch )( 
            ISyncChangeBatchBase2 * This,
            /* [out] */ DWORD *pdwWorkForBatch);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemainingWorkEstimateForSession )( 
            ISyncChangeBatchBase2 * This,
            /* [out] */ DWORD *pdwRemainingWorkForSession);
        
        HRESULT ( STDMETHODCALLTYPE *BeginOrderedGroup )( 
            ISyncChangeBatchBase2 * This,
            /* [in] */ const BYTE *pbLowerBound);
        
        HRESULT ( STDMETHODCALLTYPE *EndOrderedGroup )( 
            ISyncChangeBatchBase2 * This,
            /* [in] */ const BYTE *pbUpperBound,
            /* [in] */ ISyncKnowledge *pMadeWithKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *AddItemMetadataToGroup )( 
            ISyncChangeBatchBase2 * This,
            /* [in] */ const BYTE *pbOwnerReplicaId,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const SYNC_VERSION *pChangeVersion,
            /* [in] */ const SYNC_VERSION *pCreationVersion,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwWorkForChange,
            /* [unique][out][in] */ ISyncChangeBuilder **ppChangeBuilder);
        
        HRESULT ( STDMETHODCALLTYPE *GetLearnedKnowledge )( 
            ISyncChangeBatchBase2 * This,
            /* [out] */ ISyncKnowledge **ppLearnedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrerequisiteKnowledge )( 
            ISyncChangeBatchBase2 * This,
            /* [out] */ ISyncKnowledge **ppPrerequisteKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceForgottenKnowledge )( 
            ISyncChangeBatchBase2 * This,
            /* [out] */ IForgottenKnowledge **ppSourceForgottenKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *SetLastBatch )( 
            ISyncChangeBatchBase2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetWorkEstimateForBatch )( 
            ISyncChangeBatchBase2 * This,
            /* [in] */ DWORD dwWorkForBatch);
        
        HRESULT ( STDMETHODCALLTYPE *SetRemainingWorkEstimateForSession )( 
            ISyncChangeBatchBase2 * This,
            /* [in] */ DWORD dwRemainingWorkForSession);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ISyncChangeBatchBase2 * This,
            /* [size_is][unique][out][in] */ BYTE *pbChangeBatch,
            /* [out][in] */ DWORD *pcbChangeBatch);
        
        HRESULT ( STDMETHODCALLTYPE *SerializeWithOptions )( 
            ISyncChangeBatchBase2 * This,
            /* [in] */ SYNC_SERIALIZATION_VERSION targetFormatVersion,
            /* [in] */ DWORD dwFlags,
            /* [size_is][unique][out][in] */ BYTE *pbBuffer,
            /* [out][in] */ DWORD *pdwSerializedSize);
        
        END_INTERFACE
    } ISyncChangeBatchBase2Vtbl;

    interface ISyncChangeBatchBase2
    {
        CONST_VTBL struct ISyncChangeBatchBase2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncChangeBatchBase2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncChangeBatchBase2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncChangeBatchBase2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncChangeBatchBase2_GetChangeEnumerator(This,ppEnum)	\
    ( (This)->lpVtbl -> GetChangeEnumerator(This,ppEnum) ) 

#define ISyncChangeBatchBase2_GetIsLastBatch(This,pfLastBatch)	\
    ( (This)->lpVtbl -> GetIsLastBatch(This,pfLastBatch) ) 

#define ISyncChangeBatchBase2_GetWorkEstimateForBatch(This,pdwWorkForBatch)	\
    ( (This)->lpVtbl -> GetWorkEstimateForBatch(This,pdwWorkForBatch) ) 

#define ISyncChangeBatchBase2_GetRemainingWorkEstimateForSession(This,pdwRemainingWorkForSession)	\
    ( (This)->lpVtbl -> GetRemainingWorkEstimateForSession(This,pdwRemainingWorkForSession) ) 

#define ISyncChangeBatchBase2_BeginOrderedGroup(This,pbLowerBound)	\
    ( (This)->lpVtbl -> BeginOrderedGroup(This,pbLowerBound) ) 

#define ISyncChangeBatchBase2_EndOrderedGroup(This,pbUpperBound,pMadeWithKnowledge)	\
    ( (This)->lpVtbl -> EndOrderedGroup(This,pbUpperBound,pMadeWithKnowledge) ) 

#define ISyncChangeBatchBase2_AddItemMetadataToGroup(This,pbOwnerReplicaId,pbItemId,pChangeVersion,pCreationVersion,dwFlags,dwWorkForChange,ppChangeBuilder)	\
    ( (This)->lpVtbl -> AddItemMetadataToGroup(This,pbOwnerReplicaId,pbItemId,pChangeVersion,pCreationVersion,dwFlags,dwWorkForChange,ppChangeBuilder) ) 

#define ISyncChangeBatchBase2_GetLearnedKnowledge(This,ppLearnedKnowledge)	\
    ( (This)->lpVtbl -> GetLearnedKnowledge(This,ppLearnedKnowledge) ) 

#define ISyncChangeBatchBase2_GetPrerequisiteKnowledge(This,ppPrerequisteKnowledge)	\
    ( (This)->lpVtbl -> GetPrerequisiteKnowledge(This,ppPrerequisteKnowledge) ) 

#define ISyncChangeBatchBase2_GetSourceForgottenKnowledge(This,ppSourceForgottenKnowledge)	\
    ( (This)->lpVtbl -> GetSourceForgottenKnowledge(This,ppSourceForgottenKnowledge) ) 

#define ISyncChangeBatchBase2_SetLastBatch(This)	\
    ( (This)->lpVtbl -> SetLastBatch(This) ) 

#define ISyncChangeBatchBase2_SetWorkEstimateForBatch(This,dwWorkForBatch)	\
    ( (This)->lpVtbl -> SetWorkEstimateForBatch(This,dwWorkForBatch) ) 

#define ISyncChangeBatchBase2_SetRemainingWorkEstimateForSession(This,dwRemainingWorkForSession)	\
    ( (This)->lpVtbl -> SetRemainingWorkEstimateForSession(This,dwRemainingWorkForSession) ) 

#define ISyncChangeBatchBase2_Serialize(This,pbChangeBatch,pcbChangeBatch)	\
    ( (This)->lpVtbl -> Serialize(This,pbChangeBatch,pcbChangeBatch) ) 


#define ISyncChangeBatchBase2_SerializeWithOptions(This,targetFormatVersion,dwFlags,pbBuffer,pdwSerializedSize)	\
    ( (This)->lpVtbl -> SerializeWithOptions(This,targetFormatVersion,dwFlags,pbBuffer,pdwSerializedSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncChangeBatchBase2_INTERFACE_DEFINED__ */


#ifndef __ISyncChangeBatchAdvanced_INTERFACE_DEFINED__
#define __ISyncChangeBatchAdvanced_INTERFACE_DEFINED__

/* interface ISyncChangeBatchAdvanced */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncChangeBatchAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0f1a4995-cbc8-421d-b550-5d0bebf3e9a5")
    ISyncChangeBatchAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFilterInfo( 
            /* [out] */ ISyncFilterInfo **ppFilterInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertFullEnumerationChangeBatchToRegularChangeBatch( 
            /* [out] */ ISyncChangeBatch **ppChangeBatch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUpperBoundItemId( 
            /* [size_is][unique][out][in] */ BYTE *pbItemId,
            /* [out][in] */ DWORD *pcbIdSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBatchLevelKnowledgeShouldBeApplied( 
            /* [out] */ BOOL *pfBatchKnowledgeShouldBeApplied) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncChangeBatchAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncChangeBatchAdvanced * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncChangeBatchAdvanced * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncChangeBatchAdvanced * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterInfo )( 
            ISyncChangeBatchAdvanced * This,
            /* [out] */ ISyncFilterInfo **ppFilterInfo);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertFullEnumerationChangeBatchToRegularChangeBatch )( 
            ISyncChangeBatchAdvanced * This,
            /* [out] */ ISyncChangeBatch **ppChangeBatch);
        
        HRESULT ( STDMETHODCALLTYPE *GetUpperBoundItemId )( 
            ISyncChangeBatchAdvanced * This,
            /* [size_is][unique][out][in] */ BYTE *pbItemId,
            /* [out][in] */ DWORD *pcbIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBatchLevelKnowledgeShouldBeApplied )( 
            ISyncChangeBatchAdvanced * This,
            /* [out] */ BOOL *pfBatchKnowledgeShouldBeApplied);
        
        END_INTERFACE
    } ISyncChangeBatchAdvancedVtbl;

    interface ISyncChangeBatchAdvanced
    {
        CONST_VTBL struct ISyncChangeBatchAdvancedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncChangeBatchAdvanced_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncChangeBatchAdvanced_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncChangeBatchAdvanced_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncChangeBatchAdvanced_GetFilterInfo(This,ppFilterInfo)	\
    ( (This)->lpVtbl -> GetFilterInfo(This,ppFilterInfo) ) 

#define ISyncChangeBatchAdvanced_ConvertFullEnumerationChangeBatchToRegularChangeBatch(This,ppChangeBatch)	\
    ( (This)->lpVtbl -> ConvertFullEnumerationChangeBatchToRegularChangeBatch(This,ppChangeBatch) ) 

#define ISyncChangeBatchAdvanced_GetUpperBoundItemId(This,pbItemId,pcbIdSize)	\
    ( (This)->lpVtbl -> GetUpperBoundItemId(This,pbItemId,pcbIdSize) ) 

#define ISyncChangeBatchAdvanced_GetBatchLevelKnowledgeShouldBeApplied(This,pfBatchKnowledgeShouldBeApplied)	\
    ( (This)->lpVtbl -> GetBatchLevelKnowledgeShouldBeApplied(This,pfBatchKnowledgeShouldBeApplied) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncChangeBatchAdvanced_INTERFACE_DEFINED__ */


#ifndef __IKnowledgeSyncProvider_INTERFACE_DEFINED__
#define __IKnowledgeSyncProvider_INTERFACE_DEFINED__

/* interface IKnowledgeSyncProvider */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IKnowledgeSyncProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43434a49-8da4-47f2-8172-ad7b8b024978")
    IKnowledgeSyncProvider : public ISyncProvider
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginSession( 
            /* [in] */ SYNC_PROVIDER_ROLE role,
            /* [in] */ ISyncSessionState *pSessionState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncBatchParameters( 
            /* [out] */ ISyncKnowledge **ppSyncKnowledge,
            /* [out] */ DWORD *pdwRequestedBatchSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeBatch( 
            /* [in] */ DWORD dwBatchSize,
            /* [in] */ ISyncKnowledge *pSyncKnowledge,
            /* [out] */ ISyncChangeBatch **ppSyncChangeBatch,
            /* [out] */ IUnknown **ppUnkDataRetriever) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFullEnumerationChangeBatch( 
            /* [in] */ DWORD dwBatchSize,
            /* [in] */ const BYTE *pbLowerEnumerationBound,
            /* [in] */ ISyncKnowledge *pSyncKnowledge,
            /* [out] */ ISyncFullEnumerationChangeBatch **ppSyncChangeBatch,
            /* [out] */ IUnknown **ppUnkDataRetriever) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessChangeBatch( 
            /* [in] */ CONFLICT_RESOLUTION_POLICY resolutionPolicy,
            /* [in] */ ISyncChangeBatch *pSourceChangeBatch,
            /* [in] */ IUnknown *pUnkDataRetriever,
            /* [in] */ ISyncCallback *pCallback,
            /* [out][in] */ SYNC_SESSION_STATISTICS *pSyncSessionStatistics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessFullEnumerationChangeBatch( 
            /* [in] */ CONFLICT_RESOLUTION_POLICY resolutionPolicy,
            /* [in] */ ISyncFullEnumerationChangeBatch *pSourceChangeBatch,
            /* [in] */ IUnknown *pUnkDataRetriever,
            /* [in] */ ISyncCallback *pCallback,
            /* [out][in] */ SYNC_SESSION_STATISTICS *pSyncSessionStatistics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndSession( 
            /* [in] */ ISyncSessionState *pSessionState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKnowledgeSyncProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IKnowledgeSyncProvider * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IKnowledgeSyncProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IKnowledgeSyncProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdParameters )( 
            IKnowledgeSyncProvider * This,
            /* [out] */ ID_PARAMETERS *pIdParameters);
        
        HRESULT ( STDMETHODCALLTYPE *BeginSession )( 
            IKnowledgeSyncProvider * This,
            /* [in] */ SYNC_PROVIDER_ROLE role,
            /* [in] */ ISyncSessionState *pSessionState);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncBatchParameters )( 
            IKnowledgeSyncProvider * This,
            /* [out] */ ISyncKnowledge **ppSyncKnowledge,
            /* [out] */ DWORD *pdwRequestedBatchSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeBatch )( 
            IKnowledgeSyncProvider * This,
            /* [in] */ DWORD dwBatchSize,
            /* [in] */ ISyncKnowledge *pSyncKnowledge,
            /* [out] */ ISyncChangeBatch **ppSyncChangeBatch,
            /* [out] */ IUnknown **ppUnkDataRetriever);
        
        HRESULT ( STDMETHODCALLTYPE *GetFullEnumerationChangeBatch )( 
            IKnowledgeSyncProvider * This,
            /* [in] */ DWORD dwBatchSize,
            /* [in] */ const BYTE *pbLowerEnumerationBound,
            /* [in] */ ISyncKnowledge *pSyncKnowledge,
            /* [out] */ ISyncFullEnumerationChangeBatch **ppSyncChangeBatch,
            /* [out] */ IUnknown **ppUnkDataRetriever);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessChangeBatch )( 
            IKnowledgeSyncProvider * This,
            /* [in] */ CONFLICT_RESOLUTION_POLICY resolutionPolicy,
            /* [in] */ ISyncChangeBatch *pSourceChangeBatch,
            /* [in] */ IUnknown *pUnkDataRetriever,
            /* [in] */ ISyncCallback *pCallback,
            /* [out][in] */ SYNC_SESSION_STATISTICS *pSyncSessionStatistics);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessFullEnumerationChangeBatch )( 
            IKnowledgeSyncProvider * This,
            /* [in] */ CONFLICT_RESOLUTION_POLICY resolutionPolicy,
            /* [in] */ ISyncFullEnumerationChangeBatch *pSourceChangeBatch,
            /* [in] */ IUnknown *pUnkDataRetriever,
            /* [in] */ ISyncCallback *pCallback,
            /* [out][in] */ SYNC_SESSION_STATISTICS *pSyncSessionStatistics);
        
        HRESULT ( STDMETHODCALLTYPE *EndSession )( 
            IKnowledgeSyncProvider * This,
            /* [in] */ ISyncSessionState *pSessionState);
        
        END_INTERFACE
    } IKnowledgeSyncProviderVtbl;

    interface IKnowledgeSyncProvider
    {
        CONST_VTBL struct IKnowledgeSyncProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKnowledgeSyncProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IKnowledgeSyncProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IKnowledgeSyncProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IKnowledgeSyncProvider_GetIdParameters(This,pIdParameters)	\
    ( (This)->lpVtbl -> GetIdParameters(This,pIdParameters) ) 


#define IKnowledgeSyncProvider_BeginSession(This,role,pSessionState)	\
    ( (This)->lpVtbl -> BeginSession(This,role,pSessionState) ) 

#define IKnowledgeSyncProvider_GetSyncBatchParameters(This,ppSyncKnowledge,pdwRequestedBatchSize)	\
    ( (This)->lpVtbl -> GetSyncBatchParameters(This,ppSyncKnowledge,pdwRequestedBatchSize) ) 

#define IKnowledgeSyncProvider_GetChangeBatch(This,dwBatchSize,pSyncKnowledge,ppSyncChangeBatch,ppUnkDataRetriever)	\
    ( (This)->lpVtbl -> GetChangeBatch(This,dwBatchSize,pSyncKnowledge,ppSyncChangeBatch,ppUnkDataRetriever) ) 

#define IKnowledgeSyncProvider_GetFullEnumerationChangeBatch(This,dwBatchSize,pbLowerEnumerationBound,pSyncKnowledge,ppSyncChangeBatch,ppUnkDataRetriever)	\
    ( (This)->lpVtbl -> GetFullEnumerationChangeBatch(This,dwBatchSize,pbLowerEnumerationBound,pSyncKnowledge,ppSyncChangeBatch,ppUnkDataRetriever) ) 

#define IKnowledgeSyncProvider_ProcessChangeBatch(This,resolutionPolicy,pSourceChangeBatch,pUnkDataRetriever,pCallback,pSyncSessionStatistics)	\
    ( (This)->lpVtbl -> ProcessChangeBatch(This,resolutionPolicy,pSourceChangeBatch,pUnkDataRetriever,pCallback,pSyncSessionStatistics) ) 

#define IKnowledgeSyncProvider_ProcessFullEnumerationChangeBatch(This,resolutionPolicy,pSourceChangeBatch,pUnkDataRetriever,pCallback,pSyncSessionStatistics)	\
    ( (This)->lpVtbl -> ProcessFullEnumerationChangeBatch(This,resolutionPolicy,pSourceChangeBatch,pUnkDataRetriever,pCallback,pSyncSessionStatistics) ) 

#define IKnowledgeSyncProvider_EndSession(This,pSessionState)	\
    ( (This)->lpVtbl -> EndSession(This,pSessionState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IKnowledgeSyncProvider_INTERFACE_DEFINED__ */


#ifndef __ISyncChangeUnit_INTERFACE_DEFINED__
#define __ISyncChangeUnit_INTERFACE_DEFINED__

/* interface ISyncChangeUnit */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncChangeUnit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60edd8ca-7341-4bb7-95ce-fab6394b51cb")
    ISyncChangeUnit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetItemChange( 
            /* [out] */ ISyncChange **ppSyncChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeUnitId( 
            /* [size_is][unique][out][in] */ BYTE *pbChangeUnitId,
            /* [out][in] */ DWORD *pcbIdSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeUnitVersion( 
            /* [in] */ const BYTE *pbCurrentReplicaId,
            /* [out] */ SYNC_VERSION *pVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncChangeUnitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncChangeUnit * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncChangeUnit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncChangeUnit * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemChange )( 
            ISyncChangeUnit * This,
            /* [out] */ ISyncChange **ppSyncChange);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeUnitId )( 
            ISyncChangeUnit * This,
            /* [size_is][unique][out][in] */ BYTE *pbChangeUnitId,
            /* [out][in] */ DWORD *pcbIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeUnitVersion )( 
            ISyncChangeUnit * This,
            /* [in] */ const BYTE *pbCurrentReplicaId,
            /* [out] */ SYNC_VERSION *pVersion);
        
        END_INTERFACE
    } ISyncChangeUnitVtbl;

    interface ISyncChangeUnit
    {
        CONST_VTBL struct ISyncChangeUnitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncChangeUnit_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncChangeUnit_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncChangeUnit_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncChangeUnit_GetItemChange(This,ppSyncChange)	\
    ( (This)->lpVtbl -> GetItemChange(This,ppSyncChange) ) 

#define ISyncChangeUnit_GetChangeUnitId(This,pbChangeUnitId,pcbIdSize)	\
    ( (This)->lpVtbl -> GetChangeUnitId(This,pbChangeUnitId,pcbIdSize) ) 

#define ISyncChangeUnit_GetChangeUnitVersion(This,pbCurrentReplicaId,pVersion)	\
    ( (This)->lpVtbl -> GetChangeUnitVersion(This,pbCurrentReplicaId,pVersion) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncChangeUnit_INTERFACE_DEFINED__ */


#ifndef __IEnumSyncChangeUnits_INTERFACE_DEFINED__
#define __IEnumSyncChangeUnits_INTERFACE_DEFINED__

/* interface IEnumSyncChangeUnits */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IEnumSyncChangeUnits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("346b35f1-8703-4c6d-ab1a-4dbca2cff97f")
    IEnumSyncChangeUnits : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [range][in] */ ULONG cChanges,
            /* [length_is][size_is][out] */ ISyncChangeUnit **ppChangeUnit,
            /* [unique][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cChanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumSyncChangeUnits **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSyncChangeUnitsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSyncChangeUnits * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSyncChangeUnits * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSyncChangeUnits * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSyncChangeUnits * This,
            /* [range][in] */ ULONG cChanges,
            /* [length_is][size_is][out] */ ISyncChangeUnit **ppChangeUnit,
            /* [unique][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSyncChangeUnits * This,
            /* [in] */ ULONG cChanges);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSyncChangeUnits * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSyncChangeUnits * This,
            /* [out] */ IEnumSyncChangeUnits **ppEnum);
        
        END_INTERFACE
    } IEnumSyncChangeUnitsVtbl;

    interface IEnumSyncChangeUnits
    {
        CONST_VTBL struct IEnumSyncChangeUnitsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSyncChangeUnits_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSyncChangeUnits_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSyncChangeUnits_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSyncChangeUnits_Next(This,cChanges,ppChangeUnit,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cChanges,ppChangeUnit,pcFetched) ) 

#define IEnumSyncChangeUnits_Skip(This,cChanges)	\
    ( (This)->lpVtbl -> Skip(This,cChanges) ) 

#define IEnumSyncChangeUnits_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSyncChangeUnits_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumSyncChangeUnits_INTERFACE_DEFINED__ */


#ifndef __ISyncChange_INTERFACE_DEFINED__
#define __ISyncChange_INTERFACE_DEFINED__

/* interface ISyncChange */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a1952beb-0f6b-4711-b136-01da85b968a6")
    ISyncChange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwnerReplicaId( 
            /* [size_is][unique][out][in] */ BYTE *pbReplicaId,
            /* [out][in] */ DWORD *pcbIdSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootItemId( 
            /* [size_is][unique][out][in] */ BYTE *pbRootItemId,
            /* [out][in] */ DWORD *pcbIdSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeVersion( 
            /* [in] */ const BYTE *pbCurrentReplicaId,
            /* [out] */ SYNC_VERSION *pVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCreationVersion( 
            /* [in] */ const BYTE *pbCurrentReplicaId,
            /* [out] */ SYNC_VERSION *pVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorkEstimate( 
            /* [out] */ DWORD *pdwWork) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeUnits( 
            /* [out] */ IEnumSyncChangeUnits **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMadeWithKnowledge( 
            /* [out] */ ISyncKnowledge **ppMadeWithKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLearnedKnowledge( 
            /* [out] */ ISyncKnowledge **ppLearnedKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorkEstimate( 
            /* [in] */ DWORD dwWork) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncChange * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncChange * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncChange * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwnerReplicaId )( 
            ISyncChange * This,
            /* [size_is][unique][out][in] */ BYTE *pbReplicaId,
            /* [out][in] */ DWORD *pcbIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootItemId )( 
            ISyncChange * This,
            /* [size_is][unique][out][in] */ BYTE *pbRootItemId,
            /* [out][in] */ DWORD *pcbIdSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeVersion )( 
            ISyncChange * This,
            /* [in] */ const BYTE *pbCurrentReplicaId,
            /* [out] */ SYNC_VERSION *pVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetCreationVersion )( 
            ISyncChange * This,
            /* [in] */ const BYTE *pbCurrentReplicaId,
            /* [out] */ SYNC_VERSION *pVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            ISyncChange * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetWorkEstimate )( 
            ISyncChange * This,
            /* [out] */ DWORD *pdwWork);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeUnits )( 
            ISyncChange * This,
            /* [out] */ IEnumSyncChangeUnits **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetMadeWithKnowledge )( 
            ISyncChange * This,
            /* [out] */ ISyncKnowledge **ppMadeWithKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetLearnedKnowledge )( 
            ISyncChange * This,
            /* [out] */ ISyncKnowledge **ppLearnedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *SetWorkEstimate )( 
            ISyncChange * This,
            /* [in] */ DWORD dwWork);
        
        END_INTERFACE
    } ISyncChangeVtbl;

    interface ISyncChange
    {
        CONST_VTBL struct ISyncChangeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncChange_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncChange_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncChange_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncChange_GetOwnerReplicaId(This,pbReplicaId,pcbIdSize)	\
    ( (This)->lpVtbl -> GetOwnerReplicaId(This,pbReplicaId,pcbIdSize) ) 

#define ISyncChange_GetRootItemId(This,pbRootItemId,pcbIdSize)	\
    ( (This)->lpVtbl -> GetRootItemId(This,pbRootItemId,pcbIdSize) ) 

#define ISyncChange_GetChangeVersion(This,pbCurrentReplicaId,pVersion)	\
    ( (This)->lpVtbl -> GetChangeVersion(This,pbCurrentReplicaId,pVersion) ) 

#define ISyncChange_GetCreationVersion(This,pbCurrentReplicaId,pVersion)	\
    ( (This)->lpVtbl -> GetCreationVersion(This,pbCurrentReplicaId,pVersion) ) 

#define ISyncChange_GetFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetFlags(This,pdwFlags) ) 

#define ISyncChange_GetWorkEstimate(This,pdwWork)	\
    ( (This)->lpVtbl -> GetWorkEstimate(This,pdwWork) ) 

#define ISyncChange_GetChangeUnits(This,ppEnum)	\
    ( (This)->lpVtbl -> GetChangeUnits(This,ppEnum) ) 

#define ISyncChange_GetMadeWithKnowledge(This,ppMadeWithKnowledge)	\
    ( (This)->lpVtbl -> GetMadeWithKnowledge(This,ppMadeWithKnowledge) ) 

#define ISyncChange_GetLearnedKnowledge(This,ppLearnedKnowledge)	\
    ( (This)->lpVtbl -> GetLearnedKnowledge(This,ppLearnedKnowledge) ) 

#define ISyncChange_SetWorkEstimate(This,dwWork)	\
    ( (This)->lpVtbl -> SetWorkEstimate(This,dwWork) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncChange_INTERFACE_DEFINED__ */


#ifndef __ISyncChangeWithPrerequisite_INTERFACE_DEFINED__
#define __ISyncChangeWithPrerequisite_INTERFACE_DEFINED__

/* interface ISyncChangeWithPrerequisite */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncChangeWithPrerequisite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e38382f-1589-48c3-92e4-05ecdcb4f3f7")
    ISyncChangeWithPrerequisite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPrerequisiteKnowledge( 
            /* [out] */ ISyncKnowledge **ppPrerequisiteKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLearnedKnowledgeWithPrerequisite( 
            /* [in] */ ISyncKnowledge *pDestinationKnowledge,
            /* [out] */ ISyncKnowledge **ppLearnedKnowledgeWithPrerequisite) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncChangeWithPrerequisiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncChangeWithPrerequisite * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncChangeWithPrerequisite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncChangeWithPrerequisite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrerequisiteKnowledge )( 
            ISyncChangeWithPrerequisite * This,
            /* [out] */ ISyncKnowledge **ppPrerequisiteKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetLearnedKnowledgeWithPrerequisite )( 
            ISyncChangeWithPrerequisite * This,
            /* [in] */ ISyncKnowledge *pDestinationKnowledge,
            /* [out] */ ISyncKnowledge **ppLearnedKnowledgeWithPrerequisite);
        
        END_INTERFACE
    } ISyncChangeWithPrerequisiteVtbl;

    interface ISyncChangeWithPrerequisite
    {
        CONST_VTBL struct ISyncChangeWithPrerequisiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncChangeWithPrerequisite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncChangeWithPrerequisite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncChangeWithPrerequisite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncChangeWithPrerequisite_GetPrerequisiteKnowledge(This,ppPrerequisiteKnowledge)	\
    ( (This)->lpVtbl -> GetPrerequisiteKnowledge(This,ppPrerequisiteKnowledge) ) 

#define ISyncChangeWithPrerequisite_GetLearnedKnowledgeWithPrerequisite(This,pDestinationKnowledge,ppLearnedKnowledgeWithPrerequisite)	\
    ( (This)->lpVtbl -> GetLearnedKnowledgeWithPrerequisite(This,pDestinationKnowledge,ppLearnedKnowledgeWithPrerequisite) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncChangeWithPrerequisite_INTERFACE_DEFINED__ */


#ifndef __ISyncFullEnumerationChange_INTERFACE_DEFINED__
#define __ISyncFullEnumerationChange_INTERFACE_DEFINED__

/* interface ISyncFullEnumerationChange */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISyncFullEnumerationChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9785e0bd-bdff-40c4-98c5-b34b2f1991b3")
    ISyncFullEnumerationChange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLearnedKnowledgeAfterRecoveryComplete( 
            /* [out] */ ISyncKnowledge **ppLearnedKnowledge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLearnedForgottenKnowledge( 
            /* [out] */ IForgottenKnowledge **ppLearnedForgottenKnowledge) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncFullEnumerationChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncFullEnumerationChange * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncFullEnumerationChange * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncFullEnumerationChange * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLearnedKnowledgeAfterRecoveryComplete )( 
            ISyncFullEnumerationChange * This,
            /* [out] */ ISyncKnowledge **ppLearnedKnowledge);
        
        HRESULT ( STDMETHODCALLTYPE *GetLearnedForgottenKnowledge )( 
            ISyncFullEnumerationChange * This,
            /* [out] */ IForgottenKnowledge **ppLearnedForgottenKnowledge);
        
        END_INTERFACE
    } ISyncFullEnumerationChangeVtbl;

    interface ISyncFullEnumerationChange
    {
        CONST_VTBL struct ISyncFullEnumerationChangeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncFullEnumerationChange_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncFullEnumerationChange_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncFullEnumerationChange_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncFullEnumerationChange_GetLearnedKnowledgeAfterRecoveryComplete(This,ppLearnedKnowledge)	\
    ( (This)->lpVtbl -> GetLearnedKnowledgeAfterRecoveryComplete(This,ppLearnedKnowledge) ) 

#define ISyncFullEnumerationChange_GetLearnedForgottenKnowledge(This,ppLearnedForgottenKnowledge)	\
    ( (This)->lpVtbl -> GetLearnedForgottenKnowledge(This,ppLearnedForgottenKnowledge) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncFullEnumerationChange_INTERFACE_DEFINED__ */


#ifndef __IDataRetrieverCallback_INTERFACE_DEFINED__
#define __IDataRetrieverCallback_INTERFACE_DEFINED__

/* interface IDataRetrieverCallback */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDataRetrieverCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71b4863b-f969-4676-bbc3-3d9fdc3fb2c7")
    IDataRetrieverCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadChangeDataComplete( 
            /* [in] */ IUnknown *pUnkData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadChangeDataError( 
            /* [in] */ HRESULT hrError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataRetrieverCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataRetrieverCallback * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataRetrieverCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataRetrieverCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadChangeDataComplete )( 
            IDataRetrieverCallback * This,
            /* [in] */ IUnknown *pUnkData);
        
        HRESULT ( STDMETHODCALLTYPE *LoadChangeDataError )( 
            IDataRetrieverCallback * This,
            /* [in] */ HRESULT hrError);
        
        END_INTERFACE
    } IDataRetrieverCallbackVtbl;

    interface IDataRetrieverCallback
    {
        CONST_VTBL struct IDataRetrieverCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataRetrieverCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDataRetrieverCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDataRetrieverCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDataRetrieverCallback_LoadChangeDataComplete(This,pUnkData)	\
    ( (This)->lpVtbl -> LoadChangeDataComplete(This,pUnkData) ) 

#define IDataRetrieverCallback_LoadChangeDataError(This,hrError)	\
    ( (This)->lpVtbl -> LoadChangeDataError(This,hrError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDataRetrieverCallback_INTERFACE_DEFINED__ */


#ifndef __ILoadChangeContext_INTERFACE_DEFINED__
#define __ILoadChangeContext_INTERFACE_DEFINED__

/* interface ILoadChangeContext */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ILoadChangeContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44a4aaca-ec39-46d5-b5c9-d633c0ee67e2")
    ILoadChangeContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSyncChange( 
            /* [out] */ ISyncChange **ppSyncChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRecoverableErrorOnChange( 
            /* [in] */ HRESULT hrError,
            /* [unique][in] */ IRecoverableErrorData *pErrorData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRecoverableErrorOnChangeUnit( 
            /* [in] */ HRESULT hrError,
            /* [in] */ ISyncChangeUnit *pChangeUnit,
            /* [unique][in] */ IRecoverableErrorData *pErrorData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILoadChangeContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILoadChangeContext * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILoadChangeContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILoadChangeContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncChange )( 
            ILoadChangeContext * This,
            /* [out] */ ISyncChange **ppSyncChange);
        
        HRESULT ( STDMETHODCALLTYPE *SetRecoverableErrorOnChange )( 
            ILoadChangeContext * This,
            /* [in] */ HRESULT hrError,
            /* [unique][in] */ IRecoverableErrorData *pErrorData);
        
        HRESULT ( STDMETHODCALLTYPE *SetRecoverableErrorOnChangeUnit )( 
            ILoadChangeContext * This,
            /* [in] */ HRESULT hrError,
            /* [in] */ ISyncChangeUnit *pChangeUnit,
            /* [unique][in] */ IRecoverableErrorData *pErrorData);
        
        END_INTERFACE
    } ILoadChangeContextVtbl;

    interface ILoadChangeContext
    {
        CONST_VTBL struct ILoadChangeContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILoadChangeContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILoadChangeContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILoadChangeContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILoadChangeContext_GetSyncChange(This,ppSyncChange)	\
    ( (This)->lpVtbl -> GetSyncChange(This,ppSyncChange) ) 

#define ILoadChangeContext_SetRecoverableErrorOnChange(This,hrError,pErrorData)	\
    ( (This)->lpVtbl -> SetRecoverableErrorOnChange(This,hrError,pErrorData) ) 

#define ILoadChangeContext_SetRecoverableErrorOnChangeUnit(This,hrError,pChangeUnit,pErrorData)	\
    ( (This)->lpVtbl -> SetRecoverableErrorOnChangeUnit(This,hrError,pChangeUnit,pErrorData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILoadChangeContext_INTERFACE_DEFINED__ */


#ifndef __ISynchronousDataRetriever_INTERFACE_DEFINED__
#define __ISynchronousDataRetriever_INTERFACE_DEFINED__

/* interface ISynchronousDataRetriever */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISynchronousDataRetriever;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9b22f2a9-a4cd-4648-9d8e-3a510d4da04b")
    ISynchronousDataRetriever : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIdParameters( 
            /* [out] */ ID_PARAMETERS *pIdParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadChangeData( 
            /* [in] */ ILoadChangeContext *pLoadChangeContext,
            /* [out] */ IUnknown **ppUnkData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISynchronousDataRetrieverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISynchronousDataRetriever * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISynchronousDataRetriever * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISynchronousDataRetriever * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdParameters )( 
            ISynchronousDataRetriever * This,
            /* [out] */ ID_PARAMETERS *pIdParameters);
        
        HRESULT ( STDMETHODCALLTYPE *LoadChangeData )( 
            ISynchronousDataRetriever * This,
            /* [in] */ ILoadChangeContext *pLoadChangeContext,
            /* [out] */ IUnknown **ppUnkData);
        
        END_INTERFACE
    } ISynchronousDataRetrieverVtbl;

    interface ISynchronousDataRetriever
    {
        CONST_VTBL struct ISynchronousDataRetrieverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISynchronousDataRetriever_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISynchronousDataRetriever_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISynchronousDataRetriever_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISynchronousDataRetriever_GetIdParameters(This,pIdParameters)	\
    ( (This)->lpVtbl -> GetIdParameters(This,pIdParameters) ) 

#define ISynchronousDataRetriever_LoadChangeData(This,pLoadChangeContext,ppUnkData)	\
    ( (This)->lpVtbl -> LoadChangeData(This,pLoadChangeContext,ppUnkData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISynchronousDataRetriever_INTERFACE_DEFINED__ */


#ifndef __IAsynchronousDataRetriever_INTERFACE_DEFINED__
#define __IAsynchronousDataRetriever_INTERFACE_DEFINED__

/* interface IAsynchronousDataRetriever */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAsynchronousDataRetriever;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9fc7e470-61ea-4a88-9be4-df56a27cfef2")
    IAsynchronousDataRetriever : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIdParameters( 
            /* [out] */ ID_PARAMETERS *pIdParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterCallback( 
            /* [in] */ IDataRetrieverCallback *pDataRetrieverCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevokeCallback( 
            /* [in] */ IDataRetrieverCallback *pDataRetrieverCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadChangeData( 
            /* [in] */ ILoadChangeContext *pLoadChangeContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAsynchronousDataRetrieverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAsynchronousDataRetriever * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAsynchronousDataRetriever * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAsynchronousDataRetriever * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdParameters )( 
            IAsynchronousDataRetriever * This,
            /* [out] */ ID_PARAMETERS *pIdParameters);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterCallback )( 
            IAsynchronousDataRetriever * This,
            /* [in] */ IDataRetrieverCallback *pDataRetrieverCallback);
        
        HRESULT ( STDMETHODCALLTYPE *RevokeCallback )( 
            IAsynchronousDataRetriever * This,
            /* [in] */ IDataRetrieverCallback *pDataRetrieverCallback);
        
        HRESULT ( STDMETHODCALLTYPE *LoadChangeData )( 
            IAsynchronousDataRetriever * This,
            /* [in] */ ILoadChangeContext *pLoadChangeContext);
        
        END_INTERFACE
    } IAsynchronousDataRetrieverVtbl;

    interface IAsynchronousDataRetriever
    {
        CONST_VTBL struct IAsynchronousDataRetrieverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAsynchronousDataRetriever_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAsynchronousDataRetriever_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAsynchronousDataRetriever_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAsynchronousDataRetriever_GetIdParameters(This,pIdParameters)	\
    ( (This)->lpVtbl -> GetIdParameters(This,pIdParameters) ) 

#define IAsynchronousDataRetriever_RegisterCallback(This,pDataRetrieverCallback)	\
    ( (This)->lpVtbl -> RegisterCallback(This,pDataRetrieverCallback) ) 

#define IAsynchronousDataRetriever_RevokeCallback(This,pDataRetrieverCallback)	\
    ( (This)->lpVtbl -> RevokeCallback(This,pDataRetrieverCallback) ) 

#define IAsynchronousDataRetriever_LoadChangeData(This,pLoadChangeContext)	\
    ( (This)->lpVtbl -> LoadChangeData(This,pLoadChangeContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAsynchronousDataRetriever_INTERFACE_DEFINED__ */


#ifndef __IFilterRequestCallback_INTERFACE_DEFINED__
#define __IFilterRequestCallback_INTERFACE_DEFINED__

/* interface IFilterRequestCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFilterRequestCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("82df8873-6360-463a-a8a1-ede5e1a1594d")
    IFilterRequestCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestFilter( 
            /* [in] */ __RPC__in_opt IUnknown *pFilter,
            /* [in] */ FILTERING_TYPE filteringType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterRequestCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFilterRequestCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFilterRequestCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFilterRequestCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestFilter )( 
            __RPC__in IFilterRequestCallback * This,
            /* [in] */ __RPC__in_opt IUnknown *pFilter,
            /* [in] */ FILTERING_TYPE filteringType);
        
        END_INTERFACE
    } IFilterRequestCallbackVtbl;

    interface IFilterRequestCallback
    {
        CONST_VTBL struct IFilterRequestCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterRequestCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFilterRequestCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFilterRequestCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFilterRequestCallback_RequestFilter(This,pFilter,filteringType)	\
    ( (This)->lpVtbl -> RequestFilter(This,pFilter,filteringType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFilterRequestCallback_INTERFACE_DEFINED__ */


#ifndef __IRequestFilteredSync_INTERFACE_DEFINED__
#define __IRequestFilteredSync_INTERFACE_DEFINED__

/* interface IRequestFilteredSync */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRequestFilteredSync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e020184-6d18-46a7-a32a-da4aeb06696c")
    IRequestFilteredSync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SpecifyFilter( 
            /* [in] */ __RPC__in_opt IFilterRequestCallback *pCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestFilteredSyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRequestFilteredSync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRequestFilteredSync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRequestFilteredSync * This);
        
        HRESULT ( STDMETHODCALLTYPE *SpecifyFilter )( 
            __RPC__in IRequestFilteredSync * This,
            /* [in] */ __RPC__in_opt IFilterRequestCallback *pCallback);
        
        END_INTERFACE
    } IRequestFilteredSyncVtbl;

    interface IRequestFilteredSync
    {
        CONST_VTBL struct IRequestFilteredSyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequestFilteredSync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRequestFilteredSync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRequestFilteredSync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRequestFilteredSync_SpecifyFilter(This,pCallback)	\
    ( (This)->lpVtbl -> SpecifyFilter(This,pCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRequestFilteredSync_INTERFACE_DEFINED__ */


#ifndef __ISupportFilteredSync_INTERFACE_DEFINED__
#define __ISupportFilteredSync_INTERFACE_DEFINED__

/* interface ISupportFilteredSync */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISupportFilteredSync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d128ded-d555-4e0d-bf4b-fb213a8a9302")
    ISupportFilteredSync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddFilter( 
            /* [in] */ __RPC__in_opt IUnknown *pFilter,
            /* [in] */ FILTERING_TYPE filteringType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISupportFilteredSyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISupportFilteredSync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISupportFilteredSync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISupportFilteredSync * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilter )( 
            __RPC__in ISupportFilteredSync * This,
            /* [in] */ __RPC__in_opt IUnknown *pFilter,
            /* [in] */ FILTERING_TYPE filteringType);
        
        END_INTERFACE
    } ISupportFilteredSyncVtbl;

    interface ISupportFilteredSync
    {
        CONST_VTBL struct ISupportFilteredSyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISupportFilteredSync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISupportFilteredSync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISupportFilteredSync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISupportFilteredSync_AddFilter(This,pFilter,filteringType)	\
    ( (This)->lpVtbl -> AddFilter(This,pFilter,filteringType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISupportFilteredSync_INTERFACE_DEFINED__ */


#ifndef __ISupportLastWriteTime_INTERFACE_DEFINED__
#define __ISupportLastWriteTime_INTERFACE_DEFINED__

/* interface ISupportLastWriteTime */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISupportLastWriteTime;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eadf816f-d0bd-43ca-8f40-5acdc6c06f7a")
    ISupportLastWriteTime : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetItemChangeTime( 
            /* [in] */ const BYTE *pbItemId,
            /* [out] */ ULONGLONG *pullTimestamp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeUnitChangeTime( 
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [out] */ ULONGLONG *pullTimestamp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISupportLastWriteTimeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISupportLastWriteTime * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISupportLastWriteTime * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISupportLastWriteTime * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemChangeTime )( 
            ISupportLastWriteTime * This,
            /* [in] */ const BYTE *pbItemId,
            /* [out] */ ULONGLONG *pullTimestamp);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeUnitChangeTime )( 
            ISupportLastWriteTime * This,
            /* [in] */ const BYTE *pbItemId,
            /* [in] */ const BYTE *pbChangeUnitId,
            /* [out] */ ULONGLONG *pullTimestamp);
        
        END_INTERFACE
    } ISupportLastWriteTimeVtbl;

    interface ISupportLastWriteTime
    {
        CONST_VTBL struct ISupportLastWriteTimeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISupportLastWriteTime_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISupportLastWriteTime_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISupportLastWriteTime_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISupportLastWriteTime_GetItemChangeTime(This,pbItemId,pullTimestamp)	\
    ( (This)->lpVtbl -> GetItemChangeTime(This,pbItemId,pullTimestamp) ) 

#define ISupportLastWriteTime_GetChangeUnitChangeTime(This,pbItemId,pbChangeUnitId,pullTimestamp)	\
    ( (This)->lpVtbl -> GetChangeUnitChangeTime(This,pbItemId,pbChangeUnitId,pullTimestamp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISupportLastWriteTime_INTERFACE_DEFINED__ */


#ifndef __IProviderConverter_INTERFACE_DEFINED__
#define __IProviderConverter_INTERFACE_DEFINED__

/* interface IProviderConverter */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IProviderConverter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("809b7276-98cf-4957-93a5-0ebdd3dddffd")
    IProviderConverter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISyncProvider *pISyncProvider) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProviderConverterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProviderConverter * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProviderConverter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProviderConverter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IProviderConverter * This,
            /* [in] */ ISyncProvider *pISyncProvider);
        
        END_INTERFACE
    } IProviderConverterVtbl;

    interface IProviderConverter
    {
        CONST_VTBL struct IProviderConverterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProviderConverter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProviderConverter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProviderConverter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProviderConverter_Initialize(This,pISyncProvider)	\
    ( (This)->lpVtbl -> Initialize(This,pISyncProvider) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProviderConverter_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WinUser.h ===
/****************************************************************************
*                                                                           *
* winuser.h -- USER procedure declarations, constant definitions and macros *
*                                                                           *
* Copyright (c) Microsoft Corporation. All rights reserved.                 *
*                                                                           *
****************************************************************************/



#ifndef _WINUSER_
#define _WINUSER_



#pragma once

//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_USER32_)
#define WINUSERAPI DECLSPEC_IMPORT
#define WINABLEAPI DECLSPEC_IMPORT
#else
#define WINUSERAPI
#define WINABLEAPI
#endif

#ifdef _MAC
#include <macwin32.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifndef WINVER
#define WINVER  0x0500      /* version 5.0 */
#endif /* !WINVER */

#include <stdarg.h>

#ifndef NOUSER

typedef HANDLE HDWP;
typedef VOID MENUTEMPLATEA;
typedef VOID MENUTEMPLATEW;
#ifdef UNICODE
typedef MENUTEMPLATEW MENUTEMPLATE;
#else
typedef MENUTEMPLATEA MENUTEMPLATE;
#endif // UNICODE
typedef PVOID LPMENUTEMPLATEA;
typedef PVOID LPMENUTEMPLATEW;
#ifdef UNICODE
typedef LPMENUTEMPLATEW LPMENUTEMPLATE;
#else
typedef LPMENUTEMPLATEA LPMENUTEMPLATE;
#endif // UNICODE

typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT

typedef INT_PTR (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
typedef VOID (CALLBACK* TIMERPROC)(HWND, UINT, UINT_PTR, DWORD);
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
typedef VOID (CALLBACK* SENDASYNCPROC)(HWND, UINT, ULONG_PTR, LRESULT);

typedef BOOL (CALLBACK* PROPENUMPROCA)(HWND, LPCSTR, HANDLE);
typedef BOOL (CALLBACK* PROPENUMPROCW)(HWND, LPCWSTR, HANDLE);

typedef BOOL (CALLBACK* PROPENUMPROCEXA)(HWND, LPSTR, HANDLE, ULONG_PTR);
typedef BOOL (CALLBACK* PROPENUMPROCEXW)(HWND, LPWSTR, HANDLE, ULONG_PTR);

typedef int (CALLBACK* EDITWORDBREAKPROCA)(LPSTR lpch, int ichCurrent, int cch, int code);
typedef int (CALLBACK* EDITWORDBREAKPROCW)(LPWSTR lpch, int ichCurrent, int cch, int code);

#if(WINVER >= 0x0400)
typedef BOOL (CALLBACK* DRAWSTATEPROC)(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy);
#endif /* WINVER >= 0x0400 */


#else /* !STRICT */

typedef FARPROC DLGPROC;
typedef FARPROC TIMERPROC;
typedef FARPROC GRAYSTRINGPROC;
typedef FARPROC WNDENUMPROC;
typedef FARPROC HOOKPROC;
typedef FARPROC SENDASYNCPROC;

typedef FARPROC EDITWORDBREAKPROCA;
typedef FARPROC EDITWORDBREAKPROCW;

typedef FARPROC PROPENUMPROCA;
typedef FARPROC PROPENUMPROCW;

typedef FARPROC PROPENUMPROCEXA;
typedef FARPROC PROPENUMPROCEXW;

#if(WINVER >= 0x0400)
typedef FARPROC DRAWSTATEPROC;
#endif /* WINVER >= 0x0400 */


#endif /* !STRICT */

#ifdef UNICODE
typedef PROPENUMPROCW        PROPENUMPROC;
typedef PROPENUMPROCEXW      PROPENUMPROCEX;
typedef EDITWORDBREAKPROCW   EDITWORDBREAKPROC;
#else  /* !UNICODE */
typedef PROPENUMPROCA        PROPENUMPROC;
typedef PROPENUMPROCEXA      PROPENUMPROCEX;
typedef EDITWORDBREAKPROCA   EDITWORDBREAKPROC;
#endif /* UNICODE */

#ifdef STRICT

typedef BOOL (CALLBACK* NAMEENUMPROCA)(LPSTR, LPARAM);
typedef BOOL (CALLBACK* NAMEENUMPROCW)(LPWSTR, LPARAM);

typedef NAMEENUMPROCA   WINSTAENUMPROCA;
typedef NAMEENUMPROCA   DESKTOPENUMPROCA;
typedef NAMEENUMPROCW   WINSTAENUMPROCW;
typedef NAMEENUMPROCW   DESKTOPENUMPROCW;


#else /* !STRICT */

typedef FARPROC NAMEENUMPROCA;
typedef FARPROC NAMEENUMPROCW;
typedef FARPROC WINSTAENUMPROCA;
typedef FARPROC DESKTOPENUMPROCA;
typedef FARPROC WINSTAENUMPROCW;
typedef FARPROC DESKTOPENUMPROCW;


#endif /* !STRICT */

#ifdef UNICODE
typedef WINSTAENUMPROCW     WINSTAENUMPROC;
typedef DESKTOPENUMPROCW    DESKTOPENUMPROC;


#else  /* !UNICODE */
typedef WINSTAENUMPROCA     WINSTAENUMPROC;
typedef DESKTOPENUMPROCA    DESKTOPENUMPROC;

#endif /* UNICODE */

#define IS_INTRESOURCE(_r) ((((ULONG_PTR)(_r)) >> 16) == 0)
#define MAKEINTRESOURCEA(i) ((LPSTR)((ULONG_PTR)((WORD)(i))))
#define MAKEINTRESOURCEW(i) ((LPWSTR)((ULONG_PTR)((WORD)(i))))
#ifdef UNICODE
#define MAKEINTRESOURCE  MAKEINTRESOURCEW
#else
#define MAKEINTRESOURCE  MAKEINTRESOURCEA
#endif // !UNICODE

#ifndef NORESOURCE

/*
 * Predefined Resource Types
 */
#define RT_CURSOR           MAKEINTRESOURCE(1)
#define RT_BITMAP           MAKEINTRESOURCE(2)
#define RT_ICON             MAKEINTRESOURCE(3)
#define RT_MENU             MAKEINTRESOURCE(4)
#define RT_DIALOG           MAKEINTRESOURCE(5)
#define RT_STRING           MAKEINTRESOURCE(6)
#define RT_FONTDIR          MAKEINTRESOURCE(7)
#define RT_FONT             MAKEINTRESOURCE(8)
#define RT_ACCELERATOR      MAKEINTRESOURCE(9)
#define RT_RCDATA           MAKEINTRESOURCE(10)
#define RT_MESSAGETABLE     MAKEINTRESOURCE(11)

#define DIFFERENCE     11
#define RT_GROUP_CURSOR MAKEINTRESOURCE((ULONG_PTR)(RT_CURSOR) + DIFFERENCE)
#define RT_GROUP_ICON   MAKEINTRESOURCE((ULONG_PTR)(RT_ICON) + DIFFERENCE)
#define RT_VERSION      MAKEINTRESOURCE(16)
#define RT_DLGINCLUDE   MAKEINTRESOURCE(17)
#if(WINVER >= 0x0400)
#define RT_PLUGPLAY     MAKEINTRESOURCE(19)
#define RT_VXD          MAKEINTRESOURCE(20)
#define RT_ANICURSOR    MAKEINTRESOURCE(21)
#define RT_ANIICON      MAKEINTRESOURCE(22)
#endif /* WINVER >= 0x0400 */
#define RT_HTML         MAKEINTRESOURCE(23)
#ifdef RC_INVOKED
#define RT_MANIFEST                        24
#define CREATEPROCESS_MANIFEST_RESOURCE_ID  1
#define ISOLATIONAWARE_MANIFEST_RESOURCE_ID 2
#define ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID 3
#define MINIMUM_RESERVED_MANIFEST_RESOURCE_ID 1   /* inclusive */
#define MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID 16  /* inclusive */
#else  /* RC_INVOKED */
#define RT_MANIFEST                        MAKEINTRESOURCE(24)
#define CREATEPROCESS_MANIFEST_RESOURCE_ID MAKEINTRESOURCE( 1)
#define ISOLATIONAWARE_MANIFEST_RESOURCE_ID MAKEINTRESOURCE(2)
#define ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID MAKEINTRESOURCE(3)
#define MINIMUM_RESERVED_MANIFEST_RESOURCE_ID MAKEINTRESOURCE( 1 /*inclusive*/)
#define MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID MAKEINTRESOURCE(16 /*inclusive*/)
#endif /* RC_INVOKED */


#endif /* !NORESOURCE */

#if defined(DEPRECATE_SUPPORTED)
#pragma warning(push)
#pragma warning(disable:4995)
#endif

WINUSERAPI
int
WINAPI
wvsprintfA(
    __out LPSTR,
    __in __format_string LPCSTR,
    __in va_list arglist);
WINUSERAPI
int
WINAPI
wvsprintfW(
    __out LPWSTR,
    __in __format_string LPCWSTR,
    __in va_list arglist);
#ifdef UNICODE
#define wvsprintf  wvsprintfW
#else
#define wvsprintf  wvsprintfA
#endif // !UNICODE

WINUSERAPI
int
WINAPIV
wsprintfA(
    __out LPSTR,
    __in __format_string LPCSTR,
    ...);
WINUSERAPI
int
WINAPIV
wsprintfW(
    __out LPWSTR,
    __in __format_string LPCWSTR,
    ...);
#ifdef UNICODE
#define wsprintf  wsprintfW
#else
#define wsprintf  wsprintfA
#endif // !UNICODE

#if defined(DEPRECATE_SUPPORTED)
#pragma warning(pop)
#endif


/*
 * SPI_SETDESKWALLPAPER defined constants
 */
#define SETWALLPAPER_DEFAULT    ((LPWSTR)-1)

#ifndef NOSCROLL

/*
 * Scroll Bar Constants
 */
#define SB_HORZ             0
#define SB_VERT             1
#define SB_CTL              2
#define SB_BOTH             3

/*
 * Scroll Bar Commands
 */
#define SB_LINEUP           0
#define SB_LINELEFT         0
#define SB_LINEDOWN         1
#define SB_LINERIGHT        1
#define SB_PAGEUP           2
#define SB_PAGELEFT         2
#define SB_PAGEDOWN         3
#define SB_PAGERIGHT        3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK       5
#define SB_TOP              6
#define SB_LEFT             6
#define SB_BOTTOM           7
#define SB_RIGHT            7
#define SB_ENDSCROLL        8

#endif /* !NOSCROLL */

#ifndef NOSHOWWINDOW


/*
 * ShowWindow() Commands
 */
#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9
#define SW_SHOWDEFAULT      10
#define SW_FORCEMINIMIZE    11
#define SW_MAX              11


/*
 * Old ShowWindow() Commands
 */
#define HIDE_WINDOW         0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

/*
 * Identifiers for the WM_SHOWWINDOW message
 */
#define SW_PARENTCLOSING    1
#define SW_OTHERZOOM        2
#define SW_PARENTOPENING    3
#define SW_OTHERUNZOOM      4


#endif /* !NOSHOWWINDOW */

#if(WINVER >= 0x0500)
/*
 * AnimateWindow() Commands
 */
#define AW_HOR_POSITIVE             0x00000001
#define AW_HOR_NEGATIVE             0x00000002
#define AW_VER_POSITIVE             0x00000004
#define AW_VER_NEGATIVE             0x00000008
#define AW_CENTER                   0x00000010
#define AW_HIDE                     0x00010000
#define AW_ACTIVATE                 0x00020000
#define AW_SLIDE                    0x00040000
#define AW_BLEND                    0x00080000

#endif /* WINVER >= 0x0500 */


/*
 * WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags
 */
#define KF_EXTENDED       0x0100
#define KF_DLGMODE        0x0800
#define KF_MENUMODE       0x1000
#define KF_ALTDOWN        0x2000
#define KF_REPEAT         0x4000
#define KF_UP             0x8000

#ifndef NOVIRTUALKEYCODES


/*
 * Virtual Keys, Standard Set
 */
#define VK_LBUTTON        0x01
#define VK_RBUTTON        0x02
#define VK_CANCEL         0x03
#define VK_MBUTTON        0x04    /* NOT contiguous with L & RBUTTON */

#if(_WIN32_WINNT >= 0x0500)
#define VK_XBUTTON1       0x05    /* NOT contiguous with L & RBUTTON */
#define VK_XBUTTON2       0x06    /* NOT contiguous with L & RBUTTON */
#endif /* _WIN32_WINNT >= 0x0500 */

/*
 * 0x07 : unassigned
 */

#define VK_BACK           0x08
#define VK_TAB            0x09

/*
 * 0x0A - 0x0B : reserved
 */

#define VK_CLEAR          0x0C
#define VK_RETURN         0x0D

#define VK_SHIFT          0x10
#define VK_CONTROL        0x11
#define VK_MENU           0x12
#define VK_PAUSE          0x13
#define VK_CAPITAL        0x14

#define VK_KANA           0x15
#define VK_HANGEUL        0x15  /* old name - should be here for compatibility */
#define VK_HANGUL         0x15
#define VK_JUNJA          0x17
#define VK_FINAL          0x18
#define VK_HANJA          0x19
#define VK_KANJI          0x19

#define VK_ESCAPE         0x1B

#define VK_CONVERT        0x1C
#define VK_NONCONVERT     0x1D
#define VK_ACCEPT         0x1E
#define VK_MODECHANGE     0x1F

#define VK_SPACE          0x20
#define VK_PRIOR          0x21
#define VK_NEXT           0x22
#define VK_END            0x23
#define VK_HOME           0x24
#define VK_LEFT           0x25
#define VK_UP             0x26
#define VK_RIGHT          0x27
#define VK_DOWN           0x28
#define VK_SELECT         0x29
#define VK_PRINT          0x2A
#define VK_EXECUTE        0x2B
#define VK_SNAPSHOT       0x2C
#define VK_INSERT         0x2D
#define VK_DELETE         0x2E
#define VK_HELP           0x2F

/*
 * VK_0 - VK_9 are the same as ASCII '0' - '9' (0x30 - 0x39)
 * 0x40 : unassigned
 * VK_A - VK_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)
 */

#define VK_LWIN           0x5B
#define VK_RWIN           0x5C
#define VK_APPS           0x5D

/*
 * 0x5E : reserved
 */

#define VK_SLEEP          0x5F

#define VK_NUMPAD0        0x60
#define VK_NUMPAD1        0x61
#define VK_NUMPAD2        0x62
#define VK_NUMPAD3        0x63
#define VK_NUMPAD4        0x64
#define VK_NUMPAD5        0x65
#define VK_NUMPAD6        0x66
#define VK_NUMPAD7        0x67
#define VK_NUMPAD8        0x68
#define VK_NUMPAD9        0x69
#define VK_MULTIPLY       0x6A
#define VK_ADD            0x6B
#define VK_SEPARATOR      0x6C
#define VK_SUBTRACT       0x6D
#define VK_DECIMAL        0x6E
#define VK_DIVIDE         0x6F
#define VK_F1             0x70
#define VK_F2             0x71
#define VK_F3             0x72
#define VK_F4             0x73
#define VK_F5             0x74
#define VK_F6             0x75
#define VK_F7             0x76
#define VK_F8             0x77
#define VK_F9             0x78
#define VK_F10            0x79
#define VK_F11            0x7A
#define VK_F12            0x7B
#define VK_F13            0x7C
#define VK_F14            0x7D
#define VK_F15            0x7E
#define VK_F16            0x7F
#define VK_F17            0x80
#define VK_F18            0x81
#define VK_F19            0x82
#define VK_F20            0x83
#define VK_F21            0x84
#define VK_F22            0x85
#define VK_F23            0x86
#define VK_F24            0x87

/*
 * 0x88 - 0x8F : unassigned
 */

#define VK_NUMLOCK        0x90
#define VK_SCROLL         0x91

/*
 * NEC PC-9800 kbd definitions
 */
#define VK_OEM_NEC_EQUAL  0x92   // '=' key on numpad

/*
 * Fujitsu/OASYS kbd definitions
 */
#define VK_OEM_FJ_JISHO   0x92   // 'Dictionary' key
#define VK_OEM_FJ_MASSHOU 0x93   // 'Unregister word' key
#define VK_OEM_FJ_TOUROKU 0x94   // 'Register word' key
#define VK_OEM_FJ_LOYA    0x95   // 'Left OYAYUBI' key
#define VK_OEM_FJ_ROYA    0x96   // 'Right OYAYUBI' key

/*
 * 0x97 - 0x9F : unassigned
 */

/*
 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
#define VK_LSHIFT         0xA0
#define VK_RSHIFT         0xA1
#define VK_LCONTROL       0xA2
#define VK_RCONTROL       0xA3
#define VK_LMENU          0xA4
#define VK_RMENU          0xA5

#if(_WIN32_WINNT >= 0x0500)
#define VK_BROWSER_BACK        0xA6
#define VK_BROWSER_FORWARD     0xA7
#define VK_BROWSER_REFRESH     0xA8
#define VK_BROWSER_STOP        0xA9
#define VK_BROWSER_SEARCH      0xAA
#define VK_BROWSER_FAVORITES   0xAB
#define VK_BROWSER_HOME        0xAC

#define VK_VOLUME_MUTE         0xAD
#define VK_VOLUME_DOWN         0xAE
#define VK_VOLUME_UP           0xAF
#define VK_MEDIA_NEXT_TRACK    0xB0
#define VK_MEDIA_PREV_TRACK    0xB1
#define VK_MEDIA_STOP          0xB2
#define VK_MEDIA_PLAY_PAUSE    0xB3
#define VK_LAUNCH_MAIL         0xB4
#define VK_LAUNCH_MEDIA_SELECT 0xB5
#define VK_LAUNCH_APP1         0xB6
#define VK_LAUNCH_APP2         0xB7

#endif /* _WIN32_WINNT >= 0x0500 */

/*
 * 0xB8 - 0xB9 : reserved
 */

#define VK_OEM_1          0xBA   // ';:' for US
#define VK_OEM_PLUS       0xBB   // '+' any country
#define VK_OEM_COMMA      0xBC   // ',' any country
#define VK_OEM_MINUS      0xBD   // '-' any country
#define VK_OEM_PERIOD     0xBE   // '.' any country
#define VK_OEM_2          0xBF   // '/?' for US
#define VK_OEM_3          0xC0   // '`~' for US

/*
 * 0xC1 - 0xD7 : reserved
 */

/*
 * 0xD8 - 0xDA : unassigned
 */

#define VK_OEM_4          0xDB  //  '[{' for US
#define VK_OEM_5          0xDC  //  '\|' for US
#define VK_OEM_6          0xDD  //  ']}' for US
#define VK_OEM_7          0xDE  //  ''"' for US
#define VK_OEM_8          0xDF

/*
 * 0xE0 : reserved
 */

/*
 * Various extended or enhanced keyboards
 */
#define VK_OEM_AX         0xE1  //  'AX' key on Japanese AX kbd
#define VK_OEM_102        0xE2  //  "<>" or "\|" on RT 102-key kbd.
#define VK_ICO_HELP       0xE3  //  Help key on ICO
#define VK_ICO_00         0xE4  //  00 key on ICO

#if(WINVER >= 0x0400)
#define VK_PROCESSKEY     0xE5
#endif /* WINVER >= 0x0400 */

#define VK_ICO_CLEAR      0xE6


#if(_WIN32_WINNT >= 0x0500)
#define VK_PACKET         0xE7
#endif /* _WIN32_WINNT >= 0x0500 */

/*
 * 0xE8 : unassigned
 */

/*
 * Nokia/Ericsson definitions
 */
#define VK_OEM_RESET      0xE9
#define VK_OEM_JUMP       0xEA
#define VK_OEM_PA1        0xEB
#define VK_OEM_PA2        0xEC
#define VK_OEM_PA3        0xED
#define VK_OEM_WSCTRL     0xEE
#define VK_OEM_CUSEL      0xEF
#define VK_OEM_ATTN       0xF0
#define VK_OEM_FINISH     0xF1
#define VK_OEM_COPY       0xF2
#define VK_OEM_AUTO       0xF3
#define VK_OEM_ENLW       0xF4
#define VK_OEM_BACKTAB    0xF5

#define VK_ATTN           0xF6
#define VK_CRSEL          0xF7
#define VK_EXSEL          0xF8
#define VK_EREOF          0xF9
#define VK_PLAY           0xFA
#define VK_ZOOM           0xFB
#define VK_NONAME         0xFC
#define VK_PA1            0xFD
#define VK_OEM_CLEAR      0xFE

/*
 * 0xFF : reserved
 */


#endif /* !NOVIRTUALKEYCODES */

#ifndef NOWH

/*
 * SetWindowsHook() codes
 */
#define WH_MIN              (-1)
#define WH_MSGFILTER        (-1)
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1
#define WH_KEYBOARD         2
#define WH_GETMESSAGE       3
#define WH_CALLWNDPROC      4
#define WH_CBT              5
#define WH_SYSMSGFILTER     6
#define WH_MOUSE            7
#if defined(_WIN32_WINDOWS)
#define WH_HARDWARE         8
#endif
#define WH_DEBUG            9
#define WH_SHELL           10
#define WH_FOREGROUNDIDLE  11
#if(WINVER >= 0x0400)
#define WH_CALLWNDPROCRET  12
#endif /* WINVER >= 0x0400 */

#if (_WIN32_WINNT >= 0x0400)
#define WH_KEYBOARD_LL     13
#define WH_MOUSE_LL        14
#endif // (_WIN32_WINNT >= 0x0400)

#if(WINVER >= 0x0400)
#if (_WIN32_WINNT >= 0x0400)
#define WH_MAX             14
#else
#define WH_MAX             12
#endif // (_WIN32_WINNT >= 0x0400)
#else
#define WH_MAX             11
#endif

#define WH_MINHOOK         WH_MIN
#define WH_MAXHOOK         WH_MAX

/*
 * Hook Codes
 */
#define HC_ACTION           0
#define HC_GETNEXT          1
#define HC_SKIP             2
#define HC_NOREMOVE         3
#define HC_NOREM            HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF      5

/*
 * CBT Hook Codes
 */
#define HCBT_MOVESIZE       0
#define HCBT_MINMAX         1
#define HCBT_QS             2
#define HCBT_CREATEWND      3
#define HCBT_DESTROYWND     4
#define HCBT_ACTIVATE       5
#define HCBT_CLICKSKIPPED   6
#define HCBT_KEYSKIPPED     7
#define HCBT_SYSCOMMAND     8
#define HCBT_SETFOCUS       9

/*
 * HCBT_CREATEWND parameters pointed to by lParam
 */
typedef struct tagCBT_CREATEWNDA
{
    struct tagCREATESTRUCTA *lpcs;
    HWND           hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;
/*
 * HCBT_CREATEWND parameters pointed to by lParam
 */
typedef struct tagCBT_CREATEWNDW
{
    struct tagCREATESTRUCTW *lpcs;
    HWND           hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;
#ifdef UNICODE
typedef CBT_CREATEWNDW CBT_CREATEWND;
typedef LPCBT_CREATEWNDW LPCBT_CREATEWND;
#else
typedef CBT_CREATEWNDA CBT_CREATEWND;
typedef LPCBT_CREATEWNDA LPCBT_CREATEWND;
#endif // UNICODE

/*
 * HCBT_ACTIVATE structure pointed to by lParam
 */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;

#if(_WIN32_WINNT >= 0x0501)
/*
 * WTSSESSION_NOTIFICATION struct pointed by lParam, for WM_WTSSESSION_CHANGE
 */
typedef struct tagWTSSESSION_NOTIFICATION
{
    DWORD cbSize;
    DWORD dwSessionId;

} WTSSESSION_NOTIFICATION, *PWTSSESSION_NOTIFICATION;

/*
 * codes passed in WPARAM for WM_WTSSESSION_CHANGE
 */

#define WTS_CONSOLE_CONNECT                0x1
#define WTS_CONSOLE_DISCONNECT             0x2
#define WTS_REMOTE_CONNECT                 0x3
#define WTS_REMOTE_DISCONNECT              0x4
#define WTS_SESSION_LOGON                  0x5
#define WTS_SESSION_LOGOFF                 0x6
#define WTS_SESSION_LOCK                   0x7
#define WTS_SESSION_UNLOCK                 0x8
#define WTS_SESSION_REMOTE_CONTROL         0x9

#endif /* _WIN32_WINNT >= 0x0501 */

/*
 * WH_MSGFILTER Filter Proc Codes
 */
#define MSGF_DIALOGBOX      0
#define MSGF_MESSAGEBOX     1
#define MSGF_MENU           2
#define MSGF_SCROLLBAR      5
#define MSGF_NEXTWINDOW     6
#define MSGF_MAX            8                       // unused
#define MSGF_USER           4096

/*
 * Shell support
 */
#define HSHELL_WINDOWCREATED        1
#define HSHELL_WINDOWDESTROYED      2
#define HSHELL_ACTIVATESHELLWINDOW  3

#if(WINVER >= 0x0400)
#define HSHELL_WINDOWACTIVATED      4
#define HSHELL_GETMINRECT           5
#define HSHELL_REDRAW               6
#define HSHELL_TASKMAN              7
#define HSHELL_LANGUAGE             8
#define HSHELL_SYSMENU              9
#define HSHELL_ENDTASK              10
#endif /* WINVER >= 0x0400 */
#if(_WIN32_WINNT >= 0x0500)
#define HSHELL_ACCESSIBILITYSTATE   11
#define HSHELL_APPCOMMAND           12
#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0501)
#define HSHELL_WINDOWREPLACED       13
#define HSHELL_WINDOWREPLACING      14
#endif /* _WIN32_WINNT >= 0x0501 */


#define HSHELL_HIGHBIT            0x8000
#define HSHELL_FLASH              (HSHELL_REDRAW|HSHELL_HIGHBIT)
#define HSHELL_RUDEAPPACTIVATED   (HSHELL_WINDOWACTIVATED|HSHELL_HIGHBIT)

#if(_WIN32_WINNT >= 0x0500)
/* cmd for HSHELL_APPCOMMAND and WM_APPCOMMAND */
#define APPCOMMAND_BROWSER_BACKWARD       1
#define APPCOMMAND_BROWSER_FORWARD        2
#define APPCOMMAND_BROWSER_REFRESH        3
#define APPCOMMAND_BROWSER_STOP           4
#define APPCOMMAND_BROWSER_SEARCH         5
#define APPCOMMAND_BROWSER_FAVORITES      6
#define APPCOMMAND_BROWSER_HOME           7
#define APPCOMMAND_VOLUME_MUTE            8
#define APPCOMMAND_VOLUME_DOWN            9
#define APPCOMMAND_VOLUME_UP              10
#define APPCOMMAND_MEDIA_NEXTTRACK        11
#define APPCOMMAND_MEDIA_PREVIOUSTRACK    12
#define APPCOMMAND_MEDIA_STOP             13
#define APPCOMMAND_MEDIA_PLAY_PAUSE       14
#define APPCOMMAND_LAUNCH_MAIL            15
#define APPCOMMAND_LAUNCH_MEDIA_SELECT    16
#define APPCOMMAND_LAUNCH_APP1            17
#define APPCOMMAND_LAUNCH_APP2            18
#define APPCOMMAND_BASS_DOWN              19
#define APPCOMMAND_BASS_BOOST             20
#define APPCOMMAND_BASS_UP                21
#define APPCOMMAND_TREBLE_DOWN            22
#define APPCOMMAND_TREBLE_UP              23
#if(_WIN32_WINNT >= 0x0501)
#define APPCOMMAND_MICROPHONE_VOLUME_MUTE 24
#define APPCOMMAND_MICROPHONE_VOLUME_DOWN 25
#define APPCOMMAND_MICROPHONE_VOLUME_UP   26
#define APPCOMMAND_HELP                   27
#define APPCOMMAND_FIND                   28
#define APPCOMMAND_NEW                    29
#define APPCOMMAND_OPEN                   30
#define APPCOMMAND_CLOSE                  31
#define APPCOMMAND_SAVE                   32
#define APPCOMMAND_PRINT                  33
#define APPCOMMAND_UNDO                   34
#define APPCOMMAND_REDO                   35
#define APPCOMMAND_COPY                   36
#define APPCOMMAND_CUT                    37
#define APPCOMMAND_PASTE                  38
#define APPCOMMAND_REPLY_TO_MAIL          39
#define APPCOMMAND_FORWARD_MAIL           40
#define APPCOMMAND_SEND_MAIL              41
#define APPCOMMAND_SPELL_CHECK            42
#define APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE    43
#define APPCOMMAND_MIC_ON_OFF_TOGGLE      44
#define APPCOMMAND_CORRECTION_LIST        45
#define APPCOMMAND_MEDIA_PLAY             46
#define APPCOMMAND_MEDIA_PAUSE            47
#define APPCOMMAND_MEDIA_RECORD           48
#define APPCOMMAND_MEDIA_FAST_FORWARD     49
#define APPCOMMAND_MEDIA_REWIND           50
#define APPCOMMAND_MEDIA_CHANNEL_UP       51
#define APPCOMMAND_MEDIA_CHANNEL_DOWN     52
#endif /* _WIN32_WINNT >= 0x0501 */
#if(_WIN32_WINNT >= 0x0600)
#define APPCOMMAND_DELETE                 53
#define APPCOMMAND_DWM_FLIP3D             54
#endif /* _WIN32_WINNT >= 0x0600 */

#define FAPPCOMMAND_MOUSE 0x8000
#define FAPPCOMMAND_KEY   0
#define FAPPCOMMAND_OEM   0x1000
#define FAPPCOMMAND_MASK  0xF000

#define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))
#define GET_DEVICE_LPARAM(lParam)     ((WORD)(HIWORD(lParam) & FAPPCOMMAND_MASK))
#define GET_MOUSEORKEY_LPARAM         GET_DEVICE_LPARAM
#define GET_FLAGS_LPARAM(lParam)      (LOWORD(lParam))
#define GET_KEYSTATE_LPARAM(lParam)   GET_FLAGS_LPARAM(lParam)
#endif /* _WIN32_WINNT >= 0x0500 */

typedef struct
{
    HWND    hwnd;
    RECT    rc;
} SHELLHOOKINFO, *LPSHELLHOOKINFO;

/*
 * Message Structure used in Journaling
 */
typedef struct tagEVENTMSG {
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD    time;
    HWND     hwnd;
} EVENTMSG, *PEVENTMSGMSG, NEAR *NPEVENTMSGMSG, FAR *LPEVENTMSGMSG;

typedef struct tagEVENTMSG *PEVENTMSG, NEAR *NPEVENTMSG, FAR *LPEVENTMSG;

/*
 * Message structure used by WH_CALLWNDPROC
 */
typedef struct tagCWPSTRUCT {
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPSTRUCT, *PCWPSTRUCT, NEAR *NPCWPSTRUCT, FAR *LPCWPSTRUCT;

#if(WINVER >= 0x0400)
/*
 * Message structure used by WH_CALLWNDPROCRET
 */
typedef struct tagCWPRETSTRUCT {
    LRESULT lResult;
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPRETSTRUCT, *PCWPRETSTRUCT, NEAR *NPCWPRETSTRUCT, FAR *LPCWPRETSTRUCT;

#endif /* WINVER >= 0x0400 */

#if (_WIN32_WINNT >= 0x0400)

/*
 * Low level hook flags
 */

#define LLKHF_EXTENDED       (KF_EXTENDED >> 8)
#define LLKHF_INJECTED       0x00000010
#define LLKHF_ALTDOWN        (KF_ALTDOWN >> 8)
#define LLKHF_UP             (KF_UP >> 8)

#define LLMHF_INJECTED       0x00000001

/*
 * Structure used by WH_KEYBOARD_LL
 */
typedef struct tagKBDLLHOOKSTRUCT {
    DWORD   vkCode;
    DWORD   scanCode;
    DWORD   flags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} KBDLLHOOKSTRUCT, FAR *LPKBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;

/*
 * Structure used by WH_MOUSE_LL
 */
typedef struct tagMSLLHOOKSTRUCT {
    POINT   pt;
    DWORD   mouseData;
    DWORD   flags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT, FAR *LPMSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;

#endif // (_WIN32_WINNT >= 0x0400)

/*
 * Structure used by WH_DEBUG
 */
typedef struct tagDEBUGHOOKINFO
{
    DWORD   idThread;
    DWORD   idThreadInstaller;
    LPARAM  lParam;
    WPARAM  wParam;
    int     code;
} DEBUGHOOKINFO, *PDEBUGHOOKINFO, NEAR *NPDEBUGHOOKINFO, FAR* LPDEBUGHOOKINFO;

/*
 * Structure used by WH_MOUSE
 */
typedef struct tagMOUSEHOOKSTRUCT {
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    ULONG_PTR dwExtraInfo;
} MOUSEHOOKSTRUCT, FAR *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT;

#if(_WIN32_WINNT >= 0x0500)
#ifdef __cplusplus
typedef struct tagMOUSEHOOKSTRUCTEX : public tagMOUSEHOOKSTRUCT
{
    DWORD   mouseData;
} MOUSEHOOKSTRUCTEX, *LPMOUSEHOOKSTRUCTEX, *PMOUSEHOOKSTRUCTEX;
#else // ndef __cplusplus
typedef struct tagMOUSEHOOKSTRUCTEX
{
    MOUSEHOOKSTRUCT;
    DWORD   mouseData;
} MOUSEHOOKSTRUCTEX, *LPMOUSEHOOKSTRUCTEX, *PMOUSEHOOKSTRUCTEX;
#endif
#endif /* _WIN32_WINNT >= 0x0500 */

#if(WINVER >= 0x0400)
/*
 * Structure used by WH_HARDWARE
 */
typedef struct tagHARDWAREHOOKSTRUCT {
    HWND    hwnd;
    UINT    message;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT, FAR *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;
#endif /* WINVER >= 0x0400 */
#endif /* !NOWH */

/*
 * Keyboard Layout API
 */
#define HKL_PREV            0
#define HKL_NEXT            1


#define KLF_ACTIVATE        0x00000001
#define KLF_SUBSTITUTE_OK   0x00000002
#define KLF_REORDER         0x00000008
#if(WINVER >= 0x0400)
#define KLF_REPLACELANG     0x00000010
#define KLF_NOTELLSHELL     0x00000080
#endif /* WINVER >= 0x0400 */
#define KLF_SETFORPROCESS   0x00000100
#if(_WIN32_WINNT >= 0x0500)
#define KLF_SHIFTLOCK       0x00010000
#define KLF_RESET           0x40000000
#endif /* _WIN32_WINNT >= 0x0500 */


#if(WINVER >= 0x0500)
/*
 * Bits in wParam of WM_INPUTLANGCHANGEREQUEST message
 */
#define INPUTLANGCHANGE_SYSCHARSET 0x0001
#define INPUTLANGCHANGE_FORWARD    0x0002
#define INPUTLANGCHANGE_BACKWARD   0x0004
#endif /* WINVER >= 0x0500 */

/*
 * Size of KeyboardLayoutName (number of characters), including nul terminator
 */
#define KL_NAMELENGTH 9

WINUSERAPI
HKL
WINAPI
LoadKeyboardLayoutA(
    __in LPCSTR pwszKLID,
    __in UINT Flags);
WINUSERAPI
HKL
WINAPI
LoadKeyboardLayoutW(
    __in LPCWSTR pwszKLID,
    __in UINT Flags);
#ifdef UNICODE
#define LoadKeyboardLayout  LoadKeyboardLayoutW
#else
#define LoadKeyboardLayout  LoadKeyboardLayoutA
#endif // !UNICODE


#if(WINVER >= 0x0400)
WINUSERAPI
HKL
WINAPI
ActivateKeyboardLayout(
    __in HKL hkl,
    __in UINT Flags);
#else
WINUSERAPI
BOOL
WINAPI
ActivateKeyboardLayout(
    __in HKL hkl,
    __in UINT Flags);
#endif /* WINVER >= 0x0400 */

#if(WINVER >= 0x0400)
WINUSERAPI
int
WINAPI
ToUnicodeEx(
    __in UINT wVirtKey,
    __in UINT wScanCode,
    __in_bcount(256) CONST BYTE *lpKeyState,
    __out_ecount(cchBuff) LPWSTR pwszBuff,
    __in int cchBuff,
    __in UINT wFlags,
    __in_opt HKL dwhkl);
#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
UnloadKeyboardLayout(
    __in HKL hkl);

WINUSERAPI
BOOL
WINAPI
GetKeyboardLayoutNameA(
    __out_ecount(KL_NAMELENGTH) LPSTR pwszKLID);
WINUSERAPI
BOOL
WINAPI
GetKeyboardLayoutNameW(
    __out_ecount(KL_NAMELENGTH) LPWSTR pwszKLID);
#ifdef UNICODE
#define GetKeyboardLayoutName  GetKeyboardLayoutNameW
#else
#define GetKeyboardLayoutName  GetKeyboardLayoutNameA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI
int
WINAPI
GetKeyboardLayoutList(
    __in int nBuff,
    __out_ecount_part_opt(nBuff, return) HKL FAR *lpList);

WINUSERAPI
HKL
WINAPI
GetKeyboardLayout(
    __in DWORD idThread);

#endif /* WINVER >= 0x0400 */


#if(WINVER >= 0x0500)

typedef struct tagMOUSEMOVEPOINT {
    int   x;
    int   y;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MOUSEMOVEPOINT, *PMOUSEMOVEPOINT, FAR* LPMOUSEMOVEPOINT;

/*
 * Values for resolution parameter of GetMouseMovePointsEx
 */
#define GMMP_USE_DISPLAY_POINTS          1
#define GMMP_USE_HIGH_RESOLUTION_POINTS  2

WINUSERAPI
int
WINAPI
GetMouseMovePointsEx(
    __in UINT cbSize,
    __in LPMOUSEMOVEPOINT lppt,
    __out_ecount(nBufPoints) LPMOUSEMOVEPOINT lpptBuf,
    __in int nBufPoints,
    __in DWORD resolution);

#endif /* WINVER >= 0x0500 */

#ifndef NODESKTOP
/*
 * Desktop-specific access flags
 */
#define DESKTOP_READOBJECTS         0x0001L
#define DESKTOP_CREATEWINDOW        0x0002L
#define DESKTOP_CREATEMENU          0x0004L
#define DESKTOP_HOOKCONTROL         0x0008L
#define DESKTOP_JOURNALRECORD       0x0010L
#define DESKTOP_JOURNALPLAYBACK     0x0020L
#define DESKTOP_ENUMERATE           0x0040L
#define DESKTOP_WRITEOBJECTS        0x0080L
#define DESKTOP_SWITCHDESKTOP       0x0100L

/*
 * Desktop-specific control flags
 */
#define DF_ALLOWOTHERACCOUNTHOOK    0x0001L

#ifdef _WINGDI_
#ifndef NOGDI

WINUSERAPI
HDESK
WINAPI
CreateDesktopA(
    __in LPCSTR lpszDesktop,
    __reserved LPCSTR lpszDevice,
    __reserved DEVMODEA* pDevmode,
    __in DWORD dwFlags,
    __in ACCESS_MASK dwDesiredAccess,
    __in_opt LPSECURITY_ATTRIBUTES lpsa);
WINUSERAPI
HDESK
WINAPI
CreateDesktopW(
    __in LPCWSTR lpszDesktop,
    __reserved LPCWSTR lpszDevice,
    __reserved DEVMODEW* pDevmode,
    __in DWORD dwFlags,
    __in ACCESS_MASK dwDesiredAccess,
    __in_opt LPSECURITY_ATTRIBUTES lpsa);
#ifdef UNICODE
#define CreateDesktop  CreateDesktopW
#else
#define CreateDesktop  CreateDesktopA
#endif // !UNICODE

WINUSERAPI
HDESK
WINAPI
CreateDesktopExA(
    __in LPCSTR lpszDesktop,
    __reserved LPCSTR lpszDevice,
    __reserved DEVMODEA* pDevmode,
    __in DWORD dwFlags,
    __in ACCESS_MASK dwDesiredAccess,
    __in_opt LPSECURITY_ATTRIBUTES lpsa,
    __in ULONG ulHeapSize,
    __reserved PVOID pvoid);
WINUSERAPI
HDESK
WINAPI
CreateDesktopExW(
    __in LPCWSTR lpszDesktop,
    __reserved LPCWSTR lpszDevice,
    __reserved DEVMODEW* pDevmode,
    __in DWORD dwFlags,
    __in ACCESS_MASK dwDesiredAccess,
    __in_opt LPSECURITY_ATTRIBUTES lpsa,
    __in ULONG ulHeapSize,
    __reserved PVOID pvoid);
#ifdef UNICODE
#define CreateDesktopEx  CreateDesktopExW
#else
#define CreateDesktopEx  CreateDesktopExA
#endif // !UNICODE

#endif /* NOGDI */
#endif /* _WINGDI_ */

WINUSERAPI
HDESK
WINAPI
OpenDesktopA(
    __in LPCSTR lpszDesktop,
    __in DWORD dwFlags,
    __in BOOL fInherit,
    __in ACCESS_MASK dwDesiredAccess);
WINUSERAPI
HDESK
WINAPI
OpenDesktopW(
    __in LPCWSTR lpszDesktop,
    __in DWORD dwFlags,
    __in BOOL fInherit,
    __in ACCESS_MASK dwDesiredAccess);
#ifdef UNICODE
#define OpenDesktop  OpenDesktopW
#else
#define OpenDesktop  OpenDesktopA
#endif // !UNICODE

WINUSERAPI
HDESK
WINAPI
OpenInputDesktop(
    __in DWORD dwFlags,
    __in BOOL fInherit,
    __in ACCESS_MASK dwDesiredAccess);


WINUSERAPI
BOOL
WINAPI
EnumDesktopsA(
    __in_opt HWINSTA hwinsta,
    __in DESKTOPENUMPROCA lpEnumFunc,
    __in LPARAM lParam);
WINUSERAPI
BOOL
WINAPI
EnumDesktopsW(
    __in_opt HWINSTA hwinsta,
    __in DESKTOPENUMPROCW lpEnumFunc,
    __in LPARAM lParam);
#ifdef UNICODE
#define EnumDesktops  EnumDesktopsW
#else
#define EnumDesktops  EnumDesktopsA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
EnumDesktopWindows(
    __in_opt HDESK hDesktop,
    __in WNDENUMPROC lpfn,
    __in LPARAM lParam);

WINUSERAPI
BOOL
WINAPI
SwitchDesktop(
    __in HDESK hDesktop);


WINUSERAPI
BOOL
WINAPI
SetThreadDesktop(
     __in HDESK hDesktop);

WINUSERAPI
BOOL
WINAPI
CloseDesktop(
    __in HDESK hDesktop);

WINUSERAPI
HDESK
WINAPI
GetThreadDesktop(
    __in DWORD dwThreadId);

#endif  /* !NODESKTOP */

#ifndef NOWINDOWSTATION
/*
 * Windowstation-specific access flags
 */
#define WINSTA_ENUMDESKTOPS         0x0001L
#define WINSTA_READATTRIBUTES       0x0002L
#define WINSTA_ACCESSCLIPBOARD      0x0004L
#define WINSTA_CREATEDESKTOP        0x0008L
#define WINSTA_WRITEATTRIBUTES      0x0010L
#define WINSTA_ACCESSGLOBALATOMS    0x0020L
#define WINSTA_EXITWINDOWS          0x0040L
#define WINSTA_ENUMERATE            0x0100L
#define WINSTA_READSCREEN           0x0200L

#define WINSTA_ALL_ACCESS           (WINSTA_ENUMDESKTOPS  | WINSTA_READATTRIBUTES  | WINSTA_ACCESSCLIPBOARD | \
                                     WINSTA_CREATEDESKTOP | WINSTA_WRITEATTRIBUTES | WINSTA_ACCESSGLOBALATOMS | \
                                     WINSTA_EXITWINDOWS   | WINSTA_ENUMERATE       | WINSTA_READSCREEN)

/*
 * Windowstation creation flags.
 */
#define CWF_CREATE_ONLY          0x00000001

/*
 * Windowstation-specific attribute flags
 */
#define WSF_VISIBLE                 0x0001L

WINUSERAPI
HWINSTA
WINAPI
CreateWindowStationA(
    __in_opt LPCSTR lpwinsta,
    __in DWORD dwFlags,
    __in ACCESS_MASK dwDesiredAccess,
    __in_opt LPSECURITY_ATTRIBUTES lpsa);
WINUSERAPI
HWINSTA
WINAPI
CreateWindowStationW(
    __in_opt LPCWSTR lpwinsta,
    __in DWORD dwFlags,
    __in ACCESS_MASK dwDesiredAccess,
    __in_opt LPSECURITY_ATTRIBUTES lpsa);
#ifdef UNICODE
#define CreateWindowStation  CreateWindowStationW
#else
#define CreateWindowStation  CreateWindowStationA
#endif // !UNICODE

WINUSERAPI
HWINSTA
WINAPI
OpenWindowStationA(
    __in LPCSTR lpszWinSta,
    __in BOOL fInherit,
    __in ACCESS_MASK dwDesiredAccess);
WINUSERAPI
HWINSTA
WINAPI
OpenWindowStationW(
    __in LPCWSTR lpszWinSta,
    __in BOOL fInherit,
    __in ACCESS_MASK dwDesiredAccess);
#ifdef UNICODE
#define OpenWindowStation  OpenWindowStationW
#else
#define OpenWindowStation  OpenWindowStationA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
EnumWindowStationsA(
    __in WINSTAENUMPROCA lpEnumFunc,
    __in LPARAM lParam);
WINUSERAPI
BOOL
WINAPI
EnumWindowStationsW(
    __in WINSTAENUMPROCW lpEnumFunc,
    __in LPARAM lParam);
#ifdef UNICODE
#define EnumWindowStations  EnumWindowStationsW
#else
#define EnumWindowStations  EnumWindowStationsA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
CloseWindowStation(
    __in HWINSTA hWinSta);

WINUSERAPI
BOOL
WINAPI
SetProcessWindowStation(
    __in HWINSTA hWinSta);

WINUSERAPI
HWINSTA
WINAPI
GetProcessWindowStation(
    VOID);
#endif  /* !NOWINDOWSTATION */

#ifndef NOSECURITY

WINUSERAPI
BOOL
WINAPI
SetUserObjectSecurity(
    __in HANDLE hObj,
    __in PSECURITY_INFORMATION pSIRequested,
    __in PSECURITY_DESCRIPTOR pSID);

WINUSERAPI
BOOL
WINAPI
GetUserObjectSecurity(
    __in HANDLE hObj,
    __in PSECURITY_INFORMATION pSIRequested,
    __out_bcount_opt(nLength) PSECURITY_DESCRIPTOR pSID,
    __in DWORD nLength,
    __out LPDWORD lpnLengthNeeded);

#define UOI_FLAGS       1
#define UOI_NAME        2
#define UOI_TYPE        3
#define UOI_USER_SID    4
#if(WINVER >= 0x0600)
#define UOI_HEAPSIZE    5
#define UOI_IO          6
#endif /* WINVER >= 0x0600 */

typedef struct tagUSEROBJECTFLAGS {
    BOOL fInherit;
    BOOL fReserved;
    DWORD dwFlags;
} USEROBJECTFLAGS, *PUSEROBJECTFLAGS;

WINUSERAPI
BOOL
WINAPI
GetUserObjectInformationA(
    __in HANDLE hObj,
    __in int nIndex,
    __out_bcount_opt(nLength) PVOID pvInfo,
    __in DWORD nLength,
    __out_opt LPDWORD lpnLengthNeeded);
WINUSERAPI
BOOL
WINAPI
GetUserObjectInformationW(
    __in HANDLE hObj,
    __in int nIndex,
    __out_bcount_opt(nLength) PVOID pvInfo,
    __in DWORD nLength,
    __out_opt LPDWORD lpnLengthNeeded);
#ifdef UNICODE
#define GetUserObjectInformation  GetUserObjectInformationW
#else
#define GetUserObjectInformation  GetUserObjectInformationA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
SetUserObjectInformationA(
    __in HANDLE hObj,
    __in int nIndex,
    __in_bcount(nLength) PVOID pvInfo,
    __in DWORD nLength);
WINUSERAPI
BOOL
WINAPI
SetUserObjectInformationW(
    __in HANDLE hObj,
    __in int nIndex,
    __in_bcount(nLength) PVOID pvInfo,
    __in DWORD nLength);
#ifdef UNICODE
#define SetUserObjectInformation  SetUserObjectInformationW
#else
#define SetUserObjectInformation  SetUserObjectInformationA
#endif // !UNICODE

#endif  /* !NOSECURITY */

#if(WINVER >= 0x0400)
typedef struct tagWNDCLASSEXA {
    UINT        cbSize;
    /* Win 3.x */
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
    /* Win 4.0 */
    HICON       hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA, NEAR *NPWNDCLASSEXA, FAR *LPWNDCLASSEXA;
typedef struct tagWNDCLASSEXW {
    UINT        cbSize;
    /* Win 3.x */
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
    /* Win 4.0 */
    HICON       hIconSm;
} WNDCLASSEXW, *PWNDCLASSEXW, NEAR *NPWNDCLASSEXW, FAR *LPWNDCLASSEXW;
#ifdef UNICODE
typedef WNDCLASSEXW WNDCLASSEX;
typedef PWNDCLASSEXW PWNDCLASSEX;
typedef NPWNDCLASSEXW NPWNDCLASSEX;
typedef LPWNDCLASSEXW LPWNDCLASSEX;
#else
typedef WNDCLASSEXA WNDCLASSEX;
typedef PWNDCLASSEXA PWNDCLASSEX;
typedef NPWNDCLASSEXA NPWNDCLASSEX;
typedef LPWNDCLASSEXA LPWNDCLASSEX;
#endif // UNICODE
#endif /* WINVER >= 0x0400 */

typedef struct tagWNDCLASSA {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASSA, *PWNDCLASSA, NEAR *NPWNDCLASSA, FAR *LPWNDCLASSA;
typedef struct tagWNDCLASSW {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
} WNDCLASSW, *PWNDCLASSW, NEAR *NPWNDCLASSW, FAR *LPWNDCLASSW;
#ifdef UNICODE
typedef WNDCLASSW WNDCLASS;
typedef PWNDCLASSW PWNDCLASS;
typedef NPWNDCLASSW NPWNDCLASS;
typedef LPWNDCLASSW LPWNDCLASS;
#else
typedef WNDCLASSA WNDCLASS;
typedef PWNDCLASSA PWNDCLASS;
typedef NPWNDCLASSA NPWNDCLASS;
typedef LPWNDCLASSA LPWNDCLASS;
#endif // UNICODE

WINUSERAPI
BOOL
WINAPI
IsHungAppWindow(
    __in HWND hwnd);


#if(WINVER >= 0x0501)
WINUSERAPI
VOID
WINAPI
DisableProcessWindowsGhosting(
    VOID);
#endif /* WINVER >= 0x0501 */


#ifndef NOMSG

/*
 * Message structure
 */
typedef struct tagMSG {
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    POINT       pt;
#ifdef _MAC
    DWORD       lPrivate;
#endif
} MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;

#define POINTSTOPOINT(pt, pts)                          \
        { (pt).x = (LONG)(SHORT)LOWORD(*(LONG*)&pts);   \
          (pt).y = (LONG)(SHORT)HIWORD(*(LONG*)&pts); }

#define POINTTOPOINTS(pt)      (MAKELONG((short)((pt).x), (short)((pt).y)))
#define MAKEWPARAM(l, h)      ((WPARAM)(DWORD)MAKELONG(l, h))
#define MAKELPARAM(l, h)      ((LPARAM)(DWORD)MAKELONG(l, h))
#define MAKELRESULT(l, h)     ((LRESULT)(DWORD)MAKELONG(l, h))


#endif /* !NOMSG */

#ifndef NOWINOFFSETS

/*
 * Window field offsets for GetWindowLong()
 */
#define GWL_WNDPROC         (-4)
#define GWL_HINSTANCE       (-6)
#define GWL_HWNDPARENT      (-8)
#define GWL_STYLE           (-16)
#define GWL_EXSTYLE         (-20)
#define GWL_USERDATA        (-21)
#define GWL_ID              (-12)

#ifdef _WIN64

#undef GWL_WNDPROC
#undef GWL_HINSTANCE
#undef GWL_HWNDPARENT
#undef GWL_USERDATA

#endif /* _WIN64 */

#define GWLP_WNDPROC        (-4)
#define GWLP_HINSTANCE      (-6)
#define GWLP_HWNDPARENT     (-8)
#define GWLP_USERDATA       (-21)
#define GWLP_ID             (-12)

/*
 * Class field offsets for GetClassLong()
 */
#define GCL_MENUNAME        (-8)
#define GCL_HBRBACKGROUND   (-10)
#define GCL_HCURSOR         (-12)
#define GCL_HICON           (-14)
#define GCL_HMODULE         (-16)
#define GCL_CBWNDEXTRA      (-18)
#define GCL_CBCLSEXTRA      (-20)
#define GCL_WNDPROC         (-24)
#define GCL_STYLE           (-26)
#define GCW_ATOM            (-32)

#if(WINVER >= 0x0400)
#define GCL_HICONSM         (-34)
#endif /* WINVER >= 0x0400 */

#ifdef _WIN64

#undef GCL_MENUNAME
#undef GCL_HBRBACKGROUND
#undef GCL_HCURSOR
#undef GCL_HICON
#undef GCL_HMODULE
#undef GCL_WNDPROC
#undef GCL_HICONSM

#endif /* _WIN64 */

#define GCLP_MENUNAME       (-8)
#define GCLP_HBRBACKGROUND  (-10)
#define GCLP_HCURSOR        (-12)
#define GCLP_HICON          (-14)
#define GCLP_HMODULE        (-16)
#define GCLP_WNDPROC        (-24)
#define GCLP_HICONSM        (-34)

#endif /* !NOWINOFFSETS */

#ifndef NOWINMESSAGES


/*
 * Window Messages
 */

#define WM_NULL                         0x0000
#define WM_CREATE                       0x0001
#define WM_DESTROY                      0x0002
#define WM_MOVE                         0x0003
#define WM_SIZE                         0x0005

#define WM_ACTIVATE                     0x0006
/*
 * WM_ACTIVATE state values
 */
#define     WA_INACTIVE     0
#define     WA_ACTIVE       1
#define     WA_CLICKACTIVE  2

#define WM_SETFOCUS                     0x0007
#define WM_KILLFOCUS                    0x0008
#define WM_ENABLE                       0x000A
#define WM_SETREDRAW                    0x000B
#define WM_SETTEXT                      0x000C
#define WM_GETTEXT                      0x000D
#define WM_GETTEXTLENGTH                0x000E
#define WM_PAINT                        0x000F
#define WM_CLOSE                        0x0010
#ifndef _WIN32_WCE
#define WM_QUERYENDSESSION              0x0011
#define WM_QUERYOPEN                    0x0013
#define WM_ENDSESSION                   0x0016
#endif
#define WM_QUIT                         0x0012
#define WM_ERASEBKGND                   0x0014
#define WM_SYSCOLORCHANGE               0x0015
#define WM_SHOWWINDOW                   0x0018
#define WM_WININICHANGE                 0x001A
#if(WINVER >= 0x0400)
#define WM_SETTINGCHANGE                WM_WININICHANGE
#endif /* WINVER >= 0x0400 */


#define WM_DEVMODECHANGE                0x001B
#define WM_ACTIVATEAPP                  0x001C
#define WM_FONTCHANGE                   0x001D
#define WM_TIMECHANGE                   0x001E
#define WM_CANCELMODE                   0x001F
#define WM_SETCURSOR                    0x0020
#define WM_MOUSEACTIVATE                0x0021
#define WM_CHILDACTIVATE                0x0022
#define WM_QUEUESYNC                    0x0023

#define WM_GETMINMAXINFO                0x0024
/*
 * Struct pointed to by WM_GETMINMAXINFO lParam
 */
typedef struct tagMINMAXINFO {
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO, *PMINMAXINFO, *LPMINMAXINFO;

#define WM_PAINTICON                    0x0026
#define WM_ICONERASEBKGND               0x0027
#define WM_NEXTDLGCTL                   0x0028
#define WM_SPOOLERSTATUS                0x002A
#define WM_DRAWITEM                     0x002B
#define WM_MEASUREITEM                  0x002C
#define WM_DELETEITEM                   0x002D
#define WM_VKEYTOITEM                   0x002E
#define WM_CHARTOITEM                   0x002F
#define WM_SETFONT                      0x0030
#define WM_GETFONT                      0x0031
#define WM_SETHOTKEY                    0x0032
#define WM_GETHOTKEY                    0x0033
#define WM_QUERYDRAGICON                0x0037
#define WM_COMPAREITEM                  0x0039
#if(WINVER >= 0x0500)
#ifndef _WIN32_WCE
#define WM_GETOBJECT                    0x003D
#endif
#endif /* WINVER >= 0x0500 */
#define WM_COMPACTING                   0x0041
#define WM_COMMNOTIFY                   0x0044  /* no longer suported */
#define WM_WINDOWPOSCHANGING            0x0046
#define WM_WINDOWPOSCHANGED             0x0047

#define WM_POWER                        0x0048
/*
 * wParam for WM_POWER window message and DRV_POWER driver notification
 */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3

#define WM_COPYDATA                     0x004A
#define WM_CANCELJOURNAL                0x004B


/*
 * lParam of WM_COPYDATA message points to...
 */
typedef struct tagCOPYDATASTRUCT {
    ULONG_PTR dwData;
    DWORD cbData;
    __field_bcount(cbData) PVOID lpData;
} COPYDATASTRUCT, *PCOPYDATASTRUCT;

#if(WINVER >= 0x0400)
typedef struct tagMDINEXTMENU
{
    HMENU   hmenuIn;
    HMENU   hmenuNext;
    HWND    hwndNext;
} MDINEXTMENU, * PMDINEXTMENU, FAR * LPMDINEXTMENU;
#endif /* WINVER >= 0x0400 */


#if(WINVER >= 0x0400)
#define WM_NOTIFY                       0x004E
#define WM_INPUTLANGCHANGEREQUEST       0x0050
#define WM_INPUTLANGCHANGE              0x0051
#define WM_TCARD                        0x0052
#define WM_HELP                         0x0053
#define WM_USERCHANGED                  0x0054
#define WM_NOTIFYFORMAT                 0x0055

#define NFR_ANSI                             1
#define NFR_UNICODE                          2
#define NF_QUERY                             3
#define NF_REQUERY                           4

#define WM_CONTEXTMENU                  0x007B
#define WM_STYLECHANGING                0x007C
#define WM_STYLECHANGED                 0x007D
#define WM_DISPLAYCHANGE                0x007E
#define WM_GETICON                      0x007F
#define WM_SETICON                      0x0080
#endif /* WINVER >= 0x0400 */

#define WM_NCCREATE                     0x0081
#define WM_NCDESTROY                    0x0082
#define WM_NCCALCSIZE                   0x0083
#define WM_NCHITTEST                    0x0084
#define WM_NCPAINT                      0x0085
#define WM_NCACTIVATE                   0x0086
#define WM_GETDLGCODE                   0x0087
#ifndef _WIN32_WCE
#define WM_SYNCPAINT                    0x0088
#endif
#define WM_NCMOUSEMOVE                  0x00A0
#define WM_NCLBUTTONDOWN                0x00A1
#define WM_NCLBUTTONUP                  0x00A2
#define WM_NCLBUTTONDBLCLK              0x00A3
#define WM_NCRBUTTONDOWN                0x00A4
#define WM_NCRBUTTONUP                  0x00A5
#define WM_NCRBUTTONDBLCLK              0x00A6
#define WM_NCMBUTTONDOWN                0x00A7
#define WM_NCMBUTTONUP                  0x00A8
#define WM_NCMBUTTONDBLCLK              0x00A9



#if(_WIN32_WINNT >= 0x0500)
#define WM_NCXBUTTONDOWN                0x00AB
#define WM_NCXBUTTONUP                  0x00AC
#define WM_NCXBUTTONDBLCLK              0x00AD
#endif /* _WIN32_WINNT >= 0x0500 */


#if(_WIN32_WINNT >= 0x0501)
#define WM_INPUT_DEVICE_CHANGE          0x00FE
#endif /* _WIN32_WINNT >= 0x0501 */

#if(_WIN32_WINNT >= 0x0501)
#define WM_INPUT                        0x00FF
#endif /* _WIN32_WINNT >= 0x0501 */

#define WM_KEYFIRST                     0x0100
#define WM_KEYDOWN                      0x0100
#define WM_KEYUP                        0x0101
#define WM_CHAR                         0x0102
#define WM_DEADCHAR                     0x0103
#define WM_SYSKEYDOWN                   0x0104
#define WM_SYSKEYUP                     0x0105
#define WM_SYSCHAR                      0x0106
#define WM_SYSDEADCHAR                  0x0107
#if(_WIN32_WINNT >= 0x0501)
#define WM_UNICHAR                      0x0109
#define WM_KEYLAST                      0x0109
#define UNICODE_NOCHAR                  0xFFFF
#else
#define WM_KEYLAST                      0x0108
#endif /* _WIN32_WINNT >= 0x0501 */

#if(WINVER >= 0x0400)
#define WM_IME_STARTCOMPOSITION         0x010D
#define WM_IME_ENDCOMPOSITION           0x010E
#define WM_IME_COMPOSITION              0x010F
#define WM_IME_KEYLAST                  0x010F
#endif /* WINVER >= 0x0400 */

#define WM_INITDIALOG                   0x0110
#define WM_COMMAND                      0x0111
#define WM_SYSCOMMAND                   0x0112
#define WM_TIMER                        0x0113
#define WM_HSCROLL                      0x0114
#define WM_VSCROLL                      0x0115
#define WM_INITMENU                     0x0116
#define WM_INITMENUPOPUP                0x0117
#if(WINVER >= 0x0601)
#define WM_GESTURE                      0x0119
#define WM_GESTURENOTIFY                0x011A
#endif /* WINVER >= 0x0601 */
#define WM_MENUSELECT                   0x011F
#define WM_MENUCHAR                     0x0120
#define WM_ENTERIDLE                    0x0121
#if(WINVER >= 0x0500)
#ifndef _WIN32_WCE
#define WM_MENURBUTTONUP                0x0122
#define WM_MENUDRAG                     0x0123
#define WM_MENUGETOBJECT                0x0124
#define WM_UNINITMENUPOPUP              0x0125
#define WM_MENUCOMMAND                  0x0126

#ifndef _WIN32_WCE
#if(_WIN32_WINNT >= 0x0500)
#define WM_CHANGEUISTATE                0x0127
#define WM_UPDATEUISTATE                0x0128
#define WM_QUERYUISTATE                 0x0129

/*
 * LOWORD(wParam) values in WM_*UISTATE*
 */
#define UIS_SET                         1
#define UIS_CLEAR                       2
#define UIS_INITIALIZE                  3

/*
 * HIWORD(wParam) values in WM_*UISTATE*
 */
#define UISF_HIDEFOCUS                  0x1
#define UISF_HIDEACCEL                  0x2
#if(_WIN32_WINNT >= 0x0501)
#define UISF_ACTIVE                     0x4
#endif /* _WIN32_WINNT >= 0x0501 */
#endif /* _WIN32_WINNT >= 0x0500 */
#endif

#endif
#endif /* WINVER >= 0x0500 */

#define WM_CTLCOLORMSGBOX               0x0132
#define WM_CTLCOLOREDIT                 0x0133
#define WM_CTLCOLORLISTBOX              0x0134
#define WM_CTLCOLORBTN                  0x0135
#define WM_CTLCOLORDLG                  0x0136
#define WM_CTLCOLORSCROLLBAR            0x0137
#define WM_CTLCOLORSTATIC               0x0138
#define MN_GETHMENU                     0x01E1

#define WM_MOUSEFIRST                   0x0200
#define WM_MOUSEMOVE                    0x0200
#define WM_LBUTTONDOWN                  0x0201
#define WM_LBUTTONUP                    0x0202
#define WM_LBUTTONDBLCLK                0x0203
#define WM_RBUTTONDOWN                  0x0204
#define WM_RBUTTONUP                    0x0205
#define WM_RBUTTONDBLCLK                0x0206
#define WM_MBUTTONDOWN                  0x0207
#define WM_MBUTTONUP                    0x0208
#define WM_MBUTTONDBLCLK                0x0209
#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
#define WM_MOUSEWHEEL                   0x020A
#endif
#if (_WIN32_WINNT >= 0x0500)
#define WM_XBUTTONDOWN                  0x020B
#define WM_XBUTTONUP                    0x020C
#define WM_XBUTTONDBLCLK                0x020D
#endif
#if (_WIN32_WINNT >= 0x0600)
#define WM_MOUSEHWHEEL                  0x020E
#endif

#if (_WIN32_WINNT >= 0x0600)
#define WM_MOUSELAST                    0x020E
#elif (_WIN32_WINNT >= 0x0500)
#define WM_MOUSELAST                    0x020D
#elif (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
#define WM_MOUSELAST                    0x020A
#else
#define WM_MOUSELAST                    0x0209
#endif /* (_WIN32_WINNT >= 0x0600) */


#if(_WIN32_WINNT >= 0x0400)
/* Value for rolling one detent */
#define WHEEL_DELTA                     120
#define GET_WHEEL_DELTA_WPARAM(wParam)  ((short)HIWORD(wParam))

/* Setting to scroll one page for SPI_GET/SETWHEELSCROLLLINES */
#define WHEEL_PAGESCROLL                (UINT_MAX)
#endif /* _WIN32_WINNT >= 0x0400 */

#if(_WIN32_WINNT >= 0x0500)
#define GET_KEYSTATE_WPARAM(wParam)     (LOWORD(wParam))
#define GET_NCHITTEST_WPARAM(wParam)    ((short)LOWORD(wParam))
#define GET_XBUTTON_WPARAM(wParam)      (HIWORD(wParam))

/* XButton values are WORD flags */
#define XBUTTON1      0x0001
#define XBUTTON2      0x0002
/* Were there to be an XBUTTON3, its value would be 0x0004 */
#endif /* _WIN32_WINNT >= 0x0500 */

#define WM_PARENTNOTIFY                 0x0210
#define WM_ENTERMENULOOP                0x0211
#define WM_EXITMENULOOP                 0x0212

#if(WINVER >= 0x0400)
#define WM_NEXTMENU                     0x0213
#define WM_SIZING                       0x0214
#define WM_CAPTURECHANGED               0x0215
#define WM_MOVING                       0x0216
#endif /* WINVER >= 0x0400 */

#if(WINVER >= 0x0400)


#define WM_POWERBROADCAST               0x0218

#ifndef _WIN32_WCE
#define PBT_APMQUERYSUSPEND             0x0000
#define PBT_APMQUERYSTANDBY             0x0001

#define PBT_APMQUERYSUSPENDFAILED       0x0002
#define PBT_APMQUERYSTANDBYFAILED       0x0003

#define PBT_APMSUSPEND                  0x0004
#define PBT_APMSTANDBY                  0x0005

#define PBT_APMRESUMECRITICAL           0x0006
#define PBT_APMRESUMESUSPEND            0x0007
#define PBT_APMRESUMESTANDBY            0x0008

#define PBTF_APMRESUMEFROMFAILURE       0x00000001

#define PBT_APMBATTERYLOW               0x0009
#define PBT_APMPOWERSTATUSCHANGE        0x000A

#define PBT_APMOEMEVENT                 0x000B


#define PBT_APMRESUMEAUTOMATIC          0x0012
#if (_WIN32_WINNT >= 0x0502)
#ifndef PBT_POWERSETTINGCHANGE
#define PBT_POWERSETTINGCHANGE          0x8013
typedef struct {
    GUID PowerSetting;
    DWORD DataLength;
    UCHAR Data[1];
} POWERBROADCAST_SETTING, *PPOWERBROADCAST_SETTING;


#endif // PBT_POWERSETTINGCHANGE

#endif // (_WIN32_WINNT >= 0x0502)
#endif

#endif /* WINVER >= 0x0400 */

#if(WINVER >= 0x0400)
#define WM_DEVICECHANGE                 0x0219
#endif /* WINVER >= 0x0400 */

#define WM_MDICREATE                    0x0220
#define WM_MDIDESTROY                   0x0221
#define WM_MDIACTIVATE                  0x0222
#define WM_MDIRESTORE                   0x0223
#define WM_MDINEXT                      0x0224
#define WM_MDIMAXIMIZE                  0x0225
#define WM_MDITILE                      0x0226
#define WM_MDICASCADE                   0x0227
#define WM_MDIICONARRANGE               0x0228
#define WM_MDIGETACTIVE                 0x0229


#define WM_MDISETMENU                   0x0230
#define WM_ENTERSIZEMOVE                0x0231
#define WM_EXITSIZEMOVE                 0x0232
#define WM_DROPFILES                    0x0233
#define WM_MDIREFRESHMENU               0x0234

#if(WINVER >= 0x0601)
#define WM_TOUCH                        0x0240
#endif /* WINVER >= 0x0601 */


#if(WINVER >= 0x0400)
#define WM_IME_SETCONTEXT               0x0281
#define WM_IME_NOTIFY                   0x0282
#define WM_IME_CONTROL                  0x0283
#define WM_IME_COMPOSITIONFULL          0x0284
#define WM_IME_SELECT                   0x0285
#define WM_IME_CHAR                     0x0286
#endif /* WINVER >= 0x0400 */
#if(WINVER >= 0x0500)
#define WM_IME_REQUEST                  0x0288
#endif /* WINVER >= 0x0500 */
#if(WINVER >= 0x0400)
#define WM_IME_KEYDOWN                  0x0290
#define WM_IME_KEYUP                    0x0291
#endif /* WINVER >= 0x0400 */

#if((_WIN32_WINNT >= 0x0400) || (WINVER >= 0x0500))
#define WM_MOUSEHOVER                   0x02A1
#define WM_MOUSELEAVE                   0x02A3
#endif
#if(WINVER >= 0x0500)
#define WM_NCMOUSEHOVER                 0x02A0
#define WM_NCMOUSELEAVE                 0x02A2
#endif /* WINVER >= 0x0500 */

#if(_WIN32_WINNT >= 0x0501)
#define WM_WTSSESSION_CHANGE            0x02B1

#define WM_TABLET_FIRST                 0x02c0
#define WM_TABLET_LAST                  0x02df
#endif /* _WIN32_WINNT >= 0x0501 */

#define WM_CUT                          0x0300
#define WM_COPY                         0x0301
#define WM_PASTE                        0x0302
#define WM_CLEAR                        0x0303
#define WM_UNDO                         0x0304
#define WM_RENDERFORMAT                 0x0305
#define WM_RENDERALLFORMATS             0x0306
#define WM_DESTROYCLIPBOARD             0x0307
#define WM_DRAWCLIPBOARD                0x0308
#define WM_PAINTCLIPBOARD               0x0309
#define WM_VSCROLLCLIPBOARD             0x030A
#define WM_SIZECLIPBOARD                0x030B
#define WM_ASKCBFORMATNAME              0x030C
#define WM_CHANGECBCHAIN                0x030D
#define WM_HSCROLLCLIPBOARD             0x030E
#define WM_QUERYNEWPALETTE              0x030F
#define WM_PALETTEISCHANGING            0x0310
#define WM_PALETTECHANGED               0x0311
#define WM_HOTKEY                       0x0312

#if(WINVER >= 0x0400)
#define WM_PRINT                        0x0317
#define WM_PRINTCLIENT                  0x0318
#endif /* WINVER >= 0x0400 */

#if(_WIN32_WINNT >= 0x0500)
#define WM_APPCOMMAND                   0x0319
#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0501)
#define WM_THEMECHANGED                 0x031A
#endif /* _WIN32_WINNT >= 0x0501 */


#if(_WIN32_WINNT >= 0x0501)
#define WM_CLIPBOARDUPDATE              0x031D
#endif /* _WIN32_WINNT >= 0x0501 */

#if(_WIN32_WINNT >= 0x0600)
#define WM_DWMCOMPOSITIONCHANGED        0x031E
#define WM_DWMNCRENDERINGCHANGED        0x031F
#define WM_DWMCOLORIZATIONCOLORCHANGED  0x0320
#define WM_DWMWINDOWMAXIMIZEDCHANGE     0x0321
#endif /* _WIN32_WINNT >= 0x0600 */

#if(_WIN32_WINNT >= 0x0601)
#define WM_DWMSENDICONICTHUMBNAIL           0x0323
#define WM_DWMSENDICONICLIVEPREVIEWBITMAP   0x0326
#endif /* _WIN32_WINNT >= 0x0601 */


#if(WINVER >= 0x0600)
#define WM_GETTITLEBARINFOEX            0x033F
#endif /* WINVER >= 0x0600 */

#if(WINVER >= 0x0400)

#define WM_HANDHELDFIRST                0x0358
#define WM_HANDHELDLAST                 0x035F

#define WM_AFXFIRST                     0x0360
#define WM_AFXLAST                      0x037F
#endif /* WINVER >= 0x0400 */

#define WM_PENWINFIRST                  0x0380
#define WM_PENWINLAST                   0x038F


#if(WINVER >= 0x0400)
#define WM_APP                          0x8000
#endif /* WINVER >= 0x0400 */


/*
 * NOTE: All Message Numbers below 0x0400 are RESERVED.
 *
 * Private Window Messages Start Here:
 */
#define WM_USER                         0x0400

#if(WINVER >= 0x0400)

/*  wParam for WM_SIZING message  */
#define WMSZ_LEFT           1
#define WMSZ_RIGHT          2
#define WMSZ_TOP            3
#define WMSZ_TOPLEFT        4
#define WMSZ_TOPRIGHT       5
#define WMSZ_BOTTOM         6
#define WMSZ_BOTTOMLEFT     7
#define WMSZ_BOTTOMRIGHT    8
#endif /* WINVER >= 0x0400 */

#ifndef NONCMESSAGES

/*
 * WM_NCHITTEST and MOUSEHOOKSTRUCT Mouse Position Codes
 */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTGROWBOX           4
#define HTSIZE              HTGROWBOX
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTMINBUTTON         8
#define HTMAXBUTTON         9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTBORDER            18
#define HTREDUCE            HTMINBUTTON
#define HTZOOM              HTMAXBUTTON
#define HTSIZEFIRST         HTLEFT
#define HTSIZELAST          HTBOTTOMRIGHT
#if(WINVER >= 0x0400)
#define HTOBJECT            19
#define HTCLOSE             20
#define HTHELP              21
#endif /* WINVER >= 0x0400 */


/*
 * SendMessageTimeout values
 */
#define SMTO_NORMAL         0x0000
#define SMTO_BLOCK          0x0001
#define SMTO_ABORTIFHUNG    0x0002
#if(WINVER >= 0x0500)
#define SMTO_NOTIMEOUTIFNOTHUNG 0x0008
#endif /* WINVER >= 0x0500 */
#if(WINVER >= 0x0600)
#define SMTO_ERRORONEXIT    0x0020
#endif /* WINVER >= 0x0600 */

#endif /* !NONCMESSAGES */

/*
 * WM_MOUSEACTIVATE Return Codes
 */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3
#define MA_NOACTIVATEANDEAT 4

/*
 * WM_SETICON / WM_GETICON Type Codes
 */
#define ICON_SMALL          0
#define ICON_BIG            1
#if(_WIN32_WINNT >= 0x0501)
#define ICON_SMALL2         2
#endif /* _WIN32_WINNT >= 0x0501 */


WINUSERAPI
UINT
WINAPI
RegisterWindowMessageA(
    __in LPCSTR lpString);
WINUSERAPI
UINT
WINAPI
RegisterWindowMessageW(
    __in LPCWSTR lpString);
#ifdef UNICODE
#define RegisterWindowMessage  RegisterWindowMessageW
#else
#define RegisterWindowMessage  RegisterWindowMessageA
#endif // !UNICODE


/*
 * WM_SIZE message wParam values
 */
#define SIZE_RESTORED       0
#define SIZE_MINIMIZED      1
#define SIZE_MAXIMIZED      2
#define SIZE_MAXSHOW        3
#define SIZE_MAXHIDE        4

/*
 * Obsolete constant names
 */
#define SIZENORMAL          SIZE_RESTORED
#define SIZEICONIC          SIZE_MINIMIZED
#define SIZEFULLSCREEN      SIZE_MAXIMIZED
#define SIZEZOOMSHOW        SIZE_MAXSHOW
#define SIZEZOOMHIDE        SIZE_MAXHIDE

/*
 * WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam
 */
typedef struct tagWINDOWPOS {
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;

/*
 * WM_NCCALCSIZE parameter structure
 */
typedef struct tagNCCALCSIZE_PARAMS {
    RECT       rgrc[3];
    PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;

/*
 * WM_NCCALCSIZE "window valid rect" return values
 */
#define WVR_ALIGNTOP        0x0010
#define WVR_ALIGNLEFT       0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT      0x0080
#define WVR_HREDRAW         0x0100
#define WVR_VREDRAW         0x0200
#define WVR_REDRAW         (WVR_HREDRAW | \
                            WVR_VREDRAW)
#define WVR_VALIDRECTS      0x0400


#ifndef NOKEYSTATES

/*
 * Key State Masks for Mouse Messages
 */
#define MK_LBUTTON          0x0001
#define MK_RBUTTON          0x0002
#define MK_SHIFT            0x0004
#define MK_CONTROL          0x0008
#define MK_MBUTTON          0x0010
#if(_WIN32_WINNT >= 0x0500)
#define MK_XBUTTON1         0x0020
#define MK_XBUTTON2         0x0040
#endif /* _WIN32_WINNT >= 0x0500 */

#endif /* !NOKEYSTATES */


#if(_WIN32_WINNT >= 0x0400)
#ifndef NOTRACKMOUSEEVENT

#define TME_HOVER       0x00000001
#define TME_LEAVE       0x00000002
#if(WINVER >= 0x0500)
#define TME_NONCLIENT   0x00000010
#endif /* WINVER >= 0x0500 */
#define TME_QUERY       0x40000000
#define TME_CANCEL      0x80000000


#define HOVER_DEFAULT   0xFFFFFFFF
#endif /* _WIN32_WINNT >= 0x0400 */

#if(_WIN32_WINNT >= 0x0400)
typedef struct tagTRACKMOUSEEVENT {
    DWORD cbSize;
    DWORD dwFlags;
    HWND  hwndTrack;
    DWORD dwHoverTime;
} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;

WINUSERAPI
BOOL
WINAPI
TrackMouseEvent(
    __inout LPTRACKMOUSEEVENT lpEventTrack);
#endif /* _WIN32_WINNT >= 0x0400 */

#if(_WIN32_WINNT >= 0x0400)

#endif /* !NOTRACKMOUSEEVENT */
#endif /* _WIN32_WINNT >= 0x0400 */


#endif /* !NOWINMESSAGES */

#ifndef NOWINSTYLES


/*
 * Window Styles
 */
#define WS_OVERLAPPED       0x00000000L
#define WS_POPUP            0x80000000L
#define WS_CHILD            0x40000000L
#define WS_MINIMIZE         0x20000000L
#define WS_VISIBLE          0x10000000L
#define WS_DISABLED         0x08000000L
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L
#define WS_MAXIMIZE         0x01000000L
#define WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
#define WS_BORDER           0x00800000L
#define WS_DLGFRAME         0x00400000L
#define WS_VSCROLL          0x00200000L
#define WS_HSCROLL          0x00100000L
#define WS_SYSMENU          0x00080000L
#define WS_THICKFRAME       0x00040000L
#define WS_GROUP            0x00020000L
#define WS_TABSTOP          0x00010000L

#define WS_MINIMIZEBOX      0x00020000L
#define WS_MAXIMIZEBOX      0x00010000L


#define WS_TILED            WS_OVERLAPPED
#define WS_ICONIC           WS_MINIMIZE
#define WS_SIZEBOX          WS_THICKFRAME
#define WS_TILEDWINDOW      WS_OVERLAPPEDWINDOW

/*
 * Common Window Styles
 */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED     | \
                             WS_CAPTION        | \
                             WS_SYSMENU        | \
                             WS_THICKFRAME     | \
                             WS_MINIMIZEBOX    | \
                             WS_MAXIMIZEBOX)

#define WS_POPUPWINDOW      (WS_POPUP          | \
                             WS_BORDER         | \
                             WS_SYSMENU)

#define WS_CHILDWINDOW      (WS_CHILD)

/*
 * Extended Window Styles
 */
#define WS_EX_DLGMODALFRAME     0x00000001L
#define WS_EX_NOPARENTNOTIFY    0x00000004L
#define WS_EX_TOPMOST           0x00000008L
#define WS_EX_ACCEPTFILES       0x00000010L
#define WS_EX_TRANSPARENT       0x00000020L
#if(WINVER >= 0x0400)
#define WS_EX_MDICHILD          0x00000040L
#define WS_EX_TOOLWINDOW        0x00000080L
#define WS_EX_WINDOWEDGE        0x00000100L
#define WS_EX_CLIENTEDGE        0x00000200L
#define WS_EX_CONTEXTHELP       0x00000400L

#endif /* WINVER >= 0x0400 */
#if(WINVER >= 0x0400)

#define WS_EX_RIGHT             0x00001000L
#define WS_EX_LEFT              0x00000000L
#define WS_EX_RTLREADING        0x00002000L
#define WS_EX_LTRREADING        0x00000000L
#define WS_EX_LEFTSCROLLBAR     0x00004000L
#define WS_EX_RIGHTSCROLLBAR    0x00000000L

#define WS_EX_CONTROLPARENT     0x00010000L
#define WS_EX_STATICEDGE        0x00020000L
#define WS_EX_APPWINDOW         0x00040000L


#define WS_EX_OVERLAPPEDWINDOW  (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)
#define WS_EX_PALETTEWINDOW     (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)

#endif /* WINVER >= 0x0400 */

#if(_WIN32_WINNT >= 0x0500)
#define WS_EX_LAYERED           0x00080000

#endif /* _WIN32_WINNT >= 0x0500 */


#if(WINVER >= 0x0500)
#define WS_EX_NOINHERITLAYOUT   0x00100000L // Disable inheritence of mirroring by children
#define WS_EX_LAYOUTRTL         0x00400000L // Right to left mirroring
#endif /* WINVER >= 0x0500 */

#if(_WIN32_WINNT >= 0x0501)
#define WS_EX_COMPOSITED        0x02000000L
#endif /* _WIN32_WINNT >= 0x0501 */
#if(_WIN32_WINNT >= 0x0500)
#define WS_EX_NOACTIVATE        0x08000000L
#endif /* _WIN32_WINNT >= 0x0500 */


/*
 * Class styles
 */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002
#define CS_DBLCLKS          0x0008
#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080
#define CS_NOCLOSE          0x0200
#define CS_SAVEBITS         0x0800
#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000
#define CS_GLOBALCLASS      0x4000

#define CS_IME              0x00010000
#if(_WIN32_WINNT >= 0x0501)
#define CS_DROPSHADOW       0x00020000
#endif /* _WIN32_WINNT >= 0x0501 */



#endif /* !NOWINSTYLES */
#if(WINVER >= 0x0400)
/* WM_PRINT flags */
#define PRF_CHECKVISIBLE    0x00000001L
#define PRF_NONCLIENT       0x00000002L
#define PRF_CLIENT          0x00000004L
#define PRF_ERASEBKGND      0x00000008L
#define PRF_CHILDREN        0x00000010L
#define PRF_OWNED           0x00000020L

/* 3D border styles */
#define BDR_RAISEDOUTER 0x0001
#define BDR_SUNKENOUTER 0x0002
#define BDR_RAISEDINNER 0x0004
#define BDR_SUNKENINNER 0x0008

#define BDR_OUTER       (BDR_RAISEDOUTER | BDR_SUNKENOUTER)
#define BDR_INNER       (BDR_RAISEDINNER | BDR_SUNKENINNER)
#define BDR_RAISED      (BDR_RAISEDOUTER | BDR_RAISEDINNER)
#define BDR_SUNKEN      (BDR_SUNKENOUTER | BDR_SUNKENINNER)


#define EDGE_RAISED     (BDR_RAISEDOUTER | BDR_RAISEDINNER)
#define EDGE_SUNKEN     (BDR_SUNKENOUTER | BDR_SUNKENINNER)
#define EDGE_ETCHED     (BDR_SUNKENOUTER | BDR_RAISEDINNER)
#define EDGE_BUMP       (BDR_RAISEDOUTER | BDR_SUNKENINNER)

/* Border flags */
#define BF_LEFT         0x0001
#define BF_TOP          0x0002
#define BF_RIGHT        0x0004
#define BF_BOTTOM       0x0008

#define BF_TOPLEFT      (BF_TOP | BF_LEFT)
#define BF_TOPRIGHT     (BF_TOP | BF_RIGHT)
#define BF_BOTTOMLEFT   (BF_BOTTOM | BF_LEFT)
#define BF_BOTTOMRIGHT  (BF_BOTTOM | BF_RIGHT)
#define BF_RECT         (BF_LEFT | BF_TOP | BF_RIGHT | BF_BOTTOM)

#define BF_DIAGONAL     0x0010

// For diagonal lines, the BF_RECT flags specify the end point of the
// vector bounded by the rectangle parameter.
#define BF_DIAGONAL_ENDTOPRIGHT     (BF_DIAGONAL | BF_TOP | BF_RIGHT)
#define BF_DIAGONAL_ENDTOPLEFT      (BF_DIAGONAL | BF_TOP | BF_LEFT)
#define BF_DIAGONAL_ENDBOTTOMLEFT   (BF_DIAGONAL | BF_BOTTOM | BF_LEFT)
#define BF_DIAGONAL_ENDBOTTOMRIGHT  (BF_DIAGONAL | BF_BOTTOM | BF_RIGHT)


#define BF_MIDDLE       0x0800  /* Fill in the middle */
#define BF_SOFT         0x1000  /* For softer buttons */
#define BF_ADJUST       0x2000  /* Calculate the space left over */
#define BF_FLAT         0x4000  /* For flat rather than 3D borders */
#define BF_MONO         0x8000  /* For monochrome borders */


WINUSERAPI
BOOL
WINAPI
DrawEdge(
    __in HDC hdc,
    __inout LPRECT qrc,
    __in UINT edge,
    __in UINT grfFlags);

/* flags for DrawFrameControl */

#define DFC_CAPTION             1
#define DFC_MENU                2
#define DFC_SCROLL              3
#define DFC_BUTTON              4
#if(WINVER >= 0x0500)
#define DFC_POPUPMENU           5
#endif /* WINVER >= 0x0500 */

#define DFCS_CAPTIONCLOSE       0x0000
#define DFCS_CAPTIONMIN         0x0001
#define DFCS_CAPTIONMAX         0x0002
#define DFCS_CAPTIONRESTORE     0x0003
#define DFCS_CAPTIONHELP        0x0004

#define DFCS_MENUARROW          0x0000
#define DFCS_MENUCHECK          0x0001
#define DFCS_MENUBULLET         0x0002
#define DFCS_MENUARROWRIGHT     0x0004
#define DFCS_SCROLLUP           0x0000
#define DFCS_SCROLLDOWN         0x0001
#define DFCS_SCROLLLEFT         0x0002
#define DFCS_SCROLLRIGHT        0x0003
#define DFCS_SCROLLCOMBOBOX     0x0005
#define DFCS_SCROLLSIZEGRIP     0x0008
#define DFCS_SCROLLSIZEGRIPRIGHT 0x0010

#define DFCS_BUTTONCHECK        0x0000
#define DFCS_BUTTONRADIOIMAGE   0x0001
#define DFCS_BUTTONRADIOMASK    0x0002
#define DFCS_BUTTONRADIO        0x0004
#define DFCS_BUTTON3STATE       0x0008
#define DFCS_BUTTONPUSH         0x0010

#define DFCS_INACTIVE           0x0100
#define DFCS_PUSHED             0x0200
#define DFCS_CHECKED            0x0400

#if(WINVER >= 0x0500)
#define DFCS_TRANSPARENT        0x0800
#define DFCS_HOT                0x1000
#endif /* WINVER >= 0x0500 */

#define DFCS_ADJUSTRECT         0x2000
#define DFCS_FLAT               0x4000
#define DFCS_MONO               0x8000

WINUSERAPI
BOOL
WINAPI
DrawFrameControl(
    __in HDC,
    __inout LPRECT,
    __in UINT,
    __in UINT);


/* flags for DrawCaption */
#define DC_ACTIVE           0x0001
#define DC_SMALLCAP         0x0002
#define DC_ICON             0x0004
#define DC_TEXT             0x0008
#define DC_INBUTTON         0x0010
#if(WINVER >= 0x0500)
#define DC_GRADIENT         0x0020
#endif /* WINVER >= 0x0500 */
#if(_WIN32_WINNT >= 0x0501)
#define DC_BUTTONS          0x1000
#endif /* _WIN32_WINNT >= 0x0501 */

WINUSERAPI
BOOL
WINAPI
DrawCaption(
    __in HWND hwnd,
    __in HDC hdc,
    __in CONST RECT * lprect,
    __in UINT flags);


#define IDANI_OPEN          1
#define IDANI_CAPTION       3

WINUSERAPI
BOOL
WINAPI
DrawAnimatedRects(
    __in_opt HWND hwnd,
    __in int idAni,
    __in CONST RECT *lprcFrom,
    __in CONST RECT *lprcTo);

#endif /* WINVER >= 0x0400 */

#ifndef NOCLIPBOARD


/*
 * Predefined Clipboard Formats
 */
#define CF_TEXT             1
#define CF_BITMAP           2
#define CF_METAFILEPICT     3
#define CF_SYLK             4
#define CF_DIF              5
#define CF_TIFF             6
#define CF_OEMTEXT          7
#define CF_DIB              8
#define CF_PALETTE          9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12
#define CF_UNICODETEXT      13
#define CF_ENHMETAFILE      14
#if(WINVER >= 0x0400)
#define CF_HDROP            15
#define CF_LOCALE           16
#endif /* WINVER >= 0x0400 */
#if(WINVER >= 0x0500)
#define CF_DIBV5            17
#endif /* WINVER >= 0x0500 */

#if(WINVER >= 0x0500)
#define CF_MAX              18
#elif(WINVER >= 0x0400)
#define CF_MAX              17
#else
#define CF_MAX              15
#endif

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083
#define CF_DSPENHMETAFILE   0x008E

/*
 * "Private" formats don't get GlobalFree()'d
 */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/*
 * "GDIOBJ" formats do get DeleteObject()'d
 */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF


#endif /* !NOCLIPBOARD */

/*
 * Defines for the fVirt field of the Accelerator table structure.
 */
#define FVIRTKEY  TRUE          /* Assumed to be == TRUE */
#define FNOINVERT 0x02
#define FSHIFT    0x04
#define FCONTROL  0x08
#define FALT      0x10

typedef struct tagACCEL {
#ifndef _MAC
    BYTE   fVirt;               /* Also called the flags field */
    WORD   key;
    WORD   cmd;
#else
    WORD   fVirt;               /* Also called the flags field */
    WORD   key;
    DWORD  cmd;
#endif
} ACCEL, *LPACCEL;

typedef struct tagPAINTSTRUCT {
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[32];
} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;

typedef struct tagCREATESTRUCTA {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCSTR      lpszName;
    LPCSTR      lpszClass;
    DWORD       dwExStyle;
} CREATESTRUCTA, *LPCREATESTRUCTA;
typedef struct tagCREATESTRUCTW {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCWSTR     lpszName;
    LPCWSTR     lpszClass;
    DWORD       dwExStyle;
} CREATESTRUCTW, *LPCREATESTRUCTW;
#ifdef UNICODE
typedef CREATESTRUCTW CREATESTRUCT;
typedef LPCREATESTRUCTW LPCREATESTRUCT;
#else
typedef CREATESTRUCTA CREATESTRUCT;
typedef LPCREATESTRUCTA LPCREATESTRUCT;
#endif // UNICODE

typedef struct tagWINDOWPLACEMENT {
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
#ifdef _MAC
    RECT  rcDevice;
#endif
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION          0x0001
#define WPF_RESTORETOMAXIMIZED      0x0002
#if(_WIN32_WINNT >= 0x0500)
#define WPF_ASYNCWINDOWPLACEMENT    0x0004
#endif /* _WIN32_WINNT >= 0x0500 */

#if(WINVER >= 0x0400)
typedef struct tagNMHDR
{
    HWND      hwndFrom;
    UINT_PTR  idFrom;
    UINT      code;         // NM_ code
}   NMHDR;
typedef NMHDR FAR * LPNMHDR;

typedef struct tagSTYLESTRUCT
{
    DWORD   styleOld;
    DWORD   styleNew;
} STYLESTRUCT, * LPSTYLESTRUCT;
#endif /* WINVER >= 0x0400 */


/*
 * Owner draw control types
 */
#define ODT_MENU        1
#define ODT_LISTBOX     2
#define ODT_COMBOBOX    3
#define ODT_BUTTON      4
#if(WINVER >= 0x0400)
#define ODT_STATIC      5
#endif /* WINVER >= 0x0400 */

/*
 * Owner draw actions
 */
#define ODA_DRAWENTIRE  0x0001
#define ODA_SELECT      0x0002
#define ODA_FOCUS       0x0004

/*
 * Owner draw state
 */
#define ODS_SELECTED    0x0001
#define ODS_GRAYED      0x0002
#define ODS_DISABLED    0x0004
#define ODS_CHECKED     0x0008
#define ODS_FOCUS       0x0010
#if(WINVER >= 0x0400)
#define ODS_DEFAULT         0x0020
#define ODS_COMBOBOXEDIT    0x1000
#endif /* WINVER >= 0x0400 */
#if(WINVER >= 0x0500)
#define ODS_HOTLIGHT        0x0040
#define ODS_INACTIVE        0x0080
#if(_WIN32_WINNT >= 0x0500)
#define ODS_NOACCEL         0x0100
#define ODS_NOFOCUSRECT     0x0200
#endif /* _WIN32_WINNT >= 0x0500 */
#endif /* WINVER >= 0x0500 */

/*
 * MEASUREITEMSTRUCT for ownerdraw
 */
typedef struct tagMEASUREITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    UINT       itemWidth;
    UINT       itemHeight;
    ULONG_PTR  itemData;
} MEASUREITEMSTRUCT, NEAR *PMEASUREITEMSTRUCT, FAR *LPMEASUREITEMSTRUCT;

/*
 * DRAWITEMSTRUCT for ownerdraw
 */
typedef struct tagDRAWITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    ULONG_PTR   itemData;
} DRAWITEMSTRUCT, NEAR *PDRAWITEMSTRUCT, FAR *LPDRAWITEMSTRUCT;

/*
 * DELETEITEMSTRUCT for ownerdraw
 */
typedef struct tagDELETEITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    ULONG_PTR  itemData;
} DELETEITEMSTRUCT, NEAR *PDELETEITEMSTRUCT, FAR *LPDELETEITEMSTRUCT;

/*
 * COMPAREITEMSTUCT for ownerdraw sorting
 */
typedef struct tagCOMPAREITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    HWND        hwndItem;
    UINT        itemID1;
    ULONG_PTR   itemData1;
    UINT        itemID2;
    ULONG_PTR   itemData2;
    DWORD       dwLocaleId;
} COMPAREITEMSTRUCT, NEAR *PCOMPAREITEMSTRUCT, FAR *LPCOMPAREITEMSTRUCT;

#ifndef NOMSG

/*
 * Message Function Templates
 */

WINUSERAPI
BOOL
WINAPI
GetMessageA(
    __out LPMSG lpMsg,
    __in_opt HWND hWnd,
    __in UINT wMsgFilterMin,
    __in UINT wMsgFilterMax);
WINUSERAPI
BOOL
WINAPI
GetMessageW(
    __out LPMSG lpMsg,
    __in_opt HWND hWnd,
    __in UINT wMsgFilterMin,
    __in UINT wMsgFilterMax);
#ifdef UNICODE
#define GetMessage  GetMessageW
#else
#define GetMessage  GetMessageA
#endif // !UNICODE

#if defined(_M_CEE)
#undef GetMessage
__inline
BOOL
GetMessage(
    LPMSG lpMsg,
    HWND hWnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax
    )
{
#ifdef UNICODE
    return GetMessageW(
#else
    return GetMessageA(
#endif
        lpMsg,
        hWnd,
        wMsgFilterMin,
        wMsgFilterMax
        );
}
#endif  /* _M_CEE */


WINUSERAPI
BOOL
WINAPI
TranslateMessage(
    __in CONST MSG *lpMsg);

WINUSERAPI
LRESULT
WINAPI
DispatchMessageA(
    __in CONST MSG *lpMsg);
WINUSERAPI
LRESULT
WINAPI
DispatchMessageW(
    __in CONST MSG *lpMsg);
#ifdef UNICODE
#define DispatchMessage  DispatchMessageW
#else
#define DispatchMessage  DispatchMessageA
#endif // !UNICODE

#if defined(_M_CEE)
#undef DispatchMessage
__inline
LRESULT
DispatchMessage(
    CONST MSG *lpMsg
    )
{
#ifdef UNICODE
    return DispatchMessageW(
#else
    return DispatchMessageA(
#endif
        lpMsg
        );
}
#endif  /* _M_CEE */

WINUSERAPI
BOOL
WINAPI
SetMessageQueue(
    __in int cMessagesMax);

WINUSERAPI
BOOL
WINAPI
PeekMessageA(
    __out LPMSG lpMsg,
    __in_opt HWND hWnd,
    __in UINT wMsgFilterMin,
    __in UINT wMsgFilterMax,
    __in UINT wRemoveMsg);
WINUSERAPI
BOOL
WINAPI
PeekMessageW(
    __out LPMSG lpMsg,
    __in_opt HWND hWnd,
    __in UINT wMsgFilterMin,
    __in UINT wMsgFilterMax,
    __in UINT wRemoveMsg);
#ifdef UNICODE
#define PeekMessage  PeekMessageW
#else
#define PeekMessage  PeekMessageA
#endif // !UNICODE


/*
 * PeekMessage() Options
 */
#define PM_NOREMOVE         0x0000
#define PM_REMOVE           0x0001
#define PM_NOYIELD          0x0002
#if(WINVER >= 0x0500)
#define PM_QS_INPUT         (QS_INPUT << 16)
#define PM_QS_POSTMESSAGE   ((QS_POSTMESSAGE | QS_HOTKEY | QS_TIMER) << 16)
#define PM_QS_PAINT         (QS_PAINT << 16)
#define PM_QS_SENDMESSAGE   (QS_SENDMESSAGE << 16)
#endif /* WINVER >= 0x0500 */


#endif /* !NOMSG */

WINUSERAPI
BOOL
WINAPI
RegisterHotKey(
    __in_opt HWND hWnd,
    __in int id,
    __in UINT fsModifiers,
    __in UINT vk);

WINUSERAPI
BOOL
WINAPI
UnregisterHotKey(
    __in_opt HWND hWnd,
    __in int id);

#define MOD_ALT         0x0001
#define MOD_CONTROL     0x0002
#define MOD_SHIFT       0x0004
#define MOD_WIN         0x0008
#if(WINVER >= 0x0601)
#define MOD_NOREPEAT    0x4000
#endif /* WINVER >= 0x0601 */


#define IDHOT_SNAPWINDOW        (-1)    /* SHIFT-PRINTSCRN  */
#define IDHOT_SNAPDESKTOP       (-2)    /* PRINTSCRN        */

#ifdef WIN_INTERNAL
    #ifndef LSTRING
    #define NOLSTRING
    #endif /* LSTRING */
    #ifndef LFILEIO
    #define NOLFILEIO
    #endif /* LFILEIO */
#endif /* WIN_INTERNAL */

#if(WINVER >= 0x0400)

#define ENDSESSION_LOGOFF    0x80000000

#define ENDSESSION_CRITICAL  0x40000000

#define ENDSESSION_CLOSEAPP  0x00000001
#endif /* WINVER >= 0x0400 */

#define EWX_LOGOFF          0
#define EWX_SHUTDOWN        0x00000001
#define EWX_REBOOT          0x00000002
#define EWX_FORCE           0x00000004
#define EWX_POWEROFF        0x00000008
#if(_WIN32_WINNT >= 0x0500)
#define EWX_FORCEIFHUNG     0x00000010
#endif /* _WIN32_WINNT >= 0x0500 */
#define EWX_QUICKRESOLVE    0x00000020
#if(_WIN32_WINNT >= 0x0600)
#define EWX_RESTARTAPPS     0x00000040
#endif /* _WIN32_WINNT >= 0x0600 */


#define ExitWindows(dwReserved, Code) ExitWindowsEx(EWX_LOGOFF, 0xFFFFFFFF)

__drv_when((uFlags&(EWX_POWEROFF|EWX_SHUTDOWN|EWX_FORCE))!=0,
    __drv_preferredFunction("InitiateSystemShutdownEx",
        "Legacy API. Rearchitect to avoid Reboot"))
WINUSERAPI
BOOL
WINAPI
ExitWindowsEx(
    __in UINT uFlags,
    __in DWORD dwReason);

WINUSERAPI
BOOL
WINAPI
SwapMouseButton(
    __in BOOL fSwap);

WINUSERAPI
DWORD
WINAPI
GetMessagePos(
    VOID);

WINUSERAPI
LONG
WINAPI
GetMessageTime(
    VOID);

WINUSERAPI
LPARAM
WINAPI
GetMessageExtraInfo(
    VOID);

#if(_WIN32_WINNT >= 0x0501)
WINUSERAPI
BOOL
WINAPI
IsWow64Message(
    VOID);
#endif /* _WIN32_WINNT >= 0x0501 */

#if(WINVER >= 0x0400)
WINUSERAPI
LPARAM
WINAPI
SetMessageExtraInfo(
    __in LPARAM lParam);
#endif /* WINVER >= 0x0400 */

WINUSERAPI
LRESULT
WINAPI
SendMessageA(
    __in HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
WINUSERAPI
LRESULT
WINAPI
SendMessageW(
    __in HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
#ifdef UNICODE
#define SendMessage  SendMessageW
#else
#define SendMessage  SendMessageA
#endif // !UNICODE

#if defined(_M_CEE)
#undef SendMessage
__inline
LRESULT
SendMessage(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
#ifdef UNICODE
    return SendMessageW(
#else
    return SendMessageA(
#endif
        hWnd,
        Msg,
        wParam,
        lParam
        );
}
#endif  /* _M_CEE */



WINUSERAPI
LRESULT
WINAPI
SendMessageTimeoutA(
    __in HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam,
    __in UINT fuFlags,
    __in UINT uTimeout,
    __out_opt PDWORD_PTR lpdwResult);
WINUSERAPI
LRESULT
WINAPI
SendMessageTimeoutW(
    __in HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam,
    __in UINT fuFlags,
    __in UINT uTimeout,
    __out_opt PDWORD_PTR lpdwResult);
#ifdef UNICODE
#define SendMessageTimeout  SendMessageTimeoutW
#else
#define SendMessageTimeout  SendMessageTimeoutA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
SendNotifyMessageA(
    __in HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
WINUSERAPI
BOOL
WINAPI
SendNotifyMessageW(
    __in HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
#ifdef UNICODE
#define SendNotifyMessage  SendNotifyMessageW
#else
#define SendNotifyMessage  SendNotifyMessageA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
SendMessageCallbackA(
    __in HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam,
    __in SENDASYNCPROC lpResultCallBack,
    __in ULONG_PTR dwData);
WINUSERAPI
BOOL
WINAPI
SendMessageCallbackW(
    __in HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam,
    __in SENDASYNCPROC lpResultCallBack,
    __in ULONG_PTR dwData);
#ifdef UNICODE
#define SendMessageCallback  SendMessageCallbackW
#else
#define SendMessageCallback  SendMessageCallbackA
#endif // !UNICODE

#if(_WIN32_WINNT >= 0x0501)
typedef struct {
    UINT  cbSize;
    HDESK hdesk;
    HWND  hwnd;
    LUID  luid;
} BSMINFO, *PBSMINFO;

WINUSERAPI
long
WINAPI
BroadcastSystemMessageExA(
    __in DWORD flags,
    __inout_opt LPDWORD lpInfo,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam,
    __out_opt PBSMINFO pbsmInfo);
WINUSERAPI
long
WINAPI
BroadcastSystemMessageExW(
    __in DWORD flags,
    __inout_opt LPDWORD lpInfo,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam,
    __out_opt PBSMINFO pbsmInfo);
#ifdef UNICODE
#define BroadcastSystemMessageEx  BroadcastSystemMessageExW
#else
#define BroadcastSystemMessageEx  BroadcastSystemMessageExA
#endif // !UNICODE
#endif /* _WIN32_WINNT >= 0x0501 */

#if(WINVER >= 0x0400)

#if defined(_WIN32_WINNT)
WINUSERAPI
long
WINAPI
BroadcastSystemMessageA(
    __in DWORD flags,
    __inout_opt LPDWORD lpInfo,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
WINUSERAPI
long
WINAPI
BroadcastSystemMessageW(
    __in DWORD flags,
    __inout_opt LPDWORD lpInfo,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
#ifdef UNICODE
#define BroadcastSystemMessage  BroadcastSystemMessageW
#else
#define BroadcastSystemMessage  BroadcastSystemMessageA
#endif // !UNICODE
#elif defined(_WIN32_WINDOWS)
// The Win95 version isn't A/W decorated
WINUSERAPI
long
WINAPI
BroadcastSystemMessage(
    __in DWORD flags,
    __inout_opt LPDWORD lpInfo,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);

#endif

//Broadcast Special Message Recipient list
#define BSM_ALLCOMPONENTS       0x00000000
#define BSM_VXDS                0x00000001
#define BSM_NETDRIVER           0x00000002
#define BSM_INSTALLABLEDRIVERS  0x00000004
#define BSM_APPLICATIONS        0x00000008
#define BSM_ALLDESKTOPS         0x00000010

//Broadcast Special Message Flags
#define BSF_QUERY               0x00000001
#define BSF_IGNORECURRENTTASK   0x00000002
#define BSF_FLUSHDISK           0x00000004
#define BSF_NOHANG              0x00000008
#define BSF_POSTMESSAGE         0x00000010
#define BSF_FORCEIFHUNG         0x00000020
#define BSF_NOTIMEOUTIFNOTHUNG  0x00000040
#if(_WIN32_WINNT >= 0x0500)
#define BSF_ALLOWSFW            0x00000080
#define BSF_SENDNOTIFYMESSAGE   0x00000100
#endif /* _WIN32_WINNT >= 0x0500 */
#if(_WIN32_WINNT >= 0x0501)
#define BSF_RETURNHDESK         0x00000200
#define BSF_LUID                0x00000400
#endif /* _WIN32_WINNT >= 0x0501 */

#define BROADCAST_QUERY_DENY         0x424D5144  // Return this value to deny a query.
#endif /* WINVER >= 0x0400 */

// RegisterDeviceNotification

#if(WINVER >= 0x0500)
typedef  PVOID           HDEVNOTIFY;
typedef  HDEVNOTIFY     *PHDEVNOTIFY;

#define DEVICE_NOTIFY_WINDOW_HANDLE          0x00000000
#define DEVICE_NOTIFY_SERVICE_HANDLE         0x00000001
#if(_WIN32_WINNT >= 0x0501)
#define DEVICE_NOTIFY_ALL_INTERFACE_CLASSES  0x00000004
#endif /* _WIN32_WINNT >= 0x0501 */

WINUSERAPI
HDEVNOTIFY
WINAPI
RegisterDeviceNotificationA(
    __in HANDLE hRecipient,
    __in LPVOID NotificationFilter,
    __in DWORD Flags);
WINUSERAPI
HDEVNOTIFY
WINAPI
RegisterDeviceNotificationW(
    __in HANDLE hRecipient,
    __in LPVOID NotificationFilter,
    __in DWORD Flags);
#ifdef UNICODE
#define RegisterDeviceNotification  RegisterDeviceNotificationW
#else
#define RegisterDeviceNotification  RegisterDeviceNotificationA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
UnregisterDeviceNotification(
    __in HDEVNOTIFY Handle
    );

#if (_WIN32_WINNT >= 0x0502)

#if !defined(_HPOWERNOTIFY_DEF_)

#define _HPOWERNOTIFY_DEF_

typedef  PVOID           HPOWERNOTIFY;
typedef  HPOWERNOTIFY   *PHPOWERNOTIFY;

#endif

WINUSERAPI
HPOWERNOTIFY
WINAPI
RegisterPowerSettingNotification(
    IN HANDLE hRecipient,
    IN LPCGUID PowerSettingGuid,
    IN DWORD Flags
    );

WINUSERAPI
BOOL
WINAPI
UnregisterPowerSettingNotification(
    IN HPOWERNOTIFY Handle
    );
#endif // (_WIN32_WINNT >= 0x0502)
#endif /* WINVER >= 0x0500 */


WINUSERAPI
BOOL
WINAPI
PostMessageA(
    __in_opt HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
WINUSERAPI
BOOL
WINAPI
PostMessageW(
    __in_opt HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
#ifdef UNICODE
#define PostMessage  PostMessageW
#else
#define PostMessage  PostMessageA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
PostThreadMessageA(
    __in DWORD idThread,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
WINUSERAPI
BOOL
WINAPI
PostThreadMessageW(
    __in DWORD idThread,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
#ifdef UNICODE
#define PostThreadMessage  PostThreadMessageW
#else
#define PostThreadMessage  PostThreadMessageA
#endif // !UNICODE

#define PostAppMessageA(idThread, wMsg, wParam, lParam)\
        PostThreadMessageA((DWORD)idThread, wMsg, wParam, lParam)
#define PostAppMessageW(idThread, wMsg, wParam, lParam)\
        PostThreadMessageW((DWORD)idThread, wMsg, wParam, lParam)
#ifdef UNICODE
#define PostAppMessage  PostAppMessageW
#else
#define PostAppMessage  PostAppMessageA
#endif // !UNICODE

/*
 * Special HWND value for use with PostMessage() and SendMessage()
 */
#define HWND_BROADCAST  ((HWND)0xffff)

#if(WINVER >= 0x0500)
#define HWND_MESSAGE     ((HWND)-3)
#endif /* WINVER >= 0x0500 */

WINUSERAPI
BOOL
WINAPI
AttachThreadInput(
    __in DWORD idAttach,
    __in DWORD idAttachTo,
    __in BOOL fAttach);


WINUSERAPI
BOOL
WINAPI
ReplyMessage(
    __in LRESULT lResult);

WINUSERAPI
BOOL
WINAPI
WaitMessage(
    VOID);


WINUSERAPI
DWORD
WINAPI
WaitForInputIdle(
    __in HANDLE hProcess,
    __in DWORD dwMilliseconds);

WINUSERAPI
#ifndef _MAC
LRESULT
WINAPI
#else
LRESULT
CALLBACK
#endif
DefWindowProcA(
    __in HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
WINUSERAPI
#ifndef _MAC
LRESULT
WINAPI
#else
LRESULT
CALLBACK
#endif
DefWindowProcW(
    __in HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
#ifdef UNICODE
#define DefWindowProc  DefWindowProcW
#else
#define DefWindowProc  DefWindowProcA
#endif // !UNICODE

WINUSERAPI
VOID
WINAPI
PostQuitMessage(
    __in int nExitCode);

#ifdef STRICT

WINUSERAPI
LRESULT
WINAPI
CallWindowProcA(
    __in WNDPROC lpPrevWndFunc,
    __in HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
WINUSERAPI
LRESULT
WINAPI
CallWindowProcW(
    __in WNDPROC lpPrevWndFunc,
    __in HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
#ifdef UNICODE
#define CallWindowProc  CallWindowProcW
#else
#define CallWindowProc  CallWindowProcA
#endif // !UNICODE

#else /* !STRICT */

WINUSERAPI
LRESULT
WINAPI
CallWindowProcA(
    __in FARPROC lpPrevWndFunc,
    __in HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
WINUSERAPI
LRESULT
WINAPI
CallWindowProcW(
    __in FARPROC lpPrevWndFunc,
    __in HWND hWnd,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
#ifdef UNICODE
#define CallWindowProc  CallWindowProcW
#else
#define CallWindowProc  CallWindowProcA
#endif // !UNICODE

#endif /* !STRICT */

WINUSERAPI
BOOL
WINAPI
InSendMessage(
    VOID);

#if(WINVER >= 0x0500)
WINUSERAPI
DWORD
WINAPI
InSendMessageEx(
    __reserved LPVOID lpReserved);

/*
 * InSendMessageEx return value
 */
#define ISMEX_NOSEND      0x00000000
#define ISMEX_SEND        0x00000001
#define ISMEX_NOTIFY      0x00000002
#define ISMEX_CALLBACK    0x00000004
#define ISMEX_REPLIED     0x00000008
#endif /* WINVER >= 0x0500 */

WINUSERAPI
UINT
WINAPI
GetDoubleClickTime(
    VOID);

WINUSERAPI
BOOL
WINAPI
SetDoubleClickTime(
    __in UINT);

WINUSERAPI
ATOM
WINAPI
RegisterClassA(
    __in CONST WNDCLASSA *lpWndClass);
WINUSERAPI
ATOM
WINAPI
RegisterClassW(
    __in CONST WNDCLASSW *lpWndClass);
#ifdef UNICODE
#define RegisterClass  RegisterClassW
#else
#define RegisterClass  RegisterClassA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
UnregisterClassA(
    __in LPCSTR lpClassName,
    __in_opt HINSTANCE hInstance);
WINUSERAPI
BOOL
WINAPI
UnregisterClassW(
    __in LPCWSTR lpClassName,
    __in_opt HINSTANCE hInstance);
#ifdef UNICODE
#define UnregisterClass  UnregisterClassW
#else
#define UnregisterClass  UnregisterClassA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
GetClassInfoA(
    __in_opt HINSTANCE hInstance,
    __in LPCSTR lpClassName,
    __out LPWNDCLASSA lpWndClass);
WINUSERAPI
BOOL
WINAPI
GetClassInfoW(
    __in_opt HINSTANCE hInstance,
    __in LPCWSTR lpClassName,
    __out LPWNDCLASSW lpWndClass);
#ifdef UNICODE
#define GetClassInfo  GetClassInfoW
#else
#define GetClassInfo  GetClassInfoA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI
ATOM
WINAPI
RegisterClassExA(
    __in CONST WNDCLASSEXA *);
WINUSERAPI
ATOM
WINAPI
RegisterClassExW(
    __in CONST WNDCLASSEXW *);
#ifdef UNICODE
#define RegisterClassEx  RegisterClassExW
#else
#define RegisterClassEx  RegisterClassExA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
GetClassInfoExA(
    __in_opt HINSTANCE hInstance,
    __in LPCSTR lpszClass,
    __out LPWNDCLASSEXA lpwcx);
WINUSERAPI
BOOL
WINAPI
GetClassInfoExW(
    __in_opt HINSTANCE hInstance,
    __in LPCWSTR lpszClass,
    __out LPWNDCLASSEXW lpwcx);
#ifdef UNICODE
#define GetClassInfoEx  GetClassInfoExW
#else
#define GetClassInfoEx  GetClassInfoExA
#endif // !UNICODE

#endif /* WINVER >= 0x0400 */

#define CW_USEDEFAULT       ((int)0x80000000)

/*
 * Special value for CreateWindow, et al.
 */
#define HWND_DESKTOP        ((HWND)0)

#if(_WIN32_WINNT >= 0x0501)
typedef BOOLEAN (WINAPI * PREGISTERCLASSNAMEW)(LPCWSTR);
#endif /* _WIN32_WINNT >= 0x0501 */

WINUSERAPI
HWND
WINAPI
CreateWindowExA(
    __in DWORD dwExStyle,
    __in_opt LPCSTR lpClassName,
    __in_opt LPCSTR lpWindowName,
    __in DWORD dwStyle,
    __in int X,
    __in int Y,
    __in int nWidth,
    __in int nHeight,
    __in_opt HWND hWndParent,
    __in_opt HMENU hMenu,
    __in_opt HINSTANCE hInstance,
    __in_opt LPVOID lpParam);
WINUSERAPI
HWND
WINAPI
CreateWindowExW(
    __in DWORD dwExStyle,
    __in_opt LPCWSTR lpClassName,
    __in_opt LPCWSTR lpWindowName,
    __in DWORD dwStyle,
    __in int X,
    __in int Y,
    __in int nWidth,
    __in int nHeight,
    __in_opt HWND hWndParent,
    __in_opt HMENU hMenu,
    __in_opt HINSTANCE hInstance,
    __in_opt LPVOID lpParam);
#ifdef UNICODE
#define CreateWindowEx  CreateWindowExW
#else
#define CreateWindowEx  CreateWindowExA
#endif // !UNICODE

#define CreateWindowA(lpClassName, lpWindowName, dwStyle, x, y,\
nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)\
CreateWindowExA(0L, lpClassName, lpWindowName, dwStyle, x, y,\
nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)
#define CreateWindowW(lpClassName, lpWindowName, dwStyle, x, y,\
nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)\
CreateWindowExW(0L, lpClassName, lpWindowName, dwStyle, x, y,\
nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)
#ifdef UNICODE
#define CreateWindow  CreateWindowW
#else
#define CreateWindow  CreateWindowA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
IsWindow(
    __in_opt HWND hWnd);


WINUSERAPI
BOOL
WINAPI
IsMenu(
    __in HMENU hMenu);

WINUSERAPI
BOOL
WINAPI
IsChild(
    __in HWND hWndParent,
    __in HWND hWnd);

WINUSERAPI
BOOL
WINAPI
DestroyWindow(
    __in HWND hWnd);

WINUSERAPI
BOOL
WINAPI
ShowWindow(
    __in HWND hWnd,
    __in int nCmdShow);

#if(WINVER >= 0x0500)
WINUSERAPI
BOOL
WINAPI
AnimateWindow(
    __in HWND hWnd,
    __in DWORD dwTime,
    __in DWORD dwFlags);
#endif /* WINVER >= 0x0500 */

#if(_WIN32_WINNT >= 0x0500)
#if defined(_WINGDI_) && !defined(NOGDI)

WINUSERAPI
BOOL
WINAPI
UpdateLayeredWindow(
    __in HWND hWnd,
    __in_opt HDC hdcDst,
    __in_opt POINT* pptDst,
    __in_opt SIZE* psize,
    __in_opt HDC hdcSrc,
    __in_opt POINT* pptSrc,
    __in COLORREF crKey,
    __in_opt BLENDFUNCTION* pblend,
    __in DWORD dwFlags);

/*
 * Layered Window Update information
 */
typedef struct tagUPDATELAYEREDWINDOWINFO
{
    __in DWORD cbSize;
    __in_opt HDC hdcDst;
    __in_opt const POINT* pptDst;
    __in_opt const SIZE* psize;
    __in_opt HDC hdcSrc;
    __in_opt const POINT* pptSrc;
    __in_opt COLORREF crKey;
    __in_opt const BLENDFUNCTION* pblend;
    __in DWORD dwFlags;
    __in_opt const RECT* prcDirty;
} UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;


#if (_WIN32_WINNT < 0x0502)
typedef
#endif /* _WIN32_WINNT < 0x0502 */
WINUSERAPI
BOOL
WINAPI
UpdateLayeredWindowIndirect(
    __in HWND hWnd,
    __in const UPDATELAYEREDWINDOWINFO* pULWInfo);

#endif

#if(_WIN32_WINNT >= 0x0501)
WINUSERAPI
BOOL
WINAPI
GetLayeredWindowAttributes(
    __in HWND hwnd,
    __out_opt COLORREF* pcrKey,
    __out_opt BYTE* pbAlpha,
    __out_opt DWORD* pdwFlags);

#define PW_CLIENTONLY           0x00000001


WINUSERAPI
BOOL
WINAPI
PrintWindow(
    __in HWND hwnd,
    __in HDC hdcBlt,
    __in UINT nFlags);

#endif /* _WIN32_WINNT >= 0x0501 */

WINUSERAPI
BOOL
WINAPI
SetLayeredWindowAttributes(
    __in HWND hwnd,
    __in COLORREF crKey,
    __in BYTE bAlpha,
    __in DWORD dwFlags);

#define LWA_COLORKEY            0x00000001
#define LWA_ALPHA               0x00000002


#define ULW_COLORKEY            0x00000001
#define ULW_ALPHA               0x00000002
#define ULW_OPAQUE              0x00000004

#define ULW_EX_NORESIZE         0x00000008

#endif /* _WIN32_WINNT >= 0x0500 */


#if(WINVER >= 0x0400)
WINUSERAPI
BOOL
WINAPI
ShowWindowAsync(
    __in  HWND hWnd,
    __in  int nCmdShow);
#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
FlashWindow(
    __in  HWND hWnd,
    __in  BOOL bInvert);

#if(WINVER >= 0x0500)
typedef struct {
    UINT  cbSize;
    HWND  hwnd;
    DWORD dwFlags;
    UINT  uCount;
    DWORD dwTimeout;
} FLASHWINFO, *PFLASHWINFO;

WINUSERAPI
BOOL
WINAPI
FlashWindowEx(
    __in PFLASHWINFO pfwi);

#define FLASHW_STOP         0
#define FLASHW_CAPTION      0x00000001
#define FLASHW_TRAY         0x00000002
#define FLASHW_ALL          (FLASHW_CAPTION | FLASHW_TRAY)
#define FLASHW_TIMER        0x00000004
#define FLASHW_TIMERNOFG    0x0000000C

#endif /* WINVER >= 0x0500 */

WINUSERAPI
BOOL
WINAPI
ShowOwnedPopups(
    __in  HWND hWnd,
    __in  BOOL fShow);

WINUSERAPI
BOOL
WINAPI
OpenIcon(
    __in  HWND hWnd);

WINUSERAPI
BOOL
WINAPI
CloseWindow(
    __in  HWND hWnd);

WINUSERAPI
BOOL
WINAPI
MoveWindow(
    __in HWND hWnd,
    __in int X,
    __in int Y,
    __in int nWidth,
    __in int nHeight,
    __in BOOL bRepaint);

WINUSERAPI
BOOL
WINAPI
SetWindowPos(
    __in HWND hWnd,
    __in_opt HWND hWndInsertAfter,
    __in int X,
    __in int Y,
    __in int cx,
    __in int cy,
    __in UINT uFlags);

WINUSERAPI
BOOL
WINAPI
GetWindowPlacement(
    __in HWND hWnd,
    __inout WINDOWPLACEMENT *lpwndpl);

WINUSERAPI
BOOL
WINAPI
SetWindowPlacement(
    __in HWND hWnd,
    __in CONST WINDOWPLACEMENT *lpwndpl);

#if(_WIN32_WINNT >= 0x0601)
#define WDA_NONE        0x00000000
#define WDA_MONITOR     0x00000001


WINUSERAPI
BOOL
WINAPI
GetWindowDisplayAffinity(
    __in HWND hWnd,
    __out DWORD* pdwAffinity);

WINUSERAPI
BOOL
WINAPI
SetWindowDisplayAffinity(
    __in HWND hWnd,
    __in DWORD dwAffinity);

#endif /* _WIN32_WINNT >= 0x0601 */

#ifndef NODEFERWINDOWPOS

WINUSERAPI
HDWP
WINAPI
BeginDeferWindowPos(
    __in int nNumWindows);

WINUSERAPI
HDWP
WINAPI
DeferWindowPos(
    __in HDWP hWinPosInfo,
    __in HWND hWnd,
    __in_opt HWND hWndInsertAfter,
    __in int x,
    __in int y,
    __in int cx,
    __in int cy,
    __in UINT uFlags);

WINUSERAPI
BOOL
WINAPI
EndDeferWindowPos(
    __in HDWP hWinPosInfo);

#endif /* !NODEFERWINDOWPOS */

WINUSERAPI
BOOL
WINAPI
IsWindowVisible(
    __in HWND hWnd);

WINUSERAPI
BOOL
WINAPI
IsIconic(
    __in HWND hWnd);

WINUSERAPI
BOOL
WINAPI
AnyPopup(
    VOID);

WINUSERAPI
BOOL
WINAPI
BringWindowToTop(
    __in HWND hWnd);

WINUSERAPI
BOOL
WINAPI
IsZoomed(
    __in HWND hWnd);

/*
 * SetWindowPos Flags
 */
#define SWP_NOSIZE          0x0001
#define SWP_NOMOVE          0x0002
#define SWP_NOZORDER        0x0004
#define SWP_NOREDRAW        0x0008
#define SWP_NOACTIVATE      0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW      0x0040
#define SWP_HIDEWINDOW      0x0080
#define SWP_NOCOPYBITS      0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */
#define SWP_NOSENDCHANGING  0x0400  /* Don't send WM_WINDOWPOSCHANGING */

#define SWP_DRAWFRAME       SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#if(WINVER >= 0x0400)
#define SWP_DEFERERASE      0x2000
#define SWP_ASYNCWINDOWPOS  0x4000
#endif /* WINVER >= 0x0400 */


#define HWND_TOP        ((HWND)0)
#define HWND_BOTTOM     ((HWND)1)
#define HWND_TOPMOST    ((HWND)-1)
#define HWND_NOTOPMOST  ((HWND)-2)

#ifndef NOCTLMGR

/*
 * WARNING:
 * The following structures must NOT be DWORD padded because they are
 * followed by strings, etc that do not have to be DWORD aligned.
 */
#include <pshpack2.h>

/*
 * original NT 32 bit dialog template:
 */
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    WORD cdit;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE;
typedef DLGTEMPLATE *LPDLGTEMPLATEA;
typedef DLGTEMPLATE *LPDLGTEMPLATEW;
#ifdef UNICODE
typedef LPDLGTEMPLATEW LPDLGTEMPLATE;
#else
typedef LPDLGTEMPLATEA LPDLGTEMPLATE;
#endif // UNICODE
typedef CONST DLGTEMPLATE *LPCDLGTEMPLATEA;
typedef CONST DLGTEMPLATE *LPCDLGTEMPLATEW;
#ifdef UNICODE
typedef LPCDLGTEMPLATEW LPCDLGTEMPLATE;
#else
typedef LPCDLGTEMPLATEA LPCDLGTEMPLATE;
#endif // UNICODE

/*
 * 32 bit Dialog item template.
 */
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    WORD id;
} DLGITEMTEMPLATE;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEW;
#ifdef UNICODE
typedef PDLGITEMTEMPLATEW PDLGITEMTEMPLATE;
#else
typedef PDLGITEMTEMPLATEA PDLGITEMTEMPLATE;
#endif // UNICODE
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEW;
#ifdef UNICODE
typedef LPDLGITEMTEMPLATEW LPDLGITEMTEMPLATE;
#else
typedef LPDLGITEMTEMPLATEA LPDLGITEMTEMPLATE;
#endif // UNICODE


#include <poppack.h> /* Resume normal packing */

WINUSERAPI
HWND
WINAPI
CreateDialogParamA(
    __in_opt HINSTANCE hInstance,
    __in LPCSTR lpTemplateName,
    __in_opt HWND hWndParent,
    __in_opt DLGPROC lpDialogFunc,
    __in LPARAM dwInitParam);
WINUSERAPI
HWND
WINAPI
CreateDialogParamW(
    __in_opt HINSTANCE hInstance,
    __in LPCWSTR lpTemplateName,
    __in_opt HWND hWndParent,
    __in_opt DLGPROC lpDialogFunc,
    __in LPARAM dwInitParam);
#ifdef UNICODE
#define CreateDialogParam  CreateDialogParamW
#else
#define CreateDialogParam  CreateDialogParamA
#endif // !UNICODE

WINUSERAPI
HWND
WINAPI
CreateDialogIndirectParamA(
    __in_opt HINSTANCE hInstance,
    __in LPCDLGTEMPLATEA lpTemplate,
    __in_opt HWND hWndParent,
    __in_opt DLGPROC lpDialogFunc,
    __in LPARAM dwInitParam);
WINUSERAPI
HWND
WINAPI
CreateDialogIndirectParamW(
    __in_opt HINSTANCE hInstance,
    __in LPCDLGTEMPLATEW lpTemplate,
    __in_opt HWND hWndParent,
    __in_opt DLGPROC lpDialogFunc,
    __in LPARAM dwInitParam);
#ifdef UNICODE
#define CreateDialogIndirectParam  CreateDialogIndirectParamW
#else
#define CreateDialogIndirectParam  CreateDialogIndirectParamA
#endif // !UNICODE

#define CreateDialogA(hInstance, lpName, hWndParent, lpDialogFunc) \
CreateDialogParamA(hInstance, lpName, hWndParent, lpDialogFunc, 0L)
#define CreateDialogW(hInstance, lpName, hWndParent, lpDialogFunc) \
CreateDialogParamW(hInstance, lpName, hWndParent, lpDialogFunc, 0L)
#ifdef UNICODE
#define CreateDialog  CreateDialogW
#else
#define CreateDialog  CreateDialogA
#endif // !UNICODE

#define CreateDialogIndirectA(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
CreateDialogIndirectParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)
#define CreateDialogIndirectW(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
CreateDialogIndirectParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)
#ifdef UNICODE
#define CreateDialogIndirect  CreateDialogIndirectW
#else
#define CreateDialogIndirect  CreateDialogIndirectA
#endif // !UNICODE

WINUSERAPI
INT_PTR
WINAPI
DialogBoxParamA(
    __in_opt HINSTANCE hInstance,
    __in LPCSTR lpTemplateName,
    __in_opt HWND hWndParent,
    __in_opt DLGPROC lpDialogFunc,
    __in LPARAM dwInitParam);
WINUSERAPI
INT_PTR
WINAPI
DialogBoxParamW(
    __in_opt HINSTANCE hInstance,
    __in LPCWSTR lpTemplateName,
    __in_opt HWND hWndParent,
    __in_opt DLGPROC lpDialogFunc,
    __in LPARAM dwInitParam);
#ifdef UNICODE
#define DialogBoxParam  DialogBoxParamW
#else
#define DialogBoxParam  DialogBoxParamA
#endif // !UNICODE

WINUSERAPI
INT_PTR
WINAPI
DialogBoxIndirectParamA(
    __in_opt HINSTANCE hInstance,
    __in LPCDLGTEMPLATEA hDialogTemplate,
    __in_opt HWND hWndParent,
    __in_opt DLGPROC lpDialogFunc,
    __in LPARAM dwInitParam);
WINUSERAPI
INT_PTR
WINAPI
DialogBoxIndirectParamW(
    __in_opt HINSTANCE hInstance,
    __in LPCDLGTEMPLATEW hDialogTemplate,
    __in_opt HWND hWndParent,
    __in_opt DLGPROC lpDialogFunc,
    __in LPARAM dwInitParam);
#ifdef UNICODE
#define DialogBoxIndirectParam  DialogBoxIndirectParamW
#else
#define DialogBoxIndirectParam  DialogBoxIndirectParamA
#endif // !UNICODE

#define DialogBoxA(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
DialogBoxParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)
#define DialogBoxW(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
DialogBoxParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)
#ifdef UNICODE
#define DialogBox  DialogBoxW
#else
#define DialogBox  DialogBoxA
#endif // !UNICODE

#define DialogBoxIndirectA(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
DialogBoxIndirectParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)
#define DialogBoxIndirectW(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
DialogBoxIndirectParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)
#ifdef UNICODE
#define DialogBoxIndirect  DialogBoxIndirectW
#else
#define DialogBoxIndirect  DialogBoxIndirectA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
EndDialog(
    __in HWND hDlg,
    __in INT_PTR nResult);

WINUSERAPI
HWND
WINAPI
GetDlgItem(
    __in_opt HWND hDlg,
    __in int nIDDlgItem);

WINUSERAPI
BOOL
WINAPI
SetDlgItemInt(
    __in HWND hDlg,
    __in int nIDDlgItem,
    __in UINT uValue,
    __in BOOL bSigned);

WINUSERAPI
UINT
WINAPI
GetDlgItemInt(
    __in HWND hDlg,
    __in int nIDDlgItem,
    __out_opt BOOL *lpTranslated,
    __in BOOL bSigned);

WINUSERAPI
BOOL
WINAPI
SetDlgItemTextA(
    __in HWND hDlg,
    __in int nIDDlgItem,
    __in LPCSTR lpString);
WINUSERAPI
BOOL
WINAPI
SetDlgItemTextW(
    __in HWND hDlg,
    __in int nIDDlgItem,
    __in LPCWSTR lpString);
#ifdef UNICODE
#define SetDlgItemText  SetDlgItemTextW
#else
#define SetDlgItemText  SetDlgItemTextA
#endif // !UNICODE

WINUSERAPI
UINT
WINAPI
GetDlgItemTextA(
    __in HWND hDlg,
    __in int nIDDlgItem,
    __out_ecount(cchMax) LPSTR lpString,
    __in int cchMax);
WINUSERAPI
UINT
WINAPI
GetDlgItemTextW(
    __in HWND hDlg,
    __in int nIDDlgItem,
    __out_ecount(cchMax) LPWSTR lpString,
    __in int cchMax);
#ifdef UNICODE
#define GetDlgItemText  GetDlgItemTextW
#else
#define GetDlgItemText  GetDlgItemTextA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
CheckDlgButton(
    __in HWND hDlg,
    __in int nIDButton,
    __in UINT uCheck);

WINUSERAPI
BOOL
WINAPI
CheckRadioButton(
    __in HWND hDlg,
    __in int nIDFirstButton,
    __in int nIDLastButton,
    __in int nIDCheckButton);

WINUSERAPI
UINT
WINAPI
IsDlgButtonChecked(
    __in HWND hDlg,
    __in int nIDButton);

WINUSERAPI
LRESULT
WINAPI
SendDlgItemMessageA(
    __in HWND hDlg,
    __in int nIDDlgItem,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
WINUSERAPI
LRESULT
WINAPI
SendDlgItemMessageW(
    __in HWND hDlg,
    __in int nIDDlgItem,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
#ifdef UNICODE
#define SendDlgItemMessage  SendDlgItemMessageW
#else
#define SendDlgItemMessage  SendDlgItemMessageA
#endif // !UNICODE

WINUSERAPI
HWND
WINAPI
GetNextDlgGroupItem(
    __in HWND hDlg,
    __in_opt HWND hCtl,
    __in BOOL bPrevious);

WINUSERAPI
HWND
WINAPI
GetNextDlgTabItem(
    __in HWND hDlg,
    __in_opt HWND hCtl,
    __in BOOL bPrevious);

WINUSERAPI
int
WINAPI
GetDlgCtrlID(
    __in HWND hWnd);

WINUSERAPI
long
WINAPI
GetDialogBaseUnits(VOID);

WINUSERAPI
#ifndef _MAC
LRESULT
WINAPI
#else
LRESULT
CALLBACK
#endif
DefDlgProcA(
    __in HWND hDlg,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
WINUSERAPI
#ifndef _MAC
LRESULT
WINAPI
#else
LRESULT
CALLBACK
#endif
DefDlgProcW(
    __in HWND hDlg,
    __in UINT Msg,
    __in WPARAM wParam,
    __in LPARAM lParam);
#ifdef UNICODE
#define DefDlgProc  DefDlgProcW
#else
#define DefDlgProc  DefDlgProcA
#endif // !UNICODE

/*
 * Window extra byted needed for private dialog classes.
 */
#ifndef _MAC
#define DLGWINDOWEXTRA 30
#else
#define DLGWINDOWEXTRA 48
#endif

#endif /* !NOCTLMGR */

#ifndef NOMSG

WINUSERAPI
BOOL
WINAPI
CallMsgFilterA(
    __in LPMSG lpMsg,
    __in int nCode);
WINUSERAPI
BOOL
WINAPI
CallMsgFilterW(
    __in LPMSG lpMsg,
    __in int nCode);
#ifdef UNICODE
#define CallMsgFilter  CallMsgFilterW
#else
#define CallMsgFilter  CallMsgFilterA
#endif // !UNICODE

#endif /* !NOMSG */

#ifndef NOCLIPBOARD

/*
 * Clipboard Manager Functions
 */

WINUSERAPI
BOOL
WINAPI
OpenClipboard(
    __in_opt HWND hWndNewOwner);

WINUSERAPI
BOOL
WINAPI
CloseClipboard(
    VOID);


#if(WINVER >= 0x0500)

WINUSERAPI
DWORD
WINAPI
GetClipboardSequenceNumber(
    VOID);

#endif /* WINVER >= 0x0500 */

WINUSERAPI
HWND
WINAPI
GetClipboardOwner(
    VOID);

WINUSERAPI
HWND
WINAPI
SetClipboardViewer(
    __in HWND hWndNewViewer);

WINUSERAPI
HWND
WINAPI
GetClipboardViewer(
    VOID);

WINUSERAPI
BOOL
WINAPI
ChangeClipboardChain(
    __in HWND hWndRemove,
    __in HWND hWndNewNext);

WINUSERAPI
HANDLE
WINAPI
SetClipboardData(
    __in UINT uFormat,
    __in_opt HANDLE hMem);

WINUSERAPI
HANDLE
WINAPI
GetClipboardData(
    __in UINT uFormat);

WINUSERAPI
UINT
WINAPI
RegisterClipboardFormatA(
    __in LPCSTR lpszFormat);
WINUSERAPI
UINT
WINAPI
RegisterClipboardFormatW(
    __in LPCWSTR lpszFormat);
#ifdef UNICODE
#define RegisterClipboardFormat  RegisterClipboardFormatW
#else
#define RegisterClipboardFormat  RegisterClipboardFormatA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
CountClipboardFormats(
    VOID);

WINUSERAPI
UINT
WINAPI
EnumClipboardFormats(
    __in UINT format);

WINUSERAPI
int
WINAPI
GetClipboardFormatNameA(
    __in UINT format,
    __out_ecount(cchMaxCount) LPSTR lpszFormatName,
    __in int cchMaxCount);
WINUSERAPI
int
WINAPI
GetClipboardFormatNameW(
    __in UINT format,
    __out_ecount(cchMaxCount) LPWSTR lpszFormatName,
    __in int cchMaxCount);
#ifdef UNICODE
#define GetClipboardFormatName  GetClipboardFormatNameW
#else
#define GetClipboardFormatName  GetClipboardFormatNameA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
EmptyClipboard(
    VOID);

WINUSERAPI
BOOL
WINAPI
IsClipboardFormatAvailable(
    __in UINT format);

WINUSERAPI
int
WINAPI
GetPriorityClipboardFormat(
    __in_ecount(cFormats) UINT *paFormatPriorityList,
    __in int cFormats);

WINUSERAPI
HWND
WINAPI
GetOpenClipboardWindow(
    VOID);

#if(WINVER >= 0x0600)
WINUSERAPI
BOOL
WINAPI
AddClipboardFormatListener(
    __in HWND hwnd);

WINUSERAPI
BOOL
WINAPI
RemoveClipboardFormatListener(
    __in HWND hwnd);

WINUSERAPI
BOOL
WINAPI
GetUpdatedClipboardFormats(
    __out_ecount(cFormats) __notnull PUINT lpuiFormats,
    __in UINT cFormats,
    __out __notnull PUINT pcFormatsOut);
#endif /* WINVER >= 0x0600 */
#endif /* !NOCLIPBOARD */

/*
 * Character Translation Routines
 */

WINUSERAPI
BOOL
WINAPI
CharToOemA(
    __in_xcount(strlen(pSrc) + 1) LPCSTR pSrc,
    __out_xcount(strlen(pSrc) + 1) LPSTR pDst);
WINUSERAPI
BOOL
WINAPI
CharToOemW(
    __in_xcount(strlen(pSrc) + 1) LPCWSTR pSrc,
    __out_xcount(strlen(pSrc) + 1) LPSTR pDst);
#ifdef UNICODE
#define CharToOem  CharToOemW
#else
#define CharToOem  CharToOemA
#endif // !UNICODE

__drv_preferredFunction("OemToCharBuff","Does not validate buffer size")
WINUSERAPI
BOOL
WINAPI
OemToCharA(
    __in_xcount(strlen(pSrc) + 1) LPCSTR pSrc,
    __out_xcount(strlen(pSrc) + 1) LPSTR pDst);
__drv_preferredFunction("OemToCharBuff","Does not validate buffer size")
WINUSERAPI
BOOL
WINAPI
OemToCharW(
    __in_xcount(strlen(pSrc) + 1) LPCSTR pSrc,
    __out_xcount(strlen(pSrc) + 1) LPWSTR pDst);
#ifdef UNICODE
#define OemToChar  OemToCharW
#else
#define OemToChar  OemToCharA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
CharToOemBuffA(
    __in LPCSTR lpszSrc,
    __out_ecount(cchDstLength) LPSTR lpszDst,
    __in DWORD cchDstLength);
WINUSERAPI
BOOL
WINAPI
CharToOemBuffW(
    __in LPCWSTR lpszSrc,
    __out_ecount(cchDstLength) LPSTR lpszDst,
    __in DWORD cchDstLength);
#ifdef UNICODE
#define CharToOemBuff  CharToOemBuffW
#else
#define CharToOemBuff  CharToOemBuffA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
OemToCharBuffA(
    __in LPCSTR lpszSrc,
    __out_ecount(cchDstLength) LPSTR lpszDst,
    __in DWORD cchDstLength);
WINUSERAPI
BOOL
WINAPI
OemToCharBuffW(
    __in LPCSTR lpszSrc,
    __out_ecount(cchDstLength) LPWSTR lpszDst,
    __in DWORD cchDstLength);
#ifdef UNICODE
#define OemToCharBuff  OemToCharBuffW
#else
#define OemToCharBuff  OemToCharBuffA
#endif // !UNICODE

WINUSERAPI
LPSTR
WINAPI
CharUpperA(
    __inout LPSTR lpsz);
WINUSERAPI
LPWSTR
WINAPI
CharUpperW(
    __inout LPWSTR lpsz);
#ifdef UNICODE
#define CharUpper  CharUpperW
#else
#define CharUpper  CharUpperA
#endif // !UNICODE

WINUSERAPI
DWORD
WINAPI
CharUpperBuffA(
    __inout_ecount(cchLength) LPSTR lpsz,
    __in DWORD cchLength);
WINUSERAPI
DWORD
WINAPI
CharUpperBuffW(
    __inout_ecount(cchLength) LPWSTR lpsz,
    __in DWORD cchLength);
#ifdef UNICODE
#define CharUpperBuff  CharUpperBuffW
#else
#define CharUpperBuff  CharUpperBuffA
#endif // !UNICODE

WINUSERAPI
LPSTR
WINAPI
CharLowerA(
    __inout LPSTR lpsz);
WINUSERAPI
LPWSTR
WINAPI
CharLowerW(
    __inout LPWSTR lpsz);
#ifdef UNICODE
#define CharLower  CharLowerW
#else
#define CharLower  CharLowerA
#endif // !UNICODE

WINUSERAPI
DWORD
WINAPI
CharLowerBuffA(
    __inout_ecount(cchLength) LPSTR lpsz,
    __in DWORD cchLength);
WINUSERAPI
DWORD
WINAPI
CharLowerBuffW(
    __inout_ecount(cchLength) LPWSTR lpsz,
    __in DWORD cchLength);
#ifdef UNICODE
#define CharLowerBuff  CharLowerBuffW
#else
#define CharLowerBuff  CharLowerBuffA
#endif // !UNICODE

WINUSERAPI
LPSTR
WINAPI
CharNextA(
    __in LPCSTR lpsz);
WINUSERAPI
LPWSTR
WINAPI
CharNextW(
    __in LPCWSTR lpsz);
#ifdef UNICODE
#define CharNext  CharNextW
#else
#define CharNext  CharNextA
#endif // !UNICODE

WINUSERAPI
LPSTR
WINAPI
CharPrevA(
    __in LPCSTR lpszStart,
    __in LPCSTR lpszCurrent);
WINUSERAPI
LPWSTR
WINAPI
CharPrevW(
    __in LPCWSTR lpszStart,
    __in LPCWSTR lpszCurrent);
#ifdef UNICODE
#define CharPrev  CharPrevW
#else
#define CharPrev  CharPrevA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI
LPSTR
WINAPI
CharNextExA(
     __in WORD CodePage,
     __in LPCSTR lpCurrentChar,
     __in DWORD dwFlags);

WINUSERAPI
LPSTR
WINAPI
CharPrevExA(
     __in WORD CodePage,
     __in LPCSTR lpStart,
     __in LPCSTR lpCurrentChar,
     __in DWORD dwFlags);
#endif /* WINVER >= 0x0400 */

/*
 * Compatibility defines for character translation routines
 */
#define AnsiToOem CharToOemA
#define OemToAnsi OemToCharA
#define AnsiToOemBuff CharToOemBuffA
#define OemToAnsiBuff OemToCharBuffA
#define AnsiUpper CharUpperA
#define AnsiUpperBuff CharUpperBuffA
#define AnsiLower CharLowerA
#define AnsiLowerBuff CharLowerBuffA
#define AnsiNext CharNextA
#define AnsiPrev CharPrevA

#ifndef  NOLANGUAGE
/*
 * Language dependent Routines
 */

WINUSERAPI
BOOL
WINAPI
IsCharAlphaA(
    __in CHAR ch);
WINUSERAPI
BOOL
WINAPI
IsCharAlphaW(
    __in WCHAR ch);
#ifdef UNICODE
#define IsCharAlpha  IsCharAlphaW
#else
#define IsCharAlpha  IsCharAlphaA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
IsCharAlphaNumericA(
    __in CHAR ch);
WINUSERAPI
BOOL
WINAPI
IsCharAlphaNumericW(
    __in WCHAR ch);
#ifdef UNICODE
#define IsCharAlphaNumeric  IsCharAlphaNumericW
#else
#define IsCharAlphaNumeric  IsCharAlphaNumericA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
IsCharUpperA(
    __in CHAR ch);
WINUSERAPI
BOOL
WINAPI
IsCharUpperW(
    __in WCHAR ch);
#ifdef UNICODE
#define IsCharUpper  IsCharUpperW
#else
#define IsCharUpper  IsCharUpperA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
IsCharLowerA(
    __in CHAR ch);
WINUSERAPI
BOOL
WINAPI
IsCharLowerW(
    __in WCHAR ch);
#ifdef UNICODE
#define IsCharLower  IsCharLowerW
#else
#define IsCharLower  IsCharLowerA
#endif // !UNICODE

#endif  /* !NOLANGUAGE */

WINUSERAPI
HWND
WINAPI
SetFocus(
    __in_opt HWND hWnd);

WINUSERAPI
HWND
WINAPI
GetActiveWindow(
    VOID);

WINUSERAPI
HWND
WINAPI
GetFocus(
    VOID);

WINUSERAPI
UINT
WINAPI
GetKBCodePage(
    VOID);

WINUSERAPI
SHORT
WINAPI
GetKeyState(
    __in int nVirtKey);

WINUSERAPI
SHORT
WINAPI
GetAsyncKeyState(
    __in int vKey);

WINUSERAPI
BOOL
WINAPI
GetKeyboardState(
    __out_ecount(256) PBYTE lpKeyState);

WINUSERAPI
BOOL
WINAPI
SetKeyboardState(
    __in_ecount(256) LPBYTE lpKeyState);

WINUSERAPI
int
WINAPI
GetKeyNameTextA(
    __in LONG lParam,
    __out_ecount(cchSize) LPSTR lpString,
    __in int cchSize);
WINUSERAPI
int
WINAPI
GetKeyNameTextW(
    __in LONG lParam,
    __out_ecount(cchSize) LPWSTR lpString,
    __in int cchSize);
#ifdef UNICODE
#define GetKeyNameText  GetKeyNameTextW
#else
#define GetKeyNameText  GetKeyNameTextA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
GetKeyboardType(
    __in int nTypeFlag);

WINUSERAPI
int
WINAPI
ToAscii(
    __in UINT uVirtKey,
    __in UINT uScanCode,
    __in_ecount_opt(256) CONST BYTE *lpKeyState,
    __out LPWORD lpChar,
    __in UINT uFlags);

#if(WINVER >= 0x0400)
WINUSERAPI
int
WINAPI
ToAsciiEx(
    __in UINT uVirtKey,
    __in UINT uScanCode,
    __in_ecount_opt(256) CONST BYTE *lpKeyState,
    __out LPWORD lpChar,
    __in UINT uFlags,
    __in_opt HKL dwhkl);
#endif /* WINVER >= 0x0400 */

WINUSERAPI
int
WINAPI
ToUnicode(
    __in UINT wVirtKey,
    __in UINT wScanCode,
    __in_bcount_opt(256) CONST BYTE *lpKeyState,
    __out_ecount(cchBuff) LPWSTR pwszBuff,
    __in int cchBuff,
    __in UINT wFlags);

WINUSERAPI
DWORD
WINAPI
OemKeyScan(
    __in WORD wOemChar);

WINUSERAPI
SHORT
WINAPI
VkKeyScanA(
    __in CHAR ch);
WINUSERAPI
SHORT
WINAPI
VkKeyScanW(
    __in WCHAR ch);
#ifdef UNICODE
#define VkKeyScan  VkKeyScanW
#else
#define VkKeyScan  VkKeyScanA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI
SHORT
WINAPI
VkKeyScanExA(
    __in CHAR ch,
    __in HKL dwhkl);
WINUSERAPI
SHORT
WINAPI
VkKeyScanExW(
    __in WCHAR ch,
    __in HKL dwhkl);
#ifdef UNICODE
#define VkKeyScanEx  VkKeyScanExW
#else
#define VkKeyScanEx  VkKeyScanExA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */
#define KEYEVENTF_EXTENDEDKEY 0x0001
#define KEYEVENTF_KEYUP       0x0002
#if(_WIN32_WINNT >= 0x0500)
#define KEYEVENTF_UNICODE     0x0004
#define KEYEVENTF_SCANCODE    0x0008
#endif /* _WIN32_WINNT >= 0x0500 */

WINUSERAPI
VOID
WINAPI
keybd_event(
    __in BYTE bVk,
    __in BYTE bScan,
    __in DWORD dwFlags,
    __in ULONG_PTR dwExtraInfo);

#define MOUSEEVENTF_MOVE        0x0001 /* mouse move */
#define MOUSEEVENTF_LEFTDOWN    0x0002 /* left button down */
#define MOUSEEVENTF_LEFTUP      0x0004 /* left button up */
#define MOUSEEVENTF_RIGHTDOWN   0x0008 /* right button down */
#define MOUSEEVENTF_RIGHTUP     0x0010 /* right button up */
#define MOUSEEVENTF_MIDDLEDOWN  0x0020 /* middle button down */
#define MOUSEEVENTF_MIDDLEUP    0x0040 /* middle button up */
#define MOUSEEVENTF_XDOWN       0x0080 /* x button down */
#define MOUSEEVENTF_XUP         0x0100 /* x button down */
#define MOUSEEVENTF_WHEEL       0x0800 /* wheel button rolled */
#if (_WIN32_WINNT >= 0x0600)
#define MOUSEEVENTF_HWHEEL      0x01000 /* hwheel button rolled */
#endif
#if(WINVER >= 0x0600)
#define MOUSEEVENTF_MOVE_NOCOALESCE 0x2000 /* do not coalesce mouse moves */
#endif /* WINVER >= 0x0600 */
#define MOUSEEVENTF_VIRTUALDESK 0x4000 /* map to entire virtual desktop */
#define MOUSEEVENTF_ABSOLUTE    0x8000 /* absolute move */

WINUSERAPI
VOID
WINAPI
mouse_event(
    __in DWORD dwFlags,
    __in DWORD dx,
    __in DWORD dy,
    __in DWORD dwData,
    __in ULONG_PTR dwExtraInfo);

#if (_WIN32_WINNT > 0x0400)

typedef struct tagMOUSEINPUT {
    LONG    dx;
    LONG    dy;
    DWORD   mouseData;
    DWORD   dwFlags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} MOUSEINPUT, *PMOUSEINPUT, FAR* LPMOUSEINPUT;

typedef struct tagKEYBDINPUT {
    WORD    wVk;
    WORD    wScan;
    DWORD   dwFlags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} KEYBDINPUT, *PKEYBDINPUT, FAR* LPKEYBDINPUT;

typedef struct tagHARDWAREINPUT {
    DWORD   uMsg;
    WORD    wParamL;
    WORD    wParamH;
} HARDWAREINPUT, *PHARDWAREINPUT, FAR* LPHARDWAREINPUT;

#define INPUT_MOUSE     0
#define INPUT_KEYBOARD  1
#define INPUT_HARDWARE  2

typedef struct tagINPUT {
    DWORD   type;

    union
    {
        MOUSEINPUT      mi;
        KEYBDINPUT      ki;
        HARDWAREINPUT   hi;
    };
} INPUT, *PINPUT, FAR* LPINPUT;

WINUSERAPI
UINT
WINAPI
SendInput(
    __in UINT cInputs,                     // number of input in the array
    __in_ecount(cInputs) LPINPUT pInputs,  // array of inputs
    __in int cbSize);                      // sizeof(INPUT)

#endif // (_WIN32_WINNT > 0x0400)

#if(WINVER >= 0x0601)

/*
 * Touch Input defines and functions
 */

/*
 * Touch input handle
 */
DECLARE_HANDLE(HTOUCHINPUT);

typedef struct tagTOUCHINPUT {
    LONG x;
    LONG y;
    HANDLE hSource;
    DWORD dwID;
    DWORD dwFlags;
    DWORD dwMask;
    DWORD dwTime;
    ULONG_PTR dwExtraInfo;
    DWORD cxContact;
    DWORD cyContact;
} TOUCHINPUT, *PTOUCHINPUT;
typedef TOUCHINPUT const * PCTOUCHINPUT;


/*
 * Conversion of touch input coordinates to pixels
 */
#define TOUCH_COORD_TO_PIXEL(l)         ((l) / 100)

/*
 * Touch input flag values (TOUCHINPUT.dwFlags)
 */
#define TOUCHEVENTF_MOVE            0x0001
#define TOUCHEVENTF_DOWN            0x0002
#define TOUCHEVENTF_UP              0x0004
#define TOUCHEVENTF_INRANGE         0x0008
#define TOUCHEVENTF_PRIMARY         0x0010
#define TOUCHEVENTF_NOCOALESCE      0x0020
#define TOUCHEVENTF_PEN             0x0040
#define TOUCHEVENTF_PALM            0x0080

/*
 * Touch input mask values (TOUCHINPUT.dwMask)
 */
#define TOUCHINPUTMASKF_TIMEFROMSYSTEM  0x0001  // the dwTime field contains a system generated value
#define TOUCHINPUTMASKF_EXTRAINFO       0x0002  // the dwExtraInfo field is valid
#define TOUCHINPUTMASKF_CONTACTAREA     0x0004  // the cxContact and cyContact fields are valid

WINUSERAPI
BOOL
WINAPI
GetTouchInputInfo(
    __in HTOUCHINPUT hTouchInput,               // input event handle; from touch message lParam
    __in UINT cInputs,                          // number of elements in the array
    __out_ecount(cInputs) PTOUCHINPUT pInputs,  // array of touch inputs
    __in int cbSize);                           // sizeof(TOUCHINPUT)

WINUSERAPI
BOOL
WINAPI
CloseTouchInputHandle(
    __in HTOUCHINPUT hTouchInput);                   // input event handle; from touch message lParam


/*
 * RegisterTouchWindow flag values
 */
#define TWF_FINETOUCH       (0x00000001)
#define TWF_WANTPALM        (0x00000002)

WINUSERAPI
BOOL
WINAPI
RegisterTouchWindow(
    __in HWND hwnd,
    __in ULONG ulFlags);

WINUSERAPI
BOOL
WINAPI
UnregisterTouchWindow(
    __in HWND hwnd);

WINUSERAPI
BOOL
WINAPI
IsTouchWindow(
    __in HWND hwnd,
    __out_opt PULONG pulFlags);

#endif /* WINVER >= 0x0601 */

#if(_WIN32_WINNT >= 0x0500)
typedef struct tagLASTINPUTINFO {
    UINT cbSize;
    DWORD dwTime;
} LASTINPUTINFO, * PLASTINPUTINFO;

WINUSERAPI
BOOL
WINAPI
GetLastInputInfo(
    __out PLASTINPUTINFO plii);
#endif /* _WIN32_WINNT >= 0x0500 */

WINUSERAPI
UINT
WINAPI
MapVirtualKeyA(
    __in UINT uCode,
    __in UINT uMapType);
WINUSERAPI
UINT
WINAPI
MapVirtualKeyW(
    __in UINT uCode,
    __in UINT uMapType);
#ifdef UNICODE
#define MapVirtualKey  MapVirtualKeyW
#else
#define MapVirtualKey  MapVirtualKeyA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI
UINT
WINAPI
MapVirtualKeyExA(
    __in UINT uCode,
    __in UINT uMapType,
    __in_opt HKL dwhkl);
WINUSERAPI
UINT
WINAPI
MapVirtualKeyExW(
    __in UINT uCode,
    __in UINT uMapType,
    __in_opt HKL dwhkl);
#ifdef UNICODE
#define MapVirtualKeyEx  MapVirtualKeyExW
#else
#define MapVirtualKeyEx  MapVirtualKeyExA
#endif // !UNICODE

#define MAPVK_VK_TO_VSC     (0)
#define MAPVK_VSC_TO_VK     (1)
#define MAPVK_VK_TO_CHAR    (2)
#define MAPVK_VSC_TO_VK_EX  (3)
#endif /* WINVER >= 0x0400 */
#if(WINVER >= 0x0600)
#define MAPVK_VK_TO_VSC_EX  (4)
#endif /* WINVER >= 0x0600 */

WINUSERAPI
BOOL
WINAPI
GetInputState(
    VOID);

WINUSERAPI
DWORD
WINAPI
GetQueueStatus(
    __in UINT flags);


WINUSERAPI
HWND
WINAPI
GetCapture(
    VOID);

WINUSERAPI
HWND
WINAPI
SetCapture(
    __in HWND hWnd);

WINUSERAPI
BOOL
WINAPI
ReleaseCapture(
    VOID);

WINUSERAPI
DWORD
WINAPI
MsgWaitForMultipleObjects(
    __in DWORD nCount,
    __in_ecount_opt(nCount) CONST HANDLE *pHandles,
    __in BOOL fWaitAll,
    __in DWORD dwMilliseconds,
    __in DWORD dwWakeMask);

WINUSERAPI
DWORD
WINAPI
MsgWaitForMultipleObjectsEx(
    __in DWORD nCount,
    __in_ecount_opt(nCount) CONST HANDLE *pHandles,
    __in DWORD dwMilliseconds,
    __in DWORD dwWakeMask,
    __in DWORD dwFlags);


#define MWMO_WAITALL        0x0001
#define MWMO_ALERTABLE      0x0002
#define MWMO_INPUTAVAILABLE 0x0004

/*
 * Queue status flags for GetQueueStatus() and MsgWaitForMultipleObjects()
 */
#define QS_KEY              0x0001
#define QS_MOUSEMOVE        0x0002
#define QS_MOUSEBUTTON      0x0004
#define QS_POSTMESSAGE      0x0008
#define QS_TIMER            0x0010
#define QS_PAINT            0x0020
#define QS_SENDMESSAGE      0x0040
#define QS_HOTKEY           0x0080
#define QS_ALLPOSTMESSAGE   0x0100
#if(_WIN32_WINNT >= 0x0501)
#define QS_RAWINPUT         0x0400
#endif /* _WIN32_WINNT >= 0x0501 */

#define QS_MOUSE           (QS_MOUSEMOVE     | \
                            QS_MOUSEBUTTON)

#if (_WIN32_WINNT >= 0x0501)
#define QS_INPUT           (QS_MOUSE         | \
                            QS_KEY           | \
                            QS_RAWINPUT)
#else
#define QS_INPUT           (QS_MOUSE         | \
                            QS_KEY)
#endif // (_WIN32_WINNT >= 0x0501)

#define QS_ALLEVENTS       (QS_INPUT         | \
                            QS_POSTMESSAGE   | \
                            QS_TIMER         | \
                            QS_PAINT         | \
                            QS_HOTKEY)

#define QS_ALLINPUT        (QS_INPUT         | \
                            QS_POSTMESSAGE   | \
                            QS_TIMER         | \
                            QS_PAINT         | \
                            QS_HOTKEY        | \
                            QS_SENDMESSAGE)


#define USER_TIMER_MAXIMUM  0x7FFFFFFF
#define USER_TIMER_MINIMUM  0x0000000A

/*
 * Windows Functions
 */

WINUSERAPI
UINT_PTR
WINAPI
SetTimer(
    __in_opt HWND hWnd,
    __in UINT_PTR nIDEvent,
    __in UINT uElapse,
    __in_opt TIMERPROC lpTimerFunc);

WINUSERAPI
BOOL
WINAPI
KillTimer(
    __in_opt HWND hWnd,
    __in UINT_PTR uIDEvent);

WINUSERAPI
BOOL
WINAPI
IsWindowUnicode(
    __in HWND hWnd);

WINUSERAPI
BOOL
WINAPI
EnableWindow(
    __in HWND hWnd,
    __in BOOL bEnable);

WINUSERAPI
BOOL
WINAPI
IsWindowEnabled(
    __in HWND hWnd);

WINUSERAPI
HACCEL
WINAPI
LoadAcceleratorsA(
    __in_opt HINSTANCE hInstance,
    __in LPCSTR lpTableName);
WINUSERAPI
HACCEL
WINAPI
LoadAcceleratorsW(
    __in_opt HINSTANCE hInstance,
    __in LPCWSTR lpTableName);
#ifdef UNICODE
#define LoadAccelerators  LoadAcceleratorsW
#else
#define LoadAccelerators  LoadAcceleratorsA
#endif // !UNICODE

WINUSERAPI
HACCEL
WINAPI
CreateAcceleratorTableA(
    __in_ecount(cAccel) LPACCEL paccel,
    __in int cAccel);
WINUSERAPI
HACCEL
WINAPI
CreateAcceleratorTableW(
    __in_ecount(cAccel) LPACCEL paccel,
    __in int cAccel);
#ifdef UNICODE
#define CreateAcceleratorTable  CreateAcceleratorTableW
#else
#define CreateAcceleratorTable  CreateAcceleratorTableA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
DestroyAcceleratorTable(
    __in HACCEL hAccel);

WINUSERAPI
int
WINAPI
CopyAcceleratorTableA(
    __in HACCEL hAccelSrc,
    __out_ecount_part_opt(cAccelEntries, return) LPACCEL lpAccelDst,
    __in int cAccelEntries);
WINUSERAPI
int
WINAPI
CopyAcceleratorTableW(
    __in HACCEL hAccelSrc,
    __out_ecount_part_opt(cAccelEntries, return) LPACCEL lpAccelDst,
    __in int cAccelEntries);
#ifdef UNICODE
#define CopyAcceleratorTable  CopyAcceleratorTableW
#else
#define CopyAcceleratorTable  CopyAcceleratorTableA
#endif // !UNICODE

#ifndef NOMSG

WINUSERAPI
int
WINAPI
TranslateAcceleratorA(
    __in HWND hWnd,
    __in HACCEL hAccTable,
    __in LPMSG lpMsg);
WINUSERAPI
int
WINAPI
TranslateAcceleratorW(
    __in HWND hWnd,
    __in HACCEL hAccTable,
    __in LPMSG lpMsg);
#ifdef UNICODE
#define TranslateAccelerator  TranslateAcceleratorW
#else
#define TranslateAccelerator  TranslateAcceleratorA
#endif // !UNICODE

#endif /* !NOMSG */

#ifndef NOSYSMETRICS

/*
 * GetSystemMetrics() codes
 */

#define SM_CXSCREEN             0
#define SM_CYSCREEN             1
#define SM_CXVSCROLL            2
#define SM_CYHSCROLL            3
#define SM_CYCAPTION            4
#define SM_CXBORDER             5
#define SM_CYBORDER             6
#define SM_CXDLGFRAME           7
#define SM_CYDLGFRAME           8
#define SM_CYVTHUMB             9
#define SM_CXHTHUMB             10
#define SM_CXICON               11
#define SM_CYICON               12
#define SM_CXCURSOR             13
#define SM_CYCURSOR             14
#define SM_CYMENU               15
#define SM_CXFULLSCREEN         16
#define SM_CYFULLSCREEN         17
#define SM_CYKANJIWINDOW        18
#define SM_MOUSEPRESENT         19
#define SM_CYVSCROLL            20
#define SM_CXHSCROLL            21
#define SM_DEBUG                22
#define SM_SWAPBUTTON           23
#define SM_RESERVED1            24
#define SM_RESERVED2            25
#define SM_RESERVED3            26
#define SM_RESERVED4            27
#define SM_CXMIN                28
#define SM_CYMIN                29
#define SM_CXSIZE               30
#define SM_CYSIZE               31
#define SM_CXFRAME              32
#define SM_CYFRAME              33
#define SM_CXMINTRACK           34
#define SM_CYMINTRACK           35
#define SM_CXDOUBLECLK          36
#define SM_CYDOUBLECLK          37
#define SM_CXICONSPACING        38
#define SM_CYICONSPACING        39
#define SM_MENUDROPALIGNMENT    40
#define SM_PENWINDOWS           41
#define SM_DBCSENABLED          42
#define SM_CMOUSEBUTTONS        43

#if(WINVER >= 0x0400)
#define SM_CXFIXEDFRAME           SM_CXDLGFRAME  /* ;win40 name change */
#define SM_CYFIXEDFRAME           SM_CYDLGFRAME  /* ;win40 name change */
#define SM_CXSIZEFRAME            SM_CXFRAME     /* ;win40 name change */
#define SM_CYSIZEFRAME            SM_CYFRAME     /* ;win40 name change */

#define SM_SECURE               44
#define SM_CXEDGE               45
#define SM_CYEDGE               46
#define SM_CXMINSPACING         47
#define SM_CYMINSPACING         48
#define SM_CXSMICON             49
#define SM_CYSMICON             50
#define SM_CYSMCAPTION          51
#define SM_CXSMSIZE             52
#define SM_CYSMSIZE             53
#define SM_CXMENUSIZE           54
#define SM_CYMENUSIZE           55
#define SM_ARRANGE              56
#define SM_CXMINIMIZED          57
#define SM_CYMINIMIZED          58
#define SM_CXMAXTRACK           59
#define SM_CYMAXTRACK           60
#define SM_CXMAXIMIZED          61
#define SM_CYMAXIMIZED          62
#define SM_NETWORK              63
#define SM_CLEANBOOT            67
#define SM_CXDRAG               68
#define SM_CYDRAG               69
#endif /* WINVER >= 0x0400 */
#define SM_SHOWSOUNDS           70
#if(WINVER >= 0x0400)
#define SM_CXMENUCHECK          71   /* Use instead of GetMenuCheckMarkDimensions()! */
#define SM_CYMENUCHECK          72
#define SM_SLOWMACHINE          73
#define SM_MIDEASTENABLED       74
#endif /* WINVER >= 0x0400 */

#if (WINVER >= 0x0500) || (_WIN32_WINNT >= 0x0400)
#define SM_MOUSEWHEELPRESENT    75
#endif
#if(WINVER >= 0x0500)
#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80
#define SM_SAMEDISPLAYFORMAT    81
#endif /* WINVER >= 0x0500 */
#if(_WIN32_WINNT >= 0x0500)
#define SM_IMMENABLED           82
#endif /* _WIN32_WINNT >= 0x0500 */
#if(_WIN32_WINNT >= 0x0501)
#define SM_CXFOCUSBORDER        83
#define SM_CYFOCUSBORDER        84
#endif /* _WIN32_WINNT >= 0x0501 */

#if(_WIN32_WINNT >= 0x0501)
#define SM_TABLETPC             86
#define SM_MEDIACENTER          87
#define SM_STARTER              88
#define SM_SERVERR2             89
#endif /* _WIN32_WINNT >= 0x0501 */

#if(_WIN32_WINNT >= 0x0600)
#define SM_MOUSEHORIZONTALWHEELPRESENT    91
#define SM_CXPADDEDBORDER       92
#endif /* _WIN32_WINNT >= 0x0600 */

#if(WINVER >= 0x0601)

#define SM_DIGITIZER            94
#define SM_MAXIMUMTOUCHES       95
#endif /* WINVER >= 0x0601 */

#if (WINVER < 0x0500) && (!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0400))
#define SM_CMETRICS             76
#elif WINVER == 0x500
#define SM_CMETRICS             83
#elif WINVER == 0x501
#define SM_CMETRICS             91
#elif WINVER == 0x600
#define SM_CMETRICS             93
#else
#define SM_CMETRICS             97
#endif

#if(WINVER >= 0x0500)
#define SM_REMOTESESSION        0x1000


#if(_WIN32_WINNT >= 0x0501)
#define SM_SHUTTINGDOWN         0x2000
#endif /* _WIN32_WINNT >= 0x0501 */

#if(WINVER >= 0x0501)
#define SM_REMOTECONTROL        0x2001
#endif /* WINVER >= 0x0501 */

#if(WINVER >= 0x0501)
#define SM_CARETBLINKINGENABLED 0x2002
#endif /* WINVER >= 0x0501 */

#endif /* WINVER >= 0x0500 */


WINUSERAPI
int
WINAPI
GetSystemMetrics(
    __in int nIndex);


#endif /* !NOSYSMETRICS */

#ifndef NOMENUS

WINUSERAPI
HMENU
WINAPI
LoadMenuA(
    __in_opt HINSTANCE hInstance,
    __in LPCSTR lpMenuName);
WINUSERAPI
HMENU
WINAPI
LoadMenuW(
    __in_opt HINSTANCE hInstance,
    __in LPCWSTR lpMenuName);
#ifdef UNICODE
#define LoadMenu  LoadMenuW
#else
#define LoadMenu  LoadMenuA
#endif // !UNICODE

WINUSERAPI
HMENU
WINAPI
LoadMenuIndirectA(
    __in CONST MENUTEMPLATEA *lpMenuTemplate);
WINUSERAPI
HMENU
WINAPI
LoadMenuIndirectW(
    __in CONST MENUTEMPLATEW *lpMenuTemplate);
#ifdef UNICODE
#define LoadMenuIndirect  LoadMenuIndirectW
#else
#define LoadMenuIndirect  LoadMenuIndirectA
#endif // !UNICODE

WINUSERAPI
HMENU
WINAPI
GetMenu(
    __in HWND hWnd);

WINUSERAPI
BOOL
WINAPI
SetMenu(
    __in HWND hWnd,
    __in_opt HMENU hMenu);

WINUSERAPI
BOOL
WINAPI
ChangeMenuA(
    __in HMENU hMenu,
    __in UINT cmd,
    __in_opt LPCSTR lpszNewItem,
    __in UINT cmdInsert,
    __in UINT flags);
WINUSERAPI
BOOL
WINAPI
ChangeMenuW(
    __in HMENU hMenu,
    __in UINT cmd,
    __in_opt LPCWSTR lpszNewItem,
    __in UINT cmdInsert,
    __in UINT flags);
#ifdef UNICODE
#define ChangeMenu  ChangeMenuW
#else
#define ChangeMenu  ChangeMenuA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
HiliteMenuItem(
    __in HWND hWnd,
    __in HMENU hMenu,
    __in UINT uIDHiliteItem,
    __in UINT uHilite);

WINUSERAPI
int
WINAPI
GetMenuStringA(
    __in HMENU hMenu,
    __in UINT uIDItem,
    __out_ecount_opt(cchMax) LPSTR lpString,
    __in int cchMax,
    __in UINT flags);
WINUSERAPI
int
WINAPI
GetMenuStringW(
    __in HMENU hMenu,
    __in UINT uIDItem,
    __out_ecount_opt(cchMax) LPWSTR lpString,
    __in int cchMax,
    __in UINT flags);
#ifdef UNICODE
#define GetMenuString  GetMenuStringW
#else
#define GetMenuString  GetMenuStringA
#endif // !UNICODE

WINUSERAPI
UINT
WINAPI
GetMenuState(
    __in HMENU hMenu,
    __in UINT uId,
    __in UINT uFlags);

WINUSERAPI
BOOL
WINAPI
DrawMenuBar(
    __in HWND hWnd);

#if(_WIN32_WINNT >= 0x0501)
#define PMB_ACTIVE      0x00000001

#endif /* _WIN32_WINNT >= 0x0501 */


WINUSERAPI
HMENU
WINAPI
GetSystemMenu(
    __in HWND hWnd,
    __in BOOL bRevert);


WINUSERAPI
HMENU
WINAPI
CreateMenu(
    VOID);

WINUSERAPI
HMENU
WINAPI
CreatePopupMenu(
    VOID);

WINUSERAPI
BOOL
WINAPI
DestroyMenu(
    __in HMENU hMenu);

WINUSERAPI
DWORD
WINAPI
CheckMenuItem(
    __in HMENU hMenu,
    __in UINT uIDCheckItem,
    __in UINT uCheck);

WINUSERAPI
BOOL
WINAPI
EnableMenuItem(
    __in HMENU hMenu,
    __in UINT uIDEnableItem,
    __in UINT uEnable);

WINUSERAPI
HMENU
WINAPI
GetSubMenu(
    __in HMENU hMenu,
    __in int nPos);

WINUSERAPI
UINT
WINAPI
GetMenuItemID(
    __in HMENU hMenu,
    __in int nPos);

WINUSERAPI
int
WINAPI
GetMenuItemCount(
    __in_opt HMENU hMenu);

WINUSERAPI
BOOL
WINAPI
InsertMenuA(
    __in HMENU hMenu,
    __in UINT uPosition,
    __in UINT uFlags,
    __in UINT_PTR uIDNewItem,
    __in_opt LPCSTR lpNewItem);
WINUSERAPI
BOOL
WINAPI
InsertMenuW(
    __in HMENU hMenu,
    __in UINT uPosition,
    __in UINT uFlags,
    __in UINT_PTR uIDNewItem,
    __in_opt LPCWSTR lpNewItem);
#ifdef UNICODE
#define InsertMenu  InsertMenuW
#else
#define InsertMenu  InsertMenuA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
AppendMenuA(
    __in HMENU hMenu,
    __in UINT uFlags,
    __in UINT_PTR uIDNewItem,
    __in_opt LPCSTR lpNewItem);
WINUSERAPI
BOOL
WINAPI
AppendMenuW(
    __in HMENU hMenu,
    __in UINT uFlags,
    __in UINT_PTR uIDNewItem,
    __in_opt LPCWSTR lpNewItem);
#ifdef UNICODE
#define AppendMenu  AppendMenuW
#else
#define AppendMenu  AppendMenuA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
ModifyMenuA(
    __in HMENU hMnu,
    __in UINT uPosition,
    __in UINT uFlags,
    __in UINT_PTR uIDNewItem,
    __in_opt LPCSTR lpNewItem);
WINUSERAPI
BOOL
WINAPI
ModifyMenuW(
    __in HMENU hMnu,
    __in UINT uPosition,
    __in UINT uFlags,
    __in UINT_PTR uIDNewItem,
    __in_opt LPCWSTR lpNewItem);
#ifdef UNICODE
#define ModifyMenu  ModifyMenuW
#else
#define ModifyMenu  ModifyMenuA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI RemoveMenu(
    __in HMENU hMenu,
    __in UINT uPosition,
    __in UINT uFlags);

WINUSERAPI
BOOL
WINAPI
DeleteMenu(
    __in HMENU hMenu,
    __in UINT uPosition,
    __in UINT uFlags);

WINUSERAPI
BOOL
WINAPI
SetMenuItemBitmaps(
    __in HMENU hMenu,
    __in UINT uPosition,
    __in UINT uFlags,
    __in_opt HBITMAP hBitmapUnchecked,
    __in_opt HBITMAP hBitmapChecked);

WINUSERAPI
LONG
WINAPI
GetMenuCheckMarkDimensions(
    VOID);

WINUSERAPI
BOOL
WINAPI
TrackPopupMenu(
    __in HMENU hMenu,
    __in UINT uFlags,
    __in int x,
    __in int y,
    __in int nReserved,
    __in HWND hWnd,
    __in_opt CONST RECT *prcRect);

#if(WINVER >= 0x0400)
/* return codes for WM_MENUCHAR */
#define MNC_IGNORE  0
#define MNC_CLOSE   1
#define MNC_EXECUTE 2
#define MNC_SELECT  3

typedef struct tagTPMPARAMS
{
    UINT    cbSize;     /* Size of structure */
    RECT    rcExclude;  /* Screen coordinates of rectangle to exclude when positioning */
}   TPMPARAMS;
typedef TPMPARAMS FAR *LPTPMPARAMS;

WINUSERAPI
BOOL
WINAPI
TrackPopupMenuEx(
    __in HMENU,
    __in UINT,
    __in int,
    __in int,
    __in HWND,
    __in_opt LPTPMPARAMS);
#endif /* WINVER >= 0x0400 */

#if(_WIN32_WINNT >= 0x0601)
WINUSERAPI
BOOL
WINAPI
CalculatePopupWindowPosition(
    __in const POINT *anchorPoint,
    __in const SIZE *windowSize,
    __in UINT /* TPM_XXX values */ flags,
    __in_opt RECT *excludeRect,
    __out RECT *popupWindowPosition);

#endif /* _WIN32_WINNT >= 0x0601 */

#if(WINVER >= 0x0500)

#define MNS_NOCHECK         0x80000000
#define MNS_MODELESS        0x40000000
#define MNS_DRAGDROP        0x20000000
#define MNS_AUTODISMISS     0x10000000
#define MNS_NOTIFYBYPOS     0x08000000
#define MNS_CHECKORBMP      0x04000000

#define MIM_MAXHEIGHT               0x00000001
#define MIM_BACKGROUND              0x00000002
#define MIM_HELPID                  0x00000004
#define MIM_MENUDATA                0x00000008
#define MIM_STYLE                   0x00000010
#define MIM_APPLYTOSUBMENUS         0x80000000

typedef struct tagMENUINFO
{
    DWORD   cbSize;
    DWORD   fMask;
    DWORD   dwStyle;
    UINT    cyMax;
    HBRUSH  hbrBack;
    DWORD   dwContextHelpID;
    ULONG_PTR dwMenuData;
}   MENUINFO, FAR *LPMENUINFO;
typedef MENUINFO CONST FAR *LPCMENUINFO;

WINUSERAPI
BOOL
WINAPI
GetMenuInfo(
    __in HMENU,
    __inout LPMENUINFO);

WINUSERAPI
BOOL
WINAPI
SetMenuInfo(
    __in HMENU,
    __in LPCMENUINFO);

WINUSERAPI
BOOL
WINAPI
EndMenu(
        VOID);

/*
 * WM_MENUDRAG return values.
 */
#define MND_CONTINUE       0
#define MND_ENDMENU        1

typedef struct tagMENUGETOBJECTINFO
{
    DWORD dwFlags;
    UINT uPos;
    HMENU hmenu;
    PVOID riid;
    PVOID pvObj;
} MENUGETOBJECTINFO, * PMENUGETOBJECTINFO;

/*
 * MENUGETOBJECTINFO dwFlags values
 */
#define MNGOF_TOPGAP         0x00000001
#define MNGOF_BOTTOMGAP      0x00000002

/*
 * WM_MENUGETOBJECT return values
 */
#define MNGO_NOINTERFACE     0x00000000
#define MNGO_NOERROR         0x00000001
#endif /* WINVER >= 0x0500 */

#if(WINVER >= 0x0400)
#define MIIM_STATE       0x00000001
#define MIIM_ID          0x00000002
#define MIIM_SUBMENU     0x00000004
#define MIIM_CHECKMARKS  0x00000008
#define MIIM_TYPE        0x00000010
#define MIIM_DATA        0x00000020
#endif /* WINVER >= 0x0400 */

#if(WINVER >= 0x0500)
#define MIIM_STRING      0x00000040
#define MIIM_BITMAP      0x00000080
#define MIIM_FTYPE       0x00000100

#define HBMMENU_CALLBACK            ((HBITMAP) -1)
#define HBMMENU_SYSTEM              ((HBITMAP)  1)
#define HBMMENU_MBAR_RESTORE        ((HBITMAP)  2)
#define HBMMENU_MBAR_MINIMIZE       ((HBITMAP)  3)
#define HBMMENU_MBAR_CLOSE          ((HBITMAP)  5)
#define HBMMENU_MBAR_CLOSE_D        ((HBITMAP)  6)
#define HBMMENU_MBAR_MINIMIZE_D     ((HBITMAP)  7)
#define HBMMENU_POPUP_CLOSE         ((HBITMAP)  8)
#define HBMMENU_POPUP_RESTORE       ((HBITMAP)  9)
#define HBMMENU_POPUP_MAXIMIZE      ((HBITMAP) 10)
#define HBMMENU_POPUP_MINIMIZE      ((HBITMAP) 11)
#endif /* WINVER >= 0x0500 */

#if(WINVER >= 0x0400)
typedef struct tagMENUITEMINFOA
{
    UINT     cbSize;
    UINT     fMask;
    UINT     fType;         // used if MIIM_TYPE (4.0) or MIIM_FTYPE (>4.0)
    UINT     fState;        // used if MIIM_STATE
    UINT     wID;           // used if MIIM_ID
    HMENU    hSubMenu;      // used if MIIM_SUBMENU
    HBITMAP  hbmpChecked;   // used if MIIM_CHECKMARKS
    HBITMAP  hbmpUnchecked; // used if MIIM_CHECKMARKS
    ULONG_PTR dwItemData;   // used if MIIM_DATA
    __field_ecount_opt(cch) LPSTR    dwTypeData;    // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    UINT     cch;           // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
#if(WINVER >= 0x0500)
    HBITMAP  hbmpItem;      // used if MIIM_BITMAP
#endif /* WINVER >= 0x0500 */
}   MENUITEMINFOA, FAR *LPMENUITEMINFOA;
typedef struct tagMENUITEMINFOW
{
    UINT     cbSize;
    UINT     fMask;
    UINT     fType;         // used if MIIM_TYPE (4.0) or MIIM_FTYPE (>4.0)
    UINT     fState;        // used if MIIM_STATE
    UINT     wID;           // used if MIIM_ID
    HMENU    hSubMenu;      // used if MIIM_SUBMENU
    HBITMAP  hbmpChecked;   // used if MIIM_CHECKMARKS
    HBITMAP  hbmpUnchecked; // used if MIIM_CHECKMARKS
    ULONG_PTR dwItemData;   // used if MIIM_DATA
    __field_ecount_opt(cch) LPWSTR   dwTypeData;    // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    UINT     cch;           // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
#if(WINVER >= 0x0500)
    HBITMAP  hbmpItem;      // used if MIIM_BITMAP
#endif /* WINVER >= 0x0500 */
}   MENUITEMINFOW, FAR *LPMENUITEMINFOW;
#ifdef UNICODE
typedef MENUITEMINFOW MENUITEMINFO;
typedef LPMENUITEMINFOW LPMENUITEMINFO;
#else
typedef MENUITEMINFOA MENUITEMINFO;
typedef LPMENUITEMINFOA LPMENUITEMINFO;
#endif // UNICODE
typedef MENUITEMINFOA CONST FAR *LPCMENUITEMINFOA;
typedef MENUITEMINFOW CONST FAR *LPCMENUITEMINFOW;
#ifdef UNICODE
typedef LPCMENUITEMINFOW LPCMENUITEMINFO;
#else
typedef LPCMENUITEMINFOA LPCMENUITEMINFO;
#endif // UNICODE


WINUSERAPI
BOOL
WINAPI
InsertMenuItemA(
    __in HMENU hmenu,
    __in UINT item,
    __in BOOL fByPosition,
    __in LPCMENUITEMINFOA lpmi);
WINUSERAPI
BOOL
WINAPI
InsertMenuItemW(
    __in HMENU hmenu,
    __in UINT item,
    __in BOOL fByPosition,
    __in LPCMENUITEMINFOW lpmi);
#ifdef UNICODE
#define InsertMenuItem  InsertMenuItemW
#else
#define InsertMenuItem  InsertMenuItemA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
GetMenuItemInfoA(
    __in HMENU hmenu,
    __in UINT item,
    __in BOOL fByPosition,
    __inout LPMENUITEMINFOA lpmii);
WINUSERAPI
BOOL
WINAPI
GetMenuItemInfoW(
    __in HMENU hmenu,
    __in UINT item,
    __in BOOL fByPosition,
    __inout LPMENUITEMINFOW lpmii);
#ifdef UNICODE
#define GetMenuItemInfo  GetMenuItemInfoW
#else
#define GetMenuItemInfo  GetMenuItemInfoA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
SetMenuItemInfoA(
    __in HMENU hmenu,
    __in UINT item,
    __in BOOL fByPositon,
    __in LPCMENUITEMINFOA lpmii);
WINUSERAPI
BOOL
WINAPI
SetMenuItemInfoW(
    __in HMENU hmenu,
    __in UINT item,
    __in BOOL fByPositon,
    __in LPCMENUITEMINFOW lpmii);
#ifdef UNICODE
#define SetMenuItemInfo  SetMenuItemInfoW
#else
#define SetMenuItemInfo  SetMenuItemInfoA
#endif // !UNICODE


#define GMDI_USEDISABLED    0x0001L
#define GMDI_GOINTOPOPUPS   0x0002L

WINUSERAPI
UINT
WINAPI
GetMenuDefaultItem(
    __in HMENU hMenu,
    __in UINT fByPos,
    __in UINT gmdiFlags);

WINUSERAPI
BOOL
WINAPI
SetMenuDefaultItem(
    __in HMENU hMenu,
    __in UINT uItem,
    __in UINT fByPos);

WINUSERAPI
BOOL
WINAPI
GetMenuItemRect(
    __in_opt HWND hWnd,
    __in HMENU hMenu,
    __in UINT uItem,
    __out LPRECT lprcItem);

WINUSERAPI
int
WINAPI
MenuItemFromPoint(
    __in_opt HWND hWnd,
    __in HMENU hMenu,
    __in POINT ptScreen);
#endif /* WINVER >= 0x0400 */

/*
 * Flags for TrackPopupMenu
 */
#define TPM_LEFTBUTTON  0x0000L
#define TPM_RIGHTBUTTON 0x0002L
#define TPM_LEFTALIGN   0x0000L
#define TPM_CENTERALIGN 0x0004L
#define TPM_RIGHTALIGN  0x0008L
#if(WINVER >= 0x0400)
#define TPM_TOPALIGN        0x0000L
#define TPM_VCENTERALIGN    0x0010L
#define TPM_BOTTOMALIGN     0x0020L

#define TPM_HORIZONTAL      0x0000L     /* Horz alignment matters more */
#define TPM_VERTICAL        0x0040L     /* Vert alignment matters more */
#define TPM_NONOTIFY        0x0080L     /* Don't send any notification msgs */
#define TPM_RETURNCMD       0x0100L
#endif /* WINVER >= 0x0400 */
#if(WINVER >= 0x0500)
#define TPM_RECURSE         0x0001L
#define TPM_HORPOSANIMATION 0x0400L
#define TPM_HORNEGANIMATION 0x0800L
#define TPM_VERPOSANIMATION 0x1000L
#define TPM_VERNEGANIMATION 0x2000L
#if(_WIN32_WINNT >= 0x0500)
#define TPM_NOANIMATION     0x4000L
#endif /* _WIN32_WINNT >= 0x0500 */
#if(_WIN32_WINNT >= 0x0501)
#define TPM_LAYOUTRTL       0x8000L
#endif /* _WIN32_WINNT >= 0x0501 */
#endif /* WINVER >= 0x0500 */
#if(_WIN32_WINNT >= 0x0601)
#define TPM_WORKAREA        0x10000L
#endif /* _WIN32_WINNT >= 0x0601 */


#endif /* !NOMENUS */


#if(WINVER >= 0x0400)
//
// Drag-and-drop support
// Obsolete - use OLE instead
//
typedef struct tagDROPSTRUCT
{
    HWND    hwndSource;
    HWND    hwndSink;
    DWORD   wFmt;
    ULONG_PTR dwData;
    POINT   ptDrop;
    DWORD   dwControlData;
} DROPSTRUCT, *PDROPSTRUCT, *LPDROPSTRUCT;

#define DOF_EXECUTABLE      0x8001      // wFmt flags
#define DOF_DOCUMENT        0x8002
#define DOF_DIRECTORY       0x8003
#define DOF_MULTIPLE        0x8004
#define DOF_PROGMAN         0x0001
#define DOF_SHELLDATA       0x0002

#define DO_DROPFILE         0x454C4946L
#define DO_PRINTFILE        0x544E5250L

WINUSERAPI
DWORD
WINAPI
DragObject(
    __in HWND hwndParent,
    __in HWND hwndFrom,
    __in UINT fmt,
    __in ULONG_PTR data,
    __in_opt HCURSOR hcur);

WINUSERAPI
BOOL
WINAPI
DragDetect(
    __in HWND hwnd,
    __in POINT pt);
#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
DrawIcon(
    __in HDC hDC,
    __in int X,
    __in int Y,
    __in HICON hIcon);

#ifndef NODRAWTEXT

/*
 * DrawText() Format Flags
 */
#define DT_TOP                      0x00000000
#define DT_LEFT                     0x00000000
#define DT_CENTER                   0x00000001
#define DT_RIGHT                    0x00000002
#define DT_VCENTER                  0x00000004
#define DT_BOTTOM                   0x00000008
#define DT_WORDBREAK                0x00000010
#define DT_SINGLELINE               0x00000020
#define DT_EXPANDTABS               0x00000040
#define DT_TABSTOP                  0x00000080
#define DT_NOCLIP                   0x00000100
#define DT_EXTERNALLEADING          0x00000200
#define DT_CALCRECT                 0x00000400
#define DT_NOPREFIX                 0x00000800
#define DT_INTERNAL                 0x00001000

#if(WINVER >= 0x0400)
#define DT_EDITCONTROL              0x00002000
#define DT_PATH_ELLIPSIS            0x00004000
#define DT_END_ELLIPSIS             0x00008000
#define DT_MODIFYSTRING             0x00010000
#define DT_RTLREADING               0x00020000
#define DT_WORD_ELLIPSIS            0x00040000
#if(WINVER >= 0x0500)
#define DT_NOFULLWIDTHCHARBREAK     0x00080000
#if(_WIN32_WINNT >= 0x0500)
#define DT_HIDEPREFIX               0x00100000
#define DT_PREFIXONLY               0x00200000
#endif /* _WIN32_WINNT >= 0x0500 */
#endif /* WINVER >= 0x0500 */

typedef struct tagDRAWTEXTPARAMS
{
    UINT    cbSize;
    int     iTabLength;
    int     iLeftMargin;
    int     iRightMargin;
    UINT    uiLengthDrawn;
} DRAWTEXTPARAMS, FAR *LPDRAWTEXTPARAMS;
#endif /* WINVER >= 0x0400 */


WINUSERAPI
int
WINAPI
DrawTextA(
    __in HDC hdc,
    __inout_ecount_opt(cchText) LPCSTR lpchText,
    __in int cchText,
    __inout LPRECT lprc,
    __in UINT format);
WINUSERAPI
int
WINAPI
DrawTextW(
    __in HDC hdc,
    __inout_ecount_opt(cchText) LPCWSTR lpchText,
    __in int cchText,
    __inout LPRECT lprc,
    __in UINT format);
#ifdef UNICODE
#define DrawText  DrawTextW
#else
#define DrawText  DrawTextA
#endif // !UNICODE

#if defined(_M_CEE)
#undef DrawText
__inline
int
DrawText(
    HDC hdc,
    LPCTSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format
    )
{
#ifdef UNICODE
    return DrawTextW(
#else
    return DrawTextA(
#endif
        hdc,
    lpchText,
    cchText,
    lprc,
    format
        );
}
#endif  /* _M_CEE */


#if(WINVER >= 0x0400)
WINUSERAPI
int
WINAPI
DrawTextExA(
    __in HDC hdc,
    __inout_ecount_opt(cchText) LPSTR lpchText,
    __in int cchText,
    __inout LPRECT lprc,
    __in UINT format,
    __in_opt LPDRAWTEXTPARAMS lpdtp);
WINUSERAPI
int
WINAPI
DrawTextExW(
    __in HDC hdc,
    __inout_ecount_opt(cchText) LPWSTR lpchText,
    __in int cchText,
    __inout LPRECT lprc,
    __in UINT format,
    __in_opt LPDRAWTEXTPARAMS lpdtp);
#ifdef UNICODE
#define DrawTextEx  DrawTextExW
#else
#define DrawTextEx  DrawTextExA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

#endif /* !NODRAWTEXT */

WINUSERAPI
BOOL
WINAPI
GrayStringA(
    __in HDC hDC,
    __in_opt HBRUSH hBrush,
    __in_opt GRAYSTRINGPROC lpOutputFunc,
    __in LPARAM lpData,
    __in int nCount,
    __in int X,
    __in int Y,
    __in int nWidth,
    __in int nHeight);
WINUSERAPI
BOOL
WINAPI
GrayStringW(
    __in HDC hDC,
    __in_opt HBRUSH hBrush,
    __in_opt GRAYSTRINGPROC lpOutputFunc,
    __in LPARAM lpData,
    __in int nCount,
    __in int X,
    __in int Y,
    __in int nWidth,
    __in int nHeight);
#ifdef UNICODE
#define GrayString  GrayStringW
#else
#define GrayString  GrayStringA
#endif // !UNICODE

#if(WINVER >= 0x0400)
/* Monolithic state-drawing routine */
/* Image type */
#define DST_COMPLEX     0x0000
#define DST_TEXT        0x0001
#define DST_PREFIXTEXT  0x0002
#define DST_ICON        0x0003
#define DST_BITMAP      0x0004

/* State type */
#define DSS_NORMAL      0x0000
#define DSS_UNION       0x0010  /* Gray string appearance */
#define DSS_DISABLED    0x0020
#define DSS_MONO        0x0080
#if(_WIN32_WINNT >= 0x0500)
#define DSS_HIDEPREFIX  0x0200
#define DSS_PREFIXONLY  0x0400
#endif /* _WIN32_WINNT >= 0x0500 */
#define DSS_RIGHT       0x8000

WINUSERAPI
BOOL
WINAPI
DrawStateA(
    __in HDC hdc,
    __in_opt HBRUSH hbrFore,
    __in_opt DRAWSTATEPROC qfnCallBack,
    __in LPARAM lData,
    __in WPARAM wData,
    __in int x,
    __in int y,
    __in int cx,
    __in int cy,
    __in UINT uFlags);
WINUSERAPI
BOOL
WINAPI
DrawStateW(
    __in HDC hdc,
    __in_opt HBRUSH hbrFore,
    __in_opt DRAWSTATEPROC qfnCallBack,
    __in LPARAM lData,
    __in WPARAM wData,
    __in int x,
    __in int y,
    __in int cx,
    __in int cy,
    __in UINT uFlags);
#ifdef UNICODE
#define DrawState  DrawStateW
#else
#define DrawState  DrawStateA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

WINUSERAPI
LONG
WINAPI
TabbedTextOutA(
    __in HDC hdc,
    __in int x,
    __in int y,
    __in_ecount(chCount) LPCSTR lpString,
    __in int chCount,
    __in int nTabPositions,
    __in_ecount_opt(nTabPositions) CONST INT *lpnTabStopPositions,
    __in int nTabOrigin);
WINUSERAPI
LONG
WINAPI
TabbedTextOutW(
    __in HDC hdc,
    __in int x,
    __in int y,
    __in_ecount(chCount) LPCWSTR lpString,
    __in int chCount,
    __in int nTabPositions,
    __in_ecount_opt(nTabPositions) CONST INT *lpnTabStopPositions,
    __in int nTabOrigin);
#ifdef UNICODE
#define TabbedTextOut  TabbedTextOutW
#else
#define TabbedTextOut  TabbedTextOutA
#endif // !UNICODE

WINUSERAPI
DWORD
WINAPI
GetTabbedTextExtentA(
    __in HDC hdc,
    __in_ecount(chCount) LPCSTR lpString,
    __in int chCount,
    __in int nTabPositions,
    __in_ecount_opt(nTabPositions) CONST INT *lpnTabStopPositions);
WINUSERAPI
DWORD
WINAPI
GetTabbedTextExtentW(
    __in HDC hdc,
    __in_ecount(chCount) LPCWSTR lpString,
    __in int chCount,
    __in int nTabPositions,
    __in_ecount_opt(nTabPositions) CONST INT *lpnTabStopPositions);
#ifdef UNICODE
#define GetTabbedTextExtent  GetTabbedTextExtentW
#else
#define GetTabbedTextExtent  GetTabbedTextExtentA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
UpdateWindow(
    __in HWND hWnd);

WINUSERAPI
HWND
WINAPI
SetActiveWindow(
    __in HWND hWnd);

WINUSERAPI
HWND
WINAPI
GetForegroundWindow(
    VOID);

#if(WINVER >= 0x0400)
WINUSERAPI
BOOL
WINAPI
PaintDesktop(
    __in HDC hdc);

WINUSERAPI
VOID
WINAPI
SwitchToThisWindow(
    __in HWND hwnd,
    __in BOOL fUnknown);
#endif /* WINVER >= 0x0400 */


WINUSERAPI
BOOL
WINAPI
SetForegroundWindow(
    __in HWND hWnd);

#if(_WIN32_WINNT >= 0x0500)
WINUSERAPI
BOOL
WINAPI
AllowSetForegroundWindow(
    __in DWORD dwProcessId);

#define ASFW_ANY    ((DWORD)-1)

WINUSERAPI
BOOL
WINAPI
LockSetForegroundWindow(
    __in UINT uLockCode);

#define LSFW_LOCK       1
#define LSFW_UNLOCK     2

#endif /* _WIN32_WINNT >= 0x0500 */

WINUSERAPI
HWND
WINAPI
WindowFromDC(
    __in HDC hDC);

WINUSERAPI
HDC
WINAPI
GetDC(
    __in_opt HWND hWnd);

WINUSERAPI
HDC
WINAPI
GetDCEx(
    __in_opt HWND hWnd,
    __in_opt HRGN hrgnClip,
    __in DWORD flags);

/*
 * GetDCEx() flags
 */
#define DCX_WINDOW           0x00000001L
#define DCX_CACHE            0x00000002L
#define DCX_NORESETATTRS     0x00000004L
#define DCX_CLIPCHILDREN     0x00000008L
#define DCX_CLIPSIBLINGS     0x00000010L
#define DCX_PARENTCLIP       0x00000020L
#define DCX_EXCLUDERGN       0x00000040L
#define DCX_INTERSECTRGN     0x00000080L
#define DCX_EXCLUDEUPDATE    0x00000100L
#define DCX_INTERSECTUPDATE  0x00000200L
#define DCX_LOCKWINDOWUPDATE 0x00000400L

#define DCX_VALIDATE         0x00200000L

WINUSERAPI
HDC
WINAPI
GetWindowDC(
    __in_opt HWND hWnd);

WINUSERAPI
int
WINAPI
ReleaseDC(
    __in_opt HWND hWnd,
    __in HDC hDC);

WINUSERAPI
HDC
WINAPI
BeginPaint(
    __in HWND hWnd,
    __out LPPAINTSTRUCT lpPaint);

WINUSERAPI
BOOL
WINAPI
EndPaint(
    __in HWND hWnd,
    __in CONST PAINTSTRUCT *lpPaint);

WINUSERAPI
BOOL
WINAPI
GetUpdateRect(
    __in HWND hWnd,
    __out_opt LPRECT lpRect,
    __in BOOL bErase);

WINUSERAPI
int
WINAPI
GetUpdateRgn(
    __in HWND hWnd,
    __in HRGN hRgn,
    __in BOOL bErase);

WINUSERAPI
int
WINAPI
SetWindowRgn(
    __in HWND hWnd,
    __in_opt HRGN hRgn,
    __in BOOL bRedraw);


WINUSERAPI
int
WINAPI
GetWindowRgn(
    __in HWND hWnd,
    __in HRGN hRgn);

#if(_WIN32_WINNT >= 0x0501)

WINUSERAPI
int
WINAPI
GetWindowRgnBox(
    __in HWND hWnd,
    __out LPRECT lprc);

#endif /* _WIN32_WINNT >= 0x0501 */

WINUSERAPI
int
WINAPI
ExcludeUpdateRgn(
    __in HDC hDC,
    __in HWND hWnd);

WINUSERAPI
BOOL
WINAPI
InvalidateRect(
    __in_opt HWND hWnd,
    __in_opt CONST RECT *lpRect,
    __in BOOL bErase);

WINUSERAPI
BOOL
WINAPI
ValidateRect(
    __in_opt HWND hWnd,
    __in_opt CONST RECT *lpRect);

WINUSERAPI
BOOL
WINAPI
InvalidateRgn(
    __in HWND hWnd,
    __in_opt HRGN hRgn,
    __in BOOL bErase);

WINUSERAPI
BOOL
WINAPI
ValidateRgn(
    __in HWND hWnd,
    __in_opt HRGN hRgn);


WINUSERAPI
BOOL
WINAPI
RedrawWindow(
    __in_opt HWND hWnd,
    __in_opt CONST RECT *lprcUpdate,
    __in_opt HRGN hrgnUpdate,
    __in UINT flags);

/*
 * RedrawWindow() flags
 */
#define RDW_INVALIDATE          0x0001
#define RDW_INTERNALPAINT       0x0002
#define RDW_ERASE               0x0004

#define RDW_VALIDATE            0x0008
#define RDW_NOINTERNALPAINT     0x0010
#define RDW_NOERASE             0x0020

#define RDW_NOCHILDREN          0x0040
#define RDW_ALLCHILDREN         0x0080

#define RDW_UPDATENOW           0x0100
#define RDW_ERASENOW            0x0200

#define RDW_FRAME               0x0400
#define RDW_NOFRAME             0x0800


/*
 * LockWindowUpdate API
 */

WINUSERAPI
BOOL
WINAPI
LockWindowUpdate(
    __in_opt HWND hWndLock);

WINUSERAPI
BOOL
WINAPI
ScrollWindow(
    __in HWND hWnd,
    __in int XAmount,
    __in int YAmount,
    __in_opt CONST RECT *lpRect,
    __in_opt CONST RECT *lpClipRect);

WINUSERAPI
BOOL
WINAPI
ScrollDC(
    __in HDC hDC,
    __in int dx,
    __in int dy,
    __in_opt CONST RECT *lprcScroll,
    __in_opt CONST RECT *lprcClip,
    __in_opt HRGN hrgnUpdate,
    __out_opt LPRECT lprcUpdate);

WINUSERAPI
int
WINAPI
ScrollWindowEx(
    __in HWND hWnd,
    __in int dx,
    __in int dy,
    __in_opt CONST RECT *prcScroll,
    __in_opt CONST RECT *prcClip,
    __in_opt HRGN hrgnUpdate,
    __out_opt LPRECT prcUpdate,
    __in UINT flags);

#define SW_SCROLLCHILDREN   0x0001  /* Scroll children within *lprcScroll. */
#define SW_INVALIDATE       0x0002  /* Invalidate after scrolling */
#define SW_ERASE            0x0004  /* If SW_INVALIDATE, don't send WM_ERASEBACKGROUND */
#if(WINVER >= 0x0500)
#define SW_SMOOTHSCROLL     0x0010  /* Use smooth scrolling */
#endif /* WINVER >= 0x0500 */

#ifndef NOSCROLL

WINUSERAPI
int
WINAPI
SetScrollPos(
    __in HWND hWnd,
    __in int nBar,
    __in int nPos,
    __in BOOL bRedraw);

WINUSERAPI
int
WINAPI
GetScrollPos(
    __in HWND hWnd,
    __in int nBar);

WINUSERAPI
BOOL
WINAPI
SetScrollRange(
    __in HWND hWnd,
    __in int nBar,
    __in int nMinPos,
    __in int nMaxPos,
    __in BOOL bRedraw);

WINUSERAPI
BOOL
WINAPI
GetScrollRange(
    __in HWND hWnd,
    __in int nBar,
    __out LPINT lpMinPos,
    __out LPINT lpMaxPos);

WINUSERAPI
BOOL
WINAPI
ShowScrollBar(
    __in HWND hWnd,
    __in int wBar,
    __in BOOL bShow);

WINUSERAPI
BOOL
WINAPI
EnableScrollBar(
    __in HWND hWnd,
    __in UINT wSBflags,
    __in UINT wArrows);


/*
 * EnableScrollBar() flags
 */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT


#endif  /* !NOSCROLL */

WINUSERAPI
BOOL
WINAPI
SetPropA(
    __in HWND hWnd,
    __in LPCSTR lpString,
    __in_opt HANDLE hData);
WINUSERAPI
BOOL
WINAPI
SetPropW(
    __in HWND hWnd,
    __in LPCWSTR lpString,
    __in_opt HANDLE hData);
#ifdef UNICODE
#define SetProp  SetPropW
#else
#define SetProp  SetPropA
#endif // !UNICODE

WINUSERAPI
HANDLE
WINAPI
GetPropA(
    __in HWND hWnd,
    __in LPCSTR lpString);
WINUSERAPI
HANDLE
WINAPI
GetPropW(
    __in HWND hWnd,
    __in LPCWSTR lpString);
#ifdef UNICODE
#define GetProp  GetPropW
#else
#define GetProp  GetPropA
#endif // !UNICODE

WINUSERAPI
HANDLE
WINAPI
RemovePropA(
    __in HWND hWnd,
    __in LPCSTR lpString);
WINUSERAPI
HANDLE
WINAPI
RemovePropW(
    __in HWND hWnd,
    __in LPCWSTR lpString);
#ifdef UNICODE
#define RemoveProp  RemovePropW
#else
#define RemoveProp  RemovePropA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
EnumPropsExA(
    __in HWND hWnd,
    __in PROPENUMPROCEXA lpEnumFunc,
    __in LPARAM lParam);
WINUSERAPI
int
WINAPI
EnumPropsExW(
    __in HWND hWnd,
    __in PROPENUMPROCEXW lpEnumFunc,
    __in LPARAM lParam);
#ifdef UNICODE
#define EnumPropsEx  EnumPropsExW
#else
#define EnumPropsEx  EnumPropsExA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
EnumPropsA(
    __in HWND hWnd,
    __in PROPENUMPROCA lpEnumFunc);
WINUSERAPI
int
WINAPI
EnumPropsW(
    __in HWND hWnd,
    __in PROPENUMPROCW lpEnumFunc);
#ifdef UNICODE
#define EnumProps  EnumPropsW
#else
#define EnumProps  EnumPropsA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
SetWindowTextA(
    __in HWND hWnd,
    __in_opt LPCSTR lpString);
WINUSERAPI
BOOL
WINAPI
SetWindowTextW(
    __in HWND hWnd,
    __in_opt LPCWSTR lpString);
#ifdef UNICODE
#define SetWindowText  SetWindowTextW
#else
#define SetWindowText  SetWindowTextA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
GetWindowTextA(
    __in HWND hWnd,
    __out_ecount(nMaxCount) LPSTR lpString,
    __in int nMaxCount);
WINUSERAPI
int
WINAPI
GetWindowTextW(
    __in HWND hWnd,
    __out_ecount(nMaxCount) LPWSTR lpString,
    __in int nMaxCount);
#ifdef UNICODE
#define GetWindowText  GetWindowTextW
#else
#define GetWindowText  GetWindowTextA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
GetWindowTextLengthA(
    __in HWND hWnd);
WINUSERAPI
int
WINAPI
GetWindowTextLengthW(
    __in HWND hWnd);
#ifdef UNICODE
#define GetWindowTextLength  GetWindowTextLengthW
#else
#define GetWindowTextLength  GetWindowTextLengthA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
GetClientRect(
    __in HWND hWnd,
    __out LPRECT lpRect);

WINUSERAPI
BOOL
WINAPI
GetWindowRect(
    __in HWND hWnd,
    __out LPRECT lpRect);

WINUSERAPI
BOOL
WINAPI
AdjustWindowRect(
    __inout LPRECT lpRect,
    __in DWORD dwStyle,
    __in BOOL bMenu);

WINUSERAPI
BOOL
WINAPI
AdjustWindowRectEx(
    __inout LPRECT lpRect,
    __in DWORD dwStyle,
    __in BOOL bMenu,
    __in DWORD dwExStyle);


#if(WINVER >= 0x0400)
#define HELPINFO_WINDOW    0x0001
#define HELPINFO_MENUITEM  0x0002
typedef struct tagHELPINFO      /* Structure pointed to by lParam of WM_HELP */
{
    UINT    cbSize;             /* Size in bytes of this struct  */
    int     iContextType;       /* Either HELPINFO_WINDOW or HELPINFO_MENUITEM */
    int     iCtrlId;            /* Control Id or a Menu item Id. */
    HANDLE  hItemHandle;        /* hWnd of control or hMenu.     */
    DWORD_PTR dwContextId;      /* Context Id associated with this item */
    POINT   MousePos;           /* Mouse Position in screen co-ordinates */
}  HELPINFO, FAR *LPHELPINFO;

WINUSERAPI
BOOL
WINAPI
SetWindowContextHelpId(
    __in HWND,
    __in DWORD);

WINUSERAPI
DWORD
WINAPI
GetWindowContextHelpId(
    __in HWND);

WINUSERAPI
BOOL
WINAPI
SetMenuContextHelpId(
    __in HMENU,
    __in DWORD);

WINUSERAPI
DWORD
WINAPI
GetMenuContextHelpId(
    __in HMENU);

#endif /* WINVER >= 0x0400 */


#ifndef NOMB

/*
 * MessageBox() Flags
 */
#define MB_OK                       0x00000000L
#define MB_OKCANCEL                 0x00000001L
#define MB_ABORTRETRYIGNORE         0x00000002L
#define MB_YESNOCANCEL              0x00000003L
#define MB_YESNO                    0x00000004L
#define MB_RETRYCANCEL              0x00000005L
#if(WINVER >= 0x0500)
#define MB_CANCELTRYCONTINUE        0x00000006L
#endif /* WINVER >= 0x0500 */


#define MB_ICONHAND                 0x00000010L
#define MB_ICONQUESTION             0x00000020L
#define MB_ICONEXCLAMATION          0x00000030L
#define MB_ICONASTERISK             0x00000040L

#if(WINVER >= 0x0400)
#define MB_USERICON                 0x00000080L
#define MB_ICONWARNING              MB_ICONEXCLAMATION
#define MB_ICONERROR                MB_ICONHAND
#endif /* WINVER >= 0x0400 */

#define MB_ICONINFORMATION          MB_ICONASTERISK
#define MB_ICONSTOP                 MB_ICONHAND

#define MB_DEFBUTTON1               0x00000000L
#define MB_DEFBUTTON2               0x00000100L
#define MB_DEFBUTTON3               0x00000200L
#if(WINVER >= 0x0400)
#define MB_DEFBUTTON4               0x00000300L
#endif /* WINVER >= 0x0400 */

#define MB_APPLMODAL                0x00000000L
#define MB_SYSTEMMODAL              0x00001000L
#define MB_TASKMODAL                0x00002000L
#if(WINVER >= 0x0400)
#define MB_HELP                     0x00004000L // Help Button
#endif /* WINVER >= 0x0400 */

#define MB_NOFOCUS                  0x00008000L
#define MB_SETFOREGROUND            0x00010000L
#define MB_DEFAULT_DESKTOP_ONLY     0x00020000L

#if(WINVER >= 0x0400)
#define MB_TOPMOST                  0x00040000L
#define MB_RIGHT                    0x00080000L
#define MB_RTLREADING               0x00100000L

#endif /* WINVER >= 0x0400 */

#ifdef _WIN32_WINNT
#if (_WIN32_WINNT >= 0x0400)
#define MB_SERVICE_NOTIFICATION          0x00200000L
#else
#define MB_SERVICE_NOTIFICATION          0x00040000L
#endif
#define MB_SERVICE_NOTIFICATION_NT3X     0x00040000L
#endif

#define MB_TYPEMASK                 0x0000000FL
#define MB_ICONMASK                 0x000000F0L
#define MB_DEFMASK                  0x00000F00L
#define MB_MODEMASK                 0x00003000L
#define MB_MISCMASK                 0x0000C000L

WINUSERAPI
int
WINAPI
MessageBoxA(
    __in_opt HWND hWnd,
    __in_opt LPCSTR lpText,
    __in_opt LPCSTR lpCaption,
    __in UINT uType);
WINUSERAPI
int
WINAPI
MessageBoxW(
    __in_opt HWND hWnd,
    __in_opt LPCWSTR lpText,
    __in_opt LPCWSTR lpCaption,
    __in UINT uType);
#ifdef UNICODE
#define MessageBox  MessageBoxW
#else
#define MessageBox  MessageBoxA
#endif // !UNICODE

#if defined(_M_CEE)
#undef MessageBox
__inline
int
MessageBox(
    HWND hWnd,
    LPCTSTR lpText,
    LPCTSTR lpCaption,
    UINT uType
    )
{
#ifdef UNICODE
    return MessageBoxW(
#else
    return MessageBoxA(
#endif
        hWnd,
    lpText,
    lpCaption,
    uType
        );
}
#endif  /* _M_CEE */

WINUSERAPI
int
WINAPI
MessageBoxExA(
    __in_opt HWND hWnd,
    __in_opt LPCSTR lpText,
    __in_opt LPCSTR lpCaption,
    __in UINT uType,
    __in WORD wLanguageId);
WINUSERAPI
int
WINAPI
MessageBoxExW(
    __in_opt HWND hWnd,
    __in_opt LPCWSTR lpText,
    __in_opt LPCWSTR lpCaption,
    __in UINT uType,
    __in WORD wLanguageId);
#ifdef UNICODE
#define MessageBoxEx  MessageBoxExW
#else
#define MessageBoxEx  MessageBoxExA
#endif // !UNICODE

#if(WINVER >= 0x0400)

typedef VOID (CALLBACK *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);

typedef struct tagMSGBOXPARAMSA
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCSTR      lpszText;
    LPCSTR      lpszCaption;
    DWORD       dwStyle;
    LPCSTR      lpszIcon;
    DWORD_PTR   dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD       dwLanguageId;
} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;
typedef struct tagMSGBOXPARAMSW
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCWSTR     lpszText;
    LPCWSTR     lpszCaption;
    DWORD       dwStyle;
    LPCWSTR     lpszIcon;
    DWORD_PTR   dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD       dwLanguageId;
} MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW;
#ifdef UNICODE
typedef MSGBOXPARAMSW MSGBOXPARAMS;
typedef PMSGBOXPARAMSW PMSGBOXPARAMS;
typedef LPMSGBOXPARAMSW LPMSGBOXPARAMS;
#else
typedef MSGBOXPARAMSA MSGBOXPARAMS;
typedef PMSGBOXPARAMSA PMSGBOXPARAMS;
typedef LPMSGBOXPARAMSA LPMSGBOXPARAMS;
#endif // UNICODE

WINUSERAPI
int
WINAPI
MessageBoxIndirectA(
    __in CONST MSGBOXPARAMSA * lpmbp);
WINUSERAPI
int
WINAPI
MessageBoxIndirectW(
    __in CONST MSGBOXPARAMSW * lpmbp);
#ifdef UNICODE
#define MessageBoxIndirect  MessageBoxIndirectW
#else
#define MessageBoxIndirect  MessageBoxIndirectA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */


WINUSERAPI
BOOL
WINAPI
MessageBeep(
    __in UINT uType);

#endif /* !NOMB */


WINUSERAPI
int
WINAPI
ShowCursor(
    __in BOOL bShow);

WINUSERAPI
BOOL
WINAPI
SetCursorPos(
    __in int X,
    __in int Y);

#if(WINVER >= 0x0600)
WINUSERAPI
BOOL
WINAPI
SetPhysicalCursorPos(
    __in int X,
    __in int Y);
#endif /* WINVER >= 0x0600 */

WINUSERAPI
HCURSOR
WINAPI
SetCursor(
    __in_opt HCURSOR hCursor);

WINUSERAPI
BOOL
WINAPI
GetCursorPos(
    __out LPPOINT lpPoint);

#if(WINVER >= 0x0600)
WINUSERAPI
BOOL
WINAPI
GetPhysicalCursorPos(
    __out LPPOINT lpPoint);
#endif /* WINVER >= 0x0600 */

WINUSERAPI
BOOL
WINAPI
ClipCursor(
    __in_opt CONST RECT *lpRect);

WINUSERAPI
BOOL
WINAPI
GetClipCursor(
    __out LPRECT lpRect);

WINUSERAPI
HCURSOR
WINAPI
GetCursor(
    VOID);

WINUSERAPI
BOOL
WINAPI
CreateCaret(
    __in HWND hWnd,
    __in_opt HBITMAP hBitmap,
    __in int nWidth,
    __in int nHeight);

WINUSERAPI
UINT
WINAPI
GetCaretBlinkTime(
    VOID);

WINUSERAPI
BOOL
WINAPI
SetCaretBlinkTime(
    __in UINT uMSeconds);

WINUSERAPI
BOOL
WINAPI
DestroyCaret(
    VOID);

WINUSERAPI
BOOL
WINAPI
HideCaret(
    __in_opt HWND hWnd);

WINUSERAPI
BOOL
WINAPI
ShowCaret(
    __in_opt HWND hWnd);

WINUSERAPI
BOOL
WINAPI
SetCaretPos(
    __in int X,
    __in int Y);

WINUSERAPI
BOOL
WINAPI
GetCaretPos(
    __out LPPOINT lpPoint);

WINUSERAPI
BOOL
WINAPI
ClientToScreen(
    __in HWND hWnd,
    __inout LPPOINT lpPoint);

WINUSERAPI
BOOL
WINAPI
ScreenToClient(
    __in HWND hWnd,
    __inout LPPOINT lpPoint);

#if(WINVER >= 0x0600)
WINUSERAPI
BOOL
WINAPI
LogicalToPhysicalPoint(
    __in HWND hWnd,
    __inout LPPOINT lpPoint);

WINUSERAPI
BOOL
WINAPI
PhysicalToLogicalPoint(
    __in HWND hWnd,
    __inout LPPOINT lpPoint);

#endif /* WINVER >= 0x0600 */

WINUSERAPI
int
WINAPI
MapWindowPoints(
    __in_opt HWND hWndFrom,
    __in_opt HWND hWndTo,
    __inout_ecount(cPoints) LPPOINT lpPoints,
    __in UINT cPoints);

WINUSERAPI
HWND
WINAPI
WindowFromPoint(
    __in POINT Point);

#if(WINVER >= 0x0600)
WINUSERAPI
HWND
WINAPI
WindowFromPhysicalPoint(
    __in POINT Point);
#endif /* WINVER >= 0x0600 */

WINUSERAPI
HWND
WINAPI
ChildWindowFromPoint(
    __in HWND hWndParent,
    __in POINT Point);

#if(WINVER >= 0x0400)
#define CWP_ALL             0x0000
#define CWP_SKIPINVISIBLE   0x0001
#define CWP_SKIPDISABLED    0x0002
#define CWP_SKIPTRANSPARENT 0x0004

WINUSERAPI
HWND
WINAPI
ChildWindowFromPointEx(
    __in HWND hwnd,
    __in POINT pt,
    __in UINT flags);
#endif /* WINVER >= 0x0400 */

#ifndef NOCOLOR

/*
 * Color Types
 */
#define CTLCOLOR_MSGBOX         0
#define CTLCOLOR_EDIT           1
#define CTLCOLOR_LISTBOX        2
#define CTLCOLOR_BTN            3
#define CTLCOLOR_DLG            4
#define CTLCOLOR_SCROLLBAR      5
#define CTLCOLOR_STATIC         6
#define CTLCOLOR_MAX            7

#define COLOR_SCROLLBAR         0
#define COLOR_BACKGROUND        1
#define COLOR_ACTIVECAPTION     2
#define COLOR_INACTIVECAPTION   3
#define COLOR_MENU              4
#define COLOR_WINDOW            5
#define COLOR_WINDOWFRAME       6
#define COLOR_MENUTEXT          7
#define COLOR_WINDOWTEXT        8
#define COLOR_CAPTIONTEXT       9
#define COLOR_ACTIVEBORDER      10
#define COLOR_INACTIVEBORDER    11
#define COLOR_APPWORKSPACE      12
#define COLOR_HIGHLIGHT         13
#define COLOR_HIGHLIGHTTEXT     14
#define COLOR_BTNFACE           15
#define COLOR_BTNSHADOW         16
#define COLOR_GRAYTEXT          17
#define COLOR_BTNTEXT           18
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT      20

#if(WINVER >= 0x0400)
#define COLOR_3DDKSHADOW        21
#define COLOR_3DLIGHT           22
#define COLOR_INFOTEXT          23
#define COLOR_INFOBK            24
#endif /* WINVER >= 0x0400 */

#if(WINVER >= 0x0500)
#define COLOR_HOTLIGHT          26
#define COLOR_GRADIENTACTIVECAPTION 27
#define COLOR_GRADIENTINACTIVECAPTION 28
#if(WINVER >= 0x0501)
#define COLOR_MENUHILIGHT       29
#define COLOR_MENUBAR           30
#endif /* WINVER >= 0x0501 */
#endif /* WINVER >= 0x0500 */

#if(WINVER >= 0x0400)
#define COLOR_DESKTOP           COLOR_BACKGROUND
#define COLOR_3DFACE            COLOR_BTNFACE
#define COLOR_3DSHADOW          COLOR_BTNSHADOW
#define COLOR_3DHIGHLIGHT       COLOR_BTNHIGHLIGHT
#define COLOR_3DHILIGHT         COLOR_BTNHIGHLIGHT
#define COLOR_BTNHILIGHT        COLOR_BTNHIGHLIGHT
#endif /* WINVER >= 0x0400 */


WINUSERAPI
DWORD
WINAPI
GetSysColor(
    __in int nIndex);

#if(WINVER >= 0x0400)
WINUSERAPI
HBRUSH
WINAPI
GetSysColorBrush(
    __in int nIndex);


#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
SetSysColors(
    __in int cElements,
    __in_ecount(cElements) CONST INT * lpaElements,
    __in_ecount(cElements) CONST COLORREF * lpaRgbValues);

#endif /* !NOCOLOR */

WINUSERAPI
BOOL
WINAPI
DrawFocusRect(
    __in HDC hDC,
    __in CONST RECT * lprc);

WINUSERAPI
int
WINAPI
FillRect(
    __in HDC hDC,
    __in CONST RECT *lprc,
    __in HBRUSH hbr);

WINUSERAPI
int
WINAPI
FrameRect(
    __in HDC hDC,
    __in CONST RECT *lprc,
    __in HBRUSH hbr);

WINUSERAPI
BOOL
WINAPI
InvertRect(
    __in HDC hDC,
    __in CONST RECT *lprc);

WINUSERAPI
BOOL
WINAPI
SetRect(
    __out LPRECT lprc,
    __in int xLeft,
    __in int yTop,
    __in int xRight,
    __in int yBottom);

WINUSERAPI
BOOL
WINAPI
SetRectEmpty(
    __out LPRECT lprc);

WINUSERAPI
BOOL
WINAPI
CopyRect(
    __out LPRECT lprcDst,
    __in CONST RECT *lprcSrc);

WINUSERAPI
BOOL
WINAPI
InflateRect(
    __inout LPRECT lprc,
    __in int dx,
    __in int dy);

WINUSERAPI
BOOL
WINAPI
IntersectRect(
    __out LPRECT lprcDst,
    __in CONST RECT *lprcSrc1,
    __in CONST RECT *lprcSrc2);

WINUSERAPI
BOOL
WINAPI
UnionRect(
    __out LPRECT lprcDst,
    __in CONST RECT *lprcSrc1,
    __in CONST RECT *lprcSrc2);

WINUSERAPI
BOOL
WINAPI
SubtractRect(
    __out LPRECT lprcDst,
    __in CONST RECT *lprcSrc1,
    __in CONST RECT *lprcSrc2);

WINUSERAPI
BOOL
WINAPI
OffsetRect(
    __inout LPRECT lprc,
    __in int dx,
    __in int dy);

WINUSERAPI
BOOL
WINAPI
IsRectEmpty(
    __in CONST RECT *lprc);

WINUSERAPI
BOOL
WINAPI
EqualRect(
    __in CONST RECT *lprc1,
    __in CONST RECT *lprc2);

WINUSERAPI
BOOL
WINAPI
PtInRect(
    __in CONST RECT *lprc,
    __in POINT pt);

#ifndef NOWINOFFSETS

WINUSERAPI
WORD
WINAPI
GetWindowWord(
    __in HWND hWnd,
    __in int nIndex);

WINUSERAPI
WORD
WINAPI
SetWindowWord(
    __in HWND hWnd,
    __in int nIndex,
    __in WORD wNewWord);

WINUSERAPI
LONG
WINAPI
GetWindowLongA(
    __in HWND hWnd,
    __in int nIndex);
WINUSERAPI
LONG
WINAPI
GetWindowLongW(
    __in HWND hWnd,
    __in int nIndex);
#ifdef UNICODE
#define GetWindowLong  GetWindowLongW
#else
#define GetWindowLong  GetWindowLongA
#endif // !UNICODE

WINUSERAPI
LONG
WINAPI
SetWindowLongA(
    __in HWND hWnd,
    __in int nIndex,
    __in LONG dwNewLong);
WINUSERAPI
LONG
WINAPI
SetWindowLongW(
    __in HWND hWnd,
    __in int nIndex,
    __in LONG dwNewLong);
#ifdef UNICODE
#define SetWindowLong  SetWindowLongW
#else
#define SetWindowLong  SetWindowLongA
#endif // !UNICODE

#ifdef _WIN64

WINUSERAPI
LONG_PTR
WINAPI
GetWindowLongPtrA(
    __in HWND hWnd,
    __in int nIndex);
WINUSERAPI
LONG_PTR
WINAPI
GetWindowLongPtrW(
    __in HWND hWnd,
    __in int nIndex);
#ifdef UNICODE
#define GetWindowLongPtr  GetWindowLongPtrW
#else
#define GetWindowLongPtr  GetWindowLongPtrA
#endif // !UNICODE

WINUSERAPI
LONG_PTR
WINAPI
SetWindowLongPtrA(
    __in HWND hWnd,
    __in int nIndex,
    __in LONG_PTR dwNewLong);
WINUSERAPI
LONG_PTR
WINAPI
SetWindowLongPtrW(
    __in HWND hWnd,
    __in int nIndex,
    __in LONG_PTR dwNewLong);
#ifdef UNICODE
#define SetWindowLongPtr  SetWindowLongPtrW
#else
#define SetWindowLongPtr  SetWindowLongPtrA
#endif // !UNICODE

#else  /* _WIN64 */

#define GetWindowLongPtrA   GetWindowLongA
#define GetWindowLongPtrW   GetWindowLongW
#ifdef UNICODE
#define GetWindowLongPtr  GetWindowLongPtrW
#else
#define GetWindowLongPtr  GetWindowLongPtrA
#endif // !UNICODE

#define SetWindowLongPtrA   SetWindowLongA
#define SetWindowLongPtrW   SetWindowLongW
#ifdef UNICODE
#define SetWindowLongPtr  SetWindowLongPtrW
#else
#define SetWindowLongPtr  SetWindowLongPtrA
#endif // !UNICODE

#endif /* _WIN64 */

WINUSERAPI
WORD
WINAPI
GetClassWord(
    __in HWND hWnd,
    __in int nIndex);

WINUSERAPI
WORD
WINAPI
SetClassWord(
    __in HWND hWnd,
    __in int nIndex,
    __in WORD wNewWord);

WINUSERAPI
DWORD
WINAPI
GetClassLongA(
    __in HWND hWnd,
    __in int nIndex);
WINUSERAPI
DWORD
WINAPI
GetClassLongW(
    __in HWND hWnd,
    __in int nIndex);
#ifdef UNICODE
#define GetClassLong  GetClassLongW
#else
#define GetClassLong  GetClassLongA
#endif // !UNICODE

WINUSERAPI
DWORD
WINAPI
SetClassLongA(
    __in HWND hWnd,
    __in int nIndex,
    __in LONG dwNewLong);
WINUSERAPI
DWORD
WINAPI
SetClassLongW(
    __in HWND hWnd,
    __in int nIndex,
    __in LONG dwNewLong);
#ifdef UNICODE
#define SetClassLong  SetClassLongW
#else
#define SetClassLong  SetClassLongA
#endif // !UNICODE

#ifdef _WIN64

WINUSERAPI
ULONG_PTR
WINAPI
GetClassLongPtrA(
    __in HWND hWnd,
    __in int nIndex);
WINUSERAPI
ULONG_PTR
WINAPI
GetClassLongPtrW(
    __in HWND hWnd,
    __in int nIndex);
#ifdef UNICODE
#define GetClassLongPtr  GetClassLongPtrW
#else
#define GetClassLongPtr  GetClassLongPtrA
#endif // !UNICODE

WINUSERAPI
ULONG_PTR
WINAPI
SetClassLongPtrA(
    __in HWND hWnd,
    __in int nIndex,
    __in LONG_PTR dwNewLong);
WINUSERAPI
ULONG_PTR
WINAPI
SetClassLongPtrW(
    __in HWND hWnd,
    __in int nIndex,
    __in LONG_PTR dwNewLong);
#ifdef UNICODE
#define SetClassLongPtr  SetClassLongPtrW
#else
#define SetClassLongPtr  SetClassLongPtrA
#endif // !UNICODE

#else  /* _WIN64 */

#define GetClassLongPtrA    GetClassLongA
#define GetClassLongPtrW    GetClassLongW
#ifdef UNICODE
#define GetClassLongPtr  GetClassLongPtrW
#else
#define GetClassLongPtr  GetClassLongPtrA
#endif // !UNICODE

#define SetClassLongPtrA    SetClassLongA
#define SetClassLongPtrW    SetClassLongW
#ifdef UNICODE
#define SetClassLongPtr  SetClassLongPtrW
#else
#define SetClassLongPtr  SetClassLongPtrA
#endif // !UNICODE

#endif /* _WIN64 */

#endif /* !NOWINOFFSETS */

#if(WINVER >= 0x0500)
WINUSERAPI
BOOL
WINAPI
GetProcessDefaultLayout(
    __out DWORD *pdwDefaultLayout);

WINUSERAPI
BOOL
WINAPI
SetProcessDefaultLayout(
    __in DWORD dwDefaultLayout);
#endif /* WINVER >= 0x0500 */

WINUSERAPI
HWND
WINAPI
GetDesktopWindow(
    VOID);


WINUSERAPI
HWND
WINAPI
GetParent(
    __in HWND hWnd);

WINUSERAPI
HWND
WINAPI
SetParent(
    __in HWND hWndChild,
    __in_opt HWND hWndNewParent);

WINUSERAPI
BOOL
WINAPI
EnumChildWindows(
    __in_opt HWND hWndParent,
    __in WNDENUMPROC lpEnumFunc,
    __in LPARAM lParam);

WINUSERAPI
HWND
WINAPI
FindWindowA(
    __in_opt LPCSTR lpClassName,
    __in_opt LPCSTR lpWindowName);
WINUSERAPI
HWND
WINAPI
FindWindowW(
    __in_opt LPCWSTR lpClassName,
    __in_opt LPCWSTR lpWindowName);
#ifdef UNICODE
#define FindWindow  FindWindowW
#else
#define FindWindow  FindWindowA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI
HWND
WINAPI
FindWindowExA(
    __in_opt HWND hWndParent,
    __in_opt HWND hWndChildAfter,
    __in_opt LPCSTR lpszClass,
    __in_opt LPCSTR lpszWindow);
WINUSERAPI
HWND
WINAPI
FindWindowExW(
    __in_opt HWND hWndParent,
    __in_opt HWND hWndChildAfter,
    __in_opt LPCWSTR lpszClass,
    __in_opt LPCWSTR lpszWindow);
#ifdef UNICODE
#define FindWindowEx  FindWindowExW
#else
#define FindWindowEx  FindWindowExA
#endif // !UNICODE

WINUSERAPI
HWND
WINAPI
GetShellWindow(
    VOID);

#endif /* WINVER >= 0x0400 */


WINUSERAPI
BOOL
WINAPI
RegisterShellHookWindow(
    __in HWND hwnd);

WINUSERAPI
BOOL
WINAPI
DeregisterShellHookWindow(
    __in HWND hwnd);

WINUSERAPI
BOOL
WINAPI
EnumWindows(
    __in WNDENUMPROC lpEnumFunc,
    __in LPARAM lParam);

WINUSERAPI
BOOL
WINAPI
EnumThreadWindows(
    __in DWORD dwThreadId,
    __in WNDENUMPROC lpfn,
    __in LPARAM lParam);

#define EnumTaskWindows(hTask, lpfn, lParam) EnumThreadWindows(HandleToUlong(hTask), lpfn, lParam)

WINUSERAPI
int
WINAPI
GetClassNameA(
    __in HWND hWnd,
    __out_ecount_part(nMaxCount, return) LPSTR lpClassName,
    __in int nMaxCount
    );
WINUSERAPI
int
WINAPI
GetClassNameW(
    __in HWND hWnd,
    __out_ecount_part(nMaxCount, return) LPWSTR lpClassName,
    __in int nMaxCount
    );
#ifdef UNICODE
#define GetClassName  GetClassNameW
#else
#define GetClassName  GetClassNameA
#endif // !UNICODE

#if defined(_M_CEE)
#undef GetClassName
__inline
int
GetClassName(
    HWND hWnd,
    LPTSTR lpClassName,
    int nMaxCount
    )
{
#ifdef UNICODE
    return GetClassNameW(
#else
    return GetClassNameA(
#endif
        hWnd,
    lpClassName,
    nMaxCount
        );
}
#endif  /* _M_CEE */



WINUSERAPI
HWND
WINAPI
GetTopWindow(
    __in_opt HWND hWnd);

#define GetNextWindow(hWnd, wCmd) GetWindow(hWnd, wCmd)
#define GetSysModalWindow() (NULL)
#define SetSysModalWindow(hWnd) (NULL)

WINUSERAPI
DWORD
WINAPI
GetWindowThreadProcessId(
    __in HWND hWnd,
    __out_opt LPDWORD lpdwProcessId);

#if(_WIN32_WINNT >= 0x0501)
WINUSERAPI
BOOL
WINAPI
IsGUIThread(
    __in BOOL bConvert);

#endif /* _WIN32_WINNT >= 0x0501 */


#define GetWindowTask(hWnd) \
        ((HANDLE)(DWORD_PTR)GetWindowThreadProcessId(hWnd, NULL))

WINUSERAPI
HWND
WINAPI
GetLastActivePopup(
    __in HWND hWnd);

/*
 * GetWindow() Constants
 */
#define GW_HWNDFIRST        0
#define GW_HWNDLAST         1
#define GW_HWNDNEXT         2
#define GW_HWNDPREV         3
#define GW_OWNER            4
#define GW_CHILD            5
#if(WINVER <= 0x0400)
#define GW_MAX              5
#else
#define GW_ENABLEDPOPUP     6
#define GW_MAX              6
#endif

WINUSERAPI
HWND
WINAPI
GetWindow(
    __in HWND hWnd,
    __in UINT uCmd);


#ifndef NOWH

#ifdef STRICT

WINUSERAPI
HHOOK
WINAPI
SetWindowsHookA(
    __in int nFilterType,
    __in HOOKPROC pfnFilterProc);
WINUSERAPI
HHOOK
WINAPI
SetWindowsHookW(
    __in int nFilterType,
    __in HOOKPROC pfnFilterProc);
#ifdef UNICODE
#define SetWindowsHook  SetWindowsHookW
#else
#define SetWindowsHook  SetWindowsHookA
#endif // !UNICODE

#else /* !STRICT */

WINUSERAPI
HOOKPROC
WINAPI
SetWindowsHookA(
    __in int nFilterType,
    __in HOOKPROC pfnFilterProc);
WINUSERAPI
HOOKPROC
WINAPI
SetWindowsHookW(
    __in int nFilterType,
    __in HOOKPROC pfnFilterProc);
#ifdef UNICODE
#define SetWindowsHook  SetWindowsHookW
#else
#define SetWindowsHook  SetWindowsHookA
#endif // !UNICODE

#endif /* !STRICT */

WINUSERAPI
BOOL
WINAPI
UnhookWindowsHook(
    __in int nCode,
    __in HOOKPROC pfnFilterProc);

WINUSERAPI
HHOOK
WINAPI
SetWindowsHookExA(
    __in int idHook,
    __in HOOKPROC lpfn,
    __in_opt HINSTANCE hmod,
    __in DWORD dwThreadId);
WINUSERAPI
HHOOK
WINAPI
SetWindowsHookExW(
    __in int idHook,
    __in HOOKPROC lpfn,
    __in_opt HINSTANCE hmod,
    __in DWORD dwThreadId);
#ifdef UNICODE
#define SetWindowsHookEx  SetWindowsHookExW
#else
#define SetWindowsHookEx  SetWindowsHookExA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
UnhookWindowsHookEx(
    __in HHOOK hhk);

WINUSERAPI
LRESULT
WINAPI
CallNextHookEx(
    __in_opt HHOOK hhk,
    __in int nCode,
    __in WPARAM wParam,
    __in LPARAM lParam);

/*
 * Macros for source-level compatibility with old functions.
 */
#ifdef STRICT
#define DefHookProc(nCode, wParam, lParam, phhk)\
        CallNextHookEx(*phhk, nCode, wParam, lParam)
#else
#define DefHookProc(nCode, wParam, lParam, phhk)\
        CallNextHookEx((HHOOK)*phhk, nCode, wParam, lParam)
#endif /* STRICT */
#endif /* !NOWH */

#ifndef NOMENUS


/* ;win40  -- A lot of MF_* flags have been renamed as MFT_* and MFS_* flags */
/*
 * Menu flags for Add/Check/EnableMenuItem()
 */
#define MF_INSERT           0x00000000L
#define MF_CHANGE           0x00000080L
#define MF_APPEND           0x00000100L
#define MF_DELETE           0x00000200L
#define MF_REMOVE           0x00001000L

#define MF_BYCOMMAND        0x00000000L
#define MF_BYPOSITION       0x00000400L

#define MF_SEPARATOR        0x00000800L

#define MF_ENABLED          0x00000000L
#define MF_GRAYED           0x00000001L
#define MF_DISABLED         0x00000002L

#define MF_UNCHECKED        0x00000000L
#define MF_CHECKED          0x00000008L
#define MF_USECHECKBITMAPS  0x00000200L

#define MF_STRING           0x00000000L
#define MF_BITMAP           0x00000004L
#define MF_OWNERDRAW        0x00000100L

#define MF_POPUP            0x00000010L
#define MF_MENUBARBREAK     0x00000020L
#define MF_MENUBREAK        0x00000040L

#define MF_UNHILITE         0x00000000L
#define MF_HILITE           0x00000080L

#if(WINVER >= 0x0400)
#define MF_DEFAULT          0x00001000L
#endif /* WINVER >= 0x0400 */
#define MF_SYSMENU          0x00002000L
#define MF_HELP             0x00004000L
#if(WINVER >= 0x0400)
#define MF_RIGHTJUSTIFY     0x00004000L
#endif /* WINVER >= 0x0400 */

#define MF_MOUSESELECT      0x00008000L
#if(WINVER >= 0x0400)
#define MF_END              0x00000080L  /* Obsolete -- only used by old RES files */
#endif /* WINVER >= 0x0400 */


#if(WINVER >= 0x0400)
#define MFT_STRING          MF_STRING
#define MFT_BITMAP          MF_BITMAP
#define MFT_MENUBARBREAK    MF_MENUBARBREAK
#define MFT_MENUBREAK       MF_MENUBREAK
#define MFT_OWNERDRAW       MF_OWNERDRAW
#define MFT_RADIOCHECK      0x00000200L
#define MFT_SEPARATOR       MF_SEPARATOR
#define MFT_RIGHTORDER      0x00002000L
#define MFT_RIGHTJUSTIFY    MF_RIGHTJUSTIFY

/* Menu flags for Add/Check/EnableMenuItem() */
#define MFS_GRAYED          0x00000003L
#define MFS_DISABLED        MFS_GRAYED
#define MFS_CHECKED         MF_CHECKED
#define MFS_HILITE          MF_HILITE
#define MFS_ENABLED         MF_ENABLED
#define MFS_UNCHECKED       MF_UNCHECKED
#define MFS_UNHILITE        MF_UNHILITE
#define MFS_DEFAULT         MF_DEFAULT
#endif /* WINVER >= 0x0400 */


#if(WINVER >= 0x0400)

WINUSERAPI
BOOL
WINAPI
CheckMenuRadioItem(
    __in HMENU hmenu,
    __in UINT first,
    __in UINT last,
    __in UINT check,
    __in UINT flags);
#endif /* WINVER >= 0x0400 */

/*
 * Menu item resource format
 */
typedef struct {
    WORD versionNumber;
    WORD offset;
} MENUITEMTEMPLATEHEADER, *PMENUITEMTEMPLATEHEADER;

typedef struct {        // version 0
    WORD mtOption;
    WORD mtID;
    WCHAR mtString[1];
} MENUITEMTEMPLATE, *PMENUITEMTEMPLATE;
#define MF_END             0x00000080L

#endif /* !NOMENUS */

#ifndef NOSYSCOMMANDS

/*
 * System Menu Command Values
 */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150
#if(WINVER >= 0x0400)
#define SC_DEFAULT      0xF160
#define SC_MONITORPOWER 0xF170
#define SC_CONTEXTHELP  0xF180
#define SC_SEPARATOR    0xF00F
#endif /* WINVER >= 0x0400 */

#if(WINVER >= 0x0600)
#define SCF_ISSECURE    0x00000001
#endif /* WINVER >= 0x0600 */

#define GET_SC_WPARAM(wParam) ((int)wParam & 0xFFF0)

/*
 * Obsolete names
 */
#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE

#endif /* !NOSYSCOMMANDS */

/*
 * Resource Loading Routines
 */

WINUSERAPI
HBITMAP
WINAPI
LoadBitmapA(
    __in_opt HINSTANCE hInstance,
    __in LPCSTR lpBitmapName);
WINUSERAPI
HBITMAP
WINAPI
LoadBitmapW(
    __in_opt HINSTANCE hInstance,
    __in LPCWSTR lpBitmapName);
#ifdef UNICODE
#define LoadBitmap  LoadBitmapW
#else
#define LoadBitmap  LoadBitmapA
#endif // !UNICODE

WINUSERAPI
HCURSOR
WINAPI
LoadCursorA(
    __in_opt HINSTANCE hInstance,
    __in LPCSTR lpCursorName);
WINUSERAPI
HCURSOR
WINAPI
LoadCursorW(
    __in_opt HINSTANCE hInstance,
    __in LPCWSTR lpCursorName);
#ifdef UNICODE
#define LoadCursor  LoadCursorW
#else
#define LoadCursor  LoadCursorA
#endif // !UNICODE

WINUSERAPI
HCURSOR
WINAPI
LoadCursorFromFileA(
    __in LPCSTR lpFileName);
WINUSERAPI
HCURSOR
WINAPI
LoadCursorFromFileW(
    __in LPCWSTR lpFileName);
#ifdef UNICODE
#define LoadCursorFromFile  LoadCursorFromFileW
#else
#define LoadCursorFromFile  LoadCursorFromFileA
#endif // !UNICODE

WINUSERAPI
HCURSOR
WINAPI
CreateCursor(
    __in_opt HINSTANCE hInst,
    __in int xHotSpot,
    __in int yHotSpot,
    __in int nWidth,
    __in int nHeight,
    __in CONST VOID *pvANDPlane,
    __in CONST VOID *pvXORPlane);

WINUSERAPI
BOOL
WINAPI
DestroyCursor(
    __in HCURSOR hCursor);

#ifndef _MAC
#define CopyCursor(pcur) ((HCURSOR)CopyIcon((HICON)(pcur)))
#else
WINUSERAPI
HCURSOR
WINAPI
CopyCursor(
    __in HCURSOR hCursor);
#endif

/*
 * Standard Cursor IDs
 */
#define IDC_ARROW           MAKEINTRESOURCE(32512)
#define IDC_IBEAM           MAKEINTRESOURCE(32513)
#define IDC_WAIT            MAKEINTRESOURCE(32514)
#define IDC_CROSS           MAKEINTRESOURCE(32515)
#define IDC_UPARROW         MAKEINTRESOURCE(32516)
#define IDC_SIZE            MAKEINTRESOURCE(32640)  /* OBSOLETE: use IDC_SIZEALL */
#define IDC_ICON            MAKEINTRESOURCE(32641)  /* OBSOLETE: use IDC_ARROW */
#define IDC_SIZENWSE        MAKEINTRESOURCE(32642)
#define IDC_SIZENESW        MAKEINTRESOURCE(32643)
#define IDC_SIZEWE          MAKEINTRESOURCE(32644)
#define IDC_SIZENS          MAKEINTRESOURCE(32645)
#define IDC_SIZEALL         MAKEINTRESOURCE(32646)
#define IDC_NO              MAKEINTRESOURCE(32648) /*not in win3.1 */
#if(WINVER >= 0x0500)
#define IDC_HAND            MAKEINTRESOURCE(32649)
#endif /* WINVER >= 0x0500 */
#define IDC_APPSTARTING     MAKEINTRESOURCE(32650) /*not in win3.1 */
#if(WINVER >= 0x0400)
#define IDC_HELP            MAKEINTRESOURCE(32651)
#endif /* WINVER >= 0x0400 */

WINUSERAPI
BOOL
WINAPI
SetSystemCursor(
    __in HCURSOR hcur,
    __in DWORD id);

typedef struct _ICONINFO {
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
} ICONINFO;
typedef ICONINFO *PICONINFO;

WINUSERAPI
HICON
WINAPI
LoadIconA(
    __in_opt HINSTANCE hInstance,
    __in LPCSTR lpIconName);
WINUSERAPI
HICON
WINAPI
LoadIconW(
    __in_opt HINSTANCE hInstance,
    __in LPCWSTR lpIconName);
#ifdef UNICODE
#define LoadIcon  LoadIconW
#else
#define LoadIcon  LoadIconA
#endif // !UNICODE


WINUSERAPI
UINT
WINAPI
PrivateExtractIconsA(
    __in LPCSTR szFileName,
    __in int nIconIndex,
    __in int cxIcon,
    __in int cyIcon,
    __out_ecount_part_opt(nIcons, return) HICON *phicon,
    __out_ecount_part_opt(nIcons, return) UINT *piconid,
    __in UINT nIcons,
    __in UINT flags);
WINUSERAPI
UINT
WINAPI
PrivateExtractIconsW(
    __in LPCWSTR szFileName,
    __in int nIconIndex,
    __in int cxIcon,
    __in int cyIcon,
    __out_ecount_part_opt(nIcons, return) HICON *phicon,
    __out_ecount_part_opt(nIcons, return) UINT *piconid,
    __in UINT nIcons,
    __in UINT flags);
#ifdef UNICODE
#define PrivateExtractIcons  PrivateExtractIconsW
#else
#define PrivateExtractIcons  PrivateExtractIconsA
#endif // !UNICODE

WINUSERAPI
HICON
WINAPI
CreateIcon(
    __in_opt HINSTANCE hInstance,
    __in int nWidth,
    __in int nHeight,
    __in BYTE cPlanes,
    __in BYTE cBitsPixel,
    __in CONST BYTE *lpbANDbits,
    __in CONST BYTE *lpbXORbits);

WINUSERAPI
BOOL
WINAPI
DestroyIcon(
    __in HICON hIcon);

WINUSERAPI
int
WINAPI
LookupIconIdFromDirectory(
    __in PBYTE presbits,
    __in BOOL fIcon);

#if(WINVER >= 0x0400)
WINUSERAPI
int
WINAPI
LookupIconIdFromDirectoryEx(
    __in PBYTE presbits,
    __in BOOL fIcon,
    __in int cxDesired,
    __in int cyDesired,
    __in UINT Flags);
#endif /* WINVER >= 0x0400 */

WINUSERAPI
HICON
WINAPI
CreateIconFromResource(
    __in PBYTE presbits,
    __in DWORD dwResSize,
    __in BOOL fIcon,
    __in DWORD dwVer);

#if(WINVER >= 0x0400)
WINUSERAPI
HICON
WINAPI
CreateIconFromResourceEx(
    __in PBYTE presbits,
    __in DWORD dwResSize,
    __in BOOL fIcon,
    __in DWORD dwVer,
    __in int cxDesired,
    __in int cyDesired,
    __in UINT Flags);

/* Icon/Cursor header */
typedef struct tagCURSORSHAPE
{
    int     xHotSpot;
    int     yHotSpot;
    int     cx;
    int     cy;
    int     cbWidth;
    BYTE    Planes;
    BYTE    BitsPixel;
} CURSORSHAPE, FAR *LPCURSORSHAPE;
#endif /* WINVER >= 0x0400 */

#define IMAGE_BITMAP        0
#define IMAGE_ICON          1
#define IMAGE_CURSOR        2
#if(WINVER >= 0x0400)
#define IMAGE_ENHMETAFILE   3

#define LR_DEFAULTCOLOR     0x00000000
#define LR_MONOCHROME       0x00000001
#define LR_COLOR            0x00000002
#define LR_COPYRETURNORG    0x00000004
#define LR_COPYDELETEORG    0x00000008
#define LR_LOADFROMFILE     0x00000010
#define LR_LOADTRANSPARENT  0x00000020
#define LR_DEFAULTSIZE      0x00000040
#define LR_VGACOLOR         0x00000080
#define LR_LOADMAP3DCOLORS  0x00001000
#define LR_CREATEDIBSECTION 0x00002000
#define LR_COPYFROMRESOURCE 0x00004000
#define LR_SHARED           0x00008000

WINUSERAPI
HANDLE
WINAPI
LoadImageA(
    __in_opt HINSTANCE hInst,
    __in LPCSTR name,
    __in UINT type,
    __in int cx,
    __in int cy,
    __in UINT fuLoad);
WINUSERAPI
HANDLE
WINAPI
LoadImageW(
    __in_opt HINSTANCE hInst,
    __in LPCWSTR name,
    __in UINT type,
    __in int cx,
    __in int cy,
    __in UINT fuLoad);
#ifdef UNICODE
#define LoadImage  LoadImageW
#else
#define LoadImage  LoadImageA
#endif // !UNICODE

WINUSERAPI
HANDLE
WINAPI
CopyImage(
    __in HANDLE h,
    __in UINT type,
    __in int cx,
    __in int cy,
    __in UINT flags);

#define DI_MASK         0x0001
#define DI_IMAGE        0x0002
#define DI_NORMAL       0x0003
#define DI_COMPAT       0x0004
#define DI_DEFAULTSIZE  0x0008
#if(_WIN32_WINNT >= 0x0501)
#define DI_NOMIRROR     0x0010
#endif /* _WIN32_WINNT >= 0x0501 */

WINUSERAPI BOOL WINAPI DrawIconEx(
    __in HDC hdc,
    __in int xLeft,
    __in int yTop,
    __in HICON hIcon,
    __in int cxWidth,
    __in int cyWidth,
    __in UINT istepIfAniCur,
    __in_opt HBRUSH hbrFlickerFreeDraw,
    __in UINT diFlags);

#endif /* WINVER >= 0x0400 */

WINUSERAPI
HICON
WINAPI
CreateIconIndirect(
    __in PICONINFO piconinfo);

WINUSERAPI
HICON
WINAPI
CopyIcon(
    __in HICON hIcon);

WINUSERAPI
BOOL
WINAPI
GetIconInfo(
    __in HICON hIcon,
    __out PICONINFO piconinfo);

#if(_WIN32_WINNT >= 0x0600)
typedef struct _ICONINFOEXA {
    DWORD   cbSize;
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    WORD    wResID;
    CHAR    szModName[MAX_PATH];
    CHAR    szResName[MAX_PATH];
} ICONINFOEXA, *PICONINFOEXA;
typedef struct _ICONINFOEXW {
    DWORD   cbSize;
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    WORD    wResID;
    WCHAR   szModName[MAX_PATH];
    WCHAR   szResName[MAX_PATH];
} ICONINFOEXW, *PICONINFOEXW;
#ifdef UNICODE
typedef ICONINFOEXW ICONINFOEX;
typedef PICONINFOEXW PICONINFOEX;
#else
typedef ICONINFOEXA ICONINFOEX;
typedef PICONINFOEXA PICONINFOEX;
#endif // UNICODE

WINUSERAPI
BOOL
WINAPI
GetIconInfoExA(
    __in HICON hicon,
    __inout PICONINFOEXA piconinfo);
WINUSERAPI
BOOL
WINAPI
GetIconInfoExW(
    __in HICON hicon,
    __inout PICONINFOEXW piconinfo);
#ifdef UNICODE
#define GetIconInfoEx  GetIconInfoExW
#else
#define GetIconInfoEx  GetIconInfoExA
#endif // !UNICODE
#endif /* _WIN32_WINNT >= 0x0600 */

#if(WINVER >= 0x0400)
#define RES_ICON    1
#define RES_CURSOR  2
#endif /* WINVER >= 0x0400 */

#ifdef OEMRESOURCE


/*
 * OEM Resource Ordinal Numbers
 */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755


#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640   /* OBSOLETE: use OCR_SIZEALL */
#define OCR_ICON            32641   /* OBSOLETE: use OCR_NORMAL */
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647   /* OBSOLETE: use OIC_WINLOGO */
#define OCR_NO              32648
#if(WINVER >= 0x0500)
#define OCR_HAND            32649
#endif /* WINVER >= 0x0500 */
#if(WINVER >= 0x0400)
#define OCR_APPSTARTING     32650
#endif /* WINVER >= 0x0400 */


#define OIC_SAMPLE          32512
#define OIC_HAND            32513
#define OIC_QUES            32514
#define OIC_BANG            32515
#define OIC_NOTE            32516
#if(WINVER >= 0x0400)
#define OIC_WINLOGO         32517
#define OIC_WARNING         OIC_BANG
#define OIC_ERROR           OIC_HAND
#define OIC_INFORMATION     OIC_NOTE
#endif /* WINVER >= 0x0400 */
#if(WINVER >= 0x0600)
#define OIC_SHIELD          32518
#endif /* WINVER >= 0x0600 */



#endif /* OEMRESOURCE */

#define ORD_LANGDRIVER    1     /* The ordinal number for the entry point of
                                ** language drivers.
                                */

#ifndef NOICONS

/*
 * Standard Icon IDs
 */
#ifdef RC_INVOKED
#define IDI_APPLICATION     32512
#define IDI_HAND            32513
#define IDI_QUESTION        32514
#define IDI_EXCLAMATION     32515
#define IDI_ASTERISK        32516
#if(WINVER >= 0x0400)
#define IDI_WINLOGO         32517
#endif /* WINVER >= 0x0400 */
#if(WINVER >= 0x0600)
#define IDI_SHIELD          32518
#endif /* WINVER >= 0x0600 */
#else
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND            MAKEINTRESOURCE(32513)
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK        MAKEINTRESOURCE(32516)
#if(WINVER >= 0x0400)
#define IDI_WINLOGO         MAKEINTRESOURCE(32517)
#endif /* WINVER >= 0x0400 */
#if(WINVER >= 0x0600)
#define IDI_SHIELD          MAKEINTRESOURCE(32518)
#endif /* WINVER >= 0x0600 */
#endif /* RC_INVOKED */

#if(WINVER >= 0x0400)
#define IDI_WARNING     IDI_EXCLAMATION
#define IDI_ERROR       IDI_HAND
#define IDI_INFORMATION IDI_ASTERISK
#endif /* WINVER >= 0x0400 */


#endif /* !NOICONS */


WINUSERAPI
int
WINAPI
LoadStringA(
    __in_opt HINSTANCE hInstance,
    __in UINT uID,
    __out_ecount_part(cchBufferMax, return + 1) LPSTR lpBuffer,
    __in int cchBufferMax);
WINUSERAPI
int
WINAPI
LoadStringW(
    __in_opt HINSTANCE hInstance,
    __in UINT uID,
    __out_ecount_part(cchBufferMax, return + 1) LPWSTR lpBuffer,
    __in int cchBufferMax);
#ifdef UNICODE
#define LoadString  LoadStringW
#else
#define LoadString  LoadStringA
#endif // !UNICODE


/*
 * Dialog Box Command IDs
 */
#define IDOK                1
#define IDCANCEL            2
#define IDABORT             3
#define IDRETRY             4
#define IDIGNORE            5
#define IDYES               6
#define IDNO                7
#if(WINVER >= 0x0400)
#define IDCLOSE         8
#define IDHELP          9
#endif /* WINVER >= 0x0400 */

#if(WINVER >= 0x0500)
#define IDTRYAGAIN      10
#define IDCONTINUE      11
#endif /* WINVER >= 0x0500 */

#if(WINVER >= 0x0501)
#ifndef IDTIMEOUT
#define IDTIMEOUT 32000
#endif
#endif /* WINVER >= 0x0501 */


#ifndef NOCTLMGR

/*
 * Control Manager Structures and Definitions
 */

#ifndef NOWINSTYLES


/*
 * Edit Control Styles
 */
#define ES_LEFT             0x0000L
#define ES_CENTER           0x0001L
#define ES_RIGHT            0x0002L
#define ES_MULTILINE        0x0004L
#define ES_UPPERCASE        0x0008L
#define ES_LOWERCASE        0x0010L
#define ES_PASSWORD         0x0020L
#define ES_AUTOVSCROLL      0x0040L
#define ES_AUTOHSCROLL      0x0080L
#define ES_NOHIDESEL        0x0100L
#define ES_OEMCONVERT       0x0400L
#define ES_READONLY         0x0800L
#define ES_WANTRETURN       0x1000L
#if(WINVER >= 0x0400)
#define ES_NUMBER           0x2000L
#endif /* WINVER >= 0x0400 */


#endif /* !NOWINSTYLES */

/*
 * Edit Control Notification Codes
 */
#define EN_SETFOCUS         0x0100
#define EN_KILLFOCUS        0x0200
#define EN_CHANGE           0x0300
#define EN_UPDATE           0x0400
#define EN_ERRSPACE         0x0500
#define EN_MAXTEXT          0x0501
#define EN_HSCROLL          0x0601
#define EN_VSCROLL          0x0602

#if(_WIN32_WINNT >= 0x0500)
#define EN_ALIGN_LTR_EC     0x0700
#define EN_ALIGN_RTL_EC     0x0701
#endif /* _WIN32_WINNT >= 0x0500 */

#if(WINVER >= 0x0400)
/* Edit control EM_SETMARGIN parameters */
#define EC_LEFTMARGIN       0x0001
#define EC_RIGHTMARGIN      0x0002
#define EC_USEFONTINFO      0xffff
#endif /* WINVER >= 0x0400 */

#if(WINVER >= 0x0500)
/* wParam of EM_GET/SETIMESTATUS  */
#define EMSIS_COMPOSITIONSTRING        0x0001

/* lParam for EMSIS_COMPOSITIONSTRING  */
#define EIMES_GETCOMPSTRATONCE         0x0001
#define EIMES_CANCELCOMPSTRINFOCUS     0x0002
#define EIMES_COMPLETECOMPSTRKILLFOCUS 0x0004
#endif /* WINVER >= 0x0500 */

#ifndef NOWINMESSAGES


/*
 * Edit Control Messages
 */
#define EM_GETSEL               0x00B0
#define EM_SETSEL               0x00B1
#define EM_GETRECT              0x00B2
#define EM_SETRECT              0x00B3
#define EM_SETRECTNP            0x00B4
#define EM_SCROLL               0x00B5
#define EM_LINESCROLL           0x00B6
#define EM_SCROLLCARET          0x00B7
#define EM_GETMODIFY            0x00B8
#define EM_SETMODIFY            0x00B9
#define EM_GETLINECOUNT         0x00BA
#define EM_LINEINDEX            0x00BB
#define EM_SETHANDLE            0x00BC
#define EM_GETHANDLE            0x00BD
#define EM_GETTHUMB             0x00BE
#define EM_LINELENGTH           0x00C1
#define EM_REPLACESEL           0x00C2
#define EM_GETLINE              0x00C4
#define EM_LIMITTEXT            0x00C5
#define EM_CANUNDO              0x00C6
#define EM_UNDO                 0x00C7
#define EM_FMTLINES             0x00C8
#define EM_LINEFROMCHAR         0x00C9
#define EM_SETTABSTOPS          0x00CB
#define EM_SETPASSWORDCHAR      0x00CC
#define EM_EMPTYUNDOBUFFER      0x00CD
#define EM_GETFIRSTVISIBLELINE  0x00CE
#define EM_SETREADONLY          0x00CF
#define EM_SETWORDBREAKPROC     0x00D0
#define EM_GETWORDBREAKPROC     0x00D1
#define EM_GETPASSWORDCHAR      0x00D2
#if(WINVER >= 0x0400)
#define EM_SETMARGINS           0x00D3
#define EM_GETMARGINS           0x00D4
#define EM_SETLIMITTEXT         EM_LIMITTEXT   /* ;win40 Name change */
#define EM_GETLIMITTEXT         0x00D5
#define EM_POSFROMCHAR          0x00D6
#define EM_CHARFROMPOS          0x00D7
#endif /* WINVER >= 0x0400 */

#if(WINVER >= 0x0500)
#define EM_SETIMESTATUS         0x00D8
#define EM_GETIMESTATUS         0x00D9
#endif /* WINVER >= 0x0500 */


#endif /* !NOWINMESSAGES */

/*
 * EDITWORDBREAKPROC code values
 */
#define WB_LEFT            0
#define WB_RIGHT           1
#define WB_ISDELIMITER     2


/*
 * Button Control Styles
 */
#define BS_PUSHBUTTON       0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX         0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON      0x00000004L
#define BS_3STATE           0x00000005L
#define BS_AUTO3STATE       0x00000006L
#define BS_GROUPBOX         0x00000007L
#define BS_USERBUTTON       0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_PUSHBOX          0x0000000AL
#define BS_OWNERDRAW        0x0000000BL
#define BS_TYPEMASK         0x0000000FL
#define BS_LEFTTEXT         0x00000020L
#if(WINVER >= 0x0400)
#define BS_TEXT             0x00000000L
#define BS_ICON             0x00000040L
#define BS_BITMAP           0x00000080L
#define BS_LEFT             0x00000100L
#define BS_RIGHT            0x00000200L
#define BS_CENTER           0x00000300L
#define BS_TOP              0x00000400L
#define BS_BOTTOM           0x00000800L
#define BS_VCENTER          0x00000C00L
#define BS_PUSHLIKE         0x00001000L
#define BS_MULTILINE        0x00002000L
#define BS_NOTIFY           0x00004000L
#define BS_FLAT             0x00008000L
#define BS_RIGHTBUTTON      BS_LEFTTEXT
#endif /* WINVER >= 0x0400 */

/*
 * User Button Notification Codes
 */
#define BN_CLICKED          0
#define BN_PAINT            1
#define BN_HILITE           2
#define BN_UNHILITE         3
#define BN_DISABLE          4
#define BN_DOUBLECLICKED    5
#if(WINVER >= 0x0400)
#define BN_PUSHED           BN_HILITE
#define BN_UNPUSHED         BN_UNHILITE
#define BN_DBLCLK           BN_DOUBLECLICKED
#define BN_SETFOCUS         6
#define BN_KILLFOCUS        7
#endif /* WINVER >= 0x0400 */

/*
 * Button Control Messages
 */
#define BM_GETCHECK        0x00F0
#define BM_SETCHECK        0x00F1
#define BM_GETSTATE        0x00F2
#define BM_SETSTATE        0x00F3
#define BM_SETSTYLE        0x00F4
#if(WINVER >= 0x0400)
#define BM_CLICK           0x00F5
#define BM_GETIMAGE        0x00F6
#define BM_SETIMAGE        0x00F7
#endif /* WINVER >= 0x0400 */
#if(WINVER >= 0x0600)
#define BM_SETDONTCLICK    0x00F8
#endif /* WINVER >= 0x0600 */

#if(WINVER >= 0x0400)
#define BST_UNCHECKED      0x0000
#define BST_CHECKED        0x0001
#define BST_INDETERMINATE  0x0002
#define BST_PUSHED         0x0004
#define BST_FOCUS          0x0008
#endif /* WINVER >= 0x0400 */

/*
 * Static Control Constants
 */
#define SS_LEFT             0x00000000L
#define SS_CENTER           0x00000001L
#define SS_RIGHT            0x00000002L
#define SS_ICON             0x00000003L
#define SS_BLACKRECT        0x00000004L
#define SS_GRAYRECT         0x00000005L
#define SS_WHITERECT        0x00000006L
#define SS_BLACKFRAME       0x00000007L
#define SS_GRAYFRAME        0x00000008L
#define SS_WHITEFRAME       0x00000009L
#define SS_USERITEM         0x0000000AL
#define SS_SIMPLE           0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#if(WINVER >= 0x0400)
#define SS_OWNERDRAW        0x0000000DL
#define SS_BITMAP           0x0000000EL
#define SS_ENHMETAFILE      0x0000000FL
#define SS_ETCHEDHORZ       0x00000010L
#define SS_ETCHEDVERT       0x00000011L
#define SS_ETCHEDFRAME      0x00000012L
#define SS_TYPEMASK         0x0000001FL
#endif /* WINVER >= 0x0400 */
#if(WINVER >= 0x0501)
#define SS_REALSIZECONTROL  0x00000040L
#endif /* WINVER >= 0x0501 */
#define SS_NOPREFIX         0x00000080L /* Don't do "&" character translation */
#if(WINVER >= 0x0400)
#define SS_NOTIFY           0x00000100L
#define SS_CENTERIMAGE      0x00000200L
#define SS_RIGHTJUST        0x00000400L
#define SS_REALSIZEIMAGE    0x00000800L
#define SS_SUNKEN           0x00001000L
#define SS_EDITCONTROL      0x00002000L
#define SS_ENDELLIPSIS      0x00004000L
#define SS_PATHELLIPSIS     0x00008000L
#define SS_WORDELLIPSIS     0x0000C000L
#define SS_ELLIPSISMASK     0x0000C000L
#endif /* WINVER >= 0x0400 */



#ifndef NOWINMESSAGES
/*
 * Static Control Mesages
 */
#define STM_SETICON         0x0170
#define STM_GETICON         0x0171
#if(WINVER >= 0x0400)
#define STM_SETIMAGE        0x0172
#define STM_GETIMAGE        0x0173
#define STN_CLICKED         0
#define STN_DBLCLK          1
#define STN_ENABLE          2
#define STN_DISABLE         3
#endif /* WINVER >= 0x0400 */
#define STM_MSGMAX          0x0174
#endif /* !NOWINMESSAGES */

/*
 * Dialog window class
 */
#define WC_DIALOG       (MAKEINTATOM(0x8002))

/*
 * Get/SetWindowWord/Long offsets for use with WC_DIALOG windows
 */
#define DWL_MSGRESULT   0
#define DWL_DLGPROC     4
#define DWL_USER        8

#ifdef _WIN64

#undef DWL_MSGRESULT
#undef DWL_DLGPROC
#undef DWL_USER

#endif /* _WIN64 */

#define DWLP_MSGRESULT  0
#define DWLP_DLGPROC    DWLP_MSGRESULT + sizeof(LRESULT)
#define DWLP_USER       DWLP_DLGPROC + sizeof(DLGPROC)

/*
 * Dialog Manager Routines
 */

#ifndef NOMSG

WINUSERAPI
BOOL
WINAPI
IsDialogMessageA(
    __in HWND hDlg,
    __in LPMSG lpMsg);
WINUSERAPI
BOOL
WINAPI
IsDialogMessageW(
    __in HWND hDlg,
    __in LPMSG lpMsg);
#ifdef UNICODE
#define IsDialogMessage  IsDialogMessageW
#else
#define IsDialogMessage  IsDialogMessageA
#endif // !UNICODE

#endif /* !NOMSG */

WINUSERAPI
BOOL
WINAPI
MapDialogRect(
    __in HWND hDlg,
    __inout LPRECT lpRect);

WINUSERAPI
int
WINAPI
DlgDirListA(
    __in HWND hDlg,
    __inout LPSTR lpPathSpec,
    __in int nIDListBox,
    __in int nIDStaticPath,
    __in UINT uFileType);
WINUSERAPI
int
WINAPI
DlgDirListW(
    __in HWND hDlg,
    __inout LPWSTR lpPathSpec,
    __in int nIDListBox,
    __in int nIDStaticPath,
    __in UINT uFileType);
#ifdef UNICODE
#define DlgDirList  DlgDirListW
#else
#define DlgDirList  DlgDirListA
#endif // !UNICODE

/*
 * DlgDirList, DlgDirListComboBox flags values
 */
#define DDL_READWRITE       0x0000
#define DDL_READONLY        0x0001
#define DDL_HIDDEN          0x0002
#define DDL_SYSTEM          0x0004
#define DDL_DIRECTORY       0x0010
#define DDL_ARCHIVE         0x0020

#define DDL_POSTMSGS        0x2000
#define DDL_DRIVES          0x4000
#define DDL_EXCLUSIVE       0x8000

WINUSERAPI
BOOL
WINAPI
DlgDirSelectExA(
    __in HWND hwndDlg,
    __out_ecount(chCount) LPSTR lpString,
    __in int chCount,
    __in int idListBox);
WINUSERAPI
BOOL
WINAPI
DlgDirSelectExW(
    __in HWND hwndDlg,
    __out_ecount(chCount) LPWSTR lpString,
    __in int chCount,
    __in int idListBox);
#ifdef UNICODE
#define DlgDirSelectEx  DlgDirSelectExW
#else
#define DlgDirSelectEx  DlgDirSelectExA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
DlgDirListComboBoxA(
    __in HWND hDlg,
    __inout LPSTR lpPathSpec,
    __in int nIDComboBox,
    __in int nIDStaticPath,
    __in UINT uFiletype);
WINUSERAPI
int
WINAPI
DlgDirListComboBoxW(
    __in HWND hDlg,
    __inout LPWSTR lpPathSpec,
    __in int nIDComboBox,
    __in int nIDStaticPath,
    __in UINT uFiletype);
#ifdef UNICODE
#define DlgDirListComboBox  DlgDirListComboBoxW
#else
#define DlgDirListComboBox  DlgDirListComboBoxA
#endif // !UNICODE

WINUSERAPI
BOOL
WINAPI
DlgDirSelectComboBoxExA(
    __in HWND hwndDlg,
    __out_ecount(cchOut) LPSTR lpString,
    __in int cchOut,
    __in int idComboBox);
WINUSERAPI
BOOL
WINAPI
DlgDirSelectComboBoxExW(
    __in HWND hwndDlg,
    __out_ecount(cchOut) LPWSTR lpString,
    __in int cchOut,
    __in int idComboBox);
#ifdef UNICODE
#define DlgDirSelectComboBoxEx  DlgDirSelectComboBoxExW
#else
#define DlgDirSelectComboBoxEx  DlgDirSelectComboBoxExA
#endif // !UNICODE



/*
 * Dialog Styles
 */
#define DS_ABSALIGN         0x01L
#define DS_SYSMODAL         0x02L
#define DS_LOCALEDIT        0x20L   /* Edit items get Local storage. */
#define DS_SETFONT          0x40L   /* User specified font for Dlg controls */
#define DS_MODALFRAME       0x80L   /* Can be combined with WS_CAPTION  */
#define DS_NOIDLEMSG        0x100L  /* WM_ENTERIDLE message will not be sent */
#define DS_SETFOREGROUND    0x200L  /* not in win3.1 */


#if(WINVER >= 0x0400)
#define DS_3DLOOK           0x0004L
#define DS_FIXEDSYS         0x0008L
#define DS_NOFAILCREATE     0x0010L
#define DS_CONTROL          0x0400L
#define DS_CENTER           0x0800L
#define DS_CENTERMOUSE      0x1000L
#define DS_CONTEXTHELP      0x2000L

#define DS_SHELLFONT        (DS_SETFONT | DS_FIXEDSYS)
#endif /* WINVER >= 0x0400 */

#if(_WIN32_WCE >= 0x0500)
#define DS_USEPIXELS        0x8000L
#endif


#define DM_GETDEFID         (WM_USER+0)
#define DM_SETDEFID         (WM_USER+1)

#if(WINVER >= 0x0400)
#define DM_REPOSITION       (WM_USER+2)
#endif /* WINVER >= 0x0400 */
/*
 * Returned in HIWORD() of DM_GETDEFID result if msg is supported
 */
#define DC_HASDEFID         0x534B

/*
 * Dialog Codes
 */
#define DLGC_WANTARROWS     0x0001      /* Control wants arrow keys         */
#define DLGC_WANTTAB        0x0002      /* Control wants tab keys           */
#define DLGC_WANTALLKEYS    0x0004      /* Control wants all keys           */
#define DLGC_WANTMESSAGE    0x0004      /* Pass message to control          */
#define DLGC_HASSETSEL      0x0008      /* Understands EM_SETSEL message    */
#define DLGC_DEFPUSHBUTTON  0x0010      /* Default pushbutton               */
#define DLGC_UNDEFPUSHBUTTON 0x0020     /* Non-default pushbutton           */
#define DLGC_RADIOBUTTON    0x0040      /* Radio button                     */
#define DLGC_WANTCHARS      0x0080      /* Want WM_CHAR messages            */
#define DLGC_STATIC         0x0100      /* Static item: don't include       */
#define DLGC_BUTTON         0x2000      /* Button item: can be checked      */

#define LB_CTLCODE          0L

/*
 * Listbox Return Values
 */
#define LB_OKAY             0
#define LB_ERR              (-1)
#define LB_ERRSPACE         (-2)

/*
**  The idStaticPath parameter to DlgDirList can have the following values
**  ORed if the list box should show other details of the files along with
**  the name of the files;
*/
                                  /* all other details also will be returned */


/*
 * Listbox Notification Codes
 */
#define LBN_ERRSPACE        (-2)
#define LBN_SELCHANGE       1
#define LBN_DBLCLK          2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5



#ifndef NOWINMESSAGES

/*
 * Listbox messages
 */
#define LB_ADDSTRING            0x0180
#define LB_INSERTSTRING         0x0181
#define LB_DELETESTRING         0x0182
#define LB_SELITEMRANGEEX       0x0183
#define LB_RESETCONTENT         0x0184
#define LB_SETSEL               0x0185
#define LB_SETCURSEL            0x0186
#define LB_GETSEL               0x0187
#define LB_GETCURSEL            0x0188
#define LB_GETTEXT              0x0189
#define LB_GETTEXTLEN           0x018A
#define LB_GETCOUNT             0x018B
#define LB_SELECTSTRING         0x018C
#define LB_DIR                  0x018D
#define LB_GETTOPINDEX          0x018E
#define LB_FINDSTRING           0x018F
#define LB_GETSELCOUNT          0x0190
#define LB_GETSELITEMS          0x0191
#define LB_SETTABSTOPS          0x0192
#define LB_GETHORIZONTALEXTENT  0x0193
#define LB_SETHORIZONTALEXTENT  0x0194
#define LB_SETCOLUMNWIDTH       0x0195
#define LB_ADDFILE              0x0196
#define LB_SETTOPINDEX          0x0197
#define LB_GETITEMRECT          0x0198
#define LB_GETITEMDATA          0x0199
#define LB_SETITEMDATA          0x019A
#define LB_SELITEMRANGE         0x019B
#define LB_SETANCHORINDEX       0x019C
#define LB_GETANCHORINDEX       0x019D
#define LB_SETCARETINDEX        0x019E
#define LB_GETCARETINDEX        0x019F
#define LB_SETITEMHEIGHT        0x01A0
#define LB_GETITEMHEIGHT        0x01A1
#define LB_FINDSTRINGEXACT      0x01A2
#define LB_SETLOCALE            0x01A5
#define LB_GETLOCALE            0x01A6
#define LB_SETCOUNT             0x01A7
#if(WINVER >= 0x0400)
#define LB_INITSTORAGE          0x01A8
#define LB_ITEMFROMPOINT        0x01A9
#endif /* WINVER >= 0x0400 */
#if(_WIN32_WCE >= 0x0400)
#define LB_MULTIPLEADDSTRING    0x01B1
#endif


#if(_WIN32_WINNT >= 0x0501)
#define LB_GETLISTBOXINFO       0x01B2
#endif /* _WIN32_WINNT >= 0x0501 */

#if(_WIN32_WINNT >= 0x0501)
#define LB_MSGMAX               0x01B3
#elif(_WIN32_WCE >= 0x0400)
#define LB_MSGMAX               0x01B1
#elif(WINVER >= 0x0400)
#define LB_MSGMAX               0x01B0
#else
#define LB_MSGMAX               0x01A8
#endif

#endif /* !NOWINMESSAGES */

#ifndef NOWINSTYLES


/*
 * Listbox Styles
 */
#define LBS_NOTIFY            0x0001L
#define LBS_SORT              0x0002L
#define LBS_NOREDRAW          0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL       0x0800L
#define LBS_DISABLENOSCROLL   0x1000L
#define LBS_NODATA            0x2000L
#if(WINVER >= 0x0400)
#define LBS_NOSEL             0x4000L
#endif /* WINVER >= 0x0400 */
#define LBS_COMBOBOX          0x8000L

#define LBS_STANDARD          (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)


#endif /* !NOWINSTYLES */


/*
 * Combo Box return Values
 */
#define CB_OKAY             0
#define CB_ERR              (-1)
#define CB_ERRSPACE         (-2)


/*
 * Combo Box Notification Codes
 */
#define CBN_ERRSPACE        (-1)
#define CBN_SELCHANGE       1
#define CBN_DBLCLK          2
#define CBN_SETFOCUS        3
#define CBN_KILLFOCUS       4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7
#define CBN_CLOSEUP         8
#define CBN_SELENDOK        9
#define CBN_SELENDCANCEL    10

#ifndef NOWINSTYLES

/*
 * Combo Box styles
 */
#define CBS_SIMPLE            0x0001L
#define CBS_DROPDOWN          0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#define CBS_DISABLENOSCROLL   0x0800L
#if(WINVER >= 0x0400)
#define CBS_UPPERCASE         0x2000L
#define CBS_LOWERCASE         0x4000L
#endif /* WINVER >= 0x0400 */

#endif  /* !NOWINSTYLES */


/*
 * Combo Box messages
 */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL               0x0140
#define CB_LIMITTEXT                0x0141
#define CB_SETEDITSEL               0x0142
#define CB_ADDSTRING                0x0143
#define CB_DELETESTRING             0x0144
#define CB_DIR                      0x0145
#define CB_GETCOUNT                 0x0146
#define CB_GETCURSEL                0x0147
#define CB_GETLBTEXT                0x0148
#define CB_GETLBTEXTLEN             0x0149
#define CB_INSERTSTRING             0x014A
#define CB_RESETCONTENT             0x014B
#define CB_FINDSTRING               0x014C
#define CB_SELECTSTRING             0x014D
#define CB_SETCURSEL                0x014E
#define CB_SHOWDROPDOWN             0x014F
#define CB_GETITEMDATA              0x0150
#define CB_SETITEMDATA              0x0151
#define CB_GETDROPPEDCONTROLRECT    0x0152
#define CB_SETITEMHEIGHT            0x0153
#define CB_GETITEMHEIGHT            0x0154
#define CB_SETEXTENDEDUI            0x0155
#define CB_GETEXTENDEDUI            0x0156
#define CB_GETDROPPEDSTATE          0x0157
#define CB_FINDSTRINGEXACT          0x0158
#define CB_SETLOCALE                0x0159
#define CB_GETLOCALE                0x015A
#if(WINVER >= 0x0400)
#define CB_GETTOPINDEX              0x015b
#define CB_SETTOPINDEX              0x015c
#define CB_GETHORIZONTALEXTENT      0x015d
#define CB_SETHORIZONTALEXTENT      0x015e
#define CB_GETDROPPEDWIDTH          0x015f
#define CB_SETDROPPEDWIDTH          0x0160
#define CB_INITSTORAGE              0x0161
#if(_WIN32_WCE >= 0x0400)
#define CB_MULTIPLEADDSTRING        0x0163
#endif
#endif /* WINVER >= 0x0400 */

#if(_WIN32_WINNT >= 0x0501)
#define CB_GETCOMBOBOXINFO          0x0164
#endif /* _WIN32_WINNT >= 0x0501 */

#if(_WIN32_WINNT >= 0x0501)
#define CB_MSGMAX                   0x0165
#elif(_WIN32_WCE >= 0x0400)
#define CB_MSGMAX                   0x0163
#elif(WINVER >= 0x0400)
#define CB_MSGMAX                   0x0162
#else
#define CB_MSGMAX                   0x015B
#endif
#endif  /* !NOWINMESSAGES */



#ifndef NOWINSTYLES


/*
 * Scroll Bar Styles
 */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L
#if(WINVER >= 0x0400)
#define SBS_SIZEGRIP                0x0010L
#endif /* WINVER >= 0x0400 */


#endif /* !NOWINSTYLES */

/*
 * Scroll bar messages
 */
#ifndef NOWINMESSAGES
#define SBM_SETPOS                  0x00E0 /*not in win3.1 */
#define SBM_GETPOS                  0x00E1 /*not in win3.1 */
#define SBM_SETRANGE                0x00E2 /*not in win3.1 */
#define SBM_SETRANGEREDRAW          0x00E6 /*not in win3.1 */
#define SBM_GETRANGE                0x00E3 /*not in win3.1 */
#define SBM_ENABLE_ARROWS           0x00E4 /*not in win3.1 */
#if(WINVER >= 0x0400)
#define SBM_SETSCROLLINFO           0x00E9
#define SBM_GETSCROLLINFO           0x00EA
#endif /* WINVER >= 0x0400 */

#if(_WIN32_WINNT >= 0x0501)
#define SBM_GETSCROLLBARINFO        0x00EB
#endif /* _WIN32_WINNT >= 0x0501 */

#if(WINVER >= 0x0400)
#define SIF_RANGE           0x0001
#define SIF_PAGE            0x0002
#define SIF_POS             0x0004
#define SIF_DISABLENOSCROLL 0x0008
#define SIF_TRACKPOS        0x0010
#define SIF_ALL             (SIF_RANGE | SIF_PAGE | SIF_POS | SIF_TRACKPOS)

typedef struct tagSCROLLINFO
{
    UINT    cbSize;
    UINT    fMask;
    int     nMin;
    int     nMax;
    UINT    nPage;
    int     nPos;
    int     nTrackPos;
}   SCROLLINFO, FAR *LPSCROLLINFO;
typedef SCROLLINFO CONST FAR *LPCSCROLLINFO;

WINUSERAPI
int
WINAPI
SetScrollInfo(
    __in HWND hwnd,
    __in int nBar,
    __in LPCSCROLLINFO lpsi,
    __in BOOL redraw);

WINUSERAPI
BOOL
WINAPI
GetScrollInfo(
    __in HWND hwnd,
    __in int nBar,
    __inout LPSCROLLINFO lpsi);

#endif /* WINVER >= 0x0400 */
#endif /* !NOWINMESSAGES */
#endif /* !NOCTLMGR */

#ifndef NOMDI

/*
 * MDI client style bits
 */
#define MDIS_ALLCHILDSTYLES    0x0001

/*
 * wParam Flags for WM_MDITILE and WM_MDICASCADE messages.
 */
#define MDITILE_VERTICAL       0x0000 /*not in win3.1 */
#define MDITILE_HORIZONTAL     0x0001 /*not in win3.1 */
#define MDITILE_SKIPDISABLED   0x0002 /*not in win3.1 */
#if(_WIN32_WINNT >= 0x0500)
#define MDITILE_ZORDER         0x0004
#endif /* _WIN32_WINNT >= 0x0500 */

typedef struct tagMDICREATESTRUCTA {
    LPCSTR   szClass;
    LPCSTR   szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        /* app-defined stuff */
} MDICREATESTRUCTA, *LPMDICREATESTRUCTA;
typedef struct tagMDICREATESTRUCTW {
    LPCWSTR  szClass;
    LPCWSTR  szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        /* app-defined stuff */
} MDICREATESTRUCTW, *LPMDICREATESTRUCTW;
#ifdef UNICODE
typedef MDICREATESTRUCTW MDICREATESTRUCT;
typedef LPMDICREATESTRUCTW LPMDICREATESTRUCT;
#else
typedef MDICREATESTRUCTA MDICREATESTRUCT;
typedef LPMDICREATESTRUCTA LPMDICREATESTRUCT;
#endif // UNICODE

typedef struct tagCLIENTCREATESTRUCT {
    HANDLE hWindowMenu;
    UINT idFirstChild;
} CLIENTCREATESTRUCT, *LPCLIENTCREATESTRUCT;

WINUSERAPI
LRESULT
WINAPI
DefFrameProcA(
    __in HWND hWnd,
    __in_opt HWND hWndMDIClient,
    __in UINT uMsg,
    __in WPARAM wParam,
    __in LPARAM lParam);
WINUSERAPI
LRESULT
WINAPI
DefFrameProcW(
    __in HWND hWnd,
    __in_opt HWND hWndMDIClient,
    __in UINT uMsg,
    __in WPARAM wParam,
    __in LPARAM lParam);
#ifdef UNICODE
#define DefFrameProc  DefFrameProcW
#else
#define DefFrameProc  DefFrameProcA
#endif // !UNICODE

WINUSERAPI
#ifndef _MAC
LRESULT
WINAPI
#else
LRESULT
CALLBACK
#endif
DefMDIChildProcA(
    __in HWND hWnd,
    __in UINT uMsg,
    __in WPARAM wParam,
    __in LPARAM lParam);
WINUSERAPI
#ifndef _MAC
LRESULT
WINAPI
#else
LRESULT
CALLBACK
#endif
DefMDIChildProcW(
    __in HWND hWnd,
    __in UINT uMsg,
    __in WPARAM wParam,
    __in LPARAM lParam);
#ifdef UNICODE
#define DefMDIChildProc  DefMDIChildProcW
#else
#define DefMDIChildProc  DefMDIChildProcA
#endif // !UNICODE

#ifndef NOMSG

WINUSERAPI
BOOL
WINAPI
TranslateMDISysAccel(
    __in HWND hWndClient,
    __in LPMSG lpMsg);

#endif /* !NOMSG */

WINUSERAPI
UINT
WINAPI
ArrangeIconicWindows(
    __in HWND hWnd);

WINUSERAPI
HWND
WINAPI
CreateMDIWindowA(
    __in LPCSTR lpClassName,
    __in LPCSTR lpWindowName,
    __in DWORD dwStyle,
    __in int X,
    __in int Y,
    __in int nWidth,
    __in int nHeight,
    __in_opt HWND hWndParent,
    __in_opt HINSTANCE hInstance,
    __in LPARAM lParam);
WINUSERAPI
HWND
WINAPI
CreateMDIWindowW(
    __in LPCWSTR lpClassName,
    __in LPCWSTR lpWindowName,
    __in DWORD dwStyle,
    __in int X,
    __in int Y,
    __in int nWidth,
    __in int nHeight,
    __in_opt HWND hWndParent,
    __in_opt HINSTANCE hInstance,
    __in LPARAM lParam);
#ifdef UNICODE
#define CreateMDIWindow  CreateMDIWindowW
#else
#define CreateMDIWindow  CreateMDIWindowA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINUSERAPI
WORD
WINAPI
TileWindows(
    __in_opt HWND hwndParent,
    __in UINT wHow,
    __in_opt CONST RECT * lpRect,
    __in UINT cKids,
    __in_ecount_opt(cKids) const HWND FAR * lpKids);

WINUSERAPI
WORD
WINAPI CascadeWindows(
    __in_opt HWND hwndParent,
    __in UINT wHow,
    __in_opt CONST RECT * lpRect,
    __in UINT cKids,
    __in_ecount_opt(cKids) const HWND FAR * lpKids);

#endif /* WINVER >= 0x0400 */
#endif /* !NOMDI */

#endif /* !NOUSER */

/****** Help support ********************************************************/

#ifndef NOHELP

typedef DWORD HELPPOLY;
typedef struct tagMULTIKEYHELPA {
#ifndef _MAC
    DWORD  mkSize;
#else
    WORD   mkSize;
#endif
    CHAR   mkKeylist;
    CHAR   szKeyphrase[1];
} MULTIKEYHELPA, *PMULTIKEYHELPA, *LPMULTIKEYHELPA;
typedef struct tagMULTIKEYHELPW {
#ifndef _MAC
    DWORD  mkSize;
#else
    WORD   mkSize;
#endif
    WCHAR  mkKeylist;
    WCHAR  szKeyphrase[1];
} MULTIKEYHELPW, *PMULTIKEYHELPW, *LPMULTIKEYHELPW;
#ifdef UNICODE
typedef MULTIKEYHELPW MULTIKEYHELP;
typedef PMULTIKEYHELPW PMULTIKEYHELP;
typedef LPMULTIKEYHELPW LPMULTIKEYHELP;
#else
typedef MULTIKEYHELPA MULTIKEYHELP;
typedef PMULTIKEYHELPA PMULTIKEYHELP;
typedef LPMULTIKEYHELPA LPMULTIKEYHELP;
#endif // UNICODE

typedef struct tagHELPWININFOA {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    CHAR   rgchMember[2];
} HELPWININFOA, *PHELPWININFOA, *LPHELPWININFOA;
typedef struct tagHELPWININFOW {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    WCHAR  rgchMember[2];
} HELPWININFOW, *PHELPWININFOW, *LPHELPWININFOW;
#ifdef UNICODE
typedef HELPWININFOW HELPWININFO;
typedef PHELPWININFOW PHELPWININFO;
typedef LPHELPWININFOW LPHELPWININFO;
#else
typedef HELPWININFOA HELPWININFO;
typedef PHELPWININFOA PHELPWININFO;
typedef LPHELPWININFOA LPHELPWININFO;
#endif // UNICODE


/*
 * Commands to pass to WinHelp()
 */
#define HELP_CONTEXT      0x0001L  /* Display topic in ulTopic */
#define HELP_QUIT         0x0002L  /* Terminate help */
#define HELP_INDEX        0x0003L  /* Display index */
#define HELP_CONTENTS     0x0003L
#define HELP_HELPONHELP   0x0004L  /* Display help on using help */
#define HELP_SETINDEX     0x0005L  /* Set current Index for multi index help */
#define HELP_SETCONTENTS  0x0005L
#define HELP_CONTEXTPOPUP 0x0008L
#define HELP_FORCEFILE    0x0009L
#define HELP_KEY          0x0101L  /* Display topic for keyword in offabData */
#define HELP_COMMAND      0x0102L
#define HELP_PARTIALKEY   0x0105L
#define HELP_MULTIKEY     0x0201L
#define HELP_SETWINPOS    0x0203L
#if(WINVER >= 0x0400)
#define HELP_CONTEXTMENU  0x000a
#define HELP_FINDER       0x000b
#define HELP_WM_HELP      0x000c
#define HELP_SETPOPUP_POS 0x000d

#define HELP_TCARD              0x8000
#define HELP_TCARD_DATA         0x0010
#define HELP_TCARD_OTHER_CALLER 0x0011

// These are in winhelp.h in Win95.
#define IDH_NO_HELP                     28440
#define IDH_MISSING_CONTEXT             28441 // Control doesn't have matching help context
#define IDH_GENERIC_HELP_BUTTON         28442 // Property sheet help button
#define IDH_OK                          28443
#define IDH_CANCEL                      28444
#define IDH_HELP                        28445

#endif /* WINVER >= 0x0400 */



WINUSERAPI
BOOL
WINAPI
WinHelpA(
    __in_opt HWND hWndMain,
    __in_opt LPCSTR lpszHelp,
    __in UINT uCommand,
    __in ULONG_PTR dwData);
WINUSERAPI
BOOL
WINAPI
WinHelpW(
    __in_opt HWND hWndMain,
    __in_opt LPCWSTR lpszHelp,
    __in UINT uCommand,
    __in ULONG_PTR dwData);
#ifdef UNICODE
#define WinHelp  WinHelpW
#else
#define WinHelp  WinHelpA
#endif // !UNICODE

#endif /* !NOHELP */

#if(WINVER >= 0x0500)

#define GR_GDIOBJECTS       0       /* Count of GDI objects */
#define GR_USEROBJECTS      1       /* Count of USER objects */
#endif /* WINVER >= 0x0500 */
#if(WINVER >= 0x0601)
#define GR_GDIOBJECTS_PEAK  2       /* Peak count of GDI objects */
#define GR_USEROBJECTS_PEAK 4       /* Peak count of USER objects */
#endif /* WINVER >= 0x0601 */

#if(WINVER >= 0x0601)
#define GR_GLOBAL           ((HANDLE)-2)
#endif /* WINVER >= 0x0601 */

#if(WINVER >= 0x0500)
WINUSERAPI
DWORD
WINAPI
GetGuiResources(
    __in HANDLE hProcess,
    __in DWORD uiFlags);
#endif /* WINVER >= 0x0500 */


#ifndef NOSYSPARAMSINFO

/*
 * Parameter for SystemParametersInfo.
 */

#define SPI_GETBEEP                 0x0001
#define SPI_SETBEEP                 0x0002
#define SPI_GETMOUSE                0x0003
#define SPI_SETMOUSE                0x0004
#define SPI_GETBORDER               0x0005
#define SPI_SETBORDER               0x0006
#define SPI_GETKEYBOARDSPEED        0x000A
#define SPI_SETKEYBOARDSPEED        0x000B
#define SPI_LANGDRIVER              0x000C
#define SPI_ICONHORIZONTALSPACING   0x000D
#define SPI_GETSCREENSAVETIMEOUT    0x000E
#define SPI_SETSCREENSAVETIMEOUT    0x000F
#define SPI_GETSCREENSAVEACTIVE     0x0010
#define SPI_SETSCREENSAVEACTIVE     0x0011
#define SPI_GETGRIDGRANULARITY      0x0012
#define SPI_SETGRIDGRANULARITY      0x0013
#define SPI_SETDESKWALLPAPER        0x0014
#define SPI_SETDESKPATTERN          0x0015
#define SPI_GETKEYBOARDDELAY        0x0016
#define SPI_SETKEYBOARDDELAY        0x0017
#define SPI_ICONVERTICALSPACING     0x0018
#define SPI_GETICONTITLEWRAP        0x0019
#define SPI_SETICONTITLEWRAP        0x001A
#define SPI_GETMENUDROPALIGNMENT    0x001B
#define SPI_SETMENUDROPALIGNMENT    0x001C
#define SPI_SETDOUBLECLKWIDTH       0x001D
#define SPI_SETDOUBLECLKHEIGHT      0x001E
#define SPI_GETICONTITLELOGFONT     0x001F
#define SPI_SETDOUBLECLICKTIME      0x0020
#define SPI_SETMOUSEBUTTONSWAP      0x0021
#define SPI_SETICONTITLELOGFONT     0x0022
#define SPI_GETFASTTASKSWITCH       0x0023
#define SPI_SETFASTTASKSWITCH       0x0024
#if(WINVER >= 0x0400)
#define SPI_SETDRAGFULLWINDOWS      0x0025
#define SPI_GETDRAGFULLWINDOWS      0x0026
#define SPI_GETNONCLIENTMETRICS     0x0029
#define SPI_SETNONCLIENTMETRICS     0x002A
#define SPI_GETMINIMIZEDMETRICS     0x002B
#define SPI_SETMINIMIZEDMETRICS     0x002C
#define SPI_GETICONMETRICS          0x002D
#define SPI_SETICONMETRICS          0x002E
#define SPI_SETWORKAREA             0x002F
#define SPI_GETWORKAREA             0x0030
#define SPI_SETPENWINDOWS           0x0031

#define SPI_GETHIGHCONTRAST         0x0042
#define SPI_SETHIGHCONTRAST         0x0043
#define SPI_GETKEYBOARDPREF         0x0044
#define SPI_SETKEYBOARDPREF         0x0045
#define SPI_GETSCREENREADER         0x0046
#define SPI_SETSCREENREADER         0x0047
#define SPI_GETANIMATION            0x0048
#define SPI_SETANIMATION            0x0049
#define SPI_GETFONTSMOOTHING        0x004A
#define SPI_SETFONTSMOOTHING        0x004B
#define SPI_SETDRAGWIDTH            0x004C
#define SPI_SETDRAGHEIGHT           0x004D
#define SPI_SETHANDHELD             0x004E
#define SPI_GETLOWPOWERTIMEOUT      0x004F
#define SPI_GETPOWEROFFTIMEOUT      0x0050
#define SPI_SETLOWPOWERTIMEOUT      0x0051
#define SPI_SETPOWEROFFTIMEOUT      0x0052
#define SPI_GETLOWPOWERACTIVE       0x0053
#define SPI_GETPOWEROFFACTIVE       0x0054
#define SPI_SETLOWPOWERACTIVE       0x0055
#define SPI_SETPOWEROFFACTIVE       0x0056
#define SPI_SETCURSORS              0x0057
#define SPI_SETICONS                0x0058
#define SPI_GETDEFAULTINPUTLANG     0x0059
#define SPI_SETDEFAULTINPUTLANG     0x005A
#define SPI_SETLANGTOGGLE           0x005B
#define SPI_GETWINDOWSEXTENSION     0x005C
#define SPI_SETMOUSETRAILS          0x005D
#define SPI_GETMOUSETRAILS          0x005E
#define SPI_SETSCREENSAVERRUNNING   0x0061
#define SPI_SCREENSAVERRUNNING     SPI_SETSCREENSAVERRUNNING
#endif /* WINVER >= 0x0400 */
#define SPI_GETFILTERKEYS          0x0032
#define SPI_SETFILTERKEYS          0x0033
#define SPI_GETTOGGLEKEYS          0x0034
#define SPI_SETTOGGLEKEYS          0x0035
#define SPI_GETMOUSEKEYS           0x0036
#define SPI_SETMOUSEKEYS           0x0037
#define SPI_GETSHOWSOUNDS          0x0038
#define SPI_SETSHOWSOUNDS          0x0039
#define SPI_GETSTICKYKEYS          0x003A
#define SPI_SETSTICKYKEYS          0x003B
#define SPI_GETACCESSTIMEOUT       0x003C
#define SPI_SETACCESSTIMEOUT       0x003D
#if(WINVER >= 0x0400)
#define SPI_GETSERIALKEYS          0x003E
#define SPI_SETSERIALKEYS          0x003F
#endif /* WINVER >= 0x0400 */
#define SPI_GETSOUNDSENTRY         0x0040
#define SPI_SETSOUNDSENTRY         0x0041
#if(_WIN32_WINNT >= 0x0400)
#define SPI_GETSNAPTODEFBUTTON     0x005F
#define SPI_SETSNAPTODEFBUTTON     0x0060
#endif /* _WIN32_WINNT >= 0x0400 */
#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
#define SPI_GETMOUSEHOVERWIDTH     0x0062
#define SPI_SETMOUSEHOVERWIDTH     0x0063
#define SPI_GETMOUSEHOVERHEIGHT    0x0064
#define SPI_SETMOUSEHOVERHEIGHT    0x0065
#define SPI_GETMOUSEHOVERTIME      0x0066
#define SPI_SETMOUSEHOVERTIME      0x0067
#define SPI_GETWHEELSCROLLLINES    0x0068
#define SPI_SETWHEELSCROLLLINES    0x0069
#define SPI_GETMENUSHOWDELAY       0x006A
#define SPI_SETMENUSHOWDELAY       0x006B

#if (_WIN32_WINNT >= 0x0600)
#define SPI_GETWHEELSCROLLCHARS   0x006C
#define SPI_SETWHEELSCROLLCHARS   0x006D
#endif

#define SPI_GETSHOWIMEUI          0x006E
#define SPI_SETSHOWIMEUI          0x006F
#endif


#if(WINVER >= 0x0500)
#define SPI_GETMOUSESPEED         0x0070
#define SPI_SETMOUSESPEED         0x0071
#define SPI_GETSCREENSAVERRUNNING 0x0072
#define SPI_GETDESKWALLPAPER      0x0073
#endif /* WINVER >= 0x0500 */

#if(WINVER >= 0x0600)
#define SPI_GETAUDIODESCRIPTION   0x0074
#define SPI_SETAUDIODESCRIPTION   0x0075

#define SPI_GETSCREENSAVESECURE   0x0076
#define SPI_SETSCREENSAVESECURE   0x0077
#endif /* WINVER >= 0x0600 */

#if(_WIN32_WINNT >= 0x0601)
#define SPI_GETHUNGAPPTIMEOUT           0x0078
#define SPI_SETHUNGAPPTIMEOUT           0x0079
#define SPI_GETWAITTOKILLTIMEOUT        0x007A
#define SPI_SETWAITTOKILLTIMEOUT        0x007B
#define SPI_GETWAITTOKILLSERVICETIMEOUT 0x007C
#define SPI_SETWAITTOKILLSERVICETIMEOUT 0x007D
#define SPI_GETMOUSEDOCKTHRESHOLD       0x007E
#define SPI_SETMOUSEDOCKTHRESHOLD       0x007F
#define SPI_GETPENDOCKTHRESHOLD         0x0080
#define SPI_SETPENDOCKTHRESHOLD         0x0081
#define SPI_GETWINARRANGING             0x0082
#define SPI_SETWINARRANGING             0x0083
#define SPI_GETMOUSEDRAGOUTTHRESHOLD    0x0084
#define SPI_SETMOUSEDRAGOUTTHRESHOLD    0x0085
#define SPI_GETPENDRAGOUTTHRESHOLD      0x0086
#define SPI_SETPENDRAGOUTTHRESHOLD      0x0087
#define SPI_GETMOUSESIDEMOVETHRESHOLD   0x0088
#define SPI_SETMOUSESIDEMOVETHRESHOLD   0x0089
#define SPI_GETPENSIDEMOVETHRESHOLD     0x008A
#define SPI_SETPENSIDEMOVETHRESHOLD     0x008B
#define SPI_GETDRAGFROMMAXIMIZE         0x008C
#define SPI_SETDRAGFROMMAXIMIZE         0x008D
#define SPI_GETSNAPSIZING               0x008E
#define SPI_SETSNAPSIZING               0x008F
#define SPI_GETDOCKMOVING               0x0090
#define SPI_SETDOCKMOVING               0x0091
#endif /* _WIN32_WINNT >= 0x0601 */


#if(WINVER >= 0x0500)
#define SPI_GETACTIVEWINDOWTRACKING         0x1000
#define SPI_SETACTIVEWINDOWTRACKING         0x1001
#define SPI_GETMENUANIMATION                0x1002
#define SPI_SETMENUANIMATION                0x1003
#define SPI_GETCOMBOBOXANIMATION            0x1004
#define SPI_SETCOMBOBOXANIMATION            0x1005
#define SPI_GETLISTBOXSMOOTHSCROLLING       0x1006
#define SPI_SETLISTBOXSMOOTHSCROLLING       0x1007
#define SPI_GETGRADIENTCAPTIONS             0x1008
#define SPI_SETGRADIENTCAPTIONS             0x1009
#define SPI_GETKEYBOARDCUES                 0x100A
#define SPI_SETKEYBOARDCUES                 0x100B
#define SPI_GETMENUUNDERLINES               SPI_GETKEYBOARDCUES
#define SPI_SETMENUUNDERLINES               SPI_SETKEYBOARDCUES
#define SPI_GETACTIVEWNDTRKZORDER           0x100C
#define SPI_SETACTIVEWNDTRKZORDER           0x100D
#define SPI_GETHOTTRACKING                  0x100E
#define SPI_SETHOTTRACKING                  0x100F
#define SPI_GETMENUFADE                     0x1012
#define SPI_SETMENUFADE                     0x1013
#define SPI_GETSELECTIONFADE                0x1014
#define SPI_SETSELECTIONFADE                0x1015
#define SPI_GETTOOLTIPANIMATION             0x1016
#define SPI_SETTOOLTIPANIMATION             0x1017
#define SPI_GETTOOLTIPFADE                  0x1018
#define SPI_SETTOOLTIPFADE                  0x1019
#define SPI_GETCURSORSHADOW                 0x101A
#define SPI_SETCURSORSHADOW                 0x101B
#if(_WIN32_WINNT >= 0x0501)
#define SPI_GETMOUSESONAR                   0x101C
#define SPI_SETMOUSESONAR                   0x101D
#define SPI_GETMOUSECLICKLOCK               0x101E
#define SPI_SETMOUSECLICKLOCK               0x101F
#define SPI_GETMOUSEVANISH                  0x1020
#define SPI_SETMOUSEVANISH                  0x1021
#define SPI_GETFLATMENU                     0x1022
#define SPI_SETFLATMENU                     0x1023
#define SPI_GETDROPSHADOW                   0x1024
#define SPI_SETDROPSHADOW                   0x1025
#define SPI_GETBLOCKSENDINPUTRESETS         0x1026
#define SPI_SETBLOCKSENDINPUTRESETS         0x1027
#endif /* _WIN32_WINNT >= 0x0501 */

#define SPI_GETUIEFFECTS                    0x103E
#define SPI_SETUIEFFECTS                    0x103F

#if(_WIN32_WINNT >= 0x0600)
#define SPI_GETDISABLEOVERLAPPEDCONTENT     0x1040
#define SPI_SETDISABLEOVERLAPPEDCONTENT     0x1041
#define SPI_GETCLIENTAREAANIMATION          0x1042
#define SPI_SETCLIENTAREAANIMATION          0x1043
#define SPI_GETCLEARTYPE                    0x1048
#define SPI_SETCLEARTYPE                    0x1049
#define SPI_GETSPEECHRECOGNITION            0x104A
#define SPI_SETSPEECHRECOGNITION            0x104B
#endif /* _WIN32_WINNT >= 0x0600 */

#define SPI_GETFOREGROUNDLOCKTIMEOUT        0x2000
#define SPI_SETFOREGROUNDLOCKTIMEOUT        0x2001
#define SPI_GETACTIVEWNDTRKTIMEOUT          0x2002
#define SPI_SETACTIVEWNDTRKTIMEOUT          0x2003
#define SPI_GETFOREGROUNDFLASHCOUNT         0x2004
#define SPI_SETFOREGROUNDFLASHCOUNT         0x2005
#define SPI_GETCARETWIDTH                   0x2006
#define SPI_SETCARETWIDTH                   0x2007

#if(_WIN32_WINNT >= 0x0501)
#define SPI_GETMOUSECLICKLOCKTIME           0x2008
#define SPI_SETMOUSECLICKLOCKTIME           0x2009
#define SPI_GETFONTSMOOTHINGTYPE            0x200A
#define SPI_SETFONTSMOOTHINGTYPE            0x200B

/* constants for SPI_GETFONTSMOOTHINGTYPE and SPI_SETFONTSMOOTHINGTYPE: */
#define FE_FONTSMOOTHINGSTANDARD            0x0001
#define FE_FONTSMOOTHINGCLEARTYPE           0x0002

#define SPI_GETFONTSMOOTHINGCONTRAST           0x200C
#define SPI_SETFONTSMOOTHINGCONTRAST           0x200D

#define SPI_GETFOCUSBORDERWIDTH             0x200E
#define SPI_SETFOCUSBORDERWIDTH             0x200F
#define SPI_GETFOCUSBORDERHEIGHT            0x2010
#define SPI_SETFOCUSBORDERHEIGHT            0x2011

#define SPI_GETFONTSMOOTHINGORIENTATION           0x2012
#define SPI_SETFONTSMOOTHINGORIENTATION           0x2013

/* constants for SPI_GETFONTSMOOTHINGORIENTATION and SPI_SETFONTSMOOTHINGORIENTATION: */
#define FE_FONTSMOOTHINGORIENTATIONBGR   0x0000
#define FE_FONTSMOOTHINGORIENTATIONRGB   0x0001
#endif /* _WIN32_WINNT >= 0x0501 */

#if(_WIN32_WINNT >= 0x0600)
#define SPI_GETMINIMUMHITRADIUS             0x2014
#define SPI_SETMINIMUMHITRADIUS             0x2015
#define SPI_GETMESSAGEDURATION              0x2016
#define SPI_SETMESSAGEDURATION              0x2017
#endif /* _WIN32_WINNT >= 0x0600 */

#endif /* WINVER >= 0x0500 */

/*
 * Flags
 */
#define SPIF_UPDATEINIFILE    0x0001
#define SPIF_SENDWININICHANGE 0x0002
#define SPIF_SENDCHANGE       SPIF_SENDWININICHANGE


#define METRICS_USEDEFAULT -1
#ifdef _WINGDI_
#ifndef NOGDI
typedef struct tagNONCLIENTMETRICSA
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTA lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTA lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTA lfMenuFont;
    LOGFONTA lfStatusFont;
    LOGFONTA lfMessageFont;
#if(WINVER >= 0x0600)
    int     iPaddedBorderWidth;
#endif /* WINVER >= 0x0600 */
}   NONCLIENTMETRICSA, *PNONCLIENTMETRICSA, FAR* LPNONCLIENTMETRICSA;
typedef struct tagNONCLIENTMETRICSW
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTW lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTW lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTW lfMenuFont;
    LOGFONTW lfStatusFont;
    LOGFONTW lfMessageFont;
#if(WINVER >= 0x0600)
    int     iPaddedBorderWidth;
#endif /* WINVER >= 0x0600 */
}   NONCLIENTMETRICSW, *PNONCLIENTMETRICSW, FAR* LPNONCLIENTMETRICSW;
#ifdef UNICODE
typedef NONCLIENTMETRICSW NONCLIENTMETRICS;
typedef PNONCLIENTMETRICSW PNONCLIENTMETRICS;
typedef LPNONCLIENTMETRICSW LPNONCLIENTMETRICS;
#else
typedef NONCLIENTMETRICSA NONCLIENTMETRICS;
typedef PNONCLIENTMETRICSA PNONCLIENTMETRICS;
typedef LPNONCLIENTMETRICSA LPNONCLIENTMETRICS;
#endif // UNICODE
#endif /* NOGDI */
#endif /* _WINGDI_ */

#define ARW_BOTTOMLEFT              0x0000L
#define ARW_BOTTOMRIGHT             0x0001L
#define ARW_TOPLEFT                 0x0002L
#define ARW_TOPRIGHT                0x0003L
#define ARW_STARTMASK               0x0003L
#define ARW_STARTRIGHT              0x0001L
#define ARW_STARTTOP                0x0002L

#define ARW_LEFT                    0x0000L
#define ARW_RIGHT                   0x0000L
#define ARW_UP                      0x0004L
#define ARW_DOWN                    0x0004L
#define ARW_HIDE                    0x0008L

typedef struct tagMINIMIZEDMETRICS
{
    UINT    cbSize;
    int     iWidth;
    int     iHorzGap;
    int     iVertGap;
    int     iArrange;
}   MINIMIZEDMETRICS, *PMINIMIZEDMETRICS, *LPMINIMIZEDMETRICS;

#ifdef _WINGDI_
#ifndef NOGDI
typedef struct tagICONMETRICSA
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTA lfFont;
}   ICONMETRICSA, *PICONMETRICSA, *LPICONMETRICSA;
typedef struct tagICONMETRICSW
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTW lfFont;
}   ICONMETRICSW, *PICONMETRICSW, *LPICONMETRICSW;
#ifdef UNICODE
typedef ICONMETRICSW ICONMETRICS;
typedef PICONMETRICSW PICONMETRICS;
typedef LPICONMETRICSW LPICONMETRICS;
#else
typedef ICONMETRICSA ICONMETRICS;
typedef PICONMETRICSA PICONMETRICS;
typedef LPICONMETRICSA LPICONMETRICS;
#endif // UNICODE
#endif /* NOGDI */
#endif /* _WINGDI_ */

typedef struct tagANIMATIONINFO
{
    UINT    cbSize;
    int     iMinAnimate;
}   ANIMATIONINFO, *LPANIMATIONINFO;

typedef struct tagSERIALKEYSA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR     lpszActivePort;
    LPSTR     lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}   SERIALKEYSA, *LPSERIALKEYSA;
typedef struct tagSERIALKEYSW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR    lpszActivePort;
    LPWSTR    lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}   SERIALKEYSW, *LPSERIALKEYSW;
#ifdef UNICODE
typedef SERIALKEYSW SERIALKEYS;
typedef LPSERIALKEYSW LPSERIALKEYS;
#else
typedef SERIALKEYSA SERIALKEYS;
typedef LPSERIALKEYSA LPSERIALKEYS;
#endif // UNICODE

/* flags for SERIALKEYS dwFlags field */
#define SERKF_SERIALKEYSON  0x00000001
#define SERKF_AVAILABLE     0x00000002
#define SERKF_INDICATOR     0x00000004


typedef struct tagHIGHCONTRASTA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR   lpszDefaultScheme;
}   HIGHCONTRASTA, *LPHIGHCONTRASTA;
typedef struct tagHIGHCONTRASTW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR  lpszDefaultScheme;
}   HIGHCONTRASTW, *LPHIGHCONTRASTW;
#ifdef UNICODE
typedef HIGHCONTRASTW HIGHCONTRAST;
typedef LPHIGHCONTRASTW LPHIGHCONTRAST;
#else
typedef HIGHCONTRASTA HIGHCONTRAST;
typedef LPHIGHCONTRASTA LPHIGHCONTRAST;
#endif // UNICODE

/* flags for HIGHCONTRAST dwFlags field */
#define HCF_HIGHCONTRASTON  0x00000001
#define HCF_AVAILABLE       0x00000002
#define HCF_HOTKEYACTIVE    0x00000004
#define HCF_CONFIRMHOTKEY   0x00000008
#define HCF_HOTKEYSOUND     0x00000010
#define HCF_INDICATOR       0x00000020
#define HCF_HOTKEYAVAILABLE 0x00000040
#define HCF_LOGONDESKTOP    0x00000100
#define HCF_DEFAULTDESKTOP  0x00000200

/* Flags for ChangeDisplaySettings */
#define CDS_UPDATEREGISTRY           0x00000001
#define CDS_TEST                     0x00000002
#define CDS_FULLSCREEN               0x00000004
#define CDS_GLOBAL                   0x00000008
#define CDS_SET_PRIMARY              0x00000010
#define CDS_VIDEOPARAMETERS          0x00000020
#if(WINVER >= 0x0600)
#define CDS_ENABLE_UNSAFE_MODES      0x00000100
#define CDS_DISABLE_UNSAFE_MODES     0x00000200
#endif /* WINVER >= 0x0600 */
#define CDS_RESET                    0x40000000
#define CDS_RESET_EX                 0x20000000
#define CDS_NORESET                  0x10000000

#include <tvout.h>

/* Return values for ChangeDisplaySettings */
#define DISP_CHANGE_SUCCESSFUL       0
#define DISP_CHANGE_RESTART          1
#define DISP_CHANGE_FAILED          -1
#define DISP_CHANGE_BADMODE         -2
#define DISP_CHANGE_NOTUPDATED      -3
#define DISP_CHANGE_BADFLAGS        -4
#define DISP_CHANGE_BADPARAM        -5
#if(_WIN32_WINNT >= 0x0501)
#define DISP_CHANGE_BADDUALVIEW     -6
#endif /* _WIN32_WINNT >= 0x0501 */

#ifdef _WINGDI_
#ifndef NOGDI

WINUSERAPI
LONG
WINAPI
ChangeDisplaySettingsA(
    __in_opt DEVMODEA* lpDevMode,
    __in DWORD dwFlags);
WINUSERAPI
LONG
WINAPI
ChangeDisplaySettingsW(
    __in_opt DEVMODEW* lpDevMode,
    __in DWORD dwFlags);
#ifdef UNICODE
#define ChangeDisplaySettings  ChangeDisplaySettingsW
#else
#define ChangeDisplaySettings  ChangeDisplaySettingsA
#endif // !UNICODE

WINUSERAPI
LONG
WINAPI
ChangeDisplaySettingsExA(
    __in_opt LPCSTR lpszDeviceName,
    __in_opt DEVMODEA* lpDevMode,
    __reserved HWND hwnd,
    __in DWORD dwflags,
    __in_opt LPVOID lParam);
WINUSERAPI
LONG
WINAPI
ChangeDisplaySettingsExW(
    __in_opt LPCWSTR lpszDeviceName,
    __in_opt DEVMODEW* lpDevMode,
    __reserved HWND hwnd,
    __in DWORD dwflags,
    __in_opt LPVOID lParam);
#ifdef UNICODE
#define ChangeDisplaySettingsEx  ChangeDisplaySettingsExW
#else
#define ChangeDisplaySettingsEx  ChangeDisplaySettingsExA
#endif // !UNICODE

#define ENUM_CURRENT_SETTINGS       ((DWORD)-1)
#define ENUM_REGISTRY_SETTINGS      ((DWORD)-2)

WINUSERAPI
BOOL
WINAPI
EnumDisplaySettingsA(
    __in_opt LPCSTR lpszDeviceName,
    __in DWORD iModeNum,
    __inout DEVMODEA* lpDevMode);
WINUSERAPI
BOOL
WINAPI
EnumDisplaySettingsW(
    __in_opt LPCWSTR lpszDeviceName,
    __in DWORD iModeNum,
    __inout DEVMODEW* lpDevMode);
#ifdef UNICODE
#define EnumDisplaySettings  EnumDisplaySettingsW
#else
#define EnumDisplaySettings  EnumDisplaySettingsA
#endif // !UNICODE

#if(WINVER >= 0x0500)

WINUSERAPI
BOOL
WINAPI
EnumDisplaySettingsExA(
    __in_opt LPCSTR lpszDeviceName,
    __in DWORD iModeNum,
    __inout DEVMODEA* lpDevMode,
    __in DWORD dwFlags);
WINUSERAPI
BOOL
WINAPI
EnumDisplaySettingsExW(
    __in_opt LPCWSTR lpszDeviceName,
    __in DWORD iModeNum,
    __inout DEVMODEW* lpDevMode,
    __in DWORD dwFlags);
#ifdef UNICODE
#define EnumDisplaySettingsEx  EnumDisplaySettingsExW
#else
#define EnumDisplaySettingsEx  EnumDisplaySettingsExA
#endif // !UNICODE

/* Flags for EnumDisplaySettingsEx */
#define EDS_RAWMODE                   0x00000002
#define EDS_ROTATEDMODE               0x00000004

WINUSERAPI
BOOL
WINAPI
EnumDisplayDevicesA(
    __in_opt LPCSTR lpDevice,
    __in DWORD iDevNum,
    __inout PDISPLAY_DEVICEA lpDisplayDevice,
    __in DWORD dwFlags);
WINUSERAPI
BOOL
WINAPI
EnumDisplayDevicesW(
    __in_opt LPCWSTR lpDevice,
    __in DWORD iDevNum,
    __inout PDISPLAY_DEVICEW lpDisplayDevice,
    __in DWORD dwFlags);
#ifdef UNICODE
#define EnumDisplayDevices  EnumDisplayDevicesW
#else
#define EnumDisplayDevices  EnumDisplayDevicesA
#endif // !UNICODE

/* Flags for EnumDisplayDevices */
#define EDD_GET_DEVICE_INTERFACE_NAME 0x00000001

#endif /* WINVER >= 0x0500 */

#if(WINVER >= 0x0601)

WINUSERAPI
LONG
WINAPI
GetDisplayConfigBufferSizes(
    __in UINT32 flags,
    __out UINT32* numPathArrayElements,
    __out UINT32* numModeInfoArrayElements);

WINUSERAPI
LONG
WINAPI
SetDisplayConfig(
    __in UINT32 numPathArrayElements,
    __in_ecount_opt(numPathArrayElements) DISPLAYCONFIG_PATH_INFO* pathArray,
    __in UINT32 numModeInfoArrayElements,
    __in_ecount_opt(numModeInfoArrayElements) DISPLAYCONFIG_MODE_INFO* modeInfoArray,
    __in UINT32 flags);

WINUSERAPI
LONG
WINAPI
QueryDisplayConfig(
    __in UINT32 flags,
    __inout UINT32* numPathArrayElements,
    __out_ecount_part(*numPathArrayElements, *numPathArrayElements) DISPLAYCONFIG_PATH_INFO* pathArray,
    __inout UINT32* numModeInfoArrayElements,
    __out_ecount_part(*numModeInfoArrayElements, *numModeInfoArrayElements) DISPLAYCONFIG_MODE_INFO* modeInfoArray,
    __out DISPLAYCONFIG_TOPOLOGY_ID* currentTopologyId);

WINUSERAPI
LONG
WINAPI
DisplayConfigGetDeviceInfo(
    __inout DISPLAYCONFIG_DEVICE_INFO_HEADER* requestPacket);

WINUSERAPI
LONG
WINAPI
DisplayConfigSetDeviceInfo(
    __in DISPLAYCONFIG_DEVICE_INFO_HEADER* setPacket);

#endif /* WINVER >= 0x0601 */

#endif /* NOGDI */
#endif /* _WINGDI_ */


WINUSERAPI
BOOL
WINAPI
SystemParametersInfoA(
    __in UINT uiAction,
    __in UINT uiParam,
    __inout_opt PVOID pvParam,
    __in UINT fWinIni);
WINUSERAPI
BOOL
WINAPI
SystemParametersInfoW(
    __in UINT uiAction,
    __in UINT uiParam,
    __inout_opt PVOID pvParam,
    __in UINT fWinIni);
#ifdef UNICODE
#define SystemParametersInfo  SystemParametersInfoW
#else
#define SystemParametersInfo  SystemParametersInfoA
#endif // !UNICODE


#endif  /* !NOSYSPARAMSINFO  */

/*
 * Accessibility support
 */
typedef struct tagFILTERKEYS
{
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iWaitMSec;            // Acceptance Delay
    DWORD iDelayMSec;           // Delay Until Repeat
    DWORD iRepeatMSec;          // Repeat Rate
    DWORD iBounceMSec;          // Debounce Time
} FILTERKEYS, *LPFILTERKEYS;

/*
 * FILTERKEYS dwFlags field
 */
#define FKF_FILTERKEYSON    0x00000001
#define FKF_AVAILABLE       0x00000002
#define FKF_HOTKEYACTIVE    0x00000004
#define FKF_CONFIRMHOTKEY   0x00000008
#define FKF_HOTKEYSOUND     0x00000010
#define FKF_INDICATOR       0x00000020
#define FKF_CLICKON         0x00000040

typedef struct tagSTICKYKEYS
{
    UINT  cbSize;
    DWORD dwFlags;
} STICKYKEYS, *LPSTICKYKEYS;

/*
 * STICKYKEYS dwFlags field
 */
#define SKF_STICKYKEYSON    0x00000001
#define SKF_AVAILABLE       0x00000002
#define SKF_HOTKEYACTIVE    0x00000004
#define SKF_CONFIRMHOTKEY   0x00000008
#define SKF_HOTKEYSOUND     0x00000010
#define SKF_INDICATOR       0x00000020
#define SKF_AUDIBLEFEEDBACK 0x00000040
#define SKF_TRISTATE        0x00000080
#define SKF_TWOKEYSOFF      0x00000100
#if(_WIN32_WINNT >= 0x0500)
#define SKF_LALTLATCHED       0x10000000
#define SKF_LCTLLATCHED       0x04000000
#define SKF_LSHIFTLATCHED     0x01000000
#define SKF_RALTLATCHED       0x20000000
#define SKF_RCTLLATCHED       0x08000000
#define SKF_RSHIFTLATCHED     0x02000000
#define SKF_LWINLATCHED       0x40000000
#define SKF_RWINLATCHED       0x80000000
#define SKF_LALTLOCKED        0x00100000
#define SKF_LCTLLOCKED        0x00040000
#define SKF_LSHIFTLOCKED      0x00010000
#define SKF_RALTLOCKED        0x00200000
#define SKF_RCTLLOCKED        0x00080000
#define SKF_RSHIFTLOCKED      0x00020000
#define SKF_LWINLOCKED        0x00400000
#define SKF_RWINLOCKED        0x00800000
#endif /* _WIN32_WINNT >= 0x0500 */

typedef struct tagMOUSEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iMaxSpeed;
    DWORD iTimeToMaxSpeed;
    DWORD iCtrlSpeed;
    DWORD dwReserved1;
    DWORD dwReserved2;
} MOUSEKEYS, *LPMOUSEKEYS;

/*
 * MOUSEKEYS dwFlags field
 */
#define MKF_MOUSEKEYSON     0x00000001
#define MKF_AVAILABLE       0x00000002
#define MKF_HOTKEYACTIVE    0x00000004
#define MKF_CONFIRMHOTKEY   0x00000008
#define MKF_HOTKEYSOUND     0x00000010
#define MKF_INDICATOR       0x00000020
#define MKF_MODIFIERS       0x00000040
#define MKF_REPLACENUMBERS  0x00000080
#if(_WIN32_WINNT >= 0x0500)
#define MKF_LEFTBUTTONSEL   0x10000000
#define MKF_RIGHTBUTTONSEL  0x20000000
#define MKF_LEFTBUTTONDOWN  0x01000000
#define MKF_RIGHTBUTTONDOWN 0x02000000
#define MKF_MOUSEMODE       0x80000000
#endif /* _WIN32_WINNT >= 0x0500 */

typedef struct tagACCESSTIMEOUT
{
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iTimeOutMSec;
} ACCESSTIMEOUT, *LPACCESSTIMEOUT;

/*
 * ACCESSTIMEOUT dwFlags field
 */
#define ATF_TIMEOUTON       0x00000001
#define ATF_ONOFFFEEDBACK   0x00000002

/* values for SOUNDSENTRY iFSGrafEffect field */
#define SSGF_NONE       0
#define SSGF_DISPLAY    3

/* values for SOUNDSENTRY iFSTextEffect field */
#define SSTF_NONE       0
#define SSTF_CHARS      1
#define SSTF_BORDER     2
#define SSTF_DISPLAY    3

/* values for SOUNDSENTRY iWindowsEffect field */
#define SSWF_NONE     0
#define SSWF_TITLE    1
#define SSWF_WINDOW   2
#define SSWF_DISPLAY  3
#define SSWF_CUSTOM   4

typedef struct tagSOUNDSENTRYA
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPSTR   lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYA, *LPSOUNDSENTRYA;
typedef struct tagSOUNDSENTRYW
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPWSTR  lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYW, *LPSOUNDSENTRYW;
#ifdef UNICODE
typedef SOUNDSENTRYW SOUNDSENTRY;
typedef LPSOUNDSENTRYW LPSOUNDSENTRY;
#else
typedef SOUNDSENTRYA SOUNDSENTRY;
typedef LPSOUNDSENTRYA LPSOUNDSENTRY;
#endif // UNICODE

/*
 * SOUNDSENTRY dwFlags field
 */
#define SSF_SOUNDSENTRYON   0x00000001
#define SSF_AVAILABLE       0x00000002
#define SSF_INDICATOR       0x00000004

#if(_WIN32_WINNT >= 0x0600)
WINUSERAPI
BOOL
WINAPI
SoundSentry(VOID);
#endif /* _WIN32_WINNT >= 0x0600 */

typedef struct tagTOGGLEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
} TOGGLEKEYS, *LPTOGGLEKEYS;

/*
 * TOGGLEKEYS dwFlags field
 */
#define TKF_TOGGLEKEYSON    0x00000001
#define TKF_AVAILABLE       0x00000002
#define TKF_HOTKEYACTIVE    0x00000004
#define TKF_CONFIRMHOTKEY   0x00000008
#define TKF_HOTKEYSOUND     0x00000010
#define TKF_INDICATOR       0x00000020

#if(_WIN32_WINNT >= 0x0600)
typedef struct tagAUDIODESCRIPTION {
    UINT cbSize;   // sizeof(AudioDescriptionType)
    BOOL Enabled;  // On/Off
    LCID Locale;   // locale ID for language
} AUDIODESCRIPTION, *LPAUDIODESCRIPTION;
#endif /* _WIN32_WINNT >= 0x0600 */


/*
 * Set debug level
 */

WINUSERAPI
VOID
WINAPI
SetDebugErrorLevel(
    __in DWORD dwLevel);

/*
 * SetLastErrorEx() types.
 */

#define SLE_ERROR       0x00000001
#define SLE_MINORERROR  0x00000002
#define SLE_WARNING     0x00000003

WINUSERAPI
VOID
WINAPI
SetLastErrorEx(
    __in DWORD dwErrCode,
    __in DWORD dwType);

WINUSERAPI
int
WINAPI
InternalGetWindowText(
    __in HWND hWnd,
    __out_ecount_part(cchMaxCount, return + 1) LPWSTR pString,
    __in int cchMaxCount);


#if defined(WINNT)
WINUSERAPI
BOOL
WINAPI
EndTask(
    __in HWND hWnd,
    __in BOOL fShutDown,
    __in BOOL fForce);
#endif

WINUSERAPI
BOOL
WINAPI
CancelShutdown(
    VOID);


#if(WINVER >= 0x0500)

/*
 * Multimonitor API.
 */

#define MONITOR_DEFAULTTONULL       0x00000000
#define MONITOR_DEFAULTTOPRIMARY    0x00000001
#define MONITOR_DEFAULTTONEAREST    0x00000002

WINUSERAPI
HMONITOR
WINAPI
MonitorFromPoint(
    __in POINT pt,
    __in DWORD dwFlags);

WINUSERAPI
HMONITOR
WINAPI
MonitorFromRect(
    __in LPCRECT lprc,
    __in DWORD dwFlags);

WINUSERAPI
HMONITOR
WINAPI
MonitorFromWindow(
    __in HWND hwnd,
    __in DWORD dwFlags);

#define MONITORINFOF_PRIMARY        0x00000001

#ifndef CCHDEVICENAME
#define CCHDEVICENAME 32
#endif

typedef struct tagMONITORINFO
{
    DWORD   cbSize;
    RECT    rcMonitor;
    RECT    rcWork;
    DWORD   dwFlags;
} MONITORINFO, *LPMONITORINFO;

#ifdef __cplusplus
typedef struct tagMONITORINFOEXA : public tagMONITORINFO
{
    CHAR        szDevice[CCHDEVICENAME];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW : public tagMONITORINFO
{
    WCHAR       szDevice[CCHDEVICENAME];
} MONITORINFOEXW, *LPMONITORINFOEXW;
#ifdef UNICODE
typedef MONITORINFOEXW MONITORINFOEX;
typedef LPMONITORINFOEXW LPMONITORINFOEX;
#else
typedef MONITORINFOEXA MONITORINFOEX;
typedef LPMONITORINFOEXA LPMONITORINFOEX;
#endif // UNICODE
#else // ndef __cplusplus
typedef struct tagMONITORINFOEXA
{
    MONITORINFO;
    CHAR        szDevice[CCHDEVICENAME];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW
{
    MONITORINFO;
    WCHAR       szDevice[CCHDEVICENAME];
} MONITORINFOEXW, *LPMONITORINFOEXW;
#ifdef UNICODE
typedef MONITORINFOEXW MONITORINFOEX;
typedef LPMONITORINFOEXW LPMONITORINFOEX;
#else
typedef MONITORINFOEXA MONITORINFOEX;
typedef LPMONITORINFOEXA LPMONITORINFOEX;
#endif // UNICODE
#endif

WINUSERAPI
BOOL
WINAPI
GetMonitorInfoA(
    __in HMONITOR hMonitor,
    __inout LPMONITORINFO lpmi);
WINUSERAPI
BOOL
WINAPI
GetMonitorInfoW(
    __in HMONITOR hMonitor,
    __inout LPMONITORINFO lpmi);
#ifdef UNICODE
#define GetMonitorInfo  GetMonitorInfoW
#else
#define GetMonitorInfo  GetMonitorInfoA
#endif // !UNICODE

typedef BOOL (CALLBACK* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);

WINUSERAPI
BOOL
WINAPI
EnumDisplayMonitors(
    __in_opt HDC hdc,
    __in_opt LPCRECT lprcClip,
    __in MONITORENUMPROC lpfnEnum,
    __in LPARAM dwData);


#ifndef NOWINABLE

/*
 * WinEvents - Active Accessibility hooks
 */

WINUSERAPI
VOID
WINAPI
NotifyWinEvent(
    __in DWORD event,
    __in HWND  hwnd,
    __in LONG  idObject,
    __in LONG  idChild);

typedef VOID (CALLBACK* WINEVENTPROC)(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,
    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime);

WINUSERAPI
HWINEVENTHOOK
WINAPI
SetWinEventHook(
    __in DWORD eventMin,
    __in DWORD eventMax,
    __in_opt HMODULE hmodWinEventProc,
    __in WINEVENTPROC pfnWinEventProc,
    __in DWORD idProcess,
    __in DWORD idThread,
    __in DWORD dwFlags);

#if(_WIN32_WINNT >= 0x0501)
WINUSERAPI
BOOL
WINAPI
IsWinEventHookInstalled(
    __in DWORD event);
#endif /* _WIN32_WINNT >= 0x0501 */

/*
 * dwFlags for SetWinEventHook
 */
#define WINEVENT_OUTOFCONTEXT   0x0000  // Events are ASYNC
#define WINEVENT_SKIPOWNTHREAD  0x0001  // Don't call back for events on installer's thread
#define WINEVENT_SKIPOWNPROCESS 0x0002  // Don't call back for events on installer's process
#define WINEVENT_INCONTEXT      0x0004  // Events are SYNC, this causes your dll to be injected into every process

WINUSERAPI
BOOL
WINAPI
UnhookWinEvent(
    __in HWINEVENTHOOK hWinEventHook);

/*
 * idObject values for WinEventProc and NotifyWinEvent
 */

/*
 * hwnd + idObject can be used with OLEACC.DLL's OleGetObjectFromWindow()
 * to get an interface pointer to the container.  indexChild is the item
 * within the container in question.  Setup a VARIANT with vt VT_I4 and
 * lVal the indexChild and pass that in to all methods.  Then you
 * are raring to go.
 */


/*
 * Common object IDs (cookies, only for sending WM_GETOBJECT to get at the
 * thing in question).  Positive IDs are reserved for apps (app specific),
 * negative IDs are system things and are global, 0 means "just little old
 * me".
 */
#define     CHILDID_SELF        0
#define     INDEXID_OBJECT      0
#define     INDEXID_CONTAINER   0

/*
 * Reserved IDs for system objects
 */
#define     OBJID_WINDOW        ((LONG)0x00000000)
#define     OBJID_SYSMENU       ((LONG)0xFFFFFFFF)
#define     OBJID_TITLEBAR      ((LONG)0xFFFFFFFE)
#define     OBJID_MENU          ((LONG)0xFFFFFFFD)
#define     OBJID_CLIENT        ((LONG)0xFFFFFFFC)
#define     OBJID_VSCROLL       ((LONG)0xFFFFFFFB)
#define     OBJID_HSCROLL       ((LONG)0xFFFFFFFA)
#define     OBJID_SIZEGRIP      ((LONG)0xFFFFFFF9)
#define     OBJID_CARET         ((LONG)0xFFFFFFF8)
#define     OBJID_CURSOR        ((LONG)0xFFFFFFF7)
#define     OBJID_ALERT         ((LONG)0xFFFFFFF6)
#define     OBJID_SOUND         ((LONG)0xFFFFFFF5)
#define     OBJID_QUERYCLASSNAMEIDX ((LONG)0xFFFFFFF4)
#define     OBJID_NATIVEOM      ((LONG)0xFFFFFFF0)

/*
 * EVENT DEFINITION
 */
#define EVENT_MIN           0x00000001
#define EVENT_MAX           0x7FFFFFFF

/*
 *  EVENT_SYSTEM_SOUND
 *  Sent when a sound is played.  Currently nothing is generating this, we
 *  this event when a system sound (for menus, etc) is played.  Apps
 *  generate this, if accessible, when a private sound is played.  For
 *  example, if Mail plays a "New Mail" sound.
 *
 *  System Sounds:
 *  (Generated by PlaySoundEvent in USER itself)
 *      hwnd            is NULL
 *      idObject        is OBJID_SOUND
 *      idChild         is sound child ID if one
 *  App Sounds:
 *  (PlaySoundEvent won't generate notification; up to app)
 *      hwnd + idObject gets interface pointer to Sound object
 *      idChild identifies the sound in question
 *  are going to be cleaning up the SOUNDSENTRY feature in the control panel
 *  and will use this at that time.  Applications implementing WinEvents
 *  are perfectly welcome to use it.  Clients of IAccessible* will simply
 *  turn around and get back a non-visual object that describes the sound.
 */
#define EVENT_SYSTEM_SOUND              0x0001

/*
 * EVENT_SYSTEM_ALERT
 * System Alerts:
 * (Generated by MessageBox() calls for example)
 *      hwnd            is hwndMessageBox
 *      idObject        is OBJID_ALERT
 * App Alerts:
 * (Generated whenever)
 *      hwnd+idObject gets interface pointer to Alert
 */
#define EVENT_SYSTEM_ALERT              0x0002

/*
 * EVENT_SYSTEM_FOREGROUND
 * Sent when the foreground (active) window changes, even if it is changing
 * to another window in the same thread as the previous one.
 *      hwnd            is hwndNewForeground
 *      idObject        is OBJID_WINDOW
 *      idChild    is INDEXID_OBJECT
 */
#define EVENT_SYSTEM_FOREGROUND         0x0003

/*
 * Menu
 *      hwnd            is window (top level window or popup menu window)
 *      idObject        is ID of control (OBJID_MENU, OBJID_SYSMENU, OBJID_SELF for popup)
 *      idChild         is CHILDID_SELF
 *
 * EVENT_SYSTEM_MENUSTART
 * EVENT_SYSTEM_MENUEND
 * For MENUSTART, hwnd+idObject+idChild refers to the control with the menu bar,
 *  or the control bringing up the context menu.
 *
 * Sent when entering into and leaving from menu mode (system, app bar, and
 * track popups).
 */
#define EVENT_SYSTEM_MENUSTART          0x0004
#define EVENT_SYSTEM_MENUEND            0x0005

/*
 * EVENT_SYSTEM_MENUPOPUPSTART
 * EVENT_SYSTEM_MENUPOPUPEND
 * Sent when a menu popup comes up and just before it is taken down.  Note
 * that for a call to TrackPopupMenu(), a client will see EVENT_SYSTEM_MENUSTART
 * followed almost immediately by EVENT_SYSTEM_MENUPOPUPSTART for the popup
 * being shown.
 *
 * For MENUPOPUP, hwnd+idObject+idChild refers to the NEW popup coming up, not the
 * parent item which is hierarchical.  You can get the parent menu/popup by
 * asking for the accParent object.
 */
#define EVENT_SYSTEM_MENUPOPUPSTART     0x0006
#define EVENT_SYSTEM_MENUPOPUPEND       0x0007


/*
 * EVENT_SYSTEM_CAPTURESTART
 * EVENT_SYSTEM_CAPTUREEND
 * Sent when a window takes the capture and releases the capture.
 */
#define EVENT_SYSTEM_CAPTURESTART       0x0008
#define EVENT_SYSTEM_CAPTUREEND         0x0009

/*
 * Move Size
 * EVENT_SYSTEM_MOVESIZESTART
 * EVENT_SYSTEM_MOVESIZEEND
 * Sent when a window enters and leaves move-size dragging mode.
 */
#define EVENT_SYSTEM_MOVESIZESTART      0x000A
#define EVENT_SYSTEM_MOVESIZEEND        0x000B

/*
 * Context Help
 * EVENT_SYSTEM_CONTEXTHELPSTART
 * EVENT_SYSTEM_CONTEXTHELPEND
 * Sent when a window enters and leaves context sensitive help mode.
 */
#define EVENT_SYSTEM_CONTEXTHELPSTART   0x000C
#define EVENT_SYSTEM_CONTEXTHELPEND     0x000D

/*
 * Drag & Drop
 * EVENT_SYSTEM_DRAGDROPSTART
 * EVENT_SYSTEM_DRAGDROPEND
 * Send the START notification just before going into drag&drop loop.  Send
 * the END notification just after canceling out.
 * Note that it is up to apps and OLE to generate this, since the system
 * doesn't know.  Like EVENT_SYSTEM_SOUND, it will be a while before this
 * is prevalent.
 */
#define EVENT_SYSTEM_DRAGDROPSTART      0x000E
#define EVENT_SYSTEM_DRAGDROPEND        0x000F

/*
 * Dialog
 * Send the START notification right after the dialog is completely
 *  initialized and visible.  Send the END right before the dialog
 *  is hidden and goes away.
 * EVENT_SYSTEM_DIALOGSTART
 * EVENT_SYSTEM_DIALOGEND
 */
#define EVENT_SYSTEM_DIALOGSTART        0x0010
#define EVENT_SYSTEM_DIALOGEND          0x0011

/*
 * EVENT_SYSTEM_SCROLLING
 * EVENT_SYSTEM_SCROLLINGSTART
 * EVENT_SYSTEM_SCROLLINGEND
 * Sent when beginning and ending the tracking of a scrollbar in a window,
 * and also for scrollbar controls.
 */
#define EVENT_SYSTEM_SCROLLINGSTART     0x0012
#define EVENT_SYSTEM_SCROLLINGEND       0x0013

/*
 * Alt-Tab Window
 * Send the START notification right after the switch window is initialized
 * and visible.  Send the END right before it is hidden and goes away.
 * EVENT_SYSTEM_SWITCHSTART
 * EVENT_SYSTEM_SWITCHEND
 */
#define EVENT_SYSTEM_SWITCHSTART        0x0014
#define EVENT_SYSTEM_SWITCHEND          0x0015

/*
 * EVENT_SYSTEM_MINIMIZESTART
 * EVENT_SYSTEM_MINIMIZEEND
 * Sent when a window minimizes and just before it restores.
 */
#define EVENT_SYSTEM_MINIMIZESTART      0x0016
#define EVENT_SYSTEM_MINIMIZEEND        0x0017


#if(_WIN32_WINNT >= 0x0600)
#define EVENT_SYSTEM_DESKTOPSWITCH      0x0020
#endif /* _WIN32_WINNT >= 0x0600 */


#if(_WIN32_WINNT >= 0x0601)
#define EVENT_SYSTEM_END        0x00FF

#define EVENT_OEM_DEFINED_START     0x0101
#define EVENT_OEM_DEFINED_END       0x01FF

#define EVENT_UIA_EVENTID_START         0x4E00
#define EVENT_UIA_EVENTID_END           0x4EFF

#define EVENT_UIA_PROPID_START          0x7500
#define EVENT_UIA_PROPID_END            0x75FF
#endif /* _WIN32_WINNT >= 0x0601 */

#if(_WIN32_WINNT >= 0x0501)
#define EVENT_CONSOLE_CARET             0x4001
#define EVENT_CONSOLE_UPDATE_REGION     0x4002
#define EVENT_CONSOLE_UPDATE_SIMPLE     0x4003
#define EVENT_CONSOLE_UPDATE_SCROLL     0x4004
#define EVENT_CONSOLE_LAYOUT            0x4005
#define EVENT_CONSOLE_START_APPLICATION 0x4006
#define EVENT_CONSOLE_END_APPLICATION   0x4007

/*
 * Flags for EVENT_CONSOLE_START/END_APPLICATION.
 */
#if defined(_WIN64)
#define CONSOLE_APPLICATION_16BIT       0x0000
#else
#define CONSOLE_APPLICATION_16BIT       0x0001
#endif

/*
 * Flags for EVENT_CONSOLE_CARET
 */
#define CONSOLE_CARET_SELECTION         0x0001
#define CONSOLE_CARET_VISIBLE           0x0002
#endif /* _WIN32_WINNT >= 0x0501 */

#if(_WIN32_WINNT >= 0x0601)
#define EVENT_CONSOLE_END       0x40FF
#endif /* _WIN32_WINNT >= 0x0601 */

/*
 * Object events
 *
 * The system AND apps generate these.  The system generates these for
 * real windows.  Apps generate these for objects within their window which
 * act like a separate control, e.g. an item in a list view.
 *
 * When the system generate them, dwParam2 is always WMOBJID_SELF.  When
 * apps generate them, apps put the has-meaning-to-the-app-only ID value
 * in dwParam2.
 * For all events, if you want detailed accessibility information, callers
 * should
 *      * Call AccessibleObjectFromWindow() with the hwnd, idObject parameters
 *          of the event, and IID_IAccessible as the REFIID, to get back an
 *          IAccessible* to talk to
 *      * Initialize and fill in a VARIANT as VT_I4 with lVal the idChild
 *          parameter of the event.
 *      * If idChild isn't zero, call get_accChild() in the container to see
 *          if the child is an object in its own right.  If so, you will get
 *          back an IDispatch* object for the child.  You should release the
 *          parent, and call QueryInterface() on the child object to get its
 *          IAccessible*.  Then you talk directly to the child.  Otherwise,
 *          if get_accChild() returns you nothing, you should continue to
 *          use the child VARIANT.  You will ask the container for the properties
 *          of the child identified by the VARIANT.  In other words, the
 *          child in this case is accessible but not a full-blown object.
 *          Like a button on a titlebar which is 'small' and has no children.
 */

/*
 * For all EVENT_OBJECT events,
 *      hwnd is the dude to Send the WM_GETOBJECT message to (unless NULL,
 *          see above for system things)
 *      idObject is the ID of the object that can resolve any queries a
 *          client might have.  It's a way to deal with windowless controls,
 *          controls that are just drawn on the screen in some larger parent
 *          window (like SDM), or standard frame elements of a window.
 *      idChild is the piece inside of the object that is affected.  This
 *          allows clients to access things that are too small to have full
 *          blown objects in their own right.  Like the thumb of a scrollbar.
 *          The hwnd/idObject pair gets you to the container, the dude you
 *          probably want to talk to most of the time anyway.  The idChild
 *          can then be passed into the acc properties to get the name/value
 *          of it as needed.
 *
 * Example #1:
 *      System propagating a listbox selection change
 *      EVENT_OBJECT_SELECTION
 *          hwnd == listbox hwnd
 *          idObject == OBJID_WINDOW
 *          idChild == new selected item, or CHILDID_SELF if
 *              nothing now selected within container.
 *      Word '97 propagating a listbox selection change
 *          hwnd == SDM window
 *          idObject == SDM ID to get at listbox 'control'
 *          idChild == new selected item, or CHILDID_SELF if
 *              nothing
 *
 * Example #2:
 *      System propagating a menu item selection on the menu bar
 *      EVENT_OBJECT_SELECTION
 *          hwnd == top level window
 *          idObject == OBJID_MENU
 *          idChild == ID of child menu bar item selected
 *
 * Example #3:
 *      System propagating a dropdown coming off of said menu bar item
 *      EVENT_OBJECT_CREATE
 *          hwnd == popup item
 *          idObject == OBJID_WINDOW
 *          idChild == CHILDID_SELF
 *
 * Example #4:
 *
 * For EVENT_OBJECT_REORDER, the object referred to by hwnd/idObject is the
 * PARENT container in which the zorder is occurring.  This is because if
 * one child is zordering, all of them are changing their relative zorder.
 */
#define EVENT_OBJECT_CREATE                 0x8000  // hwnd + ID + idChild is created item
#define EVENT_OBJECT_DESTROY                0x8001  // hwnd + ID + idChild is destroyed item
#define EVENT_OBJECT_SHOW                   0x8002  // hwnd + ID + idChild is shown item
#define EVENT_OBJECT_HIDE                   0x8003  // hwnd + ID + idChild is hidden item
#define EVENT_OBJECT_REORDER                0x8004  // hwnd + ID + idChild is parent of zordering children
/*
 * NOTE:
 * Minimize the number of notifications!
 *
 * When you are hiding a parent object, obviously all child objects are no
 * longer visible on screen.  They still have the same "visible" status,
 * but are not truly visible.  Hence do not send HIDE notifications for the
 * children also.  One implies all.  The same goes for SHOW.
 */


#define EVENT_OBJECT_FOCUS                  0x8005  // hwnd + ID + idChild is focused item
#define EVENT_OBJECT_SELECTION              0x8006  // hwnd + ID + idChild is selected item (if only one), or idChild is OBJID_WINDOW if complex
#define EVENT_OBJECT_SELECTIONADD           0x8007  // hwnd + ID + idChild is item added
#define EVENT_OBJECT_SELECTIONREMOVE        0x8008  // hwnd + ID + idChild is item removed
#define EVENT_OBJECT_SELECTIONWITHIN        0x8009  // hwnd + ID + idChild is parent of changed selected items

/*
 * NOTES:
 * There is only one "focused" child item in a parent.  This is the place
 * keystrokes are going at a given moment.  Hence only send a notification
 * about where the NEW focus is going.  A NEW item getting the focus already
 * implies that the OLD item is losing it.
 *
 * SELECTION however can be multiple.  Hence the different SELECTION
 * notifications.  Here's when to use each:
 *
 * (1) Send a SELECTION notification in the simple single selection
 *     case (like the focus) when the item with the selection is
 *     merely moving to a different item within a container.  hwnd + ID
 *     is the container control, idChildItem is the new child with the
 *     selection.
 *
 * (2) Send a SELECTIONADD notification when a new item has simply been added
 *     to the selection within a container.  This is appropriate when the
 *     number of newly selected items is very small.  hwnd + ID is the
 *     container control, idChildItem is the new child added to the selection.
 *
 * (3) Send a SELECTIONREMOVE notification when a new item has simply been
 *     removed from the selection within a container.  This is appropriate
 *     when the number of newly selected items is very small, just like
 *     SELECTIONADD.  hwnd + ID is the container control, idChildItem is the
 *     new child removed from the selection.
 *
 * (4) Send a SELECTIONWITHIN notification when the selected items within a
 *     control have changed substantially.  Rather than propagate a large
 *     number of changes to reflect removal for some items, addition of
 *     others, just tell somebody who cares that a lot happened.  It will
 *     be faster an easier for somebody watching to just turn around and
 *     query the container control what the new bunch of selected items
 *     are.
 */

#define EVENT_OBJECT_STATECHANGE            0x800A  // hwnd + ID + idChild is item w/ state change
/*
 * Examples of when to send an EVENT_OBJECT_STATECHANGE include
 *      * It is being enabled/disabled (USER does for windows)
 *      * It is being pressed/released (USER does for buttons)
 *      * It is being checked/unchecked (USER does for radio/check buttons)
 */
#define EVENT_OBJECT_LOCATIONCHANGE         0x800B  // hwnd + ID + idChild is moved/sized item

/*
 * Note:
 * A LOCATIONCHANGE is not sent for every child object when the parent
 * changes shape/moves.  Send one notification for the topmost object
 * that is changing.  For example, if the user resizes a top level window,
 * USER will generate a LOCATIONCHANGE for it, but not for the menu bar,
 * title bar, scrollbars, etc.  that are also changing shape/moving.
 *
 * In other words, it only generates LOCATIONCHANGE notifications for
 * real windows that are moving/sizing.  It will not generate a LOCATIONCHANGE
 * for every non-floating child window when the parent moves (the children are
 * logically moving also on screen, but not relative to the parent).
 *
 * Now, if the app itself resizes child windows as a result of being
 * sized, USER will generate LOCATIONCHANGEs for those dudes also because
 * it doesn't know better.
 *
 * Note also that USER will generate LOCATIONCHANGE notifications for two
 * non-window sys objects:
 *      (1) System caret
 *      (2) Cursor
 */

#define EVENT_OBJECT_NAMECHANGE             0x800C  // hwnd + ID + idChild is item w/ name change
#define EVENT_OBJECT_DESCRIPTIONCHANGE      0x800D  // hwnd + ID + idChild is item w/ desc change
#define EVENT_OBJECT_VALUECHANGE            0x800E  // hwnd + ID + idChild is item w/ value change
#define EVENT_OBJECT_PARENTCHANGE           0x800F  // hwnd + ID + idChild is item w/ new parent
#define EVENT_OBJECT_HELPCHANGE             0x8010  // hwnd + ID + idChild is item w/ help change
#define EVENT_OBJECT_DEFACTIONCHANGE        0x8011  // hwnd + ID + idChild is item w/ def action change
#define EVENT_OBJECT_ACCELERATORCHANGE      0x8012  // hwnd + ID + idChild is item w/ keybd accel change

#if(_WIN32_WINNT >= 0x0600)
#define EVENT_OBJECT_INVOKED                0x8013  // hwnd + ID + idChild is item invoked
#define EVENT_OBJECT_TEXTSELECTIONCHANGED   0x8014  // hwnd + ID + idChild is item w? test selection change

/*
 * EVENT_OBJECT_CONTENTSCROLLED
 * Sent when ending the scrolling of a window object.
 *
 * Unlike the similar event (EVENT_SYSTEM_SCROLLEND), this event will be
 * associated with the scrolling window itself. There is no difference
 * between horizontal or vertical scrolling.
 *
 * This event should be posted whenever scroll action is completed, including
 * when it is scrolled by scroll bars, mouse wheel, or keyboard navigations.
 *
 *   example:
 *          hwnd == window that is scrolling
 *          idObject == OBJID_CLIENT
 *          idChild == CHILDID_SELF
 */
#define EVENT_OBJECT_CONTENTSCROLLED        0x8015
#endif /* _WIN32_WINNT >= 0x0600 */

#if(_WIN32_WINNT >= 0x0601)
#define EVENT_SYSTEM_ARRANGMENTPREVIEW      0x8016
#endif /* _WIN32_WINNT >= 0x0601 */

#if(_WIN32_WINNT >= 0x0601)
#define EVENT_OBJECT_END                    0x80FF

#define EVENT_AIA_START                     0xA000
#define EVENT_AIA_END                       0xAFFF
#endif /* _WIN32_WINNT >= 0x0601 */


/*
 * Child IDs
 */


/*
 * System Sounds (idChild of system SOUND notification)
 */
#define SOUND_SYSTEM_STARTUP            1
#define SOUND_SYSTEM_SHUTDOWN           2
#define SOUND_SYSTEM_BEEP               3
#define SOUND_SYSTEM_ERROR              4
#define SOUND_SYSTEM_QUESTION           5
#define SOUND_SYSTEM_WARNING            6
#define SOUND_SYSTEM_INFORMATION        7
#define SOUND_SYSTEM_MAXIMIZE           8
#define SOUND_SYSTEM_MINIMIZE           9
#define SOUND_SYSTEM_RESTOREUP          10
#define SOUND_SYSTEM_RESTOREDOWN        11
#define SOUND_SYSTEM_APPSTART           12
#define SOUND_SYSTEM_FAULT              13
#define SOUND_SYSTEM_APPEND             14
#define SOUND_SYSTEM_MENUCOMMAND        15
#define SOUND_SYSTEM_MENUPOPUP          16
#define CSOUND_SYSTEM                   16

/*
 * System Alerts (indexChild of system ALERT notification)
 */
#define ALERT_SYSTEM_INFORMATIONAL      1       // MB_INFORMATION
#define ALERT_SYSTEM_WARNING            2       // MB_WARNING
#define ALERT_SYSTEM_ERROR              3       // MB_ERROR
#define ALERT_SYSTEM_QUERY              4       // MB_QUESTION
#define ALERT_SYSTEM_CRITICAL           5       // HardSysErrBox
#define CALERT_SYSTEM                   6

typedef struct tagGUITHREADINFO
{
    DWORD   cbSize;
    DWORD   flags;
    HWND    hwndActive;
    HWND    hwndFocus;
    HWND    hwndCapture;
    HWND    hwndMenuOwner;
    HWND    hwndMoveSize;
    HWND    hwndCaret;
    RECT    rcCaret;
} GUITHREADINFO, *PGUITHREADINFO, FAR * LPGUITHREADINFO;

#define GUI_CARETBLINKING   0x00000001
#define GUI_INMOVESIZE      0x00000002
#define GUI_INMENUMODE      0x00000004
#define GUI_SYSTEMMENUMODE  0x00000008
#define GUI_POPUPMENUMODE   0x00000010
#if(_WIN32_WINNT >= 0x0501)
#if defined(_WIN64)
#define GUI_16BITTASK       0x00000000
#else
#define GUI_16BITTASK       0x00000020
#endif
#endif /* _WIN32_WINNT >= 0x0501 */

WINUSERAPI
BOOL
WINAPI
GetGUIThreadInfo(
    __in DWORD idThread,
    __inout PGUITHREADINFO pgui);

WINUSERAPI
BOOL
WINAPI
BlockInput(
    BOOL fBlockIt);

#if(_WIN32_WINNT >= 0x0600)

#define USER_DEFAULT_SCREEN_DPI 96

WINUSERAPI
BOOL
WINAPI
SetProcessDPIAware(
    VOID);

WINUSERAPI
BOOL
WINAPI
IsProcessDPIAware(
    VOID);
#endif /* _WIN32_WINNT >= 0x0600 */

WINUSERAPI
UINT
WINAPI
GetWindowModuleFileNameA(
    __in HWND hwnd,
    __out_ecount_part(cchFileNameMax, return) LPSTR pszFileName,
    __in UINT cchFileNameMax);
WINUSERAPI
UINT
WINAPI
GetWindowModuleFileNameW(
    __in HWND hwnd,
    __out_ecount_part(cchFileNameMax, return) LPWSTR pszFileName,
    __in UINT cchFileNameMax);
#ifdef UNICODE
#define GetWindowModuleFileName  GetWindowModuleFileNameW
#else
#define GetWindowModuleFileName  GetWindowModuleFileNameA
#endif // !UNICODE

#ifndef NO_STATE_FLAGS
#define STATE_SYSTEM_UNAVAILABLE        0x00000001  // Disabled
#define STATE_SYSTEM_SELECTED           0x00000002
#define STATE_SYSTEM_FOCUSED            0x00000004
#define STATE_SYSTEM_PRESSED            0x00000008
#define STATE_SYSTEM_CHECKED            0x00000010
#define STATE_SYSTEM_MIXED              0x00000020  // 3-state checkbox or toolbar button
#define STATE_SYSTEM_INDETERMINATE      STATE_SYSTEM_MIXED
#define STATE_SYSTEM_READONLY           0x00000040
#define STATE_SYSTEM_HOTTRACKED         0x00000080
#define STATE_SYSTEM_DEFAULT            0x00000100
#define STATE_SYSTEM_EXPANDED           0x00000200
#define STATE_SYSTEM_COLLAPSED          0x00000400
#define STATE_SYSTEM_BUSY               0x00000800
#define STATE_SYSTEM_FLOATING           0x00001000  // Children "owned" not "contained" by parent
#define STATE_SYSTEM_MARQUEED           0x00002000
#define STATE_SYSTEM_ANIMATED           0x00004000
#define STATE_SYSTEM_INVISIBLE          0x00008000
#define STATE_SYSTEM_OFFSCREEN          0x00010000
#define STATE_SYSTEM_SIZEABLE           0x00020000
#define STATE_SYSTEM_MOVEABLE           0x00040000
#define STATE_SYSTEM_SELFVOICING        0x00080000
#define STATE_SYSTEM_FOCUSABLE          0x00100000
#define STATE_SYSTEM_SELECTABLE         0x00200000
#define STATE_SYSTEM_LINKED             0x00400000
#define STATE_SYSTEM_TRAVERSED          0x00800000
#define STATE_SYSTEM_MULTISELECTABLE    0x01000000  // Supports multiple selection
#define STATE_SYSTEM_EXTSELECTABLE      0x02000000  // Supports extended selection
#define STATE_SYSTEM_ALERT_LOW          0x04000000  // This information is of low priority
#define STATE_SYSTEM_ALERT_MEDIUM       0x08000000  // This information is of medium priority
#define STATE_SYSTEM_ALERT_HIGH         0x10000000  // This information is of high priority
#define STATE_SYSTEM_PROTECTED          0x20000000  // access to this is restricted
#define STATE_SYSTEM_VALID              0x3FFFFFFF
#endif

#define CCHILDREN_TITLEBAR              5
#define CCHILDREN_SCROLLBAR             5

/*
 * Information about the global cursor.
 */
typedef struct tagCURSORINFO
{
    DWORD   cbSize;
    DWORD   flags;
    HCURSOR hCursor;
    POINT   ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;

#define CURSOR_SHOWING     0x00000001

WINUSERAPI
BOOL
WINAPI
GetCursorInfo(
    __inout PCURSORINFO pci);

/*
 * Window information snapshot
 */
typedef struct tagWINDOWINFO
{
    DWORD cbSize;
    RECT rcWindow;
    RECT rcClient;
    DWORD dwStyle;
    DWORD dwExStyle;
    DWORD dwWindowStatus;
    UINT cxWindowBorders;
    UINT cyWindowBorders;
    ATOM atomWindowType;
    WORD wCreatorVersion;
} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;

#define WS_ACTIVECAPTION    0x0001

WINUSERAPI
BOOL
WINAPI
GetWindowInfo(
    __in HWND hwnd,
    __inout PWINDOWINFO pwi);

/*
 * Titlebar information.
 */
typedef struct tagTITLEBARINFO
{
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[CCHILDREN_TITLEBAR + 1];
} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;

WINUSERAPI
BOOL
WINAPI
GetTitleBarInfo(
    __in HWND hwnd,
    __inout PTITLEBARINFO pti);

#if(WINVER >= 0x0600)
typedef struct tagTITLEBARINFOEX
{
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[CCHILDREN_TITLEBAR + 1];
    RECT rgrect[CCHILDREN_TITLEBAR + 1];
} TITLEBARINFOEX, *PTITLEBARINFOEX, *LPTITLEBARINFOEX;
#endif /* WINVER >= 0x0600 */

/*
 * Menubar information
 */
typedef struct tagMENUBARINFO
{
    DWORD cbSize;
    RECT rcBar;          // rect of bar, popup, item
    HMENU hMenu;         // real menu handle of bar, popup
    HWND hwndMenu;       // hwnd of item submenu if one
    BOOL fBarFocused:1;  // bar, popup has the focus
    BOOL fFocused:1;     // item has the focus
} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;

WINUSERAPI
BOOL
WINAPI
GetMenuBarInfo(
    __in HWND hwnd,
    __in LONG idObject,
    __in LONG idItem,
    __inout PMENUBARINFO pmbi);

/*
 * Scrollbar information
 */
typedef struct tagSCROLLBARINFO
{
    DWORD cbSize;
    RECT rcScrollBar;
    int dxyLineButton;
    int xyThumbTop;
    int xyThumbBottom;
    int reserved;
    DWORD rgstate[CCHILDREN_SCROLLBAR + 1];
} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;

WINUSERAPI
BOOL
WINAPI
GetScrollBarInfo(
    __in HWND hwnd,
    __in LONG idObject,
    __inout PSCROLLBARINFO psbi);

/*
 * Combobox information
 */
typedef struct tagCOMBOBOXINFO
{
    DWORD cbSize;
    RECT rcItem;
    RECT rcButton;
    DWORD stateButton;
    HWND hwndCombo;
    HWND hwndItem;
    HWND hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;

WINUSERAPI
BOOL
WINAPI
GetComboBoxInfo(
    __in HWND hwndCombo,
    __inout PCOMBOBOXINFO pcbi);

/*
 * The "real" ancestor window
 */
#define     GA_PARENT       1
#define     GA_ROOT         2
#define     GA_ROOTOWNER    3

WINUSERAPI
HWND
WINAPI
GetAncestor(
    __in HWND hwnd,
    __in UINT gaFlags);


/*
 * This gets the REAL child window at the point.  If it is in the dead
 * space of a group box, it will try a sibling behind it.  But static
 * fields will get returned.  In other words, it is kind of a cross between
 * ChildWindowFromPointEx and WindowFromPoint.
 */
WINUSERAPI
HWND
WINAPI
RealChildWindowFromPoint(
    __in HWND hwndParent,
    __in POINT ptParentClientCoords);


/*
 * This gets the name of the window TYPE, not class.  This allows us to
 * recognize ThunderButton32 et al.
 */
WINUSERAPI
UINT
WINAPI
RealGetWindowClassA(
    __in HWND hwnd,
    __out_ecount_part(cchClassNameMax, return) LPSTR ptszClassName,
    __in UINT cchClassNameMax);
/*
 * This gets the name of the window TYPE, not class.  This allows us to
 * recognize ThunderButton32 et al.
 */
WINUSERAPI
UINT
WINAPI
RealGetWindowClassW(
    __in HWND hwnd,
    __out_ecount_part(cchClassNameMax, return) LPWSTR ptszClassName,
    __in UINT cchClassNameMax);
#ifdef UNICODE
#define RealGetWindowClass  RealGetWindowClassW
#else
#define RealGetWindowClass  RealGetWindowClassA
#endif // !UNICODE

/*
 * Alt-Tab Switch window information.
 */
typedef struct tagALTTABINFO
{
    DWORD cbSize;
    int cItems;
    int cColumns;
    int cRows;
    int iColFocus;
    int iRowFocus;
    int cxItem;
    int cyItem;
    POINT ptStart;
} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;

WINUSERAPI
BOOL
WINAPI
GetAltTabInfoA(
    __in_opt HWND hwnd,
    __in int iItem,
    __inout PALTTABINFO pati,
    __out_ecount_opt(cchItemText) LPSTR pszItemText,
    __in UINT cchItemText);
WINUSERAPI
BOOL
WINAPI
GetAltTabInfoW(
    __in_opt HWND hwnd,
    __in int iItem,
    __inout PALTTABINFO pati,
    __out_ecount_opt(cchItemText) LPWSTR pszItemText,
    __in UINT cchItemText);
#ifdef UNICODE
#define GetAltTabInfo  GetAltTabInfoW
#else
#define GetAltTabInfo  GetAltTabInfoA
#endif // !UNICODE

/*
 * Listbox information.
 * Returns the number of items per row.
 */
WINUSERAPI
DWORD
WINAPI
GetListBoxInfo(
    __in HWND hwnd);

#endif /* NOWINABLE */
#endif /* WINVER >= 0x0500 */


#if(_WIN32_WINNT >= 0x0500)
WINUSERAPI
BOOL
WINAPI
LockWorkStation(
    VOID);
#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0500)

WINUSERAPI
BOOL
WINAPI
UserHandleGrantAccess(
    __in HANDLE hUserHandle,
    __in HANDLE hJob,
    __in BOOL   bGrant);

#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0501)

/*
 * Raw Input Messages.
 */

DECLARE_HANDLE(HRAWINPUT);

/*
 * WM_INPUT wParam
 */

/*
 * Use this macro to get the input code from wParam.
 */
#define GET_RAWINPUT_CODE_WPARAM(wParam)    ((wParam) & 0xff)

/*
 * The input is in the regular message flow,
 * the app is required to call DefWindowProc
 * so that the system can perform clean ups.
 */
#define RIM_INPUT       0

/*
 * The input is sink only. The app is expected
 * to behave nicely.
 */
#define RIM_INPUTSINK   1


/*
 * Raw Input data header
 */
typedef struct tagRAWINPUTHEADER {
    DWORD dwType;
    DWORD dwSize;
    HANDLE hDevice;
    WPARAM wParam;
} RAWINPUTHEADER, *PRAWINPUTHEADER, *LPRAWINPUTHEADER;

/*
 * Type of the raw input
 */
#define RIM_TYPEMOUSE       0
#define RIM_TYPEKEYBOARD    1
#define RIM_TYPEHID         2

/*
 * Raw format of the mouse input
 */
typedef struct tagRAWMOUSE {
    /*
     * Indicator flags.
     */
    USHORT usFlags;

    /*
     * The transition state of the mouse buttons.
     */
    union {
        ULONG ulButtons;
        struct  {
            USHORT  usButtonFlags;
            USHORT  usButtonData;
        };
    };


    /*
     * The raw state of the mouse buttons.
     */
    ULONG ulRawButtons;

    /*
     * The signed relative or absolute motion in the X direction.
     */
    LONG lLastX;

    /*
     * The signed relative or absolute motion in the Y direction.
     */
    LONG lLastY;

    /*
     * Device-specific additional information for the event.
     */
    ULONG ulExtraInformation;

} RAWMOUSE, *PRAWMOUSE, *LPRAWMOUSE;

/*
 * Define the mouse button state indicators.
 */

#define RI_MOUSE_LEFT_BUTTON_DOWN   0x0001  // Left Button changed to down.
#define RI_MOUSE_LEFT_BUTTON_UP     0x0002  // Left Button changed to up.
#define RI_MOUSE_RIGHT_BUTTON_DOWN  0x0004  // Right Button changed to down.
#define RI_MOUSE_RIGHT_BUTTON_UP    0x0008  // Right Button changed to up.
#define RI_MOUSE_MIDDLE_BUTTON_DOWN 0x0010  // Middle Button changed to down.
#define RI_MOUSE_MIDDLE_BUTTON_UP   0x0020  // Middle Button changed to up.

#define RI_MOUSE_BUTTON_1_DOWN      RI_MOUSE_LEFT_BUTTON_DOWN
#define RI_MOUSE_BUTTON_1_UP        RI_MOUSE_LEFT_BUTTON_UP
#define RI_MOUSE_BUTTON_2_DOWN      RI_MOUSE_RIGHT_BUTTON_DOWN
#define RI_MOUSE_BUTTON_2_UP        RI_MOUSE_RIGHT_BUTTON_UP
#define RI_MOUSE_BUTTON_3_DOWN      RI_MOUSE_MIDDLE_BUTTON_DOWN
#define RI_MOUSE_BUTTON_3_UP        RI_MOUSE_MIDDLE_BUTTON_UP

#define RI_MOUSE_BUTTON_4_DOWN      0x0040
#define RI_MOUSE_BUTTON_4_UP        0x0080
#define RI_MOUSE_BUTTON_5_DOWN      0x0100
#define RI_MOUSE_BUTTON_5_UP        0x0200

/*
 * If usButtonFlags has RI_MOUSE_WHEEL, the wheel delta is stored in usButtonData.
 * Take it as a signed value.
 */
#define RI_MOUSE_WHEEL              0x0400

/*
 * Define the mouse indicator flags.
 */
#define MOUSE_MOVE_RELATIVE         0
#define MOUSE_MOVE_ABSOLUTE         1
#define MOUSE_VIRTUAL_DESKTOP    0x02  // the coordinates are mapped to the virtual desktop
#define MOUSE_ATTRIBUTES_CHANGED 0x04  // requery for mouse attributes
#if(WINVER >= 0x0600)
#define MOUSE_MOVE_NOCOALESCE    0x08  // do not coalesce mouse moves
#endif /* WINVER >= 0x0600 */

/*
 * Raw format of the keyboard input
 */
typedef struct tagRAWKEYBOARD {
    /*
     * The "make" scan code (key depression).
     */
    USHORT MakeCode;

    /*
     * The flags field indicates a "break" (key release) and other
     * miscellaneous scan code information defined in ntddkbd.h.
     */
    USHORT Flags;

    USHORT Reserved;

    /*
     * Windows message compatible information
     */
    USHORT VKey;
    UINT   Message;

    /*
     * Device-specific additional information for the event.
     */
    ULONG ExtraInformation;


} RAWKEYBOARD, *PRAWKEYBOARD, *LPRAWKEYBOARD;


/*
 * Define the keyboard overrun MakeCode.
 */

#define KEYBOARD_OVERRUN_MAKE_CODE    0xFF

/*
 * Define the keyboard input data Flags.
 */
#define RI_KEY_MAKE             0
#define RI_KEY_BREAK            1
#define RI_KEY_E0               2
#define RI_KEY_E1               4
#define RI_KEY_TERMSRV_SET_LED  8
#define RI_KEY_TERMSRV_SHADOW   0x10


/*
 * Raw format of the input from Human Input Devices
 */
typedef struct tagRAWHID {
    DWORD dwSizeHid;    // byte size of each report
    DWORD dwCount;      // number of input packed
    BYTE bRawData[1];
} RAWHID, *PRAWHID, *LPRAWHID;

/*
 * RAWINPUT data structure.
 */
typedef struct tagRAWINPUT {
    RAWINPUTHEADER header;
    union {
        RAWMOUSE    mouse;
        RAWKEYBOARD keyboard;
        RAWHID      hid;
    } data;
} RAWINPUT, *PRAWINPUT, *LPRAWINPUT;

#ifdef _WIN64
#define RAWINPUT_ALIGN(x)   (((x) + sizeof(QWORD) - 1) & ~(sizeof(QWORD) - 1))
#else   // _WIN64
#define RAWINPUT_ALIGN(x)   (((x) + sizeof(DWORD) - 1) & ~(sizeof(DWORD) - 1))
#endif  // _WIN64

#define NEXTRAWINPUTBLOCK(ptr) ((PRAWINPUT)RAWINPUT_ALIGN((ULONG_PTR)((PBYTE)(ptr) + (ptr)->header.dwSize)))

/*
 * Flags for GetRawInputData
 */

#define RID_INPUT               0x10000003
#define RID_HEADER              0x10000005

WINUSERAPI
UINT
WINAPI
GetRawInputData(
    __in HRAWINPUT hRawInput,
    __in UINT uiCommand,
    __out_bcount_part_opt(*pcbSize, return) LPVOID pData,
    __inout PUINT pcbSize,
    __in UINT cbSizeHeader);

/*
 * Raw Input Device Information
 */
#define RIDI_PREPARSEDDATA      0x20000005
#define RIDI_DEVICENAME         0x20000007  // the return valus is the character length, not the byte size
#define RIDI_DEVICEINFO         0x2000000b

typedef struct tagRID_DEVICE_INFO_MOUSE {
    DWORD dwId;
    DWORD dwNumberOfButtons;
    DWORD dwSampleRate;
    BOOL  fHasHorizontalWheel;
} RID_DEVICE_INFO_MOUSE, *PRID_DEVICE_INFO_MOUSE;

typedef struct tagRID_DEVICE_INFO_KEYBOARD {
    DWORD dwType;
    DWORD dwSubType;
    DWORD dwKeyboardMode;
    DWORD dwNumberOfFunctionKeys;
    DWORD dwNumberOfIndicators;
    DWORD dwNumberOfKeysTotal;
} RID_DEVICE_INFO_KEYBOARD, *PRID_DEVICE_INFO_KEYBOARD;

typedef struct tagRID_DEVICE_INFO_HID {
    DWORD dwVendorId;
    DWORD dwProductId;
    DWORD dwVersionNumber;

    /*
     * Top level collection UsagePage and Usage
     */
    USHORT usUsagePage;
    USHORT usUsage;
} RID_DEVICE_INFO_HID, *PRID_DEVICE_INFO_HID;

typedef struct tagRID_DEVICE_INFO {
    DWORD cbSize;
    DWORD dwType;
    union {
        RID_DEVICE_INFO_MOUSE mouse;
        RID_DEVICE_INFO_KEYBOARD keyboard;
        RID_DEVICE_INFO_HID hid;
    };
} RID_DEVICE_INFO, *PRID_DEVICE_INFO, *LPRID_DEVICE_INFO;

WINUSERAPI
UINT
WINAPI
GetRawInputDeviceInfoA(
    __in_opt HANDLE hDevice,
    __in UINT uiCommand,
    __inout_bcount_part_opt(*pcbSize, *pcbSize) LPVOID pData,
    __inout PUINT pcbSize);
WINUSERAPI
UINT
WINAPI
GetRawInputDeviceInfoW(
    __in_opt HANDLE hDevice,
    __in UINT uiCommand,
    __inout_bcount_part_opt(*pcbSize, *pcbSize) LPVOID pData,
    __inout PUINT pcbSize);
#ifdef UNICODE
#define GetRawInputDeviceInfo  GetRawInputDeviceInfoW
#else
#define GetRawInputDeviceInfo  GetRawInputDeviceInfoA
#endif // !UNICODE


/*
 * Raw Input Bulk Read: GetRawInputBuffer
 */
WINUSERAPI
UINT
WINAPI
GetRawInputBuffer(
    __out_bcount_opt(*pcbSize) PRAWINPUT pData,
    __inout PUINT pcbSize,
    __in UINT cbSizeHeader);

/*
 * Raw Input request APIs
 */
typedef struct tagRAWINPUTDEVICE {
    USHORT usUsagePage; // Toplevel collection UsagePage
    USHORT usUsage;     // Toplevel collection Usage
    DWORD dwFlags;
    HWND hwndTarget;    // Target hwnd. NULL = follows keyboard focus
} RAWINPUTDEVICE, *PRAWINPUTDEVICE, *LPRAWINPUTDEVICE;

typedef CONST RAWINPUTDEVICE* PCRAWINPUTDEVICE;

#define RIDEV_REMOVE            0x00000001
#define RIDEV_EXCLUDE           0x00000010
#define RIDEV_PAGEONLY          0x00000020
#define RIDEV_NOLEGACY          0x00000030
#define RIDEV_INPUTSINK         0x00000100
#define RIDEV_CAPTUREMOUSE      0x00000200  // effective when mouse nolegacy is specified, otherwise it would be an error
#define RIDEV_NOHOTKEYS         0x00000200  // effective for keyboard.
#define RIDEV_APPKEYS           0x00000400  // effective for keyboard.
#if(_WIN32_WINNT >= 0x0501)
#define RIDEV_EXINPUTSINK       0x00001000
#define RIDEV_DEVNOTIFY         0x00002000
#endif /* _WIN32_WINNT >= 0x0501 */
#define RIDEV_EXMODEMASK        0x000000F0

#define RIDEV_EXMODE(mode)  ((mode) & RIDEV_EXMODEMASK)

#if(_WIN32_WINNT >= 0x0501)
/*
 * Flags for the WM_INPUT_DEVICE_CHANGE message.
 */
#define GIDC_ARRIVAL             1
#define GIDC_REMOVAL             2
#endif /* _WIN32_WINNT >= 0x0501 */

#if (_WIN32_WINNT >= 0x0601)
#define GET_DEVICE_CHANGE_WPARAM(wParam)  (LOWORD(wParam))
#elif (_WIN32_WINNT >= 0x0501)
#define GET_DEVICE_CHANGE_LPARAM(lParam)  (LOWORD(lParam))
#endif /* (_WIN32_WINNT >= 0x0601) */

WINUSERAPI
BOOL
WINAPI
RegisterRawInputDevices(
    __in_ecount(uiNumDevices) PCRAWINPUTDEVICE pRawInputDevices,
    __in UINT uiNumDevices,
    __in UINT cbSize);

WINUSERAPI
UINT
WINAPI
GetRegisteredRawInputDevices(
    __out_ecount_opt( *puiNumDevices) PRAWINPUTDEVICE pRawInputDevices,
    __inout PUINT puiNumDevices,
    __in UINT cbSize);


typedef struct tagRAWINPUTDEVICELIST {
    HANDLE hDevice;
    DWORD dwType;
} RAWINPUTDEVICELIST, *PRAWINPUTDEVICELIST;

WINUSERAPI
UINT
WINAPI
GetRawInputDeviceList(
    __out_ecount_opt(*puiNumDevices) PRAWINPUTDEVICELIST pRawInputDeviceList,
    __inout PUINT puiNumDevices,
    __in UINT cbSize);

WINUSERAPI
LRESULT
WINAPI
DefRawInputProc(
    __in_ecount(nInput) PRAWINPUT* paRawInput,
    __in INT nInput,
    __in UINT cbSizeHeader);

#endif /* _WIN32_WINNT >= 0x0501 */


#if(WINVER >= 0x0600)

/*
 * Message Filter
 */

#define MSGFLT_ADD 1
#define MSGFLT_REMOVE 2

WINUSERAPI
BOOL
WINAPI
ChangeWindowMessageFilter(
    __in UINT message,
    __in DWORD dwFlag);

#endif /* WINVER >= 0x0600 */

#if(WINVER >= 0x0601)

/*
 * Message filter info values (CHANGEFILTERSTRUCT.ExtStatus)
 */
#define MSGFLTINFO_NONE                         (0)
#define MSGFLTINFO_ALREADYALLOWED_FORWND        (1)
#define MSGFLTINFO_ALREADYDISALLOWED_FORWND     (2)
#define MSGFLTINFO_ALLOWED_HIGHER               (3)

typedef struct tagCHANGEFILTERSTRUCT {
    DWORD cbSize;
    DWORD ExtStatus;
} CHANGEFILTERSTRUCT, *PCHANGEFILTERSTRUCT;

/*
 * Message filter action values (action parameter to ChangeWindowMessageFilterEx)
 */
#define MSGFLT_RESET                            (0)
#define MSGFLT_ALLOW                            (1)
#define MSGFLT_DISALLOW                         (2)

WINUSERAPI
BOOL
WINAPI
ChangeWindowMessageFilterEx(
    __in HWND hwnd,                                         // Window
    __in UINT message,                                      // WM_ message
    __in DWORD action,                                      // Message filter action value
    __inout_opt PCHANGEFILTERSTRUCT pChangeFilterStruct);   // Optional

#endif /* WINVER >= 0x0601 */


#if(WINVER >= 0x0601)

/*
 * Gesture defines and functions
 */

/*
 * Gesture information handle
 */
DECLARE_HANDLE(HGESTUREINFO);


/*
 * Gesture flags - GESTUREINFO.dwFlags
 */
#define GF_BEGIN                        0x00000001
#define GF_INERTIA                      0x00000002
#define GF_END                          0x00000004

/*
 * Gesture IDs
 */
#define GID_BEGIN                       1
#define GID_END                         2
#define GID_ZOOM                        3
#define GID_PAN                         4
#define GID_ROTATE                      5
#define GID_TWOFINGERTAP                6
#define GID_PRESSANDTAP                 7
#define GID_ROLLOVER                    GID_PRESSANDTAP

/*
 * Gesture information structure
 *   - Pass the HGESTUREINFO received in the WM_GESTURE message lParam into the
 *     GetGestureInfo function to retrieve this information.
 *   - If cbExtraArgs is non-zero, pass the HGESTUREINFO received in the WM_GESTURE
 *     message lParam into the GetGestureExtraArgs function to retrieve extended
 *     argument information.
 */
typedef struct tagGESTUREINFO {
    UINT cbSize;                    // size, in bytes, of this structure (including variable length Args field)
    DWORD dwFlags;                  // see GF_* flags
    DWORD dwID;                     // gesture ID, see GID_* defines
    HWND hwndTarget;                // handle to window targeted by this gesture
    POINTS ptsLocation;             // current location of this gesture
    DWORD dwInstanceID;             // internally used
    DWORD dwSequenceID;             // internally used
    ULONGLONG ullArguments;         // arguments for gestures whose arguments fit in 8 BYTES
    UINT cbExtraArgs;               // size, in bytes, of extra arguments, if any, that accompany this gesture
} GESTUREINFO, *PGESTUREINFO;
typedef GESTUREINFO const * PCGESTUREINFO;


/*
 * Gesture notification structure
 *   - The WM_GESTURENOTIFY message lParam contains a pointer to this structure.
 *   - The WM_GESTURENOTIFY message notifies a window that gesture recognition is
 *     in progress and a gesture will be generated if one is recognized under the
 *     current gesture settings.
 */
typedef struct tagGESTURENOTIFYSTRUCT {
    UINT cbSize;                    // size, in bytes, of this structure
    DWORD dwFlags;                  // unused
    HWND hwndTarget;                // handle to window targeted by the gesture
    POINTS ptsLocation;             // starting location
    DWORD dwInstanceID;             // internally used
} GESTURENOTIFYSTRUCT, *PGESTURENOTIFYSTRUCT;

/*
 * Gesture argument helpers
 *   - Angle should be a double in the range of -2pi to +2pi
 *   - Argument should be an unsigned 16-bit value
 */
#define GID_ROTATE_ANGLE_TO_ARGUMENT(_arg_)     ((USHORT)((((_arg_) + 2.0 * 3.14159265) / (4.0 * 3.14159265)) * 65535.0))
#define GID_ROTATE_ANGLE_FROM_ARGUMENT(_arg_)   ((((double)(_arg_) / 65535.0) * 4.0 * 3.14159265) - 2.0 * 3.14159265)

/*
 * Gesture information retrieval
 *   - HGESTUREINFO is received by a window in the lParam of a WM_GESTURE message.
 */
WINUSERAPI
BOOL
WINAPI
GetGestureInfo(
    __in HGESTUREINFO hGestureInfo,
    __out PGESTUREINFO pGestureInfo);

/*
 * Gesture extra arguments retrieval
 *   - HGESTUREINFO is received by a window in the lParam of a WM_GESTURE message.
 *   - Size, in bytes, of the extra argument data is available in the cbExtraArgs
 *     field of the GESTUREINFO structure retrieved using the GetGestureInfo function.
 */
WINUSERAPI
BOOL
WINAPI
GetGestureExtraArgs(
    __in HGESTUREINFO hGestureInfo,
    __in UINT cbExtraArgs,
    __out_bcount(cbExtraArgs) PBYTE pExtraArgs);

/*
 * Gesture information handle management
 *   - If an application processes the WM_GESTURE message, then once it is done
 *     with the associated HGESTUREINFO, the application is responsible for
 *     closing the handle using this function. Failure to do so may result in
 *     process memory leaks.
 *   - If the message is instead passed to DefWindowProc, or is forwarded using
 *     one of the PostMessage or SendMessage class of API functions, the handle
 *     is transfered with the message and need not be closed by the application.
 */
WINUSERAPI
BOOL
WINAPI
CloseGestureInfoHandle(
    __in HGESTUREINFO hGestureInfo);


/*
 * Gesture configuration structure
 *   - Used in SetGestureConfig and GetGestureConfig
 *   - Note that any setting not included in either GESTURECONFIG.dwWant or
 *     GESTURECONFIG.dwBlock will use the parent window's preferences or
 *     system defaults.
 */
typedef struct tagGESTURECONFIG {
    DWORD dwID;                     // gesture ID
    DWORD dwWant;                   // settings related to gesture ID that are to be turned on
    DWORD dwBlock;                  // settings related to gesture ID that are to be turned off
} GESTURECONFIG, *PGESTURECONFIG;

/*
 * Gesture configuration flags - GESTURECONFIG.dwWant or GESTURECONFIG.dwBlock
 */

/*
 * Common gesture configuration flags - set GESTURECONFIG.dwID to zero
 */
#define GC_ALLGESTURES                              0x00000001

/*
 * Zoom gesture configuration flags - set GESTURECONFIG.dwID to GID_ZOOM
 */
#define GC_ZOOM                                     0x00000001

/*
 * Pan gesture configuration flags - set GESTURECONFIG.dwID to GID_PAN
 */
#define GC_PAN                                      0x00000001
#define GC_PAN_WITH_SINGLE_FINGER_VERTICALLY        0x00000002
#define GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY      0x00000004
#define GC_PAN_WITH_GUTTER                          0x00000008
#define GC_PAN_WITH_INERTIA                         0x00000010

/*
 * Rotate gesture configuration flags - set GESTURECONFIG.dwID to GID_ROTATE
 */
#define GC_ROTATE                                   0x00000001

/*
 * Two finger tap gesture configuration flags - set GESTURECONFIG.dwID to GID_TWOFINGERTAP
 */
#define GC_TWOFINGERTAP                             0x00000001

/*
 * PressAndTap gesture configuration flags - set GESTURECONFIG.dwID to GID_PRESSANDTAP
 */
#define GC_PRESSANDTAP                              0x00000001
#define GC_ROLLOVER                                 GC_PRESSANDTAP

#define GESTURECONFIGMAXCOUNT           256             // Maximum number of gestures that can be included
                                                        // in a single call to SetGestureConfig / GetGestureConfig

WINUSERAPI
BOOL
WINAPI
SetGestureConfig(
    __in HWND hwnd,                                     // window for which configuration is specified
    __in DWORD dwReserved,                              // reserved, must be 0
    __in UINT cIDs,                                     // count of GESTURECONFIG structures
    __in_ecount(cIDs) PGESTURECONFIG pGestureConfig,    // array of GESTURECONFIG structures, dwIDs will be processed in the
                                                        // order specified and repeated occurances will overwrite previous ones
    __in UINT cbSize);                                  // sizeof(GESTURECONFIG)


#define GCF_INCLUDE_ANCESTORS           0x00000001      // If specified, GetGestureConfig returns consolidated configuration
                                                        // for the specified window and it's parent window chain

WINUSERAPI
BOOL
WINAPI
GetGestureConfig(
    __in HWND hwnd,                                     // window for which configuration is required
    __in DWORD dwReserved,                              // reserved, must be 0
    __in DWORD dwFlags,                                 // see GCF_* flags
    __in PUINT pcIDs,                                   // *pcIDs contains the size, in number of GESTURECONFIG structures,
                                                        // of the buffer pointed to by pGestureConfig
    __inout_ecount(*pcIDs) PGESTURECONFIG pGestureConfig,
                                                        // pointer to buffer to receive the returned array of GESTURECONFIG structures
    __in UINT cbSize);                                  // sizeof(GESTURECONFIG)



#endif /* WINVER >= 0x0601 */

#if(WINVER >= 0x0601)

/*
 * GetSystemMetrics(SM_DIGITIZER) flag values
 */
#define NID_INTEGRATED_TOUCH  0x00000001
#define NID_EXTERNAL_TOUCH    0x00000002
#define NID_INTEGRATED_PEN    0x00000004
#define NID_EXTERNAL_PEN      0x00000008
#define NID_MULTI_INPUT       0x00000040
#define NID_READY             0x00000080

#endif /* WINVER >= 0x0601 */


#define MAX_STR_BLOCKREASON 256

WINUSERAPI
BOOL
WINAPI
ShutdownBlockReasonCreate(
    __in HWND hWnd,
    __in LPCWSTR pwszReason);

WINUSERAPI
BOOL
WINAPI
ShutdownBlockReasonQuery(
    __in HWND hWnd,
    __out_ecount_opt(*pcchBuff) LPWSTR pwszBuff,
    __inout DWORD *pcchBuff);

WINUSERAPI
BOOL
WINAPI
ShutdownBlockReasonDestroy(
    __in HWND hWnd);




#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)
#include "winuser.inl"
#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* !_WINUSER_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\wlclient.h ===
/*++

Copyright (c) 2001 Microsoft Corporation


Module Name:

    wlclient.h

Abstract:

    Header file for wireless windows APIs.

Environment:

    User Level: Windows

Revision History:


--*/


#ifndef __WLCLIENT_H__
#define __WLCLIENT_H__

#pragma once

#ifndef __WINDOT11_H__
#include <windot11.h>
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)

#ifdef __cplusplus
extern "C" {
#endif



typedef struct _DOT11_ADAPTER {
    GUID gAdapterId;
#ifdef __midl
    [string] LPWSTR pszDescription;
#else
    LPWSTR pszDescription;
#endif
    DOT11_CURRENT_OPERATION_MODE Dot11CurrentOpMode;
} DOT11_ADAPTER, * PDOT11_ADAPTER;





typedef struct _DOT11_BSS_LIST {
    ULONG uNumOfBytes;
#ifdef __midl
    [size_is(uNumOfBytes)] PUCHAR pucBuffer;
#else
    __field_ecount_opt(uNumOfBytes) PUCHAR pucBuffer;
#endif
} DOT11_BSS_LIST, * PDOT11_BSS_LIST;





typedef struct _DOT11_PORT_STATE {
    DOT11_MAC_ADDRESS PeerMacAddress;   // Unicast mac address of the peer
    ULONG uSessionId;
    BOOL bPortControlled;               // TRUE, if the port is controlled by Security Module
    BOOL bPortAuthorized;               // TRUE, if the port is authorized for data packets
} DOT11_PORT_STATE, * PDOT11_PORT_STATE;




#include <packon.h>
typedef struct _DOT11_SECURITY_PACKET_HEADER {
    DOT11_MAC_ADDRESS PeerMac;
    USHORT usEtherType;
    UCHAR Data[1];
} DOT11_SECURITY_PACKET_HEADER, * PDOT11_SECURITY_PACKET_HEADER;
#include <packoff.h>


#ifdef __cplusplus
}
#endif

#endif  // (NTDDI_VERSION > NTDDI_VISTA)

#endif // __WLCLIENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\wlanapi.h ===
/*++

Copyright (c) 2004 Microsoft Corporation

Module Name:

    wlanapi.h

Abstract:

    Definitions and data strcutures for wlan auto config client side API.

Environment:

    User mode only

Revision History:

    11/8/2004    created

--*/

#ifndef _WLAN_WLANAPI_H
#define _WLAN_WLANAPI_H

#pragma once

#include <l2cmn.h>
#include <windot11.h>
#include <EapTypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _WIN32_WINNT
#error _WIN32_WINNT must be defined to use WLAN API. It could be either _WIN32_WINNT_WIN7, _WIN32_WINNT_VISTA, or _WIN32_WINNT_WINXP, and so on.
#endif

// major version is in low-order WORD,
// minor version is in high-order WORD
#define WLAN_API_VERSION_1_0    0x00000001
#define WLAN_API_VERSION_2_0    0x00000002
#define WLAN_API_VERSION_MAJOR(_v)  ((_v) & 0xffff)
#define WLAN_API_VERSION_MINOR(_v)  (((DWORD)(_v)) >> 16)
#define WLAN_API_MAKE_VERSION(_major, _minor)   (((DWORD)(_minor)) << 16 | (_major))

// WLAN API is version 1 in all WinXP
// and version 2 in Vista
#if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
    #define WLAN_API_VERSION        WLAN_API_VERSION_2_0
#else
    #if (_WIN32_WINNT >= _WIN32_WINNT_WINXP)
        #define WLAN_API_VERSION        WLAN_API_VERSION_1_0
    #else
        #error WLAN API is not supported on platform earlier than Windows XP.
    #endif // (_WIN32_WINNT >= _WIN32_WINNT_WINXP)
#endif  // (_WIN32_WINNT >= _WIN32_WINNT_VISTA)

// maximum length of name, in characters
#define WLAN_MAX_NAME_LENGTH L2_PROFILE_MAX_NAME_LENGTH

// profile flags
#define WLAN_PROFILE_GROUP_POLICY                   0x00000001
#define WLAN_PROFILE_USER                           0x00000002
#define WLAN_PROFILE_GET_PLAINTEXT_KEY		    0x00000004
// the following flags are only used for WlanSaveTemporaryProfile API
#define WLAN_PROFILE_CONNECTION_MODE_SET_BY_CLIENT  0x00010000
#define WLAN_PROFILE_CONNECTION_MODE_AUTO           0x00020000

// EAPHost data storage flags
#define WLAN_SET_EAPHOST_DATA_ALL_USERS 0x00000001

// struct WLAN_PROFILE_INFO defines the basic information of an 802.11 network profile
typedef struct _WLAN_PROFILE_INFO {
    WCHAR strProfileName[WLAN_MAX_NAME_LENGTH];
    DWORD dwFlags;
} WLAN_PROFILE_INFO, *PWLAN_PROFILE_INFO;


typedef struct _DOT11_NETWORK {
    DOT11_SSID dot11Ssid;
    DOT11_BSS_TYPE dot11BssType;
} DOT11_NETWORK, *PDOT11_NETWORK;

// proximity service discovery IE specific definitions

// the maximum data size in one PSD IE data entry (payload), in bytes
#define DOT11_PSD_IE_MAX_DATA_SIZE 240       
// the maximum number of PSD IE data entries
#define DOT11_PSD_IE_MAX_ENTRY_NUMBER 5       

typedef struct _WLAN_RAW_DATA {
    // size of the data blob
    DWORD dwDataSize;
#ifdef __midl
    [unique, size_is(dwDataSize)] BYTE DataBlob[*];
#else
    BYTE DataBlob[1];
#endif
} WLAN_RAW_DATA, *PWLAN_RAW_DATA;

typedef struct _WLAN_RAW_DATA_LIST {
    DWORD dwTotalSize;
    DWORD dwNumberOfItems;
    struct {
        // the beginning of the data blob
        // the offset is w.r.t. the beginning of the entry
        DWORD dwDataOffset;
        // size of the data blob
        DWORD dwDataSize;
    } DataList[1];
} WLAN_RAW_DATA_LIST, *PWLAN_RAW_DATA_LIST;

typedef enum _WLAN_CONNECTION_MODE {
    wlan_connection_mode_profile = 0,
    wlan_connection_mode_temporary_profile,
    wlan_connection_mode_discovery_secure,
    wlan_connection_mode_discovery_unsecure,
    wlan_connection_mode_auto,
    wlan_connection_mode_invalid
} WLAN_CONNECTION_MODE, *PWLAN_CONNECTION_MODE;

// Wlan reason code 
//
// They are put in the following range:
// each component got 0x1000 numbers, within which:
// the first half is for capability mismatch reason, 
// the second half for connect/security error reason.
//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// IMPORTANT: If you add/remove a reason code, please
// modify the corresponding entry in wlanres.h and wlanres.rc
// and the corresponding mapping in wlanapi.c
typedef DWORD WLAN_REASON_CODE, *PWLAN_REASON_CODE;
#define WLAN_REASON_CODE_SUCCESS                L2_REASON_CODE_SUCCESS
// general codes
#define WLAN_REASON_CODE_UNKNOWN                L2_REASON_CODE_UNKNOWN

#define WLAN_REASON_CODE_RANGE_SIZE             L2_REASON_CODE_GROUP_SIZE
#define WLAN_REASON_CODE_BASE                   L2_REASON_CODE_DOT11_AC_BASE

// range for Auto Config
//
#define WLAN_REASON_CODE_AC_BASE                L2_REASON_CODE_DOT11_AC_BASE
#define WLAN_REASON_CODE_AC_CONNECT_BASE        (WLAN_REASON_CODE_AC_BASE + WLAN_REASON_CODE_RANGE_SIZE / 2)
#define WLAN_REASON_CODE_AC_END                 (WLAN_REASON_CODE_AC_BASE + WLAN_REASON_CODE_RANGE_SIZE - 1)

// range for profile manager
// it has profile adding failure reason codes, but may not have 
// connection reason codes
//
#define WLAN_REASON_CODE_PROFILE_BASE           L2_REASON_CODE_PROFILE_BASE
#define WLAN_REASON_CODE_PROFILE_CONNECT_BASE   (WLAN_REASON_CODE_PROFILE_BASE + WLAN_REASON_CODE_RANGE_SIZE / 2)
#define WLAN_REASON_CODE_PROFILE_END            (WLAN_REASON_CODE_PROFILE_BASE + WLAN_REASON_CODE_RANGE_SIZE - 1)

// range for MSM
//
#define WLAN_REASON_CODE_MSM_BASE               L2_REASON_CODE_DOT11_MSM_BASE
#define WLAN_REASON_CODE_MSM_CONNECT_BASE       (WLAN_REASON_CODE_MSM_BASE + WLAN_REASON_CODE_RANGE_SIZE / 2)
#define WLAN_REASON_CODE_MSM_END                (WLAN_REASON_CODE_MSM_BASE + WLAN_REASON_CODE_RANGE_SIZE - 1)

// range for MSMSEC
//
#define WLAN_REASON_CODE_MSMSEC_BASE            L2_REASON_CODE_DOT11_SECURITY_BASE
#define WLAN_REASON_CODE_MSMSEC_CONNECT_BASE    (WLAN_REASON_CODE_MSMSEC_BASE + WLAN_REASON_CODE_RANGE_SIZE / 2)
#define WLAN_REASON_CODE_MSMSEC_END             (WLAN_REASON_CODE_MSMSEC_BASE + WLAN_REASON_CODE_RANGE_SIZE - 1)

// AC network incompatible reason codes
//
#define WLAN_REASON_CODE_NETWORK_NOT_COMPATIBLE (WLAN_REASON_CODE_AC_BASE +1)
#define WLAN_REASON_CODE_PROFILE_NOT_COMPATIBLE (WLAN_REASON_CODE_AC_BASE +2)

// AC connect reason code
//
#define WLAN_REASON_CODE_NO_AUTO_CONNECTION     (WLAN_REASON_CODE_AC_CONNECT_BASE +1)
#define WLAN_REASON_CODE_NOT_VISIBLE            (WLAN_REASON_CODE_AC_CONNECT_BASE +2)
#define WLAN_REASON_CODE_GP_DENIED              (WLAN_REASON_CODE_AC_CONNECT_BASE +3)
#define WLAN_REASON_CODE_USER_DENIED            (WLAN_REASON_CODE_AC_CONNECT_BASE +4)
#define WLAN_REASON_CODE_BSS_TYPE_NOT_ALLOWED   (WLAN_REASON_CODE_AC_CONNECT_BASE +5)
#define WLAN_REASON_CODE_IN_FAILED_LIST         (WLAN_REASON_CODE_AC_CONNECT_BASE +6)
#define WLAN_REASON_CODE_IN_BLOCKED_LIST        (WLAN_REASON_CODE_AC_CONNECT_BASE +7)
#define WLAN_REASON_CODE_SSID_LIST_TOO_LONG     (WLAN_REASON_CODE_AC_CONNECT_BASE +8)
#define WLAN_REASON_CODE_CONNECT_CALL_FAIL      (WLAN_REASON_CODE_AC_CONNECT_BASE +9)
#define WLAN_REASON_CODE_SCAN_CALL_FAIL         (WLAN_REASON_CODE_AC_CONNECT_BASE +10)
#define WLAN_REASON_CODE_NETWORK_NOT_AVAILABLE    (WLAN_REASON_CODE_AC_CONNECT_BASE +11)
#define WLAN_REASON_CODE_PROFILE_CHANGED_OR_DELETED \
                                                (WLAN_REASON_CODE_AC_CONNECT_BASE +12)
#define WLAN_REASON_CODE_KEY_MISMATCH           (WLAN_REASON_CODE_AC_CONNECT_BASE + 13)
#define WLAN_REASON_CODE_USER_NOT_RESPOND       (WLAN_REASON_CODE_AC_CONNECT_BASE + 14)
#define WLAN_REASON_CODE_AP_PROFILE_NOT_ALLOWED_FOR_CLIENT \
                                                (WLAN_REASON_CODE_AC_CONNECT_BASE + 15)
#define WLAN_REASON_CODE_AP_PROFILE_NOT_ALLOWED (WLAN_REASON_CODE_AC_CONNECT_BASE + 16)

// Profile validation errors
//
#define WLAN_REASON_CODE_INVALID_PROFILE_SCHEMA (WLAN_REASON_CODE_PROFILE_BASE +1)
#define WLAN_REASON_CODE_PROFILE_MISSING        (WLAN_REASON_CODE_PROFILE_BASE +2)
#define WLAN_REASON_CODE_INVALID_PROFILE_NAME   (WLAN_REASON_CODE_PROFILE_BASE +3)
#define WLAN_REASON_CODE_INVALID_PROFILE_TYPE   (WLAN_REASON_CODE_PROFILE_BASE +4)
#define WLAN_REASON_CODE_INVALID_PHY_TYPE       (WLAN_REASON_CODE_PROFILE_BASE +5)
#define WLAN_REASON_CODE_MSM_SECURITY_MISSING   (WLAN_REASON_CODE_PROFILE_BASE +6)
#define WLAN_REASON_CODE_IHV_SECURITY_NOT_SUPPORTED \
                                                (WLAN_REASON_CODE_PROFILE_BASE +7)
#define WLAN_REASON_CODE_IHV_OUI_MISMATCH       (WLAN_REASON_CODE_PROFILE_BASE +8)
        // IHV OUI not present but there is IHV settings in profile
#define WLAN_REASON_CODE_IHV_OUI_MISSING        (WLAN_REASON_CODE_PROFILE_BASE +9)
        // IHV OUI is present but there is no IHV settings in profile
#define WLAN_REASON_CODE_IHV_SETTINGS_MISSING   (WLAN_REASON_CODE_PROFILE_BASE +10)
        // both/conflict MSMSec and IHV security settings exist in profile 
#define WLAN_REASON_CODE_CONFLICT_SECURITY      (WLAN_REASON_CODE_PROFILE_BASE +11)
        // no IHV or MSMSec security settings in profile
#define WLAN_REASON_CODE_SECURITY_MISSING       (WLAN_REASON_CODE_PROFILE_BASE +12)
#define WLAN_REASON_CODE_INVALID_BSS_TYPE       (WLAN_REASON_CODE_PROFILE_BASE +13)
#define WLAN_REASON_CODE_INVALID_ADHOC_CONNECTION_MODE \
                                                (WLAN_REASON_CODE_PROFILE_BASE +14)
#define WLAN_REASON_CODE_NON_BROADCAST_SET_FOR_ADHOC \
                                                (WLAN_REASON_CODE_PROFILE_BASE +15)
#define WLAN_REASON_CODE_AUTO_SWITCH_SET_FOR_ADHOC \
                                                (WLAN_REASON_CODE_PROFILE_BASE +16)
#define WLAN_REASON_CODE_AUTO_SWITCH_SET_FOR_MANUAL_CONNECTION \
                                                (WLAN_REASON_CODE_PROFILE_BASE +17)
#define WLAN_REASON_CODE_IHV_SECURITY_ONEX_MISSING \
                                                (WLAN_REASON_CODE_PROFILE_BASE +18)
#define WLAN_REASON_CODE_PROFILE_SSID_INVALID   (WLAN_REASON_CODE_PROFILE_BASE +19)
#define WLAN_REASON_CODE_TOO_MANY_SSID          (WLAN_REASON_CODE_PROFILE_BASE +20)
#define WLAN_REASON_CODE_IHV_CONNECTIVITY_NOT_SUPPORTED \
                                                (WLAN_REASON_CODE_PROFILE_BASE +21)
#define WLAN_REASON_CODE_BAD_MAX_NUMBER_OF_CLIENTS_FOR_AP \
                                                (WLAN_REASON_CODE_PROFILE_BASE +22)
#define WLAN_REASON_CODE_INVALID_CHANNEL        (WLAN_REASON_CODE_PROFILE_BASE +23)
#define WLAN_REASON_CODE_OPERATION_MODE_NOT_SUPPORTED \
                                                (WLAN_REASON_CODE_PROFILE_BASE +24)
#define WLAN_REASON_CODE_AUTO_AP_PROFILE_NOT_ALLOWED \
                                                (WLAN_REASON_CODE_PROFILE_BASE +25)
#define WLAN_REASON_CODE_AUTO_CONNECTION_NOT_ALLOWED \
                                                (WLAN_REASON_CODE_PROFILE_BASE +26)

// MSM network incompatible reasons
//
#define WLAN_REASON_CODE_UNSUPPORTED_SECURITY_SET_BY_OS \
                                                (WLAN_REASON_CODE_MSM_BASE +1)
#define WLAN_REASON_CODE_UNSUPPORTED_SECURITY_SET \
                                                (WLAN_REASON_CODE_MSM_BASE +2)
#define WLAN_REASON_CODE_BSS_TYPE_UNMATCH       (WLAN_REASON_CODE_MSM_BASE +3)
#define WLAN_REASON_CODE_PHY_TYPE_UNMATCH       (WLAN_REASON_CODE_MSM_BASE +4)
#define WLAN_REASON_CODE_DATARATE_UNMATCH       (WLAN_REASON_CODE_MSM_BASE +5)

// MSM connection failure reasons, to be defined
// failure reason codes
//
        // user called to disconnect
#define WLAN_REASON_CODE_USER_CANCELLED         (WLAN_REASON_CODE_MSM_CONNECT_BASE+1)
        // got disconnect while associating
#define WLAN_REASON_CODE_ASSOCIATION_FAILURE    (WLAN_REASON_CODE_MSM_CONNECT_BASE+2)
        // timeout for association
#define WLAN_REASON_CODE_ASSOCIATION_TIMEOUT    (WLAN_REASON_CODE_MSM_CONNECT_BASE+3)
        // pre-association security completed with failure
#define WLAN_REASON_CODE_PRE_SECURITY_FAILURE   (WLAN_REASON_CODE_MSM_CONNECT_BASE+4)
        // fail to start post-association security
#define WLAN_REASON_CODE_START_SECURITY_FAILURE (WLAN_REASON_CODE_MSM_CONNECT_BASE+5)
        // post-association security completed with failure
#define WLAN_REASON_CODE_SECURITY_FAILURE       (WLAN_REASON_CODE_MSM_CONNECT_BASE+6)
        // security watchdog timeout
#define WLAN_REASON_CODE_SECURITY_TIMEOUT       (WLAN_REASON_CODE_MSM_CONNECT_BASE+7)
        // got disconnect from driver when roaming
#define WLAN_REASON_CODE_ROAMING_FAILURE        (WLAN_REASON_CODE_MSM_CONNECT_BASE+8)
        // failed to start security for roaming
#define WLAN_REASON_CODE_ROAMING_SECURITY_FAILURE   (WLAN_REASON_CODE_MSM_CONNECT_BASE+9)
        // failed to start security for adhoc-join
#define WLAN_REASON_CODE_ADHOC_SECURITY_FAILURE     (WLAN_REASON_CODE_MSM_CONNECT_BASE+10)
        // got disconnection from driver
#define WLAN_REASON_CODE_DRIVER_DISCONNECTED        (WLAN_REASON_CODE_MSM_CONNECT_BASE+11)
        // driver operation failed
#define WLAN_REASON_CODE_DRIVER_OPERATION_FAILURE   (WLAN_REASON_CODE_MSM_CONNECT_BASE+12)
        // Ihv service is not available
#define WLAN_REASON_CODE_IHV_NOT_AVAILABLE    (WLAN_REASON_CODE_MSM_CONNECT_BASE+13)
        // Response from ihv timed out
#define WLAN_REASON_CODE_IHV_NOT_RESPONDING   (WLAN_REASON_CODE_MSM_CONNECT_BASE+14)
        // Timed out waiting for driver to disconnect
#define WLAN_REASON_CODE_DISCONNECT_TIMEOUT   (WLAN_REASON_CODE_MSM_CONNECT_BASE+15)
        // An internal error prevented the operation from being completed.
#define WLAN_REASON_CODE_INTERNAL_FAILURE     (WLAN_REASON_CODE_MSM_CONNECT_BASE+16)
        // UI Request timed out.
#define WLAN_REASON_CODE_UI_REQUEST_TIMEOUT   (WLAN_REASON_CODE_MSM_CONNECT_BASE+17)
        // Roaming too often, post security is not completed after 5 times.
#define WLAN_REASON_CODE_TOO_MANY_SECURITY_ATTEMPTS (WLAN_REASON_CODE_MSM_CONNECT_BASE+18)
        // Failed to start AP
#define WLAN_REASON_CODE_AP_STARTING_FAILURE    (WLAN_REASON_CODE_MSM_CONNECT_BASE+19)
        
// MSMSEC reason codes
//

#define WLAN_REASON_CODE_MSMSEC_MIN                         WLAN_REASON_CODE_MSMSEC_BASE

// Key index specified is not valid
#define WLAN_REASON_CODE_MSMSEC_PROFILE_INVALID_KEY_INDEX   (WLAN_REASON_CODE_MSMSEC_BASE+1)
// Key required, PSK present
#define WLAN_REASON_CODE_MSMSEC_PROFILE_PSK_PRESENT         (WLAN_REASON_CODE_MSMSEC_BASE+2)
// Invalid key length
#define WLAN_REASON_CODE_MSMSEC_PROFILE_KEY_LENGTH          (WLAN_REASON_CODE_MSMSEC_BASE+3)
// Invalid PSK length
#define WLAN_REASON_CODE_MSMSEC_PROFILE_PSK_LENGTH          (WLAN_REASON_CODE_MSMSEC_BASE+4)
// No auth/cipher specified
#define WLAN_REASON_CODE_MSMSEC_PROFILE_NO_AUTH_CIPHER_SPECIFIED        (WLAN_REASON_CODE_MSMSEC_BASE+5)
// Too many auth/cipher specified
#define WLAN_REASON_CODE_MSMSEC_PROFILE_TOO_MANY_AUTH_CIPHER_SPECIFIED  (WLAN_REASON_CODE_MSMSEC_BASE+6)
// Profile contains duplicate auth/cipher
#define WLAN_REASON_CODE_MSMSEC_PROFILE_DUPLICATE_AUTH_CIPHER           (WLAN_REASON_CODE_MSMSEC_BASE+7)
// Profile raw data is invalid (1x or key data)
#define WLAN_REASON_CODE_MSMSEC_PROFILE_RAWDATA_INVALID                 (WLAN_REASON_CODE_MSMSEC_BASE+8)
// Invalid auth/cipher combination
#define WLAN_REASON_CODE_MSMSEC_PROFILE_INVALID_AUTH_CIPHER             (WLAN_REASON_CODE_MSMSEC_BASE+9)
// 802.1x disabled when it's required to be enabled
#define WLAN_REASON_CODE_MSMSEC_PROFILE_ONEX_DISABLED                   (WLAN_REASON_CODE_MSMSEC_BASE+10)
// 802.1x enabled when it's required to be disabled
#define WLAN_REASON_CODE_MSMSEC_PROFILE_ONEX_ENABLED                    (WLAN_REASON_CODE_MSMSEC_BASE+11)
#define WLAN_REASON_CODE_MSMSEC_PROFILE_INVALID_PMKCACHE_MODE           (WLAN_REASON_CODE_MSMSEC_BASE+12)
#define WLAN_REASON_CODE_MSMSEC_PROFILE_INVALID_PMKCACHE_SIZE           (WLAN_REASON_CODE_MSMSEC_BASE+13)
#define WLAN_REASON_CODE_MSMSEC_PROFILE_INVALID_PMKCACHE_TTL            (WLAN_REASON_CODE_MSMSEC_BASE+14)
#define WLAN_REASON_CODE_MSMSEC_PROFILE_INVALID_PREAUTH_MODE            (WLAN_REASON_CODE_MSMSEC_BASE+15)
#define WLAN_REASON_CODE_MSMSEC_PROFILE_INVALID_PREAUTH_THROTTLE        (WLAN_REASON_CODE_MSMSEC_BASE+16)
// PreAuth enabled when PMK cache is disabled
#define WLAN_REASON_CODE_MSMSEC_PROFILE_PREAUTH_ONLY_ENABLED            (WLAN_REASON_CODE_MSMSEC_BASE+17)
// Capability matching failed at network
#define WLAN_REASON_CODE_MSMSEC_CAPABILITY_NETWORK          (WLAN_REASON_CODE_MSMSEC_BASE+18)
// Capability matching failed at NIC
#define WLAN_REASON_CODE_MSMSEC_CAPABILITY_NIC              (WLAN_REASON_CODE_MSMSEC_BASE+19)
// Capability matching failed at profile
#define WLAN_REASON_CODE_MSMSEC_CAPABILITY_PROFILE          (WLAN_REASON_CODE_MSMSEC_BASE+20)
// Network does not support specified discovery type
#define WLAN_REASON_CODE_MSMSEC_CAPABILITY_DISCOVERY        (WLAN_REASON_CODE_MSMSEC_BASE+21)
// Passphrase contains invalid character
#define WLAN_REASON_CODE_MSMSEC_PROFILE_PASSPHRASE_CHAR     (WLAN_REASON_CODE_MSMSEC_BASE+22)
// Key material contains invalid character
#define WLAN_REASON_CODE_MSMSEC_PROFILE_KEYMATERIAL_CHAR     (WLAN_REASON_CODE_MSMSEC_BASE+23)
// Wrong key type specified for the auth/cipher pair
#define WLAN_REASON_CODE_MSMSEC_PROFILE_WRONG_KEYTYPE     (WLAN_REASON_CODE_MSMSEC_BASE+24)
// "Mixed cell" suspected (AP not beaconing privacy, we have privacy enabled profile)
#define WLAN_REASON_CODE_MSMSEC_MIXED_CELL                (WLAN_REASON_CODE_MSMSEC_BASE+25)
// Auth timers or number of timeouts in profile is incorrect
#define WLAN_REASON_CODE_MSMSEC_PROFILE_AUTH_TIMERS_INVALID (WLAN_REASON_CODE_MSMSEC_BASE+26)
// Group key update interval in profile is incorrect
#define WLAN_REASON_CODE_MSMSEC_PROFILE_INVALID_GKEY_INTV   (WLAN_REASON_CODE_MSMSEC_BASE+27)
// "Transition network" suspected, trying legacy 802.11 security
#define WLAN_REASON_CODE_MSMSEC_TRANSITION_NETWORK          (WLAN_REASON_CODE_MSMSEC_BASE+28)
// Key contains characters which do not map to ASCII
#define WLAN_REASON_CODE_MSMSEC_PROFILE_KEY_UNMAPPED_CHAR   (WLAN_REASON_CODE_MSMSEC_BASE+29)
// Capability matching failed at profile (auth not found)
#define WLAN_REASON_CODE_MSMSEC_CAPABILITY_PROFILE_AUTH     (WLAN_REASON_CODE_MSMSEC_BASE+30)
// Capability matching failed at profile (cipher not found)
#define WLAN_REASON_CODE_MSMSEC_CAPABILITY_PROFILE_CIPHER   (WLAN_REASON_CODE_MSMSEC_BASE+31)
// Safe mode value is invalid
#define WLAN_REASON_CODE_MSMSEC_PROFILE_SAFE_MODE           (WLAN_REASON_CODE_MSMSEC_BASE+32)
// Profile requires safe mode, not supported by NIC
#define WLAN_REASON_CODE_MSMSEC_CAPABILITY_PROFILE_SAFE_MODE_NIC (WLAN_REASON_CODE_MSMSEC_BASE+33)
// Profile requires safe mode, not supported by network
#define WLAN_REASON_CODE_MSMSEC_CAPABILITY_PROFILE_SAFE_MODE_NW  (WLAN_REASON_CODE_MSMSEC_BASE+34)
// Profile has unsupported auth
#define WLAN_REASON_CODE_MSMSEC_PROFILE_UNSUPPORTED_AUTH    (WLAN_REASON_CODE_MSMSEC_BASE+35)
// Profile has unsupported cipher
#define WLAN_REASON_CODE_MSMSEC_PROFILE_UNSUPPORTED_CIPHER  (WLAN_REASON_CODE_MSMSEC_BASE+36)

// Failed to queue UI request
#define WLAN_REASON_CODE_MSMSEC_UI_REQUEST_FAILURE          (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+1)
// 802.1x authentication did not start within configured time 
#define WLAN_REASON_CODE_MSMSEC_AUTH_START_TIMEOUT          (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+2)
// 802.1x authentication did not complete within configured time
#define WLAN_REASON_CODE_MSMSEC_AUTH_SUCCESS_TIMEOUT        (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+3)
// Dynamic key exchange did not start within configured time
#define WLAN_REASON_CODE_MSMSEC_KEY_START_TIMEOUT           (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+4)
// Dynamic key exchange did not succeed within configured time
#define WLAN_REASON_CODE_MSMSEC_KEY_SUCCESS_TIMEOUT         (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+5)
// Message 3 of 4 way handshake has no key data (RSN/WPA)
#define WLAN_REASON_CODE_MSMSEC_M3_MISSING_KEY_DATA         (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+6)
// Message 3 of 4 way handshake has no IE (RSN/WPA)
#define WLAN_REASON_CODE_MSMSEC_M3_MISSING_IE               (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+7)
// Message 3 of 4 way handshake has no Group Key (RSN)
#define WLAN_REASON_CODE_MSMSEC_M3_MISSING_GRP_KEY          (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+8)
// Matching security capabilities of IE in M3 failed (RSN/WPA)
#define WLAN_REASON_CODE_MSMSEC_PR_IE_MATCHING              (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+9)
// Matching security capabilities of Secondary IE in M3 failed (RSN)
#define WLAN_REASON_CODE_MSMSEC_SEC_IE_MATCHING             (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+10)
// Required a pairwise key but AP configured only group keys
#define WLAN_REASON_CODE_MSMSEC_NO_PAIRWISE_KEY             (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+11)
// Message 1 of group key handshake has no key data (RSN/WPA)
#define WLAN_REASON_CODE_MSMSEC_G1_MISSING_KEY_DATA         (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+12)
// Message 1 of group key handshake has no group key
#define WLAN_REASON_CODE_MSMSEC_G1_MISSING_GRP_KEY          (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+13)
// AP reset secure bit after connection was secured
#define WLAN_REASON_CODE_MSMSEC_PEER_INDICATED_INSECURE     (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+14)
// 802.1x indicated there is no authenticator but profile requires 802.1x
#define WLAN_REASON_CODE_MSMSEC_NO_AUTHENTICATOR            (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+15)
// Plumbing settings to NIC failed
#define WLAN_REASON_CODE_MSMSEC_NIC_FAILURE                 (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+16)
// Operation was cancelled by caller
#define WLAN_REASON_CODE_MSMSEC_CANCELLED                   (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+17)
// Key was in incorrect format 
#define WLAN_REASON_CODE_MSMSEC_KEY_FORMAT                  (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+18)
// Security downgrade detected
#define WLAN_REASON_CODE_MSMSEC_DOWNGRADE_DETECTED          (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+19)
// PSK mismatch suspected
#define WLAN_REASON_CODE_MSMSEC_PSK_MISMATCH_SUSPECTED      (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+20)
// Forced failure because connection method was not secure
#define WLAN_REASON_CODE_MSMSEC_FORCED_FAILURE              (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+21)
// Message 3 of 4 way handshake contains too many RSN IE (RSN)
#define WLAN_REASON_CODE_MSMSEC_M3_TOO_MANY_RSNIE           (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+22)
// Message 2 of 4 way handshake has no key data (RSN Adhoc)
#define WLAN_REASON_CODE_MSMSEC_M2_MISSING_KEY_DATA         (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+23)
// Message 2 of 4 way handshake has no IE (RSN Adhoc)
#define WLAN_REASON_CODE_MSMSEC_M2_MISSING_IE               (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+24)
#define WLAN_REASON_CODE_MSMSEC_AUTH_WCN_COMPLETED          (WLAN_REASON_CODE_MSMSEC_CONNECT_BASE+25)

#define WLAN_REASON_CODE_MSMSEC_MAX                         WLAN_REASON_CODE_MSMSEC_END

typedef ULONG WLAN_SIGNAL_QUALITY, *PWLAN_SIGNAL_QUALITY; 

// available network flags
#define WLAN_AVAILABLE_NETWORK_CONNECTED                    0x00000001  // This network is currently connected
#define WLAN_AVAILABLE_NETWORK_HAS_PROFILE                  0x00000002  // There is a profile for this network
#define WLAN_AVAILABLE_NETWORK_CONSOLE_USER_PROFILE         0x00000004  // The profile is the active console user's per user profile

// flags that control the list returned by WlanGetAvailableNetworkList
// include all ad hoc network profiles in the available network list, regardless they are visible or not
#define WLAN_AVAILABLE_NETWORK_INCLUDE_ALL_ADHOC_PROFILES           0x00000001  
// include all hidden network profiles in the available network list, regardless they are visible or not
#define WLAN_AVAILABLE_NETWORK_INCLUDE_ALL_MANUAL_HIDDEN_PROFILES   0x00000002

typedef struct _WLAN_RATE_SET {
    ULONG uRateSetLength;
    __field_ecount_part(DOT11_RATE_SET_MAX_LENGTH, uRateSetLength) USHORT usRateSet[DOT11_RATE_SET_MAX_LENGTH];
} WLAN_RATE_SET, * PWLAN_RATE_SET;

#define WLAN_MAX_PHY_TYPE_NUMBER    8
// 
// struct WLAN_AVAILABLE_NETWORK defines information needed for an available network
typedef struct _WLAN_AVAILABLE_NETWORK {
    WCHAR strProfileName[WLAN_MAX_NAME_LENGTH];
    DOT11_SSID dot11Ssid;
    DOT11_BSS_TYPE dot11BssType;
    ULONG uNumberOfBssids;
    BOOL bNetworkConnectable;
    WLAN_REASON_CODE wlanNotConnectableReason;
    ULONG uNumberOfPhyTypes;
    DOT11_PHY_TYPE dot11PhyTypes[WLAN_MAX_PHY_TYPE_NUMBER];
    // bMorePhyTypes is set to TRUE if the PHY types for the network
    // exceeds WLAN_MAX_PHY_TYPE_NUMBER.
    // In this case, uNumerOfPhyTypes is WLAN_MAX_PHY_TYPE_NUMBER and the
    // first WLAN_MAX_PHY_TYPE_NUMBER PHY types are returned.
    BOOL bMorePhyTypes;
    WLAN_SIGNAL_QUALITY wlanSignalQuality;
    BOOL bSecurityEnabled;
    DOT11_AUTH_ALGORITHM dot11DefaultAuthAlgorithm;
    DOT11_CIPHER_ALGORITHM dot11DefaultCipherAlgorithm;
    DWORD dwFlags;
    DWORD dwReserved;
} WLAN_AVAILABLE_NETWORK, *PWLAN_AVAILABLE_NETWORK;


typedef struct _WLAN_BSS_ENTRY {
    DOT11_SSID dot11Ssid;
    ULONG uPhyId;
    DOT11_MAC_ADDRESS dot11Bssid;
    DOT11_BSS_TYPE dot11BssType;
    DOT11_PHY_TYPE dot11BssPhyType;
    LONG lRssi;
    ULONG uLinkQuality;
    BOOLEAN bInRegDomain;
    USHORT usBeaconPeriod;
    ULONGLONG ullTimestamp;
    ULONGLONG ullHostTimestamp;
    USHORT usCapabilityInformation;
    ULONG  ulChCenterFrequency;
    WLAN_RATE_SET wlanRateSet;
    // the beginning of the IE blob
    // the offset is w.r.t. the beginning of the entry
    ULONG ulIeOffset;
    // size of the IE blob
    ULONG ulIeSize;
} WLAN_BSS_ENTRY, * PWLAN_BSS_ENTRY;

// struct WLAN_VARIABLE_SIZE_ARRAY defines a list of entries,
// each of which may have different size  
typedef struct _WLAN_BSS_LIST {
    // The total size of the data in BYTE
    DWORD dwTotalSize;
    DWORD dwNumberOfItems;
    WLAN_BSS_ENTRY wlanBssEntries[1];
} WLAN_BSS_LIST, *PWLAN_BSS_LIST;


// the states of the network (interface)
#ifdef __midl
// use the 4-byte enum
typedef [v1_enum] enum _WLAN_INTERFACE_STATE {
#else
typedef enum _WLAN_INTERFACE_STATE {
#endif
    wlan_interface_state_not_ready,
    wlan_interface_state_connected,
    wlan_interface_state_ad_hoc_network_formed,
    wlan_interface_state_disconnecting,
    wlan_interface_state_disconnected,
    wlan_interface_state_associating,
    wlan_interface_state_discovering,
    wlan_interface_state_authenticating
} WLAN_INTERFACE_STATE, *PWLAN_INTERFACE_STATE;


// Adhoc network states
#ifdef __midl
// use the 4-byte enum
typedef [v1_enum] enum _WLAN_ADHOC_NETWORK_STATE {
#else
typedef enum _WLAN_ADHOC_NETWORK_STATE {
#endif
    wlan_adhoc_network_state_formed = 0,
    wlan_adhoc_network_state_connected
} WLAN_ADHOC_NETWORK_STATE, *PWLAN_ADHOC_NETWORK_STATE;

// struct WLAN_INTERFACE_INFO defines the basic information for an interface
typedef struct _WLAN_INTERFACE_INFO {
    GUID InterfaceGuid;
    WCHAR strInterfaceDescription[WLAN_MAX_NAME_LENGTH];
    WLAN_INTERFACE_STATE isState;
} WLAN_INTERFACE_INFO, *PWLAN_INTERFACE_INFO;

// structure WLAN_ASSOCIATION_ATTRIBUTES defines attributes of a wireless
// association. The unit for Rx/Tx rate is Kbits/second.
typedef struct _WLAN_ASSOCIATION_ATTRIBUTES {
    DOT11_SSID dot11Ssid;
    DOT11_BSS_TYPE dot11BssType;
    DOT11_MAC_ADDRESS dot11Bssid;
    DOT11_PHY_TYPE dot11PhyType;
    ULONG uDot11PhyIndex;
    WLAN_SIGNAL_QUALITY wlanSignalQuality;
    ULONG ulRxRate;
    ULONG ulTxRate;
} WLAN_ASSOCIATION_ATTRIBUTES, *PWLAN_ASSOCIATION_ATTRIBUTES;

typedef struct _WLAN_SECURITY_ATTRIBUTES {
    BOOL bSecurityEnabled;
    BOOL bOneXEnabled;
    DOT11_AUTH_ALGORITHM dot11AuthAlgorithm;
    DOT11_CIPHER_ALGORITHM dot11CipherAlgorithm;
} WLAN_SECURITY_ATTRIBUTES, *PWLAN_SECURITY_ATTRIBUTES;

// structure WLAN_CONNECTION_ATTRIBUTES defines attributes of a wireless connection
typedef struct _WLAN_CONNECTION_ATTRIBUTES {
    WLAN_INTERFACE_STATE isState;
    WLAN_CONNECTION_MODE wlanConnectionMode;
    WCHAR strProfileName[WLAN_MAX_NAME_LENGTH];
    WLAN_ASSOCIATION_ATTRIBUTES wlanAssociationAttributes;
    WLAN_SECURITY_ATTRIBUTES wlanSecurityAttributes;
} WLAN_CONNECTION_ATTRIBUTES, *PWLAN_CONNECTION_ATTRIBUTES;


// use the 4-byte enum
#ifdef __midl
typedef [v1_enum] enum _DOT11_RADIO_STATE {
#else
typedef enum _DOT11_RADIO_STATE {
#endif
    dot11_radio_state_unknown = 0,
    dot11_radio_state_on,
    dot11_radio_state_off
} DOT11_RADIO_STATE, *PDOT11_RADIO_STATE;

// the maximum number of PHYs supported by a NIC
#define WLAN_MAX_PHY_INDEX 64

typedef struct _WLAN_PHY_RADIO_STATE {
    DWORD dwPhyIndex;
    DOT11_RADIO_STATE dot11SoftwareRadioState;
    DOT11_RADIO_STATE dot11HardwareRadioState;
} WLAN_PHY_RADIO_STATE, *PWLAN_PHY_RADIO_STATE;

typedef struct _WLAN_RADIO_STATE {
    DWORD dwNumberOfPhys;
    WLAN_PHY_RADIO_STATE PhyRadioState[WLAN_MAX_PHY_INDEX];
} WLAN_RADIO_STATE, *PWLAN_RADIO_STATE;

typedef enum _WLAN_INTERFACE_TYPE {
    wlan_interface_type_emulated_802_11 = 0,
    wlan_interface_type_native_802_11,
    wlan_interface_type_invalid
} WLAN_INTERFACE_TYPE, *PWLAN_INTERFACE_TYPE;

typedef struct _WLAN_INTERFACE_CAPABILITY {
    WLAN_INTERFACE_TYPE interfaceType;
    BOOL bDot11DSupported;
    DWORD dwMaxDesiredSsidListSize;
    DWORD dwMaxDesiredBssidListSize;
    DWORD dwNumberOfSupportedPhys;
    DOT11_PHY_TYPE dot11PhyTypes[WLAN_MAX_PHY_INDEX];
} WLAN_INTERFACE_CAPABILITY, *PWLAN_INTERFACE_CAPABILITY;


typedef struct _WLAN_AUTH_CIPHER_PAIR_LIST {
    DWORD dwNumberOfItems;
#ifdef __midl
    [unique, size_is(dwNumberOfItems)] DOT11_AUTH_CIPHER_PAIR pAuthCipherPairList[*];
#else
    DOT11_AUTH_CIPHER_PAIR pAuthCipherPairList[1];
#endif
} WLAN_AUTH_CIPHER_PAIR_LIST, *PWLAN_AUTH_CIPHER_PAIR_LIST;

typedef struct _WLAN_COUNTRY_OR_REGION_STRING_LIST {
    DWORD dwNumberOfItems;
#ifdef __midl
    [unique, size_is(dwNumberOfItems)] DOT11_COUNTRY_OR_REGION_STRING pCountryOrRegionStringList[*];
#else
    DOT11_COUNTRY_OR_REGION_STRING pCountryOrRegionStringList[1];
#endif
} WLAN_COUNTRY_OR_REGION_STRING_LIST, *PWLAN_COUNTRY_OR_REGION_STRING_LIST;

typedef struct _WLAN_PROFILE_INFO_LIST {
    DWORD dwNumberOfItems;
    DWORD dwIndex;
    
#ifdef __midl
    [unique, size_is(dwNumberOfItems)] WLAN_PROFILE_INFO ProfileInfo[*];
#else
    WLAN_PROFILE_INFO ProfileInfo[1];
#endif

} WLAN_PROFILE_INFO_LIST, *PWLAN_PROFILE_INFO_LIST;


typedef struct _WLAN_AVAILABLE_NETWORK_LIST {
    DWORD dwNumberOfItems;
    DWORD dwIndex;

#ifdef __midl
    [unique, size_is(dwNumberOfItems)] WLAN_AVAILABLE_NETWORK Network[*];
#else
    WLAN_AVAILABLE_NETWORK Network[1];
#endif

} WLAN_AVAILABLE_NETWORK_LIST, *PWLAN_AVAILABLE_NETWORK_LIST;

typedef struct _WLAN_INTERFACE_INFO_LIST {
    DWORD dwNumberOfItems;
    DWORD dwIndex;

#ifdef __midl
    [unique, size_is(dwNumberOfItems)] WLAN_INTERFACE_INFO InterfaceInfo[*];
#else
    WLAN_INTERFACE_INFO InterfaceInfo[1];
#endif

} WLAN_INTERFACE_INFO_LIST, *PWLAN_INTERFACE_INFO_LIST;

// network list 
typedef struct _DOT11_NETWORK_LIST {
    DWORD dwNumberOfItems;
    DWORD dwIndex;

#ifdef __midl
    [unique, size_is(dwNumberOfItems)] DOT11_NETWORK Network[*];
#else
    __field_ecount(dwNumberOfItems) DOT11_NETWORK Network[1];
#endif
} DOT11_NETWORK_LIST, *PDOT11_NETWORK_LIST;

// power settings
#ifdef __midl
// use the 4-byte enum
typedef [v1_enum] enum _WLAN_POWER_SETTING {
#else
typedef enum _WLAN_POWER_SETTING {
#endif
    wlan_power_setting_no_saving = 0,
    wlan_power_setting_low_saving,
    wlan_power_setting_medium_saving,
    wlan_power_setting_maximum_saving,
    wlan_power_setting_invalid
} WLAN_POWER_SETTING, *PWLAN_POWER_SETTING;

// Wlan connection flags used in WLAN_CONNECTION_PARAMETERS
// The network to be connected is a hidden network
// This flag cannnot be set if the network to connected is an ad hoc network
#define WLAN_CONNECTION_HIDDEN_NETWORK      0x00000001
// Only join an ad hoc network, do not form it if it doesn't exist
// This flag cannnot be set if the network to connected is not an ad hoc network
#define WLAN_CONNECTION_ADHOC_JOIN_ONLY     0x00000002
// Ignore the privacy bit for the association. This is used to support easy config.
// This flag is valid only for wlan_connection_mode_temporary_profile and infrastructure networks.
#define WLAN_CONNECTION_IGNORE_PRIVACY_BIT  0x00000004
// Exempt EAPOL traffic from encryption/decryption. This is used to
// support an application that needs to send EAPOL traffic in non-802.1x WEP
// networks. This flag is valid only for wlan_connection_mode_temporary_profile
// in infrastructure networks when using authentication algorithm Open and
// Cipher WEP with 802.1x disabled
#define WLAN_CONNECTION_EAPOL_PASSTHROUGH   0x00000008

// connection parameters
typedef struct _WLAN_CONNECTION_PARAMETERS {
    WLAN_CONNECTION_MODE wlanConnectionMode;
#ifdef __midl
    [string] LPCWSTR strProfile;
#else
    LPCWSTR strProfile;
#endif
    PDOT11_SSID pDot11Ssid;
    PDOT11_BSSID_LIST pDesiredBssidList;
    DOT11_BSS_TYPE dot11BssType;
    DWORD dwFlags;
} WLAN_CONNECTION_PARAMETERS, *PWLAN_CONNECTION_PARAMETERS;
    
// data structure for connection-related notifications.
typedef struct _WLAN_MSM_NOTIFICATION_DATA {
    WLAN_CONNECTION_MODE wlanConnectionMode;
    WCHAR strProfileName[WLAN_MAX_NAME_LENGTH];
    DOT11_SSID dot11Ssid;
    DOT11_BSS_TYPE dot11BssType;
    DOT11_MAC_ADDRESS dot11MacAddr;
    BOOL bSecurityEnabled;
    BOOL bFirstPeer;
    BOOL bLastPeer;
    WLAN_REASON_CODE wlanReasonCode;
} WLAN_MSM_NOTIFICATION_DATA, *PWLAN_MSM_NOTIFICATION_DATA;


// flags for connection notifications
// whether an adhoc network is formed or joined
#define WLAN_CONNECTION_NOTIFICATION_ADHOC_NETWORK_FORMED    0x00000001     // Formed ad hoc network
#define WLAN_CONNECTION_NOTIFICATION_CONSOLE_USER_PROFILE    0x00000004     // The profile is the active console user's per user profile

typedef struct _WLAN_CONNECTION_NOTIFICATION_DATA {
    WLAN_CONNECTION_MODE wlanConnectionMode;
    WCHAR strProfileName[WLAN_MAX_NAME_LENGTH];
    DOT11_SSID dot11Ssid;
    DOT11_BSS_TYPE dot11BssType;
    BOOL bSecurityEnabled;
    WLAN_REASON_CODE wlanReasonCode;
    DWORD dwFlags;
    WCHAR strProfileXml[1];
} WLAN_CONNECTION_NOTIFICATION_DATA, *PWLAN_CONNECTION_NOTIFICATION_DATA;


// the types of notification
// compatible with L2_NOTIFICATION_SOURCE
#define WLAN_NOTIFICATION_SOURCE_NONE         L2_NOTIFICATION_SOURCE_NONE
#define WLAN_NOTIFICATION_SOURCE_ALL          L2_NOTIFICATION_SOURCE_ALL

#define WLAN_NOTIFICATION_SOURCE_ACM          L2_NOTIFICATION_SOURCE_WLAN_ACM
#define WLAN_NOTIFICATION_SOURCE_MSM          L2_NOTIFICATION_SOURCE_WLAN_MSM
#define WLAN_NOTIFICATION_SOURCE_SECURITY     L2_NOTIFICATION_SOURCE_WLAN_SECURITY
#define WLAN_NOTIFICATION_SOURCE_IHV          L2_NOTIFICATION_SOURCE_WLAN_IHV
#define WLAN_NOTIFICATION_SOURCE_HNWK         L2_NOTIFICATION_SOURCE_WLAN_HNWK
#define WLAN_NOTIFICATION_SOURCE_ONEX         L2_NOTIFICATION_SOURCE_ONEX


#ifdef __midl
// use the 4-byte enum
typedef [v1_enum] enum _WLAN_NOTIFICATION_ACM {
#else
typedef enum _WLAN_NOTIFICATION_ACM {
#endif
    wlan_notification_acm_start = L2_NOTIFICATION_CODE_PUBLIC_BEGIN,
    wlan_notification_acm_autoconf_enabled,
    wlan_notification_acm_autoconf_disabled,
    wlan_notification_acm_background_scan_enabled,
    wlan_notification_acm_background_scan_disabled,
    wlan_notification_acm_bss_type_change,
    wlan_notification_acm_power_setting_change,
    wlan_notification_acm_scan_complete,
    wlan_notification_acm_scan_fail,
    wlan_notification_acm_connection_start,
    wlan_notification_acm_connection_complete,
    wlan_notification_acm_connection_attempt_fail,
    wlan_notification_acm_filter_list_change,
    wlan_notification_acm_interface_arrival,
    wlan_notification_acm_interface_removal,
    wlan_notification_acm_profile_change,
    wlan_notification_acm_profile_name_change,
    wlan_notification_acm_profiles_exhausted,
    wlan_notification_acm_network_not_available,
    wlan_notification_acm_network_available,
    wlan_notification_acm_disconnecting,
    wlan_notification_acm_disconnected,
    wlan_notification_acm_adhoc_network_state_change,
    wlan_notification_acm_end
} WLAN_NOTIFICATION_ACM, *PWLAN_NOTIFICATION_ACM;


#ifdef __midl
// use the 4-byte enum
typedef [v1_enum] enum _WLAN_NOTIFICATION_MSM {
#else
typedef enum _WLAN_NOTIFICATION_MSM {
#endif
    wlan_notification_msm_start = L2_NOTIFICATION_CODE_PUBLIC_BEGIN,
    wlan_notification_msm_associating,
    wlan_notification_msm_associated,
    wlan_notification_msm_authenticating,
    wlan_notification_msm_connected,
    wlan_notification_msm_roaming_start,
    wlan_notification_msm_roaming_end,
    wlan_notification_msm_radio_state_change,
    wlan_notification_msm_signal_quality_change,
    wlan_notification_msm_disassociating,
    wlan_notification_msm_disconnected,
    wlan_notification_msm_peer_join,
    wlan_notification_msm_peer_leave,
    wlan_notification_msm_adapter_removal,
    wlan_notification_msm_adapter_operation_mode_change,
    wlan_notification_msm_end
} WLAN_NOTIFICATION_MSM, *PWLAN_NOTIFICATION_MSM;


#ifdef __midl
// use the 4-byte enum
typedef [v1_enum] enum _WLAN_NOTIFICATION_SECURITY {
#else
typedef enum _WLAN_NOTIFICATION_SECURITY {
#endif
    wlan_notification_security_start = L2_NOTIFICATION_CODE_PUBLIC_BEGIN,
    wlan_notification_security_end
} WLAN_NOTIFICATION_SECURITY, *PWLAN_NOTIFICATION_SECURITY;

typedef L2_NOTIFICATION_DATA WLAN_NOTIFICATION_DATA, *PWLAN_NOTIFICATION_DATA;

// the callback function for notifications
typedef VOID (WINAPI *WLAN_NOTIFICATION_CALLBACK) (PWLAN_NOTIFICATION_DATA, PVOID);

#ifdef __midl
// use the 4-byte enum
typedef [v1_enum] enum _WLAN_OPCODE_VALUE_TYPE {
#else
typedef enum _WLAN_OPCODE_VALUE_TYPE {
#endif
        wlan_opcode_value_type_query_only = 0,
        wlan_opcode_value_type_set_by_group_policy,
        wlan_opcode_value_type_set_by_user,
        wlan_opcode_value_type_invalid
} WLAN_OPCODE_VALUE_TYPE, *PWLAN_OPCODE_VALUE_TYPE;

// OpCodes for set/query interfaces
#ifdef __midl
// use the 4-byte enum
typedef [v1_enum] enum _WLAN_INTF_OPCODE {
#else
typedef enum _WLAN_INTF_OPCODE {
#endif
    wlan_intf_opcode_autoconf_start = 0x000000000,
    wlan_intf_opcode_autoconf_enabled,
    wlan_intf_opcode_background_scan_enabled,
    wlan_intf_opcode_media_streaming_mode,
    wlan_intf_opcode_radio_state,
    wlan_intf_opcode_bss_type,
    wlan_intf_opcode_interface_state,
    wlan_intf_opcode_current_connection,
    wlan_intf_opcode_channel_number,
    wlan_intf_opcode_supported_infrastructure_auth_cipher_pairs,
    wlan_intf_opcode_supported_adhoc_auth_cipher_pairs,
    wlan_intf_opcode_supported_country_or_region_string_list,
    wlan_intf_opcode_current_operation_mode,
    wlan_intf_opcode_supported_safe_mode,
    wlan_intf_opcode_certified_safe_mode,
    wlan_intf_opcode_hosted_network_capable,
    wlan_intf_opcode_autoconf_end = 0x0fffffff,
    wlan_intf_opcode_msm_start = 0x10000100,
    wlan_intf_opcode_statistics,
    wlan_intf_opcode_rssi,
    wlan_intf_opcode_msm_end = 0x1fffffff,
    wlan_intf_opcode_security_start = 0x20010000,
    wlan_intf_opcode_security_end = 0x2fffffff,
    wlan_intf_opcode_ihv_start = 0x30000000,
    wlan_intf_opcode_ihv_end = 0x3fffffff
} WLAN_INTF_OPCODE, *PWLAN_INTF_OPCODE;


// OpCodes for set/query auto config parameters
#ifdef __midl
// use the 4-byte enum
typedef [v1_enum] enum _WLAN_AUTOCONF_OPCODE {
#else
typedef enum _WLAN_AUTOCONF_OPCODE {
#endif
    wlan_autoconf_opcode_start = 0,
    wlan_autoconf_opcode_show_denied_networks,
    wlan_autoconf_opcode_power_setting,
    wlan_autoconf_opcode_only_use_gp_profiles_for_allowed_networks,
    wlan_autoconf_opcode_allow_explicit_creds,
    wlan_autoconf_opcode_block_period,
    wlan_autoconf_opcode_allow_virtual_station_extensibility,
    wlan_autoconf_opcode_end
} WLAN_AUTOCONF_OPCODE, *PWLAN_AUTOCONF_OPCODE;


// IHV control types
#ifdef __midl
// use the 4-byte enum
typedef [v1_enum] enum _WLAN_IHV_CONTROL_TYPE {
#else
typedef enum _WLAN_IHV_CONTROL_TYPE {
#endif
    wlan_ihv_control_type_service,
    wlan_ihv_control_type_driver
} WLAN_IHV_CONTROL_TYPE, *PWLAN_IHV_CONTROL_TYPE;

typedef enum _WLAN_FILTER_LIST_TYPE {
    wlan_filter_list_type_gp_permit,
    wlan_filter_list_type_gp_deny,
    wlan_filter_list_type_user_permit,
    wlan_filter_list_type_user_deny
} WLAN_FILTER_LIST_TYPE, *PWLAN_FILTER_LIST_TYPE;

// Driver statistics
typedef struct WLAN_PHY_FRAME_STATISTICS {
    // TX counters (MSDU/MMPDU)
    ULONGLONG ullTransmittedFrameCount;
    ULONGLONG ullMulticastTransmittedFrameCount;
    ULONGLONG ullFailedCount;
    ULONGLONG ullRetryCount;
    ULONGLONG ullMultipleRetryCount;
    ULONGLONG ullMaxTXLifetimeExceededCount;

    // TX counters (MPDU)
    ULONGLONG ullTransmittedFragmentCount;
    ULONGLONG ullRTSSuccessCount;
    ULONGLONG ullRTSFailureCount;
    ULONGLONG ullACKFailureCount;

    // RX counters (MSDU/MMPDU)
    ULONGLONG ullReceivedFrameCount;
    ULONGLONG ullMulticastReceivedFrameCount;
    ULONGLONG ullPromiscuousReceivedFrameCount;
    ULONGLONG ullMaxRXLifetimeExceededCount;

    // RX counters (MPDU)
    ULONGLONG ullFrameDuplicateCount;
    ULONGLONG ullReceivedFragmentCount;
    ULONGLONG ullPromiscuousReceivedFragmentCount;
    ULONGLONG ullFCSErrorCount;
} WLAN_PHY_FRAME_STATISTICS, * PWLAN_PHY_FRAME_STATISTICS;

typedef struct WLAN_MAC_FRAME_STATISTICS {
    ULONGLONG ullTransmittedFrameCount;
    ULONGLONG ullReceivedFrameCount;
    ULONGLONG ullWEPExcludedCount;
    ULONGLONG ullTKIPLocalMICFailures;
    ULONGLONG ullTKIPReplays;
    ULONGLONG ullTKIPICVErrorCount;
    ULONGLONG ullCCMPReplays;
    ULONGLONG ullCCMPDecryptErrors;
    ULONGLONG ullWEPUndecryptableCount;
    ULONGLONG ullWEPICVErrorCount;
    ULONGLONG ullDecryptSuccessCount;
    ULONGLONG ullDecryptFailureCount;
} WLAN_MAC_FRAME_STATISTICS, * PWLAN_MAC_FRAME_STATISTICS;

typedef struct WLAN_STATISTICS {
    ULONGLONG ullFourWayHandshakeFailures;
    ULONGLONG ullTKIPCounterMeasuresInvoked;
    ULONGLONG ullReserved;
    WLAN_MAC_FRAME_STATISTICS MacUcastCounters;
    WLAN_MAC_FRAME_STATISTICS MacMcastCounters;
    DWORD dwNumberOfPhys;
#ifdef __midl
    [unique, size_is(dwNumberOfPhys)] WLAN_PHY_FRAME_STATISTICS PhyCounters[*];
#else
    WLAN_PHY_FRAME_STATISTICS PhyCounters[1];
#endif
} WLAN_STATISTICS, * PWLAN_STATISTICS;

// API protection settings

// Definition of access masks for setting non-default security
// settings on WLAN configuration objects and connection profiles.

#define WLAN_READ_ACCESS    ( STANDARD_RIGHTS_READ | FILE_READ_DATA )
#define WLAN_EXECUTE_ACCESS ( WLAN_READ_ACCESS | STANDARD_RIGHTS_EXECUTE | FILE_EXECUTE )
#define WLAN_WRITE_ACCESS   ( WLAN_READ_ACCESS | WLAN_EXECUTE_ACCESS | STANDARD_RIGHTS_WRITE | FILE_WRITE_DATA | DELETE | WRITE_DAC )


typedef enum
_WLAN_SECURABLE_OBJECT
{
    wlan_secure_permit_list = 0,
    wlan_secure_deny_list,
    wlan_secure_ac_enabled,
    wlan_secure_bc_scan_enabled,
    wlan_secure_bss_type,
    wlan_secure_show_denied,
    wlan_secure_interface_properties,
    wlan_secure_ihv_control,
    wlan_secure_all_user_profiles_order,
    wlan_secure_add_new_all_user_profiles,
    wlan_secure_add_new_per_user_profiles,
    wlan_secure_media_streaming_mode_enabled,
    wlan_secure_current_operation_mode,
    wlan_secure_get_plaintext_key,
    wlan_secure_hosted_network_elevated_access,
    wlan_secure_virtual_station_extensibility,

    WLAN_SECURABLE_OBJECT_COUNT
}
WLAN_SECURABLE_OBJECT, *PWLAN_SECURABLE_OBJECT;


// public APIs
DWORD WINAPI
WlanOpenHandle(
    __in DWORD dwClientVersion,
    __reserved PVOID pReserved,
    __out PDWORD pdwNegotiatedVersion,
    __out PHANDLE phClientHandle
);

DWORD WINAPI
WlanCloseHandle(
    __in HANDLE hClientHandle,
    __reserved PVOID pReserved
);

DWORD WINAPI
WlanEnumInterfaces(
    __in HANDLE hClientHandle,
    __reserved PVOID pReserved,
    __deref_out PWLAN_INTERFACE_INFO_LIST *ppInterfaceList
);

DWORD WINAPI
WlanSetAutoConfigParameter(
    __in HANDLE hClientHandle,
    __in WLAN_AUTOCONF_OPCODE OpCode,
    __in DWORD dwDataSize,
    __in_bcount(dwDataSize) CONST PVOID pData,
    __reserved PVOID pReserved
);

DWORD WINAPI
WlanQueryAutoConfigParameter(
    __in HANDLE hClientHandle,
    __in WLAN_AUTOCONF_OPCODE OpCode,
    __reserved PVOID pReserved,
    __out PDWORD pdwDataSize,
    __deref_out_bcount(*pdwDataSize) PVOID *ppData,
    __out_opt PWLAN_OPCODE_VALUE_TYPE pWlanOpcodeValueType
);

DWORD WINAPI 
WlanGetInterfaceCapability(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid,
    __reserved PVOID pReserved,
    __deref_out PWLAN_INTERFACE_CAPABILITY *ppCapability
);

DWORD WINAPI
WlanSetInterface(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid, 
    __in WLAN_INTF_OPCODE OpCode,
    __in DWORD dwDataSize,
    __in_bcount(dwDataSize) CONST PVOID pData,
    __reserved PVOID pReserved
);

DWORD WINAPI
WlanQueryInterface(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid, 
    __in WLAN_INTF_OPCODE OpCode,
    __reserved PVOID pReserved,
    __out PDWORD pdwDataSize,
    __deref_out_bcount(*pdwDataSize) PVOID *ppData,
    __out_opt PWLAN_OPCODE_VALUE_TYPE pWlanOpcodeValueType
);

DWORD WINAPI
WlanIhvControl(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid,
    __in WLAN_IHV_CONTROL_TYPE Type,
    __in DWORD dwInBufferSize,
    __in_bcount(dwInBufferSize) PVOID pInBuffer,
    __in DWORD dwOutBufferSize,
    __inout_bcount_opt(dwOutBufferSize) PVOID pOutBuffer,
    __out PDWORD pdwBytesReturned
);

DWORD WINAPI
WlanScan(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid, 
    __in_opt CONST PDOT11_SSID pDot11Ssid,
    __in_opt CONST PWLAN_RAW_DATA pIeData,
    __reserved PVOID pReserved
);

DWORD WINAPI
WlanGetAvailableNetworkList(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid,
    __in DWORD dwFlags,
    __reserved PVOID pReserved,
    __deref_out PWLAN_AVAILABLE_NETWORK_LIST *ppAvailableNetworkList
);

DWORD WINAPI
WlanGetNetworkBssList(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid, 
    __in_opt CONST PDOT11_SSID pDot11Ssid,
    __in DOT11_BSS_TYPE dot11BssType,
    __in BOOL bSecurityEnabled,
    __reserved PVOID pReserved,
    __deref_out PWLAN_BSS_LIST *ppWlanBssList
);

DWORD WINAPI 
WlanConnect(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid, 
    __in CONST PWLAN_CONNECTION_PARAMETERS pConnectionParameters,
    __reserved PVOID pReserved
);

DWORD WINAPI 
WlanDisconnect(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid, 
    __reserved PVOID pReserved
);

DWORD WINAPI
WlanRegisterNotification(
    __in HANDLE hClientHandle,
    __in DWORD dwNotifSource,
    __in BOOL bIgnoreDuplicate,
    __in_opt WLAN_NOTIFICATION_CALLBACK funcCallback,
    __in_opt PVOID pCallbackContext,
    __reserved PVOID pReserved,
    __out_opt PDWORD pdwPrevNotifSource
);


DWORD WINAPI
WlanGetProfile(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid,
    __in LPCWSTR strProfileName,
    __reserved PVOID pReserved,
    __deref_out LPWSTR *pstrProfileXml,
    __inout_opt DWORD *pdwFlags,    
    __out_opt DWORD *pdwGrantedAccess
);

DWORD WINAPI
WlanSetProfileEapUserData(
    __in HANDLE hClientHandle,
    __in const GUID *pInterfaceGuid,
    __in LPCWSTR strProfileName,
    __in EAP_METHOD_TYPE eapType,
    __in DWORD dwFlags,
    __in DWORD dwEapUserDataSize,
    __in_bcount(dwEapUserDataSize) const LPBYTE pbEapUserData,
    __reserved PVOID pReserved
);

DWORD WINAPI
WlanSetProfileEapXmlUserData(
    __in HANDLE hClientHandle,
    __in const GUID *pInterfaceGuid,
    __in LPCWSTR strProfileName,
    __in DWORD dwFlags,
    __in LPCWSTR strEapXmlUserData,
    __reserved PVOID pReserved
);

DWORD WINAPI
WlanSetProfile(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid,
    __in DWORD dwFlags,
    __in LPCWSTR strProfileXml,
    __in_opt LPCWSTR strAllUserProfileSecurity,
    __in BOOL bOverwrite,
    __reserved PVOID pReserved,
    __out DWORD *pdwReasonCode
);

DWORD WINAPI
WlanDeleteProfile(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid,
    __in LPCWSTR strProfileName,
    __reserved PVOID pReserved
);

DWORD WINAPI
WlanRenameProfile(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid,
    __in LPCWSTR strOldProfileName,
    __in LPCWSTR strNewProfileName,
    __reserved PVOID pReserved
);

DWORD WINAPI
WlanGetProfileList(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid,
    __reserved PVOID pReserved,
    __deref_out PWLAN_PROFILE_INFO_LIST *ppProfileList
);

DWORD WINAPI
WlanSetProfileList(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid,
    __in DWORD dwItems,
    __in_ecount(dwItems) LPCWSTR *strProfileNames,
    __reserved PVOID pReserved
);

DWORD WINAPI
WlanSetProfilePosition(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid,
    __in LPCWSTR strProfileName,
    __in DWORD dwPosition,
    __reserved PVOID pReserved
);

DWORD WINAPI
WlanSetProfileCustomUserData(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid,
    __in LPCWSTR strProfileName,
    __in DWORD dwDataSize,
    __in_bcount(dwDataSize) CONST PBYTE pData,
    __reserved PVOID pReserved
);

DWORD WINAPI
WlanGetProfileCustomUserData(
    __in HANDLE hClientHandle,
    __in CONST GUID *pInterfaceGuid,
    __in LPCWSTR strProfileName,
    __reserved PVOID pReserved,
    __out DWORD *pdwDataSize,
    __deref_out_bcount(*pdwDataSize) PBYTE *ppData
);

DWORD WINAPI
WlanSetFilterList(
    __in HANDLE hClientHandle,
    __in WLAN_FILTER_LIST_TYPE wlanFilterListType,
    __in_opt CONST PDOT11_NETWORK_LIST pNetworkList,
    __reserved PVOID pReserved
);

DWORD WINAPI 
WlanGetFilterList(
    __in HANDLE hClientHandle,
    __in WLAN_FILTER_LIST_TYPE wlanFilterListType,
    __reserved PVOID pReserved,
    __deref_out PDOT11_NETWORK_LIST *ppNetworkList
);

DWORD WINAPI
WlanSetPsdIEDataList(
    __in HANDLE hClientHandle,
    __in_opt LPCWSTR strFormat,
    __in_opt CONST PWLAN_RAW_DATA_LIST pPsdIEDataList,
    __reserved PVOID pReserved
);

DWORD WINAPI
WlanSaveTemporaryProfile(
    __in HANDLE hClientHandle,
    __in CONST GUID* pInterfaceGuid,
    __in LPCWSTR strProfileName,
    __in_opt LPCWSTR strAllUserProfileSecurity,
    __in DWORD dwFlags,
    __in BOOL bOverWrite,
    __reserved PVOID pReserved
);

#if !defined(__midl)

// client side APIs
DWORD WINAPI
WlanExtractPsdIEDataList(
    __in HANDLE hClientHandle,
    __in DWORD dwIeDataSize,
    __in_bcount(dwIeDataSize) CONST PBYTE pRawIeData,
    __in LPCWSTR strFormat,
    __reserved PVOID pReserved,
    __deref_out PWLAN_RAW_DATA_LIST *ppPsdIEDataList
);


DWORD WINAPI 
WlanReasonCodeToString(
    __in DWORD dwReasonCode,
    __in DWORD dwBufferSize,
    __in_ecount(dwBufferSize) PWCHAR pStringBuffer,
    __reserved PVOID pReserved
);

PVOID WINAPI 
WlanAllocateMemory(
    __in DWORD dwMemorySize
);

VOID WINAPI 
WlanFreeMemory(
    __in PVOID pMemory
);

DWORD WINAPI
WlanSetSecuritySettings(
    __in HANDLE hClientHandle,
    __in WLAN_SECURABLE_OBJECT SecurableObject,
    __in LPCWSTR strModifiedSDDL
);

DWORD WINAPI
WlanGetSecuritySettings(
    __in HANDLE hClientHandle,
    __in WLAN_SECURABLE_OBJECT SecurableObject,
    __out_opt PWLAN_OPCODE_VALUE_TYPE pValueType,
    __deref_out LPWSTR* pstrCurrentSDDL,
    __out PDWORD pdwGrantedAccess
);

#endif


// the following structures and defs are
// for the UI related functions

// current version
#define WLAN_UI_API_VERSION         1
// earliest version supported
#define WLAN_UI_API_INITIAL_VERSION 1

// The list of pages displayed by the wireless profile UI
typedef enum _WL_DISPLAY_PAGES
{
    WLConnectionPage,
    WLSecurityPage,
    WLAdvPage
} WL_DISPLAY_PAGES, *PWL_DISPLAY_PAGES;

DWORD WINAPI 
WlanUIEditProfile(
    __in DWORD dwClientVersion,
    __in LPCWSTR wstrProfileName, 
    __in GUID *pInterfaceGuid,
    __in HWND hWnd,
    __in WL_DISPLAY_PAGES wlStartPage, 
    __reserved PVOID pReserved,
    __out_opt PWLAN_REASON_CODE pWlanReasonCode
    );



#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

// Hosted Network APIs

typedef
#ifdef __midl
[v1_enum]
#endif
enum _WLAN_HOSTED_NETWORK_STATE
{
    wlan_hosted_network_unavailable,
    wlan_hosted_network_idle,
    wlan_hosted_network_active,
}
WLAN_HOSTED_NETWORK_STATE, *PWLAN_HOSTED_NETWORK_STATE;




typedef
#ifdef __midl
[v1_enum]
#endif
enum _WLAN_HOSTED_NETWORK_REASON
{
    wlan_hosted_network_reason_success = 0,
    wlan_hosted_network_reason_unspecified,
    wlan_hosted_network_reason_bad_parameters,
    wlan_hosted_network_reason_service_shutting_down,
    wlan_hosted_network_reason_insufficient_resources,
    wlan_hosted_network_reason_elevation_required,
    wlan_hosted_network_reason_read_only,
    wlan_hosted_network_reason_persistence_failed,
    wlan_hosted_network_reason_crypt_error,
    wlan_hosted_network_reason_impersonation,
    wlan_hosted_network_reason_stop_before_start,

    wlan_hosted_network_reason_interface_available,
    wlan_hosted_network_reason_interface_unavailable,
    wlan_hosted_network_reason_miniport_stopped,
    wlan_hosted_network_reason_miniport_started,
    wlan_hosted_network_reason_incompatible_connection_started,
    wlan_hosted_network_reason_incompatible_connection_stopped,
    wlan_hosted_network_reason_user_action,
    wlan_hosted_network_reason_client_abort,
    wlan_hosted_network_reason_ap_start_failed,

    wlan_hosted_network_reason_peer_arrived,
    wlan_hosted_network_reason_peer_departed,
    wlan_hosted_network_reason_peer_timeout,
    wlan_hosted_network_reason_gp_denied,
    wlan_hosted_network_reason_service_unavailable,
    wlan_hosted_network_reason_device_change,
    wlan_hosted_network_reason_properties_change,
    wlan_hosted_network_reason_virtual_station_blocking_use,
    wlan_hosted_network_reason_service_available_on_virtual_station,

}
WLAN_HOSTED_NETWORK_REASON, *PWLAN_HOSTED_NETWORK_REASON;


typedef
#ifdef __midl
[v1_enum]
#endif
enum _WLAN_HOSTED_NETWORK_PEER_AUTH_STATE
{
    wlan_hosted_network_peer_state_invalid,
    wlan_hosted_network_peer_state_authenticated,
}
WLAN_HOSTED_NETWORK_PEER_AUTH_STATE, *PWLAN_HOSTED_NETWORK_PEER_AUTH_STATE;



DWORD
WINAPI
WlanHostedNetworkStartUsing
(
    __in        HANDLE                          hClientHandle,
    __out_opt   PWLAN_HOSTED_NETWORK_REASON     pFailReason,
    __reserved  PVOID                           pvReserved
);



DWORD
WINAPI
WlanHostedNetworkStopUsing
(
    __in        HANDLE                          hClientHandle,
    __out_opt   PWLAN_HOSTED_NETWORK_REASON     pFailReason,
    __reserved  PVOID                           pvReserved
);




DWORD
WINAPI
WlanHostedNetworkForceStart
(
    __in        HANDLE                          hClientHandle,
    __out_opt   PWLAN_HOSTED_NETWORK_REASON     pFailReason,
    __reserved  PVOID                           pvReserved
);



DWORD
WINAPI
WlanHostedNetworkForceStop
(
    __in        HANDLE                          hClientHandle,
    __out_opt   PWLAN_HOSTED_NETWORK_REASON     pFailReason,
    __reserved  PVOID                           pvReserved
);



typedef
struct _WLAN_HOSTED_NETWORK_PEER_STATE
{
    DOT11_MAC_ADDRESS                       PeerMacAddress;
    WLAN_HOSTED_NETWORK_PEER_AUTH_STATE     PeerAuthState;
}
WLAN_HOSTED_NETWORK_PEER_STATE, *PWLAN_HOSTED_NETWORK_PEER_STATE;



typedef
struct _WLAN_HOSTED_NETWORK_RADIO_STATE
{
    DOT11_RADIO_STATE   dot11SoftwareRadioState;
    DOT11_RADIO_STATE   dot11HardwareRadioState;
}
WLAN_HOSTED_NETWORK_RADIO_STATE, *PWLAN_HOSTED_NETWORK_RADIO_STATE;


// Definitions required for calling WlanRegisterNotification
// Notification source - L2_NOTIFICATION_SOURCE_WLAN_HNWK

// Notification code
typedef
#ifdef __midl
[v1_enum]
#endif
enum _WLAN_HOSTED_NETWORK_NOTIFICATION_CODE
{
    wlan_hosted_network_state_change = L2_NOTIFICATION_CODE_V2_BEGIN,
    wlan_hosted_network_peer_state_change,
    wlan_hosted_network_radio_state_change,
}
WLAN_HOSTED_NETWORK_NOTIFICATION_CODE, *PWLAN_HOSTED_NETWORK_NOTIFICATION_CODE;






// Notification data associated with wlan_hosted_network_state_change
typedef
struct _WLAN_HOSTED_NETWORK_STATE_CHANGE
{
    WLAN_HOSTED_NETWORK_STATE   OldState;
    WLAN_HOSTED_NETWORK_STATE   NewState;
    WLAN_HOSTED_NETWORK_REASON  StateChangeReason; 
}
WLAN_HOSTED_NETWORK_STATE_CHANGE, *PWLAN_HOSTED_NETWORK_STATE_CHANGE;



// Notification data associated with wlan_hosted_network_peer_state_change
typedef
struct _WLAN_HOSTED_NETWORK_DATA_PEER_STATE_CHANGE
{
    WLAN_HOSTED_NETWORK_PEER_STATE      OldState;
    WLAN_HOSTED_NETWORK_PEER_STATE      NewState;
    WLAN_HOSTED_NETWORK_REASON          PeerStateChangeReason; 
}
WLAN_HOSTED_NETWORK_DATA_PEER_STATE_CHANGE, *PWLAN_HOSTED_NETWORK_DATA_PEER_STATE_CHANGE;



// Notification data associated with wlan_hosted_network_radio_state_change
// WLAN_HOSTED_NETWORK_RADIO_STATE







// Definitions required for calling WlanHostedNetworkQueryProperty and WlanHostedNetworkSetProperty


typedef
#ifdef __midl
[v1_enum]
#endif
enum
_WLAN_HOSTED_NETWORK_OPCODE
{
    wlan_hosted_network_opcode_connection_settings,
    wlan_hosted_network_opcode_security_settings,
    wlan_hosted_network_opcode_station_profile,
    wlan_hosted_network_opcode_enable,
}
WLAN_HOSTED_NETWORK_OPCODE, *PWLAN_HOSTED_NETWORK_OPCODE;



// Data structure associated with wlan_hosted_network_opcode_connection_settings
// can be used for query and set
typedef
struct _WLAN_HOSTED_NETWORK_CONNECTION_SETTINGS
{
    DOT11_SSID  hostedNetworkSSID;
    DWORD       dwMaxNumberOfPeers;
}
WLAN_HOSTED_NETWORK_CONNECTION_SETTINGS, *PWLAN_HOSTED_NETWORK_CONNECTION_SETTINGS;


// Data structure associated with wlan_hosted_network_opcode_security_settings
// can be used for query only
typedef
struct _WLAN_HOSTED_NETWORK_SECURITY_SETTINGS
{
    DOT11_AUTH_ALGORITHM        dot11AuthAlgo;
    DOT11_CIPHER_ALGORITHM      dot11CipherAlgo;
}
WLAN_HOSTED_NETWORK_SECURITY_SETTINGS, *PWLAN_HOSTED_NETWORK_SECURITY_SETTINGS;



// Data structure associated with wlan_hosted_network_opcode_station_profile
// can be used for query only
// LPWSTR



// Data structure associated with wlan_hosted_network_opcode_enable
// can be used for query and set
// BOOL




//
// This function queries the static properties of the hosted network
//
DWORD
WINAPI
WlanHostedNetworkQueryProperty
(
    __in                                HANDLE                      hClientHandle,
    __in                                WLAN_HOSTED_NETWORK_OPCODE  OpCode,
    __out                               PDWORD                      pdwDataSize,
    __deref_out_bcount(*pdwDataSize)    PVOID*                      ppvData,
    __out                               PWLAN_OPCODE_VALUE_TYPE     pWlanOpcodeValueType,
    __reserved  PVOID                                               pvReserved
);




//
// This function sets the static properties of the hosted network
//
DWORD
WINAPI
WlanHostedNetworkSetProperty
(
    __in                        HANDLE                          hClientHandle,
    __in                        WLAN_HOSTED_NETWORK_OPCODE      OpCode,
    __in                        DWORD                           dwDataSize,
    __in_bcount(dwDataSize)     PVOID                           pvData,
    __out_opt                   PWLAN_HOSTED_NETWORK_REASON     pFailReason,
    __reserved                  PVOID                           pvReserved
);



//
// This function initializes hosted network configuration
// on a machine. There are no effects if an initial
// configuration has already been created.
//
DWORD
WINAPI
WlanHostedNetworkInitSettings
(
    __in        HANDLE                          hClientHandle,
    __out_opt   PWLAN_HOSTED_NETWORK_REASON     pFailReason,
    __reserved  PVOID                           pvReserved
);




DWORD
WINAPI
WlanHostedNetworkRefreshSecuritySettings
(
    __in        HANDLE                          hClientHandle,
    __out_opt   PWLAN_HOSTED_NETWORK_REASON     pFailReason,
    __reserved  PVOID                           pvReserved
);


typedef
struct _WLAN_HOSTED_NETWORK_STATUS
{
    WLAN_HOSTED_NETWORK_STATE   HostedNetworkState;
    GUID                        IPDeviceID;
    DOT11_MAC_ADDRESS           wlanHostedNetworkBSSID;
    DOT11_PHY_TYPE              dot11PhyType;
    ULONG                       ulChannelFrequency;

    DWORD                       dwNumberOfPeers;
#ifdef __midl
    [unique, size_is(dwNumberOfPeers)] WLAN_HOSTED_NETWORK_PEER_STATE PeerList[*];
#else
    WLAN_HOSTED_NETWORK_PEER_STATE PeerList[1];
#endif
}
WLAN_HOSTED_NETWORK_STATUS, *PWLAN_HOSTED_NETWORK_STATUS;


//
// This function queries the runtime status of the hosted network
//
DWORD
WINAPI
WlanHostedNetworkQueryStatus
(
    __in        HANDLE                          hClientHandle,
    __deref_out PWLAN_HOSTED_NETWORK_STATUS*    ppWlanHostedNetworkStatus,
    __reserved  PVOID                           pvReserved
);





//
// This function set the additional security key used by hosted network
// if it is passphrase, key length includes the terminating '\0',
// if not, key length is the number of bytes in the key data array.
//
DWORD
WINAPI
WlanHostedNetworkSetSecondaryKey
(
    __in        HANDLE                          hClientHandle,
    __in        DWORD                           dwKeyLength,
    __in_bcount(dwKeyLength) PUCHAR             pucKeyData,
    __in        BOOL                            bIsPassPhrase,
    __in        BOOL                            bPersistent,
    __out_opt   PWLAN_HOSTED_NETWORK_REASON     pFailReason,
    __reserved  PVOID                           pvReserved
);



//
// This function query the additional security key used by hosted network
// If it is passphrase, key length includes the terminating '\0',
// if not, key length is the number of bytes in the key data array.
//
DWORD
WINAPI
WlanHostedNetworkQuerySecondaryKey
(
    __in        HANDLE                          hClientHandle,
    __out       PDWORD                          pdwKeyLength,
    __deref_out_ecount(*pdwKeyLength)   PUCHAR  *ppucKeyData,
    __out       PBOOL                           pbIsPassPhrase,
    __out       PBOOL                           pbPersistent,
    __out_opt   PWLAN_HOSTED_NETWORK_REASON     pFailReason,
    __reserved  PVOID                           pvReserved
);

//
// This function is used to register and unregister notifications on virtual station.
//
DWORD
WINAPI
WlanRegisterVirtualStationNotification
(
    __in        HANDLE hClientHandle,
    __in        BOOL bRegister,
    __reserved  PVOID pReserved
);

#endif // (_WIN32_WINNT >= _WIN32_WINNT_WIN7)



#ifdef __cplusplus
}
#endif

#endif  // _WLAN_WLANAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WinWlx.h ===
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1999, Microsoft Corporation

Module Name:

    winwlx.h

Abstract:

    WLX == WinLogon eXtension

    This file contains definitions, data types, and routine prototypes
    necessary to produce a replacement Graphical Identification aNd
    Authentication (GINA) DLL for Winlogon.

Author:

    Richard Ward (RichardW) and Jim Kelly (JimK) May-1994

Revision History:



--*/

#ifndef _WINWLX_
#define _WINWLX_

#if _MSC_VER > 1000
#pragma once
#endif



////////////////////////////////////////////////////////////////////////
//                                                                    //
//  #defines                                                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// Revisions of Winlogon API available for use by GINAs
// Version is two parts: Major revision and minor revision.
// Major revision is the upper 16-bits, minor is the lower
// 16-bits.
//

#define WLX_VERSION_1_0             (0X00010000)
#define WLX_VERSION_1_1             (0X00010001)
#define WLX_VERSION_1_2             (0X00010002)
#define WLX_VERSION_1_3             (0X00010003)
#define WLX_VERSION_1_4             (0X00010004)
#define WLX_CURRENT_VERSION         (WLX_VERSION_1_4)


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// Secure attention sequence types
// These values are passed to routines that have a dwSasType
// parameter.
//
//  ALL VALUES FROM 0 TO 127 ARE RESERVED FOR MICROSOFT DEFINITION.
//  VALUES ABOVE 127 ARE RESERVED FOR CUSTOMER DEFINITION.
//
//      CTRL_ALT_DEL - used to indicate that the standard ctrl-alt-del
//          secure attention sequence has been entered.
//
//      SCRNSVR_TIMEOUT - used to indicate that keyboard/mouse inactivity
//          has lead to a screensaver activation.  It is up to the GINA
//          DLL whether this constitutes a workstation locking event.
//
//      SCRNSVR_ACTIVITY - used to indicate that keyboard or mouse
//          activity occured while a secure screensaver was active.
//
//      SC_INSERT - used to indicate that a smart card has been inserted
//          to a compatible device
//
//      SC_REMOVE - used to indicate that a smart card has been removed
//          from a compatible device
//

#define WLX_SAS_TYPE_TIMEOUT                    (0)
#define WLX_SAS_TYPE_CTRL_ALT_DEL               (1)
#define WLX_SAS_TYPE_SCRNSVR_TIMEOUT            (2)
#define WLX_SAS_TYPE_SCRNSVR_ACTIVITY           (3)
#define WLX_SAS_TYPE_USER_LOGOFF                (4)
#define WLX_SAS_TYPE_SC_INSERT                  (5)
#define WLX_SAS_TYPE_SC_REMOVE                  (6)
#define WLX_SAS_TYPE_AUTHENTICATED              (7)
#define WLX_SAS_TYPE_SC_FIRST_READER_ARRIVED    (8)
#define WLX_SAS_TYPE_SC_LAST_READER_REMOVED     (9)
#define WLX_SAS_TYPE_SWITCHUSER                 (10)
#define WLX_SAS_TYPE_MAX_MSFT_VALUE             (127)


//
// This structure is available through WlxGetOption, and is
// passed as the lParam for any S/C SAS notices sent to windows
//
typedef struct _WLX_SC_NOTIFICATION_INFO {
    PWSTR   pszCard ;
    PWSTR   pszReader ;
    PWSTR   pszContainer ;
    PWSTR   pszCryptoProvider ;
} WLX_SC_NOTIFICATION_INFO, * PWLX_SC_NOTIFICATION_INFO ;



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// Upon successful logon, the GINA DLL may specify any of the following
// options to Winlogon (via the dwOptions parameter of the WlxLoggedOutSas()
// api).  When set, these options specify:
//
//      NO_PROFILE - Winlogon must NOT load a profile for the logged
//                   on user.  Either the GINA DLL will take care of
//                   this activity, or the user does not need a profile.
//

#define WLX_LOGON_OPT_NO_PROFILE        (0x00000001)



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// GINA DLLs are expected to return account information to Winlogon
// following a successful logon.  This information allows Winlogon
// to support profile loading and supplemental network providers.
//
// To allow different sets of profile information to be returned
// by GINAs over time, the first DWORD of each profile structure
// is expected to contain a type-identifier.  The following constants
// are the defined profile type identifiers.
//

//
// Standard profile is V2_0
//

#define WLX_PROFILE_TYPE_V1_0           (1)
#define WLX_PROFILE_TYPE_V2_0           (2)



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// WlxLoggedOnSas() and WlxWkstaLockedSas() return an action
// value to Winlogon directing Winlogon to either remain unchanged
// or to perform some action (such as force-log the user off).
// These are the values that may be returned.  Note, however, that
// not all of the values may be returned by both of these api.  See
// the description of each api to see which values are expected from
// each.
//
//  LOGON              - User has logged on
//  NONE               - Don't change the state of the window station.
//  LOCK_WKSTA         - Lock the workstation, wait for next SAS.
//  LOGOFF             - Log the user off of the workstation.
//  SHUTDOWN           - Log the user off and shutdown the machine.
//  PWD_CHANGED        - Indicates that the user changed their password.  Notify network providers.
//  TASKLIST           - Invoke the task list.
//  UNLOCK_WKSTA       - Unlock the workstation.
//  FORCE_LOGOFF       - Forcibly log the user off.
//  SHUTDOWN_POWER_OFF - Turn off machine after shutting down.
//  SHUTDOWN_REBOOT    - Reboot machine after shutting down.
//  SHUTDOWN_SLEEP     - Put the machine to sleep
//  SHUTDOWN_SLEEP2    - Put the machine to sleep and disable wakeup events
//  SHUTDOWN_HIBERNATE - Hibernate the machine
//  RECONNECTED        - Session was reconnected to an earlier session
//

#define WLX_SAS_ACTION_LOGON                        (1)
#define WLX_SAS_ACTION_NONE                         (2)
#define WLX_SAS_ACTION_LOCK_WKSTA                   (3)
#define WLX_SAS_ACTION_LOGOFF                       (4)
#define WLX_SAS_ACTION_SHUTDOWN                     (5)
#define WLX_SAS_ACTION_PWD_CHANGED                  (6)
#define WLX_SAS_ACTION_TASKLIST                     (7)
#define WLX_SAS_ACTION_UNLOCK_WKSTA                 (8)
#define WLX_SAS_ACTION_FORCE_LOGOFF                 (9)
#define WLX_SAS_ACTION_SHUTDOWN_POWER_OFF           (10)
#define WLX_SAS_ACTION_SHUTDOWN_REBOOT              (11)
#define WLX_SAS_ACTION_SHUTDOWN_SLEEP               (12)
#define WLX_SAS_ACTION_SHUTDOWN_SLEEP2              (13)
#define WLX_SAS_ACTION_SHUTDOWN_HIBERNATE           (14)
#define WLX_SAS_ACTION_RECONNECTED                  (15)
#define WLX_SAS_ACTION_DELAYED_FORCE_LOGOFF         (16)
#define WLX_SAS_ACTION_SWITCH_CONSOLE               (17)


////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Window Messages                                                   //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// The WM_SAS is defined as follows
//
//  The wParam parameter has the SAS Type (above)

#define WLX_WM_SAS                  (WM_USER + 601)


//
// Dialog return values
//
// These may be returned by dialogs started by a GINA dll.
//
#define WLX_DLG_SAS                     101
#define WLX_DLG_INPUT_TIMEOUT           102     // Input (keys, etc) timed out
#define WLX_DLG_SCREEN_SAVER_TIMEOUT    103     // Screen Saver activated
#define WLX_DLG_USER_LOGOFF             104     // User logged off




////////////////////////////////////////////////////////////////////////
//                                                                    //
//  #data types                                                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// The WLX_PROFILE_* structure is returned from a GINA DLL
// following authentication.  This information is used by Winlogon
// to support supplemental Network Providers and to load the
// newly logged-on user's profile.
//
// Winlogon is responsible for freeing both the profile structure
// and the fields within the structure that are marked as separately
// deallocatable.
//

typedef struct _WLX_PROFILE_V1_0 {

    //
    // This field identifies the type of profile being returned by a
    // GINA DLL.  Profile types are defined with the prefix
    // WLX_PROFILE_TYPE_xxx.  It allows Winlogon to typecast the
    // structure so the remainder of the structure may be referenced.
    //

    DWORD               dwType;



    //
    // pathname of profile to load for user.
    //
    // The buffer pointed to by this field must be separately allocated.
    // Winlogon will free the buffer when it is no longer needed.
    //
    //
    PWSTR               pszProfile;

} WLX_PROFILE_V1_0, * PWLX_PROFILE_V1_0;


typedef struct _WLX_PROFILE_V2_0 {

    //
    // This field identifies the type of profile being returned by a
    // GINA DLL.  Profile types are defined with the prefix
    // WLX_PROFILE_TYPE_xxx.  It allows Winlogon to typecast the
    // structure so the remainder of the structure may be referenced.
    //

    DWORD               dwType;


    //
    // pathname of profile to load for user.
    //
    // This parameter can be NULL.  If so, the user has a local
    // profile only.
    //
    // The buffer pointed to by this field must be separately allocated.
    // Winlogon will free the buffer when it is no longer needed.
    //
    //

    PWSTR               pszProfile;


    //
    // pathname of policy to load for user.
    //
    // This parameter can be NULL which prevents network wide policy
    // from being applied.
    //
    // The buffer pointed to by this field must be separately allocated.
    // Winlogon will free the buffer when it is no longer needed.
    //
    //

    PWSTR               pszPolicy;


    //
    // pathname of network default user profile
    //
    // This parameter can be NULL, which causes the Default User
    // profile on the local machine to be used.
    //
    // The buffer pointed to by this field must be separately allocated.
    // Winlogon will free the buffer when it is no longer needed.
    //
    //

    PWSTR               pszNetworkDefaultUserProfile;


    //
    // name of the server which validated the user account
    //
    // This is used to enumerate globals groups the user belongs
    // to for policy support.  This parameter can be NULL.
    //
    // The buffer pointed to by this field must be separately allocated.
    // Winlogon will free the buffer when it is no longer needed.
    //
    //

    PWSTR               pszServerName;


    //
    // pointer to a series of null terminated environment variables
    //
    // envname=environment variable value
    //   - or -
    // envname=%OtherVar%\more text
    //
    // Each environment variable is NULL terminated with the last
    // environment variable double NULL terminated.  These variables
    // are set into the user's initial environment.  The environment
    // variable value can contain other environment variables wrapped
    // in "%" signs. This parameter can be NULL.
    //
    // The buffer pointed to by this field must be separately allocated.
    // Winlogon will free the buffer when it is no longer needed.
    //
    //

    PWSTR               pszEnvironment;

} WLX_PROFILE_V2_0, * PWLX_PROFILE_V2_0;



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// The WLX_NPR_NOTIFICATION_INFO structure is returned
// from a GINA DLL following successful authentication.
// This information is used by Winlogon to provide
// identification and authentication information already
// collected to network providers.  Winlogon is
// responsible for freeing both the main structure and all
// string and other buffers pointed to from within the
// structure.
//

typedef struct _WLX_MPR_NOTIFY_INFO {

    //
    // The name of the account logged onto (e.g. REDMOND\Joe).
    // The string pointed to by this field must be separately
    // allocated and will be separately deallocated by Winlogon.
    //

    PWSTR           pszUserName;

    //
    // The string pointed to by this field must be separately
    // allocated and will be separately deallocated by Winlogon.
    //

    PWSTR           pszDomain;

    //
    // Cleartext password of the user account.  If the OldPassword
    // field is non-null, then this field contains the new password
    // in a password change operation.  The string pointed to by
    // this field must be separately allocated and will be seperately
    // deallocated by Winlogon.
    //

    PWSTR           pszPassword;

    //
    // Cleartext old password of the user account whose password
    // has just been changed.  The Password field contains the new
    // password.  The string pointed to by this field must be
    // separately allocated and will be separately deallocated by
    // Winlogon.
    //

    PWSTR           pszOldPassword;

} WLX_MPR_NOTIFY_INFO, * PWLX_MPR_NOTIFY_INFO;



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// WLX_TERMINAL_SERVICES_DATA is used by the GINA during a
// WlxQueryTerminalServicesData() callback into WinLogon from the
// WlxLoggedOutSAS() context, after the user name and domain are known.
// This structure relates to TS user configuration information which is
// retrieved from the Domain Controller and SAM database. Having WinLogon
// pass this information means the GINA does not need to do the same
// off-machines lookups again.
//

#define WLX_DIRECTORY_LENGTH 256

typedef struct _WLX_TERMINAL_SERVICES_DATA {

    //
    // TS profile path, overrides the standard profile path.
    //

    WCHAR           ProfilePath[WLX_DIRECTORY_LENGTH + 1];


    //
    // TS home directory, overrides standard home directory.
    //

    WCHAR           HomeDir[WLX_DIRECTORY_LENGTH + 1];


    //
    // TS home directory drive, overrides standard drive.
    //

    WCHAR           HomeDirDrive[4];

} WLX_TERMINAL_SERVICES_DATA, *PWLX_TERMINAL_SERVICES_DATA;



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// The WLX_CLIENT_CREDENTIALS_INFO structure is returned
// from winlogon from the WlxQueryClientCredentials() call.
//
// This allows a network client WinStation to pass client
// credentials for automatic logon.
//
// The MSGINA DLL is responsible for freeing the memory
// and substrings with LocalFree().
//

#define WLX_CREDENTIAL_TYPE_V1_0            (1)
#define WLX_CREDENTIAL_TYPE_V2_0            (2)

typedef struct _WLX_CLIENT_CREDENTIALS_INFO {

    //
    // This field identifies the type of credentials structure being allocated
    // by GINA DLL.  Credential types are defined with the prefix
    // WLX_CREDENTIAL_TYPE_xxx.  It allows Winlogon to typecast the
    // structure so the remainder of the structure may be referenced.
    //

    DWORD           dwType;

    PWSTR           pszUserName;
    PWSTR           pszDomain;
    PWSTR           pszPassword;

    //
    // This field forces a prompt for the password. This
    // is due to an administrator override.
    //
    // This allows the distinguishing of autologon
    // with no password.
    //
    BOOL            fPromptForPassword;

} WLX_CLIENT_CREDENTIALS_INFO_V1_0, * PWLX_CLIENT_CREDENTIALS_INFO_V1_0;

typedef struct _WLX_CLIENT_CREDENTIALS_INFO_2_0 {

    DWORD           dwType;
    PWSTR           pszUserName;
    PWSTR           pszDomain;
    PWSTR           pszPassword;
    BOOL            fPromptForPassword;

    //
    // This field tells winlogon to disconnect/abort the logon attempt if the
    // provided password is incorrect, or if it should reprompt (current
    // behavior)
    //

    BOOL            fDisconnectOnLogonFailure;

} WLX_CLIENT_CREDENTIALS_INFO_V2_0, * PWLX_CLIENT_CREDENTIALS_INFO_V2_0;


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// The WLX_CONSOLESWITCH_CREDENTIALS_INFO structure is returned
// from gina in response to WlxGetConsoleSwitchCredentials calls.

// This structure is also returned from winlogon in response to 
// to WlxQueryConsoleSwitchCredentials call
//
// This is used to implement single session Terminal Server. A remote 
// session winlogon calls WlxGetConsoleSwitchCredentials to get the token
// and other info of the logged on user from msgina. This info is then passed to
// the console session winlogon to autologon the user on the console session.
// The gina on console session calls WlxQueryConsoleSwitchCredentials to get 
// this info from winlogon and logs on the user.
//
// The caller is responsible for freeing the memory
// and substrings with LocalFree().
//


#define WLX_CONSOLESWITCHCREDENTIAL_TYPE_V1_0            (1)

typedef struct _WLX_CONSOLESWITCH_CREDENTIALS_INFO {

    //
    // This field identifies the type of credentials structure being allocated
    // Credential types are defined with the prefix
    // WLX_CONSOLESWITCHCREDENTIAL_TYPE_xxx.  It allows Winlogon to typecast the
    // structure so the remainder of the structure may be referenced.
    //

    DWORD            dwType;

    HANDLE           UserToken;
    LUID             LogonId;
    QUOTA_LIMITS     Quotas;
    PWSTR            UserName;
    PWSTR            Domain;
    LARGE_INTEGER    LogonTime;
    BOOL             SmartCardLogon;
    ULONG            ProfileLength;

    //
    // From MSV1_0_INTERACTIVE_PROFILE 
    //
    DWORD            MessageType;
    USHORT           LogonCount;
    USHORT           BadPasswordCount;
    LARGE_INTEGER    ProfileLogonTime;
    LARGE_INTEGER    LogoffTime;
    LARGE_INTEGER    KickOffTime;
    LARGE_INTEGER    PasswordLastSet;
    LARGE_INTEGER    PasswordCanChange;
    LARGE_INTEGER    PasswordMustChange;
    PWSTR            LogonScript;
    PWSTR            HomeDirectory;
    PWSTR            FullName;
    PWSTR            ProfilePath;
    PWSTR            HomeDirectoryDrive;
    PWSTR            LogonServer;
    ULONG            UserFlags;
    ULONG            PrivateDataLen;
    PBYTE            PrivateData;

} WLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0, * PWLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0;


////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Services that replacement GINAs   ** MUST ** provide              //
//                                                                    //
////////////////////////////////////////////////////////////////////////

BOOL
WINAPI
WlxNegotiate(
    DWORD                   dwWinlogonVersion,
    PDWORD                  pdwDllVersion
    );

BOOL
WINAPI
WlxInitialize(
    LPWSTR                  lpWinsta,
    HANDLE                  hWlx,
    PVOID                   pvReserved,
    PVOID                   pWinlogonFunctions,
    PVOID *                 pWlxContext
    );

VOID
WINAPI
WlxDisplaySASNotice(
    PVOID                   pWlxContext
    );


int
WINAPI
WlxLoggedOutSAS(
    PVOID                   pWlxContext,
    DWORD                   dwSasType,
    PLUID                   pAuthenticationId,
    PSID                    pLogonSid,
    PDWORD                  pdwOptions,
    PHANDLE                 phToken,
    PWLX_MPR_NOTIFY_INFO    pNprNotifyInfo,
    PVOID *                 pProfile
    );

BOOL
WINAPI
WlxActivateUserShell(
    PVOID                   pWlxContext,
    PWSTR                   pszDesktopName,
    PWSTR                   pszMprLogonScript,
    PVOID                   pEnvironment
    );

int
WINAPI
WlxLoggedOnSAS(
    PVOID                   pWlxContext,
    DWORD                   dwSasType,
    PVOID                   pReserved
    );

VOID
WINAPI
WlxDisplayLockedNotice(
    PVOID                   pWlxContext
    );

int
WINAPI
WlxWkstaLockedSAS(
    PVOID                   pWlxContext,
    DWORD                   dwSasType
    );

BOOL
WINAPI
WlxIsLockOk(
    PVOID                   pWlxContext
    );

BOOL
WINAPI
WlxIsLogoffOk(
    PVOID                   pWlxContext
    );

VOID
WINAPI
WlxLogoff(
    PVOID                   pWlxContext
    );


VOID
WINAPI
WlxShutdown(
    PVOID                   pWlxContext,
    DWORD                   ShutdownType
    );


//
// NEW for version 1.1
//
BOOL
WINAPI
WlxScreenSaverNotify(
    PVOID                   pWlxContext,
    BOOL *                  pSecure);

BOOL
WINAPI
WlxStartApplication(
    PVOID                   pWlxContext,
    PWSTR                   pszDesktopName,
    PVOID                   pEnvironment,
    PWSTR                   pszCmdLine
    );

//
// New for 1.3
//

BOOL
WINAPI
WlxNetworkProviderLoad(
    PVOID                   pWlxContext,
    PWLX_MPR_NOTIFY_INFO    pNprNotifyInfo
    );


#define STATUSMSG_OPTION_NOANIMATION    0x00000001
#define STATUSMSG_OPTION_SETFOREGROUND  0x00000002

BOOL
WINAPI
WlxDisplayStatusMessage(
    PVOID                   pWlxContext,
    HDESK                   hDesktop,
    DWORD                   dwOptions,
    PWSTR                   pTitle,
    PWSTR                   pMessage
    );

BOOL
WINAPI
WlxGetStatusMessage(
    PVOID                   pWlxContext,
    DWORD *                 pdwOptions,
    PWSTR                   pMessage,
    DWORD                   dwBufferSize
    );

BOOL
WINAPI
WlxRemoveStatusMessage(
    PVOID                   pWlxContext
    );


//
// New for 1.4
//
BOOL
WINAPI
WlxGetConsoleSwitchCredentials (
    PVOID                   pWlxContext,
    PVOID                   pCredInfo
    );

VOID
WINAPI
WlxReconnectNotify (
    PVOID                   pWlxContext
    );

VOID
WINAPI
WlxDisconnectNotify (
    PVOID                   pWlxContext
    );


////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Services that Winlogon provides                                   //
//                                                                    //
////////////////////////////////////////////////////////////////////////

typedef struct _WLX_DESKTOP {
    DWORD       Size;
    DWORD       Flags;
    HDESK       hDesktop;
    PWSTR       pszDesktopName;
} WLX_DESKTOP, * PWLX_DESKTOP;

#define WLX_DESKTOP_NAME    0x00000001      // Name present
#define WLX_DESKTOP_HANDLE  0x00000002      // Handle present



typedef VOID
(WINAPI * PWLX_USE_CTRL_ALT_DEL)(
    HANDLE                  hWlx
    );

typedef VOID
(WINAPI * PWLX_SET_CONTEXT_POINTER)(
    HANDLE                  hWlx,
    PVOID                   pWlxContext
    );

typedef VOID
(WINAPI * PWLX_SAS_NOTIFY)(
    HANDLE                  hWlx,
    DWORD                   dwSasType
    );

typedef BOOL
(WINAPI * PWLX_SET_TIMEOUT)(
    HANDLE                  hWlx,
    DWORD                   Timeout);

typedef int
(WINAPI * PWLX_ASSIGN_SHELL_PROTECTION)(
    HANDLE                  hWlx,
    HANDLE                  hToken,
    HANDLE                  hProcess,
    HANDLE                  hThread
    );

typedef int
(WINAPI * PWLX_MESSAGE_BOX)(
    HANDLE                  hWlx,
    HWND                    hwndOwner,
    LPWSTR                  lpszText,
    LPWSTR                  lpszTitle,
    UINT                    fuStyle
    );

typedef int
(WINAPI * PWLX_DIALOG_BOX)(
    HANDLE                  hWlx,
    HANDLE                  hInst,
    LPWSTR                  lpszTemplate,
    HWND                    hwndOwner,
    DLGPROC                 dlgprc
    );

typedef int
(WINAPI * PWLX_DIALOG_BOX_INDIRECT)(
    HANDLE                  hWlx,
    HANDLE                  hInst,
    LPCDLGTEMPLATE          hDialogTemplate,
    HWND                    hwndOwner,
    DLGPROC                 dlgprc
    );

typedef int
(WINAPI * PWLX_DIALOG_BOX_PARAM)(
    HANDLE                  hWlx,
    HANDLE                  hInst,
    LPWSTR                  lpszTemplate,
    HWND                    hwndOwner,
    DLGPROC                 dlgprc,
    LPARAM                  dwInitParam
    );

typedef int
(WINAPI * PWLX_DIALOG_BOX_INDIRECT_PARAM)(
    HANDLE                  hWlx,
    HANDLE                  hInst,
    LPCDLGTEMPLATE          hDialogTemplate,
    HWND                    hwndOwner,
    DLGPROC                 dlgprc,
    LPARAM                  dwInitParam
    );

typedef int
(WINAPI * PWLX_SWITCH_DESKTOP_TO_USER)(
    HANDLE                  hWlx);

typedef int
(WINAPI * PWLX_SWITCH_DESKTOP_TO_WINLOGON)(
    HANDLE                  hWlx);


typedef int
(WINAPI * PWLX_CHANGE_PASSWORD_NOTIFY)(
    HANDLE                  hWlx,
    PWLX_MPR_NOTIFY_INFO    pMprInfo,
    DWORD                   dwChangeInfo
    );

typedef BOOL
(WINAPI * PWLX_GET_SOURCE_DESKTOP)(
    HANDLE                  hWlx,
    PWLX_DESKTOP *          ppDesktop);

typedef BOOL
(WINAPI * PWLX_SET_RETURN_DESKTOP)(
    HANDLE                  hWlx,
    PWLX_DESKTOP            pDesktop);

typedef BOOL
(WINAPI * PWLX_CREATE_USER_DESKTOP)(
    HANDLE                  hWlx,
    HANDLE                  hToken,
    DWORD                   Flags,
    PWSTR                   pszDesktopName,
    PWLX_DESKTOP *          ppDesktop);

#define WLX_CREATE_INSTANCE_ONLY    0x00000001
#define WLX_CREATE_USER             0x00000002

typedef int
(WINAPI * PWLX_CHANGE_PASSWORD_NOTIFY_EX)(
    HANDLE                  hWlx,
    PWLX_MPR_NOTIFY_INFO    pMprInfo,
    DWORD                   dwChangeInfo,
    PWSTR                   ProviderName,
    PVOID                   Reserved);

typedef BOOL
(WINAPI * PWLX_CLOSE_USER_DESKTOP)(
    HANDLE          hWlx,
    PWLX_DESKTOP    pDesktop,
    HANDLE          hToken );

typedef BOOL
(WINAPI * PWLX_SET_OPTION)(
    HANDLE hWlx,
    DWORD Option,
    ULONG_PTR Value,
    ULONG_PTR * OldValue
    );

typedef BOOL
(WINAPI * PWLX_GET_OPTION)(
    HANDLE hWlx,
    DWORD Option,
    ULONG_PTR * Value
    );


typedef VOID
(WINAPI * PWLX_WIN31_MIGRATE)(
    HANDLE                  hWlx
    );

typedef BOOL
(WINAPI * PWLX_QUERY_CLIENT_CREDENTIALS)(
    PWLX_CLIENT_CREDENTIALS_INFO_V1_0 pCred
    );

typedef BOOL
(WINAPI * PWLX_QUERY_IC_CREDENTIALS)(
    PWLX_CLIENT_CREDENTIALS_INFO_V1_0 pCred
    );

typedef BOOL
(WINAPI * PWLX_QUERY_TS_LOGON_CREDENTIALS)(
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pCred
    );

typedef BOOL
(WINAPI * PWLX_DISCONNECT)(
    );

typedef DWORD
(WINAPI * PWLX_QUERY_TERMINAL_SERVICES_DATA)(
    HANDLE hWlx,
    PWLX_TERMINAL_SERVICES_DATA pTSData,
    WCHAR * UserName,
    WCHAR * Domain
    );

typedef DWORD
(WINAPI * PWLX_QUERY_CONSOLESWITCH_CREDENTIALS)(
      PWLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0 pCred
     );


//
// Options that can be get or set:
//

#define WLX_OPTION_USE_CTRL_ALT_DEL     0x00000001
#define WLX_OPTION_CONTEXT_POINTER      0x00000002
#define WLX_OPTION_USE_SMART_CARD       0x00000003
#define WLX_OPTION_FORCE_LOGOFF_TIME    0x00000004
#define WLX_OPTION_IGNORE_AUTO_LOGON    0x00000008
#define WLX_OPTION_NO_SWITCH_ON_SAS     0x00000009

//
// Options that can be queried only:
//

#define WLX_OPTION_SMART_CARD_PRESENT   0x00010001
#define WLX_OPTION_SMART_CARD_INFO      0x00010002
#define WLX_OPTION_DISPATCH_TABLE_SIZE  0x00010003



////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Function dispatch tables.                                         //
//  One of the following tables will be passed to the GINA DLL        //
//  in the WlxInitialize() call during initialization.                //
//                                                                    //
////////////////////////////////////////////////////////////////////////

typedef struct _WLX_DISPATCH_VERSION_1_0 {
    PWLX_USE_CTRL_ALT_DEL           WlxUseCtrlAltDel;
    PWLX_SET_CONTEXT_POINTER        WlxSetContextPointer;
    PWLX_SAS_NOTIFY                 WlxSasNotify;
    PWLX_SET_TIMEOUT                WlxSetTimeout;
    PWLX_ASSIGN_SHELL_PROTECTION    WlxAssignShellProtection;
    PWLX_MESSAGE_BOX                WlxMessageBox;
    PWLX_DIALOG_BOX                 WlxDialogBox;
    PWLX_DIALOG_BOX_PARAM           WlxDialogBoxParam;
    PWLX_DIALOG_BOX_INDIRECT        WlxDialogBoxIndirect;
    PWLX_DIALOG_BOX_INDIRECT_PARAM  WlxDialogBoxIndirectParam;
    PWLX_SWITCH_DESKTOP_TO_USER     WlxSwitchDesktopToUser;
    PWLX_SWITCH_DESKTOP_TO_WINLOGON WlxSwitchDesktopToWinlogon;
    PWLX_CHANGE_PASSWORD_NOTIFY     WlxChangePasswordNotify;
} WLX_DISPATCH_VERSION_1_0, *PWLX_DISPATCH_VERSION_1_0;

typedef struct _WLX_DISPATCH_VERSION_1_1 {
    PWLX_USE_CTRL_ALT_DEL           WlxUseCtrlAltDel;
    PWLX_SET_CONTEXT_POINTER        WlxSetContextPointer;
    PWLX_SAS_NOTIFY                 WlxSasNotify;
    PWLX_SET_TIMEOUT                WlxSetTimeout;
    PWLX_ASSIGN_SHELL_PROTECTION    WlxAssignShellProtection;
    PWLX_MESSAGE_BOX                WlxMessageBox;
    PWLX_DIALOG_BOX                 WlxDialogBox;
    PWLX_DIALOG_BOX_PARAM           WlxDialogBoxParam;
    PWLX_DIALOG_BOX_INDIRECT        WlxDialogBoxIndirect;
    PWLX_DIALOG_BOX_INDIRECT_PARAM  WlxDialogBoxIndirectParam;
    PWLX_SWITCH_DESKTOP_TO_USER     WlxSwitchDesktopToUser;
    PWLX_SWITCH_DESKTOP_TO_WINLOGON WlxSwitchDesktopToWinlogon;
    PWLX_CHANGE_PASSWORD_NOTIFY     WlxChangePasswordNotify;
    PWLX_GET_SOURCE_DESKTOP         WlxGetSourceDesktop;
    PWLX_SET_RETURN_DESKTOP         WlxSetReturnDesktop;
    PWLX_CREATE_USER_DESKTOP        WlxCreateUserDesktop;
    PWLX_CHANGE_PASSWORD_NOTIFY_EX  WlxChangePasswordNotifyEx;
} WLX_DISPATCH_VERSION_1_1, * PWLX_DISPATCH_VERSION_1_1;

typedef struct _WLX_DISPATCH_VERSION_1_2 {
    PWLX_USE_CTRL_ALT_DEL           WlxUseCtrlAltDel;
    PWLX_SET_CONTEXT_POINTER        WlxSetContextPointer;
    PWLX_SAS_NOTIFY                 WlxSasNotify;
    PWLX_SET_TIMEOUT                WlxSetTimeout;
    PWLX_ASSIGN_SHELL_PROTECTION    WlxAssignShellProtection;
    PWLX_MESSAGE_BOX                WlxMessageBox;
    PWLX_DIALOG_BOX                 WlxDialogBox;
    PWLX_DIALOG_BOX_PARAM           WlxDialogBoxParam;
    PWLX_DIALOG_BOX_INDIRECT        WlxDialogBoxIndirect;
    PWLX_DIALOG_BOX_INDIRECT_PARAM  WlxDialogBoxIndirectParam;
    PWLX_SWITCH_DESKTOP_TO_USER     WlxSwitchDesktopToUser;
    PWLX_SWITCH_DESKTOP_TO_WINLOGON WlxSwitchDesktopToWinlogon;
    PWLX_CHANGE_PASSWORD_NOTIFY     WlxChangePasswordNotify;
    PWLX_GET_SOURCE_DESKTOP         WlxGetSourceDesktop;
    PWLX_SET_RETURN_DESKTOP         WlxSetReturnDesktop;
    PWLX_CREATE_USER_DESKTOP        WlxCreateUserDesktop;
    PWLX_CHANGE_PASSWORD_NOTIFY_EX  WlxChangePasswordNotifyEx;
    PWLX_CLOSE_USER_DESKTOP         WlxCloseUserDesktop ;
} WLX_DISPATCH_VERSION_1_2, * PWLX_DISPATCH_VERSION_1_2;

typedef struct _WLX_DISPATCH_VERSION_1_3 {
    PWLX_USE_CTRL_ALT_DEL             WlxUseCtrlAltDel;
    PWLX_SET_CONTEXT_POINTER          WlxSetContextPointer;
    PWLX_SAS_NOTIFY                   WlxSasNotify;
    PWLX_SET_TIMEOUT                  WlxSetTimeout;
    PWLX_ASSIGN_SHELL_PROTECTION      WlxAssignShellProtection;
    PWLX_MESSAGE_BOX                  WlxMessageBox;
    PWLX_DIALOG_BOX                   WlxDialogBox;
    PWLX_DIALOG_BOX_PARAM             WlxDialogBoxParam;
    PWLX_DIALOG_BOX_INDIRECT          WlxDialogBoxIndirect;
    PWLX_DIALOG_BOX_INDIRECT_PARAM    WlxDialogBoxIndirectParam;
    PWLX_SWITCH_DESKTOP_TO_USER       WlxSwitchDesktopToUser;
    PWLX_SWITCH_DESKTOP_TO_WINLOGON   WlxSwitchDesktopToWinlogon;
    PWLX_CHANGE_PASSWORD_NOTIFY       WlxChangePasswordNotify;
    PWLX_GET_SOURCE_DESKTOP           WlxGetSourceDesktop;
    PWLX_SET_RETURN_DESKTOP           WlxSetReturnDesktop;
    PWLX_CREATE_USER_DESKTOP          WlxCreateUserDesktop;
    PWLX_CHANGE_PASSWORD_NOTIFY_EX    WlxChangePasswordNotifyEx;
    PWLX_CLOSE_USER_DESKTOP           WlxCloseUserDesktop ;
    PWLX_SET_OPTION                   WlxSetOption;
    PWLX_GET_OPTION                   WlxGetOption;
    PWLX_WIN31_MIGRATE                WlxWin31Migrate;
    PWLX_QUERY_CLIENT_CREDENTIALS     WlxQueryClientCredentials;
    PWLX_QUERY_IC_CREDENTIALS         WlxQueryInetConnectorCredentials;
    PWLX_DISCONNECT                   WlxDisconnect;
    PWLX_QUERY_TERMINAL_SERVICES_DATA WlxQueryTerminalServicesData;
} WLX_DISPATCH_VERSION_1_3, * PWLX_DISPATCH_VERSION_1_3;

typedef struct _WLX_DISPATCH_VERSION_1_4 {
    PWLX_USE_CTRL_ALT_DEL               WlxUseCtrlAltDel;
    PWLX_SET_CONTEXT_POINTER            WlxSetContextPointer;
    PWLX_SAS_NOTIFY                     WlxSasNotify;
    PWLX_SET_TIMEOUT                    WlxSetTimeout;
    PWLX_ASSIGN_SHELL_PROTECTION        WlxAssignShellProtection;
    PWLX_MESSAGE_BOX                    WlxMessageBox;
    PWLX_DIALOG_BOX                     WlxDialogBox;
    PWLX_DIALOG_BOX_PARAM               WlxDialogBoxParam;
    PWLX_DIALOG_BOX_INDIRECT            WlxDialogBoxIndirect;
    PWLX_DIALOG_BOX_INDIRECT_PARAM      WlxDialogBoxIndirectParam;
    PWLX_SWITCH_DESKTOP_TO_USER         WlxSwitchDesktopToUser;
    PWLX_SWITCH_DESKTOP_TO_WINLOGON     WlxSwitchDesktopToWinlogon;
    PWLX_CHANGE_PASSWORD_NOTIFY         WlxChangePasswordNotify;
    PWLX_GET_SOURCE_DESKTOP             WlxGetSourceDesktop;
    PWLX_SET_RETURN_DESKTOP             WlxSetReturnDesktop;
    PWLX_CREATE_USER_DESKTOP            WlxCreateUserDesktop;
    PWLX_CHANGE_PASSWORD_NOTIFY_EX      WlxChangePasswordNotifyEx;
    PWLX_CLOSE_USER_DESKTOP             WlxCloseUserDesktop ;
    PWLX_SET_OPTION                     WlxSetOption;
    PWLX_GET_OPTION                     WlxGetOption;
    PWLX_WIN31_MIGRATE                  WlxWin31Migrate;
    PWLX_QUERY_CLIENT_CREDENTIALS       WlxQueryClientCredentials;
    PWLX_QUERY_IC_CREDENTIALS           WlxQueryInetConnectorCredentials;
    PWLX_DISCONNECT                     WlxDisconnect;
    PWLX_QUERY_TERMINAL_SERVICES_DATA   WlxQueryTerminalServicesData;
    PWLX_QUERY_CONSOLESWITCH_CREDENTIALS WlxQueryConsoleSwitchCredentials;
    PWLX_QUERY_TS_LOGON_CREDENTIALS     WlxQueryTsLogonCredentials;
} WLX_DISPATCH_VERSION_1_4, * PWLX_DISPATCH_VERSION_1_4;


//
// Non-GINA notification DLLs
//

typedef DWORD (*PFNMSGECALLBACK)(BOOL bVerbose, LPWSTR lpMessage);

typedef __struct_bcount(Size) struct _WLX_NOTIFICATION_INFO {
    ULONG  Size ;
    ULONG  Flags ;
    PWSTR  UserName ;
    PWSTR  Domain ;
    PWSTR  WindowStation ;
    HANDLE hToken ;
    HDESK  hDesktop ;
    PFNMSGECALLBACK pStatusCallback ;
} WLX_NOTIFICATION_INFO, * PWLX_NOTIFICATION_INFO ;



#endif /* _WINWLX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\wlanihv.h ===
/*++

Copyright (c) 2005 Microsoft Corporation

Module Name:

   wlanihv.h

Abstract:

   Definition of public APIs for WLAN Extensibility Framework.

--*/

#ifndef __WLAN_IHV_H__
#define __WLAN_IHV_H__

#pragma once

#include <windot11.h>
#include <wlclient.h>
#include <l2cmn.h>
#include <WlanIhvTypes.h>
#include <dot1x.h>

// Forward declaration for the
// API structure to be exchanged
// during IHV DLL initialization.
typedef
struct _DOT11EXT_APIS
DOT11EXT_APIS, *PDOT11EXT_APIS;




// Forward declaration for the
// handler structure to be exchanged
// during IHV DLL initialization.
typedef
struct _DOT11EXT_IHV_HANDLERS
DOT11EXT_IHV_HANDLERS, *PDOT11EXT_IHV_HANDLERS;




// Forward declaration for the
// API set for controlling virtual station.
typedef
struct _DOT11EXT_VIRTUAL_STATION_APIS
DOT11EXT_VIRTUAL_STATION_APIS, *PDOT11EXT_VIRTUAL_STATION_APIS;






// Version exchange between
// extensibility framework
// and IHV DLL.
typedef
struct _DOT11_IHV_VERSION_INFO
{
   DWORD    dwVerMin;
   DWORD    dwVerMax;
}
DOT11_IHV_VERSION_INFO, *PDOT11_IHV_VERSION_INFO;



// connection phase to decide
// appropriate UI request.
typedef enum
_DOT11EXT_IHV_CONNECTION_PHASE
{
   connection_phase_any,
   connection_phase_initial_connection,
   connection_phase_post_l3_connection
}
DOT11EXT_IHV_CONNECTION_PHASE, *PDOT11EXT_IHV_CONNECTION_PHASE; 


// Information to build the UI Request information.
typedef
struct _DOT11EXT_IHV_UI_REQUEST
{
   DWORD    dwSessionId;
   GUID     guidUIRequest;
   CLSID    UIPageClsid;
   DWORD    dwByteCount;
#ifdef __midl
   [size_is(dwByteCount)] 
#endif
   __field_ecount(dwByteCount) BYTE*    pvUIRequest;
}
DOT11EXT_IHV_UI_REQUEST, *PDOT11EXT_IHV_UI_REQUEST;



// Structures to support MS 802.1X extensibility
typedef enum _DOT11_MSONEX_RESULT
{
    DOT11_MSONEX_SUCCESS,
    DOT11_MSONEX_FAILURE,
    DOT11_MSONEX_IN_PROGRESS
} DOT11_MSONEX_RESULT, *PDOT11_MSONEX_RESULT;


typedef struct _DOT11_EAP_RESULT 
{
   UINT32 dwFailureReasonCode;
   EAP_ATTRIBUTES* pAttribArray;
} DOT11_EAP_RESULT, *PDOT11_EAP_RESULT;


typedef struct _DOT11_MSONEX_RESULT_PARAMS
{
    ONEX_AUTH_STATUS Dot11OnexAuthStatus;
    ONEX_REASON_CODE Dot11OneXReasonCode;
#ifdef __midl
    [size_is(dwMPPESendKeyLen)]
#endif
    __field_ecount(dwMPPESendKeyLen) PBYTE pbMPPESendKey;
    DWORD dwMPPESendKeyLen;

#ifdef __midl
    [size_is(dwMPPERecvKeyLen)]
#endif
    __field_ecount(dwMPPERecvKeyLen) PBYTE pbMPPERecvKey;
    DWORD dwMPPERecvKeyLen;
    PDOT11_EAP_RESULT pDot11EapResult;
} DOT11_MSONEX_RESULT_PARAMS, *PDOT11_MSONEX_RESULT_PARAMS;



// Structures to define Ihv profiles.

typedef
struct _DOT11EXT_IHV_CONNECTIVITY_PROFILE
{
#ifdef __midl
    [string]
#endif
    LPWSTR      pszXmlFragmentIhvConnectivity;
    
}
DOT11EXT_IHV_CONNECTIVITY_PROFILE, *PDOT11EXT_IHV_CONNECTIVITY_PROFILE;


typedef
struct _DOT11EXT_IHV_SECURITY_PROFILE
{
#ifdef __midl
    [string]
#endif
    LPWSTR      pszXmlFragmentIhvSecurity;
    BOOL        bUseMSOnex;
}
DOT11EXT_IHV_SECURITY_PROFILE, *PDOT11EXT_IHV_SECURITY_PROFILE;


typedef
struct _DOT11EXT_IHV_DISCOVERY_PROFILE
{
    DOT11EXT_IHV_CONNECTIVITY_PROFILE   IhvConnectivityProfile;
    DOT11EXT_IHV_SECURITY_PROFILE       IhvSecurityProfile;
}
DOT11EXT_IHV_DISCOVERY_PROFILE, *PDOT11EXT_IHV_DISCOVERY_PROFILE;




typedef
struct _DOT11EXT_IHV_DISCOVERY_PROFILE_LIST
{
    DWORD                           dwCount;
#ifdef __midl
    [size_is(dwCount)]
#endif
    PDOT11EXT_IHV_DISCOVERY_PROFILE  pIhvDiscoveryProfiles;
}
DOT11EXT_IHV_DISCOVERY_PROFILE_LIST, *PDOT11EXT_IHV_DISCOVERY_PROFILE_LIST;

//
// Enum to distinguish between received Ihv notification types.
//
typedef enum
_DOT11EXT_IHV_INDICATION_TYPE
{
    IndicationTypeNicSpecificNotification,
    IndicationTypePmkidCandidateList,
    IndicationTypeTkipMicFailure,
    IndicationTypePhyStateChange,
    IndicationTypeLinkQuality
}
DOT11EXT_IHV_INDICATION_TYPE, *PDOT11EXT_IHV_INDICATION_TYPE;



// 
// Structure to represent the virtual station
// access point property.
//
#define DOT11EXT_PSK_MAX_LENGTH 64

typedef
struct _DOT11EXT_VIRTUAL_STATION_AP_PROPERTY
{
    DOT11_SSID              dot11SSID;
    DOT11_AUTH_ALGORITHM    dot11AuthAlgo;
    DOT11_CIPHER_ALGORITHM  dot11CipherAlgo;
    BOOL                    bIsPassPhrase;
    DWORD                   dwKeyLength;
    UCHAR                   ucKeyData[DOT11EXT_PSK_MAX_LENGTH];
}
DOT11EXT_VIRTUAL_STATION_AP_PROPERTY, *PDOT11EXT_VIRTUAL_STATION_AP_PROPERTY;

//
// Diagnostics Helper Class class parameter
//
#define WDIAG_IHV_WLAN_ID_FLAG_SECURITY_ENABLED               0x00000001

typedef
struct _WDIAG_IHV_WLAN_ID
{
    WCHAR                           strProfileName [MS_MAX_PROFILE_NAME_LENGTH];
    DOT11_SSID                      Ssid;
    DOT11_BSS_TYPE                  BssType;
    DWORD                           dwFlags;           // Flags define above
    DWORD                           dwReasonCode;      // Set only when an applicable reason code is available
}
WDIAG_IHV_WLAN_ID, *PWDIAG_IHV_WLAN_ID;



typedef
DWORD
(WINAPI *DOT11EXT_ALLOCATE_BUFFER)
(
                                    DWORD       dwByteCount,
    __deref_out_bcount(dwByteCount) LPVOID*     ppvBuffer
);




typedef
VOID
(WINAPI *DOT11EXT_FREE_BUFFER)
(
    __in_opt    LPVOID      pvMemory
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_PROFILE_CUSTOM_USER_DATA)
(
    __in_opt                HANDLE  hDot11SvcHandle,
    __in_opt                HANDLE  hConnectSession,
                            DWORD   dwSessionID,
                            DWORD   dwDataSize,
    __in_bcount(dwDataSize) LPVOID  pvData
);




typedef
DWORD
(WINAPI *DOT11EXT_GET_PROFILE_CUSTOM_USER_DATA)
(
    __in_opt                            HANDLE      hDot11SvcHandle,
    __in_opt                            HANDLE      hConnectSession,
                                        DWORD       dwSessionID,
    __out                               DWORD*      pdwDataSize,
    __deref_out_bcount(*pdwDataSize)    LPVOID*     ppvData
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_CURRENT_PROFILE)
(
    __in_opt    HANDLE                                  hDot11SvcHandle,
    __in_opt    HANDLE                                  hConnectSession,
    __in_opt    PDOT11EXT_IHV_CONNECTIVITY_PROFILE      pIhvConnProfile,
    __in_opt    PDOT11EXT_IHV_SECURITY_PROFILE          pIhvSecProfile
);




typedef
DWORD
(WINAPI *DOT11EXT_SEND_UI_REQUEST)
(
    __in_opt    HANDLE                      hDot11SvcHandle,
    __in        PDOT11EXT_IHV_UI_REQUEST    pIhvUIRequest
);




typedef
DWORD
(WINAPI *DOT11EXT_PRE_ASSOCIATE_COMPLETION)
(
    __in_opt    HANDLE      hDot11SvcHandle,
    __in_opt    HANDLE      hConnectSession,
                DWORD       dwReasonCode,
                DWORD       dwWin32Error
);




typedef
DWORD
(WINAPI *DOT11EXT_POST_ASSOCIATE_COMPLETION)
(
    __in_opt    HANDLE              hDot11SvcHandle,
    __in_opt    HANDLE              hSecuritySessionID,
    __in_opt    PDOT11_MAC_ADDRESS  pPeer,
                DWORD               dwReasonCode,
                DWORD               dwWin32Error
);




typedef
DWORD
(WINAPI *DOT11EXT_SEND_NOTIFICATION)
(
    __in_opt    HANDLE                  hDot11SvcHandle,
    __in        PL2_NOTIFICATION_DATA   pNotificationData
);




typedef
DWORD
(WINAPI *DOT11EXT_SEND_PACKET)
(
    __in_opt                HANDLE      hDot11SvcHandle,
                            ULONG       uPacketLen,
    __in_bcount(uPacketLen) LPVOID      pvPacket,
    __in_opt                HANDLE      hSendCompletion
);





typedef
DWORD
(WINAPI *DOT11EXT_SET_ETHERTYPE_HANDLING)
(
    __in_opt                            HANDLE                      hDot11SvcHandle,
                                        ULONG                       uMaxBackLog,
                                        ULONG                       uNumOfExemption,
    __in_ecount_opt(uNumOfExemption)    PDOT11_PRIVACY_EXEMPTION    pExemption,
                                        ULONG                       uNumOfRegistration,
    __in_ecount_opt(uNumOfRegistration) USHORT*                     pusRegistration
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_AUTH_ALGORITHM)
(
    __in_opt    HANDLE      hDot11SvcHandle,
                DWORD       dwAuthAlgo
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_UNICAST_CIPHER_ALGORITHM)
(
    __in_opt    HANDLE      hDot11SvcHandle,
                DWORD       dwUnicastCipherAlgo
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_MULTICAST_CIPHER_ALGORITHM)
(
    __in_opt    HANDLE      hDot11SvcHandle,
                DWORD       dwMulticastCipherAlgo
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_DEFAULT_KEY)
(
    __in_opt    HANDLE                              hDot11SvcHandle,
    __in        PDOT11_CIPHER_DEFAULT_KEY_VALUE     pKey,
                DOT11_DIRECTION                     dot11Direction
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_KEY_MAPPING_KEY)
(
    __in_opt    HANDLE                                  hDot11SvcHandle,
    __in        PDOT11_CIPHER_KEY_MAPPING_KEY_VALUE     pKey
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_DEFAULT_KEY_ID)
(
    __in_opt    HANDLE      hDot11SvcHandle,
                ULONG       uDefaultKeyId
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_EXCLUDE_UNENCRYPTED)
(
    __in_opt    HANDLE      hDot11SvcHandle,
                BOOL        bExcludeUnencrypted
);




typedef
DWORD
(WINAPI *DOT11EXT_NIC_SPECIFIC_EXTENSION)
(
    __in_opt                                                    HANDLE      hDot11SvcHandle,
                                                                DWORD       dwInBufferSize,
    __in_bcount(dwInBufferSize)                                 LPVOID      pvInBuffer,
    __inout                                                     DWORD*      pdwOutBufferSize,
    __out_bcount_part_opt(*pdwOutBufferSize, *pdwOutBufferSize) LPVOID      pvOutBuffer
);


/*
     IHV should allocate EAP attributes using DOT11EXT_ALLOCATE_BUFFER
     The IHV framework will free them.                      
*/

typedef
DWORD
(WINAPI *DOT11EXT_ONEX_START)
(
    __in_opt    HANDLE              hDot11SvcHandle,
    __in_opt    EAP_ATTRIBUTES*     pEapAttributes
);



typedef
DWORD
(WINAPI *DOT11EXT_ONEX_STOP)
(
    __in_opt    HANDLE  hDot11SvcHandle
);



typedef
DWORD
(WINAPI *DOT11EXT_PROCESS_ONEX_PACKET)
(
    __in_opt                    HANDLE      hDot11SvcHandle,
                                DWORD       dwInPacketSize,
    __in_bcount(dwInPacketSize) LPVOID      pvInPacket
);


//
// APIs to control Virtual Station.
//

typedef
DWORD
(WINAPI *DOT11EXT_REQUEST_VIRTUAL_STATION)
(
    __in_opt    HANDLE  hDot11PrimaryHandle,
    __reserved  LPVOID  pvReserved
);


typedef
DWORD
(WINAPI *DOT11EXT_RELEASE_VIRTUAL_STATION)
(
    __in_opt    HANDLE  hDot11PrimaryHandle,
    __reserved  LPVOID  pvReserved
);



typedef
DWORD
(WINAPI *DOT11EXT_QUERY_VIRTUAL_STATION_PROPERTIES)
(
    __in_opt    HANDLE  hDot11SvcHandle,
    __out       BOOL*   pbIsVirtualStation,
    __out       GUID*   pgPrimary,
    __reserved  LPVOID  pvReserved
);



typedef
DWORD
(WINAPI *DOT11EXT_SET_VIRTUAL_STATION_AP_PROPERTIES)
(
    __in_opt                        HANDLE                                  hDot11SvcHandle,
    __in_opt                        HANDLE                                  hConnectSession,
                                    DWORD                                   dwNumProperties,
    __in_ecount(dwNumProperties)    PDOT11EXT_VIRTUAL_STATION_AP_PROPERTY   pProperties,
    __reserved                      LPVOID                                  pvReserved
);



#define  IHV_VERSION_FUNCTION_NAME  "Dot11ExtIhvGetVersionInfo"
#define  IHV_INIT_FUNCTION_NAME     "Dot11ExtIhvInitService"
#define  IHV_INIT_VS_FUNCTION_NAME  "Dot11ExtIhvInitVirtualStation"




typedef
DWORD
(WINAPI *DOT11EXTIHV_GET_VERSION_INFO)
(
    __out   PDOT11_IHV_VERSION_INFO     pDot11IHVVersionInfo
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_INIT_SERVICE)
(
                DWORD                      dwVerNumUsed,
    __in        PDOT11EXT_APIS             pDot11ExtAPI,
    __reserved  LPVOID                     pvReserved,
    __out       PDOT11EXT_IHV_HANDLERS     pDot11IHVHandlers
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_INIT_VIRTUAL_STATION)
(
    __in        PDOT11EXT_VIRTUAL_STATION_APIS      pDot11ExtVSAPI,
    __reserved  LPVOID                              pvReserved
);




typedef
VOID
(WINAPI *DOT11EXTIHV_DEINIT_SERVICE)
(
    VOID
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_INIT_ADAPTER)
(
    __in        PDOT11_ADAPTER    pDot11Adapter,
    __in_opt    HANDLE            hDot11SvcHandle,
    __out       PHANDLE           phIhvExtAdapter
);




typedef
VOID
(WINAPI *DOT11EXTIHV_DEINIT_ADAPTER)
(
    __in_opt    HANDLE      hIhvExtAdapter
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_PERFORM_PRE_ASSOCIATE)
(
    __in_opt    HANDLE                                 hIhvExtAdapter,
    __in_opt    HANDLE                                 hConnectSession,
    __in_opt    PDOT11EXT_IHV_PROFILE_PARAMS           pIhvProfileParams,
    __in        PDOT11EXT_IHV_CONNECTIVITY_PROFILE     pIhvConnProfile,
    __in        PDOT11EXT_IHV_SECURITY_PROFILE         pIhvSecProfile,
    __in        PDOT11_BSS_LIST                        pConnectableBssid,
    __out       PDWORD                                 pdwReasonCode
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_ADAPTER_RESET)
(
    __in_opt    HANDLE      hIhvExtAdapter
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_PERFORM_POST_ASSOCIATE)
(
    __in_opt                            HANDLE                                      hIhvExtAdapter,
    __in_opt                            HANDLE                                      hSecuritySessionID,
    __in                                PDOT11_PORT_STATE                           pPortState,
                                        ULONG                                       uDot11AssocParamsBytes,
    __in_bcount(uDot11AssocParamsBytes) PDOT11_ASSOCIATION_COMPLETION_PARAMETERS    pDot11AssocParams
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_STOP_POST_ASSOCIATE)
(
    __in_opt    HANDLE                  hIhvExtAdapter,
    __in        PDOT11_MAC_ADDRESS      pPeer,
                DOT11_ASSOC_STATUS      dot11AssocStatus
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_VALIDATE_PROFILE)
(
    __in_opt    HANDLE                              hIhvExtAdapter,
    __in_opt    PDOT11EXT_IHV_PROFILE_PARAMS        pIhvProfileParams,
    __in        PDOT11EXT_IHV_CONNECTIVITY_PROFILE  pIhvConnProfile,
    __in        PDOT11EXT_IHV_SECURITY_PROFILE      pIhvSecProfile,
    __out       PDWORD                              pdwReasonCode
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_PERFORM_CAPABILITY_MATCH)
(
    __in_opt    HANDLE                              hIhvExtAdapter,
    __in_opt    PDOT11EXT_IHV_PROFILE_PARAMS        pIhvProfileParams,
    __in        PDOT11EXT_IHV_CONNECTIVITY_PROFILE  pIhvConnProfile,
    __in        PDOT11EXT_IHV_SECURITY_PROFILE      pIhvSecProfile,
    __in_opt    PDOT11_BSS_LIST                     pConnectableBssid,
    __out       PDWORD                              pdwReasonCode
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_CREATE_DISCOVERY_PROFILES)
(
    __in_opt    HANDLE                                  hIhvExtAdapter,
                BOOL                                    bInsecure,
    __in_opt    PDOT11EXT_IHV_PROFILE_PARAMS            pIhvProfileParams,
    __in_opt    PDOT11_BSS_LIST                         pConnectableBssid,
    __out       PDOT11EXT_IHV_DISCOVERY_PROFILE_LIST    pIhvDiscoveryProfileList,
    __out       PDWORD                                  pdwReasonCode
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_PROCESS_SESSION_CHANGE)
(
            ULONG                         uEventType,
    __in    PWTSSESSION_NOTIFICATION      pSessionNotification
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_RECEIVE_INDICATION)
(
    __in_opt                        HANDLE                          hIhvExtAdapter,
                                    DOT11EXT_IHV_INDICATION_TYPE    indicationType,
                                    ULONG                           uBufferLength,
    __in_bcount_opt(uBufferLength)  LPVOID                          pvBuffer
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_RECEIVE_PACKET)
(
    __in_opt                    HANDLE   hIhvExtAdapter,
                                DWORD    dwInBufferSize,
    __in_bcount(dwInBufferSize) LPVOID   pvInBuffer
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_SEND_PACKET_COMPLETION)
(
    __in_opt    HANDLE  hSendCompletion
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_IS_UI_REQUEST_PENDING)
(
            GUID    guidUIRequest,
    __out   PBOOL   pbIsRequestPending
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_PROCESS_UI_RESPONSE)
(
                                    GUID        guidUIRequest,
                                    DWORD       dwByteCount,
    __in_bcount_opt(dwByteCount)    LPVOID      pvResponseBuffer
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_QUERY_UI_REQUEST)
(
    __in_opt        HANDLE                          hIhvExtAdapter,
                    DOT11EXT_IHV_CONNECTION_PHASE   connectionPhase,
    __deref_out     PDOT11EXT_IHV_UI_REQUEST*       ppIhvUIRequest
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_ONEX_INDICATE_RESULT)
(
    __in_opt    HANDLE                          hIhvExtAdapter,
                DOT11_MSONEX_RESULT             msOneXResult,
    __in_opt    PDOT11_MSONEX_RESULT_PARAMS     pDot11MsOneXResultParams
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_CONTROL)
(
    __in_opt                                                    HANDLE    hIhvExtAdapter,
                                                                DWORD     dwInBufferSize,
    __in_bcount_opt(dwInBufferSize)                             PBYTE     pInBuffer,
                                                                DWORD     dwOutBufferSize,
    __out_bcount_part_opt(dwOutBufferSize,*pdwBytesReturned)    PBYTE     pOutBuffer,
    __out                                                       PDWORD    pdwBytesReturned
);


struct _DOT11EXT_APIS
{
   DOT11EXT_ALLOCATE_BUFFER                     Dot11ExtAllocateBuffer;
   DOT11EXT_FREE_BUFFER                         Dot11ExtFreeBuffer;
   DOT11EXT_SET_PROFILE_CUSTOM_USER_DATA        Dot11ExtSetProfileCustomUserData;
   DOT11EXT_GET_PROFILE_CUSTOM_USER_DATA        Dot11ExtGetProfileCustomUserData;
   DOT11EXT_SET_CURRENT_PROFILE                 Dot11ExtSetCurrentProfile;
   DOT11EXT_SEND_UI_REQUEST                     Dot11ExtSendUIRequest;
   DOT11EXT_PRE_ASSOCIATE_COMPLETION            Dot11ExtPreAssociateCompletion;
   DOT11EXT_POST_ASSOCIATE_COMPLETION           Dot11ExtPostAssociateCompletion;
   DOT11EXT_SEND_NOTIFICATION                   Dot11ExtSendNotification;
   DOT11EXT_SEND_PACKET                         Dot11ExtSendPacket;
   DOT11EXT_SET_ETHERTYPE_HANDLING              Dot11ExtSetEtherTypeHandling;
   DOT11EXT_SET_AUTH_ALGORITHM                  Dot11ExtSetAuthAlgorithm;
   DOT11EXT_SET_UNICAST_CIPHER_ALGORITHM        Dot11ExtSetUnicastCipherAlgorithm;
   DOT11EXT_SET_MULTICAST_CIPHER_ALGORITHM      Dot11ExtSetMulticastCipherAlgorithm;
   DOT11EXT_SET_DEFAULT_KEY                     Dot11ExtSetDefaultKey;
   DOT11EXT_SET_KEY_MAPPING_KEY                 Dot11ExtSetKeyMappingKey;
   DOT11EXT_SET_DEFAULT_KEY_ID                  Dot11ExtSetDefaultKeyId;
   DOT11EXT_NIC_SPECIFIC_EXTENSION              Dot11ExtNicSpecificExtension;
   DOT11EXT_SET_EXCLUDE_UNENCRYPTED             Dot11ExtSetExcludeUnencrypted;
   DOT11EXT_ONEX_START                          Dot11ExtStartOneX;
   DOT11EXT_ONEX_STOP                           Dot11ExtStopOneX;
   DOT11EXT_PROCESS_ONEX_PACKET                 Dot11ExtProcessSecurityPacket;
};




struct _DOT11EXT_IHV_HANDLERS
{
   DOT11EXTIHV_DEINIT_SERVICE                   Dot11ExtIhvDeinitService;
   DOT11EXTIHV_INIT_ADAPTER                     Dot11ExtIhvInitAdapter;
   DOT11EXTIHV_DEINIT_ADAPTER                   Dot11ExtIhvDeinitAdapter;
   DOT11EXTIHV_PERFORM_PRE_ASSOCIATE            Dot11ExtIhvPerformPreAssociate;
   DOT11EXTIHV_ADAPTER_RESET                    Dot11ExtIhvAdapterReset;
   DOT11EXTIHV_PERFORM_POST_ASSOCIATE           Dot11ExtIhvPerformPostAssociate;
   DOT11EXTIHV_STOP_POST_ASSOCIATE              Dot11ExtIhvStopPostAssociate;
   DOT11EXTIHV_VALIDATE_PROFILE                 Dot11ExtIhvValidateProfile;
   DOT11EXTIHV_PERFORM_CAPABILITY_MATCH         Dot11ExtIhvPerformCapabilityMatch;
   DOT11EXTIHV_CREATE_DISCOVERY_PROFILES        Dot11ExtIhvCreateDiscoveryProfiles;
   DOT11EXTIHV_PROCESS_SESSION_CHANGE           Dot11ExtIhvProcessSessionChange;
   DOT11EXTIHV_RECEIVE_INDICATION               Dot11ExtIhvReceiveIndication;
   DOT11EXTIHV_RECEIVE_PACKET                   Dot11ExtIhvReceivePacket;
   DOT11EXTIHV_SEND_PACKET_COMPLETION           Dot11ExtIhvSendPacketCompletion;
   DOT11EXTIHV_IS_UI_REQUEST_PENDING            Dot11ExtIhvIsUIRequestPending;
   DOT11EXTIHV_PROCESS_UI_RESPONSE              Dot11ExtIhvProcessUIResponse;
   DOT11EXTIHV_QUERY_UI_REQUEST                 Dot11ExtIhvQueryUIRequest;
   DOT11EXTIHV_ONEX_INDICATE_RESULT             Dot11ExtIhvOnexIndicateResult;
   DOT11EXTIHV_CONTROL                          Dot11ExtIhvControl;
};


struct _DOT11EXT_VIRTUAL_STATION_APIS
{
    DOT11EXT_REQUEST_VIRTUAL_STATION                Dot11ExtRequestVirtualStation;
    DOT11EXT_RELEASE_VIRTUAL_STATION                Dot11ExtReleaseVirtualStation;
    DOT11EXT_QUERY_VIRTUAL_STATION_PROPERTIES       Dot11ExtQueryVirtualStationProperties;
    DOT11EXT_SET_VIRTUAL_STATION_AP_PROPERTIES      Dot11ExtSetVirtualStationAPProperties;
};


#endif // __WLAN_IHV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WinUser.Inl ===
/* Copyright (c) 2001-2009, Microsoft Corp. All rights reserved. */

#if _MSC_VER > 1000
#pragma once
#endif

#if defined(__cplusplus)
extern "C" {
#endif


#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)


#if !defined(ISOLATION_AWARE_USE_STATIC_LIBRARY)
#define ISOLATION_AWARE_USE_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_BUILD_STATIC_LIBRARY)
#define ISOLATION_AWARE_BUILD_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_INLINE)
#if ISOLATION_AWARE_BUILD_STATIC_LIBRARY
#define ISOLATION_AWARE_INLINE /* nothing */
#else
#if defined(__cplusplus)
#define ISOLATION_AWARE_INLINE inline
#else
#define ISOLATION_AWARE_INLINE __inline
#endif
#endif
#endif

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */
ATOM IsolationAwarePrivatenCv IsolationAwareRegisterClassA(__in const WNDCLASSA*lpWndClass);
ATOM IsolationAwarePrivatenCv IsolationAwareRegisterClassW(__in const WNDCLASSW*lpWndClass);
BOOL IsolationAwarePrivatenCv IsolationAwareUnregisterClassA(__in LPCSTR lpClassName,__in_opt HINSTANCE hInstance);
BOOL IsolationAwarePrivatenCv IsolationAwareUnregisterClassW(__in LPCWSTR lpClassName,__in_opt HINSTANCE hInstance);
BOOL IsolationAwarePrivatenCv IsolationAwareGetClassInfoA(__in_opt HINSTANCE hInstance,__in LPCSTR lpClassName,__out LPWNDCLASSA lpWndClass);
BOOL IsolationAwarePrivatenCv IsolationAwareGetClassInfoW(__in_opt HINSTANCE hInstance,__in LPCWSTR lpClassName,__out LPWNDCLASSW lpWndClass);
ATOM IsolationAwarePrivatenCv IsolationAwareRegisterClassExA(__in const WNDCLASSEXA*unnamed1);
ATOM IsolationAwarePrivatenCv IsolationAwareRegisterClassExW(__in const WNDCLASSEXW*unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwareGetClassInfoExA(__in_opt HINSTANCE hInstance,__in LPCSTR lpszClass,__out LPWNDCLASSEXA lpwcx);
BOOL IsolationAwarePrivatenCv IsolationAwareGetClassInfoExW(__in_opt HINSTANCE hInstance,__in LPCWSTR lpszClass,__out LPWNDCLASSEXW lpwcx);
HWND IsolationAwarePrivatenCv IsolationAwareCreateWindowExA(__in DWORD dwExStyle,__in_opt LPCSTR lpClassName,__in_opt LPCSTR lpWindowName,__in DWORD dwStyle,__in int X,__in int Y,__in int nWidth,__in int nHeight,__in_opt HWND hWndParent,__in_opt HMENU hMenu,__in_opt HINSTANCE hInstance,__in_opt LPVOID lpParam);
HWND IsolationAwarePrivatenCv IsolationAwareCreateWindowExW(__in DWORD dwExStyle,__in_opt LPCWSTR lpClassName,__in_opt LPCWSTR lpWindowName,__in DWORD dwStyle,__in int X,__in int Y,__in int nWidth,__in int nHeight,__in_opt HWND hWndParent,__in_opt HMENU hMenu,__in_opt HINSTANCE hInstance,__in_opt LPVOID lpParam);
HWND IsolationAwarePrivatenCv IsolationAwareCreateDialogParamA(__in_opt HINSTANCE hInstance,__in LPCSTR lpTemplateName,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam);
HWND IsolationAwarePrivatenCv IsolationAwareCreateDialogParamW(__in_opt HINSTANCE hInstance,__in LPCWSTR lpTemplateName,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam);
HWND IsolationAwarePrivatenCv IsolationAwareCreateDialogIndirectParamA(__in_opt HINSTANCE hInstance,__in LPCDLGTEMPLATEA lpTemplate,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam);
HWND IsolationAwarePrivatenCv IsolationAwareCreateDialogIndirectParamW(__in_opt HINSTANCE hInstance,__in LPCDLGTEMPLATEW lpTemplate,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam);
INT_PTR IsolationAwarePrivatenCv IsolationAwareDialogBoxParamA(__in_opt HINSTANCE hInstance,__in LPCSTR lpTemplateName,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam);
INT_PTR IsolationAwarePrivatenCv IsolationAwareDialogBoxParamW(__in_opt HINSTANCE hInstance,__in LPCWSTR lpTemplateName,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam);
INT_PTR IsolationAwarePrivatenCv IsolationAwareDialogBoxIndirectParamA(__in_opt HINSTANCE hInstance,__in LPCDLGTEMPLATEA hDialogTemplate,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam);
INT_PTR IsolationAwarePrivatenCv IsolationAwareDialogBoxIndirectParamW(__in_opt HINSTANCE hInstance,__in LPCDLGTEMPLATEW hDialogTemplate,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam);
int IsolationAwarePrivatenCv IsolationAwareMessageBoxA(__in_opt HWND hWnd,__in_opt LPCSTR lpText,__in_opt LPCSTR lpCaption,__in UINT uType);
int IsolationAwarePrivatenCv IsolationAwareMessageBoxW(__in_opt HWND hWnd,__in_opt LPCWSTR lpText,__in_opt LPCWSTR lpCaption,__in UINT uType);
int IsolationAwarePrivatenCv IsolationAwareMessageBoxExA(__in_opt HWND hWnd,__in_opt LPCSTR lpText,__in_opt LPCSTR lpCaption,__in UINT uType,__in WORD wLanguageId);
int IsolationAwarePrivatenCv IsolationAwareMessageBoxExW(__in_opt HWND hWnd,__in_opt LPCWSTR lpText,__in_opt LPCWSTR lpCaption,__in UINT uType,__in WORD wLanguageId);
int IsolationAwarePrivatenCv IsolationAwareMessageBoxIndirectA(__in const MSGBOXPARAMSA*lpmbp);
int IsolationAwarePrivatenCv IsolationAwareMessageBoxIndirectW(__in const MSGBOXPARAMSW*lpmbp);

#if defined(UNICODE)

#define IsolationAwareCreateDialogIndirectParam IsolationAwareCreateDialogIndirectParamW
#define IsolationAwareCreateDialogParam IsolationAwareCreateDialogParamW
#define IsolationAwareCreateWindowEx IsolationAwareCreateWindowExW
#define IsolationAwareDialogBoxIndirectParam IsolationAwareDialogBoxIndirectParamW
#define IsolationAwareDialogBoxParam IsolationAwareDialogBoxParamW
#define IsolationAwareGetClassInfo IsolationAwareGetClassInfoW
#define IsolationAwareGetClassInfoEx IsolationAwareGetClassInfoExW
#define IsolationAwareMessageBox IsolationAwareMessageBoxW
#define IsolationAwareMessageBoxEx IsolationAwareMessageBoxExW
#define IsolationAwareMessageBoxIndirect IsolationAwareMessageBoxIndirectW
#define IsolationAwareRegisterClass IsolationAwareRegisterClassW
#define IsolationAwareRegisterClassEx IsolationAwareRegisterClassExW
#define IsolationAwareUnregisterClass IsolationAwareUnregisterClassW

#else /* UNICODE */

#define IsolationAwareCreateDialogIndirectParam IsolationAwareCreateDialogIndirectParamA
#define IsolationAwareCreateDialogParam IsolationAwareCreateDialogParamA
#define IsolationAwareCreateWindowEx IsolationAwareCreateWindowExA
#define IsolationAwareDialogBoxIndirectParam IsolationAwareDialogBoxIndirectParamA
#define IsolationAwareDialogBoxParam IsolationAwareDialogBoxParamA
#define IsolationAwareGetClassInfo IsolationAwareGetClassInfoA
#define IsolationAwareGetClassInfoEx IsolationAwareGetClassInfoExA
#define IsolationAwareMessageBox IsolationAwareMessageBoxA
#define IsolationAwareMessageBoxEx IsolationAwareMessageBoxExA
#define IsolationAwareMessageBoxIndirect IsolationAwareMessageBoxIndirectA
#define IsolationAwareRegisterClass IsolationAwareRegisterClassA
#define IsolationAwareRegisterClassEx IsolationAwareRegisterClassExA
#define IsolationAwareUnregisterClass IsolationAwareUnregisterClassA

#endif /* UNICODE */

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
ISOLATION_AWARE_INLINE ATOM IsolationAwarePrivatenCv IsolationAwareRegisterClassA(__in const WNDCLASSA*lpWndClass)
{
    ATOM result = 0 ;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        result = RegisterClassA(lpWndClass);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE ATOM IsolationAwarePrivatenCv IsolationAwareRegisterClassW(__in const WNDCLASSW*lpWndClass)
{
    ATOM result = 0 ;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        result = RegisterClassW(lpWndClass);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareUnregisterClassA(__in LPCSTR lpClassName,__in_opt HINSTANCE hInstance)
{
    BOOL fResult = FALSE;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        fResult = UnregisterClassA(lpClassName,hInstance);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareUnregisterClassW(__in LPCWSTR lpClassName,__in_opt HINSTANCE hInstance)
{
    BOOL fResult = FALSE;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        fResult = UnregisterClassW(lpClassName,hInstance);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareGetClassInfoA(__in_opt HINSTANCE hInstance,__in LPCSTR lpClassName,__out LPWNDCLASSA lpWndClass)
{
    BOOL fResult = FALSE;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        fResult = GetClassInfoA(hInstance,lpClassName,lpWndClass);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareGetClassInfoW(__in_opt HINSTANCE hInstance,__in LPCWSTR lpClassName,__out LPWNDCLASSW lpWndClass)
{
    BOOL fResult = FALSE;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        fResult = GetClassInfoW(hInstance,lpClassName,lpWndClass);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE ATOM IsolationAwarePrivatenCv IsolationAwareRegisterClassExA(__in const WNDCLASSEXA*unnamed1)
{
    ATOM result = 0 ;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        result = RegisterClassExA(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE ATOM IsolationAwarePrivatenCv IsolationAwareRegisterClassExW(__in const WNDCLASSEXW*unnamed1)
{
    ATOM result = 0 ;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        result = RegisterClassExW(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareGetClassInfoExA(__in_opt HINSTANCE hInstance,__in LPCSTR lpszClass,__out LPWNDCLASSEXA lpwcx)
{
    BOOL fResult = FALSE;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        fResult = GetClassInfoExA(hInstance,lpszClass,lpwcx);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareGetClassInfoExW(__in_opt HINSTANCE hInstance,__in LPCWSTR lpszClass,__out LPWNDCLASSEXW lpwcx)
{
    BOOL fResult = FALSE;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        fResult = GetClassInfoExW(hInstance,lpszClass,lpwcx);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareCreateWindowExA(__in DWORD dwExStyle,__in_opt LPCSTR lpClassName,__in_opt LPCSTR lpWindowName,__in DWORD dwStyle,__in int X,__in int Y,__in int nWidth,__in int nHeight,__in_opt HWND hWndParent,__in_opt HMENU hMenu,__in_opt HINSTANCE hInstance,__in_opt LPVOID lpParam)
{
    HWND windowResult = NULL;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        windowResult = CreateWindowExA(dwExStyle,lpClassName,lpWindowName,dwStyle,X,Y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareCreateWindowExW(__in DWORD dwExStyle,__in_opt LPCWSTR lpClassName,__in_opt LPCWSTR lpWindowName,__in DWORD dwStyle,__in int X,__in int Y,__in int nWidth,__in int nHeight,__in_opt HWND hWndParent,__in_opt HMENU hMenu,__in_opt HINSTANCE hInstance,__in_opt LPVOID lpParam)
{
    HWND windowResult = NULL;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        windowResult = CreateWindowExW(dwExStyle,lpClassName,lpWindowName,dwStyle,X,Y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareCreateDialogParamA(__in_opt HINSTANCE hInstance,__in LPCSTR lpTemplateName,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam)
{
    HWND windowResult = NULL;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        windowResult = CreateDialogParamA(hInstance,lpTemplateName,hWndParent,lpDialogFunc,dwInitParam);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareCreateDialogParamW(__in_opt HINSTANCE hInstance,__in LPCWSTR lpTemplateName,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam)
{
    HWND windowResult = NULL;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        windowResult = CreateDialogParamW(hInstance,lpTemplateName,hWndParent,lpDialogFunc,dwInitParam);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareCreateDialogIndirectParamA(__in_opt HINSTANCE hInstance,__in LPCDLGTEMPLATEA lpTemplate,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam)
{
    HWND windowResult = NULL;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        windowResult = CreateDialogIndirectParamA(hInstance,lpTemplate,hWndParent,lpDialogFunc,dwInitParam);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareCreateDialogIndirectParamW(__in_opt HINSTANCE hInstance,__in LPCDLGTEMPLATEW lpTemplate,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam)
{
    HWND windowResult = NULL;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        windowResult = CreateDialogIndirectParamW(hInstance,lpTemplate,hWndParent,lpDialogFunc,dwInitParam);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE INT_PTR IsolationAwarePrivatenCv IsolationAwareDialogBoxParamA(__in_opt HINSTANCE hInstance,__in LPCSTR lpTemplateName,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam)
{
    INT_PTR nResult = -1;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        nResult = DialogBoxParamA(hInstance,lpTemplateName,hWndParent,lpDialogFunc,dwInitParam);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE INT_PTR IsolationAwarePrivatenCv IsolationAwareDialogBoxParamW(__in_opt HINSTANCE hInstance,__in LPCWSTR lpTemplateName,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam)
{
    INT_PTR nResult = -1;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        nResult = DialogBoxParamW(hInstance,lpTemplateName,hWndParent,lpDialogFunc,dwInitParam);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE INT_PTR IsolationAwarePrivatenCv IsolationAwareDialogBoxIndirectParamA(__in_opt HINSTANCE hInstance,__in LPCDLGTEMPLATEA hDialogTemplate,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam)
{
    INT_PTR nResult = -1;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        nResult = DialogBoxIndirectParamA(hInstance,hDialogTemplate,hWndParent,lpDialogFunc,dwInitParam);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE INT_PTR IsolationAwarePrivatenCv IsolationAwareDialogBoxIndirectParamW(__in_opt HINSTANCE hInstance,__in LPCDLGTEMPLATEW hDialogTemplate,__in_opt HWND hWndParent,__in_opt DLGPROC lpDialogFunc,__in LPARAM dwInitParam)
{
    INT_PTR nResult = -1;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        nResult = DialogBoxIndirectParamW(hInstance,hDialogTemplate,hWndParent,lpDialogFunc,dwInitParam);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareMessageBoxA(__in_opt HWND hWnd,__in_opt LPCSTR lpText,__in_opt LPCSTR lpCaption,__in UINT uType)
{
    int nResult = 0 ;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        nResult = MessageBoxA(hWnd,lpText,lpCaption,uType);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareMessageBoxW(__in_opt HWND hWnd,__in_opt LPCWSTR lpText,__in_opt LPCWSTR lpCaption,__in UINT uType)
{
    int nResult = 0 ;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        nResult = MessageBoxW(hWnd,lpText,lpCaption,uType);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareMessageBoxExA(__in_opt HWND hWnd,__in_opt LPCSTR lpText,__in_opt LPCSTR lpCaption,__in UINT uType,__in WORD wLanguageId)
{
    int nResult = 0 ;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        nResult = MessageBoxExA(hWnd,lpText,lpCaption,uType,wLanguageId);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareMessageBoxExW(__in_opt HWND hWnd,__in_opt LPCWSTR lpText,__in_opt LPCWSTR lpCaption,__in UINT uType,__in WORD wLanguageId)
{
    int nResult = 0 ;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        nResult = MessageBoxExW(hWnd,lpText,lpCaption,uType,wLanguageId);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareMessageBoxIndirectA(__in const MSGBOXPARAMSA*lpmbp)
{
    int nResult = 0 ;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        nResult = MessageBoxIndirectA(lpmbp);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareMessageBoxIndirectW(__in const MSGBOXPARAMSW*lpmbp)
{
    int nResult = 0 ;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        nResult = MessageBoxIndirectW(lpmbp);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE FARPROC IsolationAwarePrivatenCv WinuserIsolationAwarePrivatetRgCebPnQQeRff_HfReQP_QYY(LPCSTR pszProcName)
/* This function is shared by the other stubs in this header. */
{
    static HMODULE s_module;
    const static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB
        c = { IsolationAwarePrivatezlybNQyVOeNelJ, L"User32.dll"
#ifdef _M_IX86
             , IsolationAwarePrivatezlybNQyVOeNeln, "User32.dll"
#endif
    };
    static IsolationAwarePrivatezHGnoyr_zBqHyr_vAsB m;

    return IsolationAwarePrivatezltRgCebPnQQeRff(&c, &m, pszProcName);
}

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */

#define CreateDialogIndirectParamA IsolationAwareCreateDialogIndirectParamA
#define CreateDialogIndirectParamW IsolationAwareCreateDialogIndirectParamW
#define CreateDialogParamA IsolationAwareCreateDialogParamA
#define CreateDialogParamW IsolationAwareCreateDialogParamW
#define CreateWindowExA IsolationAwareCreateWindowExA
#define CreateWindowExW IsolationAwareCreateWindowExW
#define DialogBoxIndirectParamA IsolationAwareDialogBoxIndirectParamA
#define DialogBoxIndirectParamW IsolationAwareDialogBoxIndirectParamW
#define DialogBoxParamA IsolationAwareDialogBoxParamA
#define DialogBoxParamW IsolationAwareDialogBoxParamW
 /* GetClassInfoA skipped, as it is a popular C++ member function name. */
#define GetClassInfoExA IsolationAwareGetClassInfoExA
#define GetClassInfoExW IsolationAwareGetClassInfoExW
 /* GetClassInfoW skipped, as it is a popular C++ member function name. */
 /* MessageBoxA skipped, as it is a popular C++ member function name. */
#define MessageBoxExA IsolationAwareMessageBoxExA
#define MessageBoxExW IsolationAwareMessageBoxExW
#define MessageBoxIndirectA IsolationAwareMessageBoxIndirectA
#define MessageBoxIndirectW IsolationAwareMessageBoxIndirectW
 /* MessageBoxW skipped, as it is a popular C++ member function name. */
#define RegisterClassA IsolationAwareRegisterClassA
#define RegisterClassExA IsolationAwareRegisterClassExA
#define RegisterClassExW IsolationAwareRegisterClassExW
#define RegisterClassW IsolationAwareRegisterClassW
#define UnregisterClassA IsolationAwareUnregisterClassA
#define UnregisterClassW IsolationAwareUnregisterClassW

#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */


#if defined(__cplusplus)
} /* __cplusplus */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\wmdm.h ===
EXTERN_C const CLSID CLSID_MediaDevMgr;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\wlantypes.h ===
/*++

    Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wlantypes.h

Abstract:

    Structures used to hold wlan information.

--*/

#ifndef __WLANTYPES_H__
#define __WLANTYPES_H__

typedef enum _DOT11_BSS_TYPE {
    dot11_BSS_type_infrastructure = 1,
    dot11_BSS_type_independent = 2,
    dot11_BSS_type_any = 3
} DOT11_BSS_TYPE, * PDOT11_BSS_TYPE;

#define DOT11_SSID_MAX_LENGTH   32      // 32 bytes
typedef struct _DOT11_SSID {
#ifndef __midl
    __range(0,32)
#endif
    ULONG uSSIDLength;
    UCHAR ucSSID[DOT11_SSID_MAX_LENGTH];
} DOT11_SSID, * PDOT11_SSID;


// DOT11_AUTH_ALGO_LIST
#ifdef __midl
// use the 4-byte enum
typedef [v1_enum] enum _DOT11_AUTH_ALGORITHM {
#else
typedef enum _DOT11_AUTH_ALGORITHM {
#endif
    DOT11_AUTH_ALGO_80211_OPEN = 1,
    DOT11_AUTH_ALGO_80211_SHARED_KEY = 2,
    DOT11_AUTH_ALGO_WPA = 3,
    DOT11_AUTH_ALGO_WPA_PSK = 4,
    DOT11_AUTH_ALGO_WPA_NONE = 5,               // used in NatSTA only
    DOT11_AUTH_ALGO_RSNA = 6,
    DOT11_AUTH_ALGO_RSNA_PSK = 7,
    DOT11_AUTH_ALGO_IHV_START = 0x80000000,
    DOT11_AUTH_ALGO_IHV_END = 0xffffffff
} DOT11_AUTH_ALGORITHM, * PDOT11_AUTH_ALGORITHM;

#define DOT11_AUTH_ALGORITHM_OPEN_SYSTEM        DOT11_AUTH_ALGO_80211_OPEN
#define DOT11_AUTH_ALGORITHM_SHARED_KEY         DOT11_AUTH_ALGO_80211_SHARED_KEY
#define DOT11_AUTH_ALGORITHM_WPA                DOT11_AUTH_ALGO_WPA
#define DOT11_AUTH_ALGORITHM_WPA_PSK            DOT11_AUTH_ALGO_WPA_PSK
#define DOT11_AUTH_ALGORITHM_WPA_NONE           DOT11_AUTH_ALGO_WPA_NONE
#define DOT11_AUTH_ALGORITHM_RSNA               DOT11_AUTH_ALGO_RSNA
#define DOT11_AUTH_ALGORITHM_RSNA_PSK           DOT11_AUTH_ALGO_RSNA_PSK

// Cipher algorithm Ids (for little endian platform)
#ifdef __midl
// use the 4-byte enum
typedef [v1_enum] enum _DOT11_CIPHER_ALGORITHM {
#else
typedef enum _DOT11_CIPHER_ALGORITHM {
#endif
    DOT11_CIPHER_ALGO_NONE = 0x00,
    DOT11_CIPHER_ALGO_WEP40 = 0x01,
    DOT11_CIPHER_ALGO_TKIP = 0x02,
    DOT11_CIPHER_ALGO_CCMP = 0x04,
    DOT11_CIPHER_ALGO_WEP104 = 0x05,
    DOT11_CIPHER_ALGO_WPA_USE_GROUP = 0x100,
    DOT11_CIPHER_ALGO_RSN_USE_GROUP = 0x100,
    DOT11_CIPHER_ALGO_WEP = 0x101,
    DOT11_CIPHER_ALGO_IHV_START = 0x80000000,
    DOT11_CIPHER_ALGO_IHV_END = 0xffffffff
} DOT11_CIPHER_ALGORITHM, * PDOT11_CIPHER_ALGORITHM;

typedef struct DOT11_AUTH_CIPHER_PAIR {
    DOT11_AUTH_ALGORITHM AuthAlgoId;
    DOT11_CIPHER_ALGORITHM CipherAlgoId;
} DOT11_AUTH_CIPHER_PAIR, * PDOT11_AUTH_CIPHER_PAIR;


#endif // __WLANTYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\wlanihvtypes.h ===
/*++

    Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wlanihvtypes.h

Abstract:

    Structures used to hold information for IHV.

--*/

#ifndef __WLANIHVTYPES_H__
#define __WLANIHVTYPES_H__

#include <EapTypes.h>
#include <WlanTypes.h>

// Select MS Security settings 
// as may be needed by the IHVs
typedef
struct _DOT11_MSSECURITY_SETTINGS
{
   DOT11_AUTH_ALGORITHM dot11AuthAlgorithm;
   DOT11_CIPHER_ALGORITHM dot11CipherAlgorithm;
   BOOL fOneXEnabled;
   EAP_METHOD_TYPE eapMethodType;
   DWORD dwEapConnectionDataLen;
#ifdef __midl
   [size_is(dwEapConnectionDataLen)] 
#endif
   BYTE* pEapConnectionData;
}
DOT11_MSSECURITY_SETTINGS, *PDOT11_MSSECURITY_SETTINGS;


typedef
struct _DOT11EXT_IHV_SSID_LIST
{
    ULONG                                   ulCount;
#ifdef __midl
    [unique, size_is(ulCount)] DOT11_SSID   SSIDs[*];
#else
    DOT11_SSID                              SSIDs[1];
#endif
}
DOT11EXT_IHV_SSID_LIST, * PDOT11EXT_IHV_SSID_LIST;


// Data structure to hold
// additional information regarding
// IHV profile.
typedef
struct _DOT11EXT_IHV_PROFILE_PARAMS
{
   PDOT11EXT_IHV_SSID_LIST      pSsidList;
   DOT11_BSS_TYPE               BssType;
   PDOT11_MSSECURITY_SETTINGS   pMSSecuritySettings;
}
DOT11EXT_IHV_PROFILE_PARAMS, *PDOT11EXT_IHV_PROFILE_PARAMS;

// the following shoud be the same as WLAN_MAX_NAME_LENGTH
#define MS_MAX_PROFILE_NAME_LENGTH 256

// profile flags
#define MS_PROFILE_GROUP_POLICY    0x00000001
#define MS_PROFILE_USER            0x00000002

// Data structure to hold
// all params passed to IHV
// for the UI extension
typedef
struct _DOT11EXT_IHV_PARAMS
{
   DOT11EXT_IHV_PROFILE_PARAMS  dot11ExtIhvProfileParams;
   WCHAR                        wstrProfileName[MS_MAX_PROFILE_NAME_LENGTH];
   DWORD                        dwProfileTypeFlags;
   GUID                         interfaceGuid;
}
DOT11EXT_IHV_PARAMS, *PDOT11EXT_IHV_PARAMS;


#endif // __WLANIHVTYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\wmcodecdsp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for wmcodecdsp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmcodecdsp_h__
#define __wmcodecdsp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMValidate_FWD_DEFINED__
#define __IWMValidate_FWD_DEFINED__
typedef interface IWMValidate IWMValidate;
#endif 	/* __IWMValidate_FWD_DEFINED__ */


#ifndef __IValidateBinding_FWD_DEFINED__
#define __IValidateBinding_FWD_DEFINED__
typedef interface IValidateBinding IValidateBinding;
#endif 	/* __IValidateBinding_FWD_DEFINED__ */


#ifndef __IWMVideoDecoderHurryup_FWD_DEFINED__
#define __IWMVideoDecoderHurryup_FWD_DEFINED__
typedef interface IWMVideoDecoderHurryup IWMVideoDecoderHurryup;
#endif 	/* __IWMVideoDecoderHurryup_FWD_DEFINED__ */


#ifndef __IWMVideoForceKeyFrame_FWD_DEFINED__
#define __IWMVideoForceKeyFrame_FWD_DEFINED__
typedef interface IWMVideoForceKeyFrame IWMVideoForceKeyFrame;
#endif 	/* __IWMVideoForceKeyFrame_FWD_DEFINED__ */


#ifndef __IWMCodecStrings_FWD_DEFINED__
#define __IWMCodecStrings_FWD_DEFINED__
typedef interface IWMCodecStrings IWMCodecStrings;
#endif 	/* __IWMCodecStrings_FWD_DEFINED__ */


#ifndef __IWMCodecProps_FWD_DEFINED__
#define __IWMCodecProps_FWD_DEFINED__
typedef interface IWMCodecProps IWMCodecProps;
#endif 	/* __IWMCodecProps_FWD_DEFINED__ */


#ifndef __IWMCodecLeakyBucket_FWD_DEFINED__
#define __IWMCodecLeakyBucket_FWD_DEFINED__
typedef interface IWMCodecLeakyBucket IWMCodecLeakyBucket;
#endif 	/* __IWMCodecLeakyBucket_FWD_DEFINED__ */


#ifndef __IWMCodecOutputTimestamp_FWD_DEFINED__
#define __IWMCodecOutputTimestamp_FWD_DEFINED__
typedef interface IWMCodecOutputTimestamp IWMCodecOutputTimestamp;
#endif 	/* __IWMCodecOutputTimestamp_FWD_DEFINED__ */


#ifndef __IWMVideoDecoderReconBuffer_FWD_DEFINED__
#define __IWMVideoDecoderReconBuffer_FWD_DEFINED__
typedef interface IWMVideoDecoderReconBuffer IWMVideoDecoderReconBuffer;
#endif 	/* __IWMVideoDecoderReconBuffer_FWD_DEFINED__ */


#ifndef __IWMCodecPrivateData_FWD_DEFINED__
#define __IWMCodecPrivateData_FWD_DEFINED__
typedef interface IWMCodecPrivateData IWMCodecPrivateData;
#endif 	/* __IWMCodecPrivateData_FWD_DEFINED__ */


#ifndef __IWMSampleExtensionSupport_FWD_DEFINED__
#define __IWMSampleExtensionSupport_FWD_DEFINED__
typedef interface IWMSampleExtensionSupport IWMSampleExtensionSupport;
#endif 	/* __IWMSampleExtensionSupport_FWD_DEFINED__ */


#ifndef __IWMResamplerProps_FWD_DEFINED__
#define __IWMResamplerProps_FWD_DEFINED__
typedef interface IWMResamplerProps IWMResamplerProps;
#endif 	/* __IWMResamplerProps_FWD_DEFINED__ */


#ifndef __IWMResizerProps_FWD_DEFINED__
#define __IWMResizerProps_FWD_DEFINED__
typedef interface IWMResizerProps IWMResizerProps;
#endif 	/* __IWMResizerProps_FWD_DEFINED__ */


#ifndef __IWMColorLegalizerProps_FWD_DEFINED__
#define __IWMColorLegalizerProps_FWD_DEFINED__
typedef interface IWMColorLegalizerProps IWMColorLegalizerProps;
#endif 	/* __IWMColorLegalizerProps_FWD_DEFINED__ */


#ifndef __IWMInterlaceProps_FWD_DEFINED__
#define __IWMInterlaceProps_FWD_DEFINED__
typedef interface IWMInterlaceProps IWMInterlaceProps;
#endif 	/* __IWMInterlaceProps_FWD_DEFINED__ */


#ifndef __IWMFrameInterpProps_FWD_DEFINED__
#define __IWMFrameInterpProps_FWD_DEFINED__
typedef interface IWMFrameInterpProps IWMFrameInterpProps;
#endif 	/* __IWMFrameInterpProps_FWD_DEFINED__ */


#ifndef __IWMColorConvProps_FWD_DEFINED__
#define __IWMColorConvProps_FWD_DEFINED__
typedef interface IWMColorConvProps IWMColorConvProps;
#endif 	/* __IWMColorConvProps_FWD_DEFINED__ */


#ifndef __ITocEntry_FWD_DEFINED__
#define __ITocEntry_FWD_DEFINED__
typedef interface ITocEntry ITocEntry;
#endif 	/* __ITocEntry_FWD_DEFINED__ */


#ifndef __ITocEntryList_FWD_DEFINED__
#define __ITocEntryList_FWD_DEFINED__
typedef interface ITocEntryList ITocEntryList;
#endif 	/* __ITocEntryList_FWD_DEFINED__ */


#ifndef __IToc_FWD_DEFINED__
#define __IToc_FWD_DEFINED__
typedef interface IToc IToc;
#endif 	/* __IToc_FWD_DEFINED__ */


#ifndef __ITocCollection_FWD_DEFINED__
#define __ITocCollection_FWD_DEFINED__
typedef interface ITocCollection ITocCollection;
#endif 	/* __ITocCollection_FWD_DEFINED__ */


#ifndef __ITocParser_FWD_DEFINED__
#define __ITocParser_FWD_DEFINED__
typedef interface ITocParser ITocParser;
#endif 	/* __ITocParser_FWD_DEFINED__ */


#ifndef __IFileIo_FWD_DEFINED__
#define __IFileIo_FWD_DEFINED__
typedef interface IFileIo IFileIo;
#endif 	/* __IFileIo_FWD_DEFINED__ */


#ifndef __IFileClient_FWD_DEFINED__
#define __IFileClient_FWD_DEFINED__
typedef interface IFileClient IFileClient;
#endif 	/* __IFileClient_FWD_DEFINED__ */


#ifndef __IClusterDetector_FWD_DEFINED__
#define __IClusterDetector_FWD_DEFINED__
typedef interface IClusterDetector IClusterDetector;
#endif 	/* __IClusterDetector_FWD_DEFINED__ */


#ifndef __CMpeg4DecMediaObject_FWD_DEFINED__
#define __CMpeg4DecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMpeg4DecMediaObject CMpeg4DecMediaObject;
#else
typedef struct CMpeg4DecMediaObject CMpeg4DecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CMpeg4DecMediaObject_FWD_DEFINED__ */


#ifndef __CMpeg43DecMediaObject_FWD_DEFINED__
#define __CMpeg43DecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMpeg43DecMediaObject CMpeg43DecMediaObject;
#else
typedef struct CMpeg43DecMediaObject CMpeg43DecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CMpeg43DecMediaObject_FWD_DEFINED__ */


#ifndef __CMpeg4sDecMediaObject_FWD_DEFINED__
#define __CMpeg4sDecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMpeg4sDecMediaObject CMpeg4sDecMediaObject;
#else
typedef struct CMpeg4sDecMediaObject CMpeg4sDecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CMpeg4sDecMediaObject_FWD_DEFINED__ */


#ifndef __CMpeg4sDecMFT_FWD_DEFINED__
#define __CMpeg4sDecMFT_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMpeg4sDecMFT CMpeg4sDecMFT;
#else
typedef struct CMpeg4sDecMFT CMpeg4sDecMFT;
#endif /* __cplusplus */

#endif 	/* __CMpeg4sDecMFT_FWD_DEFINED__ */


#ifndef __CZuneM4S2DecMediaObject_FWD_DEFINED__
#define __CZuneM4S2DecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CZuneM4S2DecMediaObject CZuneM4S2DecMediaObject;
#else
typedef struct CZuneM4S2DecMediaObject CZuneM4S2DecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CZuneM4S2DecMediaObject_FWD_DEFINED__ */


#ifndef __CMpeg4EncMediaObject_FWD_DEFINED__
#define __CMpeg4EncMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMpeg4EncMediaObject CMpeg4EncMediaObject;
#else
typedef struct CMpeg4EncMediaObject CMpeg4EncMediaObject;
#endif /* __cplusplus */

#endif 	/* __CMpeg4EncMediaObject_FWD_DEFINED__ */


#ifndef __CMpeg4sEncMediaObject_FWD_DEFINED__
#define __CMpeg4sEncMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMpeg4sEncMediaObject CMpeg4sEncMediaObject;
#else
typedef struct CMpeg4sEncMediaObject CMpeg4sEncMediaObject;
#endif /* __cplusplus */

#endif 	/* __CMpeg4sEncMediaObject_FWD_DEFINED__ */


#ifndef __CMSSCDecMediaObject_FWD_DEFINED__
#define __CMSSCDecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMSSCDecMediaObject CMSSCDecMediaObject;
#else
typedef struct CMSSCDecMediaObject CMSSCDecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CMSSCDecMediaObject_FWD_DEFINED__ */


#ifndef __CMSSCEncMediaObject_FWD_DEFINED__
#define __CMSSCEncMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMSSCEncMediaObject CMSSCEncMediaObject;
#else
typedef struct CMSSCEncMediaObject CMSSCEncMediaObject;
#endif /* __cplusplus */

#endif 	/* __CMSSCEncMediaObject_FWD_DEFINED__ */


#ifndef __CMSSCEncMediaObject2_FWD_DEFINED__
#define __CMSSCEncMediaObject2_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMSSCEncMediaObject2 CMSSCEncMediaObject2;
#else
typedef struct CMSSCEncMediaObject2 CMSSCEncMediaObject2;
#endif /* __cplusplus */

#endif 	/* __CMSSCEncMediaObject2_FWD_DEFINED__ */


#ifndef __CWMADecMediaObject_FWD_DEFINED__
#define __CWMADecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMADecMediaObject CWMADecMediaObject;
#else
typedef struct CWMADecMediaObject CWMADecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CWMADecMediaObject_FWD_DEFINED__ */


#ifndef __CWMAEncMediaObject_FWD_DEFINED__
#define __CWMAEncMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMAEncMediaObject CWMAEncMediaObject;
#else
typedef struct CWMAEncMediaObject CWMAEncMediaObject;
#endif /* __cplusplus */

#endif 	/* __CWMAEncMediaObject_FWD_DEFINED__ */


#ifndef __CWMATransMediaObject_FWD_DEFINED__
#define __CWMATransMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMATransMediaObject CWMATransMediaObject;
#else
typedef struct CWMATransMediaObject CWMATransMediaObject;
#endif /* __cplusplus */

#endif 	/* __CWMATransMediaObject_FWD_DEFINED__ */


#ifndef __CWMSPDecMediaObject_FWD_DEFINED__
#define __CWMSPDecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMSPDecMediaObject CWMSPDecMediaObject;
#else
typedef struct CWMSPDecMediaObject CWMSPDecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CWMSPDecMediaObject_FWD_DEFINED__ */


#ifndef __CWMSPEncMediaObject_FWD_DEFINED__
#define __CWMSPEncMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMSPEncMediaObject CWMSPEncMediaObject;
#else
typedef struct CWMSPEncMediaObject CWMSPEncMediaObject;
#endif /* __cplusplus */

#endif 	/* __CWMSPEncMediaObject_FWD_DEFINED__ */


#ifndef __CWMSPEncMediaObject2_FWD_DEFINED__
#define __CWMSPEncMediaObject2_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMSPEncMediaObject2 CWMSPEncMediaObject2;
#else
typedef struct CWMSPEncMediaObject2 CWMSPEncMediaObject2;
#endif /* __cplusplus */

#endif 	/* __CWMSPEncMediaObject2_FWD_DEFINED__ */


#ifndef __CWMTDecMediaObject_FWD_DEFINED__
#define __CWMTDecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMTDecMediaObject CWMTDecMediaObject;
#else
typedef struct CWMTDecMediaObject CWMTDecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CWMTDecMediaObject_FWD_DEFINED__ */


#ifndef __CWMTEncMediaObject_FWD_DEFINED__
#define __CWMTEncMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMTEncMediaObject CWMTEncMediaObject;
#else
typedef struct CWMTEncMediaObject CWMTEncMediaObject;
#endif /* __cplusplus */

#endif 	/* __CWMTEncMediaObject_FWD_DEFINED__ */


#ifndef __CWMVDecMediaObject_FWD_DEFINED__
#define __CWMVDecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMVDecMediaObject CWMVDecMediaObject;
#else
typedef struct CWMVDecMediaObject CWMVDecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CWMVDecMediaObject_FWD_DEFINED__ */


#ifndef __CWMVEncMediaObject2_FWD_DEFINED__
#define __CWMVEncMediaObject2_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMVEncMediaObject2 CWMVEncMediaObject2;
#else
typedef struct CWMVEncMediaObject2 CWMVEncMediaObject2;
#endif /* __cplusplus */

#endif 	/* __CWMVEncMediaObject2_FWD_DEFINED__ */


#ifndef __CWMVXEncMediaObject_FWD_DEFINED__
#define __CWMVXEncMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMVXEncMediaObject CWMVXEncMediaObject;
#else
typedef struct CWMVXEncMediaObject CWMVXEncMediaObject;
#endif /* __cplusplus */

#endif 	/* __CWMVXEncMediaObject_FWD_DEFINED__ */


#ifndef __CWMV9EncMediaObject_FWD_DEFINED__
#define __CWMV9EncMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMV9EncMediaObject CWMV9EncMediaObject;
#else
typedef struct CWMV9EncMediaObject CWMV9EncMediaObject;
#endif /* __cplusplus */

#endif 	/* __CWMV9EncMediaObject_FWD_DEFINED__ */


#ifndef __CWVC1DecMediaObject_FWD_DEFINED__
#define __CWVC1DecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWVC1DecMediaObject CWVC1DecMediaObject;
#else
typedef struct CWVC1DecMediaObject CWVC1DecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CWVC1DecMediaObject_FWD_DEFINED__ */


#ifndef __CWVC1EncMediaObject_FWD_DEFINED__
#define __CWVC1EncMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWVC1EncMediaObject CWVC1EncMediaObject;
#else
typedef struct CWVC1EncMediaObject CWVC1EncMediaObject;
#endif /* __cplusplus */

#endif 	/* __CWVC1EncMediaObject_FWD_DEFINED__ */


#ifndef __CDeColorConvMediaObject_FWD_DEFINED__
#define __CDeColorConvMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CDeColorConvMediaObject CDeColorConvMediaObject;
#else
typedef struct CDeColorConvMediaObject CDeColorConvMediaObject;
#endif /* __cplusplus */

#endif 	/* __CDeColorConvMediaObject_FWD_DEFINED__ */


#ifndef __CDVDecoderMediaObject_FWD_DEFINED__
#define __CDVDecoderMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CDVDecoderMediaObject CDVDecoderMediaObject;
#else
typedef struct CDVDecoderMediaObject CDVDecoderMediaObject;
#endif /* __cplusplus */

#endif 	/* __CDVDecoderMediaObject_FWD_DEFINED__ */


#ifndef __CDVEncoderMediaObject_FWD_DEFINED__
#define __CDVEncoderMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CDVEncoderMediaObject CDVEncoderMediaObject;
#else
typedef struct CDVEncoderMediaObject CDVEncoderMediaObject;
#endif /* __cplusplus */

#endif 	/* __CDVEncoderMediaObject_FWD_DEFINED__ */


#ifndef __CMpeg2DecMediaObject_FWD_DEFINED__
#define __CMpeg2DecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMpeg2DecMediaObject CMpeg2DecMediaObject;
#else
typedef struct CMpeg2DecMediaObject CMpeg2DecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CMpeg2DecMediaObject_FWD_DEFINED__ */


#ifndef __CPK_DS_MPEG2Decoder_FWD_DEFINED__
#define __CPK_DS_MPEG2Decoder_FWD_DEFINED__

#ifdef __cplusplus
typedef class CPK_DS_MPEG2Decoder CPK_DS_MPEG2Decoder;
#else
typedef struct CPK_DS_MPEG2Decoder CPK_DS_MPEG2Decoder;
#endif /* __cplusplus */

#endif 	/* __CPK_DS_MPEG2Decoder_FWD_DEFINED__ */


#ifndef __CAC3DecMediaObject_FWD_DEFINED__
#define __CAC3DecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CAC3DecMediaObject CAC3DecMediaObject;
#else
typedef struct CAC3DecMediaObject CAC3DecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CAC3DecMediaObject_FWD_DEFINED__ */


#ifndef __CPK_DS_AC3Decoder_FWD_DEFINED__
#define __CPK_DS_AC3Decoder_FWD_DEFINED__

#ifdef __cplusplus
typedef class CPK_DS_AC3Decoder CPK_DS_AC3Decoder;
#else
typedef struct CPK_DS_AC3Decoder CPK_DS_AC3Decoder;
#endif /* __cplusplus */

#endif 	/* __CPK_DS_AC3Decoder_FWD_DEFINED__ */


#ifndef __CMP3DecMediaObject_FWD_DEFINED__
#define __CMP3DecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMP3DecMediaObject CMP3DecMediaObject;
#else
typedef struct CMP3DecMediaObject CMP3DecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CMP3DecMediaObject_FWD_DEFINED__ */


#ifndef __CResamplerMediaObject_FWD_DEFINED__
#define __CResamplerMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CResamplerMediaObject CResamplerMediaObject;
#else
typedef struct CResamplerMediaObject CResamplerMediaObject;
#endif /* __cplusplus */

#endif 	/* __CResamplerMediaObject_FWD_DEFINED__ */


#ifndef __CResizerMediaObject_FWD_DEFINED__
#define __CResizerMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CResizerMediaObject CResizerMediaObject;
#else
typedef struct CResizerMediaObject CResizerMediaObject;
#endif /* __cplusplus */

#endif 	/* __CResizerMediaObject_FWD_DEFINED__ */


#ifndef __CInterlaceMediaObject_FWD_DEFINED__
#define __CInterlaceMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CInterlaceMediaObject CInterlaceMediaObject;
#else
typedef struct CInterlaceMediaObject CInterlaceMediaObject;
#endif /* __cplusplus */

#endif 	/* __CInterlaceMediaObject_FWD_DEFINED__ */


#ifndef __CWMAudioLFXAPO_FWD_DEFINED__
#define __CWMAudioLFXAPO_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMAudioLFXAPO CWMAudioLFXAPO;
#else
typedef struct CWMAudioLFXAPO CWMAudioLFXAPO;
#endif /* __cplusplus */

#endif 	/* __CWMAudioLFXAPO_FWD_DEFINED__ */


#ifndef __CWMAudioGFXAPO_FWD_DEFINED__
#define __CWMAudioGFXAPO_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMAudioGFXAPO CWMAudioGFXAPO;
#else
typedef struct CWMAudioGFXAPO CWMAudioGFXAPO;
#endif /* __cplusplus */

#endif 	/* __CWMAudioGFXAPO_FWD_DEFINED__ */


#ifndef __CWMAudioSpdTxDMO_FWD_DEFINED__
#define __CWMAudioSpdTxDMO_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMAudioSpdTxDMO CWMAudioSpdTxDMO;
#else
typedef struct CWMAudioSpdTxDMO CWMAudioSpdTxDMO;
#endif /* __cplusplus */

#endif 	/* __CWMAudioSpdTxDMO_FWD_DEFINED__ */


#ifndef __CWMAudioAEC_FWD_DEFINED__
#define __CWMAudioAEC_FWD_DEFINED__

#ifdef __cplusplus
typedef class CWMAudioAEC CWMAudioAEC;
#else
typedef struct CWMAudioAEC CWMAudioAEC;
#endif /* __cplusplus */

#endif 	/* __CWMAudioAEC_FWD_DEFINED__ */


#ifndef __CClusterDetectorDmo_FWD_DEFINED__
#define __CClusterDetectorDmo_FWD_DEFINED__

#ifdef __cplusplus
typedef class CClusterDetectorDmo CClusterDetectorDmo;
#else
typedef struct CClusterDetectorDmo CClusterDetectorDmo;
#endif /* __cplusplus */

#endif 	/* __CClusterDetectorDmo_FWD_DEFINED__ */


#ifndef __CColorControlDmo_FWD_DEFINED__
#define __CColorControlDmo_FWD_DEFINED__

#ifdef __cplusplus
typedef class CColorControlDmo CColorControlDmo;
#else
typedef struct CColorControlDmo CColorControlDmo;
#endif /* __cplusplus */

#endif 	/* __CColorControlDmo_FWD_DEFINED__ */


#ifndef __CColorConvertDMO_FWD_DEFINED__
#define __CColorConvertDMO_FWD_DEFINED__

#ifdef __cplusplus
typedef class CColorConvertDMO CColorConvertDMO;
#else
typedef struct CColorConvertDMO CColorConvertDMO;
#endif /* __cplusplus */

#endif 	/* __CColorConvertDMO_FWD_DEFINED__ */


#ifndef __CColorLegalizerDmo_FWD_DEFINED__
#define __CColorLegalizerDmo_FWD_DEFINED__

#ifdef __cplusplus
typedef class CColorLegalizerDmo CColorLegalizerDmo;
#else
typedef struct CColorLegalizerDmo CColorLegalizerDmo;
#endif /* __cplusplus */

#endif 	/* __CColorLegalizerDmo_FWD_DEFINED__ */


#ifndef __CFrameInterpDMO_FWD_DEFINED__
#define __CFrameInterpDMO_FWD_DEFINED__

#ifdef __cplusplus
typedef class CFrameInterpDMO CFrameInterpDMO;
#else
typedef struct CFrameInterpDMO CFrameInterpDMO;
#endif /* __cplusplus */

#endif 	/* __CFrameInterpDMO_FWD_DEFINED__ */


#ifndef __CFrameRateConvertDmo_FWD_DEFINED__
#define __CFrameRateConvertDmo_FWD_DEFINED__

#ifdef __cplusplus
typedef class CFrameRateConvertDmo CFrameRateConvertDmo;
#else
typedef struct CFrameRateConvertDmo CFrameRateConvertDmo;
#endif /* __cplusplus */

#endif 	/* __CFrameRateConvertDmo_FWD_DEFINED__ */


#ifndef __CResizerDMO_FWD_DEFINED__
#define __CResizerDMO_FWD_DEFINED__

#ifdef __cplusplus
typedef class CResizerDMO CResizerDMO;
#else
typedef struct CResizerDMO CResizerDMO;
#endif /* __cplusplus */

#endif 	/* __CResizerDMO_FWD_DEFINED__ */


#ifndef __CShotDetectorDmo_FWD_DEFINED__
#define __CShotDetectorDmo_FWD_DEFINED__

#ifdef __cplusplus
typedef class CShotDetectorDmo CShotDetectorDmo;
#else
typedef struct CShotDetectorDmo CShotDetectorDmo;
#endif /* __cplusplus */

#endif 	/* __CShotDetectorDmo_FWD_DEFINED__ */


#ifndef __CSmpteTransformsDmo_FWD_DEFINED__
#define __CSmpteTransformsDmo_FWD_DEFINED__

#ifdef __cplusplus
typedef class CSmpteTransformsDmo CSmpteTransformsDmo;
#else
typedef struct CSmpteTransformsDmo CSmpteTransformsDmo;
#endif /* __cplusplus */

#endif 	/* __CSmpteTransformsDmo_FWD_DEFINED__ */


#ifndef __CThumbnailGeneratorDmo_FWD_DEFINED__
#define __CThumbnailGeneratorDmo_FWD_DEFINED__

#ifdef __cplusplus
typedef class CThumbnailGeneratorDmo CThumbnailGeneratorDmo;
#else
typedef struct CThumbnailGeneratorDmo CThumbnailGeneratorDmo;
#endif /* __cplusplus */

#endif 	/* __CThumbnailGeneratorDmo_FWD_DEFINED__ */


#ifndef __CTocGeneratorDmo_FWD_DEFINED__
#define __CTocGeneratorDmo_FWD_DEFINED__

#ifdef __cplusplus
typedef class CTocGeneratorDmo CTocGeneratorDmo;
#else
typedef struct CTocGeneratorDmo CTocGeneratorDmo;
#endif /* __cplusplus */

#endif 	/* __CTocGeneratorDmo_FWD_DEFINED__ */


#ifndef __CMPEGAACDecMediaObject_FWD_DEFINED__
#define __CMPEGAACDecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMPEGAACDecMediaObject CMPEGAACDecMediaObject;
#else
typedef struct CMPEGAACDecMediaObject CMPEGAACDecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CMPEGAACDecMediaObject_FWD_DEFINED__ */


#ifndef __CNokiaAACDecMediaObject_FWD_DEFINED__
#define __CNokiaAACDecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CNokiaAACDecMediaObject CNokiaAACDecMediaObject;
#else
typedef struct CNokiaAACDecMediaObject CNokiaAACDecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CNokiaAACDecMediaObject_FWD_DEFINED__ */


#ifndef __CVodafoneAACDecMediaObject_FWD_DEFINED__
#define __CVodafoneAACDecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CVodafoneAACDecMediaObject CVodafoneAACDecMediaObject;
#else
typedef struct CVodafoneAACDecMediaObject CVodafoneAACDecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CVodafoneAACDecMediaObject_FWD_DEFINED__ */


#ifndef __CZuneAACCCDecMediaObject_FWD_DEFINED__
#define __CZuneAACCCDecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CZuneAACCCDecMediaObject CZuneAACCCDecMediaObject;
#else
typedef struct CZuneAACCCDecMediaObject CZuneAACCCDecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CZuneAACCCDecMediaObject_FWD_DEFINED__ */


#ifndef __CNokiaAACCCDecMediaObject_FWD_DEFINED__
#define __CNokiaAACCCDecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CNokiaAACCCDecMediaObject CNokiaAACCCDecMediaObject;
#else
typedef struct CNokiaAACCCDecMediaObject CNokiaAACCCDecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CNokiaAACCCDecMediaObject_FWD_DEFINED__ */


#ifndef __CVodafoneAACCCDecMediaObject_FWD_DEFINED__
#define __CVodafoneAACCCDecMediaObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CVodafoneAACCCDecMediaObject CVodafoneAACCCDecMediaObject;
#else
typedef struct CVodafoneAACCCDecMediaObject CVodafoneAACCCDecMediaObject;
#endif /* __cplusplus */

#endif 	/* __CVodafoneAACCCDecMediaObject_FWD_DEFINED__ */


#ifndef __CMPEG2EncoderDS_FWD_DEFINED__
#define __CMPEG2EncoderDS_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMPEG2EncoderDS CMPEG2EncoderDS;
#else
typedef struct CMPEG2EncoderDS CMPEG2EncoderDS;
#endif /* __cplusplus */

#endif 	/* __CMPEG2EncoderDS_FWD_DEFINED__ */


#ifndef __CMPEG2EncoderVideoDS_FWD_DEFINED__
#define __CMPEG2EncoderVideoDS_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMPEG2EncoderVideoDS CMPEG2EncoderVideoDS;
#else
typedef struct CMPEG2EncoderVideoDS CMPEG2EncoderVideoDS;
#endif /* __cplusplus */

#endif 	/* __CMPEG2EncoderVideoDS_FWD_DEFINED__ */


#ifndef __CMPEG2EncoderAudioDS_FWD_DEFINED__
#define __CMPEG2EncoderAudioDS_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMPEG2EncoderAudioDS CMPEG2EncoderAudioDS;
#else
typedef struct CMPEG2EncoderAudioDS CMPEG2EncoderAudioDS;
#endif /* __cplusplus */

#endif 	/* __CMPEG2EncoderAudioDS_FWD_DEFINED__ */


#ifndef __CMPEG2AudDecoderDS_FWD_DEFINED__
#define __CMPEG2AudDecoderDS_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMPEG2AudDecoderDS CMPEG2AudDecoderDS;
#else
typedef struct CMPEG2AudDecoderDS CMPEG2AudDecoderDS;
#endif /* __cplusplus */

#endif 	/* __CMPEG2AudDecoderDS_FWD_DEFINED__ */


#ifndef __CMPEG2VidDecoderDS_FWD_DEFINED__
#define __CMPEG2VidDecoderDS_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMPEG2VidDecoderDS CMPEG2VidDecoderDS;
#else
typedef struct CMPEG2VidDecoderDS CMPEG2VidDecoderDS;
#endif /* __cplusplus */

#endif 	/* __CMPEG2VidDecoderDS_FWD_DEFINED__ */


#ifndef __CDTVAudDecoderDS_FWD_DEFINED__
#define __CDTVAudDecoderDS_FWD_DEFINED__

#ifdef __cplusplus
typedef class CDTVAudDecoderDS CDTVAudDecoderDS;
#else
typedef struct CDTVAudDecoderDS CDTVAudDecoderDS;
#endif /* __cplusplus */

#endif 	/* __CDTVAudDecoderDS_FWD_DEFINED__ */


#ifndef __CDTVVidDecoderDS_FWD_DEFINED__
#define __CDTVVidDecoderDS_FWD_DEFINED__

#ifdef __cplusplus
typedef class CDTVVidDecoderDS CDTVVidDecoderDS;
#else
typedef struct CDTVVidDecoderDS CDTVVidDecoderDS;
#endif /* __cplusplus */

#endif 	/* __CDTVVidDecoderDS_FWD_DEFINED__ */


#ifndef __CMSAC3Enc_FWD_DEFINED__
#define __CMSAC3Enc_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMSAC3Enc CMSAC3Enc;
#else
typedef struct CMSAC3Enc CMSAC3Enc;
#endif /* __cplusplus */

#endif 	/* __CMSAC3Enc_FWD_DEFINED__ */


#ifndef __CMSH264DecoderMFT_FWD_DEFINED__
#define __CMSH264DecoderMFT_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMSH264DecoderMFT CMSH264DecoderMFT;
#else
typedef struct CMSH264DecoderMFT CMSH264DecoderMFT;
#endif /* __cplusplus */

#endif 	/* __CMSH264DecoderMFT_FWD_DEFINED__ */


/* header files for imported files */
#include "mediaobj.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wmcodecdsp_0000_0000 */
/* [local] */ 

//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT ("EULA").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (C) Microsoft Corporation, 1999 - 1999  All Rights Reserved.
//
//=========================================================================
typedef 
enum WMT_PROP_DATATYPE
    {	WMT_PROP_TYPE_DWORD	= 0,
	WMT_PROP_TYPE_STRING	= 1,
	WMT_PROP_TYPE_BINARY	= 2,
	WMT_PROP_TYPE_BOOL	= 3,
	WMT_PROP_TYPE_QWORD	= 4,
	WMT_PROP_TYPE_WORD	= 5,
	WMT_PROP_TYPE_GUID	= 6
    } 	WMT_PROP_DATATYPE;



extern RPC_IF_HANDLE __MIDL_itf_wmcodecdsp_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcodecdsp_0000_0000_v0_0_s_ifspec;

#ifndef __IWMValidate_INTERFACE_DEFINED__
#define __IWMValidate_INTERFACE_DEFINED__

/* interface IWMValidate */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMValidate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CEE3DEF2-3808-414d-BE66-FAFD472210BC")
    IWMValidate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIdentifier( 
            /* [in] */ GUID guidValidationID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMValidateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWMValidate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWMValidate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWMValidate * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetIdentifier )( 
            __RPC__in IWMValidate * This,
            /* [in] */ GUID guidValidationID);
        
        END_INTERFACE
    } IWMValidateVtbl;

    interface IWMValidate
    {
        CONST_VTBL struct IWMValidateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMValidate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMValidate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMValidate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMValidate_SetIdentifier(This,guidValidationID)	\
    ( (This)->lpVtbl -> SetIdentifier(This,guidValidationID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMValidate_INTERFACE_DEFINED__ */


#ifndef __IValidateBinding_INTERFACE_DEFINED__
#define __IValidateBinding_INTERFACE_DEFINED__

/* interface IValidateBinding */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IValidateBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04A578B2-E778-422a-A805-B3EE54D90BD9")
    IValidateBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIdentifier( 
            /* [in] */ GUID guidLicensorID,
            /* [size_is][in] */ __RPC__in_ecount_full(cbEphemeron) BYTE *pbEphemeron,
            /* [in] */ DWORD cbEphemeron,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbBlobSize) BYTE **ppbBlobValidationID,
            /* [out] */ __RPC__out DWORD *pcbBlobSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IValidateBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IValidateBinding * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IValidateBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IValidateBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdentifier )( 
            __RPC__in IValidateBinding * This,
            /* [in] */ GUID guidLicensorID,
            /* [size_is][in] */ __RPC__in_ecount_full(cbEphemeron) BYTE *pbEphemeron,
            /* [in] */ DWORD cbEphemeron,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbBlobSize) BYTE **ppbBlobValidationID,
            /* [out] */ __RPC__out DWORD *pcbBlobSize);
        
        END_INTERFACE
    } IValidateBindingVtbl;

    interface IValidateBinding
    {
        CONST_VTBL struct IValidateBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IValidateBinding_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IValidateBinding_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IValidateBinding_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IValidateBinding_GetIdentifier(This,guidLicensorID,pbEphemeron,cbEphemeron,ppbBlobValidationID,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetIdentifier(This,guidLicensorID,pbEphemeron,cbEphemeron,ppbBlobValidationID,pcbBlobSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IValidateBinding_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcodecdsp_0000_0002 */
/* [local] */ 

////////////////////////////////////////////////////////////////
//
// The Speech code supports the following format property.
//
static const WCHAR *g_wszSpeechFormatCaps = L"SpeechFormatCap";
static const WCHAR *g_wszWMCPCodecName = L"_CODECNAME";
static const WCHAR *g_wszWMCPSupportedVBRModes = L"_SUPPORTEDVBRMODES";
#define WM_CODEC_ONEPASS_CBR 1
#define WM_CODEC_ONEPASS_VBR 2
#define WM_CODEC_TWOPASS_CBR 4
#define WM_CODEC_TWOPASS_VBR_UNCONSTRAINED   8
#define WM_CODEC_TWOPASS_VBR_PEAKCONSTRAINED 16
static const WCHAR *g_wszWMCPAudioVBRSupported = L"_VBRENABLED";
static const WCHAR *g_wszWMCPAudioVBRQuality = L"_VBRQUALITY";
static const WCHAR *g_wszWMCPMaxPasses = L"_PASSESRECOMMENDED";
static const WCHAR *g_wszWMCPDefaultCrisp = L"_DEFAULTCRISP";


extern RPC_IF_HANDLE __MIDL_itf_wmcodecdsp_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcodecdsp_0000_0002_v0_0_s_ifspec;

#ifndef __IWMVideoDecoderHurryup_INTERFACE_DEFINED__
#define __IWMVideoDecoderHurryup_INTERFACE_DEFINED__

/* interface IWMVideoDecoderHurryup */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMVideoDecoderHurryup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("352bb3bd-2d4d-4323-9e71-dcdcfbd53ca6")
    IWMVideoDecoderHurryup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetHurryup( 
            /* [in] */ LONG lHurryup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHurryup( 
            /* [out] */ LONG *plHurryup) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMVideoDecoderHurryupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMVideoDecoderHurryup * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMVideoDecoderHurryup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMVideoDecoderHurryup * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetHurryup )( 
            IWMVideoDecoderHurryup * This,
            /* [in] */ LONG lHurryup);
        
        HRESULT ( STDMETHODCALLTYPE *GetHurryup )( 
            IWMVideoDecoderHurryup * This,
            /* [out] */ LONG *plHurryup);
        
        END_INTERFACE
    } IWMVideoDecoderHurryupVtbl;

    interface IWMVideoDecoderHurryup
    {
        CONST_VTBL struct IWMVideoDecoderHurryupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMVideoDecoderHurryup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMVideoDecoderHurryup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMVideoDecoderHurryup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMVideoDecoderHurryup_SetHurryup(This,lHurryup)	\
    ( (This)->lpVtbl -> SetHurryup(This,lHurryup) ) 

#define IWMVideoDecoderHurryup_GetHurryup(This,plHurryup)	\
    ( (This)->lpVtbl -> GetHurryup(This,plHurryup) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMVideoDecoderHurryup_INTERFACE_DEFINED__ */


#ifndef __IWMVideoForceKeyFrame_INTERFACE_DEFINED__
#define __IWMVideoForceKeyFrame_INTERFACE_DEFINED__

/* interface IWMVideoForceKeyFrame */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMVideoForceKeyFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F8496BE-5B9A-41b9-A9E8-F21CD80596C2")
    IWMVideoForceKeyFrame : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetKeyFrame( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMVideoForceKeyFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMVideoForceKeyFrame * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMVideoForceKeyFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMVideoForceKeyFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetKeyFrame )( 
            IWMVideoForceKeyFrame * This);
        
        END_INTERFACE
    } IWMVideoForceKeyFrameVtbl;

    interface IWMVideoForceKeyFrame
    {
        CONST_VTBL struct IWMVideoForceKeyFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMVideoForceKeyFrame_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMVideoForceKeyFrame_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMVideoForceKeyFrame_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMVideoForceKeyFrame_SetKeyFrame(This)	\
    ( (This)->lpVtbl -> SetKeyFrame(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMVideoForceKeyFrame_INTERFACE_DEFINED__ */


#ifndef __IWMCodecStrings_INTERFACE_DEFINED__
#define __IWMCodecStrings_INTERFACE_DEFINED__

/* interface IWMCodecStrings */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecStrings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A7B2504B-E58A-47fb-958B-CAC7165A057D")
    IWMCodecStrings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ DMO_MEDIA_TYPE *pmt,
            /* [in] */ ULONG cchLength,
            /* [annotation][size_is][unique][out][in] */ 
            __out_ecount_opt(cchLength)  LPWSTR szName,
            /* [out] */ ULONG *pcchLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [in] */ DMO_MEDIA_TYPE *pmt,
            /* [in] */ ULONG cchLength,
            /* [annotation][size_is][unique][out][in] */ 
            __out_ecount_opt(cchLength)  LPWSTR szDescription,
            /* [out] */ ULONG *pcchLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecStringsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMCodecStrings * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMCodecStrings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMCodecStrings * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IWMCodecStrings * This,
            /* [in] */ DMO_MEDIA_TYPE *pmt,
            /* [in] */ ULONG cchLength,
            /* [annotation][size_is][unique][out][in] */ 
            __out_ecount_opt(cchLength)  LPWSTR szName,
            /* [out] */ ULONG *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IWMCodecStrings * This,
            /* [in] */ DMO_MEDIA_TYPE *pmt,
            /* [in] */ ULONG cchLength,
            /* [annotation][size_is][unique][out][in] */ 
            __out_ecount_opt(cchLength)  LPWSTR szDescription,
            /* [out] */ ULONG *pcchLength);
        
        END_INTERFACE
    } IWMCodecStringsVtbl;

    interface IWMCodecStrings
    {
        CONST_VTBL struct IWMCodecStringsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecStrings_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMCodecStrings_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMCodecStrings_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMCodecStrings_GetName(This,pmt,cchLength,szName,pcchLength)	\
    ( (This)->lpVtbl -> GetName(This,pmt,cchLength,szName,pcchLength) ) 

#define IWMCodecStrings_GetDescription(This,pmt,cchLength,szDescription,pcchLength)	\
    ( (This)->lpVtbl -> GetDescription(This,pmt,cchLength,szDescription,pcchLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMCodecStrings_INTERFACE_DEFINED__ */


#ifndef __IWMCodecProps_INTERFACE_DEFINED__
#define __IWMCodecProps_INTERFACE_DEFINED__

/* interface IWMCodecProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2573e11a-f01a-4fdd-a98d-63b8e0ba9589")
    IWMCodecProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFormatProp( 
            /* [in] */ DMO_MEDIA_TYPE *pmt,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_PROP_DATATYPE *pType,
            /* [size_is][unique][out][in] */ BYTE *pValue,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecProp( 
            /* [in] */ DWORD dwFormat,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_PROP_DATATYPE *pType,
            /* [size_is][unique][out][in] */ BYTE *pValue,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMCodecProps * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMCodecProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMCodecProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormatProp )( 
            IWMCodecProps * This,
            /* [in] */ DMO_MEDIA_TYPE *pmt,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_PROP_DATATYPE *pType,
            /* [size_is][unique][out][in] */ BYTE *pValue,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecProp )( 
            IWMCodecProps * This,
            /* [in] */ DWORD dwFormat,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_PROP_DATATYPE *pType,
            /* [size_is][unique][out][in] */ BYTE *pValue,
            /* [out][in] */ DWORD *pdwSize);
        
        END_INTERFACE
    } IWMCodecPropsVtbl;

    interface IWMCodecProps
    {
        CONST_VTBL struct IWMCodecPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMCodecProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMCodecProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMCodecProps_GetFormatProp(This,pmt,pszName,pType,pValue,pdwSize)	\
    ( (This)->lpVtbl -> GetFormatProp(This,pmt,pszName,pType,pValue,pdwSize) ) 

#define IWMCodecProps_GetCodecProp(This,dwFormat,pszName,pType,pValue,pdwSize)	\
    ( (This)->lpVtbl -> GetCodecProp(This,dwFormat,pszName,pType,pValue,pdwSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMCodecProps_INTERFACE_DEFINED__ */


#ifndef __IWMCodecLeakyBucket_INTERFACE_DEFINED__
#define __IWMCodecLeakyBucket_INTERFACE_DEFINED__

/* interface IWMCodecLeakyBucket */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecLeakyBucket;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A81BA647-6227-43b7-B231-C7B15135DD7D")
    IWMCodecLeakyBucket : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBufferSizeBits( 
            /* [in] */ ULONG ulBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferSizeBits( 
            /* [out] */ ULONG *pulBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferFullnessBits( 
            /* [in] */ ULONG ulBufferFullness) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferFullnessBits( 
            /* [out] */ ULONG *pulBufferFullness) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecLeakyBucketVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMCodecLeakyBucket * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMCodecLeakyBucket * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMCodecLeakyBucket * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferSizeBits )( 
            IWMCodecLeakyBucket * This,
            /* [in] */ ULONG ulBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferSizeBits )( 
            IWMCodecLeakyBucket * This,
            /* [out] */ ULONG *pulBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferFullnessBits )( 
            IWMCodecLeakyBucket * This,
            /* [in] */ ULONG ulBufferFullness);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferFullnessBits )( 
            IWMCodecLeakyBucket * This,
            /* [out] */ ULONG *pulBufferFullness);
        
        END_INTERFACE
    } IWMCodecLeakyBucketVtbl;

    interface IWMCodecLeakyBucket
    {
        CONST_VTBL struct IWMCodecLeakyBucketVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecLeakyBucket_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMCodecLeakyBucket_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMCodecLeakyBucket_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMCodecLeakyBucket_SetBufferSizeBits(This,ulBufferSize)	\
    ( (This)->lpVtbl -> SetBufferSizeBits(This,ulBufferSize) ) 

#define IWMCodecLeakyBucket_GetBufferSizeBits(This,pulBufferSize)	\
    ( (This)->lpVtbl -> GetBufferSizeBits(This,pulBufferSize) ) 

#define IWMCodecLeakyBucket_SetBufferFullnessBits(This,ulBufferFullness)	\
    ( (This)->lpVtbl -> SetBufferFullnessBits(This,ulBufferFullness) ) 

#define IWMCodecLeakyBucket_GetBufferFullnessBits(This,pulBufferFullness)	\
    ( (This)->lpVtbl -> GetBufferFullnessBits(This,pulBufferFullness) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMCodecLeakyBucket_INTERFACE_DEFINED__ */


#ifndef __IWMCodecOutputTimestamp_INTERFACE_DEFINED__
#define __IWMCodecOutputTimestamp_INTERFACE_DEFINED__

/* interface IWMCodecOutputTimestamp */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecOutputTimestamp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B72ADF95-7ADC-4a72-BC05-577D8EA6BF68")
    IWMCodecOutputTimestamp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNextOutputTime( 
            /* [out] */ REFERENCE_TIME *prtTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecOutputTimestampVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMCodecOutputTimestamp * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMCodecOutputTimestamp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMCodecOutputTimestamp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextOutputTime )( 
            IWMCodecOutputTimestamp * This,
            /* [out] */ REFERENCE_TIME *prtTime);
        
        END_INTERFACE
    } IWMCodecOutputTimestampVtbl;

    interface IWMCodecOutputTimestamp
    {
        CONST_VTBL struct IWMCodecOutputTimestampVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecOutputTimestamp_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMCodecOutputTimestamp_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMCodecOutputTimestamp_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMCodecOutputTimestamp_GetNextOutputTime(This,prtTime)	\
    ( (This)->lpVtbl -> GetNextOutputTime(This,prtTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMCodecOutputTimestamp_INTERFACE_DEFINED__ */


#ifndef __IWMVideoDecoderReconBuffer_INTERFACE_DEFINED__
#define __IWMVideoDecoderReconBuffer_INTERFACE_DEFINED__

/* interface IWMVideoDecoderReconBuffer */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMVideoDecoderReconBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45BDA2AC-88E2-4923-98BA-3949080711A3")
    IWMVideoDecoderReconBuffer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReconstructedVideoFrameSize( 
            /* [out] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReconstructedVideoFrame( 
            /* [out] */ IMediaBuffer *pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReconstructedVideoFrame( 
            /* [in] */ IMediaBuffer *pBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMVideoDecoderReconBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMVideoDecoderReconBuffer * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMVideoDecoderReconBuffer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMVideoDecoderReconBuffer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReconstructedVideoFrameSize )( 
            IWMVideoDecoderReconBuffer * This,
            /* [out] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetReconstructedVideoFrame )( 
            IWMVideoDecoderReconBuffer * This,
            /* [out] */ IMediaBuffer *pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *SetReconstructedVideoFrame )( 
            IWMVideoDecoderReconBuffer * This,
            /* [in] */ IMediaBuffer *pBuf);
        
        END_INTERFACE
    } IWMVideoDecoderReconBufferVtbl;

    interface IWMVideoDecoderReconBuffer
    {
        CONST_VTBL struct IWMVideoDecoderReconBufferVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMVideoDecoderReconBuffer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMVideoDecoderReconBuffer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMVideoDecoderReconBuffer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMVideoDecoderReconBuffer_GetReconstructedVideoFrameSize(This,pdwSize)	\
    ( (This)->lpVtbl -> GetReconstructedVideoFrameSize(This,pdwSize) ) 

#define IWMVideoDecoderReconBuffer_GetReconstructedVideoFrame(This,pBuf)	\
    ( (This)->lpVtbl -> GetReconstructedVideoFrame(This,pBuf) ) 

#define IWMVideoDecoderReconBuffer_SetReconstructedVideoFrame(This,pBuf)	\
    ( (This)->lpVtbl -> SetReconstructedVideoFrame(This,pBuf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMVideoDecoderReconBuffer_INTERFACE_DEFINED__ */


#ifndef __IWMCodecPrivateData_INTERFACE_DEFINED__
#define __IWMCodecPrivateData_INTERFACE_DEFINED__

/* interface IWMCodecPrivateData */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecPrivateData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73F0BE8E-57F7-4f01-AA66-9F57340CFE0E")
    IWMCodecPrivateData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPartialOutputType( 
            /* [in] */ DMO_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrivateData( 
            /* [size_is][unique][out][in] */ BYTE *pbData,
            /* [out][in] */ ULONG *pcbData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecPrivateDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMCodecPrivateData * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMCodecPrivateData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMCodecPrivateData * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartialOutputType )( 
            IWMCodecPrivateData * This,
            /* [in] */ DMO_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IWMCodecPrivateData * This,
            /* [size_is][unique][out][in] */ BYTE *pbData,
            /* [out][in] */ ULONG *pcbData);
        
        END_INTERFACE
    } IWMCodecPrivateDataVtbl;

    interface IWMCodecPrivateData
    {
        CONST_VTBL struct IWMCodecPrivateDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecPrivateData_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMCodecPrivateData_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMCodecPrivateData_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMCodecPrivateData_SetPartialOutputType(This,pmt)	\
    ( (This)->lpVtbl -> SetPartialOutputType(This,pmt) ) 

#define IWMCodecPrivateData_GetPrivateData(This,pbData,pcbData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,pbData,pcbData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMCodecPrivateData_INTERFACE_DEFINED__ */


#ifndef __IWMSampleExtensionSupport_INTERFACE_DEFINED__
#define __IWMSampleExtensionSupport_INTERFACE_DEFINED__

/* interface IWMSampleExtensionSupport */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMSampleExtensionSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9bca9884-0604-4c2a-87da-793ff4d586c3")
    IWMSampleExtensionSupport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetUseSampleExtensions( 
            BOOL fUseExtensions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSampleExtensionSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSampleExtensionSupport * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSampleExtensionSupport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSampleExtensionSupport * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUseSampleExtensions )( 
            IWMSampleExtensionSupport * This,
            BOOL fUseExtensions);
        
        END_INTERFACE
    } IWMSampleExtensionSupportVtbl;

    interface IWMSampleExtensionSupport
    {
        CONST_VTBL struct IWMSampleExtensionSupportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSampleExtensionSupport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSampleExtensionSupport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSampleExtensionSupport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSampleExtensionSupport_SetUseSampleExtensions(This,fUseExtensions)	\
    ( (This)->lpVtbl -> SetUseSampleExtensions(This,fUseExtensions) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSampleExtensionSupport_INTERFACE_DEFINED__ */


#ifndef __IWMResamplerProps_INTERFACE_DEFINED__
#define __IWMResamplerProps_INTERFACE_DEFINED__

/* interface IWMResamplerProps */
/* [local][unique][helpstring][uuid][object] */ 

typedef float ChMtxType;


EXTERN_C const IID IID_IWMResamplerProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E7E9984F-F09F-4da4-903F-6E2E0EFE56B5")
    IWMResamplerProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetHalfFilterLength( 
            /* [in] */ LONG lhalfFilterLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserChannelMtx( 
            /* [in] */ ChMtxType *userChannelMtx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMResamplerPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMResamplerProps * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMResamplerProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMResamplerProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetHalfFilterLength )( 
            IWMResamplerProps * This,
            /* [in] */ LONG lhalfFilterLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserChannelMtx )( 
            IWMResamplerProps * This,
            /* [in] */ ChMtxType *userChannelMtx);
        
        END_INTERFACE
    } IWMResamplerPropsVtbl;

    interface IWMResamplerProps
    {
        CONST_VTBL struct IWMResamplerPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMResamplerProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMResamplerProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMResamplerProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMResamplerProps_SetHalfFilterLength(This,lhalfFilterLen)	\
    ( (This)->lpVtbl -> SetHalfFilterLength(This,lhalfFilterLen) ) 

#define IWMResamplerProps_SetUserChannelMtx(This,userChannelMtx)	\
    ( (This)->lpVtbl -> SetUserChannelMtx(This,userChannelMtx) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMResamplerProps_INTERFACE_DEFINED__ */


#ifndef __IWMResizerProps_INTERFACE_DEFINED__
#define __IWMResizerProps_INTERFACE_DEFINED__

/* interface IWMResizerProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMResizerProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("57665D4C-0414-4faa-905B-10E546F81C33")
    IWMResizerProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetResizerQuality( 
            /* [in] */ LONG lquality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInterlaceMode( 
            /* [in] */ LONG lmode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClipRegion( 
            /* [in] */ LONG lClipOriXSrc,
            /* [in] */ LONG lClipOriYSrc,
            /* [in] */ LONG lClipWidthSrc,
            /* [in] */ LONG lClipHeightSrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFullCropRegion( 
            /* [in] */ LONG lClipOriXSrc,
            /* [in] */ LONG lClipOriYSrc,
            /* [in] */ LONG lClipWidthSrc,
            /* [in] */ LONG lClipHeightSrc,
            /* [in] */ LONG lClipOriXDst,
            /* [in] */ LONG lClipOriYDst,
            /* [in] */ LONG lClipWidthDst,
            /* [in] */ LONG lClipHeightDst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFullCropRegion( 
            /* [out] */ LONG *lClipOriXSrc,
            /* [out] */ LONG *lClipOriYSrc,
            /* [out] */ LONG *lClipWidthSrc,
            /* [out] */ LONG *lClipHeightSrc,
            /* [out] */ LONG *lClipOriXDst,
            /* [out] */ LONG *lClipOriYDst,
            /* [out] */ LONG *lClipWidthDst,
            /* [out] */ LONG *lClipHeightDst) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMResizerPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMResizerProps * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMResizerProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMResizerProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetResizerQuality )( 
            IWMResizerProps * This,
            /* [in] */ LONG lquality);
        
        HRESULT ( STDMETHODCALLTYPE *SetInterlaceMode )( 
            IWMResizerProps * This,
            /* [in] */ LONG lmode);
        
        HRESULT ( STDMETHODCALLTYPE *SetClipRegion )( 
            IWMResizerProps * This,
            /* [in] */ LONG lClipOriXSrc,
            /* [in] */ LONG lClipOriYSrc,
            /* [in] */ LONG lClipWidthSrc,
            /* [in] */ LONG lClipHeightSrc);
        
        HRESULT ( STDMETHODCALLTYPE *SetFullCropRegion )( 
            IWMResizerProps * This,
            /* [in] */ LONG lClipOriXSrc,
            /* [in] */ LONG lClipOriYSrc,
            /* [in] */ LONG lClipWidthSrc,
            /* [in] */ LONG lClipHeightSrc,
            /* [in] */ LONG lClipOriXDst,
            /* [in] */ LONG lClipOriYDst,
            /* [in] */ LONG lClipWidthDst,
            /* [in] */ LONG lClipHeightDst);
        
        HRESULT ( STDMETHODCALLTYPE *GetFullCropRegion )( 
            IWMResizerProps * This,
            /* [out] */ LONG *lClipOriXSrc,
            /* [out] */ LONG *lClipOriYSrc,
            /* [out] */ LONG *lClipWidthSrc,
            /* [out] */ LONG *lClipHeightSrc,
            /* [out] */ LONG *lClipOriXDst,
            /* [out] */ LONG *lClipOriYDst,
            /* [out] */ LONG *lClipWidthDst,
            /* [out] */ LONG *lClipHeightDst);
        
        END_INTERFACE
    } IWMResizerPropsVtbl;

    interface IWMResizerProps
    {
        CONST_VTBL struct IWMResizerPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMResizerProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMResizerProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMResizerProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMResizerProps_SetResizerQuality(This,lquality)	\
    ( (This)->lpVtbl -> SetResizerQuality(This,lquality) ) 

#define IWMResizerProps_SetInterlaceMode(This,lmode)	\
    ( (This)->lpVtbl -> SetInterlaceMode(This,lmode) ) 

#define IWMResizerProps_SetClipRegion(This,lClipOriXSrc,lClipOriYSrc,lClipWidthSrc,lClipHeightSrc)	\
    ( (This)->lpVtbl -> SetClipRegion(This,lClipOriXSrc,lClipOriYSrc,lClipWidthSrc,lClipHeightSrc) ) 

#define IWMResizerProps_SetFullCropRegion(This,lClipOriXSrc,lClipOriYSrc,lClipWidthSrc,lClipHeightSrc,lClipOriXDst,lClipOriYDst,lClipWidthDst,lClipHeightDst)	\
    ( (This)->lpVtbl -> SetFullCropRegion(This,lClipOriXSrc,lClipOriYSrc,lClipWidthSrc,lClipHeightSrc,lClipOriXDst,lClipOriYDst,lClipWidthDst,lClipHeightDst) ) 

#define IWMResizerProps_GetFullCropRegion(This,lClipOriXSrc,lClipOriYSrc,lClipWidthSrc,lClipHeightSrc,lClipOriXDst,lClipOriYDst,lClipWidthDst,lClipHeightDst)	\
    ( (This)->lpVtbl -> GetFullCropRegion(This,lClipOriXSrc,lClipOriYSrc,lClipWidthSrc,lClipHeightSrc,lClipOriXDst,lClipOriYDst,lClipWidthDst,lClipHeightDst) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMResizerProps_INTERFACE_DEFINED__ */


#ifndef __IWMColorLegalizerProps_INTERFACE_DEFINED__
#define __IWMColorLegalizerProps_INTERFACE_DEFINED__

/* interface IWMColorLegalizerProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMColorLegalizerProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("776C93B3-B72D-4508-B6D0-208785F553E7")
    IWMColorLegalizerProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetColorLegalizerQuality( 
            /* [in] */ LONG lquality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMColorLegalizerPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMColorLegalizerProps * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMColorLegalizerProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMColorLegalizerProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorLegalizerQuality )( 
            IWMColorLegalizerProps * This,
            /* [in] */ LONG lquality);
        
        END_INTERFACE
    } IWMColorLegalizerPropsVtbl;

    interface IWMColorLegalizerProps
    {
        CONST_VTBL struct IWMColorLegalizerPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMColorLegalizerProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMColorLegalizerProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMColorLegalizerProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMColorLegalizerProps_SetColorLegalizerQuality(This,lquality)	\
    ( (This)->lpVtbl -> SetColorLegalizerQuality(This,lquality) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMColorLegalizerProps_INTERFACE_DEFINED__ */


#ifndef __IWMInterlaceProps_INTERFACE_DEFINED__
#define __IWMInterlaceProps_INTERFACE_DEFINED__

/* interface IWMInterlaceProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMInterlaceProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7B12E5D1-BD22-48ea-BC06-98E893221C89")
    IWMInterlaceProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProcessType( 
            /* [in] */ int iProcessType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInitInverseTeleCinePattern( 
            /* [in] */ int iInitPattern) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLastFrame( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMInterlacePropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMInterlaceProps * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMInterlaceProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMInterlaceProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProcessType )( 
            IWMInterlaceProps * This,
            /* [in] */ int iProcessType);
        
        HRESULT ( STDMETHODCALLTYPE *SetInitInverseTeleCinePattern )( 
            IWMInterlaceProps * This,
            /* [in] */ int iInitPattern);
        
        HRESULT ( STDMETHODCALLTYPE *SetLastFrame )( 
            IWMInterlaceProps * This);
        
        END_INTERFACE
    } IWMInterlacePropsVtbl;

    interface IWMInterlaceProps
    {
        CONST_VTBL struct IWMInterlacePropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMInterlaceProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMInterlaceProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMInterlaceProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMInterlaceProps_SetProcessType(This,iProcessType)	\
    ( (This)->lpVtbl -> SetProcessType(This,iProcessType) ) 

#define IWMInterlaceProps_SetInitInverseTeleCinePattern(This,iInitPattern)	\
    ( (This)->lpVtbl -> SetInitInverseTeleCinePattern(This,iInitPattern) ) 

#define IWMInterlaceProps_SetLastFrame(This)	\
    ( (This)->lpVtbl -> SetLastFrame(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMInterlaceProps_INTERFACE_DEFINED__ */


#ifndef __IWMFrameInterpProps_INTERFACE_DEFINED__
#define __IWMFrameInterpProps_INTERFACE_DEFINED__

/* interface IWMFrameInterpProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMFrameInterpProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4C06BB9B-626C-4614-8329-CC6A21B93FA0")
    IWMFrameInterpProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFrameRateIn( 
            /* [in] */ LONG lFrameRate,
            /* [in] */ LONG lScale) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameRateOut( 
            /* [in] */ LONG lFrameRate,
            /* [in] */ LONG lScale) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameInterpEnabled( 
            /* [in] */ BOOL bFIEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComplexityLevel( 
            /* [in] */ int iComplexity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMFrameInterpPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMFrameInterpProps * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMFrameInterpProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMFrameInterpProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFrameRateIn )( 
            IWMFrameInterpProps * This,
            /* [in] */ LONG lFrameRate,
            /* [in] */ LONG lScale);
        
        HRESULT ( STDMETHODCALLTYPE *SetFrameRateOut )( 
            IWMFrameInterpProps * This,
            /* [in] */ LONG lFrameRate,
            /* [in] */ LONG lScale);
        
        HRESULT ( STDMETHODCALLTYPE *SetFrameInterpEnabled )( 
            IWMFrameInterpProps * This,
            /* [in] */ BOOL bFIEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetComplexityLevel )( 
            IWMFrameInterpProps * This,
            /* [in] */ int iComplexity);
        
        END_INTERFACE
    } IWMFrameInterpPropsVtbl;

    interface IWMFrameInterpProps
    {
        CONST_VTBL struct IWMFrameInterpPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMFrameInterpProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMFrameInterpProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMFrameInterpProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMFrameInterpProps_SetFrameRateIn(This,lFrameRate,lScale)	\
    ( (This)->lpVtbl -> SetFrameRateIn(This,lFrameRate,lScale) ) 

#define IWMFrameInterpProps_SetFrameRateOut(This,lFrameRate,lScale)	\
    ( (This)->lpVtbl -> SetFrameRateOut(This,lFrameRate,lScale) ) 

#define IWMFrameInterpProps_SetFrameInterpEnabled(This,bFIEnabled)	\
    ( (This)->lpVtbl -> SetFrameInterpEnabled(This,bFIEnabled) ) 

#define IWMFrameInterpProps_SetComplexityLevel(This,iComplexity)	\
    ( (This)->lpVtbl -> SetComplexityLevel(This,iComplexity) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMFrameInterpProps_INTERFACE_DEFINED__ */


#ifndef __IWMColorConvProps_INTERFACE_DEFINED__
#define __IWMColorConvProps_INTERFACE_DEFINED__

/* interface IWMColorConvProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMColorConvProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E6A49E22-C099-421d-AAD3-C061FB4AE85B")
    IWMColorConvProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMode( 
            /* [in] */ LONG lMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFullCroppingParam( 
            /* [in] */ LONG lSrcCropLeft,
            /* [in] */ LONG lSrcCropTop,
            /* [in] */ LONG lDstCropLeft,
            /* [in] */ LONG lDstCropTop,
            /* [in] */ LONG lCropWidth,
            /* [in] */ LONG lCropHeight) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMColorConvPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMColorConvProps * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMColorConvProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMColorConvProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMode )( 
            IWMColorConvProps * This,
            /* [in] */ LONG lMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetFullCroppingParam )( 
            IWMColorConvProps * This,
            /* [in] */ LONG lSrcCropLeft,
            /* [in] */ LONG lSrcCropTop,
            /* [in] */ LONG lDstCropLeft,
            /* [in] */ LONG lDstCropTop,
            /* [in] */ LONG lCropWidth,
            /* [in] */ LONG lCropHeight);
        
        END_INTERFACE
    } IWMColorConvPropsVtbl;

    interface IWMColorConvProps
    {
        CONST_VTBL struct IWMColorConvPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMColorConvProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMColorConvProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMColorConvProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMColorConvProps_SetMode(This,lMode)	\
    ( (This)->lpVtbl -> SetMode(This,lMode) ) 

#define IWMColorConvProps_SetFullCroppingParam(This,lSrcCropLeft,lSrcCropTop,lDstCropLeft,lDstCropTop,lCropWidth,lCropHeight)	\
    ( (This)->lpVtbl -> SetFullCroppingParam(This,lSrcCropLeft,lSrcCropTop,lDstCropLeft,lDstCropTop,lCropWidth,lCropHeight) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMColorConvProps_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcodecdsp_0000_0017 */
/* [local] */ 

#ifndef NO_MF_PROPKEYS
static const PROPERTYKEY MFPKEY_STARTTIME = { { 0x5cefee10, 0xe210, 0x45c6, {0x9e, 0x28, 0xf5, 0xa8, 0x73, 0x1c, 0x96, 0xc7} }, 0x01 }; 
static const PROPERTYKEY MFPKEY_STOPTIME = { { 0x5cefee10, 0xe210, 0x45c6, {0x9e, 0x28, 0xf5, 0xa8, 0x73, 0x1c, 0x96, 0xc7} }, 0x02 }; 
static const PROPERTYKEY MFPKEY_PROGRESS = { { 0x5cefee10, 0xe210, 0x45c6, {0x9e, 0x28, 0xf5, 0xa8, 0x73, 0x1c, 0x96, 0xc7} }, 0x03 }; 
static const PROPERTYKEY MFPKEY_PHANTOMING_ON = { { 0x12b53cb2, 0xe12e, 0x4579, { 0x8a, 0xc3, 0xd0, 0x2f, 0x94, 0xf1, 0xe8, 0x9e } }, PID_FIRST_USABLE }; 
#define PHANTOMING_ENABLED_KEY_GUID (MFPKEY_PHANTOMING_ON.fmtid)
static const PROPERTYKEY MFPKEY_ROOMCORR_PROFILE        = { { 0xf311cdc7, 0xf45f, 0x4eb7, { 0xa8, 0x64, 0x9d, 0xc1, 0xae, 0xeb, 0x7e, 0x6d } }, PID_FIRST_USABLE }; 
#define ROOM_PROFILE_KEY_GUID (MFPKEY_ROOMCORR_PROFILE.fmtid)
static const PROPERTYKEY MFPKEY_BASSMGMT_CROSSOVER_FREQ = { { 0x61e8acb9, 0xf04f, 0x4f40, { 0xa6, 0x5f, 0x8f, 0x49, 0xfa, 0xb3, 0xba, 0x10 } }, PID_FIRST_USABLE }; 
#define CROSSOVER_FREQ_KEY_GUID (MFPKEY_BASSMGMT_CROSSOVER_FREQ.fmtid)
static const PROPERTYKEY MFPKEY_BASSMGMT_SPKRBASSCONFIG = { { 0x7bfd170d, 0x4770, 0x4dc5, { 0x92, 0x4d, 0x0b, 0x7b, 0x25, 0x2e, 0xe9, 0x18 } }, PID_FIRST_USABLE }; 
#define FULL_RANGE_SPEAKERS_KEY_GUID (MFPKEY_BASSMGMT_SPKRBASSCONFIG.fmtid)
static const PROPERTYKEY MFPKEY_BASSMGMT_BIGROOM        = { { 0xc816a1a7, 0xa119, 0x48a5, { 0x9a, 0xd2, 0x85, 0x45, 0x1f, 0x4b, 0x5a, 0x2e } }, PID_FIRST_USABLE }; 
#define BIG_ROOM_KEY_GUID (MFPKEY_BASSMGMT_BIGROOM.fmtid)
static const PROPERTYKEY MFPKEY_BASSMGMT_NO_SUB         = { { 0x5c3fd32e, 0x0d40, 0x4e2d, { 0x99, 0xfb, 0xc9, 0x1e, 0x96, 0x42, 0x0b, 0xe7 } }, PID_FIRST_USABLE }; 
#define NO_SUB_KEY_GUID (MFPKEY_BASSMGMT_NO_SUB.fmtid)
static const PROPERTYKEY MFPKEY_BASSMGMT_INVERT_SUB     = { { 0xb1103003, 0xc191, 0x4275, { 0x9f, 0xa0, 0x8c, 0x28, 0x2c, 0x72, 0x4b, 0xce } }, PID_FIRST_USABLE }; 
#define INVERTED_SUB_KEY_GUID (MFPKEY_BASSMGMT_INVERT_SUB.fmtid)
static const PROPERTYKEY MFPKEY_CORR_HEADPHONE          = { { 0x445f3559, 0xb43f, 0x4b67, {0xb0, 0xf8, 0x32, 0xb6, 0x7c, 0xf9, 0x4b, 0x48} }, PID_FIRST_USABLE + 0}; 
static const PROPERTYKEY MFPKEY_CORR_BASS_MANAGEMENT_MODE        = { { 0x1864a4e0, 0xefc1, 0x45e6, { 0xa6, 0x75, 0x57, 0x86, 0xcb, 0xf3, 0xb9, 0xf0 } }, PID_FIRST_USABLE }; 
#define BASSMGMT_MODE_KEY_GUID (MFPKEY_CORR_BASS_MANAGEMENT_MODE.fmtid)
static const PROPERTYKEY MFPKEY_CORR_MULTICHANNEL_MODE           = { { 0x1b5c2483, 0x0839, 0x4523, { 0xba, 0x87, 0x95, 0xf8, 0x9d, 0x27, 0xbd, 0x8c } }, PID_FIRST_USABLE }; 
#define MULTICHANNEL_MODE_KEY_GUID (MFPKEY_CORR_MULTICHANNEL_MODE.fmtid)
static const PROPERTYKEY MFPKEY_CORR_LOUDNESS_EQUALIZATION_ON    = { { 0xfc52a749, 0x4be9, 0x4510, { 0x89, 0x6e, 0x96, 0x6b, 0xa6, 0x52, 0x59, 0x80 } }, PID_FIRST_USABLE }; 
#define LEQ_ENABLED_KEY_GUID (MFPKEY_CORR_LOUDNESS_EQUALIZATION_ON.fmtid)
static const PROPERTYKEY MFPKEY_CORR_ROOM_CORRECTION_ON          = { { 0x01fb17e3, 0x796c, 0x4451, { 0x81, 0x63, 0x68, 0xcd, 0xc1, 0x32, 0x1a, 0x60 } }, PID_FIRST_USABLE }; 
#define ROOM_CORRECTION_ENABLED_KEY_GUID (MFPKEY_CORR_ROOM_CORRECTION_ON.fmtid)
static const PROPERTYKEY MFPKEY_CORR_SPKRMASK               = { { 0xd328d8fb, 0xd49f, 0x4aa9, {0xb7, 0x21, 0xe1, 0x71, 0xe9, 0x3a, 0xd5, 0x63} }, PID_FIRST_USABLE + 5}; 
static const PROPERTYKEY MFPKEY_CORR_NORMALIZATION_GAIN     = { { 0xd61b266c, 0x5aee, 0x456b, {0x84, 0x24, 0x72, 0x25, 0x47, 0x7d, 0xae, 0x77} }, PID_FIRST_USABLE + 0}; 
static const PROPERTYKEY MFPKEY_BASS_BOOST_AMOUNT                = { { 0xae7f0b2a, 0x96fc, 0x493a, { 0x92, 0x47, 0xa0, 0x19, 0xf1, 0xf7, 0x01, 0xe1 } }, PID_FIRST_USABLE }; 
#define BOOST_LEVEL_KEY_GUID (MFPKEY_BASS_BOOST_AMOUNT.fmtid)
static const PROPERTYKEY MFPKEY_LOUDNESS_EQUALIZATION_RELEASE    = { { 0x9c00eeed, 0xedce, 0x4cd8, { 0xae, 0x08, 0xcb, 0x05, 0xe8, 0xef, 0x57, 0xa0 } }, PID_FIRST_USABLE }; 
#define LEQ_RELEASE_KEY_GUID (MFPKEY_LOUDNESS_EQUALIZATION_RELEASE.fmtid)
static const PROPERTYKEY PKEY_SYSFXUI_HIDE_MASK = { { 0xcb9c6bce, 0x7a25, 0x47aa, { 0xb2, 0xbe, 0x6a, 0xd8, 0x44, 0x31, 0xed, 0xde } }, PID_FIRST_USABLE }; 
#define SYSFXUI_DONOTSHOW_LOUDNESSEQUALIZATION    0x01
#define SYSFXUI_DONOTSHOW_ROOMCORRECTION          0x02
#define SYSFXUI_DONOTSHOW_BASSMANAGEMENT          0x04
#define SYSFXUI_DONOTSHOW_BASSBOOST               0x08
#define SYSFXUI_DONOTSHOW_HEADPHONEVIRTUALIZATION 0x10
#define SYSFXUI_DONOTSHOW_VIRTUALSURROUND         0x20
#define SYSFXUI_DONOTSHOW_SPEAKERFILLING          0x40
#define SYSFXUI_DONOTSHOW_CHANNELPHANTOMING       0x80
static const PROPERTYKEY MFPKEY_AUVRHP_SKIPHRTFREVERB = { { 0x30bbfebf, 0x24b4, 0x4198, { 0x89, 0xba, 0xad, 0x11, 0xa2, 0xac, 0xd6, 0x1 } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_AUVRHP_SKIPPOSTREVERB = { { 0x30bbfebf, 0x24b4, 0x4198, { 0x89, 0xba, 0xad, 0x11, 0xa2, 0xac, 0xd6, 0x1 } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_AUVRHP_ROOMMODEL = { { 0x73ae880e, 0x8258, 0x4e57, { 0xb8, 0x5f, 0x7d, 0xaa, 0x6b, 0x7d, 0x5e, 0xf0 } }, PID_FIRST_USABLE }; 
#define VIRTUALIZATION_MODE_KEY_GUID (MFPKEY_AUVRHP_ROOMMODEL.fmtid)
static const PROPERTYKEY MFPKEY_AUVRHP_LFWEIGHT = { { 0x30bbfebf, 0x24b4, 0x4198, { 0x89, 0xba, 0xad, 0x11, 0xa2, 0xac, 0xd6, 0x1 } }, 0x04 }; 
static const PROPERTYKEY MFPKEY_AUVRHP_DOHRTFREVERB = { { 0x30bbfebf, 0x24b4, 0x4198, { 0x89, 0xba, 0xad, 0x11, 0xa2, 0xac, 0xd6, 0x1 } }, 0x05 }; 
static const PROPERTYKEY MFPKEY_AUVRHP_DOPOSTREVERB = { { 0x30bbfebf, 0x24b4, 0x4198, { 0x89, 0xba, 0xad, 0x11, 0xa2, 0xac, 0xd6, 0x1 } }, 0x06 }; 
static const PROPERTYKEY MFPKEY_AUVRHP_POSTREVERB_START = { { 0x30bbfebf, 0x24b4, 0x4198, { 0x89, 0xba, 0xad, 0x11, 0xa2, 0xac, 0xd6, 0x1 } }, 0x07 }; 
static const PROPERTYKEY MFPKEY_AUVRHP_POSTREVERB_LEN = { { 0x30bbfebf, 0x24b4, 0x4198, { 0x89, 0xba, 0xad, 0x11, 0xa2, 0xac, 0xd6, 0x1 } }, 0x08 }; 
static const PROPERTYKEY MFPKEY_WMRESAMP_FILTERQUALITY = { { 0xaf1adc73, 0xa210, 0x4b05, {0x96, 0x6e, 0x54, 0x91, 0xcf, 0xf4, 0x8b, 0x1d} }, 0x01 }; 
static const PROPERTYKEY MFPKEY_WMRESAMP_CHANNELMTX = { { 0xaf1adc73, 0xa210, 0x4b05, {0x96, 0x6e, 0x54, 0x91, 0xcf, 0xf4, 0x8b, 0x1d} }, 0x02 }; 
static const PROPERTYKEY MFPKEY_WMRESAMP_LOWPASS_BANDWIDTH = { { 0xaf1adc73, 0xa210, 0x4b05, {0x96, 0x6e, 0x54, 0x91, 0xcf, 0xf4, 0x8b, 0x1d} }, 0x03 }; 
static const PROPERTYKEY MFPKEY_WMAENC_AVGBYTESPERSEC = { { 0x11caf780, 0x921b, 0x42ef, { 0xb7, 0x55, 0xf3, 0xa0, 0x53, 0xea, 0x1a, 0x41 } }, 0x00 }; 
static const PROPERTYKEY MFPKEY_WMAENC_ORIGWAVEFORMAT = { { 0xf5c760a2, 0x3635, 0x48e1, { 0x8f, 0xbd, 0x0e, 0x49, 0x81, 0x24, 0xe0, 0xa2 } }, 0x00 }; 
static const PROPERTYKEY MFPKEY_PEAKCONSTRAINED = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 }; 
static const PROPERTYKEY MFPKEY_STAT_RAVG = { { 0x23a0e3b5, 0xfc62, 0x4ab8, { 0xb7, 0x7c, 0x6e, 0x0c, 0x28, 0xab, 0x30, 0x16 } }, 0x00 }; 
static const PROPERTYKEY MFPKEY_STAT_BAVG = { { 0x036f6b60, 0xad43, 0x485c, { 0x86, 0xc6, 0x21, 0xa6, 0xdb, 0x2c, 0x1b, 0xa3 } }, 0x00 }; 
static const PROPERTYKEY MFPKEY_STAT_RMAX = { { 0x82ff7c67, 0x6554, 0x4749, { 0xa3, 0x2b, 0x36, 0x90, 0xdd, 0x1a, 0xe8, 0xde } }, 0x00 }; 
static const PROPERTYKEY MFPKEY_STAT_BMAX = { { 0xcd95e5b7, 0x9143, 0x47fb, { 0xa9, 0xd2, 0x9d, 0xb7, 0x5f, 0x2e, 0x74, 0xbe } }, 0x00 }; 
static const PROPERTYKEY MFPKEY_CONSTRAINENCLATENCY    = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 1}; 
static const PROPERTYKEY MFPKEY_CONSTRAINDECLATENCY    = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 2}; 
static const PROPERTYKEY MFPKEY_CONSTRAINENCCOMPLEXITY = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 3}; 
static const PROPERTYKEY MFPKEY_MAXENCLATENCYMS        = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 4}; 
static const PROPERTYKEY MFPKEY_MAXDECLATENCYMS        = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 5}; 
static const PROPERTYKEY MFPKEY_ENCCOMPLEXITY          = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 6}; 
static const PROPERTYKEY MFPKEY_CHECKDATACONSISTENCY2P = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 +  7}; 
static const PROPERTYKEY MFPKEY_AVGCONSTRAINED         = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 +  8}; 
static const PROPERTYKEY MFPKEY_ENHANCED_WMA           = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 20}; 
static const PROPERTYKEY MFPKEY_REQUESTING_A_FRAMESIZE = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 21}; 
static const PROPERTYKEY MFPKEY_PREFERRED_FRAMESIZE    = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 22}; 
static const PROPERTYKEY MFPKEY_WMA_ELEMENTARY_STREAM  = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 23}; 
static const PROPERTYKEY MFPKEY_MOST_RECENTLY_ENUMERATED_VBRQUALITY = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 24}; 
static const PROPERTYKEY MFPKEY_DESIRED_VBRQUALITY                  = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 25}; 
static const PROPERTYKEY MFPKEY_CONSTRAIN_ENUMERATED_VBRQUALITY     = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 26}; 
static const PROPERTYKEY MFPKEY_WMAENC_GENERATE_DRC_PARAMS 	= { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 28}; 
static const PROPERTYKEY MFPKEY_WMAENC_BUFFERLESSCBR 	= { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 29}; 
static const PROPERTYKEY MFPKEY_WMAENC_RTSPDIF    		= { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 30}; 
static const PROPERTYKEY MFPKEY_DYN_VBR_RAVG           = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 +  9}; 
static const PROPERTYKEY MFPKEY_DYN_BANDTRUNCATION     = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 10}; 
static const PROPERTYKEY MFPKEY_DYN_BANDTRUNC_QFLOOR   = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 11}; 
static const PROPERTYKEY MFPKEY_DYN_BANDTRUNC_QCEIL    = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 12}; 
static const PROPERTYKEY MFPKEY_DYN_BANDTRUNC_BWFLOOR  = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 13}; 
static const PROPERTYKEY MFPKEY_DYN_BANDTRUNC_BWCEIL   = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 14}; 
static const PROPERTYKEY MFPKEY_DYN_SIMPLEMASK         = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 15}; 
static const PROPERTYKEY MFPKEY_DYN_STEREO_PREPROC     = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 16}; 
static const PROPERTYKEY MFPKEY_DYN_VBR_BAVG           = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 18}; 
static const PROPERTYKEY MFPKEY_DYN_ALLOW_NOISESUB     = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 19}; 
static const PROPERTYKEY MFPKEY_DYN_ALLOW_PCMRANGELIMITING  = { { 0x6dbdf03b, 0xb05c, 0x4a03, { 0x8e, 0xc1, 0xbb, 0xe6, 0x3d, 0xb1, 0x0c, 0xb4 } }, 0x00 + 27}; 
static const PROPERTYKEY MFPKEY_WMADEC_HIRESOUTPUT     = { { 0x8d3fe592, 0xeecc, 0x4f4e, { 0x9a, 0xff, 0x5a, 0xf1, 0x67, 0x9d, 0x38, 0xd2 } }, 0x00 }; 
static const PROPERTYKEY MFPKEY_WMADEC_SPKRCFG         = { { 0x8fff67be, 0x977f, 0x41dc, { 0x8f, 0xaf, 0x23, 0xba, 0xc9, 0xa6, 0xdf, 0x73 } }, 0x00 }; 
static const PROPERTYKEY MFPKEY_WMADEC_FOLDDOWN_MATRIX = { { 0x51647e9b, 0x6a7f, 0x4739, { 0x9e, 0x0b, 0x29, 0x4b, 0x27, 0x89, 0x69, 0xeb } }, 0x00 }; 
static const PROPERTYKEY MFPKEY_WMADEC_DRCMODE         = { { 0x7b613713, 0x3d38, 0x4cda, { 0xaa, 0x61, 0x04, 0x78, 0xb1, 0xbc, 0xfc, 0x42 } }, 0x00 }; 
static const PROPERTYKEY MFPKEY_WMADRC_AVGTARGET       = { { 0x7b613713, 0x3d38, 0x4cda, { 0xaa, 0x61, 0x04, 0x78, 0xb1, 0xbc, 0xfc, 0x42 } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_WMADRC_PEAKTARGET      = { { 0x7b613713, 0x3d38, 0x4cda, { 0xaa, 0x61, 0x04, 0x78, 0xb1, 0xbc, 0xfc, 0x42 } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_WMADRC_AVGREF          = { { 0x7b613713, 0x3d38, 0x4cda, { 0xaa, 0x61, 0x04, 0x78, 0xb1, 0xbc, 0xfc, 0x42 } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_WMADRC_PEAKREF         = { { 0x7b613713, 0x3d38, 0x4cda, { 0xaa, 0x61, 0x04, 0x78, 0xb1, 0xbc, 0xfc, 0x42 } }, 0x04 }; 
static const PROPERTYKEY MFPKEY_WMADEC_LTRTOUTPUT      = { { 0x7b613713, 0x3d38, 0x4cda, { 0xaa, 0x61, 0x04, 0x78, 0xb1, 0xbc, 0xfc, 0x42 } }, 0x05 }; 
static const PROPERTYKEY MFPKEY_WMAVOICE_ENC_MusicSpeechClassMode = { { 0xd9c8f5fe, 0x8682, 0x4347, { 0x85, 0x7, 0x60, 0xa3, 0xf5, 0x1f, 0x33, 0xf1 } }, PID_FIRST_USABLE }; 
static const PROPERTYKEY MFPKEY_WMAVOICE_ENC_BufferWindow         = { { 0xd9c8f5fe, 0x8682, 0x4347, { 0x85, 0x7, 0x60, 0xa3, 0xf5, 0x1f, 0x33, 0xf1 } }, PID_FIRST_USABLE + 1 }; 
static const PROPERTYKEY MFPKEY_WMAVOICE_ENC_DecoderDelay         = { { 0xd9c8f5fe, 0x8682, 0x4347, { 0x85, 0x7, 0x60, 0xa3, 0xf5, 0x1f, 0x33, 0xf1 } }, PID_FIRST_USABLE + 2 }; 
static const PROPERTYKEY MFPKEY_WMAVOICE_ENC_EDL                  = { { 0xd9c8f5fe, 0x8682, 0x4347, { 0x85, 0x7, 0x60, 0xa3, 0xf5, 0x1f, 0x33, 0xf1 } }, PID_FIRST_USABLE + 3 }; 
static const PROPERTYKEY MFPKEY_WMAVOICE_ENC_RT_VariableRate      = { { 0xd9c8f5fe, 0x8682, 0x4347, { 0x85, 0x7, 0x60, 0xa3, 0xf5, 0x1f, 0x33, 0xf1 } }, PID_FIRST_USABLE + 4 }; 
static const PROPERTYKEY MFPKEY_WMAVOICE_ENC_RT_BandWidth         = { { 0xd9c8f5fe, 0x8682, 0x4347, { 0x85, 0x7, 0x60, 0xa3, 0xf5, 0x1f, 0x33, 0xf1 } }, PID_FIRST_USABLE + 5 }; 
static const PROPERTYKEY MFPKEY_WMAVOICE_ENC_RT_PacketLossMode    = { { 0xd9c8f5fe, 0x8682, 0x4347, { 0x85, 0x7, 0x60, 0xa3, 0xf5, 0x1f, 0x33, 0xf1 } }, PID_FIRST_USABLE + 6 }; 
static const PROPERTYKEY MFPKEY_WMAVOICE_ENC_RT_MinBufferSize     = { { 0xd9c8f5fe, 0x8682, 0x4347, { 0x85, 0x7, 0x60, 0xa3, 0xf5, 0x1f, 0x33, 0xf1 } }, PID_FIRST_USABLE + 7 }; 
static const PROPERTYKEY MFPKEY_WMAVOICE_DEC_RT_JitterControl     = { { 0x165f69b, 0x80a1, 0x4ef8, { 0xa4, 0xa9, 0xad, 0xa3, 0xb8, 0xa6, 0x89, 0xdd } }, PID_FIRST_USABLE }; 
static const PROPERTYKEY MFPKEY_WMAVOICE_DEC_RT_JitterMode        = { { 0x165f69b, 0x80a1, 0x4ef8, { 0xa4, 0xa9, 0xad, 0xa3, 0xb8, 0xa6, 0x89, 0xdd } }, PID_FIRST_USABLE + 1 }; 
static const PROPERTYKEY MFPKEY_WMAVOICE_DEC_RT_PacketLossMode    = { { 0x165f69b, 0x80a1, 0x4ef8, { 0xa4, 0xa9, 0xad, 0xa3, 0xb8, 0xa6, 0x89, 0xdd } }, PID_FIRST_USABLE + 2 }; 
static const PROPERTYKEY MFPKEY_Decoder_MaxNumPCMSamplesWithPaddedSilence  = { { 0xc678ba85, 0x1212, 0x43da, { 90, 0xc3, 0xe7, 0x48, 0xb9, 0x24, 0x49, 0xec } }, 0x00 }; 
static const PROPERTYKEY MFPKEY_WMAAECMA_SYSTEM_MODE          = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 0}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_DMO_SOURCE_MODE      = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 1}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_DEVICE_INDEXES       = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 2}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_FEATURE_MODE         = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 3}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_FEATR_FRAME_SIZE     = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 4}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_FEATR_ECHO_LENGTH    = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 5}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_FEATR_NS             = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 6}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_FEATR_AGC            = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 7}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_FEATR_AES            = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 8}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_FEATR_VAD            = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 9}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_FEATR_CENTER_CLIP    = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 10}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_FEATR_NOISE_FILL     = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 11}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_RETRIEVE_TS_STATS    = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 12}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_QUALITY_METRICS      = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 13}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_MICARRAY_DESCPTR     = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 14}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_DEVICEPAIR_GUID      = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 15}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_FEATR_MICARR_MODE    = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 16}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_FEATR_MICARR_BEAM    = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 17}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_FEATR_MICARR_PREPROC = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 18}; 
static const PROPERTYKEY MFPKEY_WMAAECMA_MIC_GAIN_BOUNDER     = { { 0x6f52c567, 0x360, 0x4bd2, { 0x96, 0x17, 0xcc, 0xbf, 0x14, 0x21, 0xc9, 0x39 } }, PID_FIRST_USABLE + 19}; 
static const PROPERTYKEY MFPKEY_COLOR_BRIGHTNESS    = { { 0x174fb0ec, 0x2695, 0x476c, { 0x88, 0xaa, 0xd2, 0xb4, 0x1c, 0xe7, 0x5e, 0x67 } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_COLOR_CONTRAST      = { { 0x174fb0ec, 0x2695, 0x476c, { 0x88, 0xaa, 0xd2, 0xb4, 0x1c, 0xe7, 0x5e, 0x67 } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_COLOR_HUE           = { { 0x174fb0ec, 0x2695, 0x476c, { 0x88, 0xaa, 0xd2, 0xb4, 0x1c, 0xe7, 0x5e, 0x67 } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_COLOR_SATURATION    = { { 0x174fb0ec, 0x2695, 0x476c, { 0x88, 0xaa, 0xd2, 0xb4, 0x1c, 0xe7, 0x5e, 0x67 } }, 0x04 }; 
static const PROPERTYKEY MFPKEY_COLORLEGALIZER_COMPLEXITY        = { { 0xadd0e6c1, 0xcc30, 0x475d, { 0x9e, 0x5a, 0xf1, 0xb1, 0x9f, 0x58, 0x7b, 0xe0 } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_COLORLEGALIZER_COMPLEXITYEX      = { { 0xadd0e6c1, 0xcc30, 0x475d, { 0x9e, 0x5a, 0xf1, 0xb1, 0x9f, 0x58, 0x7b, 0xe0 } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_COLORLEGALIZER_COMPLEXITYMAX     = { { 0xadd0e6c1, 0xcc30, 0x475d, { 0x9e, 0x5a, 0xf1, 0xb1, 0x9f, 0x58, 0x7b, 0xe0 } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_COLORLEGALIZER_COMPLEXITYLIVE    = { { 0xadd0e6c1, 0xcc30, 0x475d, { 0x9e, 0x5a, 0xf1, 0xb1, 0x9f, 0x58, 0x7b, 0xe0 } }, 0x04 }; 
static const PROPERTYKEY MFPKEY_COLORLEGALIZER_COMPLEXITYOFFLINE = { { 0xadd0e6c1, 0xcc30, 0x475d, { 0x9e, 0x5a, 0xf1, 0xb1, 0x9f, 0x58, 0x7b, 0xe0 } }, 0x05 }; 
static const PROPERTYKEY MFPKEY_COLORLEGALIZER_bSVideo           = { { 0xadd0e6c1, 0xcc30, 0x475d, { 0x9e, 0x5a, 0xf1, 0xb1, 0x9f, 0x58, 0x7b, 0xe0 } }, 0x06 }; 
static const PROPERTYKEY MFPKEY_CONV_INPUTFRAMERATE  = { { 0x52f8d29b, 0x2e76, 0x43f7, { 0xa4, 0xf6, 0x17, 0x17, 0x90, 0x4e, 0x35, 0xdf } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_CONV_OUTPUTFRAMERATE = { { 0x52f8d29b, 0x2e76, 0x43f7, { 0xa4, 0xf6, 0x17, 0x17, 0x90, 0x4e, 0x35, 0xdf } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_CONV_REVERSEPLAYBACK = { { 0x52f8d29b, 0x2e76, 0x43f7, { 0xa4, 0xf6, 0x17, 0x17, 0x90, 0x4e, 0x35, 0xdf } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_SMPTE_MASKNUM        = { { 0x427ce859, 0xd55c, 0x4f8e, {0xb0, 0x0e, 0x9c, 0xdf, 0x76, 0x15, 0x48, 0xa6} }, 0x01 }; 
static const PROPERTYKEY MFPKEY_SMPTE_OFFSETX        = { { 0x427ce859, 0xd55c, 0x4f8e, {0xb0, 0x0e, 0x9c, 0xdf, 0x76, 0x15, 0x48, 0xa6} }, 0x02 }; 
static const PROPERTYKEY MFPKEY_SMPTE_OFFSETY        = { { 0x427ce859, 0xd55c, 0x4f8e, {0xb0, 0x0e, 0x9c, 0xdf, 0x76, 0x15, 0x48, 0xa6} }, 0x03 }; 
static const PROPERTYKEY MFPKEY_SMPTE_REPLICATEX     = { { 0x427ce859, 0xd55c, 0x4f8e, {0xb0, 0x0e, 0x9c, 0xdf, 0x76, 0x15, 0x48, 0xa6} }, 0x04 }; 
static const PROPERTYKEY MFPKEY_SMPTE_REPLICATEY     = { { 0x427ce859, 0xd55c, 0x4f8e, {0xb0, 0x0e, 0x9c, 0xdf, 0x76, 0x15, 0x48, 0xa6} }, 0x05 }; 
static const PROPERTYKEY MFPKEY_SMPTE_REVERSE        = { { 0x427ce859, 0xd55c, 0x4f8e, {0xb0, 0x0e, 0x9c, 0xdf, 0x76, 0x15, 0x48, 0xa6} }, 0x06 }; 
static const PROPERTYKEY MFPKEY_SMPTE_BORDERSOFTNESS = { { 0x427ce859, 0xd55c, 0x4f8e, {0xb0, 0x0e, 0x9c, 0xdf, 0x76, 0x15, 0x48, 0xa6} }, 0x07 }; 
static const PROPERTYKEY MFPKEY_SMPTE_BORDERWIDTH    = { { 0x427ce859, 0xd55c, 0x4f8e, {0xb0, 0x0e, 0x9c, 0xdf, 0x76, 0x15, 0x48, 0xa6} }, 0x08 }; 
static const PROPERTYKEY MFPKEY_SMPTE_BORDERCOLOR    = { { 0x427ce859, 0xd55c, 0x4f8e, {0xb0, 0x0e, 0x9c, 0xdf, 0x76, 0x15, 0x48, 0xa6} }, 0x09 }; 
static const PROPERTYKEY MFPKEY_DENOISE_FILTER      = { { 0x7213c6ef, 0xcdd4, 0x4d09, {0xa8, 0x9e, 0xf3, 0xeb, 0xeb, 0xe5, 0xf5, 0x65} }, 0x01 }; 
static const PROPERTYKEY MFPKEY_DENOISE_CACHEFRAMES = { { 0x7213c6ef, 0xcdd4, 0x4d09, {0xa8, 0x9e, 0xf3, 0xeb, 0xeb, 0xe5, 0xf5, 0x65} }, 0x02 }; 
static const PROPERTYKEY MFPKEY_DENOISE_PROCFRAMES  = { { 0x7213c6ef, 0xcdd4, 0x4d09, {0xa8, 0x9e, 0xf3, 0xeb, 0xeb, 0xe5, 0xf5, 0x65} }, 0x03 }; 
static const PROPERTYKEY MFPKEY_DENOISE_CAUSAL      = { { 0x7213c6ef, 0xcdd4, 0x4d09, {0xa8, 0x9e, 0xf3, 0xeb, 0xeb, 0xe5, 0xf5, 0x65} }, 0x04 }; 
static const PROPERTYKEY MFPKEY_DENOISE_ITERATIVE   = { { 0x7213c6ef, 0xcdd4, 0x4d09, {0xa8, 0x9e, 0xf3, 0xeb, 0xeb, 0xe5, 0xf5, 0x65} }, 0x05 }; 
static const PROPERTYKEY MFPKEY_DENOISE_PARA1       = { { 0x7213c6ef, 0xcdd4, 0x4d09, {0xa8, 0x9e, 0xf3, 0xeb, 0xeb, 0xe5, 0xf5, 0x65} }, 0x06 }; 
static const PROPERTYKEY MFPKEY_DENOISE_PARA2       = { { 0x7213c6ef, 0xcdd4, 0x4d09, {0xa8, 0x9e, 0xf3, 0xeb, 0xeb, 0xe5, 0xf5, 0x65} }, 0x07 }; 
static const PROPERTYKEY MFPKEY_DENOISE_PARA3       = { { 0x7213c6ef, 0xcdd4, 0x4d09, {0xa8, 0x9e, 0xf3, 0xeb, 0xeb, 0xe5, 0xf5, 0x65} }, 0x08 }; 
static const PROPERTYKEY MFPKEY_DENOISE_PARA4       = { { 0x7213c6ef, 0xcdd4, 0x4d09, {0xa8, 0x9e, 0xf3, 0xeb, 0xeb, 0xe5, 0xf5, 0x65} }, 0x09 }; 
static const PROPERTYKEY MFPKEY_DENOISE_PARA5       = { { 0x7213c6ef, 0xcdd4, 0x4d09, {0xa8, 0x9e, 0xf3, 0xeb, 0xeb, 0xe5, 0xf5, 0x65} }, 0x10 }; 
static const PROPERTYKEY MFPKEY_CLUSTERDETECTOR_MAXCLUSTERS        =  { { 0xb79a666d, 0x8a9d, 0x463c, { 0x9d, 0x97, 0xe1, 0xb1, 0x0, 0x45, 0xc1, 0x3a } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_CLUSTERDETECTOR_MINCLUSTERDURATION =  { { 0xb79a666d, 0x8a9d, 0x463c, { 0x9d, 0x97, 0xe1, 0xb1, 0x0, 0x45, 0xc1, 0x3a } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_CLUSTERDETECTOR_MAXCLUSTERDURATION =  { { 0xb79a666d, 0x8a9d, 0x463c, { 0x9d, 0x97, 0xe1, 0xb1, 0x0, 0x45, 0xc1, 0x3a } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_FACEDETECTOR_SKIPFRAMES = { { 0xe1a124a6, 0x4fa8, 0x4ba5, { 0xa2, 0xd8, 0xdc, 0x34, 0x53, 0x6f, 0x74, 0x26 } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_SHOTDETECTOR_TYPE                 = { { 0x7bcc7b0f, 0xdedf, 0x4a68, { 0x96, 0xa2, 0xfc, 0xe0, 0x19, 0xed, 0x95, 0x6f } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_SHOTDETECTOR_CLASSIFICATIONMETHOD = { { 0x7bcc7b0f, 0xdedf, 0x4a68, { 0x96, 0xa2, 0xfc, 0xe0, 0x19, 0xed, 0x95, 0x6f } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_SHOTDETECTOR_GLOBALTHRESHOLD      = { { 0x7bcc7b0f, 0xdedf, 0x4a68, { 0x96, 0xa2, 0xfc, 0xe0, 0x19, 0xed, 0x95, 0x6f } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_SHOTDETECTOR_ADAPTIVETHRESHOLD    = { { 0x7bcc7b0f, 0xdedf, 0x4a68, { 0x96, 0xa2, 0xfc, 0xe0, 0x19, 0xed, 0x95, 0x6f } }, 0x04 }; 
static const PROPERTYKEY MFPKEY_SHOTDETECTOR_ADAPTIVEWINDOWSIZE   = { { 0x7bcc7b0f, 0xdedf, 0x4a68, { 0x96, 0xa2, 0xfc, 0xe0, 0x19, 0xed, 0x95, 0x6f } }, 0x05 }; 
static const PROPERTYKEY MFPKEY_SHOTDETECTOR_MINCLIPWEIGHT        = { { 0x7bcc7b0f, 0xdedf, 0x4a68, { 0x96, 0xa2, 0xfc, 0xe0, 0x19, 0xed, 0x95, 0x6f } }, 0x06 }; 
static const PROPERTYKEY MFPKEY_SHOTDETECTOR_MINCLIPDURATION      = { { 0x7bcc7b0f, 0xdedf, 0x4a68, { 0x96, 0xa2, 0xfc, 0xe0, 0x19, 0xed, 0x95, 0x6f } }, 0x07 }; 
static const PROPERTYKEY MFPKEY_SHOTDETECTOR_MAXCLIPDURATION      = { { 0x7bcc7b0f, 0xdedf, 0x4a68, { 0x96, 0xa2, 0xfc, 0xe0, 0x19, 0xed, 0x95, 0x6f } }, 0x08 }; 
static const PROPERTYKEY MFPKEY_SHOTDETECTOR_MAXCLIPSPERHOUR      = { { 0x7bcc7b0f, 0xdedf, 0x4a68, { 0x96, 0xa2, 0xfc, 0xe0, 0x19, 0xed, 0x95, 0x6f } }, 0x09 }; 
static const PROPERTYKEY MFPKEY_SHOTDETECTOR_PRESERVEMONOCLIPS    = { { 0x7bcc7b0f, 0xdedf, 0x4a68, { 0x96, 0xa2, 0xfc, 0xe0, 0x19, 0xed, 0x95, 0x6f } }, 0x0a }; 
static const PROPERTYKEY MFPKEY_THUMBNAILGENERATOR_SEARCHWINDOWSIZE  = { { 0xd9d7473f, 0x7d68, 0x4226, { 0x98, 0x5c, 0x31, 0x85, 0x2c, 0x4c, 0x9e, 0x74 } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_THUMBNAILGENERATOR_MINCOLORENTROPY   = { { 0xd9d7473f, 0x7d68, 0x4226, { 0x98, 0x5c, 0x31, 0x85, 0x2c, 0x4c, 0x9e, 0x74 } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_THUMBNAILGENERATOR_MAXMOTIONACTIVITY = { { 0xd9d7473f, 0x7d68, 0x4226, { 0x98, 0x5c, 0x31, 0x85, 0x2c, 0x4c, 0x9e, 0x74 } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_THUMBNAILGENERATOR_THUMBNAILWIDTH    = { { 0xd9d7473f, 0x7d68, 0x4226, { 0x98, 0x5c, 0x31, 0x85, 0x2c, 0x4c, 0x9e, 0x74 } }, 0x04 }; 
static const PROPERTYKEY MFPKEY_THUMBNAILGENERATOR_THUMBNAILHEIGHT   = { { 0xd9d7473f, 0x7d68, 0x4226, { 0x98, 0x5c, 0x31, 0x85, 0x2c, 0x4c, 0x9e, 0x74 } }, 0x05 }; 
static const PROPERTYKEY MFPKEY_THUMBNAILGENERATOR_THUMBNAILREADY    = { { 0xd9d7473f, 0x7d68, 0x4226, { 0x98, 0x5c, 0x31, 0x85, 0x2c, 0x4c, 0x9e, 0x74 } }, 0x06 }; 
static const PROPERTYKEY MFPKEY_THUMBNAILGENERATOR_THUMBNAILFILENAME = { { 0xd9d7473f, 0x7d68, 0x4226, { 0x98, 0x5c, 0x31, 0x85, 0x2c, 0x4c, 0x9e, 0x74 } }, 0xff }; 
static const PROPERTYKEY MFPKEY_TOCGENERATOR_TOCREADY              = { { 0x7c109759, 0x3c27, 0x42ef, { 0xa6, 0xa3, 0xce, 0xde, 0xf7, 0x5a, 0x35, 0xe9 } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_TOCGENERATOR_TOCOBJECT             = { { 0x7c109759, 0x3c27, 0x42ef, { 0xa6, 0xa3, 0xce, 0xde, 0xf7, 0x5a, 0x35, 0xe9 } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_TOCGENERATOR_SHOTDETECTOR_ON       = { { 0x7c109759, 0x3c27, 0x42ef, { 0xa6, 0xa3, 0xce, 0xde, 0xf7, 0x5a, 0x35, 0xe9 } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_TOCGENERATOR_CLUSTERDETECTOR_ON    = { { 0x7c109759, 0x3c27, 0x42ef, { 0xa6, 0xa3, 0xce, 0xde, 0xf7, 0x5a, 0x35, 0xe9 } }, 0x04 }; 
static const PROPERTYKEY MFPKEY_TOCGENERATOR_THUMBNAILGENERATOR_ON = { { 0x7c109759, 0x3c27, 0x42ef, { 0xa6, 0xa3, 0xce, 0xde, 0xf7, 0x5a, 0x35, 0xe9 } }, 0x05 }; 
static const PROPERTYKEY MFPKEY_TOCGENERATOR_FEATUREEXTRACTOR_ON   = { { 0x7c109759, 0x3c27, 0x42ef, { 0xa6, 0xa3, 0xce, 0xde, 0xf7, 0x5a, 0x35, 0xe9 } }, 0x06 }; 
static const PROPERTYKEY MFPKEY_TOCGENERATOR_FACEDETECTOR_ON       = { { 0x7c109759, 0x3c27, 0x42ef, { 0xa6, 0xa3, 0xce, 0xde, 0xf7, 0x5a, 0x35, 0xe9 } }, 0x07 }; 
static const PROPERTYKEY MFPKEY_TOCGENERATOR_USEENDSIGNAL          = { { 0x7c109759, 0x3c27, 0x42ef, { 0xa6, 0xa3, 0xce, 0xde, 0xf7, 0x5a, 0x35, 0xe9 } }, 0xfa }; 
static const PROPERTYKEY MFPKEY_TOCGENERATOR_ENDSIGNAL             = { { 0x7c109759, 0x3c27, 0x42ef, { 0xa6, 0xa3, 0xce, 0xde, 0xf7, 0x5a, 0x35, 0xe9 } }, 0xfb }; 
static const PROPERTYKEY MFPKEY_TOCGENERATOR_ENDTIME               = { { 0x7c109759, 0x3c27, 0x42ef, { 0xa6, 0xa3, 0xce, 0xde, 0xf7, 0x5a, 0x35, 0xe9 } }, 0xfc }; 
static const PROPERTYKEY MFPKEY_TOCGENERATOR_CURRENTTIME           = { { 0x7c109759, 0x3c27, 0x42ef, { 0xa6, 0xa3, 0xce, 0xde, 0xf7, 0x5a, 0x35, 0xe9 } }, 0xfd }; 
static const PROPERTYKEY MFPKEY_TOCGENERATOR_PROCESSEDFRAMES       = { { 0x7c109759, 0x3c27, 0x42ef, { 0xa6, 0xa3, 0xce, 0xde, 0xf7, 0x5a, 0x35, 0xe9 } }, 0xfe }; 
static const PROPERTYKEY MFPKEY_TOCGENERATOR_INDEXFILENAME         = { { 0x7c109759, 0x3c27, 0x42ef, { 0xa6, 0xa3, 0xce, 0xde, 0xf7, 0x5a, 0x35, 0xe9 } }, 0xff }; 
static const PROPERTYKEY MFPKEY_DXVA_ENABLED = { { 0x58e28605, 0x1d51, 0x48ed, { 0xa3, 0xeb, 0xf, 0x9b, 0xaf, 0x78, 0x5f, 0xbd } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_FI_SUPPORTED = { { 0x5ce18788, 0xb992, 0x49a7, { 0xa4, 0xf1, 0x60, 0xea, 0x21, 0xca, 0xa5, 0x5f } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_FI_ENABLED = { { 0xe020c4ca, 0x3bdd, 0x40ec, { 0xbc, 0xf4, 0x40, 0x39, 0xb1, 0x45, 0xe, 0xb8 } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_DECODER_DEINTERLACING = { { 0xc6281f, 0x4be6, 0x4e44, { 0x9e, 0xd8, 0x9e, 0xc5, 0x42, 0x23, 0x16, 0xe4 } }, 0x04 }; 
static const PROPERTYKEY MFPKEY_POSTPROCESSMODE = { { 0xc6281f, 0x4be6, 0x4e44, { 0x9e, 0xd8, 0x9e, 0xc5, 0x42, 0x23, 0x16, 0xe4 } }, 0x05 }; 
static const PROPERTYKEY MFPKEY_NUMTHREADSDEC = { { 0xc6281f, 0x4be6, 0x4e44, { 0x9e, 0xd8, 0x9e, 0xc5, 0x42, 0x23, 0x16, 0xe4 } }, 0x06 }; 
static const PROPERTYKEY MFPKEY_AVDecVideoSWPowerLevel = { { 0xfb5d2347, 0x4dd8, 0x4509, {0xae, 0xd0, 0xdb, 0x5f, 0xa9, 0xaa, 0x93, 0xf4 } }, 0x08 }; 
static const PROPERTYKEY MFPKEY_AVGFRAMERATE = { { 0x41d700d6, 0x95b1, 0x4e3f, { 0xb7, 0x59, 0x2d, 0x66, 0xd8, 0xc7, 0xad, 0xa2 } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_BUFFERFULLNESSINFIRSTBYTE = { { 0xb69dc3c5, 0x64c4, 0x4757, { 0x99, 0xcb, 0x5d, 0x58, 0xf, 0xd5, 0x65, 0x9e } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_PASSESRECOMMENDED = { { 0x38bdceea, 0x393e, 0x4f9a, { 0x8d, 0xc3, 0x80, 0x2c, 0xc4, 0x5, 0x83, 0x8f } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_DECODERCOMPLEXITYPROFILE = { { 0xc0d912d6, 0x14da, 0x4d31, { 0x8d, 0x83, 0xd1, 0x8, 0x91, 0x5e, 0x8d, 0x77 } }, 0x04 }; 
static const PROPERTYKEY MFPKEY_TOTALFRAMES = { { 0xce5f1e3c, 0xd3d4, 0x4c3f, { 0x88, 0xc8, 0x1, 0xe9, 0x89, 0xd9, 0x98, 0xd2 } }, 0x05 }; 
static const PROPERTYKEY MFPKEY_CODEDFRAMES = { { 0x62872b55, 0xfe0e, 0x4930, { 0xa6, 0xd2, 0xcc, 0xaa, 0x37, 0xe8, 0xf5, 0x35 } }, 0x06 }; 
static const PROPERTYKEY MFPKEY_ZEROBYTEFRAMES = { { 0x8f04aba4, 0x313d, 0x40fb, { 0x80, 0x31, 0x31, 0x51, 0x78, 0x13, 0xd9, 0xef } }, 0x07 }; 
static const PROPERTYKEY MFPKEY_ENDOFPASS = { { 0xb2030f2a, 0x8bbc, 0x46f8, { 0xa6, 0x4b, 0xa9, 0x8f, 0xf7, 0xfc, 0xf0, 0x2a } }, 0x08 }; 
static const PROPERTYKEY MFPKEY_DATARATE = { { 0xe0db0807, 0x8003, 0x4880, { 0xac, 0x11, 0x61, 0xb7, 0x3f, 0x33, 0xdc, 0x60 } }, 0x09 }; 
static const PROPERTYKEY MFPKEY_KEYDIST = { { 0x18d6f8c5, 0x2416, 0x4d7b, { 0x90, 0xd7, 0x9f, 0x3f, 0x21, 0xe7, 0x52, 0xb4 } }, 0x0a }; 
static const PROPERTYKEY MFPKEY_CRISP = { { 0x2985f772, 0x3af2, 0x4d15, { 0x8c, 0xfa, 0x8a, 0x96, 0x2f, 0xf3, 0x20, 0x40 } }, 0x0b }; 
static const PROPERTYKEY MFPKEY_FOURCC = { { 0x593e3f2e, 0xf84d, 0x4e85, { 0xb6, 0x8d, 0xf6, 0x69, 0x40, 0xe, 0xda, 0xbc } }, 0x0c }; 
static const PROPERTYKEY MFPKEY_VIDEOWINDOW = { { 0xc1c96060, 0x76f0, 0x47d4, { 0xa8, 0x75, 0x5b, 0xdd, 0xa9, 0xd, 0xf5, 0xe9 } }, 0x0d }; 
static const PROPERTYKEY MFPKEY_FRAMECOUNT = { { 0x75028eb4, 0x4853, 0x44d3, { 0x88, 0xa3, 0xe4, 0x99, 0xf8, 0x9d, 0x22, 0x7f } }, 0x0e }; 
static const PROPERTYKEY MFPKEY_LIVEENCODE = { { 0x3ffa1e60, 0x5514, 0x4634, { 0x86, 0xe6, 0x1f, 0x3b, 0x7c, 0x54, 0x51, 0x43 } }, 0x0f }; 
static const PROPERTYKEY MFPKEY_COMPLEXITY = { { 0x44fa08c7, 0x92f5, 0x45dc, { 0x83, 0x76, 0x8d, 0x1d, 0x32, 0x4c, 0x65, 0x2a } }, 0x10 }; 
static const PROPERTYKEY MFPKEY_COMPLEXITYEX = { { 0xd6e48f93, 0xfd47, 0x47a3, { 0x92, 0x62, 0x8a, 0xef, 0xb5, 0x53, 0x3, 0x32 } }, 0x11 }; 
static const PROPERTYKEY MFPKEY_ASFOVERHEADPERFRAME = { { 0xeac7502, 0x1957, 0x4beb, { 0x91, 0x4d, 0x88, 0x5f, 0x85, 0xe7, 0x54, 0x36 } }, 0x12 }; 
static const PROPERTYKEY MFPKEY_PASSESUSED = { { 0xb1653ac1, 0xcb7d, 0x43ee, { 0x84, 0x54, 0x3f, 0x9d, 0x81, 0x1b, 0x3, 0x31 } }, 0x13 }; 
static const PROPERTYKEY MFPKEY_VBRENABLED = { { 0xe48d9459, 0x6abe, 0x4eb5, { 0x92, 0x11, 0x60, 0x8, 0xc, 0x1a, 0xb9, 0x84 } }, 0x14 }; 
static const PROPERTYKEY MFPKEY_VBRQUALITY = { { 0xf97b3f3a, 0x9eff, 0x4ac9, { 0x82, 0x47, 0x35, 0xb3, 0xe, 0xb9, 0x25, 0xf4 } }, 0x15 }; 
static const PROPERTYKEY MFPKEY_RAVG = { { 0x14b2aae6, 0x2987, 0x460a, { 0x8b, 0x22, 0x9c, 0x7, 0x7c, 0x55, 0xd0, 0x5e } }, 0x16 }; 
static const PROPERTYKEY MFPKEY_BAVG = { { 0x10174e76, 0xe0ca, 0x4a39, { 0x94, 0x8c, 0x85, 0x10, 0xc2, 0x32, 0x32, 0x76 } }, 0x17 }; 
static const PROPERTYKEY MFPKEY_RMAX = { { 0x7d8dd246, 0xaaf4, 0x4a24, { 0x81, 0x66, 0x19, 0x39, 0x6b, 0x6, 0xef, 0x69 } }, 0x18 }; 
static const PROPERTYKEY MFPKEY_BMAX = { { 0xff365211, 0x21b6, 0x4134, { 0xab, 0x7c, 0x52, 0x39, 0x3a, 0x8f, 0x80, 0xf6 } }, 0x19 }; 
static const PROPERTYKEY MFPKEY_INTERLACEDCODINGENABLED = { { 0x56976073, 0x6c3, 0x4b3b, { 0xad, 0x41, 0xb7, 0x41, 0x7f, 0xce, 0x84, 0x74 } }, 0x1a }; 
static const PROPERTYKEY MFPKEY_PRODUCEDUMMYFRAMES = { { 0x61714bc6, 0x8a1, 0x49d1, { 0xb8, 0x27, 0xa3, 0x3a, 0xad, 0xa9, 0x55, 0x26 } }, 0x1b }; 
static const PROPERTYKEY MFPKEY_DECODERCOMPLEXITYREQUESTED = { { 0xb0d7d4a7, 0x422b, 0x44c3, { 0x97, 0xb4, 0xb9, 0x76, 0xc, 0xce, 0xee, 0xa9 } }, 0x1c }; 
static const PROPERTYKEY MFPKEY_DROPPEDFRAMES = { { 0xbdb5afd3, 0x4027, 0x4882, { 0x80, 0x6c, 0x41, 0x62, 0xe4, 0xa7, 0xa3, 0xf0 } }, 0x1d }; 
static const PROPERTYKEY MFPKEY_CODEDNONZEROFRAMES = { { 0x7adf5b69, 0x1e3f, 0x42d3, { 0x99, 0x1d, 0xf8, 0x1e, 0xc, 0xeb, 0xe9, 0x3e } }, 0x1e }; 
static const PROPERTYKEY MFPKEY_QPPERFRAME = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x1f }; 
static const PROPERTYKEY MFPKEY_VOLHEADERFORREENCODE = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x21 }; 
static const PROPERTYKEY MFPKEY_REENCDURATION        = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x22 }; 
static const PROPERTYKEY MFPKEY_REENCSTARTBUFFERSIZE = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x23 }; 
static const PROPERTYKEY MFPKEY_REENCENDBUFFERSIZE   = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x24 }; 
static const PROPERTYKEY MFPKEY_REENCQPREF           = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x25 }; 
static const PROPERTYKEY MFPKEY_DENOISEOPTION        = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x26 }; 
static const PROPERTYKEY MFPKEY_FULLFRAMERATE       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x2d }; 
static const PROPERTYKEY MFPKEY_MOTIONSEARCHRANGE       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x2e }; 
static const PROPERTYKEY MFPKEY_DELTAMVRANGEINDEX       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x2f }; 
static const PROPERTYKEY MFPKEY_NUMBFRAMES       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x30 }; 
static const PROPERTYKEY MFPKEY_RDSUBPIXELSEARCH       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x31 }; 
static const PROPERTYKEY MFPKEY_BDELTAQP       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x32 }; 
static const PROPERTYKEY MFPKEY_FORCEFRAMEWIDTH       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x33 }; 
static const PROPERTYKEY MFPKEY_FORCEFRAMEHEIGHT       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x34 }; 
static const PROPERTYKEY MFPKEY_RANGEREDUX       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x35 }; 
static const PROPERTYKEY MFPKEY_LOOKAHEAD       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x36 }; 
static const PROPERTYKEY MFPKEY_VIDEOSCALING       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x37 }; 
static const PROPERTYKEY MFPKEY_PERCEPTUALOPTLEVEL       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x38 }; 
static const PROPERTYKEY MFPKEY_FORCEMEDIANSETTING       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x39 }; 
static const PROPERTYKEY MFPKEY_NUMTHREADS       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x3a }; 
static const PROPERTYKEY MFPKEY_LOOPFILTER       = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x3b }; 
static const PROPERTYKEY MFPKEY_NOISEEDGEREMOVAL = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x3c }; 
static const PROPERTYKEY MFPKEY_VTYPE            = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x3d }; 
static const PROPERTYKEY MFPKEY_CLOSEDENTRYPOINT            = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x3f }; 
static const PROPERTYKEY MFPKEY_MOTIONSEARCHLEVEL           = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x40 }; 
static const PROPERTYKEY MFPKEY_MOTIONMATCHMETHOD           = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x41 }; 
static const PROPERTYKEY MFPKEY_MACROBLOCKMODECOSTMETHOD    = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x42 }; 
static const PROPERTYKEY MFPKEY_COMPRESSIONOPTIMIZATIONTYPE = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x43 }; 
static const PROPERTYKEY MFPKEY_PERIODICALSPDISTANCE        = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x46 }; 
static const PROPERTYKEY MFPKEY_ENCODERCOMPLEXITY           = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x47 }; 
static const PROPERTYKEY MFPKEY_USERDATASIZE                = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x48 }; 
static const PROPERTYKEY MFPKEY_LETTERBOXPRESENT            = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x49 }; 
static const PROPERTYKEY MFPKEY_SCENECHANGE                 = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x4a }; 
static const PROPERTYKEY MFPKEY_VARIABLEGOP                 = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x4b }; 
static const PROPERTYKEY MFPKEY_SCENECHANGEI                = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x4c }; 
static const PROPERTYKEY MFPKEY_LOOKAHEADRC                 = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x4d }; 
static const PROPERTYKEY MFPKEY_DQUANTOPTION                = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x4e }; 
static const PROPERTYKEY MFPKEY_DQUANTSTRENGTH              = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x4f }; 
static const PROPERTYKEY MFPKEY_FORCEOVERLAP                = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x50 }; 
static const PROPERTYKEY MFPKEY_MOTIONVECTORCOSTMETHOD      = { { 0x4e91bf89, 0x665a, 0x49da, { 0xbb, 0x94, 0x88, 0xc5, 0x50, 0xcf, 0xcd, 0x28 } }, 0x51 }; 
static const PROPERTYKEY MFPKEY_CLIP_XORIG = { { 0x716fe5c8, 0x755c, 0x482f, { 0x8d, 0xf3, 0xb3, 0x1d, 0x53, 0x59, 0xf0, 0xd6 } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_CLIP_YORIG = { { 0x716fe5c8, 0x755c, 0x482f, { 0x8d, 0xf3, 0xb3, 0x1d, 0x53, 0x59, 0xf0, 0xd6 } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_CLIP_WIDTH = { { 0x716fe5c8, 0x755c, 0x482f, { 0x8d, 0xf3, 0xb3, 0x1d, 0x53, 0x59, 0xf0, 0xd6 } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_CLIP_HEIGHT = { { 0x716fe5c8, 0x755c, 0x482f, { 0x8d, 0xf3, 0xb3, 0x1d, 0x53, 0x59, 0xf0, 0xd6 } }, 0x04 }; 
static const PROPERTYKEY MFPKEY_FI_FRAMERATE_VALU_SRC = { { 0x305bca55, 0x1e5b, 0x428e, { 0xa9, 0x4c, 0x65, 0xb9, 0x4d, 0x2, 0x64, 0xed } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_FI_FRAMERATE_SCAL_SRC = { { 0x305bca55, 0x1e5b, 0x428e, { 0xa9, 0x4c, 0x65, 0xb9, 0x4d, 0x2, 0x64, 0xed } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_FI_FRAMERATE_VALU_DST = { { 0x305bca55, 0x1e5b, 0x428e, { 0xa9, 0x4c, 0x65, 0xb9, 0x4d, 0x2, 0x64, 0xed } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_FI_FRAMERATE_SCAL_DST = { { 0x305bca55, 0x1e5b, 0x428e, { 0xa9, 0x4c, 0x65, 0xb9, 0x4d, 0x2, 0x64, 0xed } }, 0x04 }; 
static const PROPERTYKEY MFPKEY_FI_ALLOWED = { { 0x305bca55, 0x1e5b, 0x428e, { 0xa9, 0x4c, 0x65, 0xb9, 0x4d, 0x2, 0x64, 0xed } }, 0x05 }; 
static const PROPERTYKEY MFPKEY_FI_COMPLEXITY = { { 0x305bca55, 0x1e5b, 0x428e, { 0xa9, 0x4c, 0x65, 0xb9, 0x4d, 0x2, 0x64, 0xed } }, 0x06 }; 
static const PROPERTYKEY MFPKEY_RESIZE_SRC_LEFT   = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_RESIZE_SRC_TOP    = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_RESIZE_SRC_WIDTH  = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_RESIZE_SRC_HEIGHT = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x04 }; 
static const PROPERTYKEY MFPKEY_RESIZE_DST_LEFT   = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x05 }; 
static const PROPERTYKEY MFPKEY_RESIZE_DST_TOP    = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x06 }; 
static const PROPERTYKEY MFPKEY_RESIZE_DST_WIDTH  = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x07 }; 
static const PROPERTYKEY MFPKEY_RESIZE_DST_HEIGHT = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x08 }; 
static const PROPERTYKEY MFPKEY_RESIZE_QUALITY    = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x09 }; 
static const PROPERTYKEY MFPKEY_RESIZE_INTERLACE  = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x0a }; 
static const PROPERTYKEY MFPKEY_RESIZE_PANSCANAPX      = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x0b }; 
static const PROPERTYKEY MFPKEY_RESIZE_PANSCANAPY      = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x0c }; 
static const PROPERTYKEY MFPKEY_RESIZE_PANSCANAPWIDTH  = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x0d }; 
static const PROPERTYKEY MFPKEY_RESIZE_PANSCANAPHEIGHT = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x0e }; 
static const PROPERTYKEY MFPKEY_RESIZE_GEOMAPX      = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x0f }; 
static const PROPERTYKEY MFPKEY_RESIZE_GEOMAPY      = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x10 }; 
static const PROPERTYKEY MFPKEY_RESIZE_GEOMAPWIDTH  = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x11 }; 
static const PROPERTYKEY MFPKEY_RESIZE_GEOMAPHEIGHT = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x12 }; 
static const PROPERTYKEY MFPKEY_RESIZE_MINAPX      = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x13 }; 
static const PROPERTYKEY MFPKEY_RESIZE_MINAPY      = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x14 }; 
static const PROPERTYKEY MFPKEY_RESIZE_MINAPWIDTH  = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x15 }; 
static const PROPERTYKEY MFPKEY_RESIZE_MINAPHEIGHT = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x16 }; 
static const PROPERTYKEY MFPKEY_PIXELASPECTRATIO = { { 0x6612a6bc, 0xe57d, 0x407d, { 0xa9, 0x58, 0x28, 0x5d, 0xf0, 0xd9, 0xb4, 0x0 } }, 0x17 }; 
static const PROPERTYKEY MFPKEY_COLORCONV_SRCLEFT = { { 0xdc9100be, 0x1228, 0x416c, { 0x99, 0x48, 0x6f, 0x38, 0xf4, 0x79, 0x65, 0x4f } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_COLORCONV_SRCTOP  = { { 0xdc9100be, 0x1228, 0x416c, { 0x99, 0x48, 0x6f, 0x38, 0xf4, 0x79, 0x65, 0x4f } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_COLORCONV_DSTLEFT = { { 0xdc9100be, 0x1228, 0x416c, { 0x99, 0x48, 0x6f, 0x38, 0xf4, 0x79, 0x65, 0x4f } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_COLORCONV_DSTTOP  = { { 0xdc9100be, 0x1228, 0x416c, { 0x99, 0x48, 0x6f, 0x38, 0xf4, 0x79, 0x65, 0x4f } }, 0x04 }; 
static const PROPERTYKEY MFPKEY_COLORCONV_WIDTH   = { { 0xdc9100be, 0x1228, 0x416c, { 0x99, 0x48, 0x6f, 0x38, 0xf4, 0x79, 0x65, 0x4f } }, 0x05 }; 
static const PROPERTYKEY MFPKEY_COLORCONV_HEIGHT  = { { 0xdc9100be, 0x1228, 0x416c, { 0x99, 0x48, 0x6f, 0x38, 0xf4, 0x79, 0x65, 0x4f } }, 0x06 }; 
static const PROPERTYKEY MFPKEY_COLORCONV_MODE    = { { 0xdc9100be, 0x1228, 0x416c, { 0x99, 0x48, 0x6f, 0x38, 0xf4, 0x79, 0x65, 0x4f } }, 0x07 }; 
static const PROPERTYKEY MFPKEY_DEINTERLACE_PROCESSTYPE     = { { 0x6141f4c3, 0xd3a2, 0x48a9, { 0x96, 0xac, 0x2f, 0x0, 0x14, 0x17, 0x6c, 0x26 } }, 0x01 }; 
static const PROPERTYKEY MFPKEY_DEINTERLACE_TELECINEPATTERN = { { 0x6141f4c3, 0xd3a2, 0x48a9, { 0x96, 0xac, 0x2f, 0x0, 0x14, 0x17, 0x6c, 0x26 } }, 0x02 }; 
static const PROPERTYKEY MFPKEY_DEINTERLACE_LASTFRAME       = { { 0x6141f4c3, 0xd3a2, 0x48a9, { 0x96, 0xac, 0x2f, 0x0, 0x14, 0x17, 0x6c, 0x26 } }, 0x03 }; 
static const PROPERTYKEY MFPKEY_DEINTERLACE_DETELECINE_FLAG = { { 0x6141f4c3, 0xd3a2, 0x48a9, { 0x96, 0xac, 0x2f, 0x0, 0x14, 0x17, 0x6c, 0x26 } }, 0x04 }; 
static const PROPERTYKEY MFPKEY_DEINTERLACE_SMOOTHLEVEL     = { { 0x6141f4c3, 0xd3a2, 0x48a9, { 0x96, 0xac, 0x2f, 0x0, 0x14, 0x17, 0x6c, 0x26 } }, 0x05 }; 
static const PROPERTYKEY MFPKEY_DEINTERLACE_EDGETHRESHOLD   = { { 0x6141f4c3, 0xd3a2, 0x48a9, { 0x96, 0xac, 0x2f, 0x0, 0x14, 0x17, 0x6c, 0x26 } }, 0x06 }; 
static const PROPERTYKEY MFPKEY_DVDEC_SIZE = { { 0x75f2421a, 0xe73a, 0x45b3, { 0xae, 0xf0, 0x91, 0x3c, 0x66, 0x84, 0x64, 0x61 } }, 0x00 }; 
static const PROPERTYKEY MFPKEY_DVENC_FORMAT = { { 0xf449a927, 0x7b22, 0x46ef, {0xb2, 0xe7, 0x4d, 0x2b, 0x72, 0x8b, 0x69, 0x9c } }, 0x00 }; 
#endif // NO_MF_PROPKEYS
#define	g_wszWMVCDatarate	( L"_DATARATE" )

#define	g_wszWMVCKeyframeDistance	( L"_KEYDIST" )

#define	g_wszWMVCCrisp	( L"_CRISP" )

#define	g_wszWMVCDefaultCrisp	( L"_DEFAULTCRISP" )

#define	g_wszWMVCFOURCC	( L"_FOURCC" )

#define	g_wszWMVCTotalWindow	( L"_TOTALWINDOW" )

#define	g_wszWMVCVideoWIndow	( L"_VIDEOWINDOW" )

#define	g_wszWMVCFrameCount	( L"_FRAMECOUNT" )

#define	g_wszWMVCLiveEncode	( L"_LIVEENCODE" )

#define	g_wszWMVCComplexityMode	( L"_COMPLEXITY" )

#define	g_wszWMVCComplexityEx	( L"_COMPLEXITYEX" )

#define	g_wszWMVCComplexityMax	( L"_COMPLEXITYEXMAX" )

#define	g_wszWMVCComplexityLive	( L"_COMPLEXITYEXLIVE" )

#define	g_wszWMVCComplexityOffline	( L"_COMPLEXITYEXOFFLINE" )

#define	g_wszWMVCPacketOverhead	( L"_ASFOVERHEADPERFRAME" )

#define	g_wszWMVCLegacy411InterlacedFormat	( L"_LEGACY411INTERLACEDFORMAT" )

#define	g_wszWMVCPassesRecommended	( L"_PASSESRECOMMENDED" )

#define	g_wszWMVCPassesUsed	( L"_PASSESUSED" )

#define	g_wszWMVCEndOfPass	( L"_ENDOFPASS" )

#define	g_wszWMVCFrameInterpolationSupported	( L"_FRAMEINTERPOLATIONSUPPORTED" )

#define	g_wszWMVCFrameInterpolationEnabled	( L"_FRAMEINTERPOLATIONENABLED" )

#define	g_wszWMVCQPPerFrame	( L"_QPPERFRAME" )

#define	g_wszWMVCReencDuration	( L"_REENCDURATION" )

#define	g_wszWMVCReencStartBufferSize	( L"_REENCSTARTBUFFERSIZE" )

#define	g_wszWMVCReencEndBufferSize	( L"_REENCENDBUFFERSIZE" )

#define	g_wszWMVCReencQPRef	( L"_REENCQPREF" )

#define	g_wszWMVCDenoiseOption	( L"_DENOISEOPTION" )

#define	g_wszWMVCMirrorDisplayOn	( L"_MIRRORDISPLAYON" )

#define	g_wszWMVCChangeFrameRate	( L"_CHANGEFRAMERATE" )

#define	g_wszWMVCChangeBitRate	( L"_CHANGEBITRATE" )

#define	g_wszWMVCChangeMaxBitRate	( L"_CHANGEMAXBITRATE" )

#define	g_wszWMVCFullFrameRate	( L"_FULLFRAMERATE" )

#define	g_wszWMVCMotionSearchRange	( L"_MOTIONSEARCHRANGE" )

#define	g_wszWMVCDeltaMVRangeIndex	( L"_DELTAMVRANGEINDEX" )

#define	g_wszWMVCNumBFrames	( L"_NUMBFRAMES" )

#define	g_wszWMVCRDSubpixelSearch	( L"_RDSUBPIXELSEARCH" )

#define	g_wszWMVCBDeltaQP	( L"_BDELTAQP" )

#define	g_wszWMVCForceFrameWidth	( L"_FORCEFRAMEWIDTH" )

#define	g_wszWMVCForceFrameHeight	( L"_FORCEFRAMEHEIGHT" )

#define	g_wszWMVCRangeRedux	( L"_RANGEREDUX" )

#define	g_wszWMVCLookAhead	( L"_LOOKAHEAD" )

#define	g_wszWMVCVideoScaling	( L"_VIDEOSCALING" )

#define	g_wszWMVCPerceptualOptLevel	( L"_PERCEPTUALOPTLEVEL" )

#define	g_wszWMVCForceMedianSetting	( L"_FORCEMEDIANSETTING" )

#define	g_wszWMVCNumThreads	( L"_NUMTHREADS" )

#define	g_wszWMVCLoopFilter	( L"_LOOPFILTER" )

#define	g_wszWMVCNoiseEdgeRemoval	( L"_NOISEEDGEREMOVAL" )

#define	g_wszWMVCVType	( L"_VTYPE" )

#define	g_wszWMVCMotionSearchLevel	( L"_MOTIONSEARCHLEVEL" )

#define	g_wszWMVCMotionMatchMethod	( L"_MOTIONMATCHMETHOD" )

#define	g_wszWMVCMacroblockModeCostMethod	( L"_MACROBLOCKMODECOSTMETHOD" )

#define	g_wszWMVCCompressionOptimizationType	( L"_COMPRESSIONOPTIMIZATIONTYPE" )

#define	g_wszWMVCPeriodicalSPDistance	( L"_PERIODICALSPDISTANCE" )

#define	g_wszWMVCQueryTimeStampTag	( L"_QUERYTIMESTAMPTAG" )

#define	g_wszWMVCSupportOneInMultiOut	( L"_SUPPORTONEINMULTIOUT" )

#define	g_wszWMVCEncodingWidth	( L"_ENCODINGWIDTH" )

#define	g_wszWMVCEncodingHeight	( L"_ENCODINGHEIGHT" )

#define	g_wszWMVCThreadAffinityMask	( L"_THREADAFFINITYMASK" )

#define	g_wszWMVCDecoderForceNoResizeOutput	( L"_FORCENORESIZE" )

#define	g_wszWMACInputFormatName	( L"_INPUTFORMATNAME" )

#define	g_wszWMACSourceFormatTag	( L"_SOURCEFORMATTAG" )

#define	g_wszWMVCVBREnabled	( L"_VBRENABLED" )

#define	g_wszWMVCVBRQuality	( L"_VBRQUALITY" )

#define	g_wszWMVCAvgBitrate	( L"_RAVG" )

#define	g_wszWMVCMaxBitrate	( L"_RMAX" )

#define	g_wszWMVCBAvg	( L"_BAVG" )

#define	g_wszWMVCBMax	( L"_BMAX" )

#define	g_wszWMVCTotalFrames	( L"_TOTALFRAMES" )

#define	g_wszWMVCCodedFrames	( L"_CODEDFRAMES" )

#define	g_wszWMVCAvgFrameRate	( L"_AVGFRAMERATE" )

#define	g_wszWMVCDecoderComplexityProfile	( L"_DECODERCOMPLEXITYPROFILE" )

#define	g_wszWMVCDecoderComplexityRequested	( L"_DECODERCOMPLEXITYREQUESTED" )

#define	g_wszWMVCBufferFullnessInFirstByte	( L"_BUFFERFULLNESSINFIRSTBYTE" )

#define	g_wszWMACPeakPCMValue	( L"PeakValue" )

#define	g_wszWMACAvgPCMValue	( L"AverageLevel" )

#define	g_wszWMADRCAverageReference	( L"WMADRCAverageReference" )

#define	g_wszWMADRCPeakReference	( L"WMADRCPeakReference" )

#define	g_wszWMADRCAverageTarget	( L"WMADRCAverageTarget" )

#define	g_wszWMADRCPeakTarget	( L"WMADRCPeakTarget" )

#define	g_wszWMACHiResOutput	( L"_HIRESOUTPUT" )

#define	g_wszWMACAvgBytesPerSec	( L"AvgBytesPerSec" )

#define	g_wszWMACSpeakerConfig	( L"SpeakerConfig" )

#define	g_wszWMACMixTable	( L"MixTable" )

#define	g_wszWMACDRCSetting	( L"DynamicRangeControl" )

#define	g_wszWMVCWatermarkConfig	( L"WatermarkConfig" )

#define	g_wszWMVCWatermarkDelay	( L"WatermarkDelay" )

#define	g_wszWMVCInterlacedCodingEnabled	( L"_INTERLACEDCODINGENABLED" )

#define	g_wszWMVCProduceDummyFrames	( L"_PRODUCEDUMMYFRAMES" )

#define	g_wszWMVCDecoderDeinterlacing	( L"_DECODERDEINTERLACING" )

#define	g_wszWMACOriginalWaveFormat	( L"_ORIGINALWAVEFORMAT" )

#define	g_wszWMACIncludeNumPasses	( L"_INCLUDENUMPASSES" )

#define	g_wszWMVCInverseTelecinedInput	( L"_INVERSETELECINEDINPUT" )

#define	g_wszWMVCForcePostProcessMode	( L"_POSTPROCESSMODE" )

#define	g_wszWMVCNumThreadsDec	( L"_NUMTHREADSDEC" )

#define	g_wszWMVCClosedEntryPoint	( L"_CLOSEDENTRYPOINT" )

#define	g_wszWMVCQueryTimeStampTagDec	( L"_QUERYTIMESTAMPTAGDEC" )

#define	g_wszWMVCSupportOneInMultiOut_Dec	( L"_SUPPORTONEINMULTIOUT_DEC" )

#define	g_wszWMVCEncodedWidth_Dec	( L"_ENCODEDWIDTH_DEC" )

#define	g_wszWMVCEncodedHeight_Dec	( L"_ENCODEDHEIGHT_DEC" )

#define	g_wszWMVCEncodercomplexity	( L"_ENCODERCOMPLEXITY" )

#define	g_wszWMVCUserdatasize	( L"_USERDATASIZE" )

#define	g_wszWMVCLetterboxpresent	( L"_LETTERBOXPRESENT" )

#define	g_wszWMVCScenechange	( L"_SCENECHANGE" )

#define	g_wszWMVCVariableGOP	( L"_VARIABLEGOP" )

#define	g_wszWMVCSceneChangeI	( L"_SCENECHANGEI" )

#define	g_wszWMVCLookaheadRC	( L"_LOOKAHEADRC" )

#define	g_wszWMVCDquantOption	( L"_DQUANTOPTION" )

#define	g_wszWMVCDquantStrength	( L"_DQUANTSTRENGTH" )

#define	g_wszWMVCForceOverlap	( L"_FORCEOVERLAP" )

#define	g_wszWMVCMotionVectorCostMethod	( L"_MOTIONVECTORCOSTMETHOD" )

#define	g_wszWMVForceStartCode	( L"_FORCESTARTCODE" )

#define	g_wszWMVCHonorKeyFrameSettings	( L"_HONORKEYSETTINGS" )

#define	g_wszWMVCHonorTSFrameQP	( L"_HONORTSFRAMEQP" )

#define	g_wszWMVDisplayWidth	( L"_DisplayWidth" )

#define	g_wszWMVDisplayHeight	( L"_DisplayHeight" )

#define	g_wszWMVEncodeWidth	( L"_EncodeWidth" )

#define	g_wszWMVEncodeHeight	( L"_EncodeHeight" )

#define	g_wszWMVTranscodeMode	( L"_TranscodeMode" )

#define	g_wszWMVAspectHorizSize	( L"_AspectHorizSize" )

#define	g_wszWMVAspectVertSize	( L"_AspectVertSize" )

#define	g_wszWMVTimeStampFixed	( L"TSFixed" )

#define	g_wszWMACMusicSpeechClassMode	( L"MusicSpeechClassMode" )

#define	g_wszWMACVoiceBuffer	( L"BufferWindow" )

#define	g_wszWMACVoiceEDL	( L"_EDL" )

#define	g_wszSpeechFormatCaps	( L"SpeechFormatCap" )

typedef 
enum MF_AUVRHP_ROOMMODEL
    {	VRHP_SMALLROOM	= 0,
	VRHP_MEDIUMROOM	= ( VRHP_SMALLROOM + 1 ) ,
	VRHP_BIGROOM	= ( VRHP_MEDIUMROOM + 1 ) ,
	VRHP_CUSTUMIZEDROOM	= ( VRHP_BIGROOM + 1 ) 
    } 	MF_AUVRHP_ROOMMODEL;

#define AEC_MAX_SYSTEM_MODES 6
typedef 
enum AEC_SYSTEM_MODE
    {	SINGLE_CHANNEL_AEC	= 0,
	ADAPTIVE_ARRAY_ONLY	= ( SINGLE_CHANNEL_AEC + 1 ) ,
	OPTIBEAM_ARRAY_ONLY	= ( ADAPTIVE_ARRAY_ONLY + 1 ) ,
	ADAPTIVE_ARRAY_AND_AEC	= ( OPTIBEAM_ARRAY_ONLY + 1 ) ,
	OPTIBEAM_ARRAY_AND_AEC	= ( ADAPTIVE_ARRAY_AND_AEC + 1 ) ,
	SINGLE_CHANNEL_NSAGC	= ( OPTIBEAM_ARRAY_AND_AEC + 1 ) ,
	MODE_NOT_SET	= ( SINGLE_CHANNEL_NSAGC + 1 ) 
    } 	AEC_SYSTEM_MODE;

typedef struct tagAecQualityMetrics_Struct
    {
    LONGLONG i64Timestamp;
    BYTE ConvergenceFlag;
    BYTE MicClippedFlag;
    BYTE MicSilenceFlag;
    BYTE PstvFeadbackFlag;
    BYTE SpkClippedFlag;
    BYTE SpkMuteFlag;
    BYTE GlitchFlag;
    BYTE DoubleTalkFlag;
    ULONG uGlitchCount;
    ULONG uMicClipCount;
    float fDuration;
    float fTSVariance;
    float fTSDriftRate;
    float fVoiceLevel;
    float fNoiseLevel;
    float fERLE;
    float fAvgERLE;
    DWORD dwReserved;
    } 	AecQualityMetrics_Struct;

typedef 
enum AEC_VAD_MODE
    {	AEC_VAD_DISABLED	= 0,
	AEC_VAD_NORMAL	= ( AEC_VAD_DISABLED + 1 ) ,
	AEC_VAD_FOR_AGC	= ( AEC_VAD_NORMAL + 1 ) ,
	AEC_VAD_FOR_SILENCE_SUPPRESSION	= ( AEC_VAD_FOR_AGC + 1 ) 
    } 	AEC_VAD_MODE;

typedef 
enum AEC_INPUT_STREAM
    {	AEC_CAPTURE_STREAM	= 0,
	AEC_REFERENCE_STREAM	= 1
    } 	AEC_INPUT_STREAM;

typedef 
enum MIC_ARRAY_MODE
    {	MICARRAY_SINGLE_CHAN	= 0,
	MICARRAY_SIMPLE_SUM	= 0x100,
	MICARRAY_SINGLE_BEAM	= 0x200,
	MICARRAY_FIXED_BEAM	= 0x400,
	MICARRAY_EXTERN_BEAM	= 0x800
    } 	MIC_ARRAY_MODE;

#define FACILITY_WMAAECMA  0x7CC
#define WMAAECMA_E_NO_ACTIVE_RENDER_STREAM 0x87CC000A
DEFINE_GUID(MEDIASUBTYPE_Y41T, 0x54313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_Y42T, 0x54323459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
#ifndef MEDIASUBTYPE_NV11_DEFINED
#define MEDIASUBTYPE_NV11_DEFINED
DEFINE_GUID(MEDIASUBTYPE_NV11, 0x3131564E, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
#endif
DEFINE_GUID(MEDIASUBTYPE_V216, 0x36313256, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_V410, 0x30313456, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_v210, 0x30313276, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_I420, 0x30323449, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_WVC1, 0x31435657, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_wvc1, 0x31637677, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_WMVA, 0x41564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_wmva, 0x61766D77, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_WMVB, 0x42564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_wmvb, 0x62766D77, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_WMVR, 0x52564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_wmvr, 0x72766D77, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_WMVP, 0x50564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_wmvp, 0x70766D77, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_WVP2, 0x32505657, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_wvp2, 0x32707677, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_WMV3, 0x33564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_wmv3, 0x33766D77, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_WMV2, 0x32564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_wmv2, 0x32766D77, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_WMV1, 0x31564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_wmv1, 0x31766D77, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_MPG4, 0x3447504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_mpg4, 0x3467706D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_MP42, 0x3234504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_mp42, 0x3234706D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_MP43, 0x3334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_mp43, 0x3334706D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_MP4S, 0x5334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_mp4s, 0x7334706D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_M4S2, 0x3253344D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_m4s2, 0x3273346D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_MSS1, 0x3153534D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_MSS2, 0x3253534D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_MSAUDIO1, 0x00000160, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_WMAUDIO2, 0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_WMAUDIO3, 0x00000162, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_WMAUDIO_LOSSLESS, 0x00000163, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_WMASPDIF, 0x00000164, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_WMAUDIO4, 0x00000168, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_MPEG_ADTS_AAC, 0x00001600, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_MPEG_RAW_AAC,  0x00001601, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_MPEG_LOAS,     0x00001602, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_NOKIA_MPEG_ADTS_AAC, 0x00001608, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_NOKIA_MPEG_RAW_AAC,  0x00001609, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_VODAFONE_MPEG_ADTS_AAC, 0x0000160A, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_VODAFONE_MPEG_RAW_AAC,  0x0000160B, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_MPEG_HEAAC, 0x00001610, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_RAW_AAC1, 0x000000FF, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_DVM, 0x00002000, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_DTS2, 0x00002001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_DOLBY_DDPLUS,  0xa7fb87af, 0x2d02, 0x42fb, 0xa4, 0xd4, 0x5, 0xcd, 0x93, 0x84, 0x3b, 0xdd);
DEFINE_GUID(MEDIASUBTYPE_DOLBY_TRUEHD,  0xeb27cec4, 0x163e, 0x4ca3, 0x8b, 0x74, 0x8e, 0x25, 0xf9, 0x1b, 0x51, 0x7e);
DEFINE_GUID(MEDIASUBTYPE_DTS_HD,        0xa2e58eb7, 0xfa9, 0x48bb, 0xa4, 0xc, 0xfa, 0xe, 0x15, 0x6d, 0x6, 0x45);
DEFINE_GUID(MEDIASUBTYPE_h264,          0x34363268, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_AVC1,          0x31435641, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_X264,          0x34363258, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_x264,          0x34363278, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(CLSID_CTocEntry,            0xF22F5E05,0x585C,0x4def,0x85,0x23,0x65,0x55,0xCF,0xBC,0x0C,0xB3);
DEFINE_GUID(CLSID_CTocEntryList,        0x3A8CCCBC,0x0EFD,0x43a3,0xB8,0x38,0xF3,0x8A,0x55,0x2B,0xA2,0x37);
DEFINE_GUID(CLSID_CToc,                 0x4FE24495,0x28CE,0x4920,0xA4,0xC4,0xE5,0x56,0xE1,0xF0,0xDF,0x2A);
DEFINE_GUID(CLSID_CTocCollection,       0x5058292D,0xA244,0x4840,0xAB,0x44,0x48,0x09,0x75,0xC4,0xFF,0xE4);
DEFINE_GUID(CLSID_CTocParser,           0x499EAEEA,0x2737,0x4849,0x8B,0xB6,0x47,0xF1,0x07,0xEA,0xF3,0x58);
DEFINE_GUID(CLSID_CAsfTocParser,        0x9B77C0F2,0x8735,0x46c5,0xB9,0x0F,0x5F,0x0B,0x30,0x3E,0xF6,0xAB);
DEFINE_GUID(CLSID_CAviTocParser,        0x3ADCE5CC,0x13C8,0x4573,0xB3,0x28,0xED,0x43,0x8E,0xB6,0x94,0xF9);
DEFINE_GUID(CLSID_CFileIo,              0x11993195,0x1244,0x4840,0xAB,0x44,0x48,0x09,0x75,0xC4,0xFF,0xE4);
DEFINE_GUID(CLSID_CFileClient,          0xBFCCD195,0x1244,0x4840,0xAB,0x44,0x48,0x09,0x75,0xC4,0xFF,0xE4);
DEFINE_GUID(CLSID_CClusterDetectorEx,   0x47354492,0x827E,0x4b8a,0xB3,0x18,0xC8,0x0E,0xBA,0x13,0x81,0xF0);
typedef unsigned __int64 QWORD;

#ifndef QWORD
typedef unsigned __int64 QWORD;
#endif //QWORD
#ifndef E_TOCPARSER_INVALIDASFFILE
#define E_TOCPARSER_INVALIDASFFILE      _HRESULT_TYPEDEF_(0x99000001L)
#endif //E_TOCPARSER_INVALIDASFFILE
#ifndef E_TOCPARSER_INVALIDRIFFFILE
#define E_TOCPARSER_INVALIDRIFFFILE     _HRESULT_TYPEDEF_(0x99000002L)
#endif //E_TOCPARSER_INVALIDRIFFFILE
#ifndef TOC_MAX_DESCRIPTION_SIZE
#define TOC_MAX_DESCRIPTION_SIZE        65535
#endif //TOC_MAX_DESCRIPTION_SIZE
#ifndef TOC_ENTRY_MAX_TITLE_SIZE
#define TOC_ENTRY_MAX_TITLE_SIZE        65535
#endif //TOC_ENTRY_MAX_TITLE_SIZE
typedef struct _TOC_DESCRIPTOR
    {
    GUID guidID;
    WORD wStreamNumber;
    GUID guidType;
    WORD wLanguageIndex;
    } 	TOC_DESCRIPTOR;

typedef struct _TOC_ENTRY_DESCRIPTOR
    {
    QWORD qwStartTime;
    QWORD qwEndTime;
    QWORD qwStartPacketOffset;
    QWORD qwEndPacketOffset;
    QWORD qwRepresentativeFrameTime;
    } 	TOC_ENTRY_DESCRIPTOR;


enum TOC_POS_TYPE
    {	TOC_POS_INHEADER	= 0,
	TOC_POS_TOPLEVELOBJECT	= ( TOC_POS_INHEADER + 1 ) 
    } ;


extern RPC_IF_HANDLE __MIDL_itf_wmcodecdsp_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcodecdsp_0000_0017_v0_0_s_ifspec;

#ifndef __ITocEntry_INTERFACE_DEFINED__
#define __ITocEntry_INTERFACE_DEFINED__

/* interface ITocEntry */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_ITocEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F22F5E06-585C-4def-8523-6555CFBC0CB3")
    ITocEntry : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTitle( 
            /* [in] */ LPCWSTR pwszTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitle( 
            /* [out][in] */ WORD *pwTitleSize,
            /* [annotation][size_is][out] */ 
            __out_ecount_opt(*pwTitleSize)  LPWSTR pwszTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescriptor( 
            /* [in] */ TOC_ENTRY_DESCRIPTOR *pDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptor( 
            /* [out] */ TOC_ENTRY_DESCRIPTOR *pDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSubEntries( 
            /* [in] */ DWORD dwNumSubEntries,
            /* [in] */ WORD *pwSubEntryIndices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubEntries( 
            /* [out][in] */ DWORD *pdwNumSubEntries,
            /* [out] */ WORD *pwSubEntryIndices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescriptionData( 
            /* [in] */ DWORD dwDescriptionDataSize,
            /* [in] */ BYTE *pbtDescriptionData,
            /* [in] */ GUID *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionData( 
            /* [out][in] */ DWORD *pdwDescriptionDataSize,
            /* [out] */ BYTE *pbtDescriptionData,
            /* [out] */ GUID *pGuidType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITocEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITocEntry * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITocEntry * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITocEntry * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetTitle )( 
            ITocEntry * This,
            /* [in] */ LPCWSTR pwszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitle )( 
            ITocEntry * This,
            /* [out][in] */ WORD *pwTitleSize,
            /* [annotation][size_is][out] */ 
            __out_ecount_opt(*pwTitleSize)  LPWSTR pwszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescriptor )( 
            ITocEntry * This,
            /* [in] */ TOC_ENTRY_DESCRIPTOR *pDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptor )( 
            ITocEntry * This,
            /* [out] */ TOC_ENTRY_DESCRIPTOR *pDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *SetSubEntries )( 
            ITocEntry * This,
            /* [in] */ DWORD dwNumSubEntries,
            /* [in] */ WORD *pwSubEntryIndices);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubEntries )( 
            ITocEntry * This,
            /* [out][in] */ DWORD *pdwNumSubEntries,
            /* [out] */ WORD *pwSubEntryIndices);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescriptionData )( 
            ITocEntry * This,
            /* [in] */ DWORD dwDescriptionDataSize,
            /* [in] */ BYTE *pbtDescriptionData,
            /* [in] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionData )( 
            ITocEntry * This,
            /* [out][in] */ DWORD *pdwDescriptionDataSize,
            /* [out] */ BYTE *pbtDescriptionData,
            /* [out] */ GUID *pGuidType);
        
        END_INTERFACE
    } ITocEntryVtbl;

    interface ITocEntry
    {
        CONST_VTBL struct ITocEntryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITocEntry_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITocEntry_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITocEntry_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITocEntry_SetTitle(This,pwszTitle)	\
    ( (This)->lpVtbl -> SetTitle(This,pwszTitle) ) 

#define ITocEntry_GetTitle(This,pwTitleSize,pwszTitle)	\
    ( (This)->lpVtbl -> GetTitle(This,pwTitleSize,pwszTitle) ) 

#define ITocEntry_SetDescriptor(This,pDescriptor)	\
    ( (This)->lpVtbl -> SetDescriptor(This,pDescriptor) ) 

#define ITocEntry_GetDescriptor(This,pDescriptor)	\
    ( (This)->lpVtbl -> GetDescriptor(This,pDescriptor) ) 

#define ITocEntry_SetSubEntries(This,dwNumSubEntries,pwSubEntryIndices)	\
    ( (This)->lpVtbl -> SetSubEntries(This,dwNumSubEntries,pwSubEntryIndices) ) 

#define ITocEntry_GetSubEntries(This,pdwNumSubEntries,pwSubEntryIndices)	\
    ( (This)->lpVtbl -> GetSubEntries(This,pdwNumSubEntries,pwSubEntryIndices) ) 

#define ITocEntry_SetDescriptionData(This,dwDescriptionDataSize,pbtDescriptionData,pguidType)	\
    ( (This)->lpVtbl -> SetDescriptionData(This,dwDescriptionDataSize,pbtDescriptionData,pguidType) ) 

#define ITocEntry_GetDescriptionData(This,pdwDescriptionDataSize,pbtDescriptionData,pGuidType)	\
    ( (This)->lpVtbl -> GetDescriptionData(This,pdwDescriptionDataSize,pbtDescriptionData,pGuidType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITocEntry_INTERFACE_DEFINED__ */


#ifndef __ITocEntryList_INTERFACE_DEFINED__
#define __ITocEntryList_INTERFACE_DEFINED__

/* interface ITocEntryList */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_ITocEntryList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3A8CCCBD-0EFD-43a3-B838-F38A552BA237")
    ITocEntryList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEntryCount( 
            /* [out] */ DWORD *pdwEntryCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntryByIndex( 
            /* [in] */ DWORD dwEntryIndex,
            /* [out] */ ITocEntry **ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEntry( 
            /* [in] */ ITocEntry *pEntry,
            /* [out] */ DWORD *pdwEntryIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEntryByIndex( 
            /* [in] */ DWORD dwEntryIndex,
            /* [in] */ ITocEntry *pEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveEntryByIndex( 
            /* [in] */ DWORD dwEntryIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITocEntryListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITocEntryList * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITocEntryList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITocEntryList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEntryCount )( 
            ITocEntryList * This,
            /* [out] */ DWORD *pdwEntryCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetEntryByIndex )( 
            ITocEntryList * This,
            /* [in] */ DWORD dwEntryIndex,
            /* [out] */ ITocEntry **ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE *AddEntry )( 
            ITocEntryList * This,
            /* [in] */ ITocEntry *pEntry,
            /* [out] */ DWORD *pdwEntryIndex);
        
        HRESULT ( STDMETHODCALLTYPE *AddEntryByIndex )( 
            ITocEntryList * This,
            /* [in] */ DWORD dwEntryIndex,
            /* [in] */ ITocEntry *pEntry);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveEntryByIndex )( 
            ITocEntryList * This,
            /* [in] */ DWORD dwEntryIndex);
        
        END_INTERFACE
    } ITocEntryListVtbl;

    interface ITocEntryList
    {
        CONST_VTBL struct ITocEntryListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITocEntryList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITocEntryList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITocEntryList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITocEntryList_GetEntryCount(This,pdwEntryCount)	\
    ( (This)->lpVtbl -> GetEntryCount(This,pdwEntryCount) ) 

#define ITocEntryList_GetEntryByIndex(This,dwEntryIndex,ppEntry)	\
    ( (This)->lpVtbl -> GetEntryByIndex(This,dwEntryIndex,ppEntry) ) 

#define ITocEntryList_AddEntry(This,pEntry,pdwEntryIndex)	\
    ( (This)->lpVtbl -> AddEntry(This,pEntry,pdwEntryIndex) ) 

#define ITocEntryList_AddEntryByIndex(This,dwEntryIndex,pEntry)	\
    ( (This)->lpVtbl -> AddEntryByIndex(This,dwEntryIndex,pEntry) ) 

#define ITocEntryList_RemoveEntryByIndex(This,dwEntryIndex)	\
    ( (This)->lpVtbl -> RemoveEntryByIndex(This,dwEntryIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITocEntryList_INTERFACE_DEFINED__ */


#ifndef __IToc_INTERFACE_DEFINED__
#define __IToc_INTERFACE_DEFINED__

/* interface IToc */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IToc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6F05441-A919-423b-91A0-89D5B4A8AB77")
    IToc : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDescriptor( 
            /* [in] */ TOC_DESCRIPTOR *pDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptor( 
            /* [out] */ TOC_DESCRIPTOR *pDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [in] */ LPCWSTR pwszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out][in] */ WORD *pwDescriptionSize,
            /* [annotation][size_is][out] */ 
            __out_ecount_opt(*pwDescriptionSize)  LPWSTR pwszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ DWORD dwContextSize,
            /* [in] */ BYTE *pbtContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ DWORD *pdwContextSize,
            /* [out] */ BYTE *pbtContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntryListCount( 
            /* [out] */ WORD *pwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntryListByIndex( 
            /* [in] */ WORD wEntryListIndex,
            /* [out] */ ITocEntryList **ppEntryList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEntryList( 
            /* [in] */ ITocEntryList *pEntryList,
            /* [out] */ WORD *pwEntryListIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEntryListByIndex( 
            /* [in] */ WORD wEntryListIndex,
            /* [in] */ ITocEntryList *pEntryList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveEntryListByIndex( 
            /* [in] */ WORD wEntryListIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITocVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IToc * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IToc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IToc * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescriptor )( 
            IToc * This,
            /* [in] */ TOC_DESCRIPTOR *pDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptor )( 
            IToc * This,
            /* [out] */ TOC_DESCRIPTOR *pDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            IToc * This,
            /* [in] */ LPCWSTR pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IToc * This,
            /* [out][in] */ WORD *pwDescriptionSize,
            /* [annotation][size_is][out] */ 
            __out_ecount_opt(*pwDescriptionSize)  LPWSTR pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            IToc * This,
            /* [in] */ DWORD dwContextSize,
            /* [in] */ BYTE *pbtContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IToc * This,
            /* [out][in] */ DWORD *pdwContextSize,
            /* [out] */ BYTE *pbtContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetEntryListCount )( 
            IToc * This,
            /* [out] */ WORD *pwCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetEntryListByIndex )( 
            IToc * This,
            /* [in] */ WORD wEntryListIndex,
            /* [out] */ ITocEntryList **ppEntryList);
        
        HRESULT ( STDMETHODCALLTYPE *AddEntryList )( 
            IToc * This,
            /* [in] */ ITocEntryList *pEntryList,
            /* [out] */ WORD *pwEntryListIndex);
        
        HRESULT ( STDMETHODCALLTYPE *AddEntryListByIndex )( 
            IToc * This,
            /* [in] */ WORD wEntryListIndex,
            /* [in] */ ITocEntryList *pEntryList);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveEntryListByIndex )( 
            IToc * This,
            /* [in] */ WORD wEntryListIndex);
        
        END_INTERFACE
    } ITocVtbl;

    interface IToc
    {
        CONST_VTBL struct ITocVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IToc_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IToc_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IToc_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IToc_SetDescriptor(This,pDescriptor)	\
    ( (This)->lpVtbl -> SetDescriptor(This,pDescriptor) ) 

#define IToc_GetDescriptor(This,pDescriptor)	\
    ( (This)->lpVtbl -> GetDescriptor(This,pDescriptor) ) 

#define IToc_SetDescription(This,pwszDescription)	\
    ( (This)->lpVtbl -> SetDescription(This,pwszDescription) ) 

#define IToc_GetDescription(This,pwDescriptionSize,pwszDescription)	\
    ( (This)->lpVtbl -> GetDescription(This,pwDescriptionSize,pwszDescription) ) 

#define IToc_SetContext(This,dwContextSize,pbtContext)	\
    ( (This)->lpVtbl -> SetContext(This,dwContextSize,pbtContext) ) 

#define IToc_GetContext(This,pdwContextSize,pbtContext)	\
    ( (This)->lpVtbl -> GetContext(This,pdwContextSize,pbtContext) ) 

#define IToc_GetEntryListCount(This,pwCount)	\
    ( (This)->lpVtbl -> GetEntryListCount(This,pwCount) ) 

#define IToc_GetEntryListByIndex(This,wEntryListIndex,ppEntryList)	\
    ( (This)->lpVtbl -> GetEntryListByIndex(This,wEntryListIndex,ppEntryList) ) 

#define IToc_AddEntryList(This,pEntryList,pwEntryListIndex)	\
    ( (This)->lpVtbl -> AddEntryList(This,pEntryList,pwEntryListIndex) ) 

#define IToc_AddEntryListByIndex(This,wEntryListIndex,pEntryList)	\
    ( (This)->lpVtbl -> AddEntryListByIndex(This,wEntryListIndex,pEntryList) ) 

#define IToc_RemoveEntryListByIndex(This,wEntryListIndex)	\
    ( (This)->lpVtbl -> RemoveEntryListByIndex(This,wEntryListIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IToc_INTERFACE_DEFINED__ */


#ifndef __ITocCollection_INTERFACE_DEFINED__
#define __ITocCollection_INTERFACE_DEFINED__

/* interface ITocCollection */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_ITocCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("23fee831-ae96-42df-b170-25a04847a3ca")
    ITocCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEntryCount( 
            /* [out] */ DWORD *pdwEntryCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntryByIndex( 
            /* [in] */ DWORD dwEntryIndex,
            /* [out] */ IToc **ppToc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEntry( 
            /* [in] */ IToc *pToc,
            /* [out] */ DWORD *pdwEntryIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEntryByIndex( 
            /* [in] */ DWORD dwEntryIndex,
            /* [in] */ IToc *pToc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveEntryByIndex( 
            /* [in] */ DWORD dwEntryIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITocCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITocCollection * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITocCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITocCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEntryCount )( 
            ITocCollection * This,
            /* [out] */ DWORD *pdwEntryCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetEntryByIndex )( 
            ITocCollection * This,
            /* [in] */ DWORD dwEntryIndex,
            /* [out] */ IToc **ppToc);
        
        HRESULT ( STDMETHODCALLTYPE *AddEntry )( 
            ITocCollection * This,
            /* [in] */ IToc *pToc,
            /* [out] */ DWORD *pdwEntryIndex);
        
        HRESULT ( STDMETHODCALLTYPE *AddEntryByIndex )( 
            ITocCollection * This,
            /* [in] */ DWORD dwEntryIndex,
            /* [in] */ IToc *pToc);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveEntryByIndex )( 
            ITocCollection * This,
            /* [in] */ DWORD dwEntryIndex);
        
        END_INTERFACE
    } ITocCollectionVtbl;

    interface ITocCollection
    {
        CONST_VTBL struct ITocCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITocCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITocCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITocCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITocCollection_GetEntryCount(This,pdwEntryCount)	\
    ( (This)->lpVtbl -> GetEntryCount(This,pdwEntryCount) ) 

#define ITocCollection_GetEntryByIndex(This,dwEntryIndex,ppToc)	\
    ( (This)->lpVtbl -> GetEntryByIndex(This,dwEntryIndex,ppToc) ) 

#define ITocCollection_AddEntry(This,pToc,pdwEntryIndex)	\
    ( (This)->lpVtbl -> AddEntry(This,pToc,pdwEntryIndex) ) 

#define ITocCollection_AddEntryByIndex(This,dwEntryIndex,pToc)	\
    ( (This)->lpVtbl -> AddEntryByIndex(This,dwEntryIndex,pToc) ) 

#define ITocCollection_RemoveEntryByIndex(This,dwEntryIndex)	\
    ( (This)->lpVtbl -> RemoveEntryByIndex(This,dwEntryIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITocCollection_INTERFACE_DEFINED__ */


#ifndef __ITocParser_INTERFACE_DEFINED__
#define __ITocParser_INTERFACE_DEFINED__

/* interface ITocParser */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_ITocParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ECFB9A55-9298-4f49-887F-0B36206599D2")
    ITocParser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ LPCWSTR pwszFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTocCount( 
            /* [in] */ enum TOC_POS_TYPE enumTocPosType,
            /* [out] */ DWORD *pdwTocCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTocByIndex( 
            /* [in] */ enum TOC_POS_TYPE enumTocPosType,
            /* [in] */ DWORD dwTocIndex,
            /* [out] */ IToc **ppToc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTocByType( 
            /* [in] */ enum TOC_POS_TYPE enumTocPosType,
            /* [in] */ GUID guidTocType,
            /* [out] */ ITocCollection **ppTocs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddToc( 
            /* [in] */ enum TOC_POS_TYPE enumTocPosType,
            /* [in] */ IToc *pToc,
            /* [out] */ DWORD *pdwTocIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveTocByIndex( 
            /* [in] */ enum TOC_POS_TYPE enumTocPosType,
            /* [in] */ DWORD dwTocIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveTocByType( 
            /* [in] */ enum TOC_POS_TYPE enumTocPosType,
            /* [in] */ GUID guidTocType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITocParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITocParser * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITocParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITocParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            ITocParser * This,
            /* [in] */ LPCWSTR pwszFileName);
        
        HRESULT ( STDMETHODCALLTYPE *GetTocCount )( 
            ITocParser * This,
            /* [in] */ enum TOC_POS_TYPE enumTocPosType,
            /* [out] */ DWORD *pdwTocCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetTocByIndex )( 
            ITocParser * This,
            /* [in] */ enum TOC_POS_TYPE enumTocPosType,
            /* [in] */ DWORD dwTocIndex,
            /* [out] */ IToc **ppToc);
        
        HRESULT ( STDMETHODCALLTYPE *GetTocByType )( 
            ITocParser * This,
            /* [in] */ enum TOC_POS_TYPE enumTocPosType,
            /* [in] */ GUID guidTocType,
            /* [out] */ ITocCollection **ppTocs);
        
        HRESULT ( STDMETHODCALLTYPE *AddToc )( 
            ITocParser * This,
            /* [in] */ enum TOC_POS_TYPE enumTocPosType,
            /* [in] */ IToc *pToc,
            /* [out] */ DWORD *pdwTocIndex);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveTocByIndex )( 
            ITocParser * This,
            /* [in] */ enum TOC_POS_TYPE enumTocPosType,
            /* [in] */ DWORD dwTocIndex);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveTocByType )( 
            ITocParser * This,
            /* [in] */ enum TOC_POS_TYPE enumTocPosType,
            /* [in] */ GUID guidTocType);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            ITocParser * This);
        
        END_INTERFACE
    } ITocParserVtbl;

    interface ITocParser
    {
        CONST_VTBL struct ITocParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITocParser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITocParser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITocParser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITocParser_Init(This,pwszFileName)	\
    ( (This)->lpVtbl -> Init(This,pwszFileName) ) 

#define ITocParser_GetTocCount(This,enumTocPosType,pdwTocCount)	\
    ( (This)->lpVtbl -> GetTocCount(This,enumTocPosType,pdwTocCount) ) 

#define ITocParser_GetTocByIndex(This,enumTocPosType,dwTocIndex,ppToc)	\
    ( (This)->lpVtbl -> GetTocByIndex(This,enumTocPosType,dwTocIndex,ppToc) ) 

#define ITocParser_GetTocByType(This,enumTocPosType,guidTocType,ppTocs)	\
    ( (This)->lpVtbl -> GetTocByType(This,enumTocPosType,guidTocType,ppTocs) ) 

#define ITocParser_AddToc(This,enumTocPosType,pToc,pdwTocIndex)	\
    ( (This)->lpVtbl -> AddToc(This,enumTocPosType,pToc,pdwTocIndex) ) 

#define ITocParser_RemoveTocByIndex(This,enumTocPosType,dwTocIndex)	\
    ( (This)->lpVtbl -> RemoveTocByIndex(This,enumTocPosType,dwTocIndex) ) 

#define ITocParser_RemoveTocByType(This,enumTocPosType,guidTocType)	\
    ( (This)->lpVtbl -> RemoveTocByType(This,enumTocPosType,guidTocType) ) 

#define ITocParser_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITocParser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcodecdsp_0000_0022 */
/* [local] */ 


enum FILE_OPENMODE
    {	OPENMODE_FAIL_IF_NOT_EXIST	= 0,
	OPENMODE_FAIL_IF_EXIST	= 1,
	OPENMODE_RESET_IF_EXIST	= 2,
	OPENMODE_APPEND_IF_EXIST	= 3,
	OPENMODE_DELETE_IF_EXIST	= 4
    } ;

enum SEEK_ORIGIN
    {	_msoBegin	= 0,
	_msoCurrent	= 1
    } ;

enum FILE_ACCESSMODE
    {	ACCESSMODE_READ	= 1,
	ACCESSMODE_WRITE	= 2,
	ACCESSMODE_READWRITE	= 3,
	ACCESSMODE_WRITE_EXCLUSIVE	= 4
    } ;


extern RPC_IF_HANDLE __MIDL_itf_wmcodecdsp_0000_0022_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcodecdsp_0000_0022_v0_0_s_ifspec;

#ifndef __IFileIo_INTERFACE_DEFINED__
#define __IFileIo_INTERFACE_DEFINED__

/* interface IFileIo */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IFileIo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11993196-1244-4840-AB44-480975C4FFE4")
    IFileIo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ enum FILE_ACCESSMODE eAccessMode,
            /* [in] */ enum FILE_OPENMODE eOpenMode,
            /* [in] */ LPCWSTR pwszFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ QWORD *pqwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ QWORD qwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentPosition( 
            /* [out] */ QWORD *pqwPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentPosition( 
            /* [in] */ QWORD qwPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEndOfStream( 
            /* [out] */ BOOL *pbEndOfStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [in] */ BYTE *pbt,
            /* [in] */ ULONG ul,
            /* [out] */ ULONG *pulRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ BYTE *pbt,
            /* [in] */ ULONG ul,
            /* [out] */ ULONG *pulWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ enum SEEK_ORIGIN eSeekOrigin,
            /* [in] */ QWORD qwSeekOffset,
            /* [in] */ DWORD dwSeekFlags,
            /* [out] */ QWORD *pqwCurrentPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileIoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileIo * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileIo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileIo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IFileIo * This,
            /* [in] */ enum FILE_ACCESSMODE eAccessMode,
            /* [in] */ enum FILE_OPENMODE eOpenMode,
            /* [in] */ LPCWSTR pwszFileName);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IFileIo * This,
            /* [out] */ QWORD *pqwLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetLength )( 
            IFileIo * This,
            /* [in] */ QWORD qwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPosition )( 
            IFileIo * This,
            /* [out] */ QWORD *pqwPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentPosition )( 
            IFileIo * This,
            /* [in] */ QWORD qwPosition);
        
        HRESULT ( STDMETHODCALLTYPE *IsEndOfStream )( 
            IFileIo * This,
            /* [out] */ BOOL *pbEndOfStream);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IFileIo * This,
            /* [in] */ BYTE *pbt,
            /* [in] */ ULONG ul,
            /* [out] */ ULONG *pulRead);
        
        HRESULT ( STDMETHODCALLTYPE *Write )( 
            IFileIo * This,
            /* [in] */ BYTE *pbt,
            /* [in] */ ULONG ul,
            /* [out] */ ULONG *pulWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IFileIo * This,
            /* [in] */ enum SEEK_ORIGIN eSeekOrigin,
            /* [in] */ QWORD qwSeekOffset,
            /* [in] */ DWORD dwSeekFlags,
            /* [out] */ QWORD *pqwCurrentPosition);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IFileIo * This);
        
        END_INTERFACE
    } IFileIoVtbl;

    interface IFileIo
    {
        CONST_VTBL struct IFileIoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileIo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileIo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileIo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileIo_Initialize(This,eAccessMode,eOpenMode,pwszFileName)	\
    ( (This)->lpVtbl -> Initialize(This,eAccessMode,eOpenMode,pwszFileName) ) 

#define IFileIo_GetLength(This,pqwLength)	\
    ( (This)->lpVtbl -> GetLength(This,pqwLength) ) 

#define IFileIo_SetLength(This,qwLength)	\
    ( (This)->lpVtbl -> SetLength(This,qwLength) ) 

#define IFileIo_GetCurrentPosition(This,pqwPosition)	\
    ( (This)->lpVtbl -> GetCurrentPosition(This,pqwPosition) ) 

#define IFileIo_SetCurrentPosition(This,qwPosition)	\
    ( (This)->lpVtbl -> SetCurrentPosition(This,qwPosition) ) 

#define IFileIo_IsEndOfStream(This,pbEndOfStream)	\
    ( (This)->lpVtbl -> IsEndOfStream(This,pbEndOfStream) ) 

#define IFileIo_Read(This,pbt,ul,pulRead)	\
    ( (This)->lpVtbl -> Read(This,pbt,ul,pulRead) ) 

#define IFileIo_Write(This,pbt,ul,pulWritten)	\
    ( (This)->lpVtbl -> Write(This,pbt,ul,pulWritten) ) 

#define IFileIo_Seek(This,eSeekOrigin,qwSeekOffset,dwSeekFlags,pqwCurrentPosition)	\
    ( (This)->lpVtbl -> Seek(This,eSeekOrigin,qwSeekOffset,dwSeekFlags,pqwCurrentPosition) ) 

#define IFileIo_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileIo_INTERFACE_DEFINED__ */


#ifndef __IFileClient_INTERFACE_DEFINED__
#define __IFileClient_INTERFACE_DEFINED__

/* interface IFileClient */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IFileClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BFCCD196-1244-4840-AB44-480975C4FFE4")
    IFileClient : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObjectDiskSize( 
            /* [out] */ QWORD *pqwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ IFileIo *pFio) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [in] */ IFileIo *pFio) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileClient * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileClient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileClient * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectDiskSize )( 
            IFileClient * This,
            /* [out] */ QWORD *pqwSize);
        
        HRESULT ( STDMETHODCALLTYPE *Write )( 
            IFileClient * This,
            /* [in] */ IFileIo *pFio);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IFileClient * This,
            /* [in] */ IFileIo *pFio);
        
        END_INTERFACE
    } IFileClientVtbl;

    interface IFileClient
    {
        CONST_VTBL struct IFileClientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileClient_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileClient_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileClient_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileClient_GetObjectDiskSize(This,pqwSize)	\
    ( (This)->lpVtbl -> GetObjectDiskSize(This,pqwSize) ) 

#define IFileClient_Write(This,pFio)	\
    ( (This)->lpVtbl -> Write(This,pFio) ) 

#define IFileClient_Read(This,pFio)	\
    ( (This)->lpVtbl -> Read(This,pFio) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileClient_INTERFACE_DEFINED__ */


#ifndef __IClusterDetector_INTERFACE_DEFINED__
#define __IClusterDetector_INTERFACE_DEFINED__

/* interface IClusterDetector */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IClusterDetector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F07F7B7-C680-41d9-9423-915107EC9FF9")
    IClusterDetector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ WORD wBaseEntryLevel,
            /* [in] */ WORD wClusterEntryLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detect( 
            /* [in] */ DWORD dwMaxNumClusters,
            /* [in] */ FLOAT fMinClusterDuration,
            /* [in] */ FLOAT fMaxClusterDuration,
            /* [in] */ IToc *pSrcToc,
            /* [out] */ IToc **ppDstToc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClusterDetectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IClusterDetector * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IClusterDetector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IClusterDetector * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IClusterDetector * This,
            /* [in] */ WORD wBaseEntryLevel,
            /* [in] */ WORD wClusterEntryLevel);
        
        HRESULT ( STDMETHODCALLTYPE *Detect )( 
            IClusterDetector * This,
            /* [in] */ DWORD dwMaxNumClusters,
            /* [in] */ FLOAT fMinClusterDuration,
            /* [in] */ FLOAT fMaxClusterDuration,
            /* [in] */ IToc *pSrcToc,
            /* [out] */ IToc **ppDstToc);
        
        END_INTERFACE
    } IClusterDetectorVtbl;

    interface IClusterDetector
    {
        CONST_VTBL struct IClusterDetectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClusterDetector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IClusterDetector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IClusterDetector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IClusterDetector_Initialize(This,wBaseEntryLevel,wClusterEntryLevel)	\
    ( (This)->lpVtbl -> Initialize(This,wBaseEntryLevel,wClusterEntryLevel) ) 

#define IClusterDetector_Detect(This,dwMaxNumClusters,fMinClusterDuration,fMaxClusterDuration,pSrcToc,ppDstToc)	\
    ( (This)->lpVtbl -> Detect(This,dwMaxNumClusters,fMinClusterDuration,fMaxClusterDuration,pSrcToc,ppDstToc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IClusterDetector_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcodecdsp_0000_0025 */
/* [local] */ 

STDAPI CreateToc(
         /* out */   IToc **ppTableOfContents);
STDAPI CreateTocEntryList(
         /* out */   ITocEntryList **ppTocEntryList);
STDAPI CreateTocEntry(
         /* out */   ITocEntry **ppTocEntry);
STDAPI CreateTocCollection(
         /* out */   ITocCollection **ppTocCollection);
STDAPI CreateTocParser(
         /* out */   ITocParser **ppTocParser);
STDAPI CreateFileIo(
         /* out */   IFileIo **ppFileIo);


extern RPC_IF_HANDLE __MIDL_itf_wmcodecdsp_0000_0025_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcodecdsp_0000_0025_v0_0_s_ifspec;


#ifndef __WMCodecDSPCLSIDTypeLib_LIBRARY_DEFINED__
#define __WMCodecDSPCLSIDTypeLib_LIBRARY_DEFINED__

/* library WMCodecDSPCLSIDTypeLib */
/* [uuid] */ 


EXTERN_C const IID LIBID_WMCodecDSPCLSIDTypeLib;

EXTERN_C const CLSID CLSID_CMpeg4DecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("f371728a-6052-4d47-827c-d039335dfe0a")
CMpeg4DecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CMpeg43DecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("cba9e78b-49a3-49ea-93d4-6bcba8c4de07")
CMpeg43DecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CMpeg4sDecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("2a11bae2-fe6e-4249-864b-9e9ed6e8dbc2")
CMpeg4sDecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CMpeg4sDecMFT;

#ifdef __cplusplus

class DECLSPEC_UUID("5686a0d9-fe39-409f-9dff-3fdbc849f9f5")
CMpeg4sDecMFT;
#endif

EXTERN_C const CLSID CLSID_CZuneM4S2DecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("C56FC25C-0FC6-404a-9503-B10BF51A8AB9")
CZuneM4S2DecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CMpeg4EncMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("24f258d8-c651-4042-93e4-ca654abb682c")
CMpeg4EncMediaObject;
#endif

EXTERN_C const CLSID CLSID_CMpeg4sEncMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("6ec5a7be-d81e-4f9e-ada3-cd1bf262b6d8")
CMpeg4sEncMediaObject;
#endif

EXTERN_C const CLSID CLSID_CMSSCDecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("7bafb3b1-d8f4-4279-9253-27da423108de")
CMSSCDecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CMSSCEncMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("8cb9cc06-d139-4ae6-8bb4-41e612e141d5")
CMSSCEncMediaObject;
#endif

EXTERN_C const CLSID CLSID_CMSSCEncMediaObject2;

#ifdef __cplusplus

class DECLSPEC_UUID("f7ffe0a0-a4f5-44b5-949e-15ed2bc66f9d")
CMSSCEncMediaObject2;
#endif

EXTERN_C const CLSID CLSID_CWMADecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("2eeb4adf-4578-4d10-bca7-bb955f56320a")
CWMADecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CWMAEncMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("70f598e9-f4ab-495a-99e2-a7c4d3d89abf")
CWMAEncMediaObject;
#endif

EXTERN_C const CLSID CLSID_CWMATransMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("edcad9cb-3127-40df-b527-0152ccb3f6f5")
CWMATransMediaObject;
#endif

EXTERN_C const CLSID CLSID_CWMSPDecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("874131cb-4ecc-443b-8948-746b89595d20")
CWMSPDecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CWMSPEncMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("67841b03-c689-4188-ad3f-4c9ebeec710b")
CWMSPEncMediaObject;
#endif

EXTERN_C const CLSID CLSID_CWMSPEncMediaObject2;

#ifdef __cplusplus

class DECLSPEC_UUID("1f1f4e1a-2252-4063-84bb-eee75f8856d5")
CWMSPEncMediaObject2;
#endif

EXTERN_C const CLSID CLSID_CWMTDecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("F9DBC64E-2DD0-45dd-9B52-66642EF94431")
CWMTDecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CWMTEncMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("60B67652-E46B-4e44-8609-F74BFFDC083C")
CWMTEncMediaObject;
#endif

EXTERN_C const CLSID CLSID_CWMVDecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("82d353df-90bd-4382-8bc2-3f6192b76e34")
CWMVDecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CWMVEncMediaObject2;

#ifdef __cplusplus

class DECLSPEC_UUID("96b57cdd-8966-410c-bb1f-c97eea765c04")
CWMVEncMediaObject2;
#endif

EXTERN_C const CLSID CLSID_CWMVXEncMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("7e320092-596a-41b2-bbeb-175d10504eb6")
CWMVXEncMediaObject;
#endif

EXTERN_C const CLSID CLSID_CWMV9EncMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("d23b90d0-144f-46bd-841d-59e4eb19dc59")
CWMV9EncMediaObject;
#endif

EXTERN_C const CLSID CLSID_CWVC1DecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("c9bfbccf-e60e-4588-a3df-5a03b1fd9585")
CWVC1DecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CWVC1EncMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("44653D0D-8CCA-41e7-BACA-884337B747AC")
CWVC1EncMediaObject;
#endif

EXTERN_C const CLSID CLSID_CDeColorConvMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("49034c05-f43c-400f-84c1-90a683195a3a")
CDeColorConvMediaObject;
#endif

EXTERN_C const CLSID CLSID_CDVDecoderMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("e54709c5-1e17-4c8d-94e7-478940433584")
CDVDecoderMediaObject;
#endif

EXTERN_C const CLSID CLSID_CDVEncoderMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("c82ae729-c327-4cce-914d-8171fefebefb")
CDVEncoderMediaObject;
#endif

EXTERN_C const CLSID CLSID_CMpeg2DecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("863d66cd-cdce-4617-b47f-c8929cfc28a6")
CMpeg2DecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CPK_DS_MPEG2Decoder;

#ifdef __cplusplus

class DECLSPEC_UUID("9910c5cd-95c9-4e06-865a-efa1c8016bf4")
CPK_DS_MPEG2Decoder;
#endif

EXTERN_C const CLSID CLSID_CAC3DecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("03d7c802-ecfa-47d9-b268-5fb3e310dee4")
CAC3DecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CPK_DS_AC3Decoder;

#ifdef __cplusplus

class DECLSPEC_UUID("6c9c69d6-0ffc-4481-afdb-cdf1c79c6f3e")
CPK_DS_AC3Decoder;
#endif

EXTERN_C const CLSID CLSID_CMP3DecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("bbeea841-0a63-4f52-a7ab-a9b3a84ed38a")
CMP3DecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CResamplerMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("f447b69e-1884-4a7e-8055-346f74d6edb3")
CResamplerMediaObject;
#endif

EXTERN_C const CLSID CLSID_CResizerMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("d3ec8b8b-7728-4fd8-9fe0-7b67d19f73a3")
CResizerMediaObject;
#endif

EXTERN_C const CLSID CLSID_CInterlaceMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("b5a89c80-4901-407b-9abc-90d9a644bb46")
CInterlaceMediaObject;
#endif

EXTERN_C const CLSID CLSID_CWMAudioLFXAPO;

#ifdef __cplusplus

class DECLSPEC_UUID("62dc1a93-ae24-464c-a43e-452f824c4250")
CWMAudioLFXAPO;
#endif

EXTERN_C const CLSID CLSID_CWMAudioGFXAPO;

#ifdef __cplusplus

class DECLSPEC_UUID("637c490d-eee3-4c0a-973f-371958802da2")
CWMAudioGFXAPO;
#endif

EXTERN_C const CLSID CLSID_CWMAudioSpdTxDMO;

#ifdef __cplusplus

class DECLSPEC_UUID("5210f8e4-b0bb-47c3-a8d9-7b2282cc79ed")
CWMAudioSpdTxDMO;
#endif

EXTERN_C const CLSID CLSID_CWMAudioAEC;

#ifdef __cplusplus

class DECLSPEC_UUID("745057c7-f353-4f2d-a7ee-58434477730e")
CWMAudioAEC;
#endif

EXTERN_C const CLSID CLSID_CClusterDetectorDmo;

#ifdef __cplusplus

class DECLSPEC_UUID("36e820c4-165a-4521-863c-619e1160d4d4")
CClusterDetectorDmo;
#endif

EXTERN_C const CLSID CLSID_CColorControlDmo;

#ifdef __cplusplus

class DECLSPEC_UUID("798059f0-89ca-4160-b325-aeb48efe4f9a")
CColorControlDmo;
#endif

EXTERN_C const CLSID CLSID_CColorConvertDMO;

#ifdef __cplusplus

class DECLSPEC_UUID("98230571-0087-4204-b020-3282538e57d3")
CColorConvertDMO;
#endif

EXTERN_C const CLSID CLSID_CColorLegalizerDmo;

#ifdef __cplusplus

class DECLSPEC_UUID("fdfaa753-e48e-4e33-9c74-98a27fc6726a")
CColorLegalizerDmo;
#endif

EXTERN_C const CLSID CLSID_CFrameInterpDMO;

#ifdef __cplusplus

class DECLSPEC_UUID("0a7cfe1b-6ab5-4334-9ed8-3f97cb37daa1")
CFrameInterpDMO;
#endif

EXTERN_C const CLSID CLSID_CFrameRateConvertDmo;

#ifdef __cplusplus

class DECLSPEC_UUID("01f36ce2-0907-4d8b-979d-f151be91c883")
CFrameRateConvertDmo;
#endif

EXTERN_C const CLSID CLSID_CResizerDMO;

#ifdef __cplusplus

class DECLSPEC_UUID("1ea1ea14-48f4-4054-ad1a-e8aee10ac805")
CResizerDMO;
#endif

EXTERN_C const CLSID CLSID_CShotDetectorDmo;

#ifdef __cplusplus

class DECLSPEC_UUID("56aefacd-110c-4397-9292-b0a0c61b6750")
CShotDetectorDmo;
#endif

EXTERN_C const CLSID CLSID_CSmpteTransformsDmo;

#ifdef __cplusplus

class DECLSPEC_UUID("bde6388b-da25-485d-ba7f-fabc28b20318")
CSmpteTransformsDmo;
#endif

EXTERN_C const CLSID CLSID_CThumbnailGeneratorDmo;

#ifdef __cplusplus

class DECLSPEC_UUID("559c6bad-1ea8-4963-a087-8a6810f9218b")
CThumbnailGeneratorDmo;
#endif

EXTERN_C const CLSID CLSID_CTocGeneratorDmo;

#ifdef __cplusplus

class DECLSPEC_UUID("4dda1941-77a0-4fb1-a518-e2185041d70c")
CTocGeneratorDmo;
#endif

EXTERN_C const CLSID CLSID_CMPEGAACDecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("8DDE1772-EDAD-41c3-B4BE-1F30FB4EE0D6")
CMPEGAACDecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CNokiaAACDecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("3CB2BDE4-4E29-4c44-A73E-2D7C2C46D6EC")
CNokiaAACDecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CVodafoneAACDecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("7F36F942-DCF3-4d82-9289-5B1820278F7C")
CVodafoneAACDecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CZuneAACCCDecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("A74E98F2-52D6-4b4e-885B-E0A6CA4F187A")
CZuneAACCCDecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CNokiaAACCCDecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("EABF7A6F-CCBA-4d60-8620-B152CC977263")
CNokiaAACCCDecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CVodafoneAACCCDecMediaObject;

#ifdef __cplusplus

class DECLSPEC_UUID("7E76BF7F-C993-4e26-8FAB-470A70C0D59C")
CVodafoneAACCCDecMediaObject;
#endif

EXTERN_C const CLSID CLSID_CMPEG2EncoderDS;

#ifdef __cplusplus

class DECLSPEC_UUID("5F5AFF4A-2F7F-4279-88C2-CD88EB39D144")
CMPEG2EncoderDS;
#endif

EXTERN_C const CLSID CLSID_CMPEG2EncoderVideoDS;

#ifdef __cplusplus

class DECLSPEC_UUID("42150cd9-ca9a-4ea5-9939-30ee037f6e74")
CMPEG2EncoderVideoDS;
#endif

EXTERN_C const CLSID CLSID_CMPEG2EncoderAudioDS;

#ifdef __cplusplus

class DECLSPEC_UUID("acd453bc-c58a-44d1-bbf5-bfb325be2d78")
CMPEG2EncoderAudioDS;
#endif

EXTERN_C const CLSID CLSID_CMPEG2AudDecoderDS;

#ifdef __cplusplus

class DECLSPEC_UUID("E1F1A0B8-BEEE-490d-BA7C-066C40B5E2B9")
CMPEG2AudDecoderDS;
#endif

EXTERN_C const CLSID CLSID_CMPEG2VidDecoderDS;

#ifdef __cplusplus

class DECLSPEC_UUID("212690FB-83E5-4526-8FD7-74478B7939CD")
CMPEG2VidDecoderDS;
#endif

EXTERN_C const CLSID CLSID_CDTVAudDecoderDS;

#ifdef __cplusplus

class DECLSPEC_UUID("8E269032-FE03-4753-9B17-18253C21722E")
CDTVAudDecoderDS;
#endif

EXTERN_C const CLSID CLSID_CDTVVidDecoderDS;

#ifdef __cplusplus

class DECLSPEC_UUID("64777DC8-4E24-4beb-9D19-60A35BE1DAAF")
CDTVVidDecoderDS;
#endif

EXTERN_C const CLSID CLSID_CMSAC3Enc;

#ifdef __cplusplus

class DECLSPEC_UUID("C6B400E2-20A7-4e58-A2FE-24619682CE6C")
CMSAC3Enc;
#endif

EXTERN_C const CLSID CLSID_CMSH264DecoderMFT;

#ifdef __cplusplus

class DECLSPEC_UUID("62CE7E72-4C71-4d20-B15D-452831A87D9D")
CMSH264DecoderMFT;
#endif
#endif /* __WMCodecDSPCLSIDTypeLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\wmdrmdeviceapp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0365 */
/* Compiler settings for wmdrmdeviceapp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmdrmdeviceapp_h__
#define __wmdrmdeviceapp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMDRMDeviceApp_FWD_DEFINED__
#define __IWMDRMDeviceApp_FWD_DEFINED__
typedef interface IWMDRMDeviceApp IWMDRMDeviceApp;
#endif 	/* __IWMDRMDeviceApp_FWD_DEFINED__ */


#ifndef __IWMDRMDeviceApp2_FWD_DEFINED__
#define __IWMDRMDeviceApp2_FWD_DEFINED__
typedef interface IWMDRMDeviceApp2 IWMDRMDeviceApp2;
#endif 	/* __IWMDRMDeviceApp2_FWD_DEFINED__ */


#ifndef __WMDRMDeviceApp_FWD_DEFINED__
#define __WMDRMDeviceApp_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMDRMDeviceApp WMDRMDeviceApp;
#else
typedef struct WMDRMDeviceApp WMDRMDeviceApp;
#endif /* __cplusplus */

#endif 	/* __WMDRMDeviceApp_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "wmdm.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wmdrmdeviceapp_0000 */
/* [local] */ 

#include <mswmdm.h>
// WMDRM Device status flags
#define WMDRM_DEVICE_ISWMDRM                 0x00000001L
#define WMDRM_DEVICE_NEEDCLOCK               0x00000002L
#define WMDRM_DEVICE_REVOKED                 0x00000004L
#define WMDRM_CLIENT_NEEDINDIV               0x00000008L
#define WMDRM_DEVICE_REFRESHCLOCK            0x00000010L
// WMDRM Query Device flags
#define WMDRM_QUERY_DEVICE_ISWMDRM           0x00000001L
#define WMDRM_QUERY_DEVICE_CLOCKSTATUS       0x00000002L
#define WMDRM_QUERY_DEVICE_ISREVOKED         0x00000004L
#define WMDRM_QUERY_CLIENT_INDIVSTATUS       0x00000008L
// ProcessMeterResponse flags
#define WMDRM_METER_RESPONSE_ALL             0x00000000L
#define WMDRM_METER_RESPONSE_PARTIAL         0x00000001L


extern RPC_IF_HANDLE __MIDL_itf_wmdrmdeviceapp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmdrmdeviceapp_0000_v0_0_s_ifspec;

#ifndef __IWMDRMDeviceApp_INTERFACE_DEFINED__
#define __IWMDRMDeviceApp_INTERFACE_DEFINED__

/* interface IWMDRMDeviceApp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDRMDeviceApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("93AFDB44-B1E1-411d-B89B-75AD4F97882B")
    IWMDRMDeviceApp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GenerateMeterChallenge( 
            /* [in] */ IWMDMDevice *pDevice,
            /* [in] */ BSTR bstrMeterCert,
            /* [out] */ BSTR *pbstrMeterURL,
            /* [out] */ BSTR *pbstrMeterData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessMeterResponse( 
            /* [in] */ IWMDMDevice *pDevice,
            /* [in] */ BYTE *pbResponse,
            /* [in] */ DWORD cbResponse,
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryDeviceStatus( 
            /* [in] */ IWMDMDevice *pDevice,
            /* [out] */ DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AcquireDeviceData( 
            /* [in] */ IWMDMDevice *pDevice,
            /* [in] */ IWMDMProgress3 *pProgressCallback,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SynchronizeLicenses( 
            /* [in] */ IWMDMDevice *pDevice,
            /* [in] */ IWMDMProgress3 *pProgressCallback,
            /* [in] */ DWORD cMinCountThreshold,
            /* [in] */ DWORD cMinHoursThreshold) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDRMDeviceAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMDRMDeviceApp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMDRMDeviceApp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMDRMDeviceApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateMeterChallenge )( 
            IWMDRMDeviceApp * This,
            /* [in] */ IWMDMDevice *pDevice,
            /* [in] */ BSTR bstrMeterCert,
            /* [out] */ BSTR *pbstrMeterURL,
            /* [out] */ BSTR *pbstrMeterData);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessMeterResponse )( 
            IWMDRMDeviceApp * This,
            /* [in] */ IWMDMDevice *pDevice,
            /* [in] */ BYTE *pbResponse,
            /* [in] */ DWORD cbResponse,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDeviceStatus )( 
            IWMDRMDeviceApp * This,
            /* [in] */ IWMDMDevice *pDevice,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AcquireDeviceData )( 
            IWMDRMDeviceApp * This,
            /* [in] */ IWMDMDevice *pDevice,
            /* [in] */ IWMDMProgress3 *pProgressCallback,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *SynchronizeLicenses )( 
            IWMDRMDeviceApp * This,
            /* [in] */ IWMDMDevice *pDevice,
            /* [in] */ IWMDMProgress3 *pProgressCallback,
            /* [in] */ DWORD cMinCountThreshold,
            /* [in] */ DWORD cMinHoursThreshold);
        
        END_INTERFACE
    } IWMDRMDeviceAppVtbl;

    interface IWMDRMDeviceApp
    {
        CONST_VTBL struct IWMDRMDeviceAppVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDRMDeviceApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDRMDeviceApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDRMDeviceApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDRMDeviceApp_GenerateMeterChallenge(This,pDevice,bstrMeterCert,pbstrMeterURL,pbstrMeterData)	\
    (This)->lpVtbl -> GenerateMeterChallenge(This,pDevice,bstrMeterCert,pbstrMeterURL,pbstrMeterData)

#define IWMDRMDeviceApp_ProcessMeterResponse(This,pDevice,pbResponse,cbResponse,pdwFlags)	\
    (This)->lpVtbl -> ProcessMeterResponse(This,pDevice,pbResponse,cbResponse,pdwFlags)

#define IWMDRMDeviceApp_QueryDeviceStatus(This,pDevice,pdwStatus)	\
    (This)->lpVtbl -> QueryDeviceStatus(This,pDevice,pdwStatus)

#define IWMDRMDeviceApp_AcquireDeviceData(This,pDevice,pProgressCallback,dwFlags,pdwStatus)	\
    (This)->lpVtbl -> AcquireDeviceData(This,pDevice,pProgressCallback,dwFlags,pdwStatus)

#define IWMDRMDeviceApp_SynchronizeLicenses(This,pDevice,pProgressCallback,cMinCountThreshold,cMinHoursThreshold)	\
    (This)->lpVtbl -> SynchronizeLicenses(This,pDevice,pProgressCallback,cMinCountThreshold,cMinHoursThreshold)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDRMDeviceApp_GenerateMeterChallenge_Proxy( 
    IWMDRMDeviceApp * This,
    /* [in] */ IWMDMDevice *pDevice,
    /* [in] */ BSTR bstrMeterCert,
    /* [out] */ BSTR *pbstrMeterURL,
    /* [out] */ BSTR *pbstrMeterData);


void __RPC_STUB IWMDRMDeviceApp_GenerateMeterChallenge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMDeviceApp_ProcessMeterResponse_Proxy( 
    IWMDRMDeviceApp * This,
    /* [in] */ IWMDMDevice *pDevice,
    /* [in] */ BYTE *pbResponse,
    /* [in] */ DWORD cbResponse,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB IWMDRMDeviceApp_ProcessMeterResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMDeviceApp_QueryDeviceStatus_Proxy( 
    IWMDRMDeviceApp * This,
    /* [in] */ IWMDMDevice *pDevice,
    /* [out] */ DWORD *pdwStatus);


void __RPC_STUB IWMDRMDeviceApp_QueryDeviceStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMDeviceApp_AcquireDeviceData_Proxy( 
    IWMDRMDeviceApp * This,
    /* [in] */ IWMDMDevice *pDevice,
    /* [in] */ IWMDMProgress3 *pProgressCallback,
    /* [in] */ DWORD dwFlags,
    /* [out] */ DWORD *pdwStatus);


void __RPC_STUB IWMDRMDeviceApp_AcquireDeviceData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMDeviceApp_SynchronizeLicenses_Proxy( 
    IWMDRMDeviceApp * This,
    /* [in] */ IWMDMDevice *pDevice,
    /* [in] */ IWMDMProgress3 *pProgressCallback,
    /* [in] */ DWORD cMinCountThreshold,
    /* [in] */ DWORD cMinHoursThreshold);


void __RPC_STUB IWMDRMDeviceApp_SynchronizeLicenses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDRMDeviceApp_INTERFACE_DEFINED__ */


#ifndef __IWMDRMDeviceApp2_INTERFACE_DEFINED__
#define __IWMDRMDeviceApp2_INTERFACE_DEFINED__

/* interface IWMDRMDeviceApp2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDRMDeviceApp2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("600D6E55-DEA5-4e4c-9C3A-6BD642A45B9D")
    IWMDRMDeviceApp2 : public IWMDRMDeviceApp
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryDeviceStatus2( 
            /* [in] */ IWMDMDevice *pDevice,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD *pdwStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDRMDeviceApp2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMDRMDeviceApp2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMDRMDeviceApp2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMDRMDeviceApp2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateMeterChallenge )( 
            IWMDRMDeviceApp2 * This,
            /* [in] */ IWMDMDevice *pDevice,
            /* [in] */ BSTR bstrMeterCert,
            /* [out] */ BSTR *pbstrMeterURL,
            /* [out] */ BSTR *pbstrMeterData);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessMeterResponse )( 
            IWMDRMDeviceApp2 * This,
            /* [in] */ IWMDMDevice *pDevice,
            /* [in] */ BYTE *pbResponse,
            /* [in] */ DWORD cbResponse,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDeviceStatus )( 
            IWMDRMDeviceApp2 * This,
            /* [in] */ IWMDMDevice *pDevice,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AcquireDeviceData )( 
            IWMDRMDeviceApp2 * This,
            /* [in] */ IWMDMDevice *pDevice,
            /* [in] */ IWMDMProgress3 *pProgressCallback,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *SynchronizeLicenses )( 
            IWMDRMDeviceApp2 * This,
            /* [in] */ IWMDMDevice *pDevice,
            /* [in] */ IWMDMProgress3 *pProgressCallback,
            /* [in] */ DWORD cMinCountThreshold,
            /* [in] */ DWORD cMinHoursThreshold);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDeviceStatus2 )( 
            IWMDRMDeviceApp2 * This,
            /* [in] */ IWMDMDevice *pDevice,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD *pdwStatus);
        
        END_INTERFACE
    } IWMDRMDeviceApp2Vtbl;

    interface IWMDRMDeviceApp2
    {
        CONST_VTBL struct IWMDRMDeviceApp2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDRMDeviceApp2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDRMDeviceApp2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDRMDeviceApp2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDRMDeviceApp2_GenerateMeterChallenge(This,pDevice,bstrMeterCert,pbstrMeterURL,pbstrMeterData)	\
    (This)->lpVtbl -> GenerateMeterChallenge(This,pDevice,bstrMeterCert,pbstrMeterURL,pbstrMeterData)

#define IWMDRMDeviceApp2_ProcessMeterResponse(This,pDevice,pbResponse,cbResponse,pdwFlags)	\
    (This)->lpVtbl -> ProcessMeterResponse(This,pDevice,pbResponse,cbResponse,pdwFlags)

#define IWMDRMDeviceApp2_QueryDeviceStatus(This,pDevice,pdwStatus)	\
    (This)->lpVtbl -> QueryDeviceStatus(This,pDevice,pdwStatus)

#define IWMDRMDeviceApp2_AcquireDeviceData(This,pDevice,pProgressCallback,dwFlags,pdwStatus)	\
    (This)->lpVtbl -> AcquireDeviceData(This,pDevice,pProgressCallback,dwFlags,pdwStatus)

#define IWMDRMDeviceApp2_SynchronizeLicenses(This,pDevice,pProgressCallback,cMinCountThreshold,cMinHoursThreshold)	\
    (This)->lpVtbl -> SynchronizeLicenses(This,pDevice,pProgressCallback,cMinCountThreshold,cMinHoursThreshold)


#define IWMDRMDeviceApp2_QueryDeviceStatus2(This,pDevice,dwFlags,pdwStatus)	\
    (This)->lpVtbl -> QueryDeviceStatus2(This,pDevice,dwFlags,pdwStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDRMDeviceApp2_QueryDeviceStatus2_Proxy( 
    IWMDRMDeviceApp2 * This,
    /* [in] */ IWMDMDevice *pDevice,
    /* [in] */ DWORD dwFlags,
    /* [out] */ DWORD *pdwStatus);


void __RPC_STUB IWMDRMDeviceApp2_QueryDeviceStatus2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDRMDeviceApp2_INTERFACE_DEFINED__ */



#ifndef __WMDRMDeviceAppLib_LIBRARY_DEFINED__
#define __WMDRMDeviceAppLib_LIBRARY_DEFINED__

/* library WMDRMDeviceAppLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WMDRMDeviceAppLib;

EXTERN_C const CLSID CLSID_WMDRMDeviceApp;

#ifdef __cplusplus

class DECLSPEC_UUID("5C140836-43DE-11d3-847D-00C04F79DBC0")
WMDRMDeviceApp;
#endif
#endif /* __WMDRMDeviceAppLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\wmcontainer.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for wmcontainer.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmcontainer_h__
#define __wmcontainer_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMFASFContentInfo_FWD_DEFINED__
#define __IMFASFContentInfo_FWD_DEFINED__
typedef interface IMFASFContentInfo IMFASFContentInfo;
#endif 	/* __IMFASFContentInfo_FWD_DEFINED__ */


#ifndef __IMFASFProfile_FWD_DEFINED__
#define __IMFASFProfile_FWD_DEFINED__
typedef interface IMFASFProfile IMFASFProfile;
#endif 	/* __IMFASFProfile_FWD_DEFINED__ */


#ifndef __IMFASFStreamConfig_FWD_DEFINED__
#define __IMFASFStreamConfig_FWD_DEFINED__
typedef interface IMFASFStreamConfig IMFASFStreamConfig;
#endif 	/* __IMFASFStreamConfig_FWD_DEFINED__ */


#ifndef __IMFASFMutualExclusion_FWD_DEFINED__
#define __IMFASFMutualExclusion_FWD_DEFINED__
typedef interface IMFASFMutualExclusion IMFASFMutualExclusion;
#endif 	/* __IMFASFMutualExclusion_FWD_DEFINED__ */


#ifndef __IMFASFStreamPrioritization_FWD_DEFINED__
#define __IMFASFStreamPrioritization_FWD_DEFINED__
typedef interface IMFASFStreamPrioritization IMFASFStreamPrioritization;
#endif 	/* __IMFASFStreamPrioritization_FWD_DEFINED__ */


#ifndef __IMFASFSplitter_FWD_DEFINED__
#define __IMFASFSplitter_FWD_DEFINED__
typedef interface IMFASFSplitter IMFASFSplitter;
#endif 	/* __IMFASFSplitter_FWD_DEFINED__ */


#ifndef __IMFASFMultiplexer_FWD_DEFINED__
#define __IMFASFMultiplexer_FWD_DEFINED__
typedef interface IMFASFMultiplexer IMFASFMultiplexer;
#endif 	/* __IMFASFMultiplexer_FWD_DEFINED__ */


#ifndef __IMFASFIndexer_FWD_DEFINED__
#define __IMFASFIndexer_FWD_DEFINED__
typedef interface IMFASFIndexer IMFASFIndexer;
#endif 	/* __IMFASFIndexer_FWD_DEFINED__ */


#ifndef __IMFASFStreamSelector_FWD_DEFINED__
#define __IMFASFStreamSelector_FWD_DEFINED__
typedef interface IMFASFStreamSelector IMFASFStreamSelector;
#endif 	/* __IMFASFStreamSelector_FWD_DEFINED__ */


#ifndef __IMFDRMNetHelper_FWD_DEFINED__
#define __IMFDRMNetHelper_FWD_DEFINED__
typedef interface IMFDRMNetHelper IMFDRMNetHelper;
#endif 	/* __IMFDRMNetHelper_FWD_DEFINED__ */


/* header files for imported files */
#include "mfidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wmcontainer_0000_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0000_v0_0_s_ifspec;

#ifndef __IMFASFContentInfo_INTERFACE_DEFINED__
#define __IMFASFContentInfo_INTERFACE_DEFINED__

/* interface IMFASFContentInfo */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFContentInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1DCA5CD-D5DA-4451-8E9E-DB5C59914EAD")
    IMFASFContentInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetHeaderSize( 
            /* [in] */ IMFMediaBuffer *pIStartOfContent,
            /* [out] */ QWORD *cbHeaderSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseHeader( 
            /* [in] */ IMFMediaBuffer *pIHeaderBuffer,
            /* [in] */ QWORD cbOffsetWithinHeader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateHeader( 
            /* [out][in] */ IMFMediaBuffer *pIHeader,
            /* [out] */ DWORD *pcbHeader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProfile( 
            /* [out] */ IMFASFProfile **ppIProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProfile( 
            /* [in] */ IMFASFProfile *pIProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GeneratePresentationDescriptor( 
            /* [out] */ IMFPresentationDescriptor **ppIPresentationDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEncodingConfigurationPropertyStore( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IPropertyStore **ppIStore) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFContentInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFContentInfo * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFContentInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFContentInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetHeaderSize )( 
            IMFASFContentInfo * This,
            /* [in] */ IMFMediaBuffer *pIStartOfContent,
            /* [out] */ QWORD *cbHeaderSize);
        
        HRESULT ( STDMETHODCALLTYPE *ParseHeader )( 
            IMFASFContentInfo * This,
            /* [in] */ IMFMediaBuffer *pIHeaderBuffer,
            /* [in] */ QWORD cbOffsetWithinHeader);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateHeader )( 
            IMFASFContentInfo * This,
            /* [out][in] */ IMFMediaBuffer *pIHeader,
            /* [out] */ DWORD *pcbHeader);
        
        HRESULT ( STDMETHODCALLTYPE *GetProfile )( 
            IMFASFContentInfo * This,
            /* [out] */ IMFASFProfile **ppIProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetProfile )( 
            IMFASFContentInfo * This,
            /* [in] */ IMFASFProfile *pIProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GeneratePresentationDescriptor )( 
            IMFASFContentInfo * This,
            /* [out] */ IMFPresentationDescriptor **ppIPresentationDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetEncodingConfigurationPropertyStore )( 
            IMFASFContentInfo * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IPropertyStore **ppIStore);
        
        END_INTERFACE
    } IMFASFContentInfoVtbl;

    interface IMFASFContentInfo
    {
        CONST_VTBL struct IMFASFContentInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFContentInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFContentInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFContentInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFContentInfo_GetHeaderSize(This,pIStartOfContent,cbHeaderSize)	\
    ( (This)->lpVtbl -> GetHeaderSize(This,pIStartOfContent,cbHeaderSize) ) 

#define IMFASFContentInfo_ParseHeader(This,pIHeaderBuffer,cbOffsetWithinHeader)	\
    ( (This)->lpVtbl -> ParseHeader(This,pIHeaderBuffer,cbOffsetWithinHeader) ) 

#define IMFASFContentInfo_GenerateHeader(This,pIHeader,pcbHeader)	\
    ( (This)->lpVtbl -> GenerateHeader(This,pIHeader,pcbHeader) ) 

#define IMFASFContentInfo_GetProfile(This,ppIProfile)	\
    ( (This)->lpVtbl -> GetProfile(This,ppIProfile) ) 

#define IMFASFContentInfo_SetProfile(This,pIProfile)	\
    ( (This)->lpVtbl -> SetProfile(This,pIProfile) ) 

#define IMFASFContentInfo_GeneratePresentationDescriptor(This,ppIPresentationDescriptor)	\
    ( (This)->lpVtbl -> GeneratePresentationDescriptor(This,ppIPresentationDescriptor) ) 

#define IMFASFContentInfo_GetEncodingConfigurationPropertyStore(This,wStreamNumber,ppIStore)	\
    ( (This)->lpVtbl -> GetEncodingConfigurationPropertyStore(This,wStreamNumber,ppIStore) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFContentInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcontainer_0000_0001 */
/* [local] */ 

STDAPI MFCreateASFContentInfo( 
        /* out */     IMFASFContentInfo     **ppIContentInfo);
#define MFASF_MIN_HEADER_BYTES ( sizeof( GUID ) + sizeof( QWORD ) )
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_FILE_ID, 0x3de649b4, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_CREATION_TIME, 0x3de649b6, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_PACKETS, 0x3de649b7, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_PLAY_DURATION, 0x3de649b8, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_SEND_DURATION, 0x3de649b9, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_PREROLL, 0x3de649ba, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_FLAGS, 0x3de649bb, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_MIN_PACKET_SIZE, 0x3de649bc, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_MAX_PACKET_SIZE, 0x3de649bd, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_MAX_BITRATE, 0x3de649be, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_CONTENTENCRYPTION_TYPE, 0x8520fe3d, 0x277e, 0x46ea, 0x99, 0xe4, 0xe3, 0xa, 0x86, 0xdb, 0x12, 0xbe);
EXTERN_GUID(MF_PD_ASF_CONTENTENCRYPTION_KEYID, 0x8520fe3e, 0x277e, 0x46ea, 0x99, 0xe4, 0xe3, 0xa, 0x86, 0xdb, 0x12, 0xbe);
EXTERN_GUID(MF_PD_ASF_CONTENTENCRYPTION_SECRET_DATA, 0x8520fe3f, 0x277e, 0x46ea, 0x99, 0xe4, 0xe3, 0xa, 0x86, 0xdb, 0x12, 0xbe);
EXTERN_GUID(MF_PD_ASF_CONTENTENCRYPTION_LICENSE_URL, 0x8520fe40, 0x277e, 0x46ea, 0x99, 0xe4, 0xe3, 0xa, 0x86, 0xdb, 0x12, 0xbe);
EXTERN_GUID( MF_PD_ASF_CONTENTENCRYPTIONEX_ENCRYPTION_DATA, 0x62508be5, 0xecdf, 0x4924, 0xa3, 0x59, 0x72, 0xba, 0xb3, 0x39, 0x7b, 0x9d);
EXTERN_GUID( MF_PD_ASF_LANGLIST, 0xf23de43c, 0x9977, 0x460d, 0xa6, 0xec, 0x32, 0x93, 0x7f, 0x16, 0xf, 0x7d);
#if (WINVER >= _WIN32_WINNT_WIN7) 
EXTERN_GUID( MF_PD_ASF_LANGLIST_LEGACYORDER, 0xf23de43d, 0x9977, 0x460d, 0xa6, 0xec, 0x32, 0x93, 0x7f, 0x16, 0xf, 0x7d);
#endif // (WINVER >= _WIN32_WINNT_WIN7) 
EXTERN_GUID(MF_PD_ASF_MARKER, 0x5134330e, 0x83a6, 0x475e, 0xa9, 0xd5, 0x4f, 0xb8, 0x75, 0xfb, 0x2e, 0x31);
EXTERN_GUID( MF_PD_ASF_SCRIPT, 0xe29cd0d7, 0xd602, 0x4923, 0xa7, 0xfe, 0x73, 0xfd, 0x97, 0xec, 0xc6, 0x50);
EXTERN_GUID(MF_PD_ASF_CODECLIST, 0xe4bb3509, 0xc18d, 0x4df1, 0xbb, 0x99, 0x7a, 0x36, 0xb3, 0xcc, 0x41, 0x19);
EXTERN_GUID( MF_PD_ASF_METADATA_IS_VBR, 0x5fc6947a, 0xef60, 0x445d, 0xb4, 0x49, 0x44, 0x2e, 0xcc, 0x78, 0xb4, 0xc1);
EXTERN_GUID( MF_PD_ASF_METADATA_V8_VBRPEAK, 0x5fc6947b, 0xef60, 0x445d, 0xb4, 0x49, 0x44, 0x2e, 0xcc, 0x78, 0xb4, 0xc1);
EXTERN_GUID( MF_PD_ASF_METADATA_V8_BUFFERAVERAGE, 0x5fc6947c, 0xef60, 0x445d, 0xb4, 0x49, 0x44, 0x2e, 0xcc, 0x78, 0xb4, 0xc1);
EXTERN_GUID( MF_PD_ASF_METADATA_LEAKY_BUCKET_PAIRS, 0x5fc6947d, 0xef60, 0x445d, 0xb4, 0x49, 0x44, 0x2e, 0xcc, 0x78, 0xb4, 0xc1);
EXTERN_GUID(MF_PD_ASF_DATA_START_OFFSET, 0xe7d5b3e7, 0x1f29, 0x45d3, 0x88, 0x22, 0x3e, 0x78, 0xfa, 0xe2, 0x72, 0xed);
EXTERN_GUID(MF_PD_ASF_DATA_LENGTH, 0xe7d5b3e8, 0x1f29, 0x45d3, 0x88, 0x22, 0x3e, 0x78, 0xfa, 0xe2, 0x72, 0xed);
EXTERN_GUID(MF_SD_ASF_EXTSTRMPROP_LANGUAGE_ID_INDEX, 0x48f8a522, 0x305d, 0x422d, 0x85, 0x24, 0x25, 0x2, 0xdd, 0xa3, 0x36, 0x80);
EXTERN_GUID(MF_SD_ASF_EXTSTRMPROP_AVG_DATA_BITRATE, 0x48f8a523, 0x305d, 0x422d, 0x85, 0x24, 0x25, 0x2, 0xdd, 0xa3, 0x36, 0x80);
EXTERN_GUID(MF_SD_ASF_EXTSTRMPROP_AVG_BUFFERSIZE, 0x48f8a524, 0x305d, 0x422d, 0x85, 0x24, 0x25, 0x2, 0xdd, 0xa3, 0x36, 0x80);
EXTERN_GUID(MF_SD_ASF_EXTSTRMPROP_MAX_DATA_BITRATE, 0x48f8a525, 0x305d, 0x422d, 0x85, 0x24, 0x25, 0x2, 0xdd, 0xa3, 0x36, 0x80);
EXTERN_GUID(MF_SD_ASF_EXTSTRMPROP_MAX_BUFFERSIZE, 0x48f8a526, 0x305d, 0x422d, 0x85, 0x24, 0x25, 0x2, 0xdd, 0xa3, 0x36, 0x80);
EXTERN_GUID(MF_SD_ASF_STREAMBITRATES_BITRATE, 0xa8e182ed, 0xafc8, 0x43d0, 0xb0, 0xd1, 0xf6, 0x5b, 0xad, 0x9d, 0xa5, 0x58);
EXTERN_GUID(MF_SD_ASF_METADATA_DEVICE_CONFORMANCE_TEMPLATE, 0x245e929d, 0xc44e, 0x4f7e, 0xbb, 0x3c, 0x77, 0xd4, 0xdf, 0xd2, 0x7f, 0x8a);
EXTERN_GUID(MF_PD_ASF_INFO_HAS_AUDIO, 0x80e62295, 0x2296, 0x4a44, 0xb3, 0x1c, 0xd1, 0x3, 0xc6, 0xfe, 0xd2, 0x3c);
EXTERN_GUID(MF_PD_ASF_INFO_HAS_VIDEO, 0x80e62296, 0x2296, 0x4a44, 0xb3, 0x1c, 0xd1, 0x3, 0xc6, 0xfe, 0xd2, 0x3c);
EXTERN_GUID(MF_PD_ASF_INFO_HAS_NON_AUDIO_VIDEO, 0x80e62297, 0x2296, 0x4a44, 0xb3, 0x1c, 0xd1, 0x3, 0xc6, 0xfe, 0xd2, 0x3c);





extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0001_v0_0_s_ifspec;

#ifndef __IMFASFProfile_INTERFACE_DEFINED__
#define __IMFASFProfile_INTERFACE_DEFINED__

/* interface IMFASFProfile */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D267BF6A-028B-4e0d-903D-43F0EF82D0D4")
    IMFASFProfile : public IMFAttributes
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamCount( 
            /* [out] */ DWORD *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ WORD *pwStreamNumber,
            /* [out] */ IMFASFStreamConfig **ppIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamByNumber( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IMFASFStreamConfig **ppIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStream( 
            /* [in] */ IMFASFStreamConfig *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ WORD wStreamNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [in] */ IMFMediaType *pIMediaType,
            /* [out] */ IMFASFStreamConfig **ppIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusionCount( 
            /* [out] */ DWORD *pcMutexs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusion( 
            /* [in] */ DWORD dwMutexIndex,
            /* [out] */ IMFASFMutualExclusion **ppIMutex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMutualExclusion( 
            /* [in] */ IMFASFMutualExclusion *pIMutex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMutualExclusion( 
            /* [in] */ DWORD dwMutexIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateMutualExclusion( 
            /* [out] */ IMFASFMutualExclusion **ppIMutex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamPrioritization( 
            /* [out] */ IMFASFStreamPrioritization **ppIStreamPrioritization) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStreamPrioritization( 
            /* [in] */ IMFASFStreamPrioritization *pIStreamPrioritization) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamPrioritization( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStreamPrioritization( 
            /* [out] */ IMFASFStreamPrioritization **ppIStreamPrioritization) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IMFASFProfile **ppIProfile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFProfile * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFProfile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFASFProfile * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFASFProfile * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFASFProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFASFProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFASFProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFASFProfile * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFASFProfile * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFASFProfile * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCount )( 
            IMFASFProfile * This,
            /* [out] */ DWORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IMFASFProfile * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ WORD *pwStreamNumber,
            /* [out] */ IMFASFStreamConfig **ppIStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamByNumber )( 
            IMFASFProfile * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IMFASFStreamConfig **ppIStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetStream )( 
            IMFASFProfile * This,
            /* [in] */ IMFASFStreamConfig *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IMFASFProfile * This,
            /* [in] */ WORD wStreamNumber);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStream )( 
            IMFASFProfile * This,
            /* [in] */ IMFMediaType *pIMediaType,
            /* [out] */ IMFASFStreamConfig **ppIStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetMutualExclusionCount )( 
            IMFASFProfile * This,
            /* [out] */ DWORD *pcMutexs);
        
        HRESULT ( STDMETHODCALLTYPE *GetMutualExclusion )( 
            IMFASFProfile * This,
            /* [in] */ DWORD dwMutexIndex,
            /* [out] */ IMFASFMutualExclusion **ppIMutex);
        
        HRESULT ( STDMETHODCALLTYPE *AddMutualExclusion )( 
            IMFASFProfile * This,
            /* [in] */ IMFASFMutualExclusion *pIMutex);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMutualExclusion )( 
            IMFASFProfile * This,
            /* [in] */ DWORD dwMutexIndex);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMutualExclusion )( 
            IMFASFProfile * This,
            /* [out] */ IMFASFMutualExclusion **ppIMutex);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamPrioritization )( 
            IMFASFProfile * This,
            /* [out] */ IMFASFStreamPrioritization **ppIStreamPrioritization);
        
        HRESULT ( STDMETHODCALLTYPE *AddStreamPrioritization )( 
            IMFASFProfile * This,
            /* [in] */ IMFASFStreamPrioritization *pIStreamPrioritization);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStreamPrioritization )( 
            IMFASFProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStreamPrioritization )( 
            IMFASFProfile * This,
            /* [out] */ IMFASFStreamPrioritization **ppIStreamPrioritization);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IMFASFProfile * This,
            /* [out] */ IMFASFProfile **ppIProfile);
        
        END_INTERFACE
    } IMFASFProfileVtbl;

    interface IMFASFProfile
    {
        CONST_VTBL struct IMFASFProfileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFProfile_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFProfile_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFProfile_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFProfile_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFASFProfile_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFASFProfile_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFASFProfile_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFASFProfile_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFASFProfile_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFASFProfile_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFASFProfile_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFASFProfile_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFASFProfile_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFASFProfile_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFASFProfile_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFASFProfile_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFASFProfile_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFASFProfile_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFASFProfile_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFASFProfile_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFASFProfile_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFASFProfile_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFASFProfile_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFASFProfile_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFASFProfile_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFASFProfile_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFASFProfile_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFASFProfile_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFASFProfile_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFASFProfile_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFASFProfile_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFASFProfile_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFASFProfile_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFASFProfile_GetStreamCount(This,pcStreams)	\
    ( (This)->lpVtbl -> GetStreamCount(This,pcStreams) ) 

#define IMFASFProfile_GetStream(This,dwStreamIndex,pwStreamNumber,ppIStream)	\
    ( (This)->lpVtbl -> GetStream(This,dwStreamIndex,pwStreamNumber,ppIStream) ) 

#define IMFASFProfile_GetStreamByNumber(This,wStreamNumber,ppIStream)	\
    ( (This)->lpVtbl -> GetStreamByNumber(This,wStreamNumber,ppIStream) ) 

#define IMFASFProfile_SetStream(This,pIStream)	\
    ( (This)->lpVtbl -> SetStream(This,pIStream) ) 

#define IMFASFProfile_RemoveStream(This,wStreamNumber)	\
    ( (This)->lpVtbl -> RemoveStream(This,wStreamNumber) ) 

#define IMFASFProfile_CreateStream(This,pIMediaType,ppIStream)	\
    ( (This)->lpVtbl -> CreateStream(This,pIMediaType,ppIStream) ) 

#define IMFASFProfile_GetMutualExclusionCount(This,pcMutexs)	\
    ( (This)->lpVtbl -> GetMutualExclusionCount(This,pcMutexs) ) 

#define IMFASFProfile_GetMutualExclusion(This,dwMutexIndex,ppIMutex)	\
    ( (This)->lpVtbl -> GetMutualExclusion(This,dwMutexIndex,ppIMutex) ) 

#define IMFASFProfile_AddMutualExclusion(This,pIMutex)	\
    ( (This)->lpVtbl -> AddMutualExclusion(This,pIMutex) ) 

#define IMFASFProfile_RemoveMutualExclusion(This,dwMutexIndex)	\
    ( (This)->lpVtbl -> RemoveMutualExclusion(This,dwMutexIndex) ) 

#define IMFASFProfile_CreateMutualExclusion(This,ppIMutex)	\
    ( (This)->lpVtbl -> CreateMutualExclusion(This,ppIMutex) ) 

#define IMFASFProfile_GetStreamPrioritization(This,ppIStreamPrioritization)	\
    ( (This)->lpVtbl -> GetStreamPrioritization(This,ppIStreamPrioritization) ) 

#define IMFASFProfile_AddStreamPrioritization(This,pIStreamPrioritization)	\
    ( (This)->lpVtbl -> AddStreamPrioritization(This,pIStreamPrioritization) ) 

#define IMFASFProfile_RemoveStreamPrioritization(This)	\
    ( (This)->lpVtbl -> RemoveStreamPrioritization(This) ) 

#define IMFASFProfile_CreateStreamPrioritization(This,ppIStreamPrioritization)	\
    ( (This)->lpVtbl -> CreateStreamPrioritization(This,ppIStreamPrioritization) ) 

#define IMFASFProfile_Clone(This,ppIProfile)	\
    ( (This)->lpVtbl -> Clone(This,ppIProfile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFProfile_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcontainer_0000_0002 */
/* [local] */ 

EXTERN_GUID(MF_ASFPROFILE_MINPACKETSIZE, 0x22587626, 0x47de, 0x4168, 0x87, 0xf5, 0xb5, 0xaa, 0x9b, 0x12, 0xa8, 0xf0);
EXTERN_GUID(MF_ASFPROFILE_MAXPACKETSIZE, 0x22587627, 0x47de, 0x4168, 0x87, 0xf5, 0xb5, 0xaa, 0x9b, 0x12, 0xa8, 0xf0);
STDAPI MFCreateASFProfile( 
        /* out */     IMFASFProfile         **ppIProfile);
STDAPI MFCreateASFProfileFromPresentationDescriptor( 
        /* in  */     IMFPresentationDescriptor  *pIPD,
        /* out */     IMFASFProfile             **ppIProfile);
STDAPI MFCreatePresentationDescriptorFromASFProfile( 
        /* in  */     IMFASFProfile              *pIProfile,
        /* out */     IMFPresentationDescriptor **ppIPD);


extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0002_v0_0_s_ifspec;

#ifndef __IMFASFStreamConfig_INTERFACE_DEFINED__
#define __IMFASFStreamConfig_INTERFACE_DEFINED__

/* interface IMFASFStreamConfig */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFStreamConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9E8AE8D2-DBBD-4200-9ACA-06E6DF484913")
    IMFASFStreamConfig : public IMFAttributes
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamType( 
            /* [out] */ GUID *pguidStreamType) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetStreamNumber( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamNumber( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            /* [out] */ IMFMediaType **ppIMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            /* [in] */ IMFMediaType *pIMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPayloadExtensionCount( 
            /* [out] */ WORD *pcPayloadExtensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPayloadExtension( 
            /* [in] */ WORD wPayloadExtensionNumber,
            /* [out] */ GUID *pguidExtensionSystemID,
            /* [out] */ WORD *pcbExtensionDataSize,
            /* [size_is][optional][out] */ BYTE *pbExtensionSystemInfo,
            /* [optional][out][in] */ DWORD *pcbExtensionSystemInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPayloadExtension( 
            /* [in] */ GUID guidExtensionSystemID,
            /* [in] */ WORD cbExtensionDataSize,
            /* [size_is][in] */ BYTE *pbExtensionSystemInfo,
            /* [in] */ DWORD cbExtensionSystemInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllPayloadExtensions( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IMFASFStreamConfig **ppIStreamConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFStreamConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFStreamConfig * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFStreamConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFASFStreamConfig * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFASFStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFASFStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFASFStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFASFStreamConfig * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFASFStreamConfig * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFASFStreamConfig * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamType )( 
            IMFASFStreamConfig * This,
            /* [out] */ GUID *pguidStreamType);
        
        WORD ( STDMETHODCALLTYPE *GetStreamNumber )( 
            IMFASFStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamNumber )( 
            IMFASFStreamConfig * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IMFASFStreamConfig * This,
            /* [out] */ IMFMediaType **ppIMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IMFASFStreamConfig * This,
            /* [in] */ IMFMediaType *pIMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPayloadExtensionCount )( 
            IMFASFStreamConfig * This,
            /* [out] */ WORD *pcPayloadExtensions);
        
        HRESULT ( STDMETHODCALLTYPE *GetPayloadExtension )( 
            IMFASFStreamConfig * This,
            /* [in] */ WORD wPayloadExtensionNumber,
            /* [out] */ GUID *pguidExtensionSystemID,
            /* [out] */ WORD *pcbExtensionDataSize,
            /* [size_is][optional][out] */ BYTE *pbExtensionSystemInfo,
            /* [optional][out][in] */ DWORD *pcbExtensionSystemInfo);
        
        HRESULT ( STDMETHODCALLTYPE *AddPayloadExtension )( 
            IMFASFStreamConfig * This,
            /* [in] */ GUID guidExtensionSystemID,
            /* [in] */ WORD cbExtensionDataSize,
            /* [size_is][in] */ BYTE *pbExtensionSystemInfo,
            /* [in] */ DWORD cbExtensionSystemInfo);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllPayloadExtensions )( 
            IMFASFStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IMFASFStreamConfig * This,
            /* [out] */ IMFASFStreamConfig **ppIStreamConfig);
        
        END_INTERFACE
    } IMFASFStreamConfigVtbl;

    interface IMFASFStreamConfig
    {
        CONST_VTBL struct IMFASFStreamConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFStreamConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFStreamConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFStreamConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFStreamConfig_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFASFStreamConfig_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFASFStreamConfig_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFASFStreamConfig_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFASFStreamConfig_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFASFStreamConfig_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFASFStreamConfig_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFASFStreamConfig_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFASFStreamConfig_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFASFStreamConfig_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFASFStreamConfig_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFASFStreamConfig_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFASFStreamConfig_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFASFStreamConfig_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFASFStreamConfig_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFASFStreamConfig_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFASFStreamConfig_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFASFStreamConfig_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFASFStreamConfig_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFASFStreamConfig_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFASFStreamConfig_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFASFStreamConfig_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFASFStreamConfig_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFASFStreamConfig_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFASFStreamConfig_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFASFStreamConfig_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFASFStreamConfig_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFASFStreamConfig_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFASFStreamConfig_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFASFStreamConfig_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFASFStreamConfig_GetStreamType(This,pguidStreamType)	\
    ( (This)->lpVtbl -> GetStreamType(This,pguidStreamType) ) 

#define IMFASFStreamConfig_GetStreamNumber(This)	\
    ( (This)->lpVtbl -> GetStreamNumber(This) ) 

#define IMFASFStreamConfig_SetStreamNumber(This,wStreamNum)	\
    ( (This)->lpVtbl -> SetStreamNumber(This,wStreamNum) ) 

#define IMFASFStreamConfig_GetMediaType(This,ppIMediaType)	\
    ( (This)->lpVtbl -> GetMediaType(This,ppIMediaType) ) 

#define IMFASFStreamConfig_SetMediaType(This,pIMediaType)	\
    ( (This)->lpVtbl -> SetMediaType(This,pIMediaType) ) 

#define IMFASFStreamConfig_GetPayloadExtensionCount(This,pcPayloadExtensions)	\
    ( (This)->lpVtbl -> GetPayloadExtensionCount(This,pcPayloadExtensions) ) 

#define IMFASFStreamConfig_GetPayloadExtension(This,wPayloadExtensionNumber,pguidExtensionSystemID,pcbExtensionDataSize,pbExtensionSystemInfo,pcbExtensionSystemInfo)	\
    ( (This)->lpVtbl -> GetPayloadExtension(This,wPayloadExtensionNumber,pguidExtensionSystemID,pcbExtensionDataSize,pbExtensionSystemInfo,pcbExtensionSystemInfo) ) 

#define IMFASFStreamConfig_AddPayloadExtension(This,guidExtensionSystemID,cbExtensionDataSize,pbExtensionSystemInfo,cbExtensionSystemInfo)	\
    ( (This)->lpVtbl -> AddPayloadExtension(This,guidExtensionSystemID,cbExtensionDataSize,pbExtensionSystemInfo,cbExtensionSystemInfo) ) 

#define IMFASFStreamConfig_RemoveAllPayloadExtensions(This)	\
    ( (This)->lpVtbl -> RemoveAllPayloadExtensions(This) ) 

#define IMFASFStreamConfig_Clone(This,ppIStreamConfig)	\
    ( (This)->lpVtbl -> Clone(This,ppIStreamConfig) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFStreamConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcontainer_0000_0003 */
/* [local] */ 

EXTERN_GUID(MF_ASFSTREAMCONFIG_LEAKYBUCKET1, 0xc69b5901, 0xea1a, 0x4c9b, 0xb6, 0x92, 0xe2, 0xa0, 0xd2, 0x9a, 0x8a, 0xdd);
EXTERN_GUID(MF_ASFSTREAMCONFIG_LEAKYBUCKET2, 0xc69b5902, 0xea1a, 0x4c9b, 0xb6, 0x92, 0xe2, 0xa0, 0xd2, 0x9a, 0x8a, 0xdd);
EXTERN_GUID(MFASFSampleExtension_SampleDuration, 0xc6bd9450, 0x867f, 0x4907, 0x83, 0xa3, 0xc7, 0x79, 0x21, 0xb7, 0x33, 0xad);
EXTERN_GUID(MFASFSampleExtension_OutputCleanPoint, 0xf72a3c6f, 0x6eb4, 0x4ebc, 0xb1, 0x92, 0x9, 0xad, 0x97, 0x59, 0xe8, 0x28);
EXTERN_GUID(MFASFSampleExtension_SMPTE, 0x399595ec, 0x8667, 0x4e2d, 0x8f, 0xdb, 0x98, 0x81, 0x4c, 0xe7, 0x6c, 0x1e);
EXTERN_GUID(MFASFSampleExtension_FileName, 0xe165ec0e, 0x19ed, 0x45d7, 0xb4, 0xa7, 0x25, 0xcb, 0xd1, 0xe2, 0x8e, 0x9b);
EXTERN_GUID(MFASFSampleExtension_ContentType, 0xd590dc20, 0x07bc, 0x436c, 0x9c, 0xf7, 0xf3, 0xbb, 0xfb, 0xf1, 0xa4, 0xdc);
EXTERN_GUID(MFASFSampleExtension_PixelAspectRatio, 0x1b1ee554, 0xf9ea, 0x4bc8, 0x82, 0x1a, 0x37, 0x6b, 0x74, 0xe4, 0xc4, 0xb8);
EXTERN_GUID(MFASFSampleExtension_Encryption_SampleID, 0x6698B84E, 0x0AFA, 0x4330, 0xAE, 0xB2, 0x1C, 0x0A, 0x98, 0xD7, 0xA4, 0x4D);
EXTERN_GUID(MFASFSampleExtension_Encryption_KeyID, 0x76376591,  0x795f,  0x4da1, 0x86, 0xed, 0x9d, 0x46, 0xec, 0xa1, 0x09, 0xa9);


extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0003_v0_0_s_ifspec;

#ifndef __IMFASFMutualExclusion_INTERFACE_DEFINED__
#define __IMFASFMutualExclusion_INTERFACE_DEFINED__

/* interface IMFASFMutualExclusion */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFMutualExclusion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12558291-E399-11D5-BC2A-00B0D0F3F4AB")
    IMFASFMutualExclusion : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetType( 
            /* [in] */ REFGUID guidType) = 0;
        
        virtual HR